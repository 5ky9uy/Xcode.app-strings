uouarneglppa
xfuayledlppa
cfuairavlppa
xfua2bvrlppa
cfuaptunlppa
St11logic_error
St9exception
NSt3__117bad_function_callE
St13runtime_error
St12out_of_range
St12length_error
A11CAException
xmuamed3lppa
mcpl)
MbP?
@St8bad_cast
xfuatsidlppa
xmuaxmcmlppa
yE>w
xmualpsmlppa
xfuaqebnlppa
Mb@?
?mcpl
uouacoirlppa
xfuagpsdlppa
ngualpsslppa
St9bad_alloc
initWithImpl:
isInManualRenderingMode
manualRenderingMode
resetImpl:
initWithIOUnit:isInput:
presentationLatency
audioUnit
didAttachToEngine:
didDetachFromEngine:
enableManualRenderingMode:isInput:
enableRealtimeRenderingModeWithIOUnit:isInput:
manualRenderingFormat
isEqual:
manualRenderingMaximumFrameCount
outputFormatForBus:
setManualRenderingPCMFormat:maximumFrameCount:
engine
implementation
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
setPan:
renderingAlgorithm
setRenderingAlgorithm:
rate
setRate:
reverbBlend
setReverbBlend:
obstruction
setObstruction:
occlusion
setOcclusion:
position
setPosition:
destinationForMixer:bus:
volume
setVolume:
setManualRenderingInputPCMFormat:inputBlock:
raise:format:arguments:
init
dealloc
node
alloc
initWithNode:bus:
connectionPointWithNode:bus:
_node
_bus
_reserved
objectForKey:
unsignedIntegerValue
doubleValue
sharedInstance
sampleRate
inputNumberOfChannels
count
dictionaryWithDictionary:
regularExpressionWithPattern:options:error:
length
firstMatchInString:options:range:
range
substringWithRange:
whitespaceAndNewlineCharacterSet
stringByTrimmingCharactersInSet:
initWithInt:
initWithString:
isEqualToDataSource:
privateGetOwningPortID
isEqualToNumber:
dataSourceID
dataSourceName
isEqualToString:
orientation
selectedPolarPattern
stringWithFormat:
numberWithUnsignedInt:
dictionaryWithObjectsAndKeys:
errorWithDomain:code:userInfo:
arrayWithObject:
isEqualToValue:
privateGetImplementation
configurePolarPatterns:
arrayWithCapacity:
countByEnumeratingWithState:objects:count:
addObject:
initWithArray:
initWithCapacity:
objectAtIndex:
initWithRawSourceDescription:andOwningPortID:andSessionID:
insertObject:atIndex:
privateCreateArray:portID:sessionID:
initWithSessionID:
location
preferredPolarPattern
supportedPolarPatterns
setPreferredPolarPattern:error:
privateMatchesRawDescription:
_impl
unsignedIntValue
compare:
recordRoute
impl
initWithUUIDString:
initWithVoiceController:
isRemoteDevice
remoteProductIdentifier
remoteDeviceUID
_isRemoteDevice
_recordRoute
_remoteProductIdentifier
_remoteDeviceUID
defaultCenter
handleInterruption:
addObserver:selector:name:object:
handleRouteChange:
handleMediaServerDeath:
handleMediaServerReset:
removeObserver:name:object:
voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
userInfo
unsignedLongValue
voiceControllerMediaServicesWereLost:
voiceControllerMediaServicesWereReset:
objectForKeyedSubscript:
voiceControllerDidStartRecording:successfully:error:
initWithDomain:code:userInfo:
voiceControllerDidStartRecording:successfully:
initWithAudioQueueBuffer:channels:timeStamp:
voiceControllerLPCMRecordBufferAvailable:buffer:
voiceControllerRecordBufferAvailable:buffer:
audioBufferList
voiceControllerDidStopRecording:forReason:
voiceControllerDidDetectStartpoint:
voiceControllerDidDetectEndpoint:ofType:atTime:
voiceControllerDidDetectEndpoint:ofType:
voiceControllerEncoderErrorDidOccur:error:
voiceControllerDidStartPlaying:successfully:
voiceControllerPlaybackBufferAvailable:buffer:
voiceControllerDidStopPlaying:forReason:
voiceControllerDecoderErrorDidOccur:error:
voiceControllerDidFinishAlertPlayback:ofType:error:
voiceControllerBeginRecordInterruption:
voiceControllerBeginRecordInterruption:withContext:
voiceControllerEndRecordInterruption:
voiceControllerBeginPlaybackInterruption:
voiceControllerEndPlaybackInterruption:
voiceControllerWillSetAudioSessionActive:willActivate:
voiceControllerDidSetAudioSessionActive:isActivated:
setSessionNotifications
removeSessionNotifications
hardwareConfigChanged
handlePluginDidPublishDevice:
handlePluginDidUnpublishDevice:
beganRecording
lpcmRecordBufferReceived:atTime:
avAudioPCMRecordBufferListReceived:numChannels:atTime:
avAudioPCMRecordBufferReceived:atTime:
recordBufferReceived:atTime:
lpcmRecordBufferForNonLPCMReceived:atTime:
finishedRecording
startpointDetected
interspeechPointDetected
endpointDetected
encodeError
beganPlaying
playbackBufferReceived:
finishedPlaying
decodeError
alertPlaybackFinishedOfType:
beginRecordInterruption
beginRecordInterruptionWithContext:
endRecordInterruption
beginPlaybackInterruption
endPlaybackInterruption
beginAudioSessionActivate:
endAudioSessionActivate:
copy
initWithStreamDescription:
sendRemoteConnectionMessage:
playbackRoute
lastRecordStartTime
voiceTriggerInfo
isBargeInDetectEnabled
setBargeInDetectEnabled:
isStopOnBargeInEnabled
setStopOnBargeInEnabled:
isSynchronousCallbackEnabled
setSynchronousCallbackEnabled:
pcmRecordBufferFormat
setDuckOthersOption:
duckOthersOption
numberOfChannels
playAlertSoundForType:overrideMode:
setupPluginNotifications
removePluginNotifications
finalize
intValue
playAlertSoundForType:
setupAlertBehavior:
doStartRecordingAtTime:behavior:
unsignedLongLongValue
absoluteString
reset
getStatus:count:
setEndpointMode:
setStartWaitTime:
setInterspeechWaitTime:
setEndWaitTime:
isRecording
sharedManager
retrieveMetrics
initWithContext:error:
prewarmAudioSession
releaseAudioSession
releaseAudioSession:
willAcceptContext:
IsDeviceAvailableInLocalRoute:error:
setCurrentContext:error:
prepareRecordWithSettings:error:
setAlertSoundFromURL:forType:
resetEndpointer
playRecordStartingAlertAndResetEndpointer
startRecording
startRecording:
startRecordingAtTime:error:
startRecordingWithSettings:error:
stopRecording
preparePlaybackWithSettings:error:
preparePlaybackFromURL:error:
startPlaying
stopPlaying
recordDelegate
setRecordDelegate:
recordSettings
getRecordBufferDuration
setRecordBufferDuration:
endpointerDelegate
setEndpointerDelegate:
recordEndpointMode
setRecordEndpointMode:
recordStartWaitTime
setRecordStartWaitTime:
recordInterspeechWaitTime
setRecordInterspeechWaitTime:
recordEndWaitTime
setRecordEndWaitTime:
playbackDelegate
setPlaybackDelegate:
playbackSettings
getPlaybackBufferDuration
setPlaybackBufferDuration:
isPlaying
setAlertVolume:
alertVolume
getAlertStartTime
setPlaybackVolume:
playbackVolume
isMeteringEnabled
setMeteringEnabled:
updateMeters
peakPowerForChannel:
averagePowerForChannel:
isStopOnEndpointEnabled
setStopOnEndpointEnabled:
metrics
currentRecordDeviceInfo
alertStartTime
_alertStartTime
stringWithString:
rangeOfString:
substringToIndex:
whitespaceCharacterSet
substringFromIndex:
GetTypeName:
typeName
URLWithString:
arrayWithArray:
setWithArray:
isSubsetOfSet:
allObjects
postNotificationName:object:
array
dictionary
numberWithInteger:
configurationDictionary
containsObject:
audioComponentDescription
initWithComponentDescription:
initWithComponentDescription:withAVAUManagerImpl:
localeChanged
audioComponent
name
localizedTypeName
manufacturerName
versionString
iconURL
userTagNames
setUserTagNames:
allTagNames
componentURL
availableArchitectures
version
hasCustomView
passesAUVal
isSandboxSafe
hasMIDIInput
hasMIDIOutput
supportsNumberInputChannels:outputChannels:
isComponentDescriptionMatch:
getStatus:
endpointMode
startWaitTime
interspeechWaitTime
endWaitTime
configureWithSampleRate:andFrameRate:
configureWithASBD:andFrameRate:
mStartWaitTime
mInterspeechWaitTime
mEndWaitTime
mEndpointMode
mFrameRate
mLastStatus
initWithAudioComponentDescription:
bypass
setBypass:
isEqualToRoute:
inputs
isEqualToArray:
outputs
initWithPortType:
initWithObjects:
privateCreateArray:owningSession:
initWithCategory:
initWithRawDescription:owningSession:
siriRemoteInputIdentifier
unionSet:
arrayWithObjects:count:
allocWithZone:
sharedAudioUnitComponentManager
localeChanged:
filteredArrayUsingPredicate:
privateAllocInitSingleton
copyWithZone:
tagNames
standardLocalizedTagNames
componentsMatchingPredicate:
componentsPassingTest:
componentsMatchingDescription:
setValue:forParam:
valueForParam:
setWetDryMix:
setDelayTime:
setFeedback:
setLowPassCutoff:
wetDryMix
delayTime
feedback
lowPassCutoff
allBundles:
bundleWithURL:
principalClass
initWithPluginDelegate:
invalidate
devices
defaultManager
URLsForDirectory:inDomains:
objectAtIndexedSubscript:
URLByAppendingPathComponent:
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
deviceIdentifier
inputPlugin:didPublishDevice:
inputPlugin:didUnpublishDevice:
initializePlugins
invalidatePlugins
findDeviceWithIdentifier:
setPluginRecordingEngine:
plugins
mPluginRecordingEngine
code
setAudioInputBlock:
startRecordingWithCompletionBlock:
stopRecordingWithCompletionBlock:
audioInputBlock
supportedFormats
streamDescription
setFormat:
format
packetCount
audioTimeStamp
getBytes:range:
data
packetDescriptions
remoteInputDeviceName
dictionaryWithObject:forKey:
postNotificationName:object:userInfo:
loadFactoryPreset:
setPitch:
setOverlap:
pitch
overlap
_delegate
_data
_url
_actualSettings
_format
_playRetain
_channelAssignments
_audioSession
_localPlayer
_gcd
stop
audioPlayerDidFinishPlaying:successfully:
boolValue
audioPlayerDecodeErrorDidOccur:error:
audioPlayerBeginInterruption:
audioPlayerEndInterruption:withOptions:
audioPlayerEndInterruption:withFlags:
audioPlayerEndInterruption:
initBase
finishedPlaying:
decodeError:
beginInterruption
endInterruptionWithFlags:
endInterruption
initWithData:fileTypeHint:error:
initWithContentsOfURL:fileTypeHint:error:
owningPortUID
channelNumber
opaqueSessionID
initWithData:error:
initWithContentsOfURL:error:
prepareToPlay
play
playAtTime:
pause
delegate
setDelegate:
settings
duration
setVolume:fadeDuration:
setEnableRate:
enableRate
currentTime
deviceCurrentTime
setCurrentTime:
setNumberOfLoops:
numberOfLoops
channelAssignments
setChannelAssignments:
audioSession
setAudioSession:
mixToUplink
setMixToUplink:
currentDevice
setCurrentDevice:
_currentDevice
performSelectorOnMainThread:withObject:waitUntilDone:
numberWithUnsignedLongLong:
initWithUnsignedInt:
initWithBool:
initWithUnsignedInteger:
initWithDouble:
initWithLength:
mutableBytes
initWithObjects:forKeys:count:
initWithSettings:
UTF8String
setObject:forKey:
audioRecorderDidFinishRecording:successfully:
privRemoveSessionPropertyListeners
privCommonCleanup
initWithURL:settings:error:
baseInit
path
pathExtension
removeItemAtPath:error:
audioRecorderBeginInterruption:
audioRecorderEndInterruption:withOptions:
audioRecorderEndInterruption:withFlags:
audioRecorderEndInterruption:
setActive:error:
endInterruptionWithFlags
initWithURL:format:error:
prepareToRecord
record
recordAtTime:
recordForDuration:
recordAtTime:forDuration:
deleteRecording
setProcessToTap:
processToTap
instantaneousMetering
setInstantaneousMetering:
bytes
sessionType
setMusicSequence:
stringWithUTF8String:
host
populateFloat32StdVector:withFloatValuesFromNSArray:
VAD3ConfigurationFromHost
createNSMutableArrayFromStdVectorOfUInt32:
populateUInt32StdVector:withUnsignedIntValuesFromNSArray:
numberWithDouble:
objCType
numberWithFloat:
floatValue
numberWithUnsignedLong:
handleVADEventOfType:andOfCategoryNum:havingTimeStamp:andHavingValue:
setupAudioUnitWithAPListFilename:anAudioBufferSizeMilliseconds:aRealtimeOperationMode:aDecoderLatencyInSecs:anEndpointerInterspeechWaitTimeSec:aSmoothingWindowMinSpeechSec:aSmoothingWindowMinNonspeechSec:
processAudioFileNamed:andSaveInOutputObsFeatFilename:andSaveInOutputULDATFeatFilename:andSaveInOutputULDATAudioFilename:andSaveInOutputASAFeatFilename:andSaveInOutputASAAudioFilename:accordingToEPFilenamePrefix:accordingToRawStateFilenamePrefix:accordingToPostDistFilenamePrefix:
processAudioBufferList:ofMaximumCapacity:containingPayloadOf:
resetTimerToZero
decodeOffline
resetAudioUnit
registerAUForOSXDevelopment
tearDownAudioUnit
audioFormat
convertToAVVADStateValueThisEDLDecision:
printToConsoleEventType:AVVADStateValue:eventTimeStampSeconds:categoryName:callToAUTime:
openAudioFile:
maximumSamplesPerBuffer
printAndLogMessage:
numberFramesInAudioFile:
saveToEndpointerEventLogThis:ofCategoryNum:withTimeStamp:withCallToAUTime:
saveToRecurrentEventLogThis:ofCategoryNum:withTimeStamp:withCallToAUTime:
saveToRawStatesLogThis:ofCategoryNum:withTimeStamp:
saveToPosteriorDistributionsLogThisMarginalPosterior:ofCategoryNum:withTimeStamp:
VADConfigurationIsInitialized
numCategories
categoryNameWhichCorrespondToCategoryNum:
numCategoryValuesFromCategoryNum:
categoryValueNameForCategoryNum:categoryValue:
timingModelOrderForCategoryNum:
categoryDimensions
timingDimensions
interleavedCategoryAndTimingDimensions
fullCategoryDimension
fullTimingDimension
fullInterleavedDimension
encodeStateAndTimingValuesInterleaved:
decodeStateAndTimingInterleaved:fullCode:
encodeStateAndTimingDeinterleaved:timingValues:
decodeStateAndTimingDeinterleaved:timingValues:fullCode:
encodeState:
decodeState:
encodeTiming:
decodeTiming:
encodeFullWithStateCode:timingCode:
decodeFullWithStateCode:timingCode:fullCode:
createNSMutableArrayFromStdVectorOfFloat64:
populateFloat64StdVector:withDoubleValuesFromNSArray:
createNSMutableArrayFromStdVectorOfFloat32:
isInterleaved
channelCount
initWithPCMFormat:frameCapacity:
frameCapacity
setFrameLength:
mutableAudioBufferList
frameLength
timeWithAudioTimeStamp:sampleRate:
isEqualToChannel:
channelName
privateCreate:portUID:channelNumber:
privateCreateArray:portUID:
channelLabel
initWithLayout:
layout
layoutTag
initWithLayoutTag:
layoutSize
encodeBytes:length:
decodeBytesWithReturnedLength:
layoutWithLayoutTag:
layoutWithLayout:
supportsSecureCoding
encodeWithCoder:
initWithCoder:
_layoutTag
_layout
initStandardFormatWithSampleRate:channels:
arrayWithObjects:
initWithEnvironment:
initWithCommonFormat:sampleRate:interleaved:channelLayout:
initWithServiceName:
setConnection:
connection
startWithSequence:completion:
cancel
interfaceWithProtocol:
setRemoteObjectInterface:
remoteObjectInterface
setWithObjects:
setClasses:forSelector:argumentIndex:ofReply:
localizedDescription
remoteObjectProxyWithErrorHandler:
setServiceDelegateAsync:
synchronousRemoteObjectProxyWithErrorHandler:
setServiceDelegateSync:
setInterruptionHandler:
setInvalidationHandler:
resume
serviceDelegateSync
serviceDelegateAsync
.cxx_destruct
_connection
_serviceDelegateAsync
_serviceDelegateSync
channelLayout
magicCookie
setMagicCookie:
initFromFormat:toFormat:
inputFormat
outputFormat
dither
downmix
setDither:
setDownmix:
sampleRateConverterQuality
setSampleRateConverterQuality:
sampleRateConverterAlgorithm
setSampleRateConverterAlgorithm:
channelMap
setChannelMap:
maximumOutputPacketSize
primeMethod
setPrimeMethod:
primeInfo
setPrimeInfo:
convertToBuffer:fromBuffer:error:
convertToBuffer:error:withInputFromBlock:
bitRate
setBitRate:
bitRateStrategy
setBitRateStrategy:
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
initWithBytes:length:
initWithObjects:count:
integerValue
byteCapacity
setByteLength:
packetCapacity
setPacketCount:
getLock
setPublicMetrics:
publicMetrics
numberWithInt:
dictionaryWithObjects:forKeys:count:
setAvvcProfilingInfoDictionary:
setVoiceTriggerStartHostTime:
setCallToStartRecordHostTime:
localTimeZone
setTimeZone:
setDateFormat:
stringFromDate:
avvcProfilingInfoDictionary
removeAllObjects
timeIntervalSinceDate:
getStringDate:
enumerateKeysAndObjectsUsingBlock:
date
createSharedManager
destroySharedManager
resetProfileMetrics
retrieveProfileMetrics
measureElapseTimeForMetric:block:
setAudioIssueDetectorFormat:numFrames:
audioIssueDetectorAnalyzeBuffer:numFrames:timeStamp:
resetAudioIssueDetector
logRecordAudioFormat:
logRecordRoute:andPlaybackRoute:
logProfileMetrics:
voiceTriggerStartHostTime
callToStartRecordHostTime
_voiceTriggerStartHostTime
_callToStartRecordHostTime
_publicMetrics
_avvcProfilingInfoDictionary
renderBlock
FillOutAUPreset:
setPreGain:
preGain
setOutputVolume:
outputVolume
setInputVolume:bus:
setInputPan:bus:
inputConnected:
nextAvailableInputBus
initWithNode:
currentAudioTimeStamp
currentIONumberFrames
awaitIOCycle:
destroyBase
initWithContentsOfURL:soundBankURL:error:
initWithData:soundBankURL:error:
hostTimeForBeats:
beatsForHostTime:
play:
currentPosition
setCurrentPosition:
startNote:withVelocity:onChannel:
stopNote:onChannel:
sendController:withValue:onChannel:
sendPitchBend:onChannel:
sendPressure:onChannel:
sendPressureForKey:withValue:onChannel:
sendProgramChange:onChannel:
sendProgramChange:bankMSB:bankLSB:onChannel:
sendMIDIEvent:data1:data2:
sendMIDIEvent:data1:
sendMIDISysExEvent:
byteLength
mutableCopyWithZone:
initWithFormat:byteCapacity:
_initChannelPtrs
appendDataFromBuffer:channel:
calculatePower:
floatChannelData
stride
calculatePower:forFloatData:stride:frameLength:
int16ChannelData
int32ChannelData
appendDataFromBuffer:
splitIntoSingleChannelBuffers
averagePowerPerChannel
peakPowerPerChannel
initWithFormat:packetCapacity:maximumPacketSize:
initWithFormat:packetCapacity:
maximumPacketSize
setFilterType:
filterType
setFrequency:
frequency
setBandwidth:
bandwidth
setGain:
gain
initWithNumberOfBands:
bands
globalGain
setGlobalGain:
initWithStreamDescription:channelLayout:
settingsFromASBD:channelLayout:
numberWithUnsignedInteger:
setValue:forKey:
dataWithBytes:length:
encodeDouble:forKey:
encodeInteger:forKey:
encodeObject:forKey:
decodeDoubleForKey:
decodeIntegerForKey:
decodeObjectOfClass:forKey:
formatWithInvalidSampleRateAndChannelCount
initStandardFormatWithSampleRate:channelLayout:
initWithCommonFormat:sampleRate:channels:interleaved:
initWithCMAudioFormatDescription:
formatDescription
isStandard
commonFormat
_asbd
_commonFormat
initWithData:inputID:outputID:
inputID
setInputID:
outputID
setOutputID:
_inputID
_outputID
encodeFloat:forKey:
decodeFloatForKey:
stimulusURL
setStimulusURL:
inputProcessingChain
setInputProcessingChain:
outputProcessingChain
setOutputProcessingChain:
outputMode
setOutputMode:
_volume
_stimulusURL
_inputProcessingChain
_outputProcessingChain
_outputMode
graphURL
setGraphURL:
processingStripURL
setProcessingStripURL:
_graphURL
_processingStripURL
language
identifier
quality
setLanguage:
setIdentifier:
setName:
setQuality:
initialize
speechVoices
currentLanguageCode
voiceWithLanguage:
voiceWithIdentifier:
voice
speechString
attributedSpeechString
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
setVoice:
setSpeechString:
setAttributedSpeechString:
setPitchMultiplier:
setPreUtteranceDelay:
setPostUtteranceDelay:
speechUtteranceWithString:
speechUtteranceWithAttributedString:
initWithAttributedString:
_voice
_rate
_pitchMultiplier
_speechString
_attributedSpeechString
_preUtteranceDelay
_postUtteranceDelay
speakUtterance:
stopSpeakingAtBoundary:
pauseSpeakingAtBoundary:
continueSpeaking
isSpeaking
isPaused
outputChannels
setOutputChannels:
_speaking
_paused
_outputChannels
stringByAppendingString:
bundleWithPath:
isLoaded
loadAndReturnError:
isPrimary
channels
bytesCapacity
bytesDataSize
setBytesDataSize:
packetDescriptionCapacity
packetDescriptionCount
setPacketDescriptions:count:
timeStamp
remoteVoiceActivityRMS
remoteVoiceActivityVAD
setDistanceAttenuationModel:
distanceAttenuationModel
setMaximumDistance:
maximumDistance
setReferenceDistance:
referenceDistance
setRolloffFactor:
rolloffFactor
setEnable:
enable
setLevel:
level
filterParameters
loadFactoryReverbPreset:
applicableRenderingAlgorithms
setListenerPosition:
listenerPosition
setListenerVectorOrientation:
listenerVectorOrientation
setListenerAngularOrientation:
listenerAngularOrientation
distanceAttenuationParameters
reverbParameters
setCategory:withOptions:error:
setCategory:mode:options:error:
clearInputPreferences:
category
mode
categoryOptions
setIAmTheAssistant:error:
setPreferredSampleRate:error:
fileURLWithPath:
setAudioHardwareControlFlags:error:
setPreferredIOBufferFrameSize:error:
preferredIOBufferFrameSize
currentRoute
setActivationContext:error:
setActive:withOptions:error:
portType
outputLatency
inputLatency
speechDetectionDeviceSampleRate
voiceControllerEndInterruption:
privateInputIsAvailableChanged:
privateInterruptionWithInfo:
initWithFloat:
privateUpdateInputGain:
privateUpdateOutputVolume:
privateUpdatePromptStyle:
privateUpdateAudioFormats:
privateHandlePickableRoutesChange
privateHandleServerDied
privateUpdateInputChannelCount:
privateUpdateOutputChannelCount:
privateHandleSecondaryAudioHintChange:
privateUpdatePiPAvailabilityChange:
privateHandleRoutingContextChange
privateMarkKVOPropertiesDirty:
privateHandleServerConnectionCompletion:
initWithSessionType:
privateNeedsTranslationForNoSpeakerCategory:
privateSetPropertyValue:withBool:error:
setCategory:error:
privateSetOptions:forCategory:error:
setMode:error:
privateSetRouteSharingPolicy:error:
setPreferredDataSource:error:
dataSources
selectedDataSource
privateGetDataSources:
privateGetSelectedDataSource:
portName
isInputAvailable
outputNumberOfChannels
preferredSampleRate
inputIsAvailableChanged:
initWithObjectsAndKeys:
retrieveSessionWithID:
primarySession
auxiliarySession
initAuxiliarySession
routeSharingPolicy
availableCategories
setCategory:mode:routeSharingPolicy:options:error:
activateWithOptions:completionHandler:
deactivateAndSetInterruptionPriority:error:
setActive:withFlags:error:
recordPermission
requestRecordPermission:
setPreferredIOBufferDuration:error:
setInterruptionPriority:error:
setPreferredInputNumberOfChannels:error:
setPreferredOutputNumberOfChannels:error:
setInputGain:error:
setInputDataSource:error:
setOutputDataSource:error:
promptStyle
audioFormats
isDolbyDigitalEncoderAvailable
isEarpieceActiveNoiseCancelationEnabled
isPiPAvailable
forceSoundCheck
setForceSoundCheck:error:
lastActivationStoppedNowPlayingApp
allowAllBuiltInDataSources
setAllowAllBuiltInDataSources:
setBypassRingerSwitchPolicy:error:
isHardwareFormatFixedToMultiChannel
fixHardwareFormatToMultiChannel:error:
inputGain
inputDataSources
inputDataSource
outputDataSources
outputDataSource
isInputGainSettable
isOtherAudioPlaying
secondaryAudioShouldBeSilencedHint
inputSafetyOffset
outputSafetyOffset
activeSessionDisplayIDs
IOBufferDuration
IOBufferFrameSize
interruptionPriority
preferredIOBufferDuration
preferredInputNumberOfChannels
preferredOutputNumberOfChannels
maximumInputNumberOfChannels
maximumOutputNumberOfChannels
availableModes
privateSetRoutingContextUID:error:
routingContextUID
selectIndependentRoutingContext:
overrideOutputAudioPort:error:
setPreferredInput:error:
preferredInput
setAudioClockDevice:error:
audioClockDevice
availableInputs
privateRefreshAvailableInputs
setPreferredHardwareSampleRate:error:
setDisallowedPorts:error:
silenceOutput:error:
setDefaultChatMode:error:
inputIsAvailable
currentHardwareSampleRate
currentHardwareInputNumberOfChannels
currentHardwareOutputNumberOfChannels
preferredHardwareSampleRate
preferDecoupledIO:error:
setAggregatedIOPreference:error:
decoupledIO
setPreferredInputSampleRate:error:
preferredInputSampleRate
setPreferredOutputSampleRate:error:
preferredOutputSampleRate
inputSampleRate
outputSampleRate
setSpeakerThermalGain:error:
setHapticThermalGain:error:
speakerThermalGain
hapticThermalGain
privateUpdateDataSources:forInput:
privateUpdateAudioFormat:
isDolbyAtmosAvailable
firstObject
willChangeValueForKey:
didChangeValueForKey:
exceptionWithName:reason:userInfo:
initForReading:commonFormat:interleaved:error:
initForWriting:settings:commonFormat:interleaved:error:
readIntoBuffer:frameCount:error:
initForReading:error:
initForWriting:settings:error:
initSecondaryReader:format:error:
readIntoBuffer:error:
writeFromBuffer:error:
fileFormat
processingFormat
framePosition
setFramePosition:
isEqualToPort:compareStrict:
configureChannelsAndDataSources:
addObjectsFromArray:
initWithRawPortDescription:owningSession:
initWithSession:
hasHardwareVoiceCallProcessing
isLiveListenSupported
isHeadphones
endpointType
preferredDataSource
privateGetID
setOutputFormat:forBus:
inputFormatForBus:
setInputFormat:forBus:
nameForInputBus:
nameForOutputBus:
clock
lastRenderTime
latency
outputPresentationLatency
numberOfInputs
numberOfOutputs
setNumberOfInputs:
setNumberOfOutputs:
installTapOnBus:bufferSize:format:block:
removeTapOnBus:
AUAudioUnit
connectionPoint
parameterTree
caseInsensitiveCompare:
loadInstrumentAtURL:error:
loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:
loadAudioFilesAtURLs:error:
stereoPan
masterGain
globalTuning
setStereoPan:
setMasterGain:
setGlobalTuning:
currentPositionInSeconds
setCurrentPositionInSeconds:
currentPositionInBeats
setCurrentPositionInBeats:
hostTimeForBeats:error:
beatsForHostTime:error:
startAndReturnError:
cleanTracks
setTempoTrack:
setTrackArray:
trackArray
setupTrackArray
numberOfTracks
setupTracks
tempoTrack
initWithAudioEngine:
loadFromURL:options:error:
loadFromData:options:error:
writeToURL:SMPTEResolution:replaceExisting:error:
dataWithSMPTEResolution:error:
tracks
getTempoTrack
secondsForBeats:
beatsForSeconds:
index
track
setDestinationAudioUnit:
destinationAudioUnit
setDestinationMIDIEndpoint:
destinationMIDIEndpoint
loopRange
setLoopRange:
isLoopingEnabled
setLoopingEnabled:
offsetTime
setOffsetTime:
isMuted
setMuted:
isSoloed
setSoloed:
usesAutomatedParameters
setUsesAutomatedParameters:
lengthInBeats
setLengthInBeats:
lengthInSeconds
setLengthInSeconds:
timeResolution
initWithHostTime:
initWithSampleTime:atRate:
initWithHostTime:sampleTime:atRate:
initWithAudioTimeStamp:sampleRate:
secondsForHostTime:
timeWithHostTime:
timeWithSampleTime:atRate:
timeWithHostTime:sampleTime:atRate:
hostTimeForSeconds:
isHostTimeValid
isSampleTimeValid
hostTime
sampleTime
extrapolateTimeFromAnchor:
_ats
_sampleRate
loadAudioDSPManager
relativePath
dictionaryWithContentsOfURL:error:
loadDSPGraphAtURL:error:
loadAudioUnitProcessingStripAtURL:error:
dspGraphURL
auProcessingStripURL
scheduleBuffer:atTime:options:completionHandler:
scheduleBuffer:atTime:options:completionCallbackType:completionHandler:
callLegacyCompletionHandlerForType:legacyHandler:
scheduleFile:atTime:completionCallbackType:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:
scheduleBuffer:completionHandler:
scheduleBuffer:completionCallbackType:completionHandler:
scheduleFile:atTime:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionHandler:
prepareWithFrameCount:
nodeTimeForPlayerTime:
playerTimeForNodeTime:
initWithKeyOptions:valueOptions:capacity:
anyObject
removeObject:
enableVoiceTriggerListening:completionBlock:
updateVoiceTriggerConfiguration:completionBlock:
voiceTriggerServerConnection
voiceTriggerPastDataFramesAvailable
enableVoiceTriggerListening:
enableSpeakerStateListening:
speakerStateActive
speakerStateMuted
updateVoiceTriggerConfiguration:
voiceTriggerNotification:
speakerStateChangedNotification:
speakerMuteStateChangedNotification:
voiceTriggerBlock
setVoiceTriggerBlock:
speakerStateChangedBlock
setSpeakerStateChangedBlock:
speakerMuteStateChangedBlock
setSpeakerMuteStateChangedBlock:
serverCrashedBlock
setServerCrashedBlock:
serverResetBlock
setServerResetBlock:
_voiceTriggerBlock
_speakerStateChangedBlock
_speakerMuteStateChangedBlock
_serverCrashedBlock
_serverResetBlock
dictionaryWithContentsOfURL:
componentsSeparatedByString:
instantiateWithComponentDescription:options:completionHandler:
loadAudioUnitPresetAtURL:error:
attachNode:
detachNode:
outputNode
inputNode
mainMixerNode
connect:to:fromBus:toBus:format:
connect:to:format:
connect:toConnectionPoints:fromBus:format:
disconnectNodeInput:bus:
disconnectNodeOutput:bus:
disconnectNodeInput:
disconnectNodeOutput:
prepare
inputConnectionPointForNode:inputBus:
outputConnectionPointsForNode:outputBus:
musicSequence
isRunning
isAutoShutdownEnabled
setAutoShutdownEnabled:
manualRenderingSampleTime
enableManualRenderingMode:format:maximumFrameCount:error:
disableManualRenderingMode
manualRenderingBlock
renderOffline:toBuffer:error:
connectMIDI:to:format:block:
connectMIDI:toNodes:format:block:
disconnectMIDI:from:
disconnectMIDI:fromNodes:
disconnectMIDIInput:
disconnectMIDIOutput:
auAudioUnitForAudioUnit:
isMusicDeviceOrEffect
scheduleMIDIEventBlock
invalidateAudioUnit
allocateRenderResourcesAndReturnError:
deallocateRenderResources
inputBusses
outputBusses
setFormat:error:
setEnabled:
isEnabled
setBusCount:error:
parameterWithID:scope:element:
parameterWithAddress:
setValue:
value
maximumFramesToRender
setMaximumFramesToRender:
isRenderingOffline
setRenderingOffline:
tokenByAddingRenderObserver:
removeRenderObserver:
setMIDIOutputEventBlock:
setInputEnabled:
setOutputEnabled:
startHardwareAndReturnError:
stopHardware
setOutputProvider:
setInputHandler:
canPerformInput
canPerformOutput
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioIONode.mm
-[AVAudioIONode enableRealtimeRenderingModeWithIOUnit:isInput:]
ioUnit != nil
presentationLatency
Td,R,N
audioUnit
T^{OpaqueAudioComponentInstance=},R,N
-[AVAudioOutputNode setManualRenderingPCMFormat:maximumFrameCount:]
self.isInManualRenderingMode
-[AVAudioOutputNode manualRenderingFormat]
-[AVAudioOutputNode manualRenderingMaximumFrameCount]
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
Tf,N
renderingAlgorithm
Tq,N
rate
reverbBlend
obstruction
occlusion
position
T{AVAudio3DPoint=fff},N
volume
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioNodeImpl.h
AVAE_CheckNodeHasEngine
_engine != nil
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAEInternal.h
_AVAE_Check
required condition is false: %s
com.apple.coreaudio.avfaudio
node
T@"AVAudioNode",R,W,N,V_node
TQ,R,N,V_bus
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVCUtils.mm
RegisterObject
UnregisterObject
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/AVAudioSessionDataSourceImpl.mm
ValidateRequiredFields
Unknown
<%@: %p, ID = %@; name = %@; location = %@; orientation = %@; pattern = %@>
<%@: %p, ID = %@; name = %@>
-[AVAudioSessionDataSourceDescription initWithRawSourceDescription:andOwningPortID:andSessionID:]
dataSourceID
T@"NSNumber",R
dataSourceName
T@"NSString",R
location
orientation
supportedPolarPatterns
T@"NSArray",R
selectedPolarPattern
preferredPolarPattern
SelectedRouteDescription_RouteID
SelectedRouteDescription_DataSourceID
SelectedRouteDescription_MicrophonePolarPattern
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/AVAudioSessionUtilities.mm
FormatNSErrorForReturn
getUInt32
Unspecified
Headphones
Vehicle
Speakers
copyPolarPatternPreference
copyDataSourcePreference
CopyInputSelectionPreferences
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/AVAudioSessionUtilities.h
GetProperty
0x%x
activation trigger
activation device uid
StartTime
AlertBehavior
No Record Route
ATVRemoteInput
SetSessionActiveTime
SetSessionInactiveTime
BeginHostTime
EndHostTime
DurationMilliSeconds
recordRoute
T@"NSString",R,N,V_recordRoute
isRemoteDevice
TB,R,V_isRemoteDevice
remoteProductIdentifier
T@"NSString",R,N,V_remoteProductIdentifier
remoteDeviceUID
T@"NSUUID",R,N,V_remoteDeviceUID
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVoiceController.mm
-[AVVoiceController(AVVoiceControllerInternal) setSessionNotifications]
-[AVVoiceController(AVVoiceControllerInternal) removeSessionNotifications]
-[AVVoiceController(AVVoiceControllerInternal) hardwareConfigChanged]
-[AVVoiceController(AVVoiceControllerInternal) handleInterruption:]
-[AVVoiceController(AVVoiceControllerInternal) handleRouteChange:]
-[AVVoiceController(AVVoiceControllerInternal) handleMediaServerDeath:]
-[AVVoiceController(AVVoiceControllerInternal) handleMediaServerReset:]
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidPublishDevice:]
DeviceIdentifier
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidUnpublishDevice:]
-[AVVoiceController(AVVoiceControllerInternal) beganRecording]
-[AVVoiceController(AVVoiceControllerInternal) lpcmRecordBufferReceived:atTime:]
-[AVVoiceController(AVVoiceControllerInternal) avAudioPCMRecordBufferListReceived:numChannels:atTime:]
-[AVVoiceController(AVVoiceControllerInternal) avAudioPCMRecordBufferReceived:atTime:]
-[AVVoiceController(AVVoiceControllerInternal) recordBufferReceived:atTime:]
-[AVVoiceController(AVVoiceControllerInternal) lpcmRecordBufferForNonLPCMReceived:atTime:]
-[AVVoiceController(AVVoiceControllerInternal) finishedRecording]
-[AVVoiceController(AVVoiceControllerInternal) startpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) interspeechPointDetected]
-[AVVoiceController(AVVoiceControllerInternal) endpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) beganPlaying]
-[AVVoiceController(AVVoiceControllerInternal) finishedPlaying]
-[AVVoiceController(AVVoiceControllerInternal) alertPlaybackFinishedOfType:]
-[AVVoiceController(AVVoiceControllerInternal) beginAudioSessionActivate:]
-[AVVoiceController(AVVoiceControllerInternal) endAudioSessionActivate:]
-[AVVoiceController(AVVoiceController_Priv) setStopOnBargeInEnabled:]
-[AVVoiceController(AVVoiceController_Priv) numberOfChannels]
-[AVVoiceController(AVVoiceController_Priv) playAlertSoundForType:overrideMode:]
playAlertSoundForType:overrideMode
v8@?0
-[AVVoiceController(AVVoiceController_Priv) playAlertSoundForType:overrideMode:]_block_invoke
bargeInDetectEnabled
TB,GisBargeInDetectEnabled
stopOnBargeInEnabled
TB,GisStopOnBargeInEnabled
playbackRoute
lastRecordStartTime
voiceTriggerInfo
T@"NSDictionary",R
synchronousCallbackEnabled
TB,GisSynchronousCallbackEnabled
pcmRecordBufferFormat
T@"AVAudioFormat",R
duckOthersOption
TB,SsetDuckOthersOption:
numberOfChannels
-[AVVoiceController initWithContext:error:]
-[AVVoiceController prewarmAudioSession]
finalize
dealloc
-[AVVoiceController dealloc]
-[AVVoiceController releaseAudioSession]
-[AVVoiceController releaseAudioSession:]
-[AVVoiceController willAcceptContext:]
-[AVVoiceController IsDeviceAvailableInLocalRoute:error:]
-[AVVoiceController setCurrentContext:error:]
-[AVVoiceController prepareRecordWithSettings:error:]
-[AVVoiceController setAlertSoundFromURL:forType:]
-[AVVoiceController playAlertSoundForType:]
playAlertSoundForType
-[AVVoiceController resetEndpointer]
-[AVVoiceController playRecordStartingAlertAndResetEndpointer]
-[AVVoiceController startRecording]
-[AVVoiceController startRecording:]
-[AVVoiceController startRecordingAtTime:error:]
-[AVVoiceController startRecordingWithSettings:error:]
-[AVVoiceController stopRecording]
-[AVVoiceController preparePlaybackWithSettings:error:]
preparePlaybackWithSettings
-[AVVoiceController preparePlaybackFromURL:error:]
preparePlaybackFromURL
-[AVVoiceController startPlaying]
-[AVVoiceController stopPlaying]
-[AVVoiceController setRecordDelegate:]
-[AVVoiceController getRecordBufferDuration]
-[AVVoiceController setRecordBufferDuration:]
-[AVVoiceController setEndpointerDelegate:]
internal Speex
external
-[AVVoiceController setRecordEndpointMode:]
-[AVVoiceController setRecordStartWaitTime:]
-[AVVoiceController setPlaybackDelegate:]
-[AVVoiceController setPlaybackBufferDuration:]
-[AVVoiceController isRecording]
-[AVVoiceController setAlertVolume:]
-[AVVoiceController setPlaybackVolume:]
-[AVVoiceController setStopOnEndpointEnabled:]
AVVoiceControllerPluginDidDPublishDeviceNotification
AVVoiceControllerPluginDidUnpublishDeviceNotification
recordSettings
recording
TB,R,GisRecording
endpointerDelegate
T@"<Endpointer>",&
recordEndpointMode
recordStartWaitTime
recordInterspeechWaitTime
recordEndWaitTime
recordDelegate
T@"<AVVoiceControllerRecordDelegate>",D
meteringEnabled
TB,GisMeteringEnabled
playbackSettings
playing
TB,R,GisPlaying
playbackDelegate
T@"<AVVoiceControllerPlaybackDelegate>",D
playbackVolume
stopOnEndpointEnabled
TB,GisStopOnEndpointEnabled
alertVolume
alertStartTime
TQ,R,V_alertStartTime
metrics
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/ControllerImpl.h
unref
VCLocker
~VCLocker
setStartAlertMode
Silent
Haptic
Beep
setAlertQueueState
ILLEGAL
uninit
stopped
primed
started
stopping
running
setStopAlertMode
setStopWithErrorAlertMode
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVC_Log.h
~ElapsedTime
TraceMethod
~TraceMethod
setStartRecordTime
inactive
starting
active
AudioQueue
Plugin
waiting
setRecordStatus
Output
Music Device
Music Effect
Format Converter
Effect
Mixer
Panner
Generator
Offline Effect
MIDI Processor
Apple
AVAudioUnitComponentTagsDidChangeNotification
AVAudioUnitComponentImplementation
%d.%d.%d
AudioUnitTags
com.apple.audio.ComponentTagHelper
Request
type
subtype
manufacturer
version
UserTags
com.apple.audio.units.Components
AudioUnitTypes
InitialInputs
InitialOutputs
Remote Effect
Remote Generator
Remote Instrument
Remote Music Effect
name
T@"NSString",R,N
typeName
localizedTypeName
manufacturerName
TQ,R,N
versionString
componentURL
T@"NSURL",R,N
availableArchitectures
T@"NSArray",R,N
sandboxSafe
TB,R,N,GisSandboxSafe
hasMIDIInput
TB,R,N
hasMIDIOutput
audioComponent
T^{OpaqueAudioComponent=},R,N
userTagNames
T@"NSArray",C
allTagNames
audioComponentDescription
T{AudioComponentDescription=IIIII},R,N
iconURL
passesAUVal
hasCustomView
configurationDictionary
T@"NSDictionary",R,N
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/QualityDetector.cpp
QualityDetector
checkStatus
getSummedFrameQuality
setStartTimeoutFrameCount
setInterspeechTimeoutFrameCount
setEndTimeoutFrameCount
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/SpeexEndpointer.mm
-[SpeexEndpointer init]
-[SpeexEndpointer dealloc]
-[SpeexEndpointer configureWithSampleRate:andFrameRate:]
-[SpeexEndpointer configureWithASBD:andFrameRate:]
-[SpeexEndpointer setEndpointMode:]
-[SpeexEndpointer setStartWaitTime:]
-[SpeexEndpointer setInterspeechWaitTime:]
-[SpeexEndpointer setEndWaitTime:]
endpointMode
startWaitTime
interspeechWaitTime
endWaitTime
-[SpeexEndpointer(SpeexEndpointer_Priv) getStatus:count:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioUnitTimeEffect.mm
-[AVAudioUnitTimeEffect initWithAudioComponentDescription:]
audioComponentDescription.componentType == kAudioUnitType_FormatConverter
bypass
TB,N
<%@: %p, 
inputs = %@; 
outputs = %@>
RouteDetailedDescription_SiriInputDeviceUUID
inputs
outputs
siriRemoteInputIdentifier
Effects
Equalizer
Filter
Dynamics Processor
Reverb
Distortion
Delay
Time Effect
Synthesizer
Sampler
Drums
Guitar
Vocal
Bass
MIDI
Pitch
Imaging
No changes
New tags found, add it to the allTags
tagNames
standardLocalizedTagNames
delayTime
Td,N
feedback
lowPassCutoff
wetDryMix
Gain
Frame Qualities
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVCPluginRecordingEngine.mm
-[AVVCRemoteInput initializePlugins]
devices
-[AVVCRemoteInput dealloc]
-[AVVCRemoteInput invalidatePlugins]
Audio/Plug-Ins/RemoteInput
-[AVVCRemoteInput allBundles:]
-[AVVCRemoteInput findDeviceWithIdentifier:]
-[AVVCRemoteInput inputPlugin:didPublishDevice:]
-[AVVCRemoteInput inputPlugin:didUnpublishDevice:]
AVVCPluginRecordingEngine
~AVVCPluginRecordingEngine
getCurrentDeviceFromActivationContext
Initialize
prepareRecording
AVVCPluginRecordingEngine::startRecording
startRecording
startRecording_block_invoke
v16@?0@"NSError"8
AVVCPluginRecordingEngine::stopRecording
stopRecording
stopRecording_block_invoke
AVVCPluginRecordingEngine::destroyRecordEngine
destroyRecordEngine
destroyRecordEngine_block_invoke
createRecordQueue
createRecordQueue_block_invoke
v32@?0@"AVAudioBuffer"8@"AVAudioTime"16@"NSDictionary"24
handleRecordInput
/var/mobile/Library/Logs/CrashReporter/Assistant/AVVCCapture/
%s%s-%04d%02d%02d-%02d%02d%02d
Capture
.caf
setupAudioCaptureFile
getRecordRoute
Error! No Remote Device Found
Error! No RemoteInputDeviceName property
Error
NotConfigured
Inactive
InteruptedWhileRecording
InteruptedWhilePlaying
Prewarming
Activating
Deactivating
Active
setRecordState
IsLegalRecordStateChange
pitch
overlap
duration
Td,R
currentDevice
T@"NSString",C,V_currentDevice
delegate
T@"<AVAudioPlayerDelegate>"
T@"NSURL",R
data
T@"NSData",R
enableRate
currentTime
deviceCurrentTime
numberOfLoops
settings
format
channelAssignments
T@"NSArray",C,N
AVFileTypeAIFF
AVFileTypeAIFC
AVFileTypeWAVE
AVFileTypeMPEG4
AVFileTypeAppleM4A
AVFileTypeCoreAudioFormat
AVFileTypeMPEGLayer3
AVFileTypeAC3
AVFileTypeSunAU
AVFileType3GPP
AVFileType3GPP2
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioUnitGenerator.mm
-[AVAudioUnitGenerator initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Generator) || (audioComponentDescription.componentType == kAudioUnitType_RemoteGenerator)
audioSession
T@"AVAudioSession",&
processToTap
Ti,N
instantaneousMetering
T@"<AVAudioRecorderDelegate>"
Null run loop
Invalid completion handler
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/SessionConnector.mm
DoConnectAsync_block_invoke
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/SessionMap.mm
CopySession
AddSession
attempting to add a session with an ID that's already in use
DecrementSessionRefCount
RemoveSession_NoLock
UpdateSessionID
unexpected nil value
map::at:  key not found
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioSequencerImpl.mm
AVAudioSequencerImpl
NewMusicPlayer(&mPlayer)
NewMusicSequence(&mSequence)
MusicPlayerSetSequence(mPlayer, mSequence)
MusicSequenceSetAUGraph(mSequence, nullptr)
~AVAudioSequencerImpl
CurrentPosition
MusicPlayerGetTime(mPlayer, &theTime)
SetCurrentPosition
MusicPlayerSetTime(mPlayer, currentPosition)
IsPlaying
MusicPlayerIsPlaying(mPlayer, &isPlaying)
GetRate
MusicPlayerGetPlayRateScalar(mPlayer, &theRate)
SetRate
MusicPlayerSetPlayRateScalar(mPlayer, inRate)
HostTimeForBeats
MusicPlayerGetHostTimeForBeats(mPlayer, inBeats, pOutHostTime)
BeatsForHostTime
MusicPlayerGetBeatsForHostTime(mPlayer, inHostTime, pOutBeats)
NumberOfTracks
MusicSequenceGetTrackCount(mSequence, &trackCount)
GetTrackWithIndex
MusicSequenceGetIndTrack(mSequence, inIndex, &theTrack)
GetTempoTrack
MusicSequenceGetTempoTrack(mSequence, &tempoTrack)
GetSecondsForBeats
MusicSequenceGetSecondsForBeats(mSequence, inBeats, &theSeconds)
GetBeatsForSeconds
MusicSequenceGetBeatsForSeconds(mSequence, inSeconds, &theBeats)
~MusicTrackImpl
SetDestinationAudioUnit
MusicTrackSetDestinationAU(mTrack, inUnit.audioUnit, &desc)
SetDestinationMIDIEndpoint
MusicTrackSetDestMIDIEndpoint(mTrack, inEndPoint)
GetDestinationMIDIEndpoint
MusicTrackGetDestMIDIEndpoint(mTrack, &endPoint)
DoSetLengthInBeats
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_TrackLength, &inLength, sizeof(inLength))
DoGetLengthInBeats
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TrackLength, &length, &pLen)
SetLengthInSeconds
MusicTrackGetSequence(mTrack, &seq)
MusicSequenceGetBeatsForSeconds(seq, inLength, &beatLength)
GetLengthInSeconds
MusicSequenceGetSecondsForBeats(seq, DoGetLengthInBeats(), &seconds)
SetOffset
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &inOffset, sizeof(inOffset))
GetOffset
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &offset, &pLen)
SetLoopCount
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, pLen)
GetLoopCount
SetLoopStart
GetLoopStart
SetLoopEnd
GetLoopEnd
EnableLooping
IsLoopingEnabled
Mute
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, pLen)
IsMuted
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, &pLen)
Solo
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, pLen)
IsSoloed
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, &pLen)
UseAutomatedParams
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, pLen)
UsesAutomatedParams
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, &pLen)
GetTimeResolution
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TimeResolution, &timeRes, &pLen)
GetIndex
MusicTrackGetSequence(mTrack, &sequence)
MusicSequenceGetTrackIndex(sequence, mTrack, &index)
avas
com.apple.avfaudio
sequencer_verbose
_AVAE_CheckNoErr
failed call
error %d
Default implementation of AVEndpointVADEventHandler objective-C protocol (see AVEndpointVADEventHandler.h). Received VAD event data. Doing nothing with it however: please provide your own implementation of the protocol's method, in which your custom processing of the VAD event data is conducted...
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEndpointDetector/AVAudioEndpointDetector.mm
-[AVAudioEndpointDetector audioFormat]
-[AVAudioEndpointDetector convertToAVVADStateValueThisEDLDecision:]
-[AVAudioEndpointDetector openAudioFile:]
-[AVAudioEndpointDetector maximumSamplesPerBuffer]
-[AVAudioEndpointDetector numberFramesInAudioFile:]
-[AVAudioEndpointDetector VAD3ConfigurationFromHost]
-[AVAudioEndpointDetector populateFloat64StdVector:withDoubleValuesFromNSArray:]
strcmp([a[0] objCType], @encode(double)) == 0
-[AVAudioEndpointDetector populateFloat32StdVector:withFloatValuesFromNSArray:]
strcmp([a[0] objCType], @encode(float)) == 0
-[AVAudioEndpointDetector populateUInt32StdVector:withUnsignedIntValuesFromNSArray:]
strcmp([a[0] objCType], @encode(unsigned int)) == 0
T{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II},R,N
audioFormat
T@"AVAudioFormat",R,N
maximumSamplesPerBuffer
VADConfigurationIsInitialized
numCategories
TI,R,N
categoryDimensions
timingDimensions
interleavedCategoryAndTimingDimensions
fullCategoryDimension
fullTimingDimension
fullInterleavedDimension
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioNodeTap.mm
nil != _format
Start
_initialized
<%@: %p, name = %@; label = %u (0x%x); number = %d; port UID = %@>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/AVAudioSessionChannelImpl.mm
+[AVAudioSessionChannelDescription privateCreate:portUID:channelNumber:]
channelName
owningPortUID
channelNumber
channelLabel
TI,R
-[AVAudioChannelLayout initWithCoder:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVFAudioCore/AVAudioChannelLayout.mm
length == len
supportsSecureCoding
TB,R
layoutTag
layout
Tr^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]},R,N
channelCount
/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox
AudioFormatGetProperty
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAudioEngineGraph.mm
TraverseGraphNodes
inCurrNode.GetConnection(inDirection, bus, conn)
TraverseGraphNodesBFS
connNode
connNodeFirst
connNodeSecond
TraverseGraphNodesWithLookback
inCurrNode.GetConnection(otherDirection, bus, conn)
InformNodesAboutMixerConnection
inMixerConn.destNode && inMixerConn.destNode->IsMixerNode()
InformNodesAboutMixerDisconnection
UninitializeNode
inGraph.PerformCommand(node, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
InitializeActiveNodesInOutputChain
inGraph.IsNodeInGraph(inNode.NodeImpl())
inGraph.IsValidSourceNode(*startNode)
InitializeActiveNodesInInputChain
inGraph.GetInputNode() && (&inNode == inGraph.GetInputNode())
false == isInputConnToConverter
inGraph.GetTapsToPull().size() > 0
inGraph.PerformCommand(*inGraph.GetInputNode(), AVAudioEngineGraph::kAUSetInputCallback, &rc, sizeof(rc))
PrepareForConnection
srcNode && inGraph.IsNodeInGraph(srcNode)
destNode && inGraph.IsNodeInGraph(destNode)
srcCurrConn.destNode == NULL || srcCurrConn == inConn
destCurrConn.srcNode == NULL || destCurrConn == inConn
inGraph.PerformCommand(*destNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
PrepareForDisconnection
inGraph.IsNodeInGraph(&inDestNode)
inGraph.PerformCommand(inDestNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
AVAEGraphStateTracker.RunStateQueue
IdleLogTimerCallback
IdleShutdownTimerCallback
AVAEGraphTapRenderGuard
outputNode != nullptr
inputNode != nullptr || outputNode != nullptr
err = PerformCommand(*outputNode, kAUInitialize, NULL, 0)
IsFormatSampleRateAndChannelCountValid(outputHWFormat)
err = _Connect(connNode->NodeImpl(), outputNode->NodeImpl(), 0, 0, format)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainOptimizedTraversal, *GetOutputNode(), isOutputChainActive)
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *GetInputNode())
err = PerformCommand(*otherIONode, kAUInitialize, nullptr, 0)
IsFormatSampleRateAndChannelCountValid(inputHWFormat)
PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
Uninitialize
PerformCommand(*GetOutputNode(), kAUUninitialize, NULL, 0)
PerformCommand(*GetInputNode(), kAUUninitialize, NULL, 0)
CheckStartIO
ioNode != NULL
PerformCommand(*ioNode, kAUStartIO, NULL, 0)
Stop
PerformCommand(*ioNode, kAUStopIO, NULL, 0)
AddNode
nil != inAVNode
inImpl != nil && !IsIONode(inAVNode)
AddIONode
inImpl != nil && IsIONode(inAVNode)
NULL == ioNodeImpl && !IsNodeInGraph(inImpl)
RemoveNode
IsNodeInGraph(inImpl)
!IsRunning() && !graphNode->IsInitialized()
(graphNode->IsNodeState(kAUGraphNodeState_InInputChain) || graphNode->IsNodeState(kAUGraphNodeState_InOutputChain))
!nodeMixerConns.empty() && !hasDirectConnToIONode
conn.IsSrcAndDestValid()
graphNode == conn.destNode
err = UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
RemoveIONode
(isInputNode && graphNode == GetInputNode()) || (!isInputNode && graphNode == GetOutputNode())
!IsRunning() && !IsInitialized()
err = RemoveNode(inAVNode)
InstallTapOnNode
inAVNode
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *inputNode)
RemoveTapOnNode
Connect
inSrcAVNode && inDestAVNode
inSrcImpl && inDestImpl
_Connect
IsFormatSampleRateAndChannelCountValid(format)
IsNodeInGraph(inSrcImpl) && IsNodeInGraph(inDestImpl)
!srcNodeMixerConns.empty() && !isSrcNodeConnectedToIONode
!destNodeMixerConns.empty() && !isDestNodeConnectedToIONode
PerformCommand(*graphNodeSrc, kAUUninitialize, NULL, 0)
inSrcImpl->SetOutputFormat(inSrcBus, format) && inDestImpl->SetInputFormat(inDestBus, format)
inDestImpl->SetInputFormat(inDestBus, srcFormat)
[midiInputImpl->GetOutputFormat(0) isEqual:inSrcImpl->GetOutputFormat(0)]
graphNodeDest != conn.destNode
ConnectMultipleOutputs
inSrcAVNode && inDestAVConnectionPoints && inDestAVConnectionPoints.count > 0
IsNodeInGraph(inSrcImpl)
!inSrcNode->IsSplitterNode()
currentConnPoints.size() <= 1
currentConnPoints.size() > 1
avConnPoint
true == anyConnToMakeOrDisconnect
PerformCommand(*finalSrcNode, kAUUninitialize, NULL, 0)
_DisconnectInput(connPoint.node->NodeImpl(), connPoint.bus)
_Connect(inSrcImpl, [splitter impl], inSrcBus, kAudioUnitElement_Default, format)
RemoveNode(avNode)
PerformCommand(*finalSrcNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
[midiInputImpl->GetOutputFormat(0) isEqual:finalSrcNode->NodeImpl()->GetOutputFormat(0)]
_Connect(finalSrcNode->NodeImpl(), destImpl, srcBus, destBus, format)
UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
DisconnectInput
inDestAVNode
inDestImpl
_DisconnectInput
IsNodeInGraph(inDestImpl)
!IsRunning()
graphNode != conn.destNode
DisconnectOutput
inSrcAVNode
inSrcImpl
_DisconnectOutput
DisconnectAllInputs
inImpl
tmpErr = _DisconnectInput(conn.destNode->NodeImpl(), conn.destBus)
DisconnectAllOutputs
ConnectMIDI
inSourceAVNode && inDestAVNodes && inDestAVNodes.count > 0
graphNodeSrc->IsMIDIProcessorNode()
destAVNode
graphNodeDest->IsMusicDevice() || graphNodeDest->IsMIDIProcessorNode()
inSrcImpl->SetOutputFormat(0, newFormat)
PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
err = UpdateGraphAfterReconfig(&disjointNodes, kOutputChainFullTraversal)
DisconnectMIDI
PerformCommand(*midiNode, kAUUninitialize, nullptr, 0)
DisconnectAllMIDIInputs
DisconnectAllMIDIOutputs
graphNode->IsMIDIProcessorNode()
GetInputConnectionPointForNode
!graphNode->IsSplitterNode()
!splitterConnPoint.node->IsSplitterNode()
GetOutputConnectionPointsForNode
numSplitterConnections == 0 || numSplitterConnections > 1
!connPoint.node->IsSplitterNode()
NodeRenderingStateChanged
GetOutputDeviceLatencyForNode
GraphDescription
PerformCommand
NULL != inOutData && sizeof(UInt32) == inDataSize
!inNode.IsInitialized()
inNode.IsIONode()
NULL != inOutData && sizeof(AUGraphConnection) == inDataSize
NULL != inOutData && sizeof(AURenderCallbackStruct) == inDataSize
NULL != inOutData && sizeof(AUGraphMIDIConnection) == inDataSize
RenderToABL
outputNode
InputAvailable
NULL != tap
AddPendingConnection
inConn.IsSrcAndDestValid()
RemovePendingConnection
inConn.srcNode || inConn.destNode
MakeConnection
PerformCommand(*graphNodeDest, kAUMakeConnection, &connection, sizeof(connection))
PerformCommand(*graphNodeDest, kAUInitialize, NULL, 0)
MakeVirtualConnection
IsNodeInGraph(conn.srcNode) && IsNodeInGraph(conn.destNode)
srcCurrConn.destNode == NULL || srcCurrConn == conn
destCurrConn.srcNode == NULL || destCurrConn == conn
MakeDisconnection
true == graphNodeDest->GetConnection(kUpstream, inDestBus, mixerConn)
PerformCommand(*graphNodeDest, kAUMakeDisconnection, &connection, sizeof(connection))
DisconnectInactiveNode
false == inNode->IsInitialized()
UpdateGraphAfterReconfig
conn.srcNode && conn.destNode && conn.destNode->IsMixerNode()
AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainFullTraversal, *conn.srcNode, isChainActive)
PerformCommand(*inputConn.srcNode, kAUInitialize, NULL, 0)
PerformCommand(*inputConn.destNode, kAUInitialize, NULL, 0)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, inTraversalMode, *GetOutputNode(), isChainActive)
(bus%d) %p, {%s} -> 
(bus%d) %p, {%s}
________ %s ________
AVAudioEngineGraph %p: initialized = %d, running = %d, number of nodes = %d
 ******** output chain ********
 ******** input chain ********
 ******** pending connections - output ********
 %s, [%s]
 ******** pending connections - input ********
 ******** other nodes ********
______________________________________
SetSequence
err = MusicSequenceSetAudioGraph(inSequence, _seqGraphImpl)
NodeStateChanged
GetMusicDeviceNode()
RegisterRenderCallback
UnregisterRenderCallback
GetDefaultMusicDevice
outUnit || outDesc
GetOutputAudioUnit
operator()
inGraph.PerformCommand(theNode, AVAudioEngineGraph::kAUSetPropertyMaximumFramesPerSlice, &maxFrames, sizeof(maxFrames))
_AVAE_CheckAndReturnErr
false condition
CAException
inGraph.PerformCommand(midiNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
conn.destNode && conn.destNode->IsMixerNode()
0 == inCurrNode.NumberOfValidConnections(kUpstream)
inNodeUpstream.IsInitialized()
PerformCommand(midiInput, kAUInitialize, nullptr, 0)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVCRecordingEngine.mm
setupRecordQueue
setRecordEngineState
AVVCAudioQueueRecordingEngine
~AVVCAudioQueueRecordingEngine
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVCAudioQueueRecordingEngine.mm
AudioQueueRecordInputCallback
AudioQueueRecordPropertyListenerProc
QueueIsRunning
With
AVVoiceController_RecordQueue
configureRecordConverterFromSettings
createAudioConverter
startRecording:AudioQueueReset
 but failed
delay
past
startRecording : AudioQueueStart
functionstopRecording : AudioQueueStop
destroyRecordEngine : AudioQueueStop
destroyRecordEngine: AudioQueueDispose
enableMetering
DeinterleaveAudio
handleRecordQueuePropertyListener
handleAudioInput
resetAudioEngine
resetAudioEngine:AudioQueueReset
UpdateRecordDeviceOnQueue
CoreAudioUtility/Source/PublicUtility/CAStreamBasicDescription.h
ChangeNumberChannels
RecordEncoderInputDataProc
avat
devicetest_verbose
com.apple.avfaudio.devicetest.service
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioDeviceTest/AVAudioDeviceTest.mm
-[AVAudioDeviceTest init]
-[AVAudioDeviceTest init]_block_invoke
-[AVAudioDeviceTest startWithSequence:completion:]
connection
T@"NSXPCConnection",&,V_connection
serviceDelegateAsync
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateAsync
serviceDelegateSync
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateSync
inputFormat
outputFormat
channelMap
T@"NSArray",&,N
magicCookie
T@"NSData",&,N
downmix
dither
sampleRateConverterQuality
sampleRateConverterAlgorithm
T@"NSString",&,N
primeMethod
primeInfo
T{AVAudioConverterPrimeInfo=II},N
bitRate
bitRateStrategy
maximumOutputPacketSize
Tq,R,N
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioConverter.mm
convert
outputBuffer.frameCapacity >= inputBuffer.frameLength
FillComplexProc
impl->_inputBufferReceived
[impl->_inputBufferReceived.format isEqual: impl->_inputFormat]
ioData->mNumberBuffers == abl->mNumberBuffers
false
Endpointer  
Recurrent 
Unknown EDL type 
: occurred at 
 sec, detected at 
 sec.
 Decision latency = 
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEndpointDetector/EndpointVAD3Host.mm
EDLDecision2AVVADState
HandleEvent
mAVAudioEndpointDetectorUtility.VAD3ConfigurationInterface_IsInitialized(*VAD3Config)
mRecurrentEventTimesSeconds.size() == mRecurrentEventTimesSeconds.size() && mEndpointerEvents.size() == mEndpointerEventTimesSeconds.size() && mRawStates.size() == mRawStateTimesSeconds.size()
Error reading the plist.
AU start wait time property error: 
AU interspeech wait time property error: 
AU speech start-adjust property error: 
AU speech end-adjust property error: 
AU window length property error: 
AU speech fraction property error: 
Process() error: 
OfflineDecode error: 
ResetAudioUnit error: 
ProcessAudioFile
mAudioUnitVAD3 != NULL
Samples per audio buffer: 
AU input sampling rate: 
Number of buffers: 
AUEndpointVAD3 error: 
AUEndpointVAD3 processed successfully.
WriteOutputFiles
speech
.epr
.ephr
.eph
.raw
.dst
TearDownAudioUnit
getNumberFramesInAudioFile
AVVC_PROFILE_Prop_PrepareStart
AVVC_PROFILE_Prop_PrepareEnd
AVVC_PROFILE_Prop_GetPropertiesStart
AVVC_PROFILE_Prop_GetPropertiesEnd
AVVC_PROFILE_Prop_SetSessionActiveStart
AVVC_PROFILE_Prop_SetSessionActiveEnd
AVVC_PROFILE_Prop_SetupRecordQueueStart
AVVC_PROFILE_Prop_SetupRecordQueueEnd
AVVC_PROFILE_Prop_StartRecordingStart
AVVC_PROFILE_Prop_StartRecordingEnd
AVVC_PROFILE_Prop_PlayAlertStart
AVVC_PROFILE_Prop_PlayAlertEnd
AVVC_PROFILE_Prop_RecordQueueStart
AVVC_PROFILE_Prop_RecordQueueEnd
AVVC_PROFILE_Prop_FirstBufferReceived
AVVC_PROFILE_Delta_PrepareAPIStartEnd
AVVC_PROFILE_Delta_GetSessionPropStartEnd
AVVC_PROFILE_Delta_SetSessionActiveStartEnd
AVVC_PROFILE_Delta_SetupRecordQueueStartEnd
AVVC_PROFILE_Delta_StartRecordAPIStartEnd
AVVC_PROFILE_Delta_PlayAlertQueueStartEnd
AVVC_PROFILE_Delta_StartRecordAudioQueueStartEnd
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferDelta
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferToDelegateCallDelta
AVVCMM
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVCMetricsManager.mm
+[AVVCMetricsManager createSharedManager]
+[AVVCMetricsManager destroySharedManager]
+[AVVCMetricsManager sharedManager]
-[AVVCMetricsManager dealloc]
yyyy-MM-dd'T'HH:mm:ss.SSSSSSSZZZZZ
v32@?0@8@16^B24
-[AVVCMetricsManager measureElapseTimeForMetric:block:]
-[AVVCMetricsManager logProfileMetrics:]
publicMetrics
T@"NSMutableDictionary",&,V_publicMetrics
avvcProfilingInfoDictionary
T@"NSMutableDictionary",&,V_avvcProfilingInfoDictionary
voiceTriggerStartHostTime
TQ,N,V_voiceTriggerStartHostTime
callToStartRecordHostTime
TQ,N,V_callToStartRecordHostTime
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.mm
AUGraphNodeBase
nil != _avNode
nullptr != _avNodeImpl
ConnectInput
nullptr != srcNode
inNode != nil
DisconnectNode
CreateRecordingTap
nil != callbackBlock
nullptr == Tap()
NodeImpl()->SetOutputFormat(bus, format)
DestroyMIDIConnection
midiSrc == MIDIInput()
 node %p {%s}, '%s'
 inputs = %d
 (bus%d, en%d) <- (bus%d) %p, {%s}, [%s]
 outputs = %d
 (bus%d, en%d) -> (bus%d) %p, {%s}, [%s]
%s %s %s
AUGraphNodeBaseV3
RenderBlock()
AllocateInputBlock_block_invoke
i44@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36
DeallocateInputBlock
false == AUI().IsRunning()
AllocateInputHandler
inRenderCallback.inputProc
v36@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28
AUGraphMIDINodeV3
IsMIDIProcessorNode()
SetTapBlock
GetTapBlock()
i36@?0q8C16q20r*28
AUGraphMultiBusNode
IsMixerNode() || IsSplitterNode()
GetConnection
nodeBussesVec.size() >= (inBus + 1)
GetConnectionPoint
GetBusForConnectionPoint
nodeBussesVec.size() == nodeVec.size()
Drums - Bit Brush
Drums - Buffer Beats
Drums - Lo-Fi
Multi - Broken Speaker
Multi - Cellphone Concert
Multi - Decimated 1
Multi - Decimated 2
Multi - Decimated 3
Multi - Decimated 4
Multi - Distorted Funk
Multi - Distorted Cubed
Multi - Distorted Squared
Multi - Echo 1
Multi - Echo 2
Multi - Echo Tight 1
Multi - Echo Tight 2
Multi - Everything is Broken
Speech - Alien Chatter
Speech - Cosmic Interference
Speech - Golden Pi
Speech - Radio Tower
Speech - Waves
preGain
outputVolume
nextAvailableInputBus
T@"AVAudioTime",R,N
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioClock.mm
AVAudioClockImpl
_nodeImpl->AUI().AddV2PropertyListener(kAudioUnitProperty_StreamFormat, StreamFormatListener, this)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVMIDIPlayer/AVMIDIPlayer.mm
-[AVMIDIPlayer dealloc]
-[AVMIDIPlayer prepareToPlay]
MusicPlayerPreroll(impl->mPlayer)
-[AVMIDIPlayer isPlaying]
MusicPlayerIsPlaying(impl->mPlayer, &playing)
-[AVMIDIPlayer rate]
MusicPlayerGetPlayRateScalar(impl->mPlayer, &scalar)
-[AVMIDIPlayer setRate:]
MusicPlayerSetPlayRateScalar(impl->mPlayer, rate)
-[AVMIDIPlayer duration]
MusicSequenceGetSecondsForBeats(impl->mSequence, impl->mLength, &durInSeconds)
-[AVMIDIPlayer currentPosition]
MusicPlayerGetTime(impl->mPlayer, &positionInBeats)
MusicSequenceGetSecondsForBeats(impl->mSequence, positionInBeats, &positionInTime)
-[AVMIDIPlayer setCurrentPosition:]
MusicSequenceGetBeatsForSeconds(impl->mSequence, (Float64) currentPosition, &positionInBeats)
MusicPlayerSetTime(impl->mPlayer, positionInBeats)
TB,R,N,GisPlaying
currentPosition
avmp
avmidiplayer_verbose
MIDIPlayerImpl
CallbackQueue
~MIDIPlayerImpl
start
MusicPlayerStart(mPlayer)
stop
MusicPlayerStop(mPlayer)
finishLoad
MusicSequenceGetAUGraph(mSequence, &graph)
MusicTrackGetProperty(track, kSequenceTrackProperty_TrackLength, &length, &plength)
MusicSequenceSetUserCallback(mSequence, userCallback, this)
SetUpGraph
AUGraphOpen(inGraph)
AUGraphGetNodeCount (inGraph, &nodeCount)
AUGraphGetIndNode(inGraph, i, &node)
AUGraphNodeInfo(inGraph, node, &desc, &unit)
AudioUnitSetProperty (unit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &numFrames, sizeof(numFrames))
AUGraphInitialize(inGraph)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioUnitMIDIInstrument.mm
SendProgramChange
true == SendMIDIEvent(kMIDIMessage_ControlChange, 0, bankMSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_ControlChange, bankSelectLSBParam1, bankLSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_PatchChange, programID, 0, 0, channel)
-[AVAudioUnitMIDIInstrument initWithAudioComponentDescription:]
(description.componentType == kAudioUnitType_MusicDevice) || (description.componentType == kAudioUnitType_RemoteInstrument)
-[AVAudioUnitMIDIInstrument startNote:withVelocity:onChannel:]
_IMPL->StartNote(note, velocity, channel)
-[AVAudioUnitMIDIInstrument stopNote:onChannel:]
_IMPL->StopNote(note, channel)
-[AVAudioUnitMIDIInstrument sendController:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ControlChange, controller, controllerValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendPitchBend:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PitchBend, value&0x7F, value>>7, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressure:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ChannelPressure, pressureValue, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressureForKey:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_KeyPressure, key, pressureValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PatchChange, program, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:bankMSB:bankLSB:onChannel:]
_IMPL->SendProgramChange(program, bankMSB, bankLSB, channel)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:data2:]
_IMPL->SendMIDIEvent(midiStatus, data1, data2, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:]
_IMPL->SendMIDIEvent(midiStatus, data1, 0, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDISysExEvent:]
_IMPL->SendMIDISysexEvent((CFDataRef)midiData)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVFAudioCore/AVAudioBuffer.mm
-[AVAudioBuffer setByteLength:]
length <= _imp->_byteCapacity
<%@@%p: %d/%d bytes>
audioBufferList
Tr^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
mutableAudioBufferList
T^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
-[AVAudioPCMBuffer initWithPCMFormat:frameCapacity:]
isPCMFormat
-[AVAudioPCMBuffer setFrameLength:]
length <= _imp->_frameCapacity
peakPowerPerChannel
averagePowerPerChannel
frameCapacity
frameLength
TI,N
stride
floatChannelData
T^^f,R,N
int16ChannelData
T^^s,R,N
int32ChannelData
T^^i,R,N
-[AVAudioCompressedBuffer initWithFormat:packetCapacity:maximumPacketSize:]
!(fmt.IsPCM() || fmt.mFormatID == kAudioFormatALaw || fmt.mFormatID == kAudioFormatULaw)
maximumPacketSize != 0
-[AVAudioCompressedBuffer setPacketCount:]
length <= _imp->_packetCapacity
packetCapacity
packetCount
maximumPacketSize
T^v,R,N
byteCapacity
TI,R,D,N
byteLength
TI,D,N
packetDescriptions
T^{AudioStreamPacketDescription=qII},R,N
filterType
frequency
bandwidth
gain
bands
globalGain
AVAudioSessionCategoryAmbient
AVAudioSessionCategorySoloAmbient
AVAudioSessionCategoryPlayback
AVAudioSessionCategoryRecord
AVAudioSessionCategoryPlayAndRecord
AVAudioSessionCategoryAudioProcessing
AVAudioSessionCategoryMultiRoute
AVAudioSessionCategoryVoiceOver
AVAudioSessionCategoryVoiceCommand
AVAudioSessionCategoryRingtonePreview
AVAudioSessionCategoryRingtone
AVAudioSessionCategoryVoiceMail
AVAudioSessionCategoryPhoneCall
AVAudioSessionCategoryTTYCall
AVAudioSessionCategoryAlarm
AVAudioSessionCategoryPlaybackNoSpeaker
AVAudioSessionCategoryEmergencyAlert
AVAudioSessionCategoryEmergencyAlert_CanBeMuted
AVAudioSessionCategoryFindMyPhone
AVAudioSessionCategoryWaterEjection
AVAudioSessionCategoryFindMyDevice
AVAudioSessionModeDefault
AVAudioSessionModeVoiceChat
AVAudioSessionModeGameChat
AVAudioSessionModeVideoRecording
AVAudioSessionModeMeasurement
AVAudioSessionModeMoviePlayback
AVAudioSessionModeSpokenAudio
AVAudioSessionModeVoicePrompt
AVAudioSessionModeVideoChat
AVAudioSessionModeSpeechRecognition
AVAudioSessionModeRaw
AVAudioSessionModeVoiceMessages
AVAudioSessionModeLocatePhone
AVAudioSessionModeHearingAccessibility
AVAudioSessionModeLivePhoto
AVAudioSessionModeSOS
AVAudioSessionModeSpatialRecording
AVAudioSessionInterruptionNotification
AVAudioSessionRouteChangeNotification
AVAudioSessionMediaServicesWereLostNotification
AVAudioSessionMediaServicesWereResetNotification
AVAudioSessionSilenceSecondaryAudioHintNotification
AVAudioSessionPickableRouteChangeNotification
AVAudioSessionRoutingContextChangeNotification
AVAudioSessionInterruptionTypeKey
AVAudioSessionInterruptionOptionKey
AVAudioSessionInterruptorNameKey
AVAudioSessionInterruptionWasSuspendedKey
AVAudioSessionRouteChangeReasonKey
AVAudioSessionRouteChangePreviousRouteKey
AVAudioSessionSilenceSecondaryAudioHintTypeKey
activation accessibility preference
activation call direction
LineIn
MicrophoneBuiltIn
MicrophoneWired
LineOut
BluetoothA2DPOutput
Receiver
Speaker
HDMIOutput
AirPlay
S/PDIF
BluetoothLE
BluetoothHFP
USBAudio
CarAudio
Upper
Lower
Bottom
Front
Back
Left
Right
Omnidirectional
Cardioid
Subcardioid
EndpointVAD3Host
com.apple.coreaudio
EndpointVADConsoleMsgs
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEndpointDetector/FileAndDataIO_VAD3.cpp
writeASCIIRawStateValues
%.3f
writeASCIIPostDistValues
%.3f
writeASCIIEndpointsFromEventTimes
%.3f
writeBinaryDataFile
writeBinaryAudioFile
cannot convert to CMAudioFormatDescription %d
<AVAudioFormat %p: %s>
mSampleRate
mFormatID
mFormatFlags
mBytesPerPacket
mFramesPerPacket
mBytesPerFrame
mChannelsPerFrame
mBitsPerChannel
channelLayout
standard
TB,R,N,GisStandard
commonFormat
sampleRate
interleaved
TB,R,N,GisInterleaved
streamDescription
Tr^{AudioStreamBasicDescription=dIIIIIIII},R,N
T@"AVAudioChannelLayout",R,N
formatDescription
Tr^{opaqueCMFormatDescription=},R,N
Audio files cannot be non-interleaved. Ignoring setting AVLinearPCMIsNonInterleaved YES.
AVAudioSession
outputID
inputID
Tq,N,V_outputID
Tq,N,V_inputID
T@"NSData",R,N,V_data
stimulusURL
outputMode
inputProcessingChain
outputProcessingChain
Tf,N,V_volume
T@"NSURL",&,N,V_stimulusURL
T@"AVAudioDeviceTestProcessingChain",&,N,V_inputProcessingChain
T@"AVAudioDeviceTestProcessingChain",&,N,V_outputProcessingChain
Tq,N,V_outputMode
graphURL
processingStripURL
T@"NSURL",&,N,V_graphURL
T@"NSURL",&,N,V_processingStripURL
com.apple.speech.voice.Alex
AVSpeechSynthesisIPANotationAttribute
language
identifier
quality
T@"NSString",C,D,N
T@"NSString",&,D,N
Tq,D,N
voice
speechString
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
attributedSpeechString
T@"NSString",&,N,V_speechString
T@"NSAttributedString",&,N,V_attributedSpeechString
T@"AVSpeechSynthesisVoice",&,N,V_voice
Tf,N,V_rate
Tf,N,V_pitchMultiplier
Td,N,V_preUtteranceDelay
Td,N,V_postUtteranceDelay
T@"<AVSpeechSynthesizerDelegate>",W,N,V_delegate
speaking
TB,R,N,GisSpeaking,V_speaking
paused
TB,R,N,GisPaused,V_paused
outputChannels
T@"NSArray",&,N,V_outputChannels
/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle
IPHONE_SIMULATOR_ROOT
CFFIXED_USER_HOME
isPrimary
channels
Ti,R
bytesCapacity
bytesDataSize
T^v,R
packetDescriptionCapacity
packetDescriptionCount
T^{AudioStreamPacketDescription=qII},R
timeStamp
T^{AudioStreamBasicDescription=dIIIIIIII},R
remoteVoiceActivityRMS
TC,R
remoteVoiceActivityVAD
distanceAttenuationModel
referenceDistance
maximumDistance
rolloffFactor
enable
level
filterParameters
T@"AVAudioUnitEQFilterParameters",R,N
listenerPosition
listenerVectorOrientation
T{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}},N
listenerAngularOrientation
T{AVAudio3DAngularOrientation=fff},N
distanceAttenuationParameters
T@"AVAudioEnvironmentDistanceAttenuationParameters",R,N
reverbParameters
T@"AVAudioEnvironmentReverbParameters",R,N
applicableRenderingAlgorithms
setDuckOthersOption
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/ControllerImpl.mm
setSessionPropertiesFromMode
setSessionProperties
AVVC Rec Queue RunLoop
DispatchQueue
SIMULATOR_ROOT
%s%@
/System/Library/Audio/UISounds/jbl_begin.caf
/System/Library/Audio/UISounds/jbl_confirm.caf
/System/Library/Audio/UISounds/jbl_cancel.caf
Alert
Record
Playback
Session
ControllerImpl
dump_input
profile_avvc
duck_others
~ControllerImpl
callbackBarrier
setNoResumeOnDeactivate
setActivationMode
setIOBufferSize
UsePluginModelForHomeOrBluetoothButtonActivation
handlePluginDidPublishDevice
handlePluginDidUnpublishDevice
createRecordingEngine
test_LEA
configure
setCurrentContext
configureAlerts
cleanup
getCurrentRecordDeviceInfo
setActivationContext
getRecordAndPlaybackRoutes
Unknown Playback Route
No Playback Route
checkSession
AVVCEngine-prepareRecording from checkSession
forceDeactivateSessionAndFixupState
B8@?0
deactivateSession
AVAudioSessionDeactivate
setSessionActive
AVAudioSessionSetActive
mPlaybackQueue : AudioQueueStop
setSessionActive1
setSessionActive2
getSessionProperties
getSessionProperties_HWConfig
setupEndpointer
resetEndpointDetector
prepareRecordQueue
calculateRecordStartTime
configureAlertModeFromMode
handsFree
built-in speaker
Auto
Post-Voice
iMessageGestureToHead
Dictation
Wired/BT ButtonPress
prepareRecord
startRecord
stopRecord
startedRecording
doneRecording
populateRecordSettings
setAlertURL
playAlert
createAlertQueue
AVVoiceController_AlertQueue
primeAlertQueue
AudioQueueReset : mAlertQueue
setupAlert
startAlertQueue
mAlertQueue : AudioQueueStart
mAlertQueue : AudioQueueStop
destroyAlertQueue
destroyAlertQueue : AudioQueueStop
calculateAlertTimes
alertStarted
alertFinished
AlertAQPropertyListenerProc
handleAlertAQPropertyChange
vibeStartAlertFinished
vibeStopAlertFinished
VibeAlertCompletionProc
checkForEndpoint
HandleDeferredContext_block_invoke
HandleConverterError
handleInterruptStart
handleInterruptStop
handleRouteChange
interrupted
not (yet) active
handleServerDeath
handleServerReset
createPlaybackQueue
AVVoiceController_PlaybackQueue
preparePlaybackQueue
startPlaybackQueue
flushAndStopPlaybackQueue
destroyPlaybackQueue
destroyPlaybackQueue : AudioQueueStop
prepareAudioFile
setupAudioFile
startedPlaying
donePlaying
PlaybackAQPropertyListenerProc
handleEOF
handleAudioPlaybackStream
handleFileRead
handleEncodedFileRead
setSessionState
com.apple.avfoundation.avvc
VCUnlocker
~VCUnlocker
setAlertState
avvc
avvc_debug
debug_level
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVC_Log.cpp
Initialize_Logging
debug_encoding
debug_endpoint
debug_callbacks
debug_locking
debug_state
debug_trace
debug_timing
debug_delegate
debug_playback
debug_deviceselect
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/AVAudioSession.mm
AVAudioSessionPropertyListener
AVAudioSessionAddSPIPropertyListeners
-[AVAudioSession initWithSessionType:]
-[AVAudioSession initWithSessionID:]
-[AVAudioSession category]
-[AVAudioSession setActive:withOptions:error:]
-[AVAudioSession recordPermission]
v12@?0C8
-[AVAudioSession activeSessionDisplayIDs]
-[AVAudioSession mode]
-[AVAudioSession audioClockDevice]
-[AVAudioSession privateInterruptionWithInfo:]
-[AVAudioSession privateHandleServerDied]
-[AVAudioSession privateHandlePickableRoutesChange]
-[AVAudioSession privateHandleSecondaryAudioHintChange:]
-[AVAudioSession privateHandleRoutingContextChange]
-[AVAudioSession privateHandleServerConnectionCompletion:]
-[AVAudioSession privateHandleServerConnectionCompletion:]_block_invoke
-[AVAudioSession privateUpdateDataSources:forInput:]
input
output
availableCategories
category
categoryOptions
routeSharingPolicy
availableModes
mode
recordPermission
otherAudioPlaying
TB,R,GisOtherAudioPlaying
secondaryAudioShouldBeSilencedHint
currentRoute
T@"AVAudioSessionRouteDescription",R
preferredInput
T@"AVAudioSessionPortDescription",R
availableInputs
AVAudioSessionSemaphore
HandleRouteChange
avaudiosession_verbose
inputGain
inputDataSources
outputDataSources
promptStyle
isPiPAvailable
audioFormats
inputNumberOfChannels
outputNumberOfChannels
AVAudioSession Notify Thread
GetNotificationRunLoopThread
ValidateRouteSharingPolicyParameters
RouteSharingPolicyException
Illegal route sharing policy specified
com.apple.AVAudioSessionActivation
ValidateActivationContext
GetProperty_DefaultToZero
/System/Library/Frameworks/AudioToolbox.framework/libAudioDSP.dylib
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEndpointDetector/AVAudioEndpointDetectorUtility.cpp
AVAudioEndpointDetectorUtility
EndpointDetectorInterface_registerAUForOSXDevelopment
registerAUForOSXDevelopment
VAD3ConfigurationInterface_IsInitialized
VAD3ConfigurationInterface_GetNumCategories
VAD3ConfigurationInterface_GetCategoryName
VAD3ConfigurationInterface_GetNumCategoryValues
VAD3ConfigurationInterface_GetCategoryValueName
VAD3ConfigurationInterface_GetTimingModelOrder
VAD3ConfigurationInterface_GetCategoryDimensions
VAD3ConfigurationInterface_GetTimingDimensions
VAD3ConfigurationInterface_GetInterleavedCategoryAndTimingDimensions
VAD3ConfigurationInterface_GetFullCategoryDimension
VAD3ConfigurationInterface_GetFullTimingDimension
VAD3ConfigurationInterface_GetFullInterleavedDimension
VAD3ConfigurationInterface_EncodeStateTm
VAD3ConfigurationInterface_DecodeStateTm
VAD3ConfigurationInterface_EncodeStateTm_II
VAD3ConfigurationInterface_DecodeStateTm_II
VAD3ConfigurationInterface_EncodeState
VAD3ConfigurationInterface_DecodeState
VAD3ConfigurationInterface_EncodeTiming
VAD3ConfigurationInterface_DecodeTiming
VAD3ConfigurationInterface_EncodeFull
VAD3ConfigurationInterface_DecodeFull
PListReaderInterface_ReadPListFromFile
/System/Library/Frameworks/CoreMedia.framework/CoreMedia
CMAudioFormatDescriptionGetStreamBasicDescription
CMAudioFormatDescriptionCreate
CMAudioFormatDescriptionGetChannelLayout
CMAudioFormatDescriptionGetMagicCookie
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioFile.mm
-[AVAudioFile writeFromBuffer:error:]
buffer != nil
_imp->CheckClientFormatSet()
ExtAudioFileWrite(_imp->_extAudioFile, buffer.frameLength, buffer.audioBufferList)
-[AVAudioFile readIntoBuffer:frameCount:error:]
frames <= buffer.frameCapacity
ExtAudioFileRead(_imp->_extAudioFile, &ioFrames, buffer.mutableAudioBufferList)
-[AVAudioFile length]
ExtAudioFileGetProperty(_imp->_extAudioFile, kExtAudioFileProperty_FileLengthFrames, &propSize, &length)
-[AVAudioFile framePosition]
ExtAudioFileTell(_imp->_extAudioFile, &pos)
-[AVAudioFile setFramePosition:]
ExtAudioFileSeek(_imp->_extAudioFile, pos)
fileFormat
processingFormat
length
framePosition
AVAudioFileImpl
fileURL != nil
ExtAudioFileOpenURL((CFURLRef)fileURL, &_extAudioFile)
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_FileDataFormat, &propSize, &fileASBD)
SetFormats(format, interleaved, fileASBD, avacl)
ReadMagicCookie
_fileFormat
_processingFormat
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &fileID)
ExtAudioFileCreateWithURL((CFURLRef)fileURL, fileType, &fileASBD, NULL, kAudioFileFlags_EraseFile, &_extAudioFile)
ExtAudioFileGetProperty(openFileImpl->_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &openAudioFileID)
ExtAudioFileWrapAudioFileID(openAudioFileID, false, &_extAudioFile)
CheckClientFormatSet()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Aspen/AVFAudio/AVAudioSession/AVAudioSessionPortImpl.mm
<%@: %p, type = %@; name = %@; UID = %@; ID = %@; hasHWVoiceProcessing = %d; isHeadphones = %d; channels = %@; dataSources = %@; selectedDataSource = %@; isLiveListenSupported = %d>
<%@: %p, type = %@; name = %@; UID = %@; selectedDataSource = %@>
-[AVAudioSessionPortDescription initWithRawPortDescription:owningSession:]
RouteDetailedDescription_ID
RouteDetailedDescription_IsHeadphones
RouteDetailedDescription_IsVoiceProcessingSupported
RouteDetailedDescription_IsLiveListenSupported
RouteDetailedDescriptionKey_EndpointType
RouteDetailedDescription_SelectedDataSource
RouteDetailedDescription_DataSources
RouteDetailedDescription_HiddenDataSources
portType
portName
hasHardwareVoiceCallProcessing
dataSources
selectedDataSource
T@"AVAudioSessionDataSourceDescription",R
preferredDataSource
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioNode.mm
-[AVAudioNode installTapOnBus:bufferSize:format:block:]
tapBlock
NULL != engine
-[AVAudioNode removeTapOnBus:]
-[AVAudioNode destinationForMixer:bus:]
mixer
impl
T^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}B^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}},R,N
engine
T@"AVAudioEngine",R,N
numberOfInputs
numberOfOutputs
lastRenderTime
AUAudioUnit
T@"AUAudioUnit",R,N
latency
outputPresentationLatency
-[AVAudioMixingDestination destinationForMixer:bus:]
connectionPoint
T@"AVAudioConnectionPoint",R,N
GetMixingDestination
inMixerAVNode
WillDisconnectFromMixer
mixingDest
aupreset
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioUnitSampler.mm
-[AVAudioUnitSampler loadInstrumentAtURL:error:]
error
-[AVAudioUnitSampler loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:]
-[AVAudioUnitSampler loadAudioFilesAtURLs:error:]
stereoPan
masterGain
globalTuning
AVAudioIOUnit
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioIONodeImpl.mm
AUI().AddV2PropertyListener(propID, IOUnitPropertyListener, this)
_GetHWFormat
hwFormat
SetOutputFormat
_isInput
IsFormatSampleRateAndChannelCountValid(hwFormat)
format.sampleRate == hwFormat.sampleRate
SetInputFormat
!_isInput
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioSequencer.mm
-[AVAudioSequencer(AVAudioSequencer_Player) prepareToPlay]
impl->PrepareToPlay()
-[AVAudioSequencer(AVAudioSequencer_Player) startAndReturnError:]
impl->Start()
-[AVAudioSequencer(AVAudioSequencer_Player) stop]
impl->Stop()
currentPositionInSeconds
currentPositionInBeats
-[AVAudioSequencer loadFromURL:options:error:]
impl->LoadFromFile((CFURLRef)fileURL, (UInt32)options)
-[AVAudioSequencer loadFromData:options:error:]
impl->LoadFromData((CFDataRef)data, (UInt32)options)
-[AVAudioSequencer writeToURL:SMPTEResolution:replaceExisting:error:]
impl->WriteToFile((CFURLRef)fileURL, (SInt32)resolution, replace)
-[AVAudioSequencer dataWithSMPTEResolution:error:]
impl->WriteToData(&outData, (SInt32)SMPTEResolution)
tracks
tempoTrack
T@"AVMusicTrack",R,N
userInfo
-[AVMusicTrack setNumberOfLoops:]
numberOfLoops != 0
destinationAudioUnit
T@"AVAudioUnit",&,N
destinationMIDIEndpoint
loopRange
T{_AVBeatRange=dd},N
loopingEnabled
TB,N,GisLoopingEnabled
offsetTime
muted
TB,N,GisMuted
soloed
TB,N,GisSoloed
lengthInBeats
lengthInSeconds
timeResolution
%.6f s
%ld fr (/%.f Hz)
%.6f rs
<AVAudioTime %p: %s %s %s>
hostTimeValid
TB,R,N,GisHostTimeValid
hostTime
sampleTimeValid
TB,R,N,GisSampleTimeValid
sampleTime
audioTimeStamp
GetAudioDSPManager
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioUnitDSPGraph.mm
-[AVAudioUnitDSPGraph loadAudioDSPManager]_block_invoke
-[AVAudioUnitDSPGraph dspGraphURL]
-[AVAudioUnitDSPGraph auProcessingStripURL]
dspGraphURL
auProcessingStripURL
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioUnitEffect.mm
-[AVAudioUnitEffect initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Effect) || (audioComponentDescription.componentType == kAudioUnitType_MusicEffect) || (audioComponentDescription.componentType == kAudioUnitType_Panner) || (audioComponentDescription.componentType == kAudioUnitType_RemoteEffect) || (audioComponentDescription.componentType == kAudioUnitType_RemoteMusicEffect)
v16@?0q8
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioPlayerNode.mm
-[AVAudioPlayerNode scheduleBuffer:atTime:options:completionCallbackType:completionHandler:]
when == nil || when.sampleTimeValid || when.hostTimeValid
-[AVAudioPlayerNode scheduleFile:atTime:completionCallbackType:completionHandler:]
file != nil
-[AVAudioPlayerNode scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:]
stream != nil
startFrame >= 0
numberFrames > 0
-[AVAudioPlayerNode nodeTimeForPlayerTime:]
playerTime == nil || playerTime.sampleTimeValid || playerTime.hostTimeValid
-[AVAudioPlayerNode playerTimeForNodeTime:]
nodeTime == nil || nodeTime.sampleTimeValid || nodeTime.hostTimeValid
AVAudioPlayerNodeImpl.CompletionHandlerQueue
CommandQueue
StartImpl
_engine->IsRunning()
player started when in a disconnected state
player started when engine not running
nearFutureTime.sampleTimeValid
when.hostTimeValid
inTimeFull.sampleTimeValid
ScheduleBuffer
_outputFormat.channelCount == buffer.format.channelCount
HandleCompletionOfCommand
completionHandler != nil
_fileNumberOfBufferCommands > 0
CallCompletionHandler
completionHandler
SignalEndOfRender
completionHandlerWrapperPtr && completionHandlerWrapperPtr->Block()
PerformBufferCommand
ResolveToPlayerSampleTime(cmd->_when, sampleTime)
ResolveToPlayerSampleTime
!IsInManualRenderingMode()
playerTime && playerTime.sampleTimeValid
AVVoiceTriggerClient init
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVVoiceController/AVVoiceTriggerClient.mm
-[AVVoiceTriggerClient init]
-[AVVoiceTriggerClient dealloc]
handleMediaServerReset:
voiceTriggerPastDataFramesAvailable
voiceTriggerBlock
T@?,C,N,V_voiceTriggerBlock
speakerStateChangedBlock
T@?,C,N,V_speakerStateChangedBlock
speakerMuteStateChangedBlock
T@?,C,N,V_speakerMuteStateChangedBlock
serverCrashedBlock
T@?,C,N,V_serverCrashedBlock
serverResetBlock
T@?,C,N,V_serverResetBlock
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioUnit.mm
+[AVAudioUnit instantiateWithComponentDescription:options:completionHandler:]
comp != NULL
v20@?0^{OpaqueAudioComponentInstance=}8i16
T@"AUAudioUnit",R,D,N
AVAudioEngineConfigurationChangeNotification
avae
avae_verbose
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AVAudioEngine.mm
-[AVAudioEngine prepare]
musicSequence
T^{OpaqueMusicSequence=},N
T@"AVAudioOutputNode",R,N
inputNode
T@"AVAudioInputNode",R,N
mainMixerNode
T@"AVAudioMixerNode",R,N
TB,R,N,GisRunning
autoShutdownEnabled
TB,N,GisAutoShutdownEnabled
manualRenderingBlock
T@?,R,N
isInManualRenderingMode
manualRenderingMode
manualRenderingFormat
manualRenderingMaximumFrameCount
manualRenderingSampleTime
AttachNode
node != nil
!IsInternalNode(node)
nil == owningEngine || GetEngine() == owningEngine
nodeimpl->HasEngineImpl()
DetachNode
!nodeimpl->HasEngineImpl()
GetIOUnit
GetOutputNode
_outputNode != nil
GetInputNode
_inputNode != nil
UpdateOutputNode
[_outputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode]
AreRenderingModesIdentical(_outputNode)
UpdateInputNode
[_inputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode]
AreRenderingModesIdentical(_inputNode)
node1 != nil && node2 != nil
[_nodes containsObject: node1] && [_nodes containsObject: node2]
nil != sourceNode && nil != destNodes && [destNodes count] > 0
[_nodes containsObject: sourceNode]
object && [object isKindOfClass: [AVAudioConnectionPoint class]]
[_nodes containsObject: connPoint.node]
[_nodes containsObject: node]
_graph->DisconnectInput(node, bus)
_graph->DisconnectOutput(node, bus)
_graph->DisconnectAllInputs(node)
_graph->DisconnectAllOutputs(node)
node1 != nil && node2 != nil && node1 != node2
object && [object isKindOfClass: [AVAudioNode class]]
sourceNode != nil && destNode != nil
_graph->DisconnectMIDI(sourceNode, destNode)
sourceNode != nil && destNodes != nil && destNodes.count > 0
_graph->DisconnectMIDI(sourceNode, destNodes)
_graph->DisconnectAllMIDIInputs(node)
_graph->DisconnectAllMIDIOutputs(node)
node != nil && [_nodes containsObject: node]
_graph->Uninitialize()
Pause
_graph->Stop()
CheckCanPerformIO
canPerformIO
DisableManualRenderingMode
q28@?0I8^{AudioBufferList=I[1{AudioBuffer=II^v}]}12^i20
CreateGraphNode
_graph->AddNode(inNode)
DestroyGraphNode
_graph->RemoveNode(inNode)
_graph->InstallTapOnNode(inNode, bus, bufferSize, format, tapBlock)
_graph->RemoveTapOnNode(inNode, bus)
_graph->SetSequence(inSequence)
AVFormatIDKey
AVSampleRateKey
AVNumberOfChannelsKey
AVLinearPCMBitDepthKey
AVLinearPCMIsBigEndianKey
AVLinearPCMIsFloatKey
AVLinearPCMIsNonInterleaved
AVAudioFileTypeKey
AVEncoderQualityKey
AVEncoderQualityForVBRKey
AVEncoderBitRateStrategyKey
AVEncoderBitRateKey
AVEncoderBitRatePerChannelKey
AVEncoderBitDepthHintKey
AVSampleRateConverterAlgorithmKey
AVSampleRateConverterQualityKey
AVChannelLayoutKey
AVAudioBitRateStrategy_Constant
AVAudioBitRateStrategy_LongTermAverage
AVAudioBitRateStrategy_VariableConstrained
AVAudioBitRateStrategy_Variable
AVSampleRateConverterAlgorithm_Normal
AVSampleRateConverterAlgorithm_Mastering
AVSampleRateConverterAlgorithm_MinimumPhase
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/Source/AVFAudio/AVAudioEngine/AUInterface.mm
AddRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &inRenderCallback, sizeof(inRenderCallback))
RemoveRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &rcb, sizeof(rcb))
AUInterfaceBaseV3
comp != nullptr
AudioComponentInstanceNew(comp, &_auv2)
_auv2 != nullptr
_auv3 == nil
_auv3 != nil
nil != midiEventBlock
SetFormat
[[busArray objectAtIndexedSubscript:(NSUInteger)element] setFormat:format error:&nsErr]
SetNumberInputs
[[auv3() inputBusses] setBusCount:(NSUInteger)numberInputs error:&nsErr]
SetNumberOutputs
[[auv3() outputBusses] setBusCount:(NSUInteger)numberOutputs error:&nsErr]
SendMIDIEvent
nil != ScheduleMIDIEventBlock()
nullptr != midiBytes
AddRenderObserver
v32@?0I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}12I20q24
_AVAE_CheckSuccessAndNoNSError
true
%s: returned %s, error %@
realloc failed
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/Utility/CALog.cpp
RegisterScope
warning
note
notice
info
details
minutiae
spew
v16@?0^v8
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/PublicUtility/AUOutputBL.cpp
Prepare
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/Utility/XMachServer.cpp
CreateMachPort
ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
ret = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND)
DeviceClassNumber
/9luHerXthRoPoNt/PVkTg
nVh/gwNpy7Jv1NOk00CMrw
InternalBuild
ReleaseType
Carrier
IsUIBuild
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/PublicUtility/CAMutex.cpp
CAMutex
Lock
Unlock
%04d-%02d-%02d 
%02d:%02d:%02d.%06d
%02d:%02d:%02d.%03d
%02X
Int16
Int32
Int8.24
Float32
Float64
, non-inter
, inter
%2d ch, %6.0f Hz, %s%s
%2d ch, %6.0f Hz, 'freq'
%2d ch, %6.0f Hz
%2d ch, %6.0f Hz, %s (0x%08X) 
 big-endian
 little-endian
 signed
 unsigned
integer
float
packed in %d bytes
unpacked in %d bytes
 high-aligned
 low-aligned
, deinterleaved
%d.%d
%s-bit%s%s %s%s%s%s%s
from %d-bit source, 
from UNKNOWN source bit depth, 
%d frames/packet
%d bits/channel, %d bytes/packet, %d frames/packet, %d bytes/frame
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/PublicUtility/CAStreamBasicDescription.h
PackednessIsSignificant
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/PublicUtility/CAGuard.cpp
CAGuard
Wait
WaitFor
Notify
NotifyAll
RealtimeMessenger.mServiceQueue
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/Utility/RealtimeMessenger.cpp
PerformAsync
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-284.57.1/CoreAudioUtility/Source/PublicUtility/CAPThread.cpp
SetPriority
SetTimeConstraints
AVAudioIONode
AVAudioOutputNode
AVAudioInputNode
AVAudioMixing
AVAudioStereoMixing
NSObject
AVAudio3DMixing
AVAudioConnectionPoint
AVAudioSessionDataSourceDescription
AVVCRecordDeviceInfo
AVVoiceControllerInternal
AVVoiceController_Priv
AVVoiceController
AVAudioUnitComponent
SpeexEndpointer
Endpointer
SpeexEndpointer_Priv
AVAudioUnitTimeEffect
AVAudioSessionRouteDescription
AVAudioSessionPrivate
AVAudioUnitComponentManager
AVAudioUnitDelay
VoiceVerificationEndpointer
AVAudioUnitVarispeed
AVAudioRemoteInputPlugin
AVVCRemoteInput
AVAudioRemoteInputPluginDelegate
AVAudioUnitReverb
AVAudioUnitTimePitch
AudioPlayerImpl
AVAudioPlayerPriv
AVAudioPlayer
AVAudioUnitGenerator
AVAudioRecorder
AVAudioSessionParticipant
AVAudioEndpointDetector
AVEndpointVADEventHandler
AVAudioSessionChannelDescription
AVAudioChannelLayout
NSSecureCoding
NSCoding
AVAudioDeviceTestServiceProtocol
AVAudioDeviceTest
AVAudioConverter
Encoding
AVVCMetricsManager
AVAudioUnitDistortion
AVAudioMixerNode
AVAudioClock
AVMIDIPlayer
AVMIDIPlayerPriv
AVAudioUnitMIDIInstrument
AVAudioBuffer
NSCopying
NSMutableCopying
AVAudioPCMBuffer
AVAudioCompressedBuffer
AVAudioUnitSplitter
AVAudioUnitEQFilterParameters
AVAudioUnitEQ
AVAudioFormat
AVAudioDeviceTestResult
AVAudioDeviceTestSequence
AVAudioDeviceTestProcessingChain
AVSpeechSynthesisVoice
AVSpeechUtterance
AVSpeechSynthesizer
CommonImplementation
AVVCAudioBuffer
AVVCAudioBufferPriv
AVAudioEnvironmentDistanceAttenuationParameters
AVAudioEnvironmentReverbParameters
AVAudioEnvironmentNode
AVAudioSession
AVAudioFile
AVAudioSessionPortDescription
AVAudioNode
AVAudioMixingDestination
AVAudioUnitSampler
AVAudioSequencer_Player
AVAudioSequencer
AVMusicTrack
AVAudioTime
AVAudioUnitDSPGraph
AVAudioUnitEffect
AVAudioPlayerNode
AVVoiceTriggerClient
AVAudioUnit
AVAudioEngine
@28@0:8^{AVAudioIOUnit=^^?@^{AVAudioEngineImpl}{unique_ptr<AUInterfaceIOV3, std::__1::default_delete<AUInterfaceIOV3> >={__compressed_pair<AUInterfaceIOV3 *, std::__1::default_delete<AUInterfaceIOV3> >=^{AUInterfaceIOV3}}}@@}16B24
d16@0:8
^{OpaqueAudioComponentInstance=}16@0:8
v24@0:8@16
B16@0:8
q16@0:8
B28@0:8q16B24
B28@0:8^{AVAudioIOUnit=^^?@^{AVAudioEngineImpl}{unique_ptr<AUInterfaceIOV3, std::__1::default_delete<AUInterfaceIOV3> >={__compressed_pair<AUInterfaceIOV3 *, std::__1::default_delete<AUInterfaceIOV3> >=^{AUInterfaceIOV3}}}@@}16B24
B28@0:8@16I24
@16@0:8
I16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
f16@0:8
v20@0:8f16
v24@0:8q16
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@32@0:8@16Q24
@"AVAudioMixingDestination"32@0:8@"AVAudioNode"16Q24
B32@0:8@16@?24
v16@0:8
@"AVAudioNode"
@36@0:8@16@24I32
@20@0:8I16
B32@0:8@16^@24
^{DataSourceDescriptionImpl=I@@@@@@@@}16@0:8
@24@0:8@16
@"NSString"
@"NSUUID"
^{ControllerImpl=^^?@@{CAStreamBasicDescription=dIIIIIIII}dB^{AudioQueueLevelMeterState}^{GenericRunLoopThread}i^{OpaqueAudioConverter}IQBBBf@^{__CFDictionary}I@@{CAStreamBasicDescription=dIIIIIIII}d^{OpaqueAudioQueue}i@I^^{AudioQueueBuffer}iBBBBBBfI{CAStreamBasicDescription=dIIIIIIII}q^{OpaqueAudioQueue}{map<AVVoiceAlertType, NSURL *, std::__1::less<AVVoiceAlertType>, std::__1::allocator<std::__1::pair<const AVVoiceAlertType, NSURL *> > >={__tree<std::__1::__value_type<AVVoiceAlertType, NSURL *>, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, NSURL *>, std::__1::less<AVVoiceAlertType>, true>, std::__1::allocator<std::__1::__value_type<AVVoiceAlertType, NSURL *> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<AVVoiceAlertType, NSURL *>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, NSURL *>, std::__1::less<AVVoiceAlertType>, true> >=Q}}}{map<AVVoiceAlertType, AudioQueueBuffer *, std::__1::less<AVVoiceAlertType>, std::__1::allocator<std::__1::pair<const AVVoiceAlertType, AudioQueueBuffer *> > >={__tree<std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, std::__1::less<AVVoiceAlertType>, true>, std::__1::allocator<std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, std::__1::less<AVVoiceAlertType>, true> >=Q}}}iiiCCCiifdQQffB@^{OpaqueAudioFileID}I^{AudioFormatListItem}IQ*{AudioFilePacketTableInfo=qii}qqBii@BBBBidddBBB@CiBBBBIB@iBIq@[4^{MyMutex}]iiBii[75{ZeroRunLog=ii}]B^{AVVCRecordingEngine}^{AVVCPluginRecordingEngine}^{AVVCAudioQueueRecordingEngine}@@}16@0:8
v32@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16Q24
v36@0:8^{AudioBufferList=I[1{AudioBuffer=II^v}]}16I24Q28
v32@0:8@16Q24
v32@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}CC}16Q24
v24@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}CC}16
v20@0:8i16
v20@0:8B16
B28@0:8i16q20
@32@0:8@16^@24
v24@0:8Q16
B28@0:8@16i24
B20@0:8i16
i32@0:8Q16@24
B24@0:8^@16
B32@0:8Q16^@24
B24@0:8d16
i16@0:8
v24@0:8d16
f24@0:8Q16
@36@0:8{AudioComponentDescription=IIIII}16
@44@0:8{AudioComponentDescription=IIIII}16^{AVAudioUnitComponentManagerImpl=^^?^{__CFArray}^{__CFArray}^{__CFArray}}36
^{OpaqueAudioComponent=}16@0:8
{AudioComponentDescription=IIIII}16@0:8
B32@0:8q16q24
B36@0:8{AudioComponentDescription=IIIII}16
i24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
B28@0:8d16I24
B28@0:8^{AudioStreamBasicDescription=dIIIIIIII}16I24
i28@0:8^f16I24
^{RouteDescriptionImpl=@@@}16@0:8
@32@0:8@16@24
@24@0:8^{_NSZone=}16
@24@0:8@?16
@24@0:8@"<AVAudioRemoteInputPluginDelegate>"16
@"NSArray"16@0:8
v32@0:8@16@24
v32@0:8@"<AVAudioRemoteInputPlugin>"16@"<AVAudioRemoteInputDevice>"24
@24@0:8^@16
v24@0:8^{AVVCPluginRecordingEngine=^^?^{ControllerImpl}^{OpaqueAudioFileID}i@@IIfiCC}16
@"NSMutableArray<AVAudioRemoteInputPlugin>"
^{AVVCPluginRecordingEngine=^^?^{ControllerImpl}^{OpaqueAudioFileID}i@@IIfiCC}
@"<AVAudioPlayerDelegate>"
@"NSData"
@"NSURL"
@"NSDictionary"
@"AVAudioFormat"
@"NSArray"
@"AVAudioSession"
^{AVAudioPlayerCpp=^{__CFData}^{__CFURL}^{__CFDictionary}I{AudioStreamBasicDescription=dIIIIIIII}{AudioStreamBasicDescription=dIIIIIIII}Q*I^{AudioFormatListItem}I^{OpaqueAudioFileID}I^{OpaqueAudioQueue}qqqddddIdi{AudioFilePacketTableInfo=qii}iiiBBBBIBBBBdddddd^{__CFString}I^{AudioQueueLevelMeterState}[3^{AudioQueueBuffer}]^{AudioQueueBuffer}iBBBBB^{AudioQueueBuffer}BQIBBBBqiII^v^?I@I^{TEMP_AudioQueueChannelAssignment}}
@"NSObject<OS_dispatch_queue>"
@40@0:8@16@24^@32
v28@0:8f16d20
@"AVAudioSession"16@0:8
v24@0:8@"AVAudioSession"16
^{AudioRecorderImpl=@@@@@@I{AudioStreamBasicDescription=dIIIIIIII}^{OpaqueAudioFileID}^{OpaqueAudioQueue}qqqdddQ*BBBBBBBB^{AudioQueueLevelMeterState}[4^{AudioQueueBuffer}]^{AudioQueueBuffer}BQBi@}16@0:8
B32@0:8d16d24
v40@0:8i16I20d24r^v32
^{EndpointVAD3Host=^^?fff{CAStreamBasicDescription=dIIIIIIII}ffff{AVAudioEndpointDetectorUtility=^v}@^{OpaqueAudioComponentInstance}{unique_ptr<EndpointVAD3FileSaver, std::__1::default_delete<EndpointVAD3FileSaver> >={__compressed_pair<EndpointVAD3FileSaver *, std::__1::default_delete<EndpointVAD3FileSaver> >=^{EndpointVAD3FileSaver}}}{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}{vector<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> >, std::__1::allocator<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> > > >=^{vector<AVVADState, std::__1::allocator<AVVADState> >}^{vector<AVVADState, std::__1::allocator<AVVADState> >}{__compressed_pair<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> > *, std::__1::allocator<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> > > >=^{vector<AVVADState, std::__1::allocator<AVVADState> >}}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> >, std::__1::allocator<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> > > >=^{vector<AVVADState, std::__1::allocator<AVVADState> >}^{vector<AVVADState, std::__1::allocator<AVVADState> >}{__compressed_pair<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> > *, std::__1::allocator<std::__1::vector<AVVADState, std::__1::allocator<AVVADState> > > >=^{vector<AVVADState, std::__1::allocator<AVVADState> >}}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<std::__1::vector<unsigned int, std::__1::allocator<unsigned int> >, std::__1::allocator<std::__1::vector<unsigned int, std::__1::allocator<unsigned int> > > >=^{vector<unsigned int, std::__1::allocator<unsigned int> >}^{vector<unsigned int, std::__1::allocator<unsigned int> >}{__compressed_pair<std::__1::vector<unsigned int, std::__1::allocator<unsigned int> > *, std::__1::allocator<std::__1::vector<unsigned int, std::__1::allocator<unsigned int> > > >=^{vector<unsigned int, std::__1::allocator<unsigned int> >}}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<std::__1::vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > >, std::__1::allocator<std::__1::vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > > > >=^{vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > >}^{vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > >}{__compressed_pair<std::__1::vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > > *, std::__1::allocator<std::__1::vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > > > >=^{vector<std::__1::vector<float, std::__1::allocator<float> >, std::__1::allocator<std::__1::vector<float, std::__1::allocator<float> > > >}}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{basic_ofstream<char, std::__1::char_traits<char> >=^^?{basic_filebuf<char, std::__1::char_traits<char> >=^^?{locale=^{__imp}}*********[8c]Q*Q^{__sFILE}^{codecvt<char, char, __mbstate_t>}(?=[128c]q)(?=[128c]q)IIBBB}^^?IqqII^v^v^^?^iQQ^qQQ^^vQQ^{basic_ostream<char, std::__1::char_traits<char> >}i}}16@0:8
i52@0:8@16d24B32f36f40f44f48
i88@0:8@16@24@32@40@48@56@64@72@80
i32@0:8^{AudioBufferList=I[1{AudioBuffer=II^v}]}16I24I28
{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16@0:8
i20@0:8i16
v48@0:8i16i20d24@32d40
^{OpaqueExtAudioFile=}24@0:8@16
q24@0:8r^{OpaqueExtAudioFile=}16
v40@0:8i16I20d24d32
v36@0:8r^I16I24d28
v36@0:8@16I24d28
I20@0:8I16
@24@0:8I16I20
I24@0:8@16
@28@0:8@16I24
I32@0:8@16@24
v36@0:8^@16^@24I32
I24@0:8I16I20
v36@0:8^I16^I24I32
r^{VAD3Configuration=}16@0:8
@24@0:8r^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}16
v32@0:8^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}16@24
@24@0:8r^{vector<float, std::__1::allocator<float> >=^f^f{__compressed_pair<float *, std::__1::allocator<float> >=^f}}16
v32@0:8^{vector<float, std::__1::allocator<float> >=^f^f{__compressed_pair<float *, std::__1::allocator<float> >=^f}}16@24
@24@0:8r^{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}16
v32@0:8^{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}16@24
^{ChannelDescriptionImpl=@@II}16@0:8
@24@0:8r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16@0:8
^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}
v32@0:8@16@?24
v32@0:8@"AVAudioDeviceTestSequence"16@?<v@?@"NSArray"@"NSError">24
@"NSXPCConnection"
@"<AVAudioDeviceTestServiceProtocol>"
{AVAudioConverterPrimeInfo=II}16@0:8
v24@0:8{AVAudioConverterPrimeInfo=II}16
B40@0:8@16@24^@32
q40@0:8@16^@24@?32
^{CAMutex=^^?*^{_opaque_pthread_t}{_opaque_pthread_mutex_t=q[56c]}}16@0:8
i60@0:8{CAStreamBasicDescription=dIIIIIIII}16I56
i52@0:8{AudioBufferList=I[1{AudioBuffer=II^v}]}16I40r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}44
v56@0:8{CAStreamBasicDescription=dIIIIIIII}16
@"NSMutableDictionary"
{AUPreset=i^{__CFString}}24@0:8q16
v28@0:8f16Q20
@24@0:8^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}B^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}}16
@24@0:8^I16
Q24@0:8d16
d24@0:8Q16
v24@0:8@?16
^{MIDIPlayerImpl=^{OpaqueAUGraph}^{OpaqueMusicPlayer}^{OpaqueMusicSequence}d@?@}16@0:8
v28@0:8C16C20C24
v24@0:8C16C20
v24@0:8S16C20
v32@0:8C16C20C24C28
v20@0:8I16
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^^f16@0:8
^^i16@0:8
^^s16@0:8
B32@0:8@16q24
@24@0:8Q16
f44@0:8Q16^f24q32I40
@36@0:8@16I24q28
^{AudioStreamPacketDescription=qII}16@0:8
^v16@0:8
@24@0:8^{AVAudioUnitEQFilterParametersImpl=^^?}16
@32@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16@24
@24@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16
@28@0:8d16I24
@32@0:8d16@24
@40@0:8Q16d24I32B36
@44@0:8Q16d24B32@36
@24@0:8^{opaqueCMFormatDescription=}16
r^{opaqueCMFormatDescription=}16@0:8
r^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
{AudioStreamBasicDescription="mSampleRate"d"mFormatID"I"mFormatFlags"I"mBytesPerPacket"I"mFramesPerPacket"I"mBytesPerFrame"I"mChannelsPerFrame"I"mBitsPerChannel"I"mReserved"I}
@"AVAudioChannelLayout"
@40@0:8@16q24q32
@"AVAudioDeviceTestProcessingChain"
@"AVSpeechSynthesisVoice"
@"NSAttributedString"
B24@0:8q16
@"<AVSpeechSynthesizerDelegate>"
v28@0:8r^{AudioStreamPacketDescription=qII}16i24
^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
C16@0:8
@36@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}CC}16i24Q28
@24@0:8^{AVAudioEnvironmentNodeImpl=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}B^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}i{unique_ptr<AUInterfaceBaseV3, std::__1::default_delete<AUInterfaceBaseV3> >={__compressed_pair<AUInterfaceBaseV3 *, std::__1::default_delete<AUInterfaceBaseV3> >=^{AUInterfaceBaseV3}}}f{AVAudio3DPoint=fff}{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}{AVAudio3DAngularOrientation=fff}{map<AVAudio3DMixingImpl *, unsigned int, std::__1::less<AVAudio3DMixingImpl *>, std::__1::allocator<std::__1::pair<AVAudio3DMixingImpl *const, unsigned int> > >={__tree<std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, std::__1::__map_value_compare<AVAudio3DMixingImpl *, std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, std::__1::less<AVAudio3DMixingImpl *>, true>, std::__1::allocator<std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<AVAudio3DMixingImpl *, std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, std::__1::less<AVAudio3DMixingImpl *>, true> >=Q}}}@Ifff@@Bffff}16
v40@0:8{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16
{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16@0:8
v28@0:8{AVAudio3DAngularOrientation=fff}16
{AVAudio3DAngularOrientation=fff}16@0:8
B40@0:8Q16@24^@32
B40@0:8@16Q24^@32
B48@0:8@16@24Q32^@40
B56@0:8@16@24Q32Q40^@48
B28@0:8B16^@20
B36@0:8B16Q20^@28
v32@0:8Q16@?24
B32@0:8q16^@24
B36@0:8B16q20^@28
B32@0:8d16^@24
B28@0:8f16^@20
^{AVAudioSessionImpl=@^{GenericRunLoopThread}{KVOProperty<float>=^^?f@@B}{KVOProperty<float>=^^?f@@B}{KVONSArrayProperty=^^?@@@B}{KVONSArrayProperty=^^?@@@B}{KVOProperty<unsigned int>=^^?I@@B}{KVOProperty<unsigned int>=^^?I@@B}{KVONSObjectProperty<NSArray *>=^^?@@@B}{KVOProperty<unsigned int>=^^?I@@B}@B{KVOProperty<unsigned int>=^^?I@@B}{KVOProperty<unsigned int>=^^?I@@B}IIIB{SessionConnector={shared_ptr<std::__1::function<void (avfaudio::SessionConnector::ConnectionResult)> >=^{function<void (avfaudio::SessionConnector::ConnectionResult)>}^{__shared_weak_count}}}Q}16@0:8
@20@0:8B16
v24@0:8{ConnectionResult=iI}16
B32@0:8I16B20^@24
v28@0:8@16B24
@44@0:8@16Q24B32^@36
@52@0:8@16@24Q32B40^@44
B36@0:8@16I24^@28
B28@0:8@16B24
^{PortDescriptionImpl=@@@@@BBBQ@@@@}16@0:8
B24@0:8^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}B^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}}16
B32@0:8@16Q24
v44@0:8Q16I24@28@?36
^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}B^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}}16@0:8
@24@0:8^{AVAudioMixingImpl=^^?ffIff{AVAudio3DPoint=fff}ff}16
^{AVAudioMixingImpl=^^?ffIff{AVAudio3DPoint=fff}ff}16@0:8
B44@0:8@16C24C28C32^@36
Q32@0:8d16^@24
d32@0:8Q16^@24
@24@0:8^{AVAudioSequencerImpl=^{OpaqueMusicPlayer}^{OpaqueMusicSequence}@@@@}16
B44@0:8@16q24B32^@36
@32@0:8q16^@24
d24@0:8d16
@24@0:8^{MusicTrackImpl=^{OpaqueMusicTrack}@BI}16
^{OpaqueMusicTrack=}16@0:8
{_AVBeatRange=dd}16@0:8
v32@0:8{_AVBeatRange=dd}16
@32@0:8q16d24
@40@0:8Q16q24d32
@32@0:8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16d24
{AudioTimeStamp="mSampleTime"d"mHostTime"Q"mRateScalar"d"mWordClockTime"Q"mSMPTETime"{SMPTETime="mSubframes"s"mSubframeDivisor"s"mCounter"I"mType"I"mFlags"I"mHours"s"mMinutes"s"mSeconds"s"mFrames"s}"mFlags"I"mReserved"I}
v32@0:8q16@?24
v40@0:8@16q24@?32
v48@0:8@16@24Q32@?40
v56@0:8@16@24Q32q40@?48
v40@0:8@16@24@?32
v48@0:8@16@24q32@?40
v52@0:8@16q24I32@36@?44
v60@0:8@16q24I32@36q44@?52
v28@0:8B16@?20
@?16@0:8
v48@0:8{AudioComponentDescription=IIIII}16I36@?40
B24@0:8f16I20
f20@0:8I16
v56@0:8@16@24Q32Q40@48
v40@0:8@16@24@32
v48@0:8@16@24Q32@40
v24@0:8^{OpaqueMusicSequence=}16
^{OpaqueMusicSequence=}16@0:8
^{AVAudioEngineImpl=@^{AVAudioEngineGraph}BB@@@@^{AVAudioIOUnit}@iB{unique_ptr<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)>, std::__1::default_delete<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)> > >={__compressed_pair<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)> *, std::__1::default_delete<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)> > >=^{AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)>}}}}16@0:8
B44@0:8q16@24I32^@36
q36@0:8I16@20^@28
v48@0:8@16@24@32@?40
%s:%d:%s: required condition is false: [%s:%d:%s: (%s)]
%s:%d:%s: RegisterObject: registering %p
%s:%d:%s: UnregisterObject: unregistering %p
%s:%d:%s:  ASSERTION FAILED: unregistering a nonexistent object!
%s:%d:%s: Unknown ID for DataSource
%s:%d:%s: Unknown name for DataSource
%s:%d:%s: Unknown owning Port ID for DataSource
%s:%d:%s: Unknown selected polar pattern for DataSource.  There are %lu polar patterns
%s:%d:%s: nil data source description
%s:%d:%s: Not expected to see error code %d!
%s:%d:%s: -- %s failed to find a match for string "%@"
%s:%d:%s: Invalid parameter.  PortID: %@, DataSourceID: %@
%s:%d:%s: Returning %@
%s:%d:%s: Nil Port parameter
%s:%d:%s: AudioSessionGetProperty failed with code: %d
%s:%d:%s: AudioSessionGetProperty (%s) failed with error: %s
%s:%d:%s: setSessionNotifications: setting up notifications
%s:%d:%s: removeSessionNotifications: removing all notifications
%s:%d:%s: #### hardwareConfigChanged: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
%s:%d:%s:  ASSERTION FAILED: handleInterruption: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleInterruption: %@
%s:%d:%s:  ASSERTION FAILED: handleRouteChange: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleRouteChange: %@
%s:%d:%s:  ASSERTION FAILED: handleMediaServerDeath: called with NULL impl!
%s:%d:%s:  ASSERTION FAILED: handleMediaServerReset: called with NULL impl!
%s:%d:%s:  ASSERTION FAILED: handlePluginDidPublishDevice: called with NULL impl!
%s:%d:%s:  ASSERTION FAILED: handlePluginDidUnpublishDevice: called with NULL impl!
%s:%d:%s: #### beganRecording: (success = %d status = %d) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartRecording: variants
%s:%d:%s: calling lpcmRecordBufferReceived:buffer
%s:%d:%s: calling voiceControllerRecordBufferAvailable:buffer
%s:%d:%s: myBuffer->mAudioData : %p, myBuffer->mAudioDataByteSize : %d
%s:%d:%s: finishedRecording -> called after object destroyed -- ignoring call
%s:%d:%s: finishedRecording -> called after dealloc -- ignoring call
%s:%d:%s: #### AVVoiceController: Recording finished (success = %d status = %d) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopRecording:forReason:
%s:%d:%s: startpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### startpointDetected: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectStartpoint:
%s:%d:%s: interspeechPointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### interspeechPointDetected: time %.2f seconds ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectEndpoint:ofType:
%s:%d:%s: endpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### endpointDetected: time %.2f seconds ####
%s:%d:%s: #### beganPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartPlaying:successfully:
%s:%d:%s: finishedPlaying -> called after object destroyed -- ignoring call
%s:%d:%s: #### finishedPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopPlaying:forReason:
%s:%d:%s: Calling alert playback finished delegate. Type: %d
%s:%d:%s: Calling record delegate's voiceControllerWillSetAudioSessionActive. Going active? : %d
%s:%d:%s: Calling record delegate's voiceControllerDidSetAudioSessionActive. Going active? : %d
%s:%d:%s: setStopOnBargeInEnabled: barge-in previously detected -- stopping playback
%s:%d:%s: prepareRecordWithSettings should be called first before asking for number of channels
%s:%d:%s: #### AVVoiceController: playAlertSoundForType: %d overrideMode : %d ####
%s:%d:%s: playAlertSoundForType: Session check failed: %s
%s:%d:%s: Current Playback Route %@
%s:%d:%s: playAlert: calling AudioServicesPlaySystemSoundWithOptions with sound ID %d
%s:%d:%s: playAlert: Finished playing the alert beep
%s:%d:%s: playAlertSoundForType: Illegal alertType
%s:%d:%s: playAlertSoundForType: alert type - None is not supported,
%s:%d:%s: #### AVVoiceController: initWithContext: [self == %p]. with context:%{audio:4CC}d %@
%s:%d:%s: initWithContext: calling setSessionProperties
%s:%d:%s: AVVoiceController: initWithContext failure
%s:%d:%s: #### initWithContext finished [self = %p] ####
%s:%d:%s: #### AVVoiceController: prewarmAudioSession: ####
%s:%d:%s: #### AVVoiceController: dealloc [self == %p] ####
%s:%d:%s: #### AVVoiceController: exiting dealloc ####
%s:%d:%s: #### AVVoiceController: releaseAudioSession: [self = %p] ####
%s:%d:%s: #### AVVoiceController: releaseAudioSession:options [self = %p] ####
%s:%d:%s: #### AVVoiceController: willAcceptContext: with context:%{audio:4CC}d %@
%s:%d:%s: ### unimplemented in this platform
%s:%d:%s: #### AVVoiceController[self = %p]: setCurrentContext: with context:%{audio:4CC}d %@
%s:%d:%s: #### setCurrentContext:error finished [self = %p]####
%s:%d:%s: #### AVVoiceController[self = %p]: prepareRecordWithSettings: %@ 
%s:%d:%s: prepareRecordWithSettings failed with internal error %s
%s:%d:%s: #### prepareRecordWithSettings finished ####
%s:%d:%s: #### AVVoiceController: setAlertSoundFromURL: forType: %d ####
%s:%d:%s: setAlertSoundFromURL:forType: Illegal alertType
%s:%d:%s: #### AVVoiceController: playAlertSoundForType: %d [self = %p]####
%s:%d:%s: #### AVVoiceController: resetEndpointer ####
%s:%d:%s: #### AVVoiceController: playRecordStartingAlertAndResetEndpointer ####
%s:%d:%s: #### AVVoiceController::playRecordStartingAlertAndResetEndpointer current Context  %@ ####
%s:%d:%s: #### AVVoiceController: startRecording [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecording:(NSError **) [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecordingAtTime:error [self = %p]####
%s:%d:%s: #### AVVoiceController:[self = %p] startRecordingWithSettings:error %@
%s:%d:%s: AVVoiceController: startRecordingWithSettings: Ignoring old style alert behavior
%s:%d:%s: #### AVVoiceController: stopRecording ####
%s:%d:%s: #### AVVoiceController: preparePlaybackWithSettings %@ 
%s:%d:%s: preparePlaybackWithSettings: Can't perform this action while playback is active
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: #### AVVoiceController: preparePlaybackFromURL: %@ ####
%s:%d:%s: preparePlaybackFromURL: audio is already playing
%s:%d:%s: #### AVVoiceController: startPlaying ####
%s:%d:%s: Attempt to play audio without configuring format
%s:%d:%s: startPlaying: called while already playing -- stopping previous play
%s:%d:%s: #### AVVoiceController: stopPlaying ####
%s:%d:%s: setRecordDelegate: Cannot set while record is active
%s:%d:%s: Attempting to set record delegate while record state = %u, record engine state = %u
%s:%d:%s: getRecordBufferDuration: returning %.3f seconds
%s:%d:%s: #### AVVoiceController: setRecordBufferDuration: %f ####
%s:%d:%s: setRecordBufferDuration: Cannot set while record is active
%s:%d:%s: Attempting to set recordBufferDuration while record state = %u, record engine state = %u
%s:%d:%s: setRecordBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: setRecordBufferDuration: rebuilding queue
%s:%d:%s: setRecordBufferDuration: duration now %.3f
%s:%d:%s: #### AVVoiceController: setEndpointerDelegate ####
%s:%d:%s: #### setEndpointerDelegate: using %s endpointer ####
%s:%d:%s: #### AVVoiceController: setRecordEndpointMode: %d ####
%s:%d:%s: #### AVVoiceController: recordStartWaitTime: %f ####
%s:%d:%s: setPlaybackDelegate: Cannot set while playback is active
%s:%d:%s: #### AVVoiceController: setPlaybackBufferDuration: %f ####
%s:%d:%s: setPlaybackBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: isRecording: record state: %s, rec-engine type: %s, rec-engine state: %s
%s:%d:%s: #### AVVoiceController: setAlertVolume: %f ####
%s:%d:%s: #### AVVoiceController: setPlaybackVolume: %f ####
%s:%d:%s: setStopOnEndpointEnabled: endpoint previously detected -- stopping capture
%s:%d:%s:  ASSERTION FAILED: unref'ing a zero-count object!
%s:%d:%s: about to lock %s
%s:%d:%s: about to unlock %s
%s:%d:%s: setStartAlertMode: %s
%s:%d:%s: alert queue state => %s
%s:%d:%s: setStopAlertMode: %s
%s:%d:%s: setStopWithErrorAlertMode: %s
%s:%d:%s: %s : %s : start: %s end: %s duration %.2f ms
%s:%d:%s: %s : start: %s end: %s duration %.2f ms
%s:%d:%s: >> %s
%s:%d:%s: << %s
%s:%d:%s: setStartRecordTime: %llu
%s:%d:%s: setRecordStatus: %ld
%s:%d:%s: QualityDetector: Start thresh: %u Start Timeout: %u End thresh: %u  End Timeout: %u
%s:%d:%s: QualityDetector: NONE => ACTIVE
%s:%d:%s: QualityDetector: NoSpeech; End Counter %u / %u
%s:%d:%s: QualityDetector: NONE => ENDED (TIMEOUT AT START)
%s:%d:%s: QualityDetector: Active; End Counter %u / %u
%s:%d:%s: QualityDetector: Active; Watching for end point (current frame quality: %u)
%s:%d:%s: QualityDetector: ACTIVE => ENDED
%s:%d:%s: QualityDetector: ACTIVE => ENDING
%s:%d:%s: QualityDetector: Speech Ending; End Counter %u / %u
%s:%d:%s: QualityDetector: ENDING => ACTIVE
%s:%d:%s: QualityDetector: ENDING => ENDED
%s:%d:%s:  ASSERTION FAILED: inPastFrameCount <= mFrameHistoryLength
%s:%d:%s: QualityDetector: Start Timeout: %u frames
%s:%d:%s: QualityDetector: Interspeech Timeout: %u frames
%s:%d:%s: QualityDetector: End Timeout: %u frames
%s:%d:%s: SpeexEndpointer init:
%s:%d:%s: SpeexEndpointer dealloc:
%s:%d:%s: SpeexEndpointer configureWithSampleRate:
%s:%d:%s: SpeexEndpointer configureWithSampleRate:andFrameRate: illegal frame rate!
%s:%d:%s: SpeexEndpointer configureWithASBD:andFrameRate
%s:%d:%s: SpeexEndpointer setEndpointMode: %d
%s:%d:%s: SpeexEndpointer setStartWaitTime: %f
%s:%d:%s: SpeexEndpointer setInterspeechWaitTime: %f
%s:%d:%s: SpeexEndpointer setEndWaitTime: %f
%s:%d:%s:  ASSERTION FAILED: getStatus called before object was configured!
%s:%d:%s: SpeexEndpointer getStatus: Raw Speex qlty frame %d/%d: %.2f rnng avrg: %.2f, med: %.2f, cls: %d
%s:%d:%s: #### SpeexEndpointer: Detected start point ####
%s:%d:%s: #### SpeexEndpointer: Detected soft end point ####
%s:%d:%s: #### SpeexEndpointer: Detected hard end point ####
%s:%d:%s: *** InitializePlugins *** %p 
%s:%d:%s: bundle URL %@
%s:%d:%s: initialized plugin class %@
%s:%d:%s: Unable to create the plugin bundle
%s:%d:%s: dealloc : releasing all plugins *** %p
%s:%d:%s: invalidatePlugins : invalidating all plugins *** %p
%s:%d:%s: calling invalidate on plugin instance %p
%s:%d:%s: searching plugin path %@
%s:%d:%s: Error enumerating the remote input bundles %@
%s:%d:%s: Temp log. Device(%p). Identifier: %@
%s:%d:%s: Cannot find Remote Input device %@
%s:%d:%s: findDeviceWithIdentifier: found the device %@
%s:%d:%s: (self %p) device %p (id:%@), published message for plugin %p - engine %p
%s:%d:%s: (self %p) device %p (id:%@), unpublished message for plugin %p - engine %p
%s:%d:%s: AVVCPluginRecordingEngine()
%s:%d:%s: ~AVVCPluginRecordingEngine()
%s:%d:%s: device identifier shouldn't be NULL... 
%s:%d:%s: device identifier : %@
%s:%d:%s: session state: %s, record state: %s, rec-engine type: %s, rec-engine state: %s alert state: %s
%s:%d:%s: (self %p)startRecord : using activeDevice: %p
%s:%d:%s: #### calling startRecordingWithCompletionBlock on device (%p) ####
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING-PAUSED
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: setting the audioInputBlock to nil..
%s:%d:%s: startRecordQueue:  No device found, err : %d
%s:%d:%s: AVVCPluginRecordingEngine::stopRecording: mRecordIsStopping set to true
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: stopRecording:  No device found error :%d
%s:%d:%s: AVVCPluginRecordingEngine::stopRecording: resetting alert queue here
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Entering --->
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine: about to call stopRecordingCompletionBlock - previous stop completion block didn't happen
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine -- stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine - stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  calling doneRecording manually
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  skipping doneRecording as we are deallocating
%s:%d:%s: destroyRecordEngine: device found, err : %d
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Exiting <---
%s:%d:%s: AVVCPluginRecordingEngine(%p)::createRecordQueue -->
%s:%d:%s: AVVCPluginRecordingEngine::createRecordQueue : no matching device found, error : %d
%s:%d:%s: Record queue state does not match queue (previously assertion failure)
%s:%d:%s: createRecordQueue : using device %p
%s:%d:%s: Supported Formats[0] : %@ 
%s:%d:%s: *** createRecordQueue : No Format specified.. Error
%s:%d:%s: createRecordQueue : setting format on active device(%p), format:%@
%s:%d:%s: audioInputBlock called with packetcount : %d
%s:%d:%s: audioInputBlock called
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: timeStamp : %f
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: No frame qualities.
%s:%d:%s: In AVVCPluginRecordingEngine::handleRecordInput: %u frames, hostTime : %lld, sampletime : %f
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput: record internally stopped, so throwing away buffer
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput - recordState is active, but getting nil buffer
%s:%d:%s: Setting up client buffer
%s:%d:%s: Copying BT audio buffer, size %u
%s:%d:%s: handleRecordInput: packetDesc.startOffset %lld, packetDesc.mVariableFramesInPacket %u, packetDesc.DataByteSize = %u
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput: bufferLength : %d, packetCount : %d
%s:%d:%s: AudioFileWritePackets returned error %d, mPacketCount %d, numPackets %u, starting packet index : %d
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput: max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%s:%d:%s: Exiting AVVCPluginRecordingEngine::handleRecordInput
%s:%d:%s: Unable to create caf audio dump file '%s'. Error: %d
%s:%d:%s: Dumping caf input to '%s'
%s:%d:%s: AVVCPluginRecordingEngine::getRecordRoute : no matching device found, error : %d
%s:%d:%s: active device doesn't support remoteInputDeviceName property
%s:%d:%s: record state => %s
%s:%d:%s: WARNING: record state change %s => %s ignored
%s:%d:%s:  ASSERTION FAILED: Only no-op illegal state changes allowed!
%s:%d:%s: Aborting (re)try for expired notifier for session %p.
%s:%d:%s: Attempting to contact server for session %p
%s:%d:%s: Calling completion handler for session %p
%s:%d:%s: Connection succeeded, but registration of server death notification failed.
%s:%d:%s: Encountered permanent connection failure for session %p.
%s:%d:%s: Retrying connection for session %p. Attempt count: %d
%s:%d:%s: Session with ID 0x%x not found
%s:%d:%s: Adding session %p with ID 0x%x
%s:%d:%s: Session ID 0x%x is already in use
%s:%d:%s: Did not find session %p in session map
%s:%d:%s: Removing session %p with ID 0x%x
%s:%d:%s: Removed session %p
%s:%d:%s: Session %p not found
%s:%d:%s: Session not valid! New ID is 0x%x
%s:%d:%s: Updating session ID. Old: 0x%x, New: 0x%x
%s:%d:%s: Session %p not found. Proceeding to adding entry with new session ID: 0x%x
%s:%d:%s: ---> this = %p
%s:%d:%s: <---
%s:%d:%s: Track's sequence was NULL
%s:%d:%s: Underlying track already destroyed
%s:%d:%s: start -> %.2f [end %.2f]
%s:%d:%s: end -> %.2f [start %.2f]
%s:%d:%s: %sabling looping [%.2f - %.2f]
%s:%d:%s: [%s:%d:%s: (%s): error %d
%s:%d:%s: Unable to retrieve stream format from AU.
%s:%d:%s: Error
%s:%d:%s: Error. Could not get open audio file from path.
%s:%d:%s: Error. Could not get inMaxSamplesPerBuffer.
%s:%d:%s: Error. Could not get numFramesInAudioFile.
%s:%d:%s: Error. Could not retrieve VAD configuration.
%s:%d:%s: Unexpected nil channel description
%s:%d:%s: AVAudioEngine: left running idle for %.f s
%s:%d:%s: AVAudioEngine (auto shutdown mode): left running idle for %.f s, stopping!
%s:%d:%s: AVAudioEngine (auto shutdown mode): left running idle for %.f s, couldn't stop now, will retry soon!
%s:%d:%s: AVAudioEngine (auto shutdown mode): starting IO dynamically
%s:%d:%s: AVAudioEngine (auto shutdown mode): could not dynamically start the audio hardware, err = %{audio:4CC}d
%s:%d:%s: graph@%p: couldn't initialize node@%p {%s}, error %d
%s:%d:%s:  STACK_ABL: invalid number of buffers
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %d
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %{audio:4CC}d
%s:%d:%s: Rebuilding queue for new audio format
%s:%d:%s: prepareRecord: CURRENT FORMAT: %s
%s:%d:%s: prepareRecord: CLIENT NEW FORMAT: %s
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %d
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %{audio:4CC}d
%s:%d:%s: record engine state => %s
%s:%d:%s: AudioQueueRecordInputCallback called 
%s:%d:%s: AudioQueueRecordPropertyListenerProc called 
%s:%d:%s:  ASSERTION FAILED: Rec AQ listener proc called with NULL impl!
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %d
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %{audio:4CC}d
%s:%d:%s: Record engine state does not match queue (previously assertion failure)
%s:%d:%s: Record Queue Format: %s
%s:%d:%s: Creating queue with flags 0x%x. %s runloops
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %{audio:4CC}d
%s:%d:%s: FAILED createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %{audio:4CC}d
%s:%d:%s: AQGetProperty - kAudioQueueDeviceProperty_NumberChannels returned : %u
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %{audio:4CC}d
%s:%d:%s: createRecordQueue: createAudioConverter error: %d. Destroying record queue.
%s:%d:%s: AudioConverter is not created.. reason: requested channels is 1 or requested interleaved audio or non-lpcm is requested
%s:%d:%s: FrameCapacity: %d. Buffer duration: %f s
%s:%d:%s: createRecordQueue: creating %u queue buffers %u bytes each
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: Creating AVAudioPCMBuffer with frameCapacity: %d. Buffer duration: %f s
%s:%d:%s: Unexpected Format found.. 
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %{audio:4CC}d
%s:%d:%s: createAudioConverter: INITIAL AUDIOCONVERTER OUTPUT FORMAT:
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %{audio:4CC}d
%s:%d:%s: createAudioConverter: initial frames per buffer = dur %.2f * sr %.2f = %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: corrupted values??? framesPerBuffer = %u, mRecordBufferDuration = %f
%s:%d:%s:  ASSERTION FAILURE: mFramesPerPacket cannot be zero!
%s:%d:%s: createAudioConverter: setting audio converter format to %u frames per packet
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: %u atomic blocks per second
%s:%d:%s: kAudioConverterCurrentOutputStreamDescription ASBD's are different !! 
%s:%d:%s: createAudioConverter: encoded audio needs minimum of %u bytes per output buffer
%s:%d:%s: createAudioConverter: AudioConverterGetProperty(kAudioConverterPropertyMinimumOutputBufferSize) returned status %d
%s:%d:%s: createAudioConverter: final framesPerBuffer: %u
%s:%d:%s: createAudioConverter: mConvertPacketCount: %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: outputSizePerPacket: %u
%s:%d:%s: createAudioConverter: mConvertAudioCapacity %u bytes
%s:%d:%s: FINAL RECORD FORMAT:
%s:%d:%s: prepareRecord: retrieving voice trigger info
%s:%d:%s: prepareRecord: AudioQueueGetProperty(BorealisTriggerInfo) returned '%s'
%s:%d:%s: startRecordQueue: record state already started or stopping -- no-op
%s:%d:%s:  ASSERTION FAILED: attempting to prime record queue while queue !stopped
%s:%d:%s:  ASSERTION FAILED: some buffers already enqueued!
%s:%d:%s: startRecordQueue: enqueing %d buffers
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: #### Starting record queue with delay ####
%s:%d:%s: #### Starting record queue immediately ####
%s:%d:%s: #### Starting record queue at time %llu ####
%s:%d:%s: AVVC starting record queue%s at time (%s) %lld (hosttime)
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: stopRecordQueue: mRecordIsStopping set to true
%s:%d:%s: ERROR: stopRecordQueue: AudioQueueStop err %d
%s:%d:%s: ERROR: stopRecordQueue: AudioQueueStop err %{audio:4CC}d
%s:%d:%s: AVVC stopped record queue%s (%d)
%s:%d:%s: Calling destroyRecordEngine
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to true
%s:%d:%s: destroyRecordEngine: about to call AudioQueueStop(..., true)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine:  calling doneRecording by hand
%s:%d:%s: destroyRecordEngine:  skipping doneRecording call because we are deallocating
%s:%d:%s:  ASSERTION FAILED: queue was running when destroyed but not asked to stop
%s:%d:%s: destroyRecordEngine: about to call AudioQueueDispose(..., true)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to false
%s:%d:%s: destroyRecordEngine: about to destroy audio converter
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %{audio:4CC}d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %{audio:4CC}d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %{audio:4CC}d
%s:%d:%s: nChannel:%d, startChannel:%d, mClientAudioBufferList->mBuffers[nChannel+startChannel].mData : %p
%s:%d:%s: AudioConverterConvertComplexBuffer failed with error : %d
%s:%d:%s: handleRecordAQPropertyChange: queue already destroyed -- noop
%s:%d:%s: Record Listener: RUNNING
%s:%d:%s: Record Listener: RUNNING-PAUSED
%s:%d:%s: Record Listener: STOPPED
%s:%d:%s: Record Listener: Converter error: %s
%s:%d:%s: (%p) - First callback from AQ -  inStartTime: ht %lld st %lld, Now : ht %lld, tempRecordStartTime : %lld. AQ difference: %0.6f ms
%s:%d:%s: handleRecordAQInput: sample time: %f, host time %llu, %llu frames (%d bytes), %d buffers enqueued
%s:%d:%s: handleRecordAQInput: throwing away zero-length buffer
%s:%d:%s: handleRecordAQInput: record internally stopped, so throwing away buffer
%s:%d:%s: Calling avAudioPCMRecordBufferListReceived with ABL
%s:%d:%s: Calling lpcmRecordBufferRecieved with AQBufferRef directly
%s:%d:%s: handleRecordAQInput: encoder input: packetsAvailable: %u
%s:%d:%s: handleRecordAQInput: encoder input buffer %p: %u bytes, %u packets
%s:%d:%s: handleRecordAQInput: handing to converter: encoder output buffer: %u bytes, ioOutputDataPackets = %u
%s:%d:%s: handleRecordAQInput: err %s, got from converter %u encoded packets, %u bytes.  totalOutputByteSize = %u
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %{audio:4CC}d
%s:%d:%s: handleRecordAQInput: sending %u bytes of encoded data (addr %p) to client with %u packet descs @time %llu
%s:%d:%s: Re-enqueuing buffer %p (data ptr %p), size %u
%s:%d:%s:  ASSERTION FAILED: AQ enqueue error while actively recording
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: Exiting handleRecordAQInput (%d buffers enqueued)
%s:%d:%s: setupAudioCaptureFile error from AudioQueueGetProperty (StreamDescription): %d
%s:%d:%s: Unable to create LPCM audio dump file '%s'. Error: %d
%s:%d:%s: Dumping LPCM input to '%s'
%s:%d:%s: doneRecording: resetting record queue
%s:%d:%s: UpdateRecordDeviceOnQueue : AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice) - %@
%s:%d:%s: UpdateRecordDeviceOnQueue: AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice - %d)
%s:%d:%s:  ChangeNumberChannels only works for uncompressed formats
%s:%d:%s: RecordEncoderInputDataProc: ENTRY: *ioNumberDataPackets passed in: %u, packets remaining: %u, bytes already consumed: %u
%s:%d:%s: RecordEncoderInputDataProc: End of stream -- handing back zero size buffer
%s:%d:%s: RecordEncoderInputDataProc: Handing back ioData buffer %p of size %u
%s:%d:%s:  ASSERTION FAILED: packetsRead <= packetsAvailable!
%s:%d:%s: RecordEncoderInputDataProc: EXIT: *ioNumberDataPackets passed back out: %u, status: %s
%s:%d:%s: Error creating XPC connection to %@
%s:%d:%s: %@
%s:%d:%s: Interruption Handler: connection got interrupted
%s:%d:%s: Invalidation Handler: client exited
%s:%d:%s: starting sequence on client side
%s:%d:%s: finishing sequence on client side
%s:%d:%s: No corresponding EndpointVAD3Host::VADState value for EndpointDecisionLayerVAD3::Decision input.
%s:%d:%s: Could not retrieve VAD3COnfiguration.
%s:%d:%s: AudioUnitUninitialize: %i
%s:%d:%s: AudioComponentInstanceDispose: %i
%s:%d:%s: Input audio file longer than audioInputDurationWarningThreshold. Proceeding execution of function.
%s:%d:%s: AVVCMetricsManager: createSharedManager: referenceCount after incrementing = %llu
%s:%d:%s: AVVCMetricsManager: destroySharedManager : referenceCount after decrementing = %llu
%s:%d:%s: AVVCMetricsManager: sharedInstance is nil !!!!
%s:%d:%s: AVVCMetricsManager: dealloc
%s:%d:%s: Measuring Elapsed Time for %@ : %f ms
%s:%d:%s: Logging PROFILE METRIC : %@
%s:%d:%s: AVAudioEngine: couldn't render node %p, err = %d
%s:%d:%s: ---> self = %p
%s:%d:%s: can't open file
%s:%d:%s: There must be exactly one time stamp for every state value. Terminating.
%s:%d:%s: There must be exactly one time stamp for every posterior distribution!
%s:%d:%s: There must be exactly one time stamp for every event.
%s:%d:%s: session state => %s
%s:%d:%s: Error (prev Assertion Failure): Calling setDuckOthersOption on an unconfigured session
%s:%d:%s: setDuckOthersOption: done : error : %d
%s:%d:%s: setDuckOthersOption: Not available in this platform..
%s:%d:%s: setSessionPropertiesFromMode: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%s:%d:%s: setSessionPropertiesFromMode: iMessage -- setting P&R category, clearing preferred input, etc.
%s:%d:%s: ERROR: setSessionPropertiesFromMode: AVAudioSession clearInputPreferences: err %d
%s:%d:%s: ERROR: setSessionPropertiesFromMode: AVAudioSession clearInputPreferences: err %{audio:4CC}d
%s:%d:%s: setSessionPropertiesFromMode: setting speech recognition/assistant mode category: %@, mode: %@, options: 0x%x
%s:%d:%s: setSessionPropertiesFromMode: category, mode and optios are same..
%s:%d:%s: ERROR: setSessionPropertiesFromMode: AVAudioSession setCategory:error: err %d
%s:%d:%s: ERROR: setSessionPropertiesFromMode: AVAudioSession setCategory:error: err %{audio:4CC}d
%s:%d:%s: ERROR: setSessionPropertiesFromMode: setIAmTheAssistant err %d
%s:%d:%s: ERROR: setSessionPropertiesFromMode: setIAmTheAssistant err %{audio:4CC}d
%s:%d:%s: setSessionPropertiesFromMode: forcing 22050k audio for car audio
%s:%d:%s: ERROR: setSessionPropertiesFromMode: setPreferredSampleRate err %d
%s:%d:%s: ERROR: setSessionPropertiesFromMode: setPreferredSampleRate err %{audio:4CC}d
%s:%d:%s: ASSERTION FAILED: calling setSessionProperties on a configured session. Crashing assistantd process!.
%s:%d:%s: setSessionProperties: done
%s:%d:%s: siri remote input device identifier : %@ - provided by siri
%s:%d:%s: QueueRunLoop started
%s:%d:%s: Failed to start queue's run loop thread
%s:%d:%s: Dumping input (LPCM) or CAF (from plugin) to file
%s:%d:%s: Profiling AVVC NOW.
%s:%d:%s: Setting duck-others AudioSession option for CarPlay
%s:%d:%s: ControllerImpl::Entering Dealloc
%s:%d:%s: QueueRunLoop stopped
%s:%d:%s: ControllerImpl::Exiting Dealloc
%s:%d:%s: waiting for any in-flight AudioQueue property change message on run loop...
%s:%d:%s: CallbackBarrier: 9 second timeout!
%s:%d:%s: received all AudioQueue property change messages on run loop.
%s:%d:%s: setNoResumeOnDeactivate(TRUE): will not notify others on deactivation
%s:%d:%s: setNoResumeOnDeactivate(FALSE): will notify others on deactivation
%s:%d:%s: setActivationMode: voice activation
%s:%d:%s: setActivationMode: post-voice activation
%s:%d:%s: setActivationMode: iMessage nudge
%s:%d:%s: setActivationMode: iMessage gesture to head
%s:%d:%s: setActivationMode: ATVRemoteSiri
%s:%d:%s: setActivationMode: standard value (%s)
%s:%d:%s: setActivationMode: Cannot revert from mode %s to mode %s while audio session is active
%s:%d:%s: setActivationMode: will never take control of HW on activation
%s:%d:%s: ERROR: Failed at setAudioHardwareControlFlags: %s
%s:%d:%s: setActivationMode: will not take control of HW on activation
%s:%d:%s: setActivationMode: will take normal control of HW on activation
%s:%d:%s: setActivationMode: Mode already set to %s
%s:%d:%s: setPreferredIOBufferFrameSize, attempting at %d
%s:%d:%s: setPreferredIOBufferFrameSize, failed: %@
%s:%d:%s: setPreferredIOBufferFrameSize, success: %d
%s:%d:%s: currentRoute input count is : %lu : siriremoteid : %@
%s:%d:%s: siri remote input device identifier : %@ - provided by audio session
%s:%d:%s: handlePluginDidPublishDevice notification for device: %@
%s:%d:%s: handlePluginDidUnpublishDevice notification for device: %@
%s:%d:%s: Stopping recording here, plugin engine's remote device has been disconnected.
%s:%d:%s: Context is nil. can't decide what recording engine need to be created
%s:%d:%s: switching to %{audio:4CC}d mode - keeping the same recording engine (%p)
%s:%d:%s: creating pluginEngine(%p)...  Mode is %{audio:4CC}d
%s:%d:%s: creating AQRecordingEngine(%p). Mode is %{audio:4CC}d
%s:%d:%s: current recording engine - %p. type: %s
%s:%d:%s: configure: session not configured -- calling setSessionProperties
%s:%d:%s: configure: activating session for setup
%s:%d:%s: ERROR: configure: getSessionProperties err %d
%s:%d:%s: ERROR: configure: getSessionProperties err %{audio:4CC}d
%s:%d:%s: Overwriting an already-deferred context
%s:%d:%s: releasing old device identifier
%s:%d:%s: setCurrentContext - deviceID passed : %@
%s:%d:%s: setCurrentContext:error: record is active -- deferring the context change
%s:%d:%s: recordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@
%s:%d:%s: setActivationContext setting audio session activation context to: %@
%s:%d:%s: setActivationContext: HACK: ignore switch away from RemoteSiri
%s:%d:%s: setActivationContext: 'live' switch out of VoiceActivated -- reset session properties
%s:%d:%s: setActivationContext: switching in/out of CarAudio -- reset session properties
%s:%d:%s: setActivationContext: switching out of iMessage -- reset session properties
%s:%d:%s: ERROR: setActivationContext: AVAudioSession setActivationContext err %s, session id:0x%x
%s:%d:%s: setActivationContext: done setting audio session activation context
%s:%d:%s: setActivationContext: finish 'live' switch by re-activating active session setActive:TRUE
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %d
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %{audio:4CC}d
%s:%d:%s: setActivationContext: session re-activated -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is active and mode changed -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is inactive -- route change notification should generate a call to getSessionProperties
%s:%d:%s: getRecordAndPlaybackRoutes: NULL currentRoute!
%s:%d:%s: getRecordAndPlaybackRoutes: New Record Route: %@
%s:%d:%s: getRecordAndPlaybackRoutes: NULL port type!
%s:%d:%s: getRecordAndPlaybackRoutes: New Record Route %@
%s:%d:%s: getRecordAndPlaybackRoutes: No record routes returned for AQRecordEngine! - activation mode : %{audio:4CC}d
%s:%d:%s: Error! Recording engine does not exist!
%s:%d:%s: getRecordAndPlaybackRoutes: New Playback Route: %@
%s:%d:%s: getRecordAndPlaybackRoutes: NULL route returned!
%s:%d:%s: getRecordAndPlaybackRoutes: No routes returned!
%s:%d:%s: %s: audio session is inactive or had been interrupted
%s:%d:%s: %s: rebuilding alert queue
%s:%d:%s: %s: rebuilding record queue
%s:%d:%s: calling prepare instead of create record queue
%s:%d:%s: %s - setSessionActive(false): session state already %s [sSessionActiveCount = %d] -- forcing deactivation, setting sSessionActiveCount to 0
%s:%d:%s: ERROR: %s setActive:FALSE withOptions: err %s
%s:%d:%s: #### AVVoiceController: %s - error [sSessionActiveCount back to %d]####
%s:%d:%s: #### AVVoiceController: %s - error AVAudioSessionErrorCodeMediaServicesFailed, sSessionActiveCount is %d####
%s:%d:%s: setSessionActive: We have to wait for the session to be (re-)initialized
%s:%d:%s: setSessionActive: (re-)init done!
%s:%d:%s: setSessionActive: waiting...
%s:%d:%s: ERROR: setSessionActive: Timed out waiting for mediaserverd err %d
%s:%d:%s: #### AVVoiceController: Activating session [sSessionActiveCount now %d]####
%s:%d:%s: #### Error: negative or zero count detected -- resetting to 1 ####
%s:%d:%s: setSessionActive: setActive: TRUE for prewarming did not succeed
%s:%d:%s: #### AVVoiceController: [sSessionActiveCount back to %d]####
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE - err = %s, session id:0x%x
%s:%d:%s: setSessionActive(true): AVAudioSession:setActive has returned
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested - returned error : %d
%s:%d:%s: setSessionActive(true): Route change when we went active: %s -- getting properties
%s:%d:%s: #### AVVoiceController: error [sSessionActiveCount back to %d]####
%s:%d:%s: setSessionActive(false): sSessionActiveCount is %d -- not doing anything
%s:%d:%s: #### AVVoiceController: Deactivating session with notify [sSessionActiveCount = %d]####
%s:%d:%s: #### Error: negative count detected -- resetting to 0 ####
%s:%d:%s: setSessionActive(false): stopping playback queue
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %d
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): destroying record queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): in process of being destroyed -- kill the alert queue
%s:%d:%s: setSessionActive(false): resetting alert queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): alert state %s -- deactivating session asynchronously (NOT HERE) check alertFinished
%s:%d:%s: setSessionActive(true): session state already %s -- no-op
%s:%d:%s: getSessionProperties: unexpected 0.0 value for output latency
%s:%d:%s: getSessionProperties: working around bad input latency value for now
%s:%d:%s: getSessionProperties: input HW latency: %g output HW latency: %g
%s:%d:%s: getSessionProperties: input HW sampling rate %lf
%s:%d:%s: getSessionProperties: plugin mode - resetting to default HW sampling rate %lf
%s:%d:%s: getSessionProperties: Error getting input hardware sample rate
%s:%d:%s: getSessionProperties: Done.  Input HW sampling rate set to %lf - error (%d)
%s:%d:%s: setupEndpointer: configuring SR and wait times
%s:%d:%s: WARNING: startRecordingAtTime:error was used without 'silent' start alert
%s:%d:%s: calculateRecordStartTime: queue plus HW delay time: %f seconds
%s:%d:%s: calculateRecordStartTime: host time for start of record: %.3f seconds
%s:%d:%s: this is %lld ticks beyond alert end (%.6f seconds in the future)
%s:%d:%s: configureAlertModeFromMode: Wired headset output - disable ZLL
%s:%d:%s: configureAlertModeFromMode: record start time was set -- check for ZLL
%s:%d:%s: configureAlertModeFromMode: ZLL query - back frames: %u
%s:%d:%s: ZLL query result %d, backFramesAvailable: %u
%s:%d:%s: Zero or insufficient back frames - clearing start record time
%s:%d:%s: configureAlertModeFromMode: record start time not set
%s:%d:%s: configureAlertModeFromMode: HomeButtonPress/UIButtonPress
%s:%d:%s: configureAlertModeFromMode: %s
%s:%d:%s: configureAlertModeFromMode: no vibrator support and no ZLL
%s:%d:%s: configureAlertModeFromMode: VoiceActivation/BTVoiceTrigger
%s:%d:%s: configureAlertModeFromMode: VoiceTriggerTraining
%s:%d:%s: configureAlertModeFromMode: iMessage
%s:%d:%s: configureAlertModeFromMode: default
%s:%d:%s: prepareRecord: Can't perform this action while record is starting or active
%s:%d:%s: prepareRecord: home/btbp button activation : after rechecking which engine to use %p
%s:%d:%s: prepareRecord: recording engine is not selected, %{audio:4CC}d
%s:%d:%s: Attempt to start recording without calling prepareRecordWithSettings:
%s:%d:%s: startRecord: already starting or active -- no-op
%s:%d:%s: startRecord: failed to play record-start alert. status = %d
%s:%d:%s: startRecord: returning failed record status %d
%s:%d:%s:  ASSERTION FAILED: record state > inactive after record failure
%s:%d:%s: stopRecord: already stopping or inactive -- no-op
%s:%d:%s: stopRecord: record state == kRecordActive && queue not stopped - keep going here
%s:%d:%s: stopRecord: record state == kRecordStarting but object being destroyed -- just stop queue
%s:%d:%s: stopRecord: record state == kRecordStarting -- we will need to send a start notify prior to stop
%s:%d:%s: stopRecord: record was just starting -- calling doneRecording ourselves -- watch this case
%s:%d:%s: stopRecord: stopping queue at time %llu
%s:%d:%s: !!!! stopRecord: Recording engine is null -- this should not happen
%s:%d:%s: performSelectorOnMainThread: beganRecording
%s:%d:%s: calling synchronously: beganRecording
%s:%d:%s: doneRecording: resetting mRecordIsStopping and mRecordIsPrimed
%s:%d:%s: doneRecording: resetting Audio Converter
%s:%d:%s: ERROR: doneRecording: AudioConverterReset err %d
%s:%d:%s: ERROR: doneRecording: AudioConverterReset err %{audio:4CC}d
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls performSelectorOnMainThread: beganRecording
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls beganRecording synchronously
%s:%d:%s: performSelectorOnMainThread: finishedRecording
%s:%d:%s: calling finishedRecording synchronously
%s:%d:%s: Zero runs at: %s. Total: %d. Route: %s
%s:%d:%s: playAlert: alertType = %d, primeFirst=true
%s:%d:%s: playAlert: using SSS to play haptic (or silence)
%s:%d:%s: playAlert: alert %d already in progress -- stop it now
%s:%d:%s: playAlert: silent start - fake a SS completion callback
%s:%d:%s: playAlert: non-blocking SSS alert for Siri startup
%s:%d:%s: playAlert: silent stop - fake a SS completion callback
%s:%d:%s: playAlert: calling AudioServicesPlaySystemSoundWithOptions with sound ID %u and flags %x
%s:%d:%s: playAlert: using alert queue to play beep
%s:%d:%s: playAlert: alert playback failed -- attempting to re-prime
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %{audio:4CC}d
%s:%d:%s:  ASSERTION FAILED: re-entrant request for different alert type
%s:%d:%s: primeAlertQueue: alert queue state '%s'.  reentrant or multi-threaded call -- returning
%s:%d:%s: primeAlertQueue: queue is NULL -- returning
%s:%d:%s: primeAlertQueue: type %d (current is %d)
%s:%d:%s: primeAlertQueue: sync-stopping active alert queue
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %{audio:4CC}d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: silent/haptic alert: not queueing a buffer
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: done. current is now %d
%s:%d:%s: primeAlertQueue: no-op
%s:%d:%s: setupAlert: NULL alert URL
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: setupAlert: Failed to load alert '%s'
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %{audio:4CC}d
%s:%d:%s: setupAlert: resetting alert queue
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %{audio:4CC}d
%s:%d:%s:  ASSERTION FAILED: no alert buffer is enqueued!
%s:%d:%s: startAlertQueue: calling AudioQueueStart
%s:%d:%s: AVVC started alert queue%s (%d)
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %{audio:4CC}d
%s:%d:%s:  ASSERTION FAILED: alert queue NULL but state != Uninitialized
%s:%d:%s: detected unfinished alert, queue up alertFinished
%s:%d:%s: destroyAlertQueue: calling AudioQueueStop
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %{audio:4CC}d
%s:%d:%s: destroyAlertQueue: removing queue listener
%s:%d:%s: destroyAlertQueue: calling AudioQueueDispose
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: calculateAlertTimes: alert queue already stopped -- using current time as end time
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %d
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %{audio:4CC}d
%s:%d:%s: alertStarted: record state == kRecordStopping -- we need to go ahead and notify that we have started recording
%s:%d:%s: alertStarted: record state != kRecordStarting -- noop
%s:%d:%s: alertStarted: not playing start alert -- noop
%s:%d:%s: alertFinished
%s:%d:%s: alertFinished: state = %s mRecordState: %s -- not priming alert
%s:%d:%s: alertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: #### fail [sSessionActiveCount back to %d]####
%s:%d:%s: #### In alertFinished but sSessionActiveCount is %d] !!! check !!!####
%s:%d:%s: Alert Listener: impl or queue is NULL or object is being destroyed -- noop
%s:%d:%s: Alert Listener: in the middle of priming alert queue:  Doing nothing.  [THIS IS NEW BEHAVIOR]
%s:%d:%s: Alert Listener: mAlertQueueState = %s
%s:%d:%s: Alert Listener: RUNNING = %d
%s:%d:%s: Alert Listener: session was interrupted!  Doing nothing here
%s:%d:%s: Alert Listener: state already kAlertQueueRunning.  Doing nothing here
%s:%d:%s: Alert Listener: queue reports stopped on first IsRunning prop notification -- treat this like a regular start
%s:%d:%s: Alert Listener: unhandled inID %s
%s:%d:%s: vibeStartAlertFinished: record state == kRecordStopping -- we need to go ahead and notify that we have started recording
%s:%d:%s: vibeStartAlertFinished: record state != kRecordStarting -- noop
%s:%d:%s: vibeStopAlertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: #### In vibeStopAlertFinished but sSessionActiveCount is %d, !!! check !!!####
%s:%d:%s: VibeAlertCompletionProc: SSID %u done
%s:%d:%s: VibeAlertCompletionProc -> called after object destroyed -- ignoring call
%s:%d:%s: VibeAlertCompletionProc: object being destroyed -- bailing out
%s:%d:%s: VibeAlertCompletionProc: notified for other ssID %d -- no-op
%s:%d:%s: checkForEndpoint entered: inBuffer %p
%s:%d:%s: performSelectorOnMainThread: startpointDetected
%s:%d:%s: calling startpointDetected synchronously
%s:%d:%s: performSelectorOnMainThread: interspeechPointDetected
%s:%d:%s: calling interspeechPointDetected synchronously 
%s:%d:%s: #### AVVoiceController: Detected end point but NO START POINT ####
%s:%d:%s: checkForEndpoint: auto-stopping record
%s:%d:%s: performSelectorOnMainThread: endpointDetected
%s:%d:%s: calling endpointDetected synchronously
%s:%d:%s: checkForEndpoint exiting
%s:%d:%s: Record Listener: handling deferred context change
%s:%d:%s:     Reporting encoder error %s via delegate
%s:%d:%s:     performSelectorOnMainThread: encodeError
%s:%d:%s:     calling encodeError synchronously
%s:%d:%s:     No delegate method found -- dropping error
%s:%d:%s: AVVoiceController -> Interruption beginning
%s:%d:%s:   We think our session was not active.  Make sure it isn't. deactivating session
%s:%d:%s:   We are in the middle of activating!  Ignoring.
%s:%d:%s:   Playback was active
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackWasStarted = %d mPlaybackRunning= %d
%s:%d:%s: performSelectorOnMainThread: beginPlaybackInterruption
%s:%d:%s: calling beginPlaybackInterruption synchronously
%s:%d:%s: performSelectorOnMainThread: finishedPlaying
%s:%d:%s: calling finishedPlaying synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate is nil or does not respond to voiceControllerBeginPlaybackInterruption:
%s:%d:%s:   Record was active
%s:%d:%s:   sending notification with interruptor name
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruptionWithContext:
%s:%d:%s: calling beginRecordInterruptionWithContext synchronously
%s:%d:%s:   sending notification
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruption
%s:%d:%s: calling beginRecordInterruption synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate does not respond to voiceControllerBeginRecordInterruption:
%s:%d:%s: Stopping record because interrupt does not.
%s:%d:%s:   Nothing active
%s:%d:%s: sSessionActiveCount now %d
%s:%d:%s: AVVoiceController -> Interruption ending
%s:%d:%s:   No longer reactivating audio session on interrupt end
%s:%d:%s:   destroying playback queue on resume (whether we were playing or not)
%s:%d:%s:   Was interrupted during playback
%s:%d:%s: performSelectorOnMainThread: endPlaybackInterruption
%s:%d:%s: calling endPlaybackInterruption synchronously
%s:%d:%s:   Was interrupted during recording -- stopping queue on resume
%s:%d:%s:  Record should never be active when interrupt is ending!
%s:%d:%s: performSelectorOnMainThread: endRecordInterruption
%s:%d:%s: calling endRecordInterruption synchronously
%s:%d:%s:   We were never interrupted to begin with!
%s:%d:%s: AVVoiceController -> Route Change
%s:%d:%s: Route change reason %s -- falling through
%s:%d:%s: Route really changed -- Re-checking properties
%s:%d:%s: Route really changed but session not-yet-active/interrupted -- set flag to check properties when we are active
%s:%d:%s: New route Category is not ours!
%s:%d:%s: We were waiting for a route change -- Re-checking properties
%s:%d:%s: Route change reason: category change - ignoring
%s:%d:%s: Category change came in while we were %s -- ignoring
%s:%d:%s: Route change reason: route configuration change - ignoring
%s:%d:%s: Route change reason was NULL
%s:%d:%s: AVVoiceController -> Server died!
%s:%d:%s: ControllerImpl::handleServerDeath: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerDeath: got duplicate call -- bailing out
%s:%d:%s: ControllerImpl::handleServerDeath: Destroying internal state for later rebuild
%s:%d:%s: ControllerImpl::handleServerDeath: calling finishedRecording synchronously
%s:%d:%s: AVVoiceController -> Server reset after death
%s:%d:%s: ControllerImpl::handleServerReset: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerReset: restoring activation context and resetting session properties
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue: output queue format:
%s:%d:%s: %s
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %d
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %{audio:4CC}d
%s:%d:%s: createPlaybackQueue: bufferByteSize %u
packetsPerSecond %g
packetSizeUpperBound %u
%s:%d:%s: createPlaybackQueue: bufferByteSize adjusted to %u
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %d
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %{audio:4CC}d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: enqueued buffer %p mNumPlayBuffersEnqueued %d
%s:%d:%s: preparePlaybackQueue: mNumPlayBuffersEnqueued %d  numFramesPrepared %u  sr %g
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %d
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: numFramesPrepared %u  mNumPlayBuffersEnqueued %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %{audio:4CC}d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %{audio:4CC}d
%s:%d:%s: setupAudioFile: audio format from file:
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %d
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %{audio:4CC}d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %{audio:4CC}d
%s:%d:%s: mPlaybackRunning is true
%s:%d:%s: performSelectorOnMainThread: beganPlaying
%s:%d:%s: calling beganPlaying synchronously
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackRunning= %d
%s:%d:%s:  ASSERTION FAILED: PB AQ listener proc called with NULL impl!
%s:%d:%s: Playback Listener: RUNNING = %d
%s:%d:%s: performSelectorOnMainThread: decodeError
%s:%d:%s: calling decodeError synchronously
%s:%d:%s: handleAudioPlaybackStream: %d buffers now in queue.  Calling client.
%s:%d:%s: handleAudioPlaybackStream: Client filled buffer %p, size %d bytes
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: >>handleEncodedFileRead requesting: pkt pos %qd, %d packets, %d bytes. bytes capacity: %d  buffer: %p
%s:%d:%s: <<handleEncodedFileRead got %d packets, %d bytes, status %d
%s:%d:%s: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters: trim leading: %d, trim trailing: %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: unlocker about to unlock %s
%s:%d:%s:  ASSERTION FAILED: Unlocker attempted to unlock a mutex not owned by the current thread!
%s:%d:%s: unlocker about to relock %s
%s:%d:%s:  ASSERTION FAILED: ref'ing a zero-count object!
%s:%d:%s: alert state => %s
%s:%d:%s: NOTE: AVVC Details logging is turned on by default for development
%s:%d:%s: debug_encoding on
%s:%d:%s: debug_endpoint on
%s:%d:%s: debug_callbacks on
%s:%d:%s: debug_locking on
%s:%d:%s: debug_state on
%s:%d:%s: debug_trace on
%s:%d:%s: debug_timing on
%s:%d:%s: debug_delegate on
%s:%d:%s: debug_playback on
%s:%d:%s: debug_deviceselect on
%s:%d:%s: debug_level = %d
%s:%d:%s: resetting debug_level to Notify to allow scoped logging
%s:%d:%s: debug priority: %u scopes: 0x%llx
%s:%d:%s: sessionID: 0x%x; property ID: %u
%s:%d:%s: interruption callback
%s:%d:%s: Received a pickable routes change notification
%s:%d:%s: Received a server death notification
%s:%d:%s: Received a routing context change notification
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_AudioInputAvailable
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_InterruptionInfo
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_InputGainScalar
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentHardwareOutputVolume
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_AudioRouteChange
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_PromptStyle
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentAudioFormats
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentHardwareInputNumberChannels
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentHardwareOutputNumberChannels
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_SecondaryAudioShouldBeSilencedHint
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_PickableRoutesChange
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_PiPAvailable
%s:%d:%s:  AudioSessionAddPropertyListener failed for kAudioSessionProperty_RoutingContextChange
%s:%d:%s: Initialization failed because there is no run loop thread.
%s:%d:%s: Synchronous connection to media server failed. Starting asynchronous connection attempt for session %p.
%s:%d:%s: Client app was linked against SDK version %x
%s:%d:%s: Lookup of session ID: 0x%x failed
%s:%d:%s: No valid string for category: %u
%s:%d:%s: Deactivating an audio session that has running I/O. All I/O should be stopped or paused prior to deactivating the audio session.
%s:%d:%s: Permission already granted
%s:%d:%s: Permission already denied
%s:%d:%s: Permission undetermined
%s:%d:%s:  Illegal permission property value returned from AudioSessionGetProperty
%s:%d:%s: No valid string for mode: %u
%s:%d:%s: Posting AVAudioSessionInterruptionNotification (Begin Interruption). Was suspended:%d
%s:%d:%s: Posting AVAudioSessionInterruptionNotification (End Interruption). Resumable:%d
%s:%d:%s: Posting AVAudioSessionMediaServicesWereLostNotification
%s:%d:%s: Notifying listeners that pickable routes changed
%s:%d:%s: Posting AVAudioSessionSilenceSecondaryAudioHintNotification
%s:%d:%s: Notifying listeners that routing context changed
%s:%d:%s: Completion handler called for with invalid session ID
%s:%d:%s: Posting AVAudioSessionMediaServicesWereResetNotification
%s:%d:%s: ---> for %s
%s:%d:%s: Getting previous route
%s:%d:%s: Getting new route dict
%s:%d:%s: Posting AVAudioSessionRouteChangeNotification. Reason: %@
%s:%d:%s: Updating inputDataSources: %@
%s:%d:%s: Updating outputDataSources: %@
%s:%d:%s: Failed to start internal run loop thread
%s:%d:%s: %@ category is not supported in combination with AVAudioSessionRouteSharingPolicyLongForm
%s:%d:%s: %@ mode is not supported in combination with AVAudioSessionRouteSharingPolicyLongForm
%s:%d:%s: 0x%x category option(s) not supported in combination with AVAudioSessionRouteSharingPolicyLongForm
%s:%d:%s: BT activation contexts is missing its Device ID
%s:%d:%s: Call activation context is missing the accesibility preference value
%s:%d:%s: Call activation context is missing the call direction value
%s:%d:%s: Could not load AudioDSP dylib.
%s:%d:%s: Could not find registerAUForOSXDevelopment in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_IsInitialized in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetNumCategories in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetCategoryName in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetNumCategoryValues in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetCategoryValueName in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetTimingModelOrder in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetCategoryDimensions in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetTimingDimensions in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetInterleavedCategoryAndTimingDimensions in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetFullCategoryDimension in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetFullTimingDimension in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_GetFullInterleavedDimension in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_EncodeStateTm in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_DecodeStateTm in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_EncodeStateTm_II in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_DecodeStateTm_II in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_EncodeState in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_DecodeState in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_EncodeTiming in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_DecodeTiming in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_EncodeFull in libAudioDSP.
%s:%d:%s: Could not find VAD3ConfigurationInterface_DecodeFull in libAudioDSP.
%s:%d:%s: Could not find PListReaderInterface_ReadPListFromFile in libAudioDSP.
%s:%d:%s: Unknown ID for Port
%s:%d:%s: Unknown type for Port
%s:%d:%s: Unknown name for Port
%s:%d:%s: Unknown UID for Port
%s:%d:%s: Unknown selected data source for Port %@ (type: %@)
%s:%d:%s: Unexpected nil value for port description
%s:%d:%s: Raw port type: %@
%s:%d:%s: Final port type: %@
%s:%d:%s: Error: Unable to call RegisterAudioUnits_Internal from libAudioDSP.dylib.
%s:%d:%s: unable to get property kAUDSPGraphProperty_GraphTextFilePath %i
%s:%d:%s: unable to get property kAUDSPGraphProperty_AUStrip %i
%s:%d:%s: Engine is in the middle of a config change, cannot play yet!
%s:%d:%s: Engine could not start the audio hardware dynamically, cannot play!
%s:%d:%s: Engine config changed when waiting for playback to begin, cannot play yet!
%s:%d:%s: IOUnit stopped when waiting for playback to begin, cannot play yet!
%s:%d:%s: AVVoiceTriggerClient init %@
%s:%d:%s: AVVoiceTriggerClient dealloc %@
%s:%d:%s: Engine@%p: could not initialize, error = %d
%s:%d:%s: Engine@%p: could not disable manual rendering mode
%s:%d:%s: [%s:%d:%s: (%s)] returned %s, error %@
%s:%d:%s: ERROR: subscope bits are set in scope: 0x%lx
%s:%d:%s: EXCEPTION (%d) [(nBytes * mNumberBuffers) > AllocatedBytes() is false]: ""
%s:%d:%s:  ca_verify_noerr: [%s, %d]
%s:%d:%s: couldn't get mach port limits info (%s)
%s:%d:%s: couldn't set mach port limits info (%s)
%s:%d:%s:  CAMutex::CAMutex: Could not init the mutex
%s:%d:%s:  CAMutex::Lock: Could not lock the mutex
%s:%d:%s:  CAMutex::Unlock: Could not unlock the mutex
%s:%d:%s:  CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own
%s:%d:%s:  CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)
%s:%d:%s:  PackednessIsSignificant only applies for PCM
%s:%d:%s:  CAGuard::CAGuard: Could not init the cond var
%s:%d:%s:  CAGuard::Wait: A thread has to have locked a guard before it can wait
%s:%d:%s:  CAGuard::Wait: Could not wait for a signal
%s:%d:%s:  CAGuard::WaitFor: A thread has to have locked a guard be for it can wait
%s:%d:%s:  CAGuard::WaitFor: Wait got an error
%s:%d:%s:  CAGuard::Notify: failed
%s:%d:%s:  CAGuard::NotifyAll: failed
%s:%d:%s: RealtimeMessenger: trying to enqueue duplicate invocation on message %p
%s:%d:%s:  CAPThread::SetPriority: failed to set the fixed-priority policy, Error: 0x%X
%s:%d:%s:  CAPThread::SetPriority: failed to set the precedence policy, Error: 0x%X
%s:%d:%s:  CAPThread::SetTimeConstraints: thread_policy_set failed, Error: %d (%s)
%s:%d:%s:  CAPThread::Start: can't start because the thread is already running
%s:%d:%s:  CAPThread::Start: Thread attributes could not be created.
%s:%d:%s:  CAPThread::Start: A thread could not be created in the detached state.
%s:%d:%s:  CAPThread::Start: Could not create a thread.
nwku
npdh
lchv
rkps
_ytt
