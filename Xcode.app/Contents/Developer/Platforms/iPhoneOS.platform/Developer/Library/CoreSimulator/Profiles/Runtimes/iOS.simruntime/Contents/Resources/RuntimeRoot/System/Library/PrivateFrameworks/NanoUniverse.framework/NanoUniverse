Nl=!
?${5@
?@(#)PROGRAM:NanoUniverse  PROJECT:NanoTimeKit-1
init
collectionType
position
_updateCamera
_updatePositionFromAngle
date:toRotation:toAngle:toLight:toDistance:toRadius:
orbit
alloc
initWithDate:body:
longitude
calculateGeocentricDirectionForSunX:Y:Z:date:
alCity
latitude
setCenterCoordinate:animated:
initWithAnimatable:value:key:
addAnimation:
removeAllAnimationsFor:withKeys:
focus
isAnimating:forKeys:
spheroidOfType:
homeCoordinate
setCamera:target:up:roll:
setCenterCoordinate:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
animatedFloatForKey:
setAnimatedFloat:forKey:
setHomeCoordinate:
centerCoordinate
initWithScene:parent:type:
setDistanceScale:
date:toCameraPosition:toCameraTarget:
updateSunLocationForDate:
centerOnCity:
setCenter:
.cxx_destruct
type
parent
distance
setDistance:
distanceScale
angle
setAngle:
rotation
setRotation:
opacity
setOpacity:
colorize
setColorize:
radius
radiusScale
setRadiusScale:
light
programType
spriteType
setSpriteType:
isVisible
setVisible:
isFacing
setFacing:
_scene
_visible
_facing
_distance
_distanceScale
_angle
_rotation
_opacity
_radius
_radiusScale
_type
_parent
_light
_programType
_spriteType
_colorize
_position
_homeCoordinate
_centerCoordinate
addObject:
setSnap:
setDate:
date
countByEnumeratingWithState:objects:count:
frameInterval
update:
indexOfObject:
addIndex:
observer
universeAnimationFinished:
count
removeObjectsAtIndexes:
animatable
removeAnimation:
removeObject:
initWithAnimatable:from:to:key:
updateSunLocationForDate:animated:
initWithSphereoids:currentDateBlock:
snap
acceptableFrameInterval
updateSunLocation
updateFromDateIfNeeded
isUpdatable
setUpdatable:
spheroids
target
setFocus:
setOrbit:
roll
setRoll:
minFrameInterval
setMinFrameInterval:
backgroundType
setBackgroundType:
projectionType
setProjectionType:
setCollectionType:
currentDateBlock
setCurrentDateBlock:
yearsSince1970
_spheroids
_snap
_animations
_date
_currentDateBlock
_isUpdateNeeded
_isUpdatable
_orbit
_roll
_minFrameInterval
_yearsSince1970
_focus
_backgroundType
_projectionType
_collectionType
_target
timeIntervalSince1970
initWithFrame:
sharedRenderingContext
device
quadViewWithFrame:options:
addSubview:
addQuad:
setPaused:
setDelegate:
isOpaque
setOpaque:
layoutSubviews
bounds
setFrame:
setPreferredFramesPerSecond:
isPaused
renderSynchronouslyWithImageQueueDiscard:
scene
setScene:
snapshot:size:
screenScale
snapshotInRect:scale:time:
quadViewWillDisplay:forTime:
setAnimationFrameInterval:
startAnimation
stopAnimation
snapshot
_device
_context
_quadView
_quad
sharedInstance
createVertexArray
renderWithScene:viewport:
prepare
encodeGLforSize:
_isPrepared
_vertexArray
_baseTime
initWithAnimatable:from:to:ctrl1:ctrl2:key:
initWithAnimatable:values:count:key:
startTime
setStartTime:
duration
setDuration:
delay
setDelay:
setFrameInterval:
from
setFrom:
setTo:
isRepeat
setRepeat:
function
setFunction:
setKey:
setAnimatable:
setObserver:
_ctrl1
_ctrl2
_values
_valuesCount
_prevTime
_pauseTime
_repeat
_paused
_startTime
_duration
_delay
_frameInterval
_function
_key
_animatable
_observer
_from
dictionary
numberWithInteger:
setObject:forKey:
objectForKey:
dealloc
addVertices:count:
addIndices:count:vbase:
vertices
indices
vcount
icount
_vertices
_indices
_vcount
_icount
bundleForClass:
shareGroup
initWithAPI:sharegroup:
_initPrograms
_initHemi
_initTextures
defaultCenter
_asyncDeallocInstance
addObserver:selector:notificationName:
removeObserver:notificationName:
_renderWithScene:viewport:prime:
_requireTexture:sync:
imageWithCGImage:
atlasBackingWithArt:uuid:
path
atlasBackingWithBytes:length:mmapFile:uuid:
structure
_loadTexture:
stringWithFormat:
pathForResource:ofType:
isMainThread
_deallocInstance
performSelectorOnMainThread:withObject:waitUntilDone:
_purge
_prime
prime
purge
_shareGroup
_bundle
_resources
_initalizedProgams
_initalizedHemi
_initalizedTextures
_initalized
_octahedronGeomRange
_quadGeomRange
NUSpheroid
NUAnimatable
NSObject
NURotatable
NUScene
NUView
CLKUIQuadViewDelegate
NUGLQuad
NUAnimation
_NUGeometry
NURenderer
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
24@0:8Q16
v40@0:816Q32
v36@0:8{CLLocationCoordinate2D=dd}16B32
{CLLocationCoordinate2D=dd}16@0:8
v32@0:8{CLLocationCoordinate2D=dd}16
@40@0:8@16@24Q32
v16@0:8
v20@0:8f16
v40@0:8@16^24^32
v64@0:8@16^f24^f32^40^f48^f56
v24@0:8@16
v32@0:8{CGPoint=dd}16
f16@0:8
16@0:8
v32@0:816
v24@0:8Q16
v20@0:8B16
@"NUScene"
@"NUSpheroid"
{CLLocationCoordinate2D="latitude"d"longitude"d}
@32@0:8Q16@?24
i16@0:8
B32@0:8@16Q24
v32@0:8@16Q24
v28@0:8@16B24
@24@0:8Q16
v68@0:8163248f64
v20@0:8i16
@?16@0:8
v24@0:8@?16
@"NSMutableArray"
@"NSDate"
v32@0:8@16d24
v32@0:8@"CLKUIQuadView"16d24
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@40@0:8@16{CGSize=dd}24
@"CLKDevice"
@"EAGLContext"
@"CLKUIQuadView"
@"NUGLQuad"
v24@0:8{CLKUIQuadSize=ii}16
@44@0:8@16^24i32Q36
@96@0:8@1624405672Q88
@64@0:8@162440Q56
@48@0:8@1624Q40
B20@0:8f16
[75]
@"<NUAnimatable>"
@"<NUAnimationObserver>"
i28@0:8r^16i24
i32@0:8r^S16i24i28
r^16@0:8
r^S16@0:8
I16@0:8
v40@0:8@16{NUViewport=iiii}24
v44@0:8@16{NUViewport=iiii}24B40
v28@0:8Q16B24
@"EAGLSharegroup"
@"NSBundle"
{NURendererResources="programs"[3{NUProgram="program"I"uniforms"[13i]}]"vertexBuffer"I"indexBuffer"I"atlasTexture"I"loadedTexturesSet"Q"priTextures"[23I]"secTextures"[23I]"dummyCubeTexture"I"dummy2dTexture"I}
{_NUGeometryRange="start"i"count"i}
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
homeCoordinate
T{CLLocationCoordinate2D=dd},N
centerCoordinate
type
TQ,R,N,V_type
parent
T@"NUSpheroid",R,N,V_parent
distance
Tf,N,V_distance
distanceScale
Tf,N,V_distanceScale
angle
Tf,N,V_angle
rotation
Tf,N,V_rotation
opacity
Tf,N,V_opacity
colorize
T,N,V_colorize
radius
Tf,R,N,V_radius
radiusScale
Tf,N,V_radiusScale
position
T,R,N,V_position
light
T,R,N,V_light
programType
TQ,R,N,V_programType
spriteType
TQ,N,V_spriteType
T{CLLocationCoordinate2D=dd},N,V_homeCoordinate
T{CLLocationCoordinate2D=dd},N,V_centerCoordinate
visible
TB,N,GisVisible,V_visible
facing
TB,N,GisFacing,V_facing
target
T,R,N,V_target
T,R,N,V_up
focus
T@"NUSpheroid",&,N,V_focus
orbit
Tf,N,V_orbit
roll
Tf,N,V_roll
minFrameInterval
Ti,N,V_minFrameInterval
acceptableFrameInterval
Ti,R,N
snap
TQ,D,N
backgroundType
TQ,N,V_backgroundType
projectionType
TQ,N,V_projectionType
collectionType
TQ,N,V_collectionType
spheroids
T@"NSArray",R,N,V_spheroids
date
T@"NSDate",&,D,N
currentDateBlock
T@?,C,N,V_currentDateBlock
updatable
TB,N,GisUpdatable,V_isUpdatable
yearsSince1970
Tf,R,N,V_yearsSince1970
scene
T@"NUScene",&,N
T@"NUScene",&,N,V_scene
-[NUAnimation initWithAnimatable:values:count:key:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/NanoTimeKitCompanion_Sim/NanoTimeKitCompanion-1096.11/NanoUniverse/NUAnimation.m
false
startTime
Tf,N,V_startTime
duration
Tf,N,V_duration
delay
Tf,N,V_delay
frameInterval
Ti,N,V_frameInterval
from
T,N,V_from
T,N,V_to
repeat
TB,N,GisRepeat,V_repeat
paused
TB,N,GisPaused,V_paused
function
TQ,N,V_function
TQ,N,V_key
animatable
T@"<NUAnimatable>",&,N,V_animatable
observer
T@"<NUAnimationObserver>",W,N,V_observer
uPrimaryTexture
uSecondaryTexture
uViewMatrix
uModelMatrix
uModelPosition
uPositionMatrix
uCloudMatrix
uLightDirection
uViewDirection
uSprite
uOpacity
uColorize
uMixer
v8@?0
NanoUniverse
nanouniverse
vertices
Tr^,R,N,V_vertices
indices
Tr^S,R,N,V_indices
vcount
Ti,R,N,V_vcount
icount
Ti,R,N,V_icount
c%dd
c%dn
@"NSDate"8@?0
shareGroup
T@"EAGLSharegroup",R,N,V_shareGroup
com.apple.nu.queue
attribute vec3 aPosition; uniform highp vec3 uModelPosition; uniform highp mat4 uModelMatrix; uniform highp mat4 uViewMatrix; uniform highp mat4 uPositionMatrix; uniform mediump mat3 uCloudMatrix; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec4 lpos = vec4(aPosition, 1.0); highp vec4 wpos = uModelMatrix * lpos; vViewPosition = (uViewMatrix * wpos).xyz; highp vec3 wnrm = normalize(wpos.xyz - uModelPosition); vPrimaryCoord = lpos.xyz; vViewNormal = (uViewMatrix * vec4(wnrm, 0.0)).xyz; mediump vec3 cpos = uCloudMatrix * lpos.xyz; vSecondaryCoord = cpos; gl_Position = uPositionMatrix * lpos; }
uniform samplerCube uPrimaryTexture; uniform samplerCube uSecondaryTexture; uniform mediump vec4 uColorize; uniform mediump float uOpacity; uniform mediump vec3 uLightDirection; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec3 tc = vPrimaryCoord; mediump vec3 cc = vSecondaryCoord; mediump vec3 absTexCoord = abs(tc); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); mediump vec3 absCloudCoord = abs(cc); mediump float cmax = max(max(absCloudCoord.x, absCloudCoord.y), absCloudCoord.z); tc /= tmax; cc /= cmax; mediump vec3 albedoRGB = textureCube(uPrimaryTexture, tc).rgb; mediump float illumAmt = textureCube(uSecondaryTexture, tc).g; mediump float clouds = textureCube(uSecondaryTexture, cc).r; clouds *= clouds; mediump vec3 albedoBaseColor = albedoRGB; mediump float specularAmt = max(albedoRGB.g - 0.1, 0.0)/0.9; mediump vec3 normal = normalize(vViewNormal); mediump float NdotL = dot(normal, uLightDirection); mediump vec3 rfl = normal*(2.0*NdotL) - uLightDirection; mediump vec3 lightReflect = normalize(rfl); mediump vec3 viewDirection = -normalize(vViewPosition); mediump float specularFac = pow(max(dot(viewDirection, lightReflect), 0.0), 11.0); mediump float maxNdotL0 = max(NdotL, 0.0); mediump float fresnelBase = 1.0 - abs(dot(viewDirection, normal)); mediump float fresnelFac = pow(fresnelBase, 3.0)*maxNdotL0; albedoBaseColor = mix(albedoBaseColor, vec3(0.226, 0.229, 0.581), min(fresnelFac*1.5, 1.0)*(1.0 - specularAmt*0.7)); mediump float ambient = 0.03; mediump vec3 albedo = albedoBaseColor*(maxNdotL0 + ambient) + vec3(illumAmt, illumAmt*(0.75*illumAmt + 0.25), 0.0)*max(-NdotL, 0.0) + vec3(0.226, 0.229, 0.581)*min(specularAmt*specularFac + fresnelFac, 1.0); mediump vec3 cloudDiffuse = mix(vec3(0.402, 0.402, 0.726), vec3(0.683, 0.719, 0.994), smoothstep(0.2, 0.7, clouds)); cloudDiffuse *= smoothstep(0.0, 0.5, maxNdotL0)*(1.0 - 0.02) + 0.02; cloudDiffuse = mix(cloudDiffuse, vec3(0.226, 0.229, 0.581), min(fresnelFac*5.0, 1.0)); albedo = mix(albedo, cloudDiffuse, smoothstep(0.0, 0.3, clouds)*max(1.0 - fresnelFac*2.0, 0.0)*0.95); mediump float falloff = smoothstep(0.17364817766693033, 0.17364817766693033 + 0.1, 1.0 - fresnelBase); mediump float alpha = falloff*uOpacity; gl_FragColor = vec4(albedo*alpha, alpha); }
attribute vec3 aPosition; uniform mat4 uPositionMatrix; uniform mediump vec4 uSprite; varying mediump vec2 vTexCoord; void main() { vTexCoord = uSprite.xy + (aPosition.xy*0.5+0.5)*uSprite.zw; gl_Position = uPositionMatrix * vec4(aPosition.xy, 0.0, 1); }
uniform sampler2D uPrimaryTexture; uniform mediump float uOpacity; varying mediump vec2 vTexCoord; void main() { mediump vec4 albedo = texture2D(uPrimaryTexture, vTexCoord); gl_FragColor = albedo * uOpacity; }
attribute vec3 aPosition; uniform highp vec3 uModelPosition; uniform highp mat4 uModelMatrix; uniform highp mat4 uViewMatrix; uniform highp mat4 uPositionMatrix; varying mediump vec3 vPrimaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec4 lpos = vec4(aPosition, 1.0); highp vec4 wpos = uModelMatrix * lpos; vViewPosition = (uViewMatrix * wpos).xyz; highp vec3 wnrm = normalize(wpos.xyz - uModelPosition); vPrimaryCoord = lpos.xyz; vViewNormal = (uViewMatrix * vec4(wnrm, 0.0)).xyz; gl_Position = uPositionMatrix * lpos; }
uniform samplerCube uPrimaryTexture; uniform samplerCube uSecondaryTexture; uniform mediump vec4 uColorize; uniform mediump float uOpacity; uniform mediump vec3 uLightDirection; uniform highp mat4 uModelMatrix; uniform highp mat4 uViewMatrix; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec3 tc = vPrimaryCoord; mediump vec3 absTexCoord = abs(tc); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); tc /= tmax; mediump vec3 albedoRGB = textureCube(uPrimaryTexture, tc).rgb; mediump vec3 normalRGB = textureCube(uSecondaryTexture, tc).rgb; mediump vec3 lnormal = normalize(normalRGB*2.0 - 1.0); mediump vec3 wnormal = normalize((uModelMatrix * vec4(lnormal, 0.0)).xyz); mediump vec3 vnormal = normalize(vViewNormal); mediump vec3 normal = (uViewMatrix * vec4(wnormal, 0.0)).xyz; mediump float NdotL = dot(normal, uLightDirection); mediump float RdotL = dot(vnormal, uLightDirection); mediump float inten = max(NdotL, 0.0)*smoothstep(-0.1, 0.1, RdotL); mediump vec3 viewDirection = -normalize(vViewPosition); mediump float fresnelBase = 1.0 - abs(dot(viewDirection, vnormal)); mediump vec3 albedo = albedoRGB*(inten*(1.0 - 0.04) + 0.04); albedo = mix(albedo, uColorize.rgb, uColorize.a); mediump float falloff = smoothstep(0.17364817766693033, 0.17364817766693033 + 0.1, 1.0 - fresnelBase); mediump float alpha = falloff*uOpacity; gl_FragColor = vec4(albedo*alpha, alpha); }
atlas
Program validate log:
Failed to validate program %d
Failed to compile shader:
Failed to link program %d
snapshot begin
Failed to make complete framebuffer object %x
snapshot end
_requireTexture:%lu sync:%d
_loadTexture:%lu
purge texture %d
purge texture %lu
Failed to make complete framebuffer object for warmup %x
t not at right position
v not at right position
