?${5@
?@(#)PROGRAM:NanoUniverse  PROJECT:NanoTimeKit-1
init
position
_updateCamera
_updatePositionFromAngle
date:toRotation:toAngle:toLight:toDistance:
orbit
alloc
initWithDate:body:
longitude
calculateGeocentricDirectionForSunX:Y:Z:date:
alCity
latitude
setCenterCoordinate:animated:
initWithAnimatable:value:key:
addAnimation:
removeAllAnimationsFor:withKeys:
focus
isAnimating:forKeys:
spheroidOfType:
homeCoordinate
setCamera:target:up:roll:
setCenterCoordinate:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
animatedFloatForKey:
setAnimatedFloat:forKey:
setHomeCoordinate:
centerCoordinate
initWithScene:parent:type:
distanceScale
setDistanceScale:
date:toCameraPosition:toCameraTarget:
updateSunLocationForDate:
centerOnCity:
setCenter:
.cxx_destruct
type
parent
distance
setDistance:
angle
setAngle:
radius
opacity
setOpacity:
colorize
setColorize:
radiusScale
setRadiusScale:
light
rotation
setRotation:
programType
spriteType
setSpriteType:
visible
setVisible:
facing
setFacing:
_type
_programType
_parent
_distance
_angle
_radius
_rotation
_radiusScale
_opacity
_distanceScale
_colorize
_position
_light
_spriteType
_homeCoordinate
_centerCoordinate
_visible
_facing
_scene
addObject:
setSnap:
setDate:
date
countByEnumeratingWithState:objects:count:
frameInterval
update:
indexOfObject:
addIndex:
observer
universeAnimationFinished:
count
removeObjectsAtIndexes:
animatable
removeAnimation:
removeObject:
initWithAnimatable:from:to:key:
updateSunLocationForDate:animated:
initWithSphereoids:currentDateBlock:
snap
acceptableFrameInterval
updateSunLocation
updateFromDateIfNeeded
updatable
setUpdatable:
setOrbit:
yearsSince1970
minFrameInterval
setMinFrameInterval:
target
roll
setRoll:
setFocus:
spheroids
projectionType
setProjectionType:
backgroundType
setBackgroundType:
currentDateBlock
setCurrentDateBlock:
_orbit
_roll
_yearsSince1970
_minFrameInterval
_spheroids
_focus
_target
_snap
_backgroundType
_projectionType
_animations
_date
_currentDateBlock
_isUpdateNeeded
_isUpdatable
timeIntervalSince1970
_stopAnimation
window
_startAnimation
layer
setOpaque:
numberWithBool:
dictionaryWithObjectsAndKeys:
setDrawableProperties:
setAsynchronous:
mainScreen
scale
setContentScaleFactor:
sharedInstance
currentContext
shareGroup
initWithAPI:sharegroup:
setCurrentContext:
createVertexArray
initWithFrame:
_init
initWithCoder:
stopAnimation
dealloc
drawView:
_resizeFramebuffer
setAnimationFrameInterval:
renderWithScene:viewport:
scene
viewport
presentRenderbuffer:
renderbufferStorage:fromDrawable:
displayLinkWithTarget:selector:
setPreferredFramesPerSecond:
mainRunLoop
addToRunLoop:forMode:
invalidate
discardContents
defaultCenter
_backgrounded:
addObserver:selector:name:object:
_foregrounded:
removeObserver:name:object:
bounds
snapshot:size:
layerClass
willMoveToWindow:
addPortal:
drawRect:
layoutSubviews
animationFrameInterval
renderSynchronouslyWithImageQueueDiscard:
startAnimation
snapshot
isAnimating
setScene:
backingWidth
backingHeight
_context
_frameInterval
_displayLink
_isAnimated
_isAnimating
_backingWidth
_backingHeight
_vertexArray
_defaultFramebuffer
_colorRenderbuffer
_depthRenderbuffer
_portals
_baseTime
initWithAnimatable:from:to:ctrl1:ctrl2:key:
initWithAnimatable:values:count:key:
pause
setPause:
startTime
setStartTime:
duration
setDuration:
from
setFrom:
setTo:
delay
setDelay:
setKey:
setAnimatable:
function
setFunction:
setObserver:
setFrameInterval:
repeat
setRepeat:
_from
_ctrl1
_ctrl2
_values
_valuesCount
_startTime
_duration
_prevTime
_pauseTime
_delay
_key
_animatable
_repeat
_paused
_observer
_function
dictionary
numberWithInteger:
setObject:forKey:
objectForKey:
bundleForClass:
initWithAPI:
sharegroup
_initPrograms
_initHemi
_initTextures
_asyncDeallocInstance
addObserver:selector:notificationName:
removeObserver:notificationName:
_renderWithScene:viewport:prime:
_requireTexture:sync:
imageWithCGImage:
textureBackingWithArt:
path
textureBackingWithBytes:length:mmapFile:uuid:
structure
_loadTexture:
stringWithFormat:
pathForResource:ofType:
isMainThread
_deallocInstance
performSelectorOnMainThread:withObject:waitUntilDone:
_purge
_prime
prime
purge
_shareGroup
_bundle
_resources
_initalizedProgams
_initalizedHemi
_initalizedTextures
_initalized
setFrame:boundSize:contentScaleFactor:
initWithFrame:boundSize:contentScaleFactor:
frame
setViewport:
_viewport
NUSpheroid
NUAnimatable
NSObject
NURotatable
NUScene
NUView
NUAnimation
NURenderer
NUPortal
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
24@0:8Q16
v40@0:816Q32
v36@0:8{CLLocationCoordinate2D=dd}16B32
{CLLocationCoordinate2D=dd}16@0:8
v32@0:8{CLLocationCoordinate2D=dd}16
@40@0:8@16@24Q32
v16@0:8
f16@0:8
v20@0:8f16
v40@0:8@16^24^32
v56@0:8@16^f24^f32^40^f48
v24@0:8@16
v32@0:8{CGPoint=dd}16
16@0:8
v32@0:816
v24@0:8Q16
v20@0:8B16
@"NUSpheroid"
{CLLocationCoordinate2D="latitude"d"longitude"d}
@"NUScene"
@32@0:8Q16@?24
i16@0:8
B32@0:8@16Q24
v32@0:8@16Q24
v28@0:8@16B24
@24@0:8Q16
v68@0:8163248f64
v20@0:8i16
@?16@0:8
v24@0:8@?16
@"NSMutableArray"
@"NSDate"
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@24@0:8@16
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@40@0:8@16{CGSize=dd}24
@"EAGLContext"
@"CADisplayLink"
@44@0:8@16^24i32Q36
@96@0:8@1624405672Q88
@64@0:8@162440Q56
@48@0:8@1624Q40
B20@0:8f16
[75]
@"<NUAnimatable>"
@"<NUAnimationObserver>"
I16@0:8
v40@0:8@16{NUViewport=iiII}24
v44@0:8@16{NUViewport=iiII}24B40
v28@0:8Q16B24
@"EAGLSharegroup"
@"NSBundle"
{NURendererResources="programs"[7{NUProgram="program"I"uniforms"[11i]}]"vertexBuffer"I"indexBuffer"I"atlasTexture"I"loadedTexturesSet"Q"priTextures"[29I]"secTextures"[29I]"dummyCubeTexture"I"dummy2dTexture"I}
@72@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16{CGSize=dd}48d64
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
v72@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16{CGSize=dd}48d64
{NUViewport=iiII}16@0:8
v32@0:8{NUViewport=iiII}16
{NUViewport="x"i"y"i"width"I"height"I}
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
homeCoordinate
T{CLLocationCoordinate2D=dd},N
centerCoordinate
type
TQ,R,N,V_type
parent
T@"NUSpheroid",R,N,V_parent
distance
Tf,N,V_distance
distanceScale
Tf,D,N
angle
Tf,N,V_angle
rotation
Tf,N,V_rotation
opacity
Tf,N,V_opacity
colorize
T,N,V_colorize
radius
Tf,R,N,V_radius
radiusScale
Tf,N,V_radiusScale
position
T,R,N,V_position
light
T,R,N,V_light
programType
TQ,R,N,V_programType
spriteType
TQ,N,V_spriteType
T{CLLocationCoordinate2D=dd},N,V_homeCoordinate
T{CLLocationCoordinate2D=dd},N,V_centerCoordinate
visible
TB,N,V_visible
facing
TB,N,V_facing
target
T,R,N,V_target
T,R,N,V_up
focus
T@"NUSpheroid",&,N,V_focus
orbit
Tf,N,V_orbit
roll
Tf,N,V_roll
minFrameInterval
Ti,N,V_minFrameInterval
acceptableFrameInterval
Ti,R,N
snap
TQ,D,N
backgroundType
TQ,N,V_backgroundType
projectionType
TQ,N,V_projectionType
spheroids
T@"NSArray",R,N,V_spheroids
date
T@"NSDate",&,D,N
currentDateBlock
T@?,C,N,V_currentDateBlock
updatable
TB,N,V_isUpdatable
yearsSince1970
Tf,R,N,V_yearsSince1970
animating
TB,R,N,GisAnimating,V_isAnimating
animationFrameInterval
Ti,D,N
scene
T@"NUScene",&,N,V_scene
backingWidth
Ti,R,N,V_backingWidth
backingHeight
Ti,R,N,V_backingHeight
-[NUAnimation initWithAnimatable:values:count:key:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/NanoTimeKitCompanion_Sim/NanoTimeKitCompanion-634/NanoUniverse/NUAnimation.m
false
startTime
Tf,N,V_startTime
duration
Tf,N,V_duration
delay
Tf,N,V_delay
frameInterval
Ti,N,V_frameInterval
from
T,N,V_from
T,N,V_to
repeat
TB,N,V_repeat
pause
TB,D,N
function
TQ,N,V_function
TQ,N,V_key
animatable
T@"<NUAnimatable>",&,N,V_animatable
observer
T@"<NUAnimationObserver>",W,N,V_observer
uPrimaryTexture
uSecondaryTexture
uRotationMatrix
uPositionMatrix
uCloudMatrix
uLightDirection
uViewDirection
uSprite
uOpacity
uColorize
uMixer
NanoUniverse
v8@?0
nanouniverse
c%dd
c%dn
@"NSDate"8@?0
shareGroup
T@"EAGLSharegroup",R,N,V_shareGroup
com.apple.nu.queue
attribute vec3 aPosition; uniform mediump mat3 uRotationMatrix; uniform mediump mat3 uCloudMatrix; uniform mediump mat4 uPositionMatrix; uniform mediump vec3 uLightDirection; uniform mediump vec3 uViewDirection; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying mediump vec3 vPack; void main() { mediump vec3 tc = uRotationMatrix * aPosition; mediump vec3 cc = uCloudMatrix * aPosition; mediump vec3 absTexCoord = abs(tc); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); mediump vec3 absCloudCoord = abs(cc); mediump float cmax = max(max(absCloudCoord.x, absCloudCoord.y), absCloudCoord.z); mediump vec3 normal = normalize(tc); mediump float NdotL = dot(normal, uLightDirection); mediump vec3 rfl = normal*(2.0*NdotL) - uLightDirection; mediump vec3 lightReflect = normalize(rfl); mediump float specularFactor = max(dot(uViewDirection, lightReflect), 0.0); vPrimaryCoord = tc / tmax; vSecondaryCoord = cc / cmax; vPack = vec3(NdotL, specularFactor*max(NdotL, 0.0), smoothstep(0.17364817766693033, 0.17364817766693033 + 0.35, aPosition.z)); gl_Position = uPositionMatrix * vec4(aPosition, 1); }
uniform samplerCube uPrimaryTexture; uniform samplerCube uSecondaryTexture; uniform mediump vec4 uColorize; uniform mediump float uOpacity; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying mediump vec3 vPack; void main() { mediump vec3 tc = vPrimaryCoord; mediump vec3 atc = abs(tc); if (atc.x > atc.y) { if (atc.x > atc.z) { tc.yz *= 254.0 / 256.0; } else { tc.xy *= 254.0 / 256.0; } } else { if (atc.y > atc.z) { tc.xz *= 254.0 / 256.0; } else { tc.xy *= 254.0 / 256.0; } } mediump vec3 albedoRGB = textureCube(uPrimaryTexture, tc).rgb; mediump vec2 albedoSI = textureCube(uSecondaryTexture, vPrimaryCoord).rb; mediump float clouds = textureCube(uSecondaryTexture, vSecondaryCoord).g; mediump vec3 albedoBaseColor = albedoRGB*3.0; mediump float specularAmt = albedoSI.r; mediump float illumAmt = albedoSI.g; mediump float NdotL = vPack.x; mediump float maxNdotL0 = max(NdotL, 0.0); mediump float specularFac = vPack.y*vPack.y*vPack.y; mediump float ambient = specularAmt*0.01 + 0.01; mediump vec3 albedo = albedoBaseColor*(maxNdotL0*(1.0 - ambient) + ambient) + vec3(illumAmt, illumAmt*(0.75*illumAmt + 0.25), 0.0)*max(-NdotL, 0.0) + vec3(0.2, 0.3, 0.4)*(specularAmt*specularFac*specularFac); albedo = mix(albedo, vec3(maxNdotL0*0.95 + 0.05), clouds*clouds); albedo = mix(albedo, uColorize.rgb, uColorize.a); mediump float alpha = vPack.z*uOpacity; gl_FragColor = vec4(albedo*alpha, alpha); }
attribute vec3 aPosition; uniform mat3 uRotationMatrix; uniform mat4 uPositionMatrix; varying mediump vec4 vTexCoord; void main() { vTexCoord = vec4(uRotationMatrix * aPosition, aPosition.z); gl_Position = uPositionMatrix * vec4(aPosition, 1); }
uniform samplerCube uPrimaryTexture; uniform mediump vec3 uLightDirection; uniform mediump float uOpacity; varying mediump vec4 vTexCoord; void main() { mediump vec3 normal = normalize(vTexCoord.xyz); mediump vec3 absTexCoord = abs(vTexCoord.xyz); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); mediump vec3 texcoord = vTexCoord.xyz / tmax; mediump float NdotL = dot(normal, uLightDirection); mediump vec3 albedo = textureCube(uPrimaryTexture, texcoord).rgb * (max(NdotL, 0.0) * (1.0 - 0.15) + 0.15); mediump float alpha = smoothstep(0.5, 0.7, vTexCoord.w) * uOpacity; gl_FragColor = vec4(albedo * alpha, alpha); }
uniform mediump float uOpacity; uniform samplerCube uPrimaryTexture; varying mediump vec4 vTexCoord; void main() { mediump vec3 absTexCoord = abs(vTexCoord.xyz); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); mediump vec3 texcoord = vTexCoord.xyz / tmax; mediump float alpha = smoothstep(0.1, 0.4, vTexCoord.w) * uOpacity; mediump vec3 albedo = textureCube(uPrimaryTexture, texcoord).rgb; gl_FragColor = vec4(albedo*alpha, alpha); }
attribute vec3 aPosition; uniform mat3 uRotationMatrix; uniform mat4 uPositionMatrix; varying mediump vec3 vTexCoord; varying mediump vec3 vPosition; void main() { vPosition = aPosition; vTexCoord = uRotationMatrix * aPosition; gl_Position = uPositionMatrix * vec4(aPosition, 1); }
uniform mediump float uOpacity; uniform samplerCube uPrimaryTexture; varying mediump vec3 vTexCoord; varying mediump vec3 vPosition; void main() { mediump vec3 absTexCoord = abs(vPosition); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); mediump vec3 texcoord = vPosition / tmax; mediump vec3 albedo = textureCube(uPrimaryTexture, texcoord).rgb; mediump float alpha = smoothstep(0.1, 0.4, vPosition.z) * uOpacity; absTexCoord = abs(vTexCoord); tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); texcoord = vTexCoord / tmax; gl_FragColor = vec4(mix(vec3(1.0), vec3(0.15), smoothstep(-0.05, 0.05, texcoord.x))*albedo*alpha, alpha); }
attribute vec3 aPosition; uniform mat4 uPositionMatrix; uniform mediump vec4 uSprite; varying mediump vec2 vTexCoord; void main() { vTexCoord = uSprite.xy + (aPosition.xy*0.5+0.5)*uSprite.zw; gl_Position = uPositionMatrix * vec4(aPosition.xy, 0.0, 1); }
uniform sampler2D uPrimaryTexture; uniform mediump float uOpacity; varying mediump vec2 vTexCoord; void main() { mediump vec4 albedo = texture2D(uPrimaryTexture, vTexCoord); gl_FragColor = albedo * uOpacity; }
attribute vec3 aPosition; uniform mat4 uPositionMatrix; uniform mat3 uRotationMatrix; varying mediump vec4 vTexCoord; void main() { mediump float dist = aPosition.z; mediump vec3 pos = vec3(aPosition.xy*0.9396926207859084, 0.3420201433256687); vTexCoord = vec4(uRotationMatrix * pos, dist); pos.xy += (0.075 * (dist*2.0 - 1.0)) * aPosition.xy; gl_Position = uPositionMatrix * vec4(pos, 1); }
uniform mediump vec3 uLightDirection; uniform mediump float uOpacity; varying mediump vec4 vTexCoord; void main() { mediump float dist = vTexCoord.w; mediump vec3 normal = normalize(vTexCoord.xyz); mediump float inten = smoothstep(-1.0, 1.0, dot(normal, uLightDirection) - dist*dist)*0.75 + 0.25; mediump float blend = (1.0 - abs(dist*2.0 - 1.0)); mediump float alpha = blend * inten; alpha *= alpha; alpha *= alpha; alpha *= 0.65 * uOpacity; gl_FragColor = vec4(mix(vec3(0.1, 0.25, 0.4), vec3(0.2, 1.0, 1.0), blend*blend*blend)*alpha, alpha); }
attribute vec3 aPosition; uniform mediump mat3 uRotationMatrix; uniform mediump mat4 uPositionMatrix; varying mediump vec3 vPrimaryCoord; varying mediump float vAlpha; void main() { mediump vec3 tc = uRotationMatrix * aPosition; mediump vec3 absTexCoord = abs(tc); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); vPrimaryCoord = tc / tmax; vAlpha = smoothstep(0.17364817766693033, 0.17364817766693033 + 0.35, aPosition.z); gl_Position = uPositionMatrix * vec4(aPosition, 1); }
uniform samplerCube uPrimaryTexture; uniform samplerCube uSecondaryTexture; uniform mediump vec3 uLightDirection; uniform mediump vec4 uColorize; uniform mediump float uOpacity; varying mediump vec3 vPrimaryCoord; varying mediump float vAlpha; void main() { mediump vec3 normalRGB = textureCube(uSecondaryTexture, vPrimaryCoord).rgb; mediump vec3 normal = normalize(normalRGB*2.0 - 1.0); mediump float NdotL = dot(normal, uLightDirection); mediump float RdotL = dot(normalize(vPrimaryCoord), uLightDirection); mediump float inten = max(NdotL, 0.0)*smoothstep(-0.1, 0.1, RdotL); mediump vec3 albedo = textureCube(uPrimaryTexture, vPrimaryCoord).rgb*(inten*(1.0 - 0.04) + 0.04); mediump float alpha = vAlpha*uOpacity; albedo = mix(albedo, uColorize.rgb, uColorize.a); gl_FragColor = vec4(albedo * alpha, alpha); }
atlas
viewport
T{NUViewport=iiII},N,V_viewport
Program validate log:
Failed to validate program %d
Failed to compile shader:
Failed to link program %d
t not at right position
snapshot begin
Failed to make complete framebuffer object %x
snapshot end
_requireTexture:%lu sync:%d
_loadTexture:%lu
purge texture %d
purge texture %lu
Failed to make complete framebuffer object for warmup %x
