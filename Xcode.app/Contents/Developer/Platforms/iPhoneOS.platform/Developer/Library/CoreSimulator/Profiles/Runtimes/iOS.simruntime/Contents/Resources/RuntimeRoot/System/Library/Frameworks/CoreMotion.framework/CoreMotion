25CLDeviceMotionLiteService
CNSt3__120__shared_ptr_emplaceI19CLConnectionMessageNS_9allocatorIS1_EEEE
18CLFilteredPressure
N16CLMotionNotifier18CallbackDispatcherIN10CLPressure6SampleEEE
N16CLMotionNotifier10DispatcherE
18CLCompass7FastPath
24CLIoHidFastPathInterface
NSt3__120__shared_ptr_pointerIPN24CLIoHidFastPathInterface14FastPathDeviceENS_14default_deleteIS2_EENS_9allocatorIS2_EEEE
NSt3__114default_deleteIN24CLIoHidFastPathInterface14FastPathDeviceEEE
10CLCompass7
@fffff
@<@A
31CLGyroBiasEstimatorClientRemote
15CLNameValuePair
10BasicMutex
5Mutex
11NonCopyable
21DestructionAwareMutex
NSt3__120__shared_ptr_pointerIP29DestructionAwareMutexInternalNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI29DestructionAwareMutexInternalEE
?26CLSensorFusionService9Axis
N16CLMotionNotifier18CallbackDispatcherIN15CLAccelerometer6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN14CLCompass_Type6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIbEE
#>L7
=17CLRunningVector3dIfE
20CLRunningBufferStatsIfE
ACDFGHJKLMNPQRSTVWXYZ
123456789CDFGHJKLMNPQRTVWXY
14CLPlatformInfo
16CLDaemonSettings
NSt3__120__shared_ptr_pointerIP16CLDaemonSettingsN12_GLOBAL__N_112null_deleterENS_9allocatorIS1_EEEE
N12_GLOBAL__N_112null_deleterE
17CLPersistentStore
25CLGyroBiasEstimatorClient
N13CLPreferences10OtherPrefsE
13CLPreferences
NSt3__120__shared_ptr_pointerIP19CLConnectionMessageNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI19CLConnectionMessageEE
15CLKeyboardState
10CLCompass6
N16CLMotionNotifier26SingleSamplePollDispatcherIN15CLAccelerometer6SampleEEE
N16CLMotionNotifier26SingleSamplePollDispatcherIN14CLDeviceMotion6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEE
10CLPressure
EnableWakeGestureLatencyAlert
WakeGestureLatencyAlertThreshold
EnableWakeGestureHaptic
20CMWakeGestureVisitor
N15CLGestureReport7VisitorE
N16CLMotionNotifier18CallbackDispatcherIN19CLPowerStateService6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN15CLGestureReport6SampleEEE
31CLGyroCalibrationDatabaseRemote
NSt3__120__shared_ptr_emplaceIN30CLGyroCalibrationDatabase_Type16NotificationDataENS_9allocatorIS2_EEEE
N16CLMotionNotifier18CallbackDispatcherIN23CMCallHandednessService6SampleEEE
?15CMPickupService
UUUUUU
@333333
?333333
>333333
18CLSensorFusionMekf
14CLSensorFusion
17CLRunningVector3dIdE
20CLRunningBufferStatsIdE
ADDED
15CLAccelerometer
zt?6CLGyro
14CLMagnetometer
N16CLMotionNotifier18CallbackDispatcherI19CLMotionTypeVector3EE
16CLMotionNotifier
17CLSensorInterface
?N2CL3Log17logfile_streambufE
NSt3__120__shared_ptr_pointerIP10CLSettingsNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI10CLSettingsEE
@20CLPocketStateService
N16CLMotionNotifier18CallbackDispatcherIN21CLOrientationNotifier6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN19CLProximityNotifier6SampleEEE
MbP?
5CLLog
NSt3__120__shared_ptr_pointerIP19CLCircularLogBufferNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI19CLCircularLogBufferEE
10CLSettings
29CLSensorFusionService6AxisSPU
$x<:
.s<d=p<
m<D}i<;
a<\Z]<)
D<6'?<
Tr:~/d:
yQ:'
+}<K+u<g
t[<irR<
6<gI-<
;V-k;
23CLSensorFusion9AxisMekf
23CLCompassDatabaseClient
NSt3__120__shared_ptr_emplaceIN22CLCompassDatabase_Type16NotificationDataENS_9allocatorIS2_EEEE
4@ffffff
T@333333
PAff
31CLAttitudeDependentKFCalibrator
19CLCompassCalibrator
10CLVector3dIjE
10CLMatrix3dIfE
16CLRunningMaximumIfE
@333C
?333333
@X9tB
ff&?
14CLMedianFilterIfE
10CLVector3dIfE
14CLNotifierBase
17CLCompassDatabase
10CLNotifierIN22CLCompassDatabase_Type12NotificationENS0_16NotificationDataEccE
N22CLCompassDatabase_Type6ClientE
N10CLNotifierIN22CLCompassDatabase_Type12NotificationENS0_16NotificationDataEccE6ClientE
20CLNotifierClientBase
kCMActivityAlarmId
kCMActivityAlarmTrigger
kCMActivityAlarmDuration
kCMPressureBiasId
_)K;
*>,<
=jZ:
}A.@
32CLGeomagneticModelProviderClient
NSt3__120__shared_ptr_emplaceIN31CLGeomagneticModelProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
23CLIoHidMonitorInterface
26CLGeomagneticModelProvider
10CLNotifierIN31CLGeomagneticModelProvider_Type12NotificationENS0_16NotificationDataEccE
N31CLGeomagneticModelProvider_Type6ClientE
N10CLNotifierIN31CLGeomagneticModelProvider_Type12NotificationENS0_16NotificationDataEccE6ClientE
N16CLBinaryLogTypes5AccelE
N16CLBinaryLogTypes10BinaryDataE
N16CLBinaryLogTypes10AccelBatchE
N16CLBinaryLogTypes4GyroE
N16CLBinaryLogTypes12GyroOscarEmuE
N16CLBinaryLogTypes15GyroTemperatureE
N16CLBinaryLogTypes11GyroBiasFitE
N16CLBinaryLogTypes6GyroDtE
N16CLBinaryLogTypes12MagnetometerE
N16CLBinaryLogTypes7CompassE
N16CLBinaryLogTypes11GyroCompassE
N16CLBinaryLogTypes18CompassCalibrationE
N16CLBinaryLogTypes8PressureE
N16CLBinaryLogTypes4ProxE
N16CLBinaryLogTypes13TouchOscarEmuE
N16CLBinaryLogTypes12DeviceMotionE
N16CLBinaryLogTypes17MotionStateUpdateE
N16CLBinaryLogTypes8AccelGpsE
N16CLBinaryLogTypes7GyroGpsE
N16CLBinaryLogTypes12BTConnectionE
N16CLBinaryLogTypes15SessionOverrideE
N16CLBinaryLogTypes16LocationOscarEmuE
N16CLBinaryLogTypes20EnhancedDeviceMotionE
N16CLBinaryLogTypes16NonlinearBiasFitE
N16CLBinaryLogTypes11NatalieDataE
N16CLBinaryLogTypes11BodyMetricsE
N16CLBinaryLogTypes12WorkoutEventE
N16CLBinaryLogTypes18OnsetHeartRateDataE
N16CLBinaryLogTypes12StrideCalBinE
N16CLBinaryLogTypes21CalorimetryPauseEventE
N16CLBinaryLogTypes8OdometerE
N16CLBinaryLogTypes8MetsInfoE
N16CLBinaryLogTypes9FallStatsE
N16CLBinaryLogTypes13BasebandSpeedE
N16CLBinaryLogTypes14VibrationEventE
N16CLBinaryLogTypes28StepCadenceToStrideLengthBinE
N16CLBinaryLogTypes24WatchOrientationSettingsE
N16CLBinaryLogTypes21MotionWifiAssociationE
N16CLBinaryLogTypes13MotionLoiDataE
N16CLBinaryLogTypes13AccelOscarEmuE
N16CLBinaryLogTypes12AccelGestureE
N16CLBinaryLogTypes19GyroBiasAndVarianceE
N16CLBinaryLogTypes16CompassAlignmentE
N16CLBinaryLogTypes11PressureGpsE
N16CLBinaryLogTypes16PressureOscarEmuE
N16CLBinaryLogTypes16PressureFilteredE
N16CLBinaryLogTypes15ElevationChangeE
N16CLBinaryLogTypes21CoarseElevationChangeE
N16CLBinaryLogTypes11GestureHintE
N16CLBinaryLogTypes22StreamingHeartRateDataE
N16CLBinaryLogTypes17MotionGPSLocationE
N16CLBinaryLogTypes18MotionWifiLocationE
N16CLBinaryLogTypes20OdometerWithAltitudeE
23CMCallHandednessService
12CLCoverState
18CLCoverStateClient
33CLMagnetometerCoexistenceNotifier
29CLSensorFusionServiceFastPath
9CLCompass
19CLProximityNotifier
39CLMagnetometerCoexistenceNotifierCpasV5
N16CLMotionNotifier18CallbackDispatcherIN15CMPickupService6SampleEEE
39CLMagnetometerCoexistenceNotifierCpasV6
C43CLMagnetometerCoexistenceNotifierCpasCamera
40CLMagnetometerCoexistenceNotifierCpasV10
Q8>\
ZN25CLNonlinearGyroBiasFitter4evalERKN26CMMotionCoprocessorCommand20NonlinearGyroBiasFitEfE8Receiver
24CMTemperatureFitReceiver
14CLDeviceMotion
11CLBinaryLog
16CLBinaryLogTypes
PocketStateMaxMonitorTime
DisablePocketState
N16CLMotionNotifier18CallbackDispatcherIN20CLPocketStateService25CLPocketStateInternalTypeEEE
sA-C
Zw+?
Zwk?
21CLOrientationNotifier
B14CLCompass7Base
21CMDeviceMotionVisitor
N20CMDeviceMotionReport7VisitorE
>fff?
l?gf
/C33s?
)>B`e=
tS>J
Kw>z
40CLMagnetometerCoexistenceNotifierCpasV11
9CLLogBase
25CLGyroCalibrationDatabase
10CLNotifierIN30CLGyroCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE
N30CLGyroCalibrationDatabase_Type6ClientE
N10CLNotifierIN30CLGyroCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE6ClientE
N24CLIoHidFastPathInterface14FastPathDeviceE
19CLPowerStateService
zt?{
zt?{
?21CLSensorFusionService
23CLSensorFusionServiceAP
ADDED
16CLIoHidInterface
N16CLIoHidInterface6DeviceE
NSt3__120__shared_ptr_pointerIPN16CLIoHidInterface6DeviceENS_14default_deleteIS2_EENS_9allocatorIS2_EEEE
NSt3__114default_deleteIN16CLIoHidInterface6DeviceEEE
16CLGestureService
29CLSensorFusionService9AxisSPU
37CLSensorFusionService3AxisDynamicGyro
@(#)PROGRAM:CoreMotion  PROJECT:CoreLocation-2201
N5CMMsl5AccelE
N5CMMsl10AccelBatchE
N5CMMsl12AccelGestureE
N5CMMsl8AccelGpsE
N5CMMsl13AccelOscarEmuE
N5CMMsl12BTConnectionE
N5CMMsl13BasebandSpeedE
N5CMMsl11BodyMetricsE
N5CMMsl21CalorimetryPauseEventE
N5CMMsl21CoarseElevationChangeE
N5CMMsl7CompassE
N5CMMsl16CompassAlignmentE
N5CMMsl18CompassCalibrationE
N5CMMsl18CompassConstraintsE
N5CMMsl17CompassCorrectionE
N5CMMsl17CourseConstraintsE
N5CMMsl16CourseCorrectionE
N5CMMsl12DeviceMotionE
N5CMMsl22DeviceMotionCorrectionE
N5CMMsl15ElevationChangeE
N5CMMsl20EnhancedDeviceMotionE
N5CMMsl9FallStatsE
N5CMMsl11GestureHintE
N5CMMsl18GravityConstraintsE
N5CMMsl17GravityCorrectionE
N5CMMsl4GyroE
N5CMMsl19GyroBiasAndVarianceE
N5CMMsl19GyroBiasConstraintsE
N5CMMsl18GyroBiasCorrectionE
N5CMMsl11GyroBiasFitE
N5CMMsl11GyroCompassE
N5CMMsl6GyroDtE
N5CMMsl7GyroGpsE
N5CMMsl12GyroOscarEmuE
N5CMMsl15GyroTemperatureE
N5CMMsl4ItemE
N5CMMsl16LocationOscarEmuE
N5CMMsl12MagnetometerE
N5CMMsl8MetsInfoE
N5CMMsl17MotionGPSLocationE
N5CMMsl13MotionLoiDataE
N5CMMsl17MotionStateUpdateE
N5CMMsl21MotionWifiAssociationE
N5CMMsl18MotionWifiLocationE
N5CMMsl11NatalieDataE
N5CMMsl16NonlinearBiasFitE
N5CMMsl8OdometerE
N5CMMsl20OdometerWithAltitudeE
N5CMMsl18OnsetHeartRateDataE
N5CMMsl8PressureE
N5CMMsl16PressureFilteredE
N5CMMsl11PressureGpsE
N5CMMsl16PressureOscarEmuE
N5CMMsl4ProxE
N5CMMsl15SessionOverrideE
N5CMMsl28StepCadenceToStrideLengthBinE
N5CMMsl22StreamingHeartRateDataE
N5CMMsl12StrideCalBinE
N5CMMsl13TouchOscarEmuE
N5CMMsl14VibrationEventE
N5CMMsl24WatchOrientationSettingsE
N5CMMsl12WorkoutEventE
v8@?0
DeviceMotionLite
UsesCompass
is not
void CLDeviceMotionLiteService::refreshUsingCompass()
CoreLocation: DeviceMotionLite %s using compass
void CLDeviceMotionLiteService::handleRawSensorV2Msg(uint64_t, CLDeviceMotionLite_Types::RawSensorV2Msg &)
CoreLocation: Jump in message sequence number: last=%d, this=%d
CoreLocation: Updating mag timestamp to %llu
void CLDeviceMotionLiteService::handleFusedSizedStruct(uint64_t, CLDeviceMotionLite_Types::FusedStructWithStatus &)
CoreLocation: FusedWithStatus msgType,%u,infoByte,%u
void CLDeviceMotionLiteService::handleOnStartFragment(uint64_t, CLDeviceMotionLite_Types::FusedStructWithStatus &)
CoreLocation: On-start data from remote seqNo,%u,fLastOnStartDebugSeqNo,%u,bufferSize,%zu
CoreLocation: Jump in on-start sequence numbers last,%u,this,%u
%02hhX
CoreLocation: OnStartMsg: %s
CoreLocation: Discarding %zu bytes from onstart packet
CoreLocation: Accumulated %zu bytes for onstart packet
void CLDeviceMotionLiteService::handleFusedStruct(uint64_t, CLDeviceMotionLite_Types::FusedStructWithStatus &)
CoreLocation: Jump in fused packet sequence number last,%u,this,%u,rtc,%u,byte,%u
CoreLocation: handleFusedStruct(WithStatus) fLastFusedSeqNo,%u,seqNo,%u,rtc,%u,byte,%u
void CLDeviceMotionLiteService::handleSysdiagnoseMsg(uint64_t, CLDeviceMotionLite_Types::SysDiagnoseMsg &)
CoreLocation: Sysdiagnose packet. Write out the data!
void CLDeviceMotionLiteService::handleSessionMetricsMsg(uint64_t, CLDeviceMotionLite_Types::SessionMetricsMsg &)
CoreLocation: Session metrics packet. Push it to the right place
void CLDeviceMotionLiteService::onDeviceMotionLiteEvent(void *, void *, IOHIDEventRef)
CoreLocation: Empty payload, returning
void CLDeviceMotionLiteService::handleDeviceMotionLiteEvent(uint64_t, uint8_t *, size_t)
CoreLocation: DeviceMotionLite,VendorData,size,%{public}ld
CoreLocation: DeviceMotionLite debug fragment, paylaodSize=%lu, fLength=%d, fSequence=%d, fragBufferLen=%lu
CoreLocation: Received invalid payload length %d
CoreLocation: Dropping remaining %lu bytes in fragment buffer
CoreLocation: Not dropping %lu bytes in fragment buffer
CoreLocation: Jump in packet sequence number: last=%d, this=%d
CoreLocation: Skipping, buffer size %lu < packet size %lu
CoreLocation: Zero size struct, or somehow ring buffer size ran out
CoreLocation: called event handler function, remaining bytes: %lu
CoreLocation: Unknown msgType: %d
CoreLocation: msgType=%d, fragBufferLength=%lu
CoreLocation: DeviceMotionLite: unhandled size %{public}ld
Generic
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
com.apple.CoreMotion.CMSedentaryTimer.client
com.apple.CoreMotion.CMSedentaryTimer.daemon
com.apple.locationd.registration
kCLConnectionMessageRegistration
-[CMSedentaryTimer_Internal init]_block_invoke
CoreLocation: SedentaryAlarm,Error response,%{public}d
v24@?0{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}8
kCLConnectionMessageSedentaryTimerIsArmed
-[CMSedentaryTimer_Internal _handleStartStopTimerResponse:withHandler:]_block_invoke
CoreLocation: SedentaryAlarm,Error start / stop response,%{public}d
-[CMSedentaryTimer_Internal _handleStartStopTimerResponse:withHandler:]
CoreLocation: SedentaryAlarm,Error start / stop response.
kCLConnectionMessageSedentaryTimerStart
kCLConnectionMessageSedentaryTimerStop
-[CMSedentaryTimer_Internal _handleAlarmDataResponse:withHandler:]_block_invoke
CoreLocation: SedentaryAlarm,Error query response,%{public}d
-[CMSedentaryTimer_Internal _handleAlarmDataResponse:withHandler:]
CoreLocation: SedentaryAlarm,Error parsing alarm data.
kCLConnectionMessageSedentaryTimerAlarm
kCLConnectionMessageWatchdog
timerArmed
TB,N,GisTimerArmed,V_timerArmed
kCLConnectionMessageSedentaryTimerIsAvailable
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMSedentaryTimer.mm
<Unknown File>
Invalid parameter not satisfying: %@
handler
startTime
queryHandler
kCLConnectionMessageSedentaryTimerQuery
updateHandler
kCLConnectionMessageSubscribeKey
_internal
T@"CMSedentaryTimer_Internal",R,N,V_internal
kCLConnectionMessageMotionActivityAvailable
com.apple.CoreMotion.CMMotionActivityManager
kCLConnectionMessageMotionActivityUpdate
-[CMMotionActivityManager init]_block_invoke
CoreLocation: Error occurred while trying to retrieve motion state update: CMErrorDomain Code:%{public}d
CoreLocation: Unable to parse kCLConnectionMessageMotionActivityUpdate message!
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMMotionActivityManager.mm
start
queue
kCLConnectionMessageMotionActivityQuery
kNatalieDataCodingKeyStartDate
kNatalieDataCodingKeyRecordId
kNatalieDataCodingKeySession
kNatalieDataCodingKeyMets
kNatalieDataCodingKeyNatalies
kNatalieDataCodingKeyBasalNatalies
kNatalieDataCodingKeySourceId
None
Walking
Running
Cycling
OutdoorCycling
IndoorCycling
Yoga
Dancing
CrossTraining
Elliptical
Climbing
StairClimbing
Rowing
ResistanceTraining
GenericWorkout
OutdoorWalking
IndoorWalking
OutdoorRunning
IndoorRunning
Calisthenics
%@, <recordId %lu, startDate %@, session %@, mets %@, natalies %@, basalNatalies %@, sourceId %@>
recordId
Tq,R,N
sourceId
T@"NSUUID",R,N
startDate
T@"NSDate",R,N
mets
T@"NSNumber",R,N
natalies
basalNatalies
session
kCMAccelerationCodingKeyX
kCMAccelerationCodingKeyY
kCMAccelerationCodingKeyZ
x %f y %f z %f @ %f
acceleration
T{?=ddd},R,N
CMErrorDomain
LogFilteredPressure
CLFilteredPressure
virtual void CLFilteredPressure::numberOfSpectatorsChanged(int, size_t)
CoreLocation: [CLFilteredPressure] Unrecognized notification: %d
PressureFiltered
void CLFilteredPressure::onPressureData(const CLPressure::Sample *)
CoreLocation: Type,%s,pressure,%.6f,temperature,%.3f,timestamp,%f
assert
CLPlatformInfo::motionCaps().deviceMotionFastPath
virtual void CLCompass7FastPath::start(bool)
CoreLocation: [CLCompass7FastPath] Initializing fast path
useMag
mode
CoreLocation: [CLCompass7FastPath] Failed fast path set up for CLCompass,serviceRef,%p
client
CoreLocation: [CLCompass7FastPath] Unable to establish fast path with valid clientID,serviceRef,%p
enabled
CoreLocation: [CLCompass7FastPath] Fast path has been initialized,clientID,%u,serviceRef,%p,course,%s
virtual void CLCompass7FastPath::stop()
CoreLocation: [CLCompass7FastPath] Fast path has been closed,clientID,%u
virtual bool CLCompass7FastPath::setDeviceMotionServiceUpdateInterval(const CFTimeInterval &)
CoreLocation: [CLCompass7FastPath] Setting fast path update interval to %f
interval
CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()
virtual std::shared_ptr<CLIoHidInterface::Device> CLIoHidFastPathInterface::buildDevice(CLIoHidInterface::Device::Description)
CoreLocation: [CLIoHidInterface] Adding new FastPathDevice
kCMAltitudeCodingKeyAltitude
kCMAltitudeCodingKeyPressure
Altitude %f Pressure %f @ %f
relativeAltitude
pressure
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMAltitude.mm
sourceId && startDate && endDate && elevationAscended && elevationDescended
kCMSignificantElevationCodingKeyRecordId
kCMSignificantElevationCodingKeySourceId
kCMSignificantElevationCodingKeyStartDate
kCMSignificantElevationCodingKeyEndDate
kCMSignificantElevationCodingKeyElevationAscended
kCMSignificantElevationCodingKeyElevationDescended
%@, <startDate, %@, endDate, %@, elevationAscended, %@ elevationDescended, %@>
supportsSecureCoding
TB,R
TQ,R,N,VfRecordId
T@"NSUUID",R,N,VfSourceId
T@"NSDate",R,N,VfStartDate
endDate
T@"NSDate",R,N,VfEndDate
elevationAscended
T@"NSNumber",R,N,VfElevationAscended
elevationDescended
T@"NSNumber",R,N,VfElevationDescended
CLClientRef CLClientAllocate(CFAllocatorRef, CLClientCallback, const CLClientContext *)
CoreLocation: non-matching retain (%p) and release (%p) functions in context, ignoring
CoreLocation: Failed to initilize fHeadingCalibrationDisplayMutex, error code: %{public}d
com.apple.CoreLocation.%p
UIApplicationWillResignActiveNotification
UIApplicationDidBecomeActiveNotification
CLClientCreateWithBundleIdentifierAndPath
CLClientRef CLClientCreateWithBundleIdentifierAndPath(CFAllocatorRef, CLClientCallback, const CLClientContext *, CFStringRef, CFStringRef)
CoreLocation: CLClient is deprecated. Will be obsolete soon. (%{public}s)
activity
A location manager (%p) was created on a dispatch queue executing on a thread other than the main thread.  It is the developer's responsibility to ensure that there is a run loop running on the thread on which the location manager object is allocated.  In particular, creating location managers in arbitrary dispatch queues (not attached to the main queue) is not supported and will result in callbacks not being received.
CLClientRef _CLClientCreateWithBundleIdentifierAndPath(CFAllocatorRef, CLClientCallback, const CLClientContext *, CFStringRef, CFStringRef)
CoreLocation: Location manager created on a dispatch queue exectuing on non-main thread, notifying client
CoreLocation: #warning Could not register with daemon immediately, will retry later
<CLClient %p [%p]>
CLClient
void CLClientInvokeCallback(CLClientRef, CLClientEvent, id)
CoreLocation: Discarding message for event %{private}d because of too many unprocessed messages
CoreLocation: Location callback block not executed in a timely manner!
void CLClientHandleWillResignActiveNotification(CFNotificationCenterRef, void *, CFStringRef, const void *, CFDictionaryRef)
CoreLocation: received client will resign active notification
void CLClientHandleDidBecomeActiveNotification(CFNotificationCenterRef, void *, CFStringRef, const void *, CFDictionaryRef)_block_invoke
CoreLocation: received client did become active notification
kCLConnectionMessagePurposeKey
kCLConnectionMessagePurpose
This app has attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an %@ key with a string value explaining to the user how the app uses this data
void CLClientRequestAuthorization(CLClientRef, CLClientAuthorizationStatus)
CoreLocation: Missing UsageDescription key for requested authorization: %{public}d
This app has attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain both %@ and %@ keys with string values explaining to the user how the app uses this data
CoreLocation: Invalid requested authorization: %{public}d
kCLConnectionMessageStatusKey
kCLConnectionMessageRequestAuthorization
Boolean CLClientIsLocationServicesEnabled(CLClientRef)
CoreLocation: CLInternalGetLocationServicesEnabled failed: could not reach daemon
mach-lookup
CLClientShutdownDaemon
Boolean CLClientShutdownDaemon(CLClientRef)
CLClientLogDump
Boolean CLClientLogDump(CLClientRef, const char *, Boolean)
kCLConnectionMessageDesiredAccuracyKey
kCLConnectionMessageDistanceFilterKey
kCLConnectionMessageDynamicAccuracyReductionKey
kCLConnectionMessageAlteredAccessoryLocationsKey
kCLConnectionMessageLocation
kCLConnectionMessageEnabledKey
kCLConnectionMessageIsActuallyAWatchKitExtension
kCLConnectionMessageProxyForRemoteClient
kCLConnectionMessageHeadingFilterKey
kCLConnectionMessageHeading
kCLConnectionMessageSignificantLocationChange
kCLConnectionMessageSLCDistanceKey
kCLConnectionMessageSLCPowerBudgetKey
kCLConnectionMessageSignificantLocationVisitTypeKey
kCLConnectionMessageSignificantLocationVisit
kCLConnectionMessageLOIIdentifierKey
kCLConnectionMessageMicroLocation
kCLConnectionMessageRequestMicroLocation
kCLConnectionMessageNameKey
kCLConnectionMessageOnBehalfOfKey
kCLConnectionMessageNotifyOnEntryKey
kCLConnectionMessageNotifyOnExitKey
kCLConnectionMessageConservativeEntry
kCLConnectionMessageRegionTypeKey
kCLConnectionMessageLatitudeKey
kCLConnectionMessageLongitudeKey
kCLConnectionMessageRadiusKey
kCLConnectionMessageReferenceFrameKey
kCLConnectionMessageRegionDefinitionKey
kCLConnectionMessageProximityUUIDKey
kCLConnectionMessageMajorKey
kCLConnectionMessageMinorKey
kCLConnectionMessageNotifyEntryStateOnDisplayKey
kCLConnectionMessageRegionMonitoring
Boolean CLClientRequestRegionState(CLClientRef, CLClientRegion *)
CoreLocation: Fence: CLClientRequestRegionState, unsupported fence type
kCLConnectionMessageRegionState
kCLConnectionMessageBeaconRegionKey
kCLConnectionMessageCircularRegionKey
kCLConnectionMessageRangingPeersKey
kCLConnectionMessageRangingPeerTimeoutKey
kCLConnectionMessageRangingPeerInitiatorKey
kCLConnectionMessagePeerRanging
IsFitnessMatch
CLClientGetLocationUnavailable
Boolean CLClientGetLocationUnavailable(CLClientRef, CLClientLocationUnavailable *)
CoreLocation: function '%{public}s' deprecated - noop
kCLConnectionMessageError
kCLConnectionMessageErrorKey
kCLConnectionMessageEventKey
kCLConnectionMessageLocationKey
kCLConnectionMessageAlternateRegionKey
kCLConnectionMessageIdentifierKey
kCLConnectionMessageRegionsKey
kCLConnectionMessageRanging
kCLConnectionMessageBeaconsKey
kCLConnectionMessageAuthorizationStatus
kCLConnectionMessageMatchInfoEnabled
kCLConnectionMessagePersistentMonitoringEnabled
kCLConnectionMessageAllowsLocationPrompts
kCLConnectionMessageShowLocationPrompt
kCLConnectionMessageMarkAsHavingReceivedLocation
kCLConnectionMessageActivityTypeKey
kCLConnectionMessageActivityType
kCLConnectionMessagePausesLocationUpdatesAutomaticallyKey
kCLConnectionMessagePausesLocationUpdatesAutomatically
Boolean CLClientGetAutopauseState(CFDictionaryRef, Boolean *, Boolean *)
CoreLocation: Invalid call to CLClientGetAutopauseState
kCLConnectionMessageAutopauseStatusKey
kCLConnectionMessageAutopauseOverrideKey
CoreLocation: malformed message: kCLConnectionMessageAutopauseStatus
kCLConnectionMessageAllowsBackgroundLocationUpdatesKey
kCLConnectionMessageAllowsBackgroundLocationUpdates
kCLConnectionMessageBatchAllowedKey
kCLConnectionMessageBatchDistanceKey
kCLConnectionMessageBatchTimeoutKey
kCLConnectionMessageBatch
kCLConnectionMessageAllowsMapCorrectionKey
kCLConnectionMessageAllowsMapCorrection
kCLConnectionMessageRegisterAsLocationClient
kCLConnectionMessageVehicleSpeed
kCLConnectionMessageVehicleSpeedKey
kCLConnectionMessageVehicleHeading
kCLConnectionMessageVehicleHeadingKey
CLClientClearNvramData
Boolean CLClientClearNvramData(CLClientRef, int)
CLClientSetProductionTest
Boolean CLClientSetProductionTest(CLClientRef, int)
CLClientEnableNmeaOutput
Boolean CLClientEnableNmeaOutput(CLClientRef, int)
CLClientGetNmea
Boolean CLClientGetNmea(CLClientRef, CFStringRef *)
CLClientGetSatelliteInfo
Boolean CLClientGetSatelliteInfo(CLClientRef, CLClientSatelliteInfo *)
CLClientGetOneShotLocation
Boolean CLClientGetOneShotLocation(CLClientRef)
CLClientStartLocationUpdatesAll
Boolean CLClientStartLocationUpdatesAll(CLClientRef)
CLClientRetrieveData
Boolean CLClientRetrieveData(CLClientRef, CLClientEvent, Boolean)
kCLClientEventKey
void _CLClientHandleMessage(CLClientRef, std::shared_ptr<CLConnectionMessage>)
CoreLocation: Got unhandled message %s from daemon
kCLConnectionMessageLocationUnavailable
kCLConnectionMessageRegionMonitoringError
kCLConnectionMessageRangingError
kCLConnectionMessageRegionMonitoringResponseDelayed
kCLConnectionMessageRegionMonitoringSetupCompleted
kCLConnectionMessageAutopauseStatus
kCLConnectionMessagePeerRangingRequestProcessed
kCLConnectionMessagePeerRangingError
kCLConnectionMessageHeadingDataKey
kCLConnectionMessageBundleIdentifierKey
kCLConnectionMessageBundlePathKey
kCLConnectionMessageClientSDKKey
CLPlatformInfo::motionCaps().deviceMotionService
ReportInterval
kCMVehicleStateDataCodingKeyTimeRange
kCMVehicleStateDataCodingKeyDeviceId
%@,<startDate %@, endDate %@, deviceId %@>
timeRange
T@"CMMotionTimeRange",R,N
deviceId
T@"NSString",R,N
kCLConnectionMessageVehicleStateIsAvailable
kCLConnectionMessageVehicleStateMostRecentVehicleConnection
kCLConnectionMessageVehicleStateMostRecentInVehicle
+[CMVehicleState vehicularState]
CoreLocation: VEHICULAR: failed notify_register_check, error, %d
CoreLocation: VEHICULAR: failed notify_get_state, error, %d
CoreLocation: VEHICULAR: failed notify_cancel, error, %d
+[CMVehicleState vehicularHints]
CoreLocation: VEHICULAR HINTS: failed notify_register_check, error, %d
CoreLocation: VEHICULAR HINTS: failed notify_get_state, error, %d
CoreLocation: VEHICULAR HINTS: failed notify_cancel, error, %d
com.apple.locationd
com.apple.springboard
LocationServicesEnabledIn8.0
GestureServiceEnabled
DeviceOrientationServiceEnabled
LocationServicesAvailable
ResetLocationWarnings
KnownClients
PrivateMode
com.apple.locationd/kClientConfirmedCount
com.apple.locationd/Prefs
com.apple.ManagedConfiguration.profileListChanged
com.apple.locationd.DumpDiagnostics
com.apple.locationd.notbackedup
com.apple.carrier
com.apple.operator
NSLocationUsageDescription
NSLocationAlwaysUsageDescription
NSLocationWhenInUseUsageDescription
NSLocationAlwaysAndWhenInUseUsageDescription
CFRunLoopRef CLCommonGetRunLoop()
CoreLocation: ***no run loop available***
void CLCommonSetRunLoop(CFRunLoopRef)
CoreLocation: #Warning Changing CLCommon's runloop after it was already established
CoreLocation: #Warning Setting CLCommon's runloop after it was already established
CoreLocation: CLCommonSetRunLoop, %p
mobile
int CLCommonCopyFile(const char *, const char *)
CoreLocation: cannot open source file: %{public}s, errno %{public}d
CoreLocation: cannot open target file: %{public}s, errno %{public}d
CoreLocation: error reading source file: %{public}s
CoreLocation: error writing target file: %{public}s
int CLCommonBzipFile(const char *, const char *)
CoreLocation: cannot open compression stream: %{public}s, bzerror %{public}d
CoreLocation: error writing target file: %{public}s, bzerror: %{public}d
CoreLocation: error closing target file: %{public}s, bzerror: %{public}d
decompress:%@
bool CLCommonGzipDecompressFile(const char *, const char *)
CoreLocation: CLCommonGzipDecompressFile, can't stat, %{public}s
CoreLocation: CLCommonGzipDecompressFile, from, %s, to, %s, size, %llu, cTime, %.1lf, isOK, %d
CoreLocation: CLCommonGzipDecompressFile, can't open, file_path_to, %{public}s, errno %{public}d
CoreLocation: CLCommonGzipDecompressFile, can't open, file_path_from, %{public}s, errno, %{public}d
CoreLocation: CLCommonGzipDecompressFile, error reading source file: %{public}s, errno, %{public}d, read, %{public}d
CoreLocation: CLCommonGzipDecompressFile, can't write, %{public}s, errno, %{public}d, write, %{public}zu
CoreLocation: CLCommonGzipDecompressFile, from, %s, to, %s, isOK, %d, fileSize, %llu, totalReadBytes, %u, totalWrittenBytes, %u, compression, %.4lf
compress:%@
%a, %d %b %Y %T %Z
Date
int CLCommonGetTimeFromHttpHeaderAndRtt(CFDictionaryRef, const CFTimeInterval *, CFAbsoluteTime *)
CoreLocation: http date string is converted to timestamp %.3f and adjusted to %.3f by %.3fs RTT (%.3fs diff from systime)
en_US
%.3f
Jun 10 2017 23:33:07
%b %d %Y %H:%M:%S
%.1f
%03d,%03d,0x%x,0x%x
%03d,%03d,0x%x
GpsNetworkCtrl
bool CLCommonIsGpsNetworkTestMode()
CoreLocation: GPS_NETWORK: enabled %d found %d
void CLCommonSetTimerNowPlusDelay(CFRunLoopTimerRef, CFTimeInterval)
CoreLocation: Timer set loop: %d %f %f %f %f
CFRunLoopTimerRef CLCommonCreateIntervalRunLoopTimer(CFTimeInterval, CFRunLoopTimerContext *, CFRunLoopTimerCallBack)
Boolean CLCommonCompareLocationEqualityClientWithTimeCheck(const CLClientLocation *, const CLClientLocation *, bool)
CoreLocation: CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than their reference frames: (%lf, %lf, %d) (%lf, %lf, %d)
bool CLCommonGetFileTimestamps(const char *, CFAbsoluteTime *, CFAbsoluteTime *, CFAbsoluteTime *, off_t *)
CoreLocation: #Warning CLCommonGetFileTimestamps, failed to stat file, %s, ret, %d
bool CLCommonTouchMTimestamp(const char *)
CoreLocation: CLCommonTouchMTimestamp, utimes failed, ret, %{public}d, file, %{public}s
void CLCommonDeleteFileIfExists(const char *)
CoreLocation: TILE: delete file, %s
CoreLocation: TILE: stat, %s, ret, %d, mtime, %lu, ctime, %lu, size, %lld
CoreLocation: TILE: unlink, %s, ret, %d
bool CLCommonSetFileProtectionClass(const char *, int)
CoreLocation: failed, invalid filename
CoreLocation: failedToOpen, errno, %d
CoreLocation: failed,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d,errno,%d
CoreLocation: done,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d
kCLClientRegistrationResultAllowedAlways
kCLClientRegistrationResultAllowedWhenInUse
kCLClientRegistrationResultFailedUserDenied
kCLClientRegistrationResultFailedBlacklisted
kCLClientRegistrationResultFailedUnavailable
kCLClientRegistrationResultRequiresAgent
kCLClientRegistrationResultMissing
UNKNOWN
kCLClientAuthorizationStatusNotDetermined
kCLClientAuthorizationStatusRestricted
kCLClientAuthorizationStatusDenied
kCLClientAuthorizationStatusAuthorizedAlways
kCLClientAuthorizationStatusAuthorizedWhenInUse
__TEXT
Binary Images:
armv6
armv7
unknown
%16p - %lld %c%s %s <
%02X
> %s
com.apple.CoreMotion.CLDeviceMotionPrivateQueue
kCLConnectionMessageGyroBiasEstimation
virtual void CLGyroBiasEstimatorClientRemote::registerWithGyroBiasEstimatorPrivate(CLGyroBiasEstimatorClientCallback, bool, void *)_block_invoke_3
CoreLocation: Default handler received message %s
kCLConnectionMessageBuildGYTTKey
void CLGyroBiasEstimatorClientRemote::onGyroBiasEstimation(std::shared_ptr<CLConnectionMessage>, CLGyroBiasEstimatorClientCallback, void *)
CoreLocation: Could not get dictionary for message
CoreLocation: Message does not contain a valid gyro bias object
static void CLGyroBiasEstimatorClientRemote::onWatchdogTimerExpiry(CFRunLoopTimerRef, void *)
CoreLocation: unable to create fPrivateQueue
static void CLGyroBiasEstimatorClientRemote::onWatchdogTimerExpiry(CFRunLoopTimerRef, void *)_block_invoke
CoreLocation: Sent kCLConnectionMessageWatchdog message
static bool CLNameValuePair::encodeBase64(const void *, unsigned long, std::string &)
CoreLocation: processed %p %d to (%s)
CLNameValuePair::CLNameValuePair()
CoreLocation: could not create new mutable dictionary
CLNameValuePair::CLNameValuePair(CFDictionaryRef)
CLNameValuePair::CLNameValuePair(const CLNameValuePair &)
CLNameValuePair &CLNameValuePair::operator=(const CLNameValuePair &)
virtual bool CLNameValuePair::loadFromFile(const char *)
CoreLocation: could not deserialize property list from %{public}s
CoreLocation: file %s does not exist... clearing, error, %s
CoreLocation: #Warning Error reading file %{public}s: %{public}s
bool CLNameValuePair::writeDataToFile(const char *, CFDataRef, CLNVPDataProtection) const
CoreLocation: Could not create NSURL for file: %{public}s
CoreLocation: Could not write data to disk %{public}s
virtual bool CLNameValuePair::saveToFile(const char *) const
CoreLocation: Could not serialize data for file %{public}s
virtual bool CLNameValuePair::saveToBinaryFile(const char *, CLNVPDataProtection) const
virtual void CLNameValuePair::clearInternal(const CFStringRef, int)
CoreLocation: key %{public}s does not have element %{public}d in array of size %{public}ld
CoreLocation: key %{public}s does not have element %{public}d in non-array type %{public}lu
virtual bool CLNameValuePair::get(CFStringRef, CFArrayRef &) const
CoreLocation: type IDs do not match for key %{public}s - %{public}lu vs %{public}lu
virtual bool CLNameValuePair::get(CFStringRef, CFDataRef &, int) const
virtual bool CLNameValuePair::get(CFStringRef, CFStringRef &, int) const
virtual bool CLNameValuePair::copyInternal(CFStringRef, CFTypeRef &, int) const
CoreLocation: specified index is out of range for key %{public}s (%{public}d of %{public}ld)
CoreLocation: specified index %{public}d not applicable to type %{public}lu for key %{public}s
virtual bool CLNameValuePair::set(CFStringRef, const bool &)
CoreLocation: could not create cf type for key %{public}s
virtual bool CLNameValuePair::set(CFStringRef, const uint16_t &)
virtual bool CLNameValuePair::set(CFStringRef, const short &)
virtual bool CLNameValuePair::set(CFStringRef, const uint32_t &)
virtual bool CLNameValuePair::set(CFStringRef, const int64_t &)
virtual bool CLNameValuePair::set(CFStringRef, const int &)
virtual bool CLNameValuePair::set(CFStringRef, const long &)
virtual bool CLNameValuePair::set(CFStringRef, const double &)
virtual bool CLNameValuePair::set(CFStringRef, const char *)
virtual bool CLNameValuePair::set(CFStringRef, const CLNameValuePair &)
virtual bool CLNameValuePair::insert(CFStringRef, const bool &)
virtual bool CLNameValuePair::insert(CFStringRef, const uint16_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const short &)
virtual bool CLNameValuePair::insert(CFStringRef, const uint32_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const int64_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const int &)
virtual bool CLNameValuePair::insert(CFStringRef, const long &)
virtual bool CLNameValuePair::insert(CFStringRef, const double &)
virtual bool CLNameValuePair::insert(CFStringRef, const char *)
virtual bool CLNameValuePair::insert(CFStringRef, const CLNameValuePair &)
virtual bool CLNameValuePair::serializeBinary(CFDataRef *) const
CoreLocation: could not create write stream
CoreLocation: could not open write stream
CoreLocation: could not write data, error code, %{public}ld, error domain, %{public}s
unknown error
virtual bool CLNameValuePair::deserialize(const CFDataRef)
CoreLocation: could not create intermediate property list - %{public}ld (%{public}s)
virtual void CLNameValuePair::print() const
CoreLocation: %s
<empty>
void CLNameValuePair::printCSV(const char *)
CoreLocation: dictionary, %s, NULL
static void CLNameValuePair::printKeyValue(const void *, const void *, void *)
CoreLocation: 
%s = <dictionary (%ld entries)>:
CoreLocation: 
%s = %s
CoreLocation: 
%s = %0.6f
CoreLocation: 
%s = %d
CoreLocation: 
%s = <unhandled value type %lu>
type ID does not match - %lu vs %lu
%s = <dictionary (%ld entries)>:
%s = %s
%s = %0.6f
%s = %d
%s = <unhandled value type %lu>
%s[%d]
static bool CLNameValuePair::fromCfType(const CFTypeRef, short &)
CoreLocation: could not get value
static bool CLNameValuePair::fromCfType(const CFTypeRef, int64_t &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, int &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, long &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, double &)
CoreLocation: type IDs do not match - %{public}lu vs %{public}lu
static bool CLNameValuePair::fromCfType(const CFTypeRef, std::string &)
CoreLocation: could not convert to C string
CoreLocation: can't convert %{public}u data bytes
CoreLocation: type IDs do not match - %{public}lu
static bool CLNameValuePair::fromCfType(const CFTypeRef, const char *&, unsigned int &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, CLNameValuePair &)
%s.%ld
void _printCSV_logKeyValue(const void *, const void *, void *)
CoreLocation: dictionary, %s, key, %s, value, %s
CoreLocation: dictionary, %s, key, %s, value, %.8lf
CoreLocation: dictionary, %s, key, %s, value, %d, 0x%08x
CoreLocation: dictionary, %s, key, %s, value, %d, [CFBoolean]
CoreLocation: dictionary, %s, key, %s, value, %.2lf, [CFDate]
CoreLocation: dictionary, %s, key, %s, un-printable value
error == 0
<unnamed>
virtual void BasicMutex::lock()
CoreLocation: #Warning TIMEOUT: Waited %f seconds to aquire lock '%s' (%p)
info->fCount >= 0
(info->fCount == 0) || (info->fOwner == curThread)
(info->fCount > 0) || (info->fOwner == __null)
virtual void BasicMutex::unlock()
CoreLocation: #Warning TIMEOUT: Held lock '%s' (%p) for %f seconds
info->fCount > 0
!_guts->valid
info->fCount == 0
CLSensorFusionService9Axis::CLSensorFusionService9Axis(bool, int, bool)
CoreLocation: 9-axis sensor fusion is not supported on this platform.  Returning.
virtual void CLSensorFusionService9Axis::useNorthRef(bool)
CoreLocation: North reference overridden as %d by first client
GyroBias
void CLSensorFusionService9Axis::onBiasAndVariance(const CLMotionTypeGyroBiasAndVariance)_block_invoke
CoreLocation: Type,%s,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
void CLSensorFusionService9Axis::onCompass(const CLCompass_Type::Sample *)
CoreLocation: correctedCompassExt, %.3f, %.3f, %.3f, %u, %u
UIApplication
com.apple.locationd.Motion
Calorimetry
Swimming
Activity
ActivityAlarm
Pedometer
Motion
Pocket
Orientation
Gesture
EarGesture
WakeGesture
DeviceMotion
Sensors
Compass
Gyro
Accel
Pressure
Fall
Spring
SensorRecorder
MotionSync
MotionAlarm
Odometer
HeartRate
com.apple.locationd.Position
Position
Proximity
GeneralCLX
WifiPosition
GeoFencing
Gnss
Emergency
Raven
MapMatcher
Microlocation
NMEA
com.apple.locationd.Core
Client
Core
Routine
Harvester
Notifier
com.apple.locationd.Utility
Database
Network
Utility
com.apple.locationd.Legacy
Direct
Location
Sensor
Fence
gas-gauge-battery
IsSimulator
%@ %@ (%@)
<null>
<name>
<version>
<build>
hw.model
hw.machine
Apple 
 CoreLocation-
IOPlatformExpertDevice
IOPlatformSerialNumber
NotAvailable
CLPlatformInfo::Provider CLPlatformInfo::getProviders()_block_invoke
CoreLocation: unknown hardware type %{private}d
UseNewGnssArchitecture
watch-companion
GpsEnableLPPM
__OSINSTALL_ENVIRONMENT
GpsEnableGnssRfConfig
bool CLPlatformInfo::getDateFromSerialNumber(const std::string &, CFAbsoluteTime &)
CoreLocation: device SN date info type:%{private}zd - date:%{private}d %{private}d %{private}f
CoreLocation: Invalid year/week code
CoreLocation: Failed to allocate CFCalendar
CoreLocation: CFCalendarComposeAbsoluteTime() failed
CoreLocation: Cannot get weekday
CoreLocation: Cannot get week
CoreLocation: Invalid serial number format: %{private}s
bool CLPlatformInfo::supportsCampOnly()
CoreLocation: CAMP: device id [%d] [%s], camping support [%d]
ReleaseType
NonUI
InternalBuild
GpsForceSuplSupportIgnoringHw
bool CLPlatformInfo::supportsSupl()
CoreLocation: #Warning SUPL: ignoring hw. forceSuplSupport,%d
GpsForceLppSupport
bool CLPlatformInfo::supportsLpp()
CoreLocation: #Warning LPP: ignoring hw. forceLppSupport,%d
BeaconFenceBestEffortAlways
bool CLPlatformInfo::supportsBeaconBestEffortAlwaysEnabled()
CoreLocation: #Warning Overriding BeaconFenceBestEffortAlways,%d
CoreLocation: zoneBestEffortAlwaysEnabled,%d
GnssPeakAntennaGain
CLPlatformInfo::GnssRfConfig CLPlatformInfo::getGnssRfConfig()
CoreLocation: #Warning GNSSRF: overriding peak antenna gain, %d tenth-dB
CoreLocation: GNSSRF: no config for %d
CoreLocation: GNSSRF: peakAntennaGain,%d,gpsLoss,%d,gloLoss_0,%d,gloLoss_minus7,%d,gloLoss_plus6,%d
GpsForcePlosSupport
bool CLPlatformInfo::supportsPLOS()
CoreLocation: #Warning PLOS: ignoring hw. forceSupport,%d
GpsForceSupportOutdoorMatching
bool CLPlatformInfo::supportsOutdoorMatching()
CoreLocation: #Warning OBM, ignoring hw. forceSupport,%d
wlan
IOService
wifi-antenna-sku-info
static bool CLPlatformInfo::isDeviceJapanSKU()
CoreLocation: data for wifi-antenna-sku-info found
CoreLocation: Device SKU:%s
CoreLocation: wifi-antenna-ski-info property not found.
CoreLocation: service for class wlan NOT found.
CoreLocation: class wlan NOT found.
locationd
com.apple.demo-settings
StoreDemoMode
FProgramNumber
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMWorkout.mm
sessionId
type < kCMWorkoutTypeMax
kCMWorkoutDataCodingKeySessionId
kCMWorkoutDataCodingKeyType
OutdoorWheelchairWalk
OutdoorWheelchairRun
Unhandled workout type
%@, <sessionId %@, type, %@>
type >= kCMWorkoutTypeNone && type <= kCMWorkoutTypeMax
session >= kCMNatalieDataSessionNone && session <= kCMNatalieDataSessionMax
type
location < kCMSwimWorkoutLocationMax
-[CMSwimWorkout initWithSessionId:location:poolLength:]
CoreLocation: Workout, pool length %f for workout is too small and may lead to undefined behavior.
kCMWorkoutDataCodingKeySwimLocation
kCMWorkoutDataCodingKeyPoolLength
Pool
OpenWater
%@, <sessionId %@, type, kCMWorkoutTypeSwimming, location, %@, poolLength, %f>
location
poolLength
Td,R,N
workoutType == kCMWorkoutTypeIndoorRunning || workoutType == kCMWorkoutTypeIndoorWalking || workoutType == kCMWorkoutTypeIndoorCycling || workoutType == kCMWorkoutTypeElliptical || workoutType == kCMWorkoutTypeStairClimbing || workoutType == kCMWorkoutTypeRowing
kCMWorkoutDataCodingKeyFitnessMachineManufacturerName
kCMFitnessMachineWorkoutDataCodingKeyModel
%@, <sessionId %@, type, %@, manufacturerName, %@, model, %@>
manufacturerName
model
/private/var/Managed Preferences/
/Library/Caches/locationd/
static std::string CLPersistentStore::getMutableStorePath(CLPersistentStoreType)
CoreLocation: could not get mutable store path for type, %{public}d
/System/Library/Frameworks/CoreLocation.framework/Support/
/System/Library/Frameworks/CoreLocation.framework
/Library/locationd/
CLPersistentStore::CLPersistentStore(id<CLIntersiloUniverse>, const char *, CLPersistentStore::Domain, CLPersistentStoreType, CLPersistentStoreDataProtection)
CoreLocation: Unknown persistent domain: %{public}d
CoreLocation: could not create path %{public}s
.plist
virtual bool CLPersistentStore::refresh()
CoreLocation: #Warning persistent store %s has been modified - refreshing will lose changes
virtual bool CLPersistentStore::store()
CoreLocation: #Warning data set %s is not changeable - not storing
CoreLocation: %s stored to disk %s
callback != __null
virtual void CLPersistentStore::setStoreInterval(const CFTimeInterval &, CFRunLoopTimerCallBack, void *)
CoreLocation: scheduling to auto-store %s every %.3fs
CoreLocation: disabling auto-store for %s
kCMDeviceMotionCodingKeyQuaternionX
kCMDeviceMotionCodingKeyQuaternionY
kCMDeviceMotionCodingKeyQuaternionZ
kCMDeviceMotionCodingKeyQuaternionW
kCMDeviceMotionCodingKeyUserAccelerationX
kCMDeviceMotionCodingKeyUserAccelerationY
kCMDeviceMotionCodingKeyUserAccelerationZ
kCMDeviceMotionCodingKeyRotationRateX
kCMDeviceMotionCodingKeyRotationRateY
kCMDeviceMotionCodingKeyRotationRateZ
kCMDeviceMotionCodingKeyMagneticFieldX
kCMDeviceMotionCodingKeyMagneticFieldY
kCMDeviceMotionCodingKeyMagneticFieldZ
kCMDeviceMotionCodingKeyMagneticFieldCalibrationLevel
kCMDeviceMotionCodingKeyDoingYawCorrection
kCMDeviceMotionCodingKeyDoingBiasEstimation
kCMDeviceMotionCodingKeyHeading
QuaternionX %f QuaternionY %f QuaternionZ %f QuaternionW %f UserAccelX %f UserAccelY %f UserAccelZ %f RotationRateX %f RotationRateY %f RotationRateZ %f MagneticFieldX %f MagneticFieldY %f MagneticFieldZ %f MagneticFieldAccuracy %d Heading %f @ %f
doingYawCorrection
TB,R,N
doingBiasEstimation
magneticFieldCalibrationLevel
Ti,R,N
attitude
T@"CMAttitude",R,N
rotationRate
gravity
userAcceleration
magneticField
T{?={?=ddd}i},R,N
heading
kCMAttitudeCodingKeyQX
kCMAttitudeCodingKeyQY
kCMAttitudeCodingKeyQZ
kCMAttitudeCodingKeyQW
%@ Pitch: %f, Roll: %f, Yaw: %f
roll
pitch
rotationMatrix
T{?=ddddddddd},R,N
quaternion
T{?=dddd},R,N
kCMAmbientPressureCodingKeyPressure
kCMAmbientPressureCodingKeyTemperature
Pressure %f Temeprature %f @ %f
ambientPressure
T{?=dd},R,N
virtual bool CLPreferences::serialize(CFDataRef *) const
CoreLocation: ***not supported***
virtual bool CLPreferences::serializeBinary(CFDataRef *) const
virtual bool CLPreferences::deserialize(const CFDataRef)
virtual void CLPreferences::print() const
CoreLocation: 
<empty>
virtual void CLPreferences::merge(const CLPreferences &, bool)
virtual bool CLPreferences::loadFromFile(const char *)
virtual bool CLPreferences::saveToFile(const char *) const
virtual bool CLPreferences::saveToBinaryFile(const char *) const
virtual void CLPreferences::setInternal(const CFStringRef, const CFTypeRef)
CoreLocation: Attempt to set key %{public}s for read-only preferences %{public}s/%{public}s!
%llu, %f, %f, (%f, %f, %f)
identifier
TQ,R,V_identifier
T@"NSDate",R
%llu, %f, %f, (%f, %f, %f), %f
temperature
Tf,R
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMSensorRecorder.mm
Unexpected ptr exceeding size of buffer, block id, %llu, block offset %llu, size, %zu
Unexpected sensor type!
Data object returned should be valid
Data pointer returned should be valid
com.apple.CoreMotion.CMSensorRecorderInternal
kCLConnectionMessageSensorRecorderGetMetaByID
kCLConnectionMessageSensorRecorderGetMetaSinceID
-[CMSensorRecorderInternal _newMetaUsingMessage:withIdentifier:forType:]_block_invoke
CoreLocation: Error occurred while trying to retrieve accelerometer record!
kCLConnectionMessageSensorRecorderGetMetasByDateRange
-[CMSensorRecorderInternal newMetaFrom:to:forType:]_block_invoke
CoreLocation: Error occurred while trying to retrieve accelerometer records!
kCLConnectionMessageSensorRecorderWriteSensorDataToFileByDateRange
-[CMSensorRecorderInternal writeSensorDataToFile:from:to:forType:]_block_invoke
CoreLocation: Successfully wrote accelerometer data to file.
CoreLocation: Error occurred while trying to write accelerometer data to file!
kCLConnectionMessageSensorRecorderSetSensorSampleRate
-[CMSensorRecorderInternal setSensorSampleRate:forType:]_block_invoke
CoreLocation: Successfully set sensor sample rate.
CoreLocation: Error occurred while trying to set sensor sample rate!
kCLConnectionMessageSensorRecorderGetDataByID
-[CMSensorRecorderInternal newDataByID:metaID:forType:]_block_invoke
CoreLocation: Error occurred while trying to retrieve accelerometer data!
kCLConnectionMessageSensorRecorderSensorAvailable
+[CMSensorRecorder isRecordingAvailableForType:]
CoreLocation: Response invalid.
kCLConnectionMessageSensorRecorderAuthorized
+[CMSensorRecorder isAuthorizedForRecording]
*startTime
endTime
startTime must be <= to endTime
startTime must be within 3 days of today.
-[CMSensorRecorder sensorDataFromDate:toDate:forType:]
CoreLocation: #Notice -[%{public}s %{public}s] fromDate has been adjusted so that the duration requested is <= 12 hours.
-[CMSensorRecorder sendSensorDataToUrl:fromDate:toDate:forType:]
CoreLocation: #Notice Unable to get file handle for URL %{public}@
duration > 0.0
kCLConnectionMessageSensorRecorderRecordFor
-[CMSensorRecorder recordDataType:forDuration:]
rate <= 100
timestamp
accel_x
accel_y
accel_z
rotation_x
rotation_y
rotation_z
CLKeyboardState
void CLKeyboardState::registerForKeyboardUpdates()
CoreLocation: registering for keyboard updates
IOServiceFirstMatch
AppleHIDKeyboardEventDriverV2
IOServiceTerminate
void CLKeyboardState::registerForKeyboardUpdates()_block_invoke
CoreLocation: #Warning Failed to register for keyboard updates. Could not register for AppleHIDKeyboardEventDriverV2 service kIOFirstMatchNotification and kIOTerminatedNotification.
CoreLocation: #Warning Failed to register for keyboard updates. Could not create KeyboardConnectNotificationPort and KeyboardConnectNotificationPort
void CLKeyboardState::unregisterForKeyboardUpdates()
CoreLocation: unregistering for keyboard updates
DumpCompassCalibrationDatabaseOnCompassStart
CompassInterval
CompassIgnoreGyro
CLCompass6::CLCompass6()
CoreLocation: Legacy compass, interval (%.3f) gyro (%d)
virtual void CLCompass6::start(bool)
CoreLocation: Legacy compass started. Cover attached %d
%.0f
CLCompassDatabase
virtual void CLCompass6::start(bool)_block_invoke
CoreLocation: Dumped compass cal database with id %@
v16@?0@"NSString"8
CoreLocation: Compass is requesting device motion with mode 0x%x
virtual void CLCompass6::stop()
CoreLocation: Legacy compass stopped.
static void CLCompass6::onMagnetometerData(const CLMagnetometer::Sample *, void *)
CoreLocation: Notify after %.3f seconds of no event.
CompassAlignment
CoreLocation: Type,%s,compassJustAlignedToStableField,%d,timestamp,%20.20f
CoreLocation: Type,%s,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
CoreLocation: notified clients. sampleCount,%d,compass.compass.calibrationLevel,%d,compass.timestamp,%f
kCMLogItemCodingKeyTimestamp
com.apple.locationd.spi
com.apple.locationd.synchronous
Boolean CLGetControlPlaneStatusReport(int, CFAbsoluteTime *, CFAbsoluteTime *, double *, double *, double *, double *, unsigned int *)
CoreLocation: Blocking Mig routine deferred on Daemon side... waiting and retrying
CFArrayRef CLCopyTechnologiesInUse()
CoreLocation: List of technologies in use is not an array -- type ID %{public}lu
void CLInternalSetLocationServicesEnabled(Boolean)
CoreLocation: CLInternalSetLocationServicesEnabled failed
void CLInternalSetGestureServiceEnabled(Boolean)
CoreLocation: CLInternalSetGestureServiceEnabled failed
Boolean CLInternalGetAuthorizationStatus(CFStringRef, CFStringRef, CLClientAuthorizationStatus *)
CoreLocation: Couldn't send bundle identifier!
CoreLocation: Couldn't send bundle path!
Boolean CLInternalGetAuthorizationStatusForService(CFStringRef, CFStringRef, CLClientServiceTypeMask, CLClientAuthorizationStatus *)
Boolean CLInternalPerformMigration()
CoreLocation: _CLIntegrityCheck failed with result: %{public}d
Boolean CLShutdownDaemon()
CoreLocation: _CLShutdownDaemon failed with result: %{public}d
Boolean CLDisplayStatistics()
CoreLocation: _CLDisplayStatistics failed with result: %{public}d
Boolean CLDumpLogs(CFStringRef)
CoreLocation: _CLDumpLogs failed with result: %{public}d
Boolean CLCopyLastLog()
CoreLocation: _CLCopyLastLog failed with result: %{public}d
CFDictionaryRef CLCopyMonitoredRegions(CFStringRef, CFStringRef)
CoreLocation: Returned type is not a dictionary
void CLSetLocationDefault(CFStringRef, CFPropertyListRef)
CoreLocation: Key is NULL!
CoreLocation: Couldn't set location default!
Boolean CLGetLocation(CFStringRef, CFStringRef, Boolean, Boolean, CLClientLocation *)
NSTimeZone *CLTimeZoneAtLocation(CLLocation *)
<Unknown Function>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/MiG/LocationInternal.m
nil != location
LogPressure
CLPressure
v16@?0r^(NotificationData=i{?=i{NonlinearPressureBiasFit=C[101S]ff}}{?=i{PressureBiasFit=C[3C]ff}})8
void CLPressure::onBias(int, const CLPressureBias_Type::Notification &, const CLPressureBias_Type::Bias &)
CoreLocation: Unexpected pressure bias notification.notification,%d
virtual CFTimeInterval CLPressure::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting pressure data update interval to %f
CoreLocation: Unrecognized pressure notification %d
void CLPressure::onPressureData(const CLMotionTypePressure &, const CLMotionTypeTimestamp &)
CoreLocation: Pressure Temperature=%d
CMSendWakeGestureNotification
CMSendWakeGestureState
-[CMWakeGesturePhone init]
CoreLocation: Could not create instance of CLGestureService. Is wake gesture supported on this platform?
com.apple.CoreMotion.CMWakeGesturePhonePrivateQueue
SpringBoard
CoreLocation: Process: %{public}@, IsPrimary: %{public}d
IOPropertyMatch
backlight-control
IOGeneralInterest
CoreLocation: Failed to register for backlight service notification
com.apple.backboardd.backlight.changed
-[CMWakeGesturePhone init]_block_invoke
CoreLocation: Backlight level notification (%{public}llu)
CoreLocation: Unable to send display state
v12@?0i8
-[CMWakeGesturePhone startWakeGestureUpdates]
CoreLocation: Start Wake Gesture Updates
com.apple.CoreMotion.WakeGesturePreferencesChanged
-[CMWakeGesturePhone stopWakeGestureUpdates]
CoreLocation: Stop Wake Gesture Updates
-[CMWakeGesturePhone simulateGestureWithDelay:Duration:]_block_invoke
CoreLocation: Simulating gesture: delay,%f,duration,%f,success,%d
-[CMWakeGesturePhone invokeDelegateWithState:]_block_invoke
CoreLocation: Unable to invoke delegate. Please call startWakeGestureUpdates first.
-[CMWakeGesturePhone loadPreferences]
CoreLocation: Loaded Preferences. Latency Alert: %d, Latency Threshold: %d, Audio Alert: %d
Unknown
Detected
Dismissed
Rejected
PreDetection
Switched To Running
Switched To Normal
Suppressed
Unexpected
Normal
FaceUpStatic
FaceUpMoving
OtherStatic
OtherMoving
Landscape
VerticalOther
Portrait
PortraitUpsideDown
FaceDownStatic
FaceDownMoving
Invalid
Nominal
Level
FaceUpSlanted
FaceUpPortrait
PortraitSlanted
FaceDown
Peek
-[CMWakeGesturePhone onNotificationControl:]
CoreLocation: Gesture state %{public}zd is invalid!
CoreLocation: Gesture state updated to %{public}d
CoreLocation: Invalid CMSendWakeGestureNotification payload!
-[CMWakeGesturePhone onWakeUpdated:]_block_invoke
CoreLocation: Gesture notification: %{public}d(%{public}@), Mode:%{public}@, Start:%{public}@, End:%{public}@, HostAwake, %{public}d
CoreLocation: Gesture state notified,%{public}@,currentTime,%{public}f
CoreLocation: No valid delegate found.
com.apple.CoreMotion.CMOdometer.internal
com.apple.CoreMotion.CMOdometer.callback
-[CMOdometerProxy _startDaemonConnection]_block_invoke
CoreLocation: Failed with CMError code %{public}d
kCLConnectionMessageOdometerGpsAvailability
CoreLocation: CMOdometer client connection interrupt, %@, %d, %p
kCLConnectionMessageStartOdometerUpdate
-[CMOdometerProxy _startOdometerUpdatesWithHandler:]_block_invoke
CoreLocation: Unable to parse kCLConnectionMessageOdometerUpdate message!
odometer
T@"CMOdometer",N,V_odometer
totalDistance
Td,V_totalDistance
averageSpeed
Td,V_averageSpeed
Td,V_startDate
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMOdometer.mm
-[CMOdometer startOdometerUpdatesForActivity:withHandler:]
CoreLocation: #Warning The requested activity %ld is not yet supported
CoreLocation: #Warning Unsupported activity requested
odometerProxy
T@"CMOdometerProxy",R,N,V_odometerProxy
delegate
T@"<CMOdometerDelegate>",N,V_delegate
kExerciseMinuteDataCodingKeyStartDate
kExerciseMinuteDataCodingKeyRecordId
kExerciseMinuteDataCodingKeySourceId
%@, <recordId %lu, startDate %@, sourceId %@>
kCMRotationRateCodingKeyX
kCMRotationRateCodingKeyY
kCMRotationRateCodingKeyZ
%+08.4lf%+09.4lf/
%+08.4lf%+09.4lf%+08.3lf/
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %{public}s; client %{public}d does not exist
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
(fMutex).__assertOwned()
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %{public}s; notification %{public}s not found
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %s; client %d has deregistered, not notifying %s
void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLNotifierData *) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %{public}s; unknown client %{public}d
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %s; already shutdown; not listing clients
CoreLocation: %s; listing clients, num clients: %zu
CoreLocation: %s; clients, id: %d, notification: %d
virtual bool CLGyroCalibrationDatabaseRemote::getBiasFit(CLMotionTypeGyroBiasFit &)
CoreLocation: successfully got GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
CoreLocation: Warning: can't get GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
kCMCatherineDataCodingKeyCatherine
kCMCatherineDataCodingKeyConfidence
%@,<catherine %f confidence %f @ %f>
catherine
Td,R,N,V_catherine
confidence
Td,R,N,V_confidence
com.apple.CoreMotion.CMSpringTracker
-[CMSpringTrackerInternal init]_block_invoke
CoreLocation: Failed with error, %{public}d
-[CMSpringTrackerInternal init]_block_invoke_2
CoreLocation: Client connection interrupt, %@, %d, %p
kCLConnectionMessageSpringTrackerIsTracking
kCLConnectionMessageSpringTrackerStart
kCLConnectionMessageSpringTrackerStop
-[CMSpringTrackerInternal _handleStartStopResponse:handler:]
CoreLocation: Error responding to start / stop tracking request, handler unavailable.
CoreLocation: Error parsing start / stop response.
00000000-0000-0000-0000-000000000000
kCLConnectionMessageSpringTrackerQuery
-[CMSpringTrackerInternal _querySpringDataFromRecord:handler:]_block_invoke
CoreLocation: Error parsing query response.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMSleepTracker.mm
T@"CMSpringTrackerInternal",R,N,V_internal
compass
compass-calibration
CFDataRef CLMagnetometerCoexistenceLocal::copyCompassCalibrationData()
CoreLocation: Invalid cpas data.
CoreLocation: The cpas data is not a CFData type.
BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()
CoreLocation: #Warning Cpas data is NULL.
CoreLocation: #Warning Cpas pointer is NULL.
CoreLocation: Unexpected cpas version: %u.
CoreLocation: Original serial number data is NULL.
CoreLocation: Original serial number pointer is NULL.
AppleH4CamIn
BackCameraSerialNumber
CoreLocation: Invalid back camera serial number data.
CoreLocation: Incorrect back camera serial number length. Actual length %ld. Expected length %lu.
CoreLocation: Current serial number data is NULL.
BackCameraModuleFocusActuatorID
NSNumber *CLMagnetometerCoexistenceLocal::cameraVcmId()
CoreLocation: Bailing while checking VCM actuator ID.
CoreLocation: VCM actuator ID data type %d does not match expected type %d
NSData *CLMagnetometerCoexistenceLocal::sanitizedCompassCalibrationData()
CoreLocation: #Warning CPAS data is NULL.
CoreLocation: #Warning CPAS pointer is NULL.
kCMMotionTimeRangeCodingKeyStartDate
kCMMotionTimeRangeCodingKeyEndDate
%@,<startDate %@, endDate %@>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMCallHandednessManager.mm
CMCallHandednessManager is not supported on this platform. Use isCallHandednessAvailable to avoid this error
com.apple.CoreMotion.CMCallHandednessPrivateQueue
-[CMCallHandednessManager startCallHandednessUpdates]_block_invoke
CoreLocation: Started CallHandedness updates. Current Time: %f
CoreLocation: CallHandedness service already started!
-[CMCallHandednessManager stopCallHandednessUpdates]_block_invoke
CoreLocation: Stopped CallHandedness updates. Current Time: %f
CoreLocation: CallHandedness service already stopped!
-[CMCallHandednessManager onCallHandednessStateUpdated:]_block_invoke
CoreLocation: CallHandedness Detection: %ld
T@"<CMCallHandednessDelegate>",N,V_delegate
CMPickupService
virtual void CMPickupService::numberOfSpectatorsChanged(int, size_t)
CoreLocation: CMPickupService Spectators, %zd
CoreLocation: CMPickupService stopped, %zd
CoreLocation: CMPickupService started, %zd
CoreLocation: CMPickupService expects only 1 client
void CMPickupService::startDetection()
CoreLocation: #Warning No accelerometer; not starting CMPickupDetector detection!
CoreLocation: Starting PickupDetector detection with accelFrequency %.1f
static void CMPickupService::onAccelerometerData(const CLAccelerometer::Sample *, void *)
CoreLocation: Sending CMPickupDetector notification.
%@%s%s
_internal_Calypso-Trimmed.wav
kCalorieUserInfoCodingKeyAge
kCalorieUserInfoCodingKeyGender
kCalorieUserInfoCodingKeyHeight
kCalorieUserInfoCodingKeyWeight
kCalorieUserInfoCodingKeyCondition
Male
Female
%@, <age %f, gender %@, height %f, weight %f, condition %ld>
gender
height
weight
condition
com.apple.locationd.vehicle.connected
com.apple.locationd.vehicle.disconnected
com.apple.locationd.vehicle.exit
com.apple.locationd.vehicular.state
com.apple.locationd.vehicular.hints
com.apple.locationd.vehicular.changed
CLPressureSampleDatabase::~CLPressureSampleDatabase()
CoreLocation: Closing PressureSample
CLPressureSampleDatabase::CLPressureSampleDatabase(const std::string &, const std::string &, const std::string &)
CoreLocation: Can't open %s: %s
SELECT COUNT(*) FROM PressureSample
CoreLocation: Found PressureSample table already in %s
INSERT INTO PressureSample VALUES (?,?,?,?,?,?)
CoreLocation: Can't create insert statment in %s: %s
CoreLocation: No PressureSample table in %s
CREATE TABLE PressureSample (CFTime FLOAT, Timestamp FLOAT, Run TEXT, Tag TEXT, degC FLOAT, kPa FLOAT)
CoreLocation: Can't create table in %s: %s
CREATE INDEX TheIdx ON PressureSample (Run, Tag, CFTime)
CoreLocation: Can't create index in %s: %s
bool CLPressureSampleDatabase::insert(const CLPressure::Sample &)
CoreLocation: Table PressureSample invalid
CoreLocation: Table PressureSample INSERT bind error %d %s
CoreLocation: Table PressureSample insertion error %d %s
SELECT Timestamp, degC, kPa FROM PressureSample WHERE 
bool CLPressureSampleDatabase::iterate(const std::string &, CLPressureSampleDatabase::OnSample)
 ORDER BY CFTime ASC
CoreLocation: Can't create query %s
SELECT Run, MAX(degC) - MIN(degC) AS Range FROM PressureSample WHERE 
PressureSample
std::unique_ptr<std::vector<std::string> > CLPressureSampleDatabase::findRuns(const std::string &)
CoreLocation: Table %s invalid
 GROUP BY Run ORDER BY Range DESC
static bool CLPressureSampleDatabase::getPRTT(const std::string &, const std::string &, struct CLNonlinearPrtt::Syscfg &)
CoreLocation: %s is invalid
CoreLocation: %s has no runs for clause %s
RUN="
" AND 
CoreLocation: Calculating PRTT median for %s
static bool CLPressureSampleDatabase::getPRTT(const std::string &, const std::string &, struct CLNonlinearPrtt::Syscfg &)_block_invoke
CoreLocation: Feeding %f %f to median estimator
v16@?0r^{Sample=d{?=ff}}8
CoreLocation: Problem running through %s for %s
CoreLocation: Invalid stat for run %s
CoreLocation: min kPa = %f for %s
CoreLocation: No bin for %d; dropping
getMedianInPlace
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMPressureUtilities.h
size > 0
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
silo
T@"CLSilo",R,N
vendor
T@"CLServiceVendor",R,N
T@"CLSilo",R,N,V_silo
T@"CLServiceVendor",R,N,V_vendor
static bool CMOQuaternion::northAndGravity(CMVector<float, 3>, CMVector<float, 3>, CMVector<float, 3>, const float *, CMOQuaternion &, CMMatrix<float, 3> &)
CoreLocation: n and g are too close %f
CoreLocation: Assertion failed: lambda2 != 0, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMOQuaternion.cpp, line 208,invalid weights.
CoreLocation: kappa zero!
T CMVector<float, 3>::operator[](const size_t) const [T = float, N = 3]
CoreLocation: Assertion failed: i < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMVector.h, line 272,invalid index %zu >= %zu.
T CMMatrix<float, 3, 3>::operator[](size_t) const [T = float, M = 3, N = 3]
CoreLocation: Assertion failed: ldx < M*N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 78,invalid element %zu >= %zu.
T &CMMatrix<float, 3, 3>::operator()(size_t, size_t) [T = float, M = 3, N = 3]
CoreLocation: Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 71,invalid row %zu > %zu.
CoreLocation: Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 72,invalid col %zu > %zu.
T CMMatrix<float, 3, 3>::operator()(size_t, size_t) const [T = float, M = 3, N = 3]
CoreLocation: Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 64,invalid row %zu > %zu.
CoreLocation: Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 65,invalid col %zu > %zu.
kSedentaryTimerDataCodingKeyStartDate
kSedentaryTimerDataCodingKeyFiredDate
kSedentaryTimerDataCodingKeyAlarmType
kSedentaryTimerDataCodingKeyDidWake
Reminder
Final
Reset
ActiveReminder
InVehicleReminder
%@, <startDate %@, firedDate %@, alarmType %@, didWake %@>
firedDate
alarmType
didWake
LogSensorFusion
CLSensorFusionMekf::CLSensorFusionMekf(const CFTimeInterval &, const CFTimeInterval &, bool)
CoreLocation: Doing crude accel measurement update.
CoreLocation: rotBufferSize, %zu, accelBufferSize, %zuu, peakCount, %d, fMaxStd, %.3f
CoreLocation: gyroDt, %.4f, doAccelCheck, %d
virtual void CLSensorFusionMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: omegaMag6, %.3f, omega, %.3f, %.3f, %.3f
CoreLocation: [AppleQuaternion] x,%f,y,%f,z,%f,w,%f,timestamp,%f
virtual void CLSensorFusionMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)
CoreLocation: [Bias,Var] bias.x,%f,bias.y,%f,bias.z,%f,var.x,%f,var.y,%f,var.z,%f
virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: [Accelerometer6] x,%.4f,y,%.4f,z,%.4f,lpf, %.4f, %.4f, %.4f, timestamp,%lf
CoreLocation: [RotationRate6X] %.3f, %.3f, %.3f, %.3f, %.3f
CoreLocation: rotating and going through.
CoreLocation: it's been too long. go through.
CoreLocation: grabing gravity, %.4f, %.4f, %.4f
CoreLocation: std, %.3f, %.3f, %.3f, mag, %.3f, dot, %.3f, leftover, %.3f
CoreLocation: sum, %.3f, %.3f, %.3f, dot, %.3f, leftover, %.3f
CoreLocation: ===========Skip ahead.
CoreLocation: Skip ahead------.
CoreLocation: Taking another look.
CoreLocation: using mean accel
CoreLocation: accM, (%.4f, %.4f, %.4f), mag, %.3f
CoreLocation: Doing some crude updates to catch up.
CoreLocation: [KalmanFilterStates] %f,%f,%f,%f,%f,%f,%f
void CLIoHidManager::initializeHidIfNecessary()
CoreLocation: Could not create event system client. All bets are off
PreserveTimestamp
CoreLocation: Event system client initialized successfully
void CLIoHidManager::setEventCallback(IOHIDEventType, OnIoHidEvent, void *)
CoreLocation: Trying to set properties for unknown event %d
void CLIoHidManager::setEventProperty(IOHIDEventType, NSString *, id)
CoreLocation: Unknown event %d
CoreLocation: Could not convert NSString to C++ string
void CLIoHidManager::setIoHidNewServiceCallback(IOHIDEventType, OnIoHidNewService, void *)
CoreLocation: Unknown event: %d
void CLIoHidManager::requestHidDriverInterface(IOHIDEventType, bool, bool)
CoreLocation: Unknown event %u
Opening
Closing
CoreLocation: %s hid driver interface for event %u, hidServiceRef %p
id CLIoHidManager::copyProperty(IOHIDEventType, NSString *)
CoreLocation: Service with event type %d is not ready
IOHIDServiceClientRef CLIoHidManager::getHidServiceClient(IOHIDEventType)
void CLIoHidManager::refreshHidServiceRefs()
CoreLocation: IOHIDEventSystemClientCopyServices() returned NULL
PrimaryUsagePage
PrimaryUsage
CoreLocation: Service ref with usage pair {%d,%d} (event %d) is %p
uses
doesn't use
CoreLocation: DeviceMotionLite %s compass
bool CLIoHidManager::setEventPropertyIoHid(IOHIDEventType, CFStringRef, CFTypeRef)
CoreLocation: IOHIDServiceClientSetProperty() returned false
CoreLocation: IOHIDServiceClientSetProperty() successfully set property for event %d
successfully
unsuccessfully
void CLIoHidManager::applyAllDirtyEventProperties()
CoreLocation: Property for usage pair {%d,%d}: {%s = %@} was set %s
CoreLocation: Could not set all properties. Setting timer to fire %f seconds from now
CoreLocation: Could not set all properties after too many retries. Giving up.
void CLIoHidManager::printProperties()
CoreLocation: Properties for event %d:
CoreLocation: 
void CLIoHidManager::setMatchingForEventMap()
CoreLocation: Removing set matching multiple
CoreLocation: Adding touch event,hidUsagePage,%d
DeviceUsagePage
Built-In
CoreLocation: Adding match entry for usage pair {%d,%d}
CoreLocation: Setting matching multiple
CLIoHidManager::EventType CLIoHidManager::getMotionEventType(IOHIDEventRef)
CoreLocation: Unhandled usage %d
void CLIoHidManager::onEvent(void *, void *, IOHIDEventRef)
CoreLocation: Received null sender
void CLIoHidManager::onEventSystemReset(void *)
CoreLocation: It looks like our HID event system just become available (again)
void CLIoHidManager::onServiceRegistration(void *, IOHIDServiceClientRef)
CoreLocation: New IOHIDServiceClientRef for usage pair {%d,%d} just became available.
CoreLocation: Event type %d, old hidserviceref,%p,new,%p
CLIoHidManager::EventInfo::~EventInfo()
CoreLocation: Releasing value for property %s, address = %p
LogAccelerometer
CLAccelerometer
virtual CFTimeInterval CLAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting accelerometer update interval to %f
CoreLocation: Unrecognized notification
virtual CFTimeInterval CLAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting batch interval to %f
CoreLocation: Unrecognized notification %d
Accelerometer
void CLAccelerometer::onAccelerometerData(const CLMotionTypeAcceleration &, const CLMotionTypeTimestamp &)
CoreLocation: Type,%s,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f
LogGyro
CLGyro
CLGyro::CLGyro()
CoreLocation: Could not get ideal gyro update interval, assuming %{public}f s
virtual CFTimeInterval CLGyro::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting gyro data update interval to %f
GyroDt
CoreLocation: Type,%s,dt,%f
CoreLocation: Setting gyro temperature update interval to %f
CoreLocation: Unrecognized gyro notification %d
void CLGyro::onGyroData(const CLMotionTypeRotationRate &, const CLMotionTypeTimestamp &, unsigned int)
CoreLocation: Type,%s,ret=%d
CoreLocation: [CLGyro] x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d,now,%f
com.apple.CoreMotion.CMExerciseMinute.InternalQueue
com.apple.CoreMotion.CMExerciseMinute.AppQueue
-[CMExerciseMinuteInternal init]_block_invoke
CoreLocation: ExericseMinute, Failed with CMError code %{public}d
-[CMExerciseMinuteInternal init]_block_invoke_2
CoreLocation: ExericseMinute, client connection interrupt, %@, %d, %d, %p
kCLConnectionMessageExerciseMinuteUpdate
-[CMExerciseMinuteInternal _stopUpdates]_block_invoke
CoreLocation: ExerciseMinute, Error stopping updates, no active clients.
-[CMExerciseMinuteInternal _startUpdatesWithHandler:]_block_invoke
CoreLocation: ExerciseMinute, Unable to parse update.
kCLConnectionMessageExerciseMinuteQuery
-[CMExerciseMinuteInternal _queryExerciseMinutesFromRecord:handler:]_block_invoke
CoreLocation: ExerciseMinute, Unable to parse query.
kCLConnectionMessageNatalimetryAvailable
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMExerciseMinute.mm
T@"CMExerciseMinuteInternal",R,N,V_internal
LogMagnetometer
CLMagnetometer
IOHIDCompasssResetDAC
bool CLMagnetometer::setMagnetometerUpdateInterval(const CFTimeInterval &)
CoreLocation: Setting magnetometer update interval to: %d us
bool CLMagnetometer::setMagnetometerBatchInterval(const CFTimeInterval &)
CoreLocation: Setting magnetometer batch interval to: %d us
BatchInterval
virtual CFTimeInterval CLMagnetometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting magnetometer update interval to %f
CoreLocation: Unrecognized magnetometer notification %d
Magnetometer
void CLMagnetometer::onMagnetometerData(const CLMotionTypeMagneticField &, const CLMotionTypeTimestamp &)
static void CLMagnetometer::onOffset(const CLMotionTypeMagneticField *, void *)
CoreLocation: Received magnetometer offset (%f, %f, %f)
ssize_t CLMotionNotifier::numberOfClients(int)
CoreLocation: Unknown notification %d
ssize_t CLMotionNotifier::numberOfSpectators(int)
CFTimeInterval CLMotionNotifier::minimumUpdateInterval(int)
bool CLMotionNotifier::addDispatcherPrivate(int, CLMotionNotifier::Dispatcher *, const CFTimeInterval &)
CoreLocation: Requested update interval cannot be == 0.0 and dispatcher cannot be NULL. Use interval < 0.0 for spectator.
CoreLocation: CLMotionNotifier::addDispatcherPrivate UpdateInterval is zero!
CoreLocation: CLMotionNotifier::addDispatcherPrivate Added dispatcher for notification:%d, Update Interval:%f(%.1fHz)
void CLMotionNotifier::setUpdateIntervalPrivate(int, CLMotionNotifier::Dispatcher *, const CFTimeInterval &)
CoreLocation: Unknown (notification,dispatcher) pair: (%d, %p)
CoreLocation: CLMotionNotifier::setUpdateIntervalPrivate RequestedUpdateInterval:%f, UpdateInterval:%f
void CLMotionNotifier::updateSamplePeriods(int)
CoreLocation: CLMotionNotifier::updateSamplePeriod UpdateInterval:%f
CLPlatformInfo::motionCaps().pickup
com.apple.CoreMotion.CMLiftManager
T@"CMLiftManagerInternal",R,N,V_internal
T@"<CMLiftManagerDelegate>",N
_lvl
_cat
_msg
null
No value written for object
%13.3lf
/System/Library/Frameworks/CoreMotion.framework/Support
static void CLMotionCore::create()
CoreLocation: Could not get parent thread parameters
CoreLocation: Motion runloop ref still not set!
bool CLMotionCore::setMotionThreadPriority(int)_block_invoke
CoreLocation: Could not get scheduling parameters for motion thread, error = %{public}d
LogSensorAscii
bool CLMotionCore::shouldLogSensorAscii()_block_invoke
CoreLocation: LogSensorAscii,%d
wrapRunLoopWithAutoreleasePoolHandler
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Shared/Motion/CLMotionCore.mm
count > 0
com.apple.CoreMotion.MotionThread
com.apple.CoreMotion
MotionThreadPriority
static void *CLMotionCore::runMotionThread(void *)
CoreLocation: could not create runloop source
static void *CLMotionCore::runMotionThread(void *)_block_invoke_2
CoreLocation: Ping timer fired, resetting watchdog
Motion thread watchdog
static void *CLMotionCore::runMotionThread(void *)_block_invoke_3
CoreLocation: Motion thread deadlock watchdog after %d petting
com.apple.CoreMotion.ThreadDeadlockCount
%@.%@
CoreLocation: Failed to create watchdog timer
v16@?0^{__CFRunLoopTimer=}8
CoreLocation: Motion thread exiting
void CLMotionCore::onSystemPowerChanged(io_service_t, uint32_t, void *)
CoreLocation: CLMotionCore::SleepBounce
CoreLocation: CLMotionCore::PoweredOnBounce
void CLMotionCore::willResignActive()_block_invoke
CoreLocation: willResignActiveBounce
void CLMotionCore::didBecomeActive()_block_invoke
CoreLocation: didBecomeActiveBounce
CLPocketStateService
com.apple.CoreMotion.CLPocketStateService
v16@?0@"CMMotionActivity"8
void CLPocketStateService::enableDetection()
CoreLocation: Could not subscribe to system power notifications
CoreLocation: enabled detection successfully
void CLPocketStateService::determineState()
CoreLocation: Device Stationary?, %s, Orientation, %s, Proximity, %s
1 prox corroborated
2 not (FaceDown and static)
3 no prox
4 FaceDown only
5 not FaceDown, prox uncovered
OutOfPocket
FaceDownOnTable
InPocket
Uncovered
Covered
Not FaceDown
started
extended
ignored
void CLPocketStateService::transitionToState(CLPocketStateInternalType, const char *)
CoreLocation: Transition, From: %s, To: %s, %s
CoreLocation: %f: Device Stationary?, %s, Orientation, %s, Proximity, %s, State, %s
virtual void CLPocketStateService::numberOfSpectatorsChanged(int, size_t)
CoreLocation: disable Detection
com.apple.CoreMotion.PocketState.%@
void CLPocketStateService::queryInitiated(NSTimeInterval)
CoreLocation: %f: monitorTime, %f, bksMonitorTime, %f, bksDelay, %f, proxStatus, %s
proxStatus.started
proxStatus.extended
proxStatus.ignored
void CLPocketStateService::feedProximityData(const uint32_t)_block_invoke
CoreLocation: %f: ProxDelay,%f
proxBootDelay
CoreLocation: Proximity detection mask: %u, Last prox state: %s
void CLPocketStateService::onSystemPowerChanged(io_service_t, uint32_t, void *)
CoreLocation: received WillSleep
CoreLocation: received WillPowerOn
CoreLocation: received HasPoweredOn
com.apple.CoreMotion.CMMotionAlarmManager
-[CMMotionAlarmManagerInternal init]_block_invoke
-[CMMotionAlarmManagerInternal init]_block_invoke_2
CoreLocation: CMMotionAlarmManager client connection interrupt, %@, %d, %d, %p
-[CMMotionAlarmManagerInternal _teardown]
CoreLocation: Tearing down CMMotionAlarmManagerInternal
kCLConnectionMessageMotionAlarmFire
-[CMMotionAlarmManagerInternal _stopListeners]_block_invoke
CoreLocation: Unable to stop MotionAlarm data updates as we are are not receiving updates.
-[CMMotionAlarmManagerInternal _registerAlarm:error:]
CoreLocation: Unable to register motion alarm. No delegate assigned.
CoreLocation: Unable to register motion alarm. Invalid alarm object.
kCLConnectionMessageMotionAlarmRegister
-[CMMotionAlarmManagerInternal _registerAlarm:error:]_block_invoke
CoreLocation: Unable to parse kCLConnectionMessageMotionAlarmRegister message.
-[CMMotionAlarmManagerInternal _unregisterAlarm:error:]
CoreLocation: Unable to unregister motion alarm. No delegate assigned.
CoreLocation: Unable to unregister motion alarm. Invalid alarm object.
kCLConnectionMessageMotionAlarmUnregister
-[CMMotionAlarmManagerInternal _unregisterAlarm:error:]_block_invoke
CoreLocation: Unable to parse kCLConnectionMessageMotionAlarmUnregister message.
-[CMMotionAlarmManagerInternal _acknowledgeAlarm:error:]
CoreLocation: Unable to acknowledge alarm, alarm does not exist.
kCLConnectionMessageMotionAlarmAcknowledge
-[CMMotionAlarmManagerInternal _acknowledgeAlarm:error:]_block_invoke
CoreLocation: Unable to parse kCLConnectionMessageMotionAlarmAcknowledge message.
CoreLocation: Unable to call kCLConnectionMessageMotionAlarmAcknowledge message. Code: %d
kCLConnectionMessageMotionAlarmLaunchRemoteApplication
-[CMMotionAlarmManagerInternal _handleAlarmFire:]
CoreLocation: Unable to fire motion alarm. Received invalid message response.
CoreLocation: Unable to fire motion alarm %@. Could not locate valid alarm to fire.
_DefaultManager
T@"<CMMotionAlarmDelegateProtocol>",N,V_delegate
name
T@"NSString",R,N,V_name
com.apple.CoreMotion.CMNatalimeter
-[CMNatalimeterInternal init]_block_invoke
CoreLocation: Calorie response failed with error %{public}d
-[CMNatalimeterInternal init]_block_invoke_2
-[CMNatalimeterInternal init]_block_invoke_3
CoreLocation: Unable to set activity session on interrupted connection.  locationd and framework client states are not in sync!
v16@?0q8
-[CMNatalimeterInternal _setSession:withCompletionHandler:]
CoreLocation: #Notice %{public}s (%{public}d) setting session %{public}d %{public}p
kCLConnectionMessageNatalimetrySetSession
-[CMNatalimeterInternal _setSession:withCompletionHandler:]_block_invoke
CoreLocation: Unable to set session. Unexpected user error
CoreLocation: Unable to set session. Error code %{public}d
CoreLocation: #Notice %{public}s (%{public}d) received status %{public}d after setting session %{public}d %{public}p
kCLConnectionMessageNatalimetryQuery
-[CMNatalimeterInternal _queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:]_block_invoke
CoreLocation: %@, pid, %d, query since record, %@, %p
kCLConnectionMessageNatalimetryUpdate
-[CMNatalimeterInternal _startAbsoluteNatalimetryDataUpdatesWithHandler:]_block_invoke
CoreLocation: %@, pid, %d, update, %@, %p
CoreLocation: Error parsing update.
-[CMNatalimeterInternal _stopAbsoluteNatalimetryDataUpdates]_block_invoke
CoreLocation: Error stopping calorie updates, not active clients.
kCLConnectionMessageNatalimetryCalibrationPromptsNeeded
-[CMNatalimeterInternal _promptsNeeded]
CoreLocation: Prompts needed response invalid.
CoreLocation: Querying for calibration prompts encountered an error: %{public}ld.
kCLConnectionMessageNatalimetryGetUserProfile
+[CMNatalimeter userProfile]
CoreLocation: UserProfile, Invalid response
kCLConnectionMessageNatalimetrySetUserProfile
+[CMNatalimeter setUserProfile:error:]
CoreLocation: UserProfile, Error while setting, %{public}d
kCLConnectionMessageNatalimetryResetCalibration
+[CMNatalimeter resetCalibrationDataWithError:]
CoreLocation: Unable to reset calibration data. Error code %{public}ld.
CoreLocation: Invalid response to reset calibration.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMNatalimeter.mm
session >= 0 && session < kCMNatalieDataSessionMax
userInfo
activeCalories
+[CMNatalimeter computeTimeToActiveCalories:user:workoutType:]
CoreLocation: TimeToActiveCalories is negative: timeToActiveCalories, %f, %{private}@
CoreLocation: TimeToActiveCalories, %f, target, %f, workoutType, %ld, %{private}@
T@"CMNatalimeterInternal",R,N,V_internal
kTypeUnknown
kTypeFrozen
kTypeStatic
kTypeMoving
kTypeSemiStationary
kTypeWalking
kTypeWalkingSlow
kTypeRunning
kTypeCycling
kTypeInVehicleFrozen
kTypeInVehicleStatic
kTypeDriving
kTypeVehicularInHand
kTypeDrivingOther
kTypeDrivingMounted
kTypeDrivingOrWalkingSlow
kTypeCyclingSeat
kTypeCyclingChassis
kTypeCyclingLeg
kTypeCyclingArm
kTypeCyclingTorso
kTypeDrivingSeat
kTypeDrivingArm
kTypeDrivingStowed
kTypeRunningLeg
kTypeRunningArm
kTypeWalkingLeg
kTypeWalkingArm
kTypeSemiStationaryPocket
kTypeSemiStationaryArm
ERROR
LogLegacyRadar
LogFile
LogFileDirectory
LogFilePrefix
LogFileFlush
ShowError
LogFence
LogBufferSize
LogShowUI
LogFileLevel
LogBufferLevel
LogConsoleLevel
LogStackLevel
LogLocations
LogLocationsFile
LogLocationsFlush
.log
com.apple.locationd.log.compression
vlog
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Shared/Logging/CLLog.mm
newFullContentLength == fullContentLength
'\n' == buffer[fullContentLength - 1]
%s,%s,Time,%08.3f,Function,"%s",
%s,%s,Time,%08.3f,
%s,%s,logging locations to %s%s
NOTICE
CLLog
 and flushing immediately
 no flush
%s,%s,logging locations to an internal buffer with capacity %d
.bz2
%s,%s,Failed to move aside log file %s (%d)
%s/%s
Failed to delete log
%s,%s,Rotation path is too long, could not delete old logs.
C16@?0r*8
%s,%s,Failed to write %s
%s,%s,could not open locations log %s, errno %d
Unplugged!
void CLLog::logHeader()
CoreLocation-%s
locationd was compiled on %s at %s
Jun 10 2017
23:33:11
%s @ system model %s / version %s
/usr/libexec/locationd @ system model %s / version %s
IOPlatformSerialNumber: %s
Begin settings dump (read at construction of CLSettings or upon darwin notification 'com.apple.locationd/prefs')
End settings dump
%s,%s,CLLog does not honor stderr/stdout unless in backward compatibility mode
com.apple.timed
%s,%s,dumping internal buffer
%s,%s,copying gll.log
LogNatalimetry
LogCalorimetry
userinfo
cache
.plist.log
%s,%s,could not copy %s log
WARNING
%s,%s,could not dump log file
%s,%s,Time,%08.3f,%d
0x%08lx %s + %lu
STATUS
STACK
%s,%s,Time,%08.3f,%d
0x%08lx 0x%08lx + %lu
%s,%s,Time,%08.3f,%d
0x%08lx
CLCircularLogBuffer
kCMMagneticFieldCodingKeyX
kCMMagneticFieldCodingKeyY
kCMMagneticFieldCodingKeyZ
CLPlatformInfo::motionCaps().deviceMotion6Service
void CLWriteStackshot(const char *, _Bool)
CoreLocation: #Warning stackshot only available on device
T@"<CMAnomalyDelegate>",N,V_delegate
long CLCommonGetFileSizeFd(int)
CoreLocation: Failed to get current position for fd %{public}d: %{public}s
CoreLocation: Failed to get size of fd %{public}d: %{public}s
CoreLocation: Failed to restore to original position of fd %{public}d: %{public}s
-decrypt-XXXXXXXXX.tmp
bool CLCommonDecryptFileAES256(const char *, const char *, const char *)
CoreLocation: Failed to create decryptor. status = %{public}d
CoreLocation: Failed to open input file '%{public}s' to decrypt: %{public}s
CoreLocation: Failed to get size of input file %{public}s
CoreLocation: Failed to open temporary output file '%{public}s' to save '%{public}s' to '%{public}s': %{public}s
CoreLocation: Decrypting '%s' to '%s' via temporary file '%s'
CoreLocation: Failed to read from '%{public}s'.  %{public}lld bytes read successfully.  %{public}s
CoreLocation: Failed to decrypt '%{public}s'.  %{public}lld input bytes decrypted successfully. %{public}d
CoreLocation: Failed to write to '%{public}s'.  %{public}lld input bytes decrypted & written successfully. %{public}s
CoreLocation: Failed to finalize decryption of '%{public}s': %{public}d
CoreLocation: Failed to write final %{public}zu bytes to '%{public}s': %{public}s
CoreLocation: Failed to rename '%{public}s' to '%{public}s'. Decryption of '%{public}s' failed: '%{public}s'
CoreLocation: Decryption of '%{public}s' failed.  Also failed to unlink temporary file '%{public}s': %{public}s
CLAccelerometer::Sample CLSensorNetworkProtocol::deserializeAccelerometerPacket(CFDataRef)
CoreLocation: Not an accelerometer packet
CLGyro::Sample CLSensorNetworkProtocol::deserializeGyroPacket(CFDataRef)
fDeviceMotionLiteClientQueue
T@"NSOperationQueue",&,N,V_fDeviceMotionLiteClientQueue
fDeviceMotionLiteFusedHandler
T@?,C,N,V_fDeviceMotionLiteFusedHandler
fDeviceMotionLitePhysicalDeviceID
T@"NSString",&,N,V_fDeviceMotionLitePhysicalDeviceID
-[CMMotionManager startDeviceMotionLiteUpdatesForDeviceID:usingConfiguration:toQueue:withFusedHandler:]
CoreLocation: Motion manager can not start device motion lite updates, use isDeviceMotionLiteAvailable before using this API
-[CMMotionManager startDeviceMotionLiteFusedUpdatesForDeviceID:toQueue:withHandler:]
CoreLocation: Motion manager asked to start device motion lite updates for device id %@
-[CMMotionManager stopDeviceMotionLiteUpdatesForDeviceID:]
CoreLocation: Motion manager asked to stop device motion lite updates for device id %@
void onDeviceMotionLiteFused(const CLMotionTypeDeviceMotionLite *, void *)
CoreLocation: Received fused sample
isDeviceMotionLiteAvailable
TB,R,N,GisDeviceMotionLiteAvailable
accelerometerUpdateInterval
Td,D,N
accelerometerAvailable
TB,R,D,N,GisAccelerometerAvailable
accelerometerActive
TB,R,D,N,GisAccelerometerActive
accelerometerData
T@"CMAccelerometerData",R,D
gyroUpdateInterval
gyroAvailable
TB,R,D,N,GisGyroAvailable
gyroActive
TB,R,D,N,GisGyroActive
gyroData
T@"CMGyroData",R,D
magnetometerUpdateInterval
Td,N
magnetometerAvailable
TB,R,N,GisMagnetometerAvailable
magnetometerActive
TB,R,N,GisMagnetometerActive
magnetometerData
T@"CMMagnetometerData",R
deviceMotionUpdateInterval
attitudeReferenceFrame
TQ,R,D,N
deviceMotionAvailable
TB,R,D,N,GisDeviceMotionAvailable
deviceMotionActive
TB,R,D,N,GisDeviceMotionActive
deviceMotion
T@"CMDeviceMotion",R,D
showsDeviceMovementDisplay
TB,N
com.apple.locationd.appreset
com.apple.locationd.appstatus
com.apple.locationd.techstatus
com.apple.locationd.started
com.apple.locationd.statusbar
com.apple.locationd.authorization
Locations
LocationCount
__null == fConnection
__null == fDestructionHandler
fEventQueue
void CLConnection::handleMessage(std::shared_ptr<CLConnectionMessage>)
CoreLocation: #Warning Unhandled message %s
bool CLConnection::sendMessageInternal(std::shared_ptr<CLConnectionMessage>, xpc_handler_t)
CoreLocation: Couldn't create XPC message
v16@?0@"NSObject<OS_xpc_object>"8
kCLConnectionMessageInfoKey
kCLConnectionMessageFileDescriptorKey
id<NSSecureCoding> CLConnectionMessage::getObject() const
CoreLocation: The received data object is invalid: %{public}s
bool CLConnectionMessage::sendReply(const std::string &, id<NSSecureCoding>)
CoreLocation: Unable to send reply, a reply message does not exist.
bool CLConnectionMessage::sendReply(const std::string &, xpc_object_t)
void setEventHandler(xpc_connection_t, CLConnectionMessageHandler, CLConnectionEventHandler, CLConnectionEventHandler, CLConnectionEventHandler *)_block_invoke
CoreLocation: #Warning Connection interrupted!
CoreLocation: #Warning Location connection invalid!
CoreLocation: Got unexpected location event
void handleXPCEvent(xpc_object_t, CLConnectionMessageHandler, CLConnection *)
CoreLocation: Error on message reply (%{public}s)
CoreLocation: Ignoring unexpected event
CLSensorFusion9AxisMekf::CLSensorFusion9AxisMekf(const CFTimeInterval &, const CFTimeInterval &, const CFTimeInterval &, bool)
CoreLocation: rotBufferSize9, %zu, accelBufferSize, %zuu, peakCount, %d, compassBufferSize, %zu
CoreLocation: gyroDt9, %.4f, doAccelCheck, %d
virtual void CLSensorFusion9AxisMekf::reset()
CoreLocation: fAccelBuffer,size,%zu
virtual void CLSensorFusion9AxisMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: omegaMag9, %.3f, omega, %.3f, %.3f, %.3f
CoreLocation: [AppleQuaternion9] x,%f,y,%f,z,%f,w,%f,timestamp,%f
virtual void CLSensorFusion9AxisMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)
virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: [Accelerometer9] x,%f,y,%f,z,%f,timestamp,%lf
CoreLocation: [RotationRate9] %.3f, %.3f, %.3f, %.3f
CoreLocation: [KalmanFilterStates9] %f,%f,%f,%f,%f,%f,%f
void CLSensorFusion9AxisMekf::doAccelerometerMeasurementUpdate(double *, double)
CoreLocation: [KalmanFilterStates9-AccelUpdate] %f,%f,%f,%f,%f,%f,%f
virtual bool CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const bool &, const bool &, const CFTimeInterval &)
CoreLocation: [CompassIntoKF] timestamp,%f,calibration level %d, compassHasAlignedToStableField %d, useMagneticRefX %d
CoreLocation: [CompassIntoKF] fLastAccelTime,%f
CoreLocation: [CompassIntoKF] magneticFieldAdjusted!
CoreLocation: rotAroundGrav, %.3f, sum, %.3f
CoreLocation: [CompassIntoKF] omegaMag, %.3f, omegaVar, %.3f
CoreLocation: FieldDiff, %.3f, %.3f, %.3f, %.3f
CoreLocation: Aborted yawUpdate.
CoreLocation: Checking again for magField. checkcount, %d
CoreLocation: fCorrected, %.3f, %.3f, %.3f
CoreLocation: [!!!CompassInertialReference] x,%f,y,%f,z,%f,calibrationLevel,%d,timestamp,%lf
CoreLocation: Warning: Compass outputs field magnitude 0.
CoreLocation: [!!!CompassInertialReference] x,%f,y,%f,z,%f
CoreLocation: UpdatingYaw!
CoreLocation: [Magnetometer9] x,%f,y,%f,z,%f,timestamp,%lf
CoreLocation: Warning: Hey! Compass outputs field magnitude 0.
float CLSensorFusion9AxisMekf::doCompassMeasurementUpdate(double *, double, int, bool)
CoreLocation: [ExpectedCompass] %f,%f,%f,%f
CoreLocation: [TrueCompass] %f,%f,%f,%d,%f
CoreLocation: [MagCCross] %f,%f,%f,%f,%f,%f,%f,%f,%f,%f
CoreLocation: [MagCorrectionDX] %f,%f,%f,angle,%.3f,sumRot,%.3f,%f
INFO
VERBOSE
NONE
LOCATION
SENSOR
FENCE
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMElevationData.mm
sample
sourceId && startDate && endDate
kCMElevationDataCodingKeyRecordId
kCMElevationDataCodingKeySourceId
kCMElevationDataCodingKeyStartDate
kCMElevationDataCodingKeyEndDate
kCMElevationDataCodingKeyElevationAscended
kCMElevationDataCodingKeyElevationDescended
%@, <startDate, %@, endDate, %@, elevationAscended, %lu, elevationDescended, %lu>
TQ,R,N
kCMActivityCodingKeyType
kCMActivityCodingKeyConfidence
kCMActivityCodingKeyMounted
kCMActivityCodingKeyMountedConfidence
kCMActivityCodingKeyIsStanding
kCMActivityCodingKeyTiltAngle
kCMActivityCodingKeyTimestamp
kCMActivityCodingKeyVehicleExitState
kCMActivityCodingKeyEstExitTime
kCMActivityCodingKeyStartTime
%@ @ %f,<startDate,%@,type,%s,confidence,%s,mountedState,%d,mountedConfidence,%s,isStanding,%d,tiltAngle,%f,exitState,%d,estExitTime,%f>
isMoving
isWalking
isRunning
isDriving
maybeExitingVehicle
hasExitedVehicle
com.apple.CoreLocation.ConnectionClient.%p
com.apple.CoreLocation.ConnectionClient.%p.events
B8@?0
void CLConnectionClient::setHandlerForMessage_onQueue(NSString *, CLConnectionMessageHandler)
CoreLocation: Setting handler for message %s
bool CLConnectionClient::sendMessage_onQueue(std::shared_ptr<CLConnectionMessage>, bool)
CoreLocation: #Warning Sending an un-cached message '%{public}s' without first clearing the previously cached value
static void CLConnectionClient::handleDaemonStart(CFNotificationCenterRef, void *, CFStringRef, const void *, CFDictionaryRef)
CoreLocation: received daemon start notification for service %s
void CLConnectionClient::createConnection_onQueue()
CoreLocation: Creating connection
v32@?0@8@16^B24
void CLConnectionClient::destroyConnection_onQueue()
CoreLocation: Destroying connection
void CLConnectionClient::sendCachedMessages_onQueue()
CoreLocation: #Warning No cached registration message
com.apple.CoreMotionCMGestureManagerPrivateQueue
kCLConnectionMessageGesture
-[CMGestureManagerInternal startGestureUpdatesWithHandlerPrivate:]_block_invoke
CoreLocation: Could not get dictionary for kCLConnectionMessageGesture
GestureDetected
GestureCanceled
CoreLocation: Unexpected ear gesture state received: %{public}s
kCLConnectionMessagePriorityKey
-[CMGestureManager gestureHandler]_block_invoke
CoreLocation: #Notice Calling ear gesture handler
gestureHandler
T@?,C
com.apple.CoreMotion.CMActivityManagerPrivateQueue
kCLConnectionMessageMotionState
-[CMActivityManagerInternal connect]_block_invoke
CoreLocation: Could not get dictionary for kCLConnectionMessageMotionState
CoreLocation: Error occurred while trying to retrieve activity update: CMErrorDomain Code:%{public}d
CoreLocation: Unable to parse kCLConnectionMessageMotionState message!
kCLConnectionMessageSidebandOverride
CoreLocation: Could not parse dictionary for kCLConnectionMessageSidebandOverride
kCLConnectionMessageMotionStateSim
CoreLocation: Could not parse dictionary for kCLConnectionMessageMotionStateSim
-[CMActivityManagerInternal overrideOscarSideband:withState:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMActivityManager.mm
fSidebandOverrideSemaphore && "fSidbandOverrideSemaphore not initialized."
-[CMActivityManagerInternal simulateMotionState:withState:]
fMotionStateSimSemaphore && "fMotionStateSimSemaphore not initialized."
com.apple.CoreMotion.SidebandOverride
-[CMActivityManager overrideOscarSideband:withState:]_block_invoke
CoreLocation: Timeout occurred after 5 seconds during overrideOscarSideband:withState:.  Wait result = %{public}ld
com.apple.CoreMotion.MotionStateSim
activityHandler
activityAvailable
TB,R,N,GisActivityAvailable
PRTTSampleTemperature
PRTTSamplePressure
std::deque<CLMotionTypePressure> CLRobustSlopeEstimator::computePRTT()
CoreLocation: %s,%f,%s,%f
PopSampleTime
CalibrationBinCount
void CLRobustSlopeEstimator::addPoint(const CLPressure::Sample *)
CoreLocation: %s,%f,%s,%d
CalibrationSampleTime
CalibrationSamplePressure
CalibrationSampleTemperature
CalibrationTemperatureRate
CoreLocation: %s,%f,%s,%f,%s,%f,%s,%f,%s,%d
com.apple.CoreMotion.CMPedometerInternalQueue
com.apple.CoreMotion.CMPedometerUpdateQueue
kCLConnectionMessageStartStepCountUpdate
-[CMPedometerProxy init]_block_invoke
CoreLocation: Unable to parse message (%{public}@) when starting updates to queue
CoreLocation: Unable to parse message when starting updates to queue!
kCLConnectionMessagePedometerEvent
-[CMPedometerProxy init]_block_invoke_2
CoreLocation: nil pedometer event dictionary received
CoreLocation: Error pedometer event, %{public}ld
CoreLocation: Unrecognizable pedometer event dictionary
CoreLocation: CMPedometer client connection interrupt, %@, %d, %p
kCLConnectionMessageStepCountQuery
-[CMPedometerProxy _startPedometerUpdatesFromDate:withHandler:]_block_invoke
CoreLocation: Error occurred: %{public}@
v32@?0@"CMPedometerData"8@"NSDictionary"16@"NSError"24
-[CMPedometerProxy _handleQueryResponse:onQueue:withHandler:]
CoreLocation: Unable to parse message (%{public}@) for query response 
CoreLocation: Unable to parse message when checking for availability!
kCLConnectionMessageStepCountRecordQuery
kCLConnectionMessageStrideCalibrationDump
-[CMPedometerProxy _strideCalibrationDump]_block_invoke
CoreLocation: Successfully wrote stride calibration data to file.
CoreLocation: Error occurred while trying to write stride calibration data to file!
-[CMPedometerProxy _queryPedometerCalibrationBinsWithHandler:forType:forRemote:]
CoreLocation: Remote calibrations not available on this platform
kCLConnectionMessagePedometerCalibrationQuery
-[CMPedometerProxy _queryPedometerCalibrationBinsWithHandler:forType:forRemote:]_block_invoke
v16@?0@"NSDictionary"8
kCLConnectionMessageStartStepCountAvailable
kCLConnectionMessagePaceAndCadenceAPIAvailable
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMPedometer.mm
-[CMPedometer _queryPedometerDataSinceDataRecord:withHandler:]
CoreLocation: handler not set.
-[CMPedometer sendStrideCalibrationHistoryToFile:]
CoreLocation: fileURL must be a valid fileURL.
CoreLocation: File already exists at URL.
CoreLocation: URL must point to a file path which you have access to write to.
CoreLocation: Unable to dump stride calibration data.
CoreLocation: Unable to serialize stride cal data to json. Error: %@
CoreLocation: Unable to write stride cal data to output file.
pedometerProxy
T@"CMPedometerProxy",R,N,V_pedometerProxy
frozen
static
moving
walking
driving
cycling
semi-stationary
running
moving coarse
in vehicle frozen
in vehicle static
walking slow
vehicular in hand
driving other
cycling leg
Stationary Cycling
Cross Training
Stair Climbing
Indoor Running
Indoor Walking
Pushing Wheelchair
Outdoor Wheelchair Activity
medium
high
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLNotifierData *) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLAttitudeDependentKFCalibrator::init()
CoreLocation: RotationStability buffer not set.
virtual void CLAttitudeDependentKFCalibrator::setBias(const CLVector3d<float> &, const CLMotionTypeCompassCalibrationLevel &, const CLVector3d<float> &, const CLClientQuaternion *)
CoreLocation: Could not set bias retrieved from database
CoreLocation: setting bias (%.3f/%.3f/%.3f) level (%d)
void CLAttitudeDependentKFCalibrator::resetInternal(const CLVector3d<float> &, const CLMatrix3d<float> &, CLMotionTypeCompassCalibrationLevel)
CoreLocation: reset internal. levels-data(%d %d %d), pScale=%.3f 
virtual void CLAttitudeDependentKFCalibrator::reset()
CoreLocation: compass calibrator reset
void CLAttitudeDependentKFCalibrator::resetCalibration(const CLVector3d<float> &, const CLMatrix3d<float> &)
CoreLocation: Resetting calibrator states.
bool CLAttitudeDependentKFCalibrator::resync(float, bool, bool, bool, float, float, float, const CLVector3d<float> &, float, float, float, const CLVector3d<float> &)
CoreLocation: Resync after long coasting with mag drift. mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), Age(%d,%d)
CoreLocation: DRIFT DETECTED. numBad=%d,s=%.3f,delH(%.3f,%d,%.3f), expectedVec (%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d),deltaTime(%.3f)
CoreLocation: fBackupInfoSet(%d), syncAge(%d)
CoreLocation: Likely bad resync. Backup. 
CoreLocation: RESYNC Rejected. numBad=%d,mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), syncAge(%d)
CoreLocation: numBad(%d), delH(%.3f), coastVec(%.3f/%.3f/%.3f), expectedVec(%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d)
bool CLAttitudeDependentKFCalibrator::handleInterference(const CLVector3d<float> &, const CLVector3d<float> &, bool, bool)
CoreLocation: Coasting vector not set.
CoreLocation: Prolonged high magDiff. Likely bad calibration. Resetting.
CoreLocation: Extremely high magnitude.  magDiff (%.3f), magnitude (%.3f), calibrated (%.3f/%.3f/%.3f), coastVector (%.3f/%.3f/%.3f),coastingTime,%.3f,magDiffVar,%.3f,resetInternal,%d
CoreLocation: Likely bad database lookup. Resetting. 
CoreLocation: ******* scale(%.3f),cAge(%d), magDiff(%.3f), dHeading(%.3f), deltaAngle(%.3f), numBad(%d), calInc(%.3f), incDiffIsStable(%d)
CoreLocation: Steep inclination. Likely bad interference or bad database lookup. Resetting. 
CoreLocation: Interference is gone.
CoreLocation: **INTERFERENCE-1 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
CoreLocation: **INTERFERENCE-0 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
void CLAttitudeDependentKFCalibrator::handleDivergence(const CLVector3d<float> &)
CoreLocation: Divergence!!! Resetting.
int CLAttitudeDependentKFCalibrator::calcCalibrationLevel(const CLVector3d<float> &)
CoreLocation: new internal estimates (%.3f %.3f %.3f)
CoreLocation: taking new estimates, Internal. fIsCoasting (%d)
CoreLocation: new estimates denied, fIsCoasting (%d)
CoreLocation: taking new estimates, reached database. (%d)
CoreLocation: new esitmates disagree with database. (%d,%d,%.3f)
CoreLocation: calibrated, first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
CoreLocation: taking new estimates, fIsCoasting (%d)
CoreLocation: estimates improved.(%.3f/%.3f/%.3f), numImprov=%d 
CoreLocation: new estimates needed, fIsCoasting (%d)
CoreLocation: first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
bool CLAttitudeDependentKFCalibrator::sanityCheck(unsigned int *, CLMotionTypeCompassCalibrationLevel, float &)
CoreLocation: new estimates calculated, converged(%d %d %d) Var (%.3f %.3f %.3f), remain (%.3f), level (%d), num=%d 
void CLAttitudeDependentKFCalibrator::resetAfterCoasting()
CoreLocation: Bad heading divergence for too long. Prompt user to re-calibrate.
CoreLocation: Waiting too long for internal re-calibration. Prompt user.
CoreLocation: Waiting too long for high magnitude interference to go away. Exit coasting.
CoreLocation: Coasting for too long. Exit coasting.
virtual void CLAttitudeDependentKFCalibrator::referenceAttitudeChanged(bool, const CLMotionTypeMagneticField &)
CoreLocation: fCoastingVecPrint: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f
virtual void CLAttitudeDependentKFCalibrator::addSample(const CLVector3d<float> &, const CLClientQuaternion *, const CFTimeInterval &)
CoreLocation: Attitude data not set.
Compass-withFusion
CoreLocation: Type,%s,Updating reference frame.
CoreLocation: Updating during coasting, fIsResetInternal(%d)
CoreLocation: BACKUP resync coasting vector
CoreLocation: resync coasting vector. rotM,%.3f,rotV,%.3f
CoreLocation: device status: (smooth static) = (%d %d), rotM,%.3f,rotV,%.3f, q.x,%.3f,q.y,%.3f,q.z,%.3f,q.w,%.3f)
CoreLocation: coasting vector is mature, no more updating
CoreLocation: numSamplesSkipped (%d), deltaQ (%.3f/%.3f/%.3f/%.3f), deltaReadingM (%.3f)
void CLAttitudeDependentKFCalibrator::setCalibrationValues()
CoreLocation: bias.x,%.3f,bias.y,%.3f,bias.z,%.3f,scale.x,%.5f,scale.y,%.5f,scale.z,%.5f,extF.x,%.3f,extF.y,%.3f,extF.z,%.3f
void CLAttitudeDependentKFCalibrator::setCoastingVector(bool)
CoreLocation: set coasting vector (%.3f/%.3f/%.3f), levels (%d %d) conv(%d %d %d) age (%d) syncAge (%d) DueTo (%d)
void CLAttitudeDependentKFCalibrator::enterCoasting()
CoreLocation: enters coasting
CLCompassCalibrator::CLCompassCalibrator(const CFTimeInterval &)
CoreLocation: compass calibrator logging (%d)
void CLAttitudeDependentKFCalibrator::exitCoasting()
CoreLocation: exits coasting
CMAvailable
CMAuthorized
CMErrorMessage
CMReturnCode
CMOnBodyStatusManagerClassifierTheta0
CMOnBodyStatusManagerClassifierTheta1
CMOnBodyStatusManagerClassifierTheta2
CMOnBodyStatusManagerClassifierTheta3
CMOnBodyStatusManagerClassifierTheta4
CMOnBodyStatusManagerClassifierTheta5
CMOnBodyStatusManagerClassifierMinLowPower
CMOnBodyStatusManagerClassifierMaxLowPower
CMOnBodyStatusManagerClassifierMaxHighPower
CMOnBodyStatusManagerLowBandStart
CMOnBodyStatusManagerLowBandStop
CMOnBodyStatusManagerHighBandStart
CMOnBodyStatusManagerHighBandStop
CMOnBodyStatusManagerWakeThreshold
CMOnBodyStatusManagerOddsThreshold
CMOnBodyStatusManagerMedianFilterSize
CMOnBodyStatusManagerConfidenceThreshold
CMOnBodyStatusManagerUseHysteresis
CMOnBodyStatusManagerUseAngleOverride
CMOnBodyStatusManagerAngleMetricThreshold
CMOnBodyStatusManagerManufacturer
CMPedometerDataObject
CMPedometerDataArray
CMPedometerStartTime
CMPedometerStopTime
CMPedometerSpeedSum
CMPedometerEntryCount
CMPedometerEventKey
CMPedometerCalibrationBins
CLMotionSyncStoreLastUpdate
CMPedometerFetchRemoteCalibrations
CMPedometerCalibrationTypeId
CMNatalimetrySessionId
CMNatalimetryRecordId
CMNatalimetryNatalieData
CMNatalimetryNatalieDataStartDate
CMNatalimetryNatalieDataMets
CMNatalimetryNatalieDataNatalies
CMNatalimetryNatalieDataBasalNatalies
CMNatalimetryNatalieDataSourceId
CMNatalimetryNatalieDataArray
CMNatalimeterSetUserHeightMeter
CMNatalimeterSetUserWeightKG
CMNatalimeterSetUserAgeYr
CMNatalimeterSetUserBiologicalSex
CMNatalimeterSetUserCondition
CMNatalimeterSetUserPal
CMNatalimeterSetUserHrmin
CMNatalimeterSetUserHronset
CMNatalimeterSetUserVo2max
CMNatalimeterSetUserVo2maxReset
CMNatalimeterSetUserHrminReset
CMNatalimeterSetUserRunVo2max
CMNatalimeterSetUserOnsetVo2max
CMOdometerDataObject
CMOdometerGpsAvailability
CMOnBodyStatusData
CMSedentaryTimerIsArmed
CMSedentaryTimerStartTime
CMSedentaryTimerPeriodInterval
CMSedentaryTimerReminderInterval
CMSedentaryTimerAutoReschedule
CMSedentaryTimerAlarmData
CMSedentaryTimerErrorMessage
CMMotionActivityStartTime
CMMotionActivityStopTime
CMMotionActivityData
CMMotionActivityDataArray
CMActivityData
CMOverrideSidebandOverride
CMStateSidebandState
CMOverrideResult
CMSidebandSensorFusionEnable
CMSidebandSensorFusionLatency
CMSidebandSensorFusionSnoop
CMSidebandSensorFusionSuccess
CMMotionStateSim
CMMotionStateSimState
CMMotionStateSimResult
CMVehicleConnectionStartTime
CMVehicleConnectionEndTime
CMVehicleStateDeviceId
CMDeviceHasOriginalBackCamera
CMCameraVcmActuatorId
CMCompassCalibrationData
CMMotionStateUpdateType
CMMotionStateUpdateData
CMExerciseMinuteRecordId
CMExerciseMinuteStartDate
CMExerciseMinuteSourceId
CMExerciseMinuteDataArray
CMWorkoutAttributes
CMWorkoutEventDate
CMWorkoutTimeout
CMSwimKeyDataRecord
CMSwimKeyDataArray
CMSignificantElevationKeyQueryTimeRange
CMSignificantElevationKeySample
CMCaptureModeData
CMFallSetStatsEnabled
CMFallSetStatsNumberOfAvailableFiles
CMFallSetStatsNameOfCurrentFile
CMFallSetStatsSizeOfCurrentFile
CMFallStatsMode
CMFallStatsWakeAP
CMFunctionalCapacityKeyDataRecord
CMFunctionalCapacityKeyDataArray
CMSpringKeyDataRecord
CMSpringKeyDataArray
CMFitnessMachineDataRecord
CMDatabaseType
CMExtensions
CMFileSize
CMMotionAlarmKey
void CLThreshold::init(const float &, const float &, const float &, const unsigned int, const unsigned int, const unsigned int, const float &, const bool)
CoreLocation: sample rate (%.3f) observation rate (%.3f) observation threshold (%.3f) deviation count threshold (%d) standard deviation threshold (%.3f)
bool CLThreshold::update(const float &)
CoreLocation: threshold (%f) was exceeded with observed value (%f) and base value (%f) and standard deviation (%f) and count of (%d)
CLCompassAccuracy::CLCompassAccuracy(const float, const float, const size_t, const size_t, const bool)
CoreLocation: mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd), coverAttached (%d)
void CLCompassAccuracy::init(const float, const float, const size_t, const size_t)
CoreLocation: mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd)
void CLGyroCalibrationCache::removeOutliers()
CoreLocation: Begin.
CoreLocation: Too few points.  End.
CoreLocation: temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,1
CoreLocation: temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,0
CoreLocation: End.
reset
/BuildRoot/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.0.sdk/usr/local/include/boost/smart_ptr/scoped_ptr.hpp
p == 0 || p != px
CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, bool, bool)
CoreLocation: using attitude dependent KF calibrator
CompassIgnoreDatabase
CoreLocation: compass ignoring database (%d)
CompassManualCalibration
CompassOffsetManualX
CompassOffsetManualY
CompassOffsetManualZ
CoreLocation: compass using manual bias (%.3f/%.3f/%.3f)
CompassIgnoreCalibration
CoreLocation: compass ignoring calibration (%d)
CompassInputFilter
CoreLocation: compass input filter is using (%zuu) samples
CompassOutputFilterSize
CompassOutputFilterScale
CoreLocation: compass heading output filter samples (%d) scale (%f)
CoreLocation: apple compass calculator, sample rate (%.3f) ignoreDatabase (%d) manual (%d)
bool CLCompassCalculator::feedMagnetometerData(const CLMotionTypeMagneticField &)
CoreLocation: XYDevice not stable. %d, %d, %.3f, Clearing search buffers.
CoreLocation: storing new compass calibration, magneticField (%+.3f,%+.3f,%+.3f), bias (%+.3f/%+.3f/%+.3f), level (%d) magnitude (%+.3f) inclination (%+.3f)
bool CLCompassCalculator::getCompassData(CLMotionTypeCompass &)
CoreLocation: rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f
CoreLocation: #Warning Heading  %.2f, is not in bound [0 360]
void CLCompassCalculator::updateInterferenceChecks()
CoreLocation: magnitude max threshold exceeded (%+.3f), resetting calibration
CoreLocation: magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
CoreLocation: inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
void CLCompassCalculator::feedCompassDatabaseNotificationWithData(int, const CLCompassDatabase_Type::Notification &, const CLCompassDatabase_Type::NotificationData &)
CoreLocation: CompassDB restored bias (%+.3f/%+.3f/%+.3f)
CLCompassDatabaseSilo
valid
__null != self.notifier
kCLMotionTypeGeomagneticModelDataXKey
kCLMotionTypeGeomagneticModelDataYKey
kCLMotionTypeGeomagneticModelDataZKey
kCLMotionTypeGeomagneticModelDataMagnitudeKey
kCLMotionTypeGeomagneticModelDataHorizontalKey
kCLMotionTypeGeomagneticModelDataDeclinationKey
kCLMotionTypeGeomagneticModelDataInclinationKey
kCLMotionTypeGeomagneticModelDataTimestampKey
kCLBiasXKey
kCLBiasYKey
kCLBiasZKey
kCLVarianceXKey
kCLVarianceYKey
kCLVarianceZKey
KCLDoingBiasEstimationKey
class
<%@: %p>
v32@?0@"NSObject"8@"NSObject"16^B24
code
domain
Attempt to write value multiple times
nullptr key not allowed
Infinity
-Infinity
void CLOnBodyNotifier_Type::Params::log() const
CoreLocation: Parameters: theta0, %f, theta1, %f, theta2, %f, theta3, %f, theta4, %f, theta5, %f, minLowPower, %f, maxLowPower, %f, maxHighPower, %f, lowBandStart, %d, lowBandStop, %d, highbandStart, %d, highBandStop, %d, wakeThreshold, %f, oddsThreshold, %f, medianFilterSize, %u, confidenceThreshold, %f, useHysteresis, %d, useAngleOverride, %d, angleMetricThreshold, %f
static CLOnBodyNotifier_Type::Params CLOnBodyNotifier_Type::Params::getParams(NSDictionary *, NSString *)
CoreLocation: Using the manufacturer specific parameters (%s): %s
CoreLocation: Using the default parameters: %s
CoreLocation: #Warning Using the hardcoded parameters
static bool CLOnBodyNotifier_Type::Params::isValid(NSDictionary *)
CoreLocation: Invalid parameters received:
%{public}s
virtual bool CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)
CoreLocation: fLocationdConnection is not NULL
com.apple.CoreMotion.CLGeomagneticModelProviderClientPrivateQueue
kCLConnectionMessageGmm
virtual bool CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)_block_invoke
CoreLocation: Could not get geomagnetic model data for message!
virtual bool CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)_block_invoke_3
virtual bool CLGeomagneticModelProviderClient::unregisterForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)
CoreLocation: fLocationdConnection is NULL
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLNotifierData *) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
kCMOdometerDataCodingKeyStartDate
kCMOdometerDataCodingKeyEndDate
kCMOdometerDataCodingKeyDistance
kCMOdometerDataCodingKeyCurrentSpeed
kCMOdometerDataCodingKeyAverageSpeed
%@,<startDate %@, endDate %@, distance %@, currentSpeed %@, averageSpeed %@>
T@"NSDate",R,N,V_startDate
T@"NSDate",R,N,V_endDate
distance
T@"NSNumber",R,N,V_distance
currentSpeed
T@"NSNumber",R,N,V_currentSpeed
T@"NSNumber",R,N,V_averageSpeed
CLGeomagneticModelProviderSilo
CLGeomagneticModelProvider
write_escaped_str
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Shared/Logging/CLJsonLogging.cpp
next.first[0] == '\0'
nullptr != escapedControlChar(next.first[0])
/System/Library/PrivateFrameworks/CompassUI.framework/CompassUI
void CLClientLoadCompassUIIfNecessary(void)
CoreLocation: Unable to load CompassUI framework
CUICalibration
CoreLocation: Could not load CUICalibrationClass from CompassUI framework
STATUS,SENSOR,Time,%.3lf,Type,AccelOscarEmu,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,AccelGesture,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,GyroOscarEmu,x,%20.20f,y,%20.20f,z,%20.20f,sampleNum,%d,fsync,%d,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,Accelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
AccelGps,Time,%.4lf,timestamp,%.4f,x,%.12g,y,%.12g,z,%.12g
AccelBatch,Time,%.4lf,timestamp,%.4f,batch,%d,x,%.12g,y,%.12g,z,%.12g
STATUS,SENSOR,Time,%.3lf,Type,Gyro,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d
GyroGps,Time,%.4lf,timestamp,%.4f,x,%.12g,y,%.12g,z,%.12g
STATUS,SENSOR,Time,%.3lf,Type,GyroTemperature,temperature,%f
STATUS,SENSOR,Time,%.3lf,Type,GyroBias,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
STATUS,SENSOR,Time,%.3lf,Type,GyroBiasFit,slope.x,%20.20f,slope.y,%20.20f,slope.z,%20.20f,intercept.x,%20.20f,intercept.y,%20.20f,intercept.z,%20.20f, lastMiniCal,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,GyroDt,dt,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,Magnetometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,Compass,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,CompassAlignment,compassJustAlignedToStableField,%d,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,DeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,heading,%.3f,trueheading,%.3f,accuracy,%.3f,mode,%d,clientID,%#02x,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,initalized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,cachedCompassCalibration,%d,cachedGyroCalibration,%d,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,MotionStateUpdate,motionStateUpdate:Motion,%d,conf,%d,Mounted,%d,MountedConf,%d,exitState,%d,turn,%d,isVehicular,%d,isMoving,%d,seq,%d,startTime,%f,timestamp,%f,startTimeUL,%llu,nowUL,%llu -- caltype,%d,vm,%f,standing,%d,machinefrequency,%f,strokefrequency,%f,strokeAmplitude,%f,strokepower,%f
STATUS,SENSOR,Time,%.3lf,Type,Pressure,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,PressureGps,pressure,%.6f,temperature,%.6f,timestamp,%.6lf
STATUS,SENSOR,Time,%.3lf,Type,PressureOscarEmu,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,PressureFiltered,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,Prox,DetectionMask,%d,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,TouchOscarEmu,touchDetected,%d,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,GyroCompass,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,calibrated.x,%.8f,.y,%.8f,.z,%.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1f,courseMode,%d,level,%d,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,CompassCalibration,bias.x,%.8f,.y,%.8f,.z,%.8f,scale.x,%.8f,.y,%.8f,.z,%.8f,quality,%.8f,cost,%.8f,coverage,%.8f,earthDiffRatio,%.8f,pose.x,%.8f,.y,%.8f,.z,%.8f,level,%d,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,BTConnection,startTime,%.3lf,endTime,%.3lf,connected,%d
STATUS,SENSOR,Time,%.3lf,Type,SessionOverride,sessionType,%d,timestamp,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,LocationOscarEmu,locationType,%d,speed,%.3lf,speedAccuracy,%.3lf,latitude,%.7lf,longitude,%.7lf,horizontalAccuracy,%.3lf,altitude,%.3lf,verticalAccuracy,%.3lf,course,%.3lf,courseAccuracy,%.3lf,confidence,%d,locationLoggingEnabled,%d,timestamp,%.3lf
MenuButton
PowerButton
ChargerConnect
DeviceAwake
InActiveCall
DisplayOn
LockscreenOn
PocketQuery
WakePower
WakeMenu
WLAN
Baseband
Sleep
STATUS,SENSOR,Time,%.lf,Type,GestureHint,event,%d,eventDescription,%s,value,%d,valueDescription,%s
STATUS,SENSOR,Time,%.lf,Type,GestureHint,event,%d,eventDescription,%s,value,%d
STATUS,SENSOR,Time,%.3lf,Type,CLDeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,timestamp,%20.20f,doingBiasEstimation,%d,doingYawCorrection,%d,type,%d
fits,
slope.x,%f,slope.y,%f,slope.z,%f,intercept.x,%f,intercept.y,%f,intercept.z,%f,
temperatures,%f,%f,%f,%f,%f,%f,%f,overlap,%f,error,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d
STATUS,SENSOR,Time,%.3lf,Type,CLNonlinearGyroBiasFit,fits,%s
STATUS,SENSOR,Time,%.3lf,Type,NatalieData,startTime,%.3lf,activityType,%u,isStanding,%d,fractionalGrade,%f,gradeType,%u,rawGradeType,%u,metSource,%u,hrmin,%f,mets,%f,duration,%.3lf,fGpsAvailability,%d
STATUS,SENSOR,Time,%.3lf,Type,BodyMetrics,gender,%u,heightM,%f,weightKG,%f,vo2max,%f,age,%f,hrmin,%f,hrmax,%f,hronset,%f,pal,%f,condition,%u,runVo2max,%f
STATUS,SENSOR,Time,%.3lf,Type,WorkoutEvent,workoutType,%u,eventType,%u,eventTime,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,OnsetHeartRateData,dataSource,%u,interpolation,%u,HeartRate,%f,confidence,%f,error,%d,timestamp,%.3lf,startTime,%.3lf,sinceLastGood,%.3lf,mode,%u
STATUS,SENSOR,Time,%.3lf,Type,StreamingHeartRateData,dataSource,%u,interpolation,%u,HeartRate,%f,confidence,%f,error,%d,timestamp,%.3lf,startTime,%.3lf,sinceLastGood,%.3lf,mode,%u
STATUS,SENSOR,Time,%.3lf,Type,ElevationChange,timestamp,%.3lf,startTime,%.3lf,elevationAscended,%u,elevationDescended,%d,source,%u
STATUS,SENSOR,Time,%.3lf,Type,CoarseElevationChange,startTime,%.3lf,elevationAscended,%u
STATUS,SENSOR,Time,%.3lf,Type,MotionGPSLocation,timestamp,%.3lf,latitude,%+.10f,longitude,%+.10f,speed,%.3lf,speedAccuracy,%.3lf,horizontalAccuracy,%.3lf,course,%.3lf,courseAccuracy,%.3lf,altitude,%.3lf,verticalAccuracy,%.3lf,type,%d,timestampGPS,%.3lf,undulation,%.3lf,undulationModel,%d,horzUncSemiMaj,%.3lf,horzUncSemiMin,%.3lf,horzUncSemiMajAz,%.3lf,odometer,%.3lf,deltaDistance,%.3lf,deltaDistanceAccuracy,%.3lf,originDevice,%d
STATUS,SENSOR,Time,%.3lf,Type,Odometer,startTime,%.3lf,accuracy,%.3lf,distance,%.3lf,gpsAltitude,%.3lf,speed,%.3lf,rawSpeed,%.3lf,odometer,%.3lf,gpsSpeedAccuracy,%.3lf,timestampGPS,%.3lf,origin,%d,quality,%d
STATUS,SENSOR,Time,%.3lf,Type,MotionWifiLocation,timestamp,%.3lf,latitude,%+.10f,longitude,%+.10f,speed,%.3lf,speedAccuracy,%.3lf,horizontalAccuracy,%.3lf,course,%.3lf,courseAccuracy,%.3lf,altitude,%.3lf,verticalAccuracy,%.3lf,type,%d,timestampGPS,%.3lf,undulation,%.3lf,undulationModel,%d,horzUncSemiMaj,%.3lf,horzUncSemiMin,%.3lf,horzUncSemiMajAz,%.3lf,odometer,%.3lf,deltaDistance,%.3lf,deltaDistanceAccuracy,%.3lf,originDevice,%d
STATUS,SENSOR,Time,%.3lf,Type,StrideCalBin,bin,%d,begin,%.3lf,end,%.3lf,state,%d,kValue,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,CaloriemetryPauseEvent,pause,%d
STATUS,SENSOR,Time,%.3lf,Type,MetsInfo,mets,%f,metsHR,%f,metsWR,%f,source,%u,metsDiff,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f
STATUS,SENSOR,Time,%.3lf,Type,BasebandSpeed,timestamp,%f,speedThreshold,0x%02hhx,speedRange,0x%02hhx,scaledValue,0x%02x,reserved,0x%02x,speedThresholdStr,%s,speedRangeStr,%s
STATUS,SENSOR,Time,%.3lf,Type,VibrationEvent,isDeviceVibrating,%d
STATUS,SENSOR,Time,%.3lf,Type,StepCadenceToStrideLengthBin,bin,%d,begin,%.3lf,end,%.3lf,state,%d,strideLength,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,WatchOrientationSettings,wrist,%d,crown,%d
STATUS,SENSOR,Time,%.3lf,Type,MotionWifiAssociation,isWifiAssociated,%d
STATUS,SENSOR,Time,%.3lf,Type,MotionLoiData,longitude,%f,latitude,%f,departureDate,%.3lf,arrivalDate,%.3lf,horizontalAccuracy,%.3lf,confidence,%d
STATUS,SENSOR,Time,%.3lf,Type,OdometerWithAltitude,startTime,%.3lf,accuracy,%.3lf,distance,%.3lf,gpsAltitude,%.3lf,speed,%.3lf,rawSpeed,%.3lf,odometer,%.3lf,gpsSpeedAccuracy,%.3lf,timestampGPS,%.3lf,origin,%d,quality,%d,groundAltitude,%.3lf,groundAltitudeUncertainty,%.3lf,smoothedGPSAltitude,%.3lf,smoothedGPSAltitudeUncertainty,%.3lf
Below 30mph
Above 30mph
Undefined
0 to 15mph
15 to 30mph
30 to 45mph
45 to 60mph
Above 60mph
com.apple.CoreMotion.CMFitnessMachine
-[CMFitnessMachineInternal init]_block_invoke
-[CMFitnessMachineInternal init]_block_invoke_2
CoreLocation: CMFitnessMachine client connection interrupt, %@, %d, %p
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMFitnessMachine.mm
fitnessMachineData
kCLConnectionMessageFitnessMachineData
-[CMFitnessMachineInternal _feedFitnessMachineData:]_block_invoke_2
CoreLocation: Error feeding fitness machine data
CoreLocation: Error feeding fitness machine data, %@
T@"CMFitnessMachineInternal",R,N,V_internal
CMCallHandednessService
virtual void CMCallHandednessService::numberOfSpectatorsChanged(int, size_t)
CoreLocation: CMCallHandednessService Spectators, %zd
CoreLocation: CMCallHandednessService stopped, %zd
CoreLocation: CMCallHandednessService started, %zd
CoreLocation: CMCallHandednessService expects only 1 client
void CMCallHandednessService::startDetection()
CoreLocation: #Warning No accelerometer; not starting CMCallHandedness detection!
CoreLocation: Starting CallHandedness detection with accelFrequency %.1f
static void CMCallHandednessService::onAccelerometerData(const CLAccelerometer::Sample *, void *)
CoreLocation: Sending CMCallHandedness notification.
CLCoverState
dataIdentifier
offset
dataSize
dataType
movement
%@,<identifier, %llu, startTime, %f, timestamp, %llu, dataIdentifier, %llu, offset, %u, dataSize, %u, dataType, %d, movement, %d>
TQ,V_identifier
Td,V_startTime
TQ,V_timestamp
TQ,V_dataIdentifier
TI,V_offset
TI,V_dataSize
Ti,V_dataType
TB,V_movement
Td,V_endTime
metaIdentifier
TQ,V_metaIdentifier
duration
Td,V_duration
rate
TI,V_rate
CLMagnetometerCoexistenceNotifier
EnableMagnetometerCoexistenceCompensation
kCLConnectionMessageCompassCalibrationData
static void CLMagnetometerCoexistenceNotifier::create()
CoreLocation: #Warning CPAS data response was invaild.
CoreLocation: #Warning CPAS data is NULL
CoreLocation: cpas version is %u, length is %ld bytes
CoreLocation: Warning: cpas data was found but did not match any versions. version (%u) length (%ld)
CoreLocation: Magnetometer coexistence compensation is disabled
void CMNonlinearTemperatureFit::feedGyroTemperature(float)
CoreLocation: Assertion failed: temperature != 3.40282347e+38F, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMNonlinearTemperatureFit.cpp, line 79,temperature,%f.
virtual void CLSensorFusionServiceFastPath::start()
CoreLocation: Unable to establish fast path with valid clientID,serviceRef,%p,properties,%@
CoreLocation: Fast path has been initialized,clientID,%u,serviceRef,%p,useMag,%d,mode,%d,interval,%f
virtual void CLSensorFusionServiceFastPath::stop()
CoreLocation: Fast path is being closed,clientID,%u,serviceRef,%p,useMag,%d,mode,%d,interval,%f
static bool CLSensorFusionServiceFastPath::populateDeviceMotion(IOHIDEventRef, uint32_t, CLSensorFusionService::Sample &)
CoreLocation: Event ref invalid
CoreLocation: Unexpected device motion report type %d, returning
virtual void CLSensorFusionServiceFastPath::applicationStateChanged(bool)
CoreLocation: Application state changed, %d
LogCompass
CLCompass
CompassForceCoverAttach
Forcing
NOT forcing
CLCompass::CLCompass()
CoreLocation: %s cover attached logic to %d
CoreLocation: Registered for cover state notifications
virtual CFTimeInterval CLCompass::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Could not create timer
void CLCompass::startCompass()
CoreLocation: Cover %s attached
RequiresCompassResetOnConnect
open
closed
static void CLCompass::onCoverState(const bool *, void *)
CoreLocation: Cover %s
connected
disconnected
void CLCompass::updateKeyboardState(bool, bool)
CoreLocation: Keyboard %s
CLProximityNotifier
kCMMotionActivityCodingKeyType
kCMMotionActivityCodingKeyConfidence
kCMMotionActivityCodingKeyStartTime
kCMMotionActivityCodingKeyVehicleConnected
kCMMotionActivityCodingKeyVehicularGpsHint
kCMMotionActivityCodingKeyVehicularBasebandHint
kCMMotionActivityCodingKeyVehicularWifiHint
kCMMotionActivityCodingKeyVehicularMotionHint
kCMMotionActivityCodingKeyVehicularBTHint
%@ @ %f,<startDate,%@,confidence,%ld,unknown,%d,stationary,%d,walking,%d,running,%d,automotive,%d,cycling,%d>
vehicleConnected
TB,R,N,GisVehicleConnected
vehicleWifiHint
TB,R,N,GisVehicleWifiHint
vehicleGpsHint
TB,R,N,GisVehicleGpsHint
vehicleBasebandHint
TB,R,N,GisVehicleBasebandHint
vehicleMotionHint
TB,R,N,GisVehicleMotionHint
vehicleBTHint
TB,R,N,GisVehicleBTHint
stationary
automotive
void CLMagnetometerCoexistenceNotifierCpasV5::initializeCalibrationParamaters(const UInt8 *, int)
CoreLocation: Device still has original rear camera. Using unit-specific calibration info
CoreLocation: Rear camera was replaced. VCM actuator ID is %d
CoreLocation: Using generic Mitsumi calibration info
CoreLocation: Using generic Alps calibration info
CoreLocation: Unrecongized VCM actuator. Not performing compensation
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMPickupManager.mm
Pickup Detection is not supported on this platform. Use isPickupAvailable to avoid this error.
com.apple.CoreMotion.CMPickupDetectorPrivateQueue
-[CMPickupManager startPickupUpdates]_block_invoke
CoreLocation: Started pickup detection updates
CoreLocation: Pickup detection already started!
-[CMPickupManager stopPickupUpdates]_block_invoke
CoreLocation: Stopped pickup detection updates
CoreLocation: Pickup detection service already stopped!
-[CMPickupManager onPickupStateUpdated:]_block_invoke
CoreLocation: Pickup Detection: %{public}ld
T@"<CMPickupDelegate>",N,V_delegate
void CLMagnetometerCoexistenceNotifierCpasV6::initializeCalibrationParamaters(const UInt8 *, int)
kCMPedometerDataCodingKeyStartDate
kCMPedometerDataCodingKeyEndDate
kCMPedometerDataCodingKeyNumberOfSteps
kCMPedometerDataCodingKeyDistance
kCMPedometerDataCodingKeyFloorAscended
kCMPedometerDataCodingKeyFloorDescended
kCMPedometerDataCodingKeyRecordId
kCMPedometerDataCodingKeyPace
kCMPedometerDataCodingKeyCurrentCadence
kCMPedometerDataCodingKeyActiveTime
kCMPedometerDatacodingKeyUUID
kCMPedometerDataCodingKeyIsOdometerDistance
kCMPedometerDataCodingKeyIsOdometerPace
kCMPedometerDataCodingKeyNumberOfPushes
kCMPedometerDataCodingKeyWorkoutType
%@,<startDate %@ endDate %@ steps %@ distance %@ floorsAscended %@ floorsDescended %@ currentPace %@ currentCadence %@ averageActivePace %@>
numberOfPushes
workoutType
numberOfSteps
floorsAscended
floorsDescended
currentPace
currentCadence
averageActivePace
kCMPedometerEventKeyEventDate
kCMPedometerEventKeyEventType
Pause
Resume
%@,<eventDate, %@, eventType, %@>
date
T@"NSDate",R,N,VfDate
Tq,R,N,VfType
ReadyToFire
Pending0
Pending1
Pending2
Pending3
Pending4
Pending5
Pending6
Pending7
Pending8
Pending9
Expired
StateMax
void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CLMagnetometerCoexistenceNotifierCpasCamera::CameraCoexistenceInfo &)
CoreLocation: VCM Delta.x,%f,VCM Delta.y,%f,VCM Delta.z,%f
CoreLocation: Rear camera offset.x,%f,Rear camera offset.y,%f,Rear camera offset.z,%f
kCLConnectionMessageDeviceHasOriginalCamera
kCLConnectionMessageCameraVcmActuatorId
com.apple.isp.focusing
void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()
CoreLocation: Could not register for notification %s
com.apple.isp.backcamerapower
com.apple.isp.backcamerasensorconfig
void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()
CoreLocation: Could not get state for %s
CoreLocation: focus position = %d
void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()
CoreLocation: camera state = %d
void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()
CoreLocation: camera mode = %d
void CLMagnetometerCoexistenceNotifierCpasCamera::onFocusingNotification()
CoreLocation: Received focusing notification
void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraStateNotification()
CoreLocation: Received camera state notification
void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraModeNotification()
CoreLocation: Received camera mode notification
void CLMagnetometerCoexistenceNotifierCpasV10::chooseOffsetData()
CoreLocation: Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d
com.apple.CoreMotion.CLPressureBiasProxy
kCLConnectionMessagePressureBias
void CLPressureBiasProxy::start()_block_invoke_2
CoreLocation: Bad pressure bias from daemon.
receiver.fGotFit
std::is_sorted(samples.begin(), samples.end())
n <= 65
buffer.capacity() == std::max<size_t>(1, n * (n - 1))
subfitCount <= Fit::kFitSegments - 2
kCMDeviceOrientationCodingKeyOrientation
%@ orientation %d name %@ @ %f
orientation
CMSetDeviceOrientationNotification
CMSetDeviceOrientationTypeKey
CMPersistOrientationCallbackModeKey
+[CMDeviceOrientationManager initialize]
CoreLocation: Orientation Manager initialized
com.apple.backboardd.loggingchanged
OrientationCallbackMode
EnableOrientationNotification
-[CMDeviceOrientationManager onMotionPreferencesUpdated]
CoreLocation: OrientationCallbackMode,%{public}d,EnableOrientationNotification,%{public}d
-[CMDeviceOrientationManager onNotification:]_block_invoke
CoreLocation: The orientation %{public}d is not in bounds
-[CMDeviceOrientationManager startDeviceOrientationUpdatesToQueue:withHandler:]
CoreLocation: Starting orientation updates
-[CMDeviceOrientationManager stopDeviceOrientationUpdates]
CoreLocation: Stopping orientation updates
-[CMDeviceOrientationManager onDeviceOrientation:]
CoreLocation: Notifications disabled
CoreLocation: Received orientation. (%{public}@ to %{public}@) Timestamp %{public}f
CoreLocation: Updating client handler: Orientation %{public}@, Callback mode: %{public}d
-[CMDeviceOrientationManager deviceOrientationBlocking]
CoreLocation: Received deviceOrientationBlocking
%@.%@Time
com.apple.CoreMotion.DeviceOrientation
CLBundleKeyValueCache
CLSystemService
CLHarvestableSystemService
CLIsFindMyiPhone
CLIsCoreRoutine
CLEmergencyService
CLRequiredCapabilities
LogDeviceMotion
GyroOnly
6Axis
9Axis
9AxisWithNorthReference
BuildGYTT
3AxisDynamicGyro
6AxisThrottledGyro
CLDeviceMotionProperties<DeviceMotion=%@>
Ti,N,VfMode
CLDeviceMotion
static CLDeviceMotion::CLDeviceMotionNotification CLDeviceMotion::CLMotionTypeDeviceMotionModeToCLDeviceMotionNotification(const CLMotionTypeDeviceMotionMode)
CoreLocation: No viable convertion for mode 0x%x
static CLMotionTypeDeviceMotionMode CLDeviceMotion::CLDeviceMotionNotificationToCLMotionTypeDeviceMotionMode(const int)
CoreLocation: No viable convertion for notification 0x%x
properties != nullptr
void CLDeviceMotion::setDeviceMotionUpdateInterval(CLDeviceMotion::Dispatcher *, CFTimeInterval)_block_invoke
CoreLocation: CLDeviceMotion::setDeviceMotionUpdateInterval changing update interval to: %f
void CLDeviceMotion::addDeviceMotionDispatcher(CLDeviceMotion::Dispatcher *, CFTimeInterval)_block_invoke
CoreLocation: CLDeviceMotion::addDeviceMotionDispatcher adding dispatcher with property: %s
void CLDeviceMotion::removeDeviceMotionDispatcher(CLDeviceMotion::Dispatcher *)_block_invoke
CoreLocation: CLDeviceMotion::removeDeviceMotionDispatcher removing dispatcher with property: %s
virtual CFTimeInterval CLDeviceMotion::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: CLDeviceMotion::minimumUpdateIntervalChanged,notification,%d,minimumUpdateInterval,%f
virtual void CLDeviceMotion::numberOfClientsChanged(int, size_t, size_t)
CoreLocation: CLDeviceMotion::numberOfClientsChanged notification:%d, from:%zu, to:%zu
CoreLocation: numberOfClients GyroOnly:%zd, 3AxisDynamicGyro:%zd, 6Axis:%zd, 6AxisThrottledGyro:%zd, 9Axis:%zd, 9AxisWithNorthReference:%zd, BuildGYTT:%zd
fSensorFusionService9Axis->isRunning()
CoreLocation: Device motion mode (%d) not supported, can't process client change
bool CLDeviceMotion::isModeValid(const CLMotionTypeDeviceMotionMode &) const
CoreLocation: Unsupported mode (%d). Returning.
CoreLocation: Unsupported mode (%d). Compass not found. Returning.
CoreLocation: Unsupported mode (%d). Couldn't do DeviceMotion without Gyro. Returning.
void CLDeviceMotion::enableSensorFusionWithMode(const CLMotionTypeDeviceMotionMode &)
CoreLocation: Starting device motion, mode=0x%{public}x,useAccelerometer=%{public}d,useGyro=%{public}d,useCompass=%{public}d,fUseNorthRef=%{public}d,buildingGYTT=%{public}d
void CLDeviceMotion::disableSensorFusionWithMode(const CLMotionTypeDeviceMotionMode &)
CoreLocation: Stopping device motion, mode=0x%x
CoreLocation: Device motion mode (%d) not supported, unable to disable sensor fusion
void CLDeviceMotion::getLastSample(const CLMotionTypeDeviceMotionMode, CLDeviceMotion::Sample &)
CoreLocation: Device motion mode (%d) not supported, unable to get device motion
BinaryLogDirectory
static void CLBinaryLog::create()
CoreLocation: creating the BinaryLog instance
CoreLocation: creating fInstance = new CLBinaryLog()
CLBinaryLog::CLBinaryLog()
CoreLocation: kCLBinaryLogDirectory not set!
CoreLocation: #Notice Logging binary sensor data to %{public}s
com.apple.locationd.binlog.compression
void CLBinaryLog::rotateIfNeeded(const double &)
CoreLocation: Failed to determine if log rotation is needed. errno, %{public}d, %{public}s
CoreLocation: #Warning Failed to move aside log file %s to %s (%d)
%s,%s,Failed to delete log: %s
void CLBinaryLog::open()
CoreLocation: #Warning Unable to open %s
LogFileRotationSizeBinary
LogFileStorageCountBinary
%s,%s,Failed to write CLBinaryLog Buffer to disk
%s,%s,Failed to move file %s to %s (%d)
.bin
CoreMotionSensors
logs
CMSetPocketStateNotification
CMSetPocketStateTypeKey
com.apple.CoreMotion.CMPocketStatePrivateQueue
+[CMPocketStateManager isPocketStateAvailable]
CoreLocation: Pocket state disabled by defaults write
-[CMPocketStateManager _disableDispatcher]
CoreLocation: disabling dispatcher
com.apple.CoreMotion.CMPocketStateManager.%@.%@
-[CMPocketStateManager addToAggdScalarWithName:andScalar:]_block_invoke
CoreLocation: ADClient: %s + %llu
-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]
CoreLocation: QueryRequest,%f
com.apple.CoreMotion.PocketState.queryStart
-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke
CoreLocation: %f: query started with timeout %f
queryStart
CoreLocation: Query aborted
queryAbort
-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke_2
CoreLocation: QueryTimerFire,%f
queryTimerFire
queryResponse.%@
CoreLocation: %f: query response external=%u (%s), cbcount=%lu
CoreLocation: timer fired even though fQueryTimer is NULL
CoreLocation: Attempted to exceed max monitor time %f, %f
CoreLocation: Query timer failed to initialize
queryTimerFail
-[CMPocketStateManager onNotification:]_block_invoke
CoreLocation: The pocket state %d is not in bounds
T@"<CMPocketStateDelegate>",N,V_delegate
kCMLiftMotionCodingKeyLiftDate
kCMLiftMotionCodingKeyLiftTransition
%@,<liftTransition %lu date %@>
liftTransition
double CLDistanceCalc::calculateDistance(const CLDaemonLocation &, const CLDaemonLocation &)
CoreLocation: #Warning refAlt < %.1lf,refAlt,%.1lf,using the min
CoreLocation: #Warning refAlt > %.1lf,refAlt,%.1lf,using the max
bool CLDistanceCalc::calc_dNdE(double, double, double &, double &)
CoreLocation: latitude,%.7lf,is out of bounds
double CLDistanceCalc::calculateAzimuth(double, double, double, double)
CoreLocation: #Warning, same coordinates input
kCMSpringDataCodingKeyRecordId
kCMSpringDataCodingKeySourceId
kCMSpringDataCodingKeySessionId
kCMSpringDataCodingKeyEventTime
kCMSpringDataCodingKeyEventType
OutOfBid
%@, <eventTime, %@, eventType, %@>
eventTime
eventType
LogDeviceOrientation
CLOrientationNotifier
SBHasSeenACaseLatchCoverOnce
com.apple.springboard.HasSeenACaseLatchCoverNotification
CLOrientationNotifier::CLOrientationNotifier()
CoreLocation: Registering for SBHasSeenACaseLatchCoverNotification.
virtual void CLOrientationNotifier::numberOfSpectatorsChanged(int, size_t)
void CLOrientationNotifier::startDetection(bool)
CoreLocation: hwType, %{public}d
CoreLocation: Unknown iPad HW %{public}d
CoreLocation: isPad %{public}d
CoreLocation: forceAccelOnly for device %{public}d
OrientationGyroTimeout
OrientationStableVariance
CoreLocation: fOrientationGyroTimeout,%{public}f,fEnableGyroTimeout,%{public}d,fMaxAccelerationVarianceForStability,%{public}f
OrientationAccelDecimation
CoreLocation: Not starting orientation detection since requested accelerometer frequency < 0
CoreLocation: No accelerometer; not detecting orientation!
CoreLocation: No gyro; not detecting orientation!
CoreLocation: fHasSeenACaseLatchCoverOnce, %{public}d
CoreLocation: Starting orientation detection with accelFrequency %{public}f, isIpad, %{public}d, decimationRate, %{public}d
void CLOrientationNotifier::stopDetection()
CoreLocation: Stopping orientation detection.
static void CLOrientationNotifier::onAccelerometerData(const CLAccelerometer::Sample *, void *)
CoreLocation: Sending orientation changed notification
CoreLocation: Device is in motion, re-enabling Gyro.
CoreLocation: Device is stationary and OrientationGyroTimeout exceeded, disabling Gyro.
static void CLOrientationNotifier::onGyroData(const CLGyro::Sample *, void *)
CoreLocation: GYRO: Sending orientation changed notification
void CLOrientationNotifier::onNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
void CMCallHandednessDetector::detect(double)
CoreLocation: Invalid dynamics, mag, %.2f, xyVarMax, %.2f, xMean, %.2f
CoreLocation: Invalid xyNorm, %.2f
CoreLocation: Invalid tilt, %.2f
CoreLocation: Invalid swivel, %.2f
CoreLocation: Swing1. xMag, %.2f, maxXYVar, %.2f, swingX, %.2f
CoreLocation: Swing2. X sign flipping.
CoreLocation: Passed swing-detect. hand, %d, xMag, %.2f, maxXYVar, %.3f, swingX, %.3f
const Element CMVectorBufferBase<float, 3>::mean(size_t, size_t) const [T = float, N = 3]
CoreLocation: Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 96,mean() on empty buffer.
const T &CMQueue<CMVector<float, 3> >::operator[](const size_t) const [T = CMVector<float, 3>]
CoreLocation: Assertion failed: i < fCapacity, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMQueue.h, line 174,i,%zu,capacity,%u.
const Element CMVectorBufferBase<float, 3>::variance(size_t, size_t) const [T = float, N = 3]
CoreLocation: Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 213,variance() on empty buffer.
Element CMVectorBufferBase<float, 3>::back() const [T = float, N = 3]
CoreLocation: Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 148,back() on empty buffer.
Element CMVectorBufferBase<float, 3>::front() const [T = float, N = 3]
CoreLocation: Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 142,front() on empty buffer.
kCLConnectionMessageFallStatsAvailable
kCLConnectionMessageFallStatsSetEnabled
-[CMFall setStatsEnabled:]
CoreLocation: #Notice Response invalid.
-[CMFall setStatsEnabled:onCompletion:]_block_invoke
kCLConnectionMessageFallStatsSendStats
virtual void CLCompass7Base::start(bool)
CoreLocation: Compass for AOP started. CoverAttached %d
virtual void CLCompass7Base::stop()
CoreLocation: Compass for AOP stopped.
virtual CFTimeInterval CLCompass7Base::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting compass update interval to %f
CoreLocation: Unable to set compass update interval
static void CLCompass7Base::onDeviceMotionServiceIohidEvent(void *, void *, void *, IOHIDEventRef)
GyroCompass
CLMotionTypeCompass CLCompass7Base::populateMotionType(const CMDeviceMotionReport::Compass &, const CFTimeInterval &)
CoreLocation: Type,%s,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,calibrated.x,%.8f,.y,%.8f,.z,%.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1f,level,%d,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,initalized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,timestamp,%f
CLOrientationDetector::CLOrientationDetector(CLOrientationDetector::FormFactor, bool)
CoreLocation: gyroFrequency,%.3f,gyroBufferSize,%d,gyroMeanBufferSize,%d,zRotBufferSize,%d,minRequiredZrots,%d
CoreLocation: accelBufferSize,%d
void CLOrientationDetector::addAccSample(const CLMotionTypeAcceleration &, const CFAbsoluteTime &)
CoreLocation: Accelerometer samples data gap or out of order! deltaInterval=%.4f
CoreLocation: accel, %.3f, %.3f, %.3f, timestamp, %.20f
void CLOrientationDetector::addGyroSample(const CLMotionTypeRotationRate &, const CFAbsoluteTime &)
CoreLocation: Gyro samples data gap or out of order! deltaInterval=%.4f
CoreLocation: gyro, %.3f, %.3f, %.3f, gyroMean, %.3f, %.3f, %.3f, fLastDetection,%d,fStartZrot,%d, timestamp, %.10f
void CLOrientationDetector::fillZRotBuffer(const CLMotionTypeRotationRate &, const CLVector3d<float> &)
CoreLocation: zRot (%.3f, %.3f, %.3f), mean(%.3f, %.3f, %.3f), var(%.3f, %.3f, %.3f)
bool CLOrientationDetector::updateZRotationStatus(float, float, float)
CoreLocation: Likely transient.
CoreLocation: Slowing. decrement numZRot,delta, %.3f, numZRot, %d
CoreLocation: ZDROP detected. deltaDrop, %.3f, fNumZDrops, %d
CoreLocation: mostlyZ, %d, zRotMean.z, %.3f, zRot, %.3f, numZRots, %d, estCurr, %.3f, totalZ, %.2f, mag2MinusGrav, %.2f
CoreLocation: Going through with 180 turn.
CoreLocation: Rotating around Z. numSamples: %d, numAccu, %d, zRotVar, %.3f
void CLOrientationDetector::checkForRotation()
CoreLocation: SCREEN FLAT. NOT FILLING UP ZROT BUFFER.
CoreLocation: Transient!
CoreLocation: Rotating! Current max gyro rate %.3f
void CLOrientationDetector::updateLastPrimaryOrientationForZStats(float, float)
CoreLocation: Setting lastPrimaryOrientation.
void CLOrientationDetector::nixRotationAroundZIfNecessary(float, float, float)
CoreLocation: Nixed rotationAroundZ state.
void CLOrientationDetector::setUpForOrienationChangeViaRotation(CLVector3d<float> &)
CoreLocation: Ready for orientation change via rotation
void CLOrientationDetector::resetZStatsWhenQuiescent(float, float)
CoreLocation: Not filling Zrot buffer.
float CLOrientationDetector::getAccStats(CLVector3d<float> &, float &)
CoreLocation: acc variance, %.3f, %.3f, %.3f, acc mean, %.3f, %.3f, %.3f, maxVar, %.3f, mag2,%.3f
bool CLOrientationDetector::deviceIsMoving(const CLVector3d<float> &, float, float)
CoreLocation: Resetting stable count
static bool CLOrientationDetector::withinMagicAngleLimits(CLOrientationDetector::FormFactor, bool, float, bool)
CoreLocation: Within magic angle limits: Threshold %.4f, Delta %.4f
bool CLOrientationDetector::atMagicCoverRestingAngle(const float *, float, float, float)
CoreLocation: Ipad %d: screenJustTurnedOn, %d, deltaTime %.5f
CoreLocation: allowShallow, %d, magicCaseRest, %d, tiltIn, %d, wasMoving, %d, maxVar, %.5f
void CLOrientationDetector::calcCurrentOrientation()
CoreLocation: onStartup, x, %.3f, y, %.3f, z, %.3f
CoreLocation: FaceUp/Down: maxWeight,%.3f, 2ndWeight,%.3f, orientation,%d
CoreLocation: deltaWeightThreshold, %.3f, tiltWeightTheshold, %.3f, currAcc, %.3f, %.3f, %.3f, deltaWeight, %.3f, tilt, %.3f, fCurrentOrientation, %d, isMoving, %d, wasMoving, %d, fLastClearOrientation, %d, fStableCount, %d, DetectionTime, %f
bool CLOrientationDetector::calcOrientation(CMDeviceOrientationType &, CLMotionTypeTimestamp &)
CoreLocation: Notify from, %{public}s -> %{public}s 
void CLOrientationDetector::disableGyro()
CoreLocation: Disabling gyro.
void CLOrientationDetector::enableGyro()
CoreLocation: Enabling gyro.
Ambiguous
LandscapeLeft
LandscapeRight
FaceUp
CLVector3d<T> CLRunningVector3d<float>::getSample(unsigned int) const [T = float]
CoreLocation: Index out of bound.
com.apple.CoreMotion.CMCatherineFeeder.internal
-[CMCatherineFeederInternal _startDaemonConnection]_block_invoke
kCLConnectionMessageCatherineDataKey
kCLConnectionMessageCatherineData
internal
T@"CMCatherineFeederInternal",R,N,V_internal
void CLMagnetometerCoexistenceNotifierCpasV11::chooseOffsetData()
LogFileRotationSize
LogFileStorageCount
CLLogBase
LogDumpOnUnload
LogDumpOnLoad
yyyy-MM-dd_HH-mm-ss
/Library/Logs/CrashReporter
Library
Caches
Logs
CrashReporter
move
%s,%s,could not %s log file %s to %s
%s,%s,could not stat %s
%s,%s,failed to open %s
CLGyroCalibrationDatabaseSilo
CLGyroCalibrationDatabase
virtual bool CLGyroCalibrationDatabase::getGyroStats(CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, bool)
CoreLocation: Warning: Not implemented.
virtual int CLGyroCalibrationDatabase::getMaxDynamicTemperature()
kCMPedometerBinCodingKeyValueOut
kCMPedometerBinCodingKeyBegin
kCMPedometerBinCodingKeyEnd
kCMPedometerBinCodingKeyState
Begin,%.4f,End,%.4f,State,%ld,ValueOut,%.4f
valueOut
Td,R,N,V_valueOut
begin
Td,R,N,V_begin
lowerQuartile
center
upperQuartile
Td,R,N,V_end
state
Tq,R,N,V_state
CMPressureFilter::update
void CMPressureFilter::update(const CMPressureSample &)
CoreLocation: Type,%s,Time,%llu,RawPressure,%f,FilteredPressureTimeStamp,%llu,FilteredPressure,%f,RawPressurePeriod,%f,StateFOF,%d,StateFIR,%d
void CMPressureFilter::updateFIR(const CMPressureSample &)
CoreLocation: CMPressureFilter,Time,%llu,FastPressureRate,%f,PressureDecimation,%d,PressureFilterOffset,%d,PressureFilterDelay,%d
const T &CMQueue<float>::operator[](const size_t) const [T = float]
SampleType CMSymmetricFirFilter<float>::batchFilter(const CMQueue<SampleType> &, int) const [T = float, SampleType = float]
CoreLocation: Assertion failed: (offset >= 0) && (offset + fFullTapCount - 1 < samples.size()), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMSymmetricFirFilter.h, line 37,offset,%d,fullTapCount,%d,samplesSize,%zu.
com.apple.CoreMotion.CMFunctionalCapacity
-[CMFunctionalCapacityInternal init]_block_invoke
-[CMFunctionalCapacityInternal init]_block_invoke_2
CoreLocation: FunctionalCapacity, client connection interrupt, %@, %d, %d, %p
T@"CMFunctionalCapacityInternal",R,N,V_internal
v32@?0@"NSString"8@16^B24
CoreMotion
com.apple.CoreMotion.CMMotionUtils.AsyncMessageQueue.
com.apple.CoreMotion.CMMotionUtils.SyncMessageQueue.
+[CMMotionUtils sendMessageWithReplySync:]
CoreLocation: Timeout (after 5 seconds) occurred during wait!
com.apple.locationd.activity
+[CMMotionUtils tccServiceMotionAccessWithLabel:]
CoreLocation: Warning - invoking %@ on main may lead to deadlock.
v12@?0C8
+[CMMotionUtils tccServiceMotionAccessWithLabel:]_block_invoke
CoreLocation: TCCServiceMotionAccess timeouts!
com.apple.CoreMotion.tcc
+[CMMotionUtils tccServiceMotionAccessWithBlock:]_block_invoke
+[CMMotionUtils featureAvailability:]
+[CMMotionUtils fileHandleForWritingToURL:]
CoreLocation: #Notice URL must specify a file.
CoreLocation: #Notice File already exists at URL.
CoreLocation: #Notice URL must point to a file path which you have access to write to.
CoreLocation: #Notice Unable to get file handle for URL %{public}s: %{public}s
bool CLIoHidFastPathInterface::FastPathDevice::initializeFastPath(NSDictionary *)
CoreLocation: [FastPath] Already initialized
CoreLocation: [FastPath] Cannot initialize fast path when service ref is null
CoreLocation: [FastPath] Initialization failed,serviceRef,%@,properties,%@
void CLIoHidFastPathInterface::FastPathDevice::closeFastPath()
CoreLocation: [FastPath] Not initialized, nothing to close
virtual id CLIoHidFastPathInterface::FastPathDevice::copyProperty(NSString *)
CoreLocation: [FastPath] Fast path not initialized! Can't copy property
CoreLocation: [FastPath] Cannot copy property when service ref is null
virtual void CLIoHidFastPathInterface::FastPathDevice::setProperty(NSString *, id)
CoreLocation: [FastPath] Fast path not initialized! Can't set property %@ to %@
CoreLocation: [FastPath] Set property failed! %@, %@
com.apple.CoreMotion.CMActivityAlarmProxyPrivateQueue
kCLConnectionMessageActivityAlarmStart
-[CMActivityAlarmProxy init]_block_invoke
CoreLocation: #Warning Did not find the triggered activity alarm in the current set of alarms.
CoreLocation: Could not get dictionary for kCLConnectionMessageActivityAlarm
kCLConnectionMessageActivityAlarmAvailable
-[CMActivityAlarmProxy listenForActivityAlarm:]
CoreLocation: #Warning Was not able to listen for alarm.  Activity alarms are not available for this system.
-[CMActivityAlarmProxy stopListeningForActivityAlarm:]
CoreLocation: #Warning Cannot unsubscribe from activity alarm (Trigger:%d, Duration:%f).  This alarm is not being listened for.
kCMVehicleConnectionDataCodingKeyStartDate
kCMVehicleConnectionDataCodingKeyEndDate
kCLConnectionMessageVehicleConnectionMostRecent
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMActivityAlarm.mm
trigger < kActivityAlarmTriggerCount
-[CMActivityAlarm initWithTrigger:duration:onQueue:withHandler:]
CoreLocation: Unable to create sharedInstance of CMActivityAlarmProxy.
-[CMActivityAlarm initWithTrigger:duration:onRunLoop:withHandler:]
Td,N,V_duration
trigger
TI,N,V_trigger
CLPowerStateService
CMStepCounterQueue
-[CMStepCounterProxy init]_block_invoke
-[CMStepCounterProxy _startStepCountingUpdatesToQueue:updateOn:withHandler:]_block_invoke
CoreLocation: Unable to parse mesage (%{public}@) when starting updates to queue
-[CMStepCounterProxy _handleQueryResponse:onQueue:withHandler:]
CoreLocation: Unable to parse mesage (%{public}@) for query response
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMStepCounter.mm
-[CMStepCounter startStepCountingUpdatesToQueue:updateOn:withHandler:]_block_invoke
CoreLocation: Unable to start additional step updates while it is already active
-[CMStepCounter stopStepCountingUpdates]_block_invoke
CoreLocation: Unable to stop step updates as we are are not receiving updates
kCLConnectionMessageStepCountReset
stepcounterProxy
T@"CMStepCounterProxy",R,N,V_stepcounterProxy
CLSensorFusionService::CLSensorFusionService(int)
CoreLocation: Starting device motion service 0x%x
DeviceMotionUseThrottledInterval
DeviceMotionAccelerometerUpdateInterval
DeviceMotionGyroUpdateInterval
DeviceMotionCompassUpdateInterval
CoreLocation: GyroUpdateInterval,%.4f,AccelerometerUpdateInterval,%.4f
DumpGyroCalibrationDatabaseOnDeviceMotionStart
CLSensorFusionService::CLSensorFusionService(int)_block_invoke
CoreLocation: Dumped gyro cal database with id %@
virtual CLSensorFusionService::~CLSensorFusionService()
CoreLocation: Stopping device motion service 0x%x
void CLSensorFusionService::publishSensorFusion(const CLSensorFusionService::Sample *)
CoreLocation: [CLSensorFusionService] q.x,%10.10f,q.y,%10.10f,q.z,%10.10f,q.w,%10.10f,userAccel.x,%10.10f,userAccel.y,%10.10f,userAccel.z,%10.10f,rotationRate.x,%10.10f,rotationRate.y,%10.10f,rotationRate.z,%10.10f,magneticField.x,%10.10f,magneticField.y,%10.10f,magneticField.z,%10.10f,heading,%.3f,accuracy,%.3f,level,%d,mode,%d,status,%#02x,clientID,%d,timestamp,%lf,now,%lf
void CLSensorFusionService::updateSensorStatus(const CLSensorFusionService::SensorStatus &)
CoreLocation: Set device motion sensor status %ld
kCMDeviceMotionLiteCodingKeyQuaternionW
kCMDeviceMotionLiteCodingKeyQuaternionX
kCMDeviceMotionLiteCodingKeyQuaternionY
kCMDeviceMotionLiteCodingKeyQuaternionZ
kCMDeviceMotionLiteCodingKeyUserAccelerationX
kCMDeviceMotionLiteCodingKeyUserAccelerationY
kCMDeviceMotionLiteCodingKeyUserAccelerationZ
kCMDeviceMotionLiteCodingKeyRotationRateX
kCMDeviceMotionLiteCodingKeyRotationRateY
kCMDeviceMotionLiteCodingKeyRotationRateZ
kCMDeviceMotionLiteCodingKeyRawAccelerationX
kCMDeviceMotionLiteCodingKeyRawAccelerationY
kCMDeviceMotionLiteCodingKeyRawAccelerationZ
kCMDeviceMotionLiteCodingKeyRawRotationRateX
kCMDeviceMotionLiteCodingKeyRawRotationRateY
kCMDeviceMotionLiteCodingKeyRawRotationRateZ
kCMDeviceMotionLiteCodingKeyMachTimestamp
kCMDeviceMotionLiteCodingKeyUsingCompass
kCMDeviceMotionLiteCodingKeyGyroTemperature
kCMDeviceMotionLiteCodingKeyCompassTemperature
kCMDeviceMotionLiteCodingKeyRawMagneticFieldX
kCMDeviceMotionLiteCodingKeyRawMagneticFieldY
kCMDeviceMotionLiteCodingKeyRawMagneticFieldZ
kCMDeviceMotionLiteCodingKeyPhysicalDeviceUniqueID
%@,Gravity,%f,%f,%f,UserAcceleration,%f,%f,%f,Tip,%f,Tilt,%f,Attitude,%f,%f,%f,RotationRate,%f,%f,%f,MachTimestamp,%f,UsingCompass,%d,PhysicalDeviceUniqueID,%@
%@,Gravity,%f,%f,%f,UserAcceleration,%f,%f,%f,Tip,%f,Tilt,%f,MachTimestamp,%f,UsingCompass,%d,PhysicalDeviceUniqueID,%@
Carbon,%f,%f,%f,%f,%f,%f,%f,MachTimestamp,%f,PhysicalDeviceUniqueID,%@
Magnesium,%f,%f,%f,%f,MachTimestamp,%f,PhysicalDeviceUniqueID,%@
%@,Quaternion,%f,%f,%f,%f,RotationRate,%f,%f,%f, RawAcceleration,%f,%f,%f,RawRotationRate,%f,%f,%f,MachTimestamp,%f,UsingCompass,%d PhysicalDeviceUniqueID,%@
rawAcceleration
T{?=ddd},R,N,VfRawAcceleration
rawRotationRate
T{?=ddd},R,N,VfRawRotationRate
machTimestamp
TQ,R,N,VfMachTimestamp
gyroTemperature
Tf,R,N,VfGyroTemperature
compassTemperature
Tf,R,N,VfCompassTemperature
rawMagneticField
T{?=ddd},R,N,VfRawMagneticField
T{?=ddd},R,N,VfGravity
T{?=ddd},R,N,VfUserAcceleration
Tf,R,N
tilt
T@"CMAttitude",R,N,VfAttitude
T{?=ddd},R,N,VfRotationRate
usingCompass
TB,R,N,GisUsingCompass,VfUsingCompass
physicalDeviceUniqueID
T@"NSString",R,&,N,VfPhysicalDeviceUniqueID
BKDigitizerSignpostsEnabled
com.apple.backboardd
CLSilo: %@
T@"NSString",R,N,V_identifier
void CMPickupDetector::StaticReference::feedBufferAndCalcReference(const CMVector3d &, uint64_t, uint64_t, CMPickupDetector_Types::DetectionState)
CoreLocation: Grabbing reference pose while static, %.3f, %.3f, %.3f, varInfNorm, %.8f
CoreLocation: Getting new reference in StableState when no reference is available yet.
bool CMPickupDetector::checkForStable(uint64_t)
CoreLocation: Entered Stable state from being static/frozen
CoreLocation: fStableCount, %d, maxXYVar, %.8f, xyMeanNorm, %.3f, deltaTiltMean, %.3f
CoreLocation: Entered Stable state. timestamp, %.6f
bool CMPickupDetector::checkForLift(const CMVector3d &, uint64_t)
CoreLocation: deltaTilt, %.3f, fLiftCount, %d, z2xyRatio, %.3f, dt, %.2f
CoreLocation: Entered Lift state. timestamp, %.6f
-[CLDispatchTimerScheduler reflectNextFireTime:fireInterval:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Shared/Intersilo/CLDispatchSilo.m
_source
timer
T@"CLTimer",W,N
source
T@"NSObject<OS_dispatch_source>",&,N,V_source
T@"CLTimer",W,N,Vtimer
MainSilo
%@.NSOperationQueue
CLDispatchSilo: %s
_handler
T@?,C,N,V_handler
nextFireTime
Td,N,V_nextFireTime
fireInterval
Td,N,V_fireInterval
32 > _numArguments
syncget
0 != _returnValueSize
0 == _returnValueSize
withReply:
0 == _returnAddressIndex
T:,R,N,V_sel
numArguments
Ti,R,N,V_numArguments
replyBlockIndex
Ti,R,N,V_replyBlockIndex
returnAddressIndex
Ti,R,N,V_returnAddressIndex
returnValueSize
Ti,R,N,V_returnValueSize
T@"NSMethodSignature",R,&,N,V_sig
T@"NSString",R,&,N,V_str
Protocol: %p
Name: %s
Selectors: (
protocol
T@"Protocol",R,N,V_protocol
void CLSensorFusionServiceAP::onBiasAndVariance(const CLMotionTypeGyroBiasAndVariance)_block_invoke
com.apple.CoreMotion.CMAltimeterInternalQueue
com.apple.CoreMotion.CMAltimeterAppQueue
kCLConnectionMessageSignificantElevationUpdate
-[CMAltimeterInternal init]_block_invoke
CoreLocation: Unable to parse message (%{public}s) when starting updates to queue
kCLConnectionMessageSignificantElevationDeltaQuery
-[CMAltimeterInternal _querySignificantElevationChangeFromDate:toDate:withHandler:]_block_invoke
CoreLocation: Unable to parse message (%{public}s) for query response
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMAltimeter.mm
fromDate
toDate
-[CMAltimeter onFilteredPressure:]
CoreLocation: relativeAltitude,%f,pressure,%f
T@"CMAltimeterInternal",R,N,V_internal
com.apple.CoreMotion.CMSwimTracker
-[CMSwimTrackerInternal init]_block_invoke
-[CMSwimTrackerInternal init]_block_invoke_2
CoreLocation: Client connection interrupt, %@, %d, %d, %p
kCLConnectionMessageSwimDataQuery
kCLConnectionMessageSwimDataUpdate
-[CMSwimTrackerInternal _stopUpdates]_block_invoke
CoreLocation: Unable to stop swim data updates as we are are not receiving updates.
-[CMSwimTrackerInternal _querySwimUpdatesFromRecord:handler:]_block_invoke
CoreLocation: Unable to parse query message.
-[CMSwimTrackerInternal _handleUpdates:]
CoreLocation: %@, %@, %d, %p
CoreLocation: Unable to parse update message.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMSwimTracker.mm
T@"CMSwimTrackerInternal",R,N,V_internal
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMMotionAlarm.mm
type == kCMMotionAlarmTypeTimer
type < kMotionAlarmTypeCount
kCMMotionAlarmName
kCMMotionAlarmType
kCMMotionAlarmDuration
kCMMotionAlarmRepeats
kCMMotionAlarmId
kCMMotionAlarmBundleId
kCMMotionAlarmState
Name: %@, Type: %d, Duration: %d, Repeats: %d, AlarmID: %llu, BundleID: %@, AlarmState: %@
alarmId
TQ,N,V_alarmId
bundleId
T@"NSString",&,N,V_bundleId
Ti,N,V_state
manager
T@"CMMotionAlarmManager",&,N,V_manager
T@"NSString",R,&,N,V_name
TI,R,N,V_duration
repeats
TB,R,N,V_repeats
TI,R,N,V_type
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMSwimData.mm
sourceId && sessionId && startDate && endDate && strokeType < kCMSwimStrokeTypeMax
kCMSwimDataCodingKeyRecordId
kCMSwimDataCodingKeySourceId
kCMSwimDataCodingKeySessionId
kCMSwimDataCodingKeyStartDate
kCMSwimDataCodingKeyEndDate
kCMSwimDataCodingKeyStrokeCount
kCMSwimDataCodingKeyDistance
kCMSwimDataCodingKeyAvgPace
kCMSwimDataCodingKeyLapCount
kCMSwimDataCodingKeyStrokeType
kCMSwimDataCodingKeySegmentCount
Freestyle
Backstroke
Breaststroke
Butterfly
Mixed
%@, <sessionId %@, startDate %@, endDate %@, strokeCount %lu, distance %.2f, avgPace %.2f, lapCount %lu, strokeType %@, segment %lu>
strokeCount
avgPace
lapCount
strokeType
segment
postInit == initiatorProxy
postInit == recipientProxy
[_last sel] == [inv selector]
![inv argumentsRetained]
_delegate
_delegateSilo
CLService: Block was not compiled using a compiler that inserts type information about arguments. (%@)
v16@?0@"NSInvocation"8
(id)[NSNull null] != _delegate
__objc_no
_delegate == (id)[NSNull null] && !_delegateSilo
<%@: peer silo:%@, peer tag:%lu>
_opaqueTag == 0
T@"<CLIntersiloProxyDelegateProtocol>",R,W,N,V_delegate
delegateSilo
T@"CLSilo",R,W,N,V_delegateSilo
delegateInterface
T@"CLIntersiloInterface",R,C,N,V_delegateInterface
proxiedInterface
T@"CLIntersiloInterface",R,C,N,V_proxiedInterface
kCMOnBodyStatusResult
kCMOnBodyStatusConfidence
result %d confidence %d timestamp %f
result
virtual std::shared_ptr<CLIoHidInterface::Device> CLIoHidInterface::buildDevice(CLIoHidInterface::Device::Description)
CoreLocation: [CLIoHidInterface] Adding new Device with usage pair {%d, %d}
void CLIoHidInterface::initializeHidIfNecessary()
CoreLocation: [CLIoHidInterface] Could not create event system client. All bets are off
CoreLocation: [CLIoHidInterface] Event system client initialized successfully
void CLIoHidInterface::closeHid()
CoreLocation: [CLIoHidInterface] Hid interface closed
void CLIoHidInterface::refreshDeviceServiceRefs()
CoreLocation: [CLIoHidInterface] Refreshing service refs
CoreLocation: [CLIoHidInterface] The device is gone!
CoreLocation: [CLIoHidInterface] Check service ref %p with usage pair {%d,%d} as a potential match
CoreLocation: [CLIoHidInterface] Service ref with usage pair {%d,%d} is %p
void CLIoHidInterface::invalidateDeviceServiceRefs()
CoreLocation: [CLIoHidInterface] invalidating hid service refs
bool CLIoHidInterface::setPropertyIoHid(IOHIDServiceClientRef, CFStringRef, CFTypeRef)
CoreLocation: [CLIoHidInterface] property can not be set for null hidServiceRef
CoreLocation: [CLIoHidInterface] IOHIDServiceClientSetProperty() returned false
void CLIoHidInterface::applyAllDirtyDeviceProperties()
CoreLocation: [CLIoHidInterface] apply all dirty device properties
CoreLocation: [CLIoHidInterface] Service with for device with usage pair {%d,%d} is not ready
CoreLocation: [CLIoHidInterface] Property for usage pair {%d,%d}: {%s = %@} was set %s
CoreLocation: [CLIoHidInterface] Could not set all properties. Setting timer to fire %f seconds from now
CoreLocation: [CLIoHidInterface] Could not set all properties after too many retries. Giving up.
void CLIoHidInterface::setMatchingForDevices()
CoreLocation: [CLIoHidInterface] Prox: remove set matching multiple
CoreLocation: [CLIoHidInterface] Adding match entry for usage pair {%d,%d}
CoreLocation: [CLIoHidInterface] Setting matching multiple for %lu events
void CLIoHidInterface::onEvent(void *, void *, IOHIDEventRef)
CoreLocation: [CLIoHidInterface] Received null sender
CoreLocation: [CLIoHidInterface] Processing event %d
CoreLocation: [CLIoHidInterface] Got null event,sender %p,registryID %llx
CoreLocation: [CLIoHidInterface] Fetching historical events
CoreLocation: [CLIoHidInterface] Did not fetch historical events
CoreLocation: [CLIoHidInterface] The device has no event callback, skipping.
void CLIoHidInterface::onEventSystemReset(void *)
CoreLocation: [CLIoHidInterface] It looks like our HID event system just become available (again)
void CLIoHidInterface::onEventSystemReset(void *)_block_invoke
void CLIoHidInterface::onServiceRegistration(void *, IOHIDServiceClientRef)
CoreLocation: [CLIoHidInterface] New IOHIDServiceClientRef for usage pair {%d,%d} just became available.
CoreLocation: [CLIoHidInterface] Device,usagePage,%d,usage,%d,hidserviceref,old,%p,new,%p
virtual CLIoHidInterface::Device::~Device()
CoreLocation: [CLIoHidInterface] Releasing value for property %s, address = %p
void CLIoHidInterface::Device::setCallback(OnIoHidEvent, void *)
CoreLocation: [CLIoHidInterface] setCallback should be called from motion thread
void CLIoHidInterface::Device::setNewServiceCallback(OnIoHidNewService, void *)
CoreLocation: [CLIoHidInterface] setNewServiceCallback should be called from motion thread
void CLIoHidInterface::Device::setIoHidResetCallback(OnIoHidReset, void *)
CoreLocation: [CLIoHidInterface] setIoHidResetCallback should be called from motion thread
virtual void CLIoHidInterface::Device::setProperty(NSString *, id)
CoreLocation: [CLIoHidInterface] Could not set property value for %@
CoreLocation: [CLIoHidInterface] setProperty should be called from motion thread
virtual id CLIoHidInterface::Device::copyProperty(NSString *)
CoreLocation: [CLIoHidInterface] copyProperty should be called from motion thread
eventType > 0
void CLIoHidInterface::Device::setRegistryIDChangedCallback(OnRegistryIDChanged, void *)
CoreLocation: %s hid driver interface for event {%d, %d}, hidServiceRef %p
CoreLocation: [CLIoHidInterface] setRegistryIDChangedCallback should be called from motion thread
void CLIoHidInterface::Device::setHistoricalTransitionCallback(OnHistoricalTransition, void *)
CoreLocation: [CLIoHidInterface] setHistoricalTransitionCallback should be called from motion thread
void CLIoHidInterface::Device::setEventType(IOHIDEventType)
CoreLocation: [CLIoHidInterface] setEventType should be called from motion thread
bool CLIoHidInterface::Device::initializeServiceRef()
CoreLocation: [CLIoHidInterface] Service for usage pair {%d, %d} is not ready
void CLIoHidInterface::Device::print()
CoreLocation: [CLIoHidInterface] Device,hidUsagePage,%d,hidUsage,%d,hasCallback,%d,serviceRef,%p
void CLIoHidInterface::Device::printProperties()
CoreLocation: [CLIoHidInterface] 
%s = %@,dirty,%d
((void *)0)
((void *)0) == _inboundInterface
((void *)0) == _outboundInterface
_inboundInterface
_outboundInterface
!_silo
!_vendor
Silo: %@
Inbound: %@
Outbound: %@
universe
T@"<CLIntersiloUniverse>",R,N
inboundInterface
T@"CLIntersiloInterface",R,N,V_inboundInterface
outboundInterface
T@"CLIntersiloInterface",R,N,V_outboundInterface
TB,N,V_valid
self.keyedPayloads
![self.keyedPayloads objectForKey:key]
payload
keyedPayloads
T@"NSMutableDictionary",&,N,V_keyedPayloads
+[CMWakeGestureManager sharedManager]_block_invoke
CoreLocation: Watch: Gesture Manager Active
CoreLocation: Phone: Gesture Manager Active
CoreLocation: CMWakeGestureManager is not supported on this platform!
-[CMWakeGestureManager logAssert]
CoreLocation: Calling methods directly on an instance of CMWakeGestureManager is not permitted. Please use +[CMWakeGestureManager sharedManager] instead.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMWakeGestureManager.mm
false
T@"<CMWakeGestureDelegate>",N,V_delegate
svcClass
T#,R,N,V_svcClass
residentCount
Ti,N,V_residentCount
synCount
Ti,R,N,V_synCount
ackCount
Ti,R,N,V_ackCount
0 == [fellows count]
0 <= dewrappedDeficit
record.svcClass
v32@?0@"CLSilo"8@"CLServiceVendorHeartbeatRecord"16^B24
HeartAttack
q24@?0@8@16
Adapter
_CLUnSupportedService
CLServiceVendorQueue
CLServiceVendor.HeartbeatCheckInterval
HeartAttackStackshot
remapping
newEffectiveSvcName
oldEffectiveSvcName
[oldEffectiveSvcName isEqual:newEffectiveSvcName]
Test
Mock
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMFitnessMachineData.mm
kCMFitnessMachineDataKeyTimestamp
kCMFitnessMachineDataKeyElapsedTime
kCMFitnessMachineDataKeyTotalEnergy
kCMFitnessMachineDataKeyTotalDistance
kCMFitnessMachineDataKeyTotalElevationAscended
kCMFitnessMachineDataKeyTotalStrideCount
kCMFitnessMachineDataKeyTotalStrokeCount
kCMFitnessMachineDataKeyTotalFloorsClimbed
kCMFitnessMachineDataKeyInstantaneousSpeed
kCMFitnessMachineDataKeyInstantaneousCadence
kCMFitnessMachineDataKeyInstantaneousPower
kCMFitnessMachineDataKeyInclination
kCMFitnessMachineDataKeyResistanceLevel
%@, <timestamp, %f, elapsedTime, %f, totalEnergy, %f, totalDistance, %f, totalElevationAscended, %f,  totalStrideCount, %ld, totalStokeCount, %ld,totalFloorsClimbed, %ld, instantaneousSpeed, %f, instantaneousCadence, %f, instantaneousPower, %f, inclination, %f, resistanceLevel, %f>
elapsedTime
Td,N,V_elapsedTime
totalEnergy
Td,N,V_totalEnergy
Td,N,V_totalDistance
totalElevationAscended
Td,N,V_totalElevationAscended
totalStrideCount
Tq,N,V_totalStrideCount
totalStrokeCount
Tq,N,V_totalStrokeCount
totalFloorsClimbed
Tq,N,V_totalFloorsClimbed
instantaneousSpeed
Td,N,V_instantaneousSpeed
instantaneousCadence
Td,N,V_instantaneousCadence
instantaneousPower
Td,N,V_instantaneousPower
inclination
Td,N,V_inclination
resistanceLevel
Td,N,V_resistanceLevel
CLGestureService
void CLGestureService::closeHidDriverInterface()
CoreLocation: Close hid driver interface
bool CLGestureService::sendGestureCommand(const void *, size_t)
CoreLocation: #Warning Gesture service is not available on this platform
notification == kNotificationGestureReport
void CLGestureService::onGestureService(const uint8_t *, size_t, const CFTimeInterval &)
CoreLocation: numberOfSpectators,%zi
CoreLocation: Undecodable data.,size,%zu,type,%u
com.apple.CoreMotion.CMOnBodyStatusManagerPrivateQueue
kCLConnectionMessageOnBodyDetectionParams
kCLConnectionMessageOnBodyDetection
-[CMOnBodyStatusManager connect]_block_invoke
-[CMOnBodyStatusManager startOnBodyStatusDetectionPrivateToQueue:withParameters:handler:]
CoreLocation: Neither the queue nor the handler can be nil
data
T^v,N,V_data
destructor
T@?,C,N,V_destructor
virtual void CLSensorFusionService3AxisDynamicGyro::start()
CoreLocation: %s is enabling power conservative device motion for parallax.
virtual void CLSensorFusionService3AxisDynamicGyro::stop()
CoreLocation: %s is disabling power conservation for parallax.
void CLSensorFusionService3AxisDynamicGyro::onAccelerometerData(const CLAccelerometer::Sample *)_block_invoke_3
CoreLocation: Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.
void CLSensorFusionService3AxisDynamicGyro::onBiasAndVariance(const CLMotionTypeGyroBiasAndVariance)_block_invoke
_client
CLNotifierClientBase: %p
nullptr == _notifier
[self valid]
_notifier
ClientIntegerMap: (
%p = %d
notifier
T^{CLNotifierBase=^^?},R,N,V_notifier
com.apple.CoreMotion.CMWorkoutManager
-[CMWorkoutManagerInternal init]_block_invoke
CoreLocation: Workout, client connection interrupt, %@, %d, %d, %p
kCLConnectionMessageWorkoutEvent
-[CMWorkoutManagerInternal _startWorkout:]
CoreLocation: Workout, START, %@, %@, %d, %p
CoreLocation: Trying to start a swim session without using a CMSwimWorkout!  Treating this swim as an open water swim.
kCLConnectionMessageWorkoutStart
-[CMWorkoutManagerInternal _stopWorkout:]
CoreLocation: Workout, STOP, %@, %@, %d, %p
kCLConnectionMessageWorkoutStop
-[CMWorkoutManagerInternal _setSuggestedStopTimeout:]
CoreLocation: Workout, Registering suggested stop timeout, %@, %d, %p
kCLConnectionMessageSetWorkoutTimeout
-[CMWorkoutManagerInternal _handleDaemonResponse:]
CoreLocation: Workout, nil event dictionary, %@
CoreLocation: Workout, Error, %d, %@
-[CMWorkoutManagerInternal _handleDaemonEvent:]
CoreLocation: Workout, ERROR, %d, %@
CoreLocation: Workout, DID START at %f, %@
CoreLocation: Workout, DID STOP at %f, %@
CoreLocation: Workout, WILL PAUSE at %f, %@
CoreLocation: Workout, WILL RESUME at %f, %@
CoreLocation: Workout, SUGGESTED STOP at %f, %@
CoreLocation: Workout, Unrecognized event, %@
CoreLocation: Workout, Unrecognizable event dictionary, %@
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Framework/CoreMotion/CMWorkoutManager.mm
workout
seconds > 0
T@"CMWorkoutManagerInternal",R,N,V_internal
T@"<CMWorkoutManagerDelegate>",N
CMMsl.Writer
1.2.8
setFlushTimeout_block_invoke
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Shared/Motion/Msl/CMMslWriter.cpp
(fFd == -1) && ("Writer::setFlushTimeout() must be called before ::open().")
Cannot open Msl file
Cannot seek to end of Msl file
Cannot seek to start of Msl file
Short signature in Msl file
Bad signature in Msl file
Cannot create dispatch_io for Msl file
zstream status? Msl %d
Msl dispatch io write error %s
v24@?0B8^{dispatch_data_s=}12i20
batch
super
fConnected
fEndTime
fStartTime
reserved
scaledValue
speedRange
speedThreshold
heightM
hrmax
hrmin
hronset
runVo2max
vo2max
weightKG
pause
accuracy
biasX
biasY
biasZ
calibrationLevel
horizontal
magneticFieldX
magneticFieldY
magneticFieldZ
magneticHeading
magnitude
trueHeading
compassJustAlignedToStableField
cost
coverage
earthDiffRatio
poseX
poseY
poseZ
quality
scaleX
scaleY
scaleZ
calibratedField
predictedField
scale
unitDistance
vertical
correction
writeTo
/BuildRoot/Library/Caches/com.apple.xbs/Binaries/CoreLocationFramework_Sim/install/TempContent/Objects/CoreLocation.build/Msl.build/DerivedSources/CMMslSens.gen.cpp
_correction
clientID
quaternionW
quaternionX
quaternionY
quaternionZ
rotationRateX
rotationRateY
rotationRateZ
status
userAccelerationX
userAccelerationY
userAccelerationZ
estimate
measurement
noisevariance
residual
statevariance
variant
aopTsNow
aopTsSensor
magMax
xMax
xMin
xZCTime
yMax
yMin
yZCTime
zMax
zMin
zZCTime
event
value
gyroMaxMean
magnitudeDiffUnity
maxAccelStdAxis
sampleNumMod3
subType
triggerEnabled
triggerOn
varianceX
varianceY
varianceZ
allowRelaxedGyroMean
gyroMean
gyroVariance
stillOnAll
temperatureBias
axis
intercept
lastMiniCal
slope
fsync
sampleNum
accel
accelBatch
accelGesture
accelGps
accelOscarEmu
bTConnection
basebandSpeed
bodyMetrics
calorimetryPauseEvent
cftime
coarseElevationChange
compassAlignment
compassCalibration
compassConstraints
compassCorrection
courseConstraints
courseCorrection
elevationChange
enhancedDeviceMotion
fallStats
gestureHint
gravityConstraints
gravityCorrection
gyro
gyroBiasAndVariance
gyroBiasConstraints
gyroBiasCorrection
gyroBiasFit
gyroCompass
gyroDt
gyroGps
gyroOscarEmu
locationOscarEmu
magnetometer
metsInfo
motionGPSLocation
motionLoiData
motionStateUpdate
motionWifiAssociation
motionWifiLocation
natalieData
nonlinearBiasFit
odometerWithAltitude
onsetHeartRateData
pressureFiltered
pressureGps
pressureOscarEmu
prox
sessionOverride
stepCadenceToStrideLengthBin
streamingHeartRateData
strideCalBin
touchOscarEmu
vibrationEvent
watchOrientationSettings
workoutEvent
altitude
course
courseAccuracy
horizontalAccuracy
latitude
locationLoggingEnabled
longitude
speed
speedAccuracy
verticalAccuracy
metsDiff
metsHR
metsWR
deltaDistance
deltaDistanceAccuracy
horzUncSemiMaj
horzUncSemiMajAz
horzUncSemiMin
originDevice
timestampGps
undulation
undulationModel
arrivalDate
departureDate
caltype
exitState
hidTimestamp
isVehicular
machineFrequency
motionType
mounted
mountedConfidence
rowStrokeAmplitude
rowStrokeFrequency
rowStrokePower
standing
turn
vectorMagnitude
wallStartTime
isWifiAssociated
activityType
fGpsAvailability
fractionalGrade
gradeType
isStanding
metSource
rawGradeType
error
overlap
gpsAltitude
gpsSpeedAccuracy
rawSpeed
groundAltitude
groundAltitudeUncertainty
smoothedGPSAltitude
smoothedGPSAltitudeUncertainty
dataSource
heartRate
interpolation
sinceLastGood
detectionMask
sessionType
strideLength
kValue
touchDetected
isDeviceVibrating
crown
wrist
CMSedentaryTimer_Internal
CMSedentaryTimer
CMMotionActivityManager
CMNatalieData
CMAccelerometerDataInternal
NSCopying
CMAccelerometerData
CMAltitudeDataInternal
CMAltitudeData
CMSignificantElevationSample
NSSecureCoding
NSCoding
CMVehicleStateData
CMVehicleState
CMWorkout
CMSwimWorkout
CMFitnessMachineWorkout
CMDeviceMotionInternal
CMDeviceMotion
CMAttitudeInternal
CMAttitude
CMAmbientPressureDataInternal
CMAmbientPressureData
CMRecordedAccelerometerData
CMRecordedGyroData
CMSensorDataList
NSFastEnumeration
CMSensorRecorderInternal
CMSensorRecorder
CMLogItemInternal
CMLogItem
CMWakeGesturePhone
CMOdometerProxy
CMOdometer
CMExerciseMinuteData
CMGyroDataInternal
CMGyroData
CMCatherineData
CMSpringTrackerInternal
CMSleepTracker
CMMotionTimeRange
CMCallHandednessManager
CMCalorieUserInfo
CLIntersiloUniverse
NSObject
CMSedentaryTimerData
CMExerciseMinuteInternal
CMExerciseMinute
CMLiftManagerInternal
CMLiftManager
CMMotionAlarmManagerInternal
CMMotionAlarmManager
CMNatalimeterInternal
CMNatalimeter
CMMagnetometerDataInternal
CMMagnetometerData
CMAnomalyManager
CMMotionManagerInternal
CMMotionManager
CMElevationData
CMActivity
CMGestureManagerInternal
CMGestureManager
CMActivityManagerInternal
CMActivityManager
CMPedometerProxy
CMPedometer
CLCompassDatabaseProtocol
CLNotifierServiceProtocol
CLIntersiloServiceProtocol
CLIntersiloProxyDelegateProtocol
CLCompassDatabaseClientProtocol
CLNotifierServiceClientProtocol
CLIntersiloClientProtocol
CLCompassDatabaseAdapter
CMWakeGestureWatch
CLJsonLogging
IsSupported
CMOdometerData
CLGeomagneticModelProviderProtocol
CLGeomagneticModelProviderClientProtocol
CLGeomagneticModelProviderAdapter
CMFitnessMachineInternal
CMFitnessMachine
CLSensorRecorderSensorMeta
CLSensorRecorderSensorMetaRequestById
CLSensorRecorderSensorMetaRequestByDateRange
CLSensorRecorderSensorDataRequestById
CLSensorRecorderRecordSensorTypeFor
CLSensorRecorderWriteSensorDataToFileForDateRange
CLSensorRecorderSensorAvailable
CLSensorRecorderSensorSampleRate
CMMotionActivity
CMPickupManager
CMPedometerData
CMPedometerEvent
CMDeviceOrientation
CMDeviceOrientationManagerInternal
CMDeviceOrientationManager
CLDeviceMotionProperties
CMPocketStateQueueBlockPair
CMPocketStateManager
CMLiftMotion
CMSleepData
CMFall
CMCatherineFeederInternal
CMCatherineFeeder
CLGyroCalibrationDatabaseProtocol
CLGyroCalibrationDatabaseClientProtocol
CLGyroCalibrationDatabaseAdapter
CMPedometerBin
CMFunctionalCapacityInternal
CMFunctionalCapacity
CMMotionUtils
CMActivityAlarmProxy
CMVehicleConnectionData
CMVehicleConnection
CMActivityAlarm
CMStepCounterProxy
CMStepCounter
CMDeviceMotionLite
CLSilo
CLDispatchTimerScheduler
CLTimerScheduler
CLDispatchSilo
MainSilo
CLTimer
CLExtensions
CLIntersiloInterfaceSelectorInfo
CLIntersiloInterface
CMAltimeterInternal
CMAltimeter
CMElevation
CMSwimTrackerInternal
CMSwimTracker
CMMotionAlarm
CMSwimData
CLIntersiloProxy
CMOnBodyStatus
CLIntersiloService
CLIntersiloServiceMock
CLIntersiloServiceMockProtocol
CMWakeGestureManager
CLServiceVendorHeartbeatRecord
_Locationd
_CLMainService
_CLUnSupportedService
CLServiceVendor
CMFitnessMachineData
CMOnBodyStatusManager
CLNotifierData
CLNotifierClientAdapter
CLNotifierServiceAdapter
CMWorkoutManagerInternal
CMWorkoutManager
numberWithInt:
intValue
stringWithUTF8String:
boolValue
init
objectForKeyedSubscript:
_startWatchdogCheckins
dealloc
_stopWatchdogCheckins
sendMessageWithReplySync:
setTimerArmed:
isTimerArmed
errorWithDomain:code:userInfo:
integerValue
_handleAlarmDataResponse:withHandler:
_teardown
_isActive
_handleStartStopTimerResponse:withHandler:
_registerForAlarmsWithHandler:
fClientQueue
fWatchdogTimer
fDaemonQueue
fLocationdConnection
_timerArmed
alloc
release
featureAvailability:
_internal
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
timeIntervalSinceReferenceDate
numberWithDouble:
numberWithBool:
dictionaryWithObjects:forKeys:count:
isAvailable
isActive
startTimerWithStartTime:periodInterval:reminderInterval:autoReschedule:handler:
stopTimerWithHandler:
queryAlarmDataSince:withHandler:
registerForAlarmsWithHandler:
authorizationStatus
addOperationWithBlock:
_handleQueryResponse:onQueue:withHandler:
tccServiceMotionAccessWithBlock:
retain
isActivityAvailable
queryActivityStartingFromDate:toDate:toQueue:withHandler:
startActivityUpdatesToQueue:withHandler:
stopActivityUpdates
fLocationConnection
fQueue
fHandler
fHandlerQueue
initWithTimestamp:
copy
initWithCoder:
decodeDoubleForKey:
decodeIntegerForKey:
class
decodeObjectOfClass:forKey:
allocWithZone:
initWithStartDate:recordId:session:mets:natalies:basalNatalies:sourceId:
encodeWithCoder:
encodeDouble:forKey:
encodeInteger:forKey:
encodeObject:forKey:
dateWithTimeIntervalSinceReferenceDate:
recordId
startDate
sessionName:
mets
stringValue
natalies
basalNatalies
sourceId
stringWithFormat:
supportsSecureCoding
maxNatalieEntries
copyWithZone:
session
description
fRecordId
fStartDate
fSession
fMets
fNatalies
fBasalNatalies
fSourceId
setAcceleration:
initWithAcceleration:
fAcceleration
timestamp
initWithAcceleration:andTimestamp:
acceleration
numberWithUnsignedChar:
getBytes:length:
numberWithUnsignedInt:
setAltitude:andPressure:
initWithAltitude:andPressure:
fAltitude
fPressure
initWithAltitude:andTimestamp:atBaseAltitude:
relativeAltitude
pressure
initWithUUIDBytes:
initWithTimeIntervalSinceReferenceDate:
initWithDouble:
initWithRecordId:sourceId:startDate:endDate:elevationAscended:elevationDescended:
endDate
elevationAscended
elevationDescended
initWithSignificantElevation:
fEndDate
fElevationAscended
fElevationDescended
UTF8String
cStringUsingEncoding:
mainBundle
objectForInfoDictionaryKey:
timeRange
deviceId
initWithTimeRange:deviceId:
fTimeRange
fDeviceId
doubleValue
initWithStartDate:endDate:
autorelease
mostRecentVehicleConnection
mostRecentInVehicle
vehicularState
vehicularHints
lastPathComponent
fileURLWithPath:isDirectory:
dataWithContentsOfURL:options:error:
domain
isEqual:
code
writeToURL:options:error:
assertInside
sharedApplication
performSelector:
applicationState
objectForKey:
processInfo
processName
compare:
initWithSessionId:type:
sessionId
type
workoutName:
natalieDataSessionFromWorkoutType:
workoutTypeFromNatalieDataSession:
fSessionId
fType
initWithSessionId:location:poolLength:
location
swimLocationName:
poolLength
isMemberOfClass:
swimWorkoutInstance:
fLocation
fPoolLength
initWithSessionId:workoutType:manufacturerName:model:
manufacturerName
model
fitnessMachineWorkoutInstance:
fManufacturerName
fModel
defaultManager
currentDirectoryPath
stringByAppendingString:
silo
setQuaternion:
initWithQuaternion:
setDeviceMotion:
initWithDeviceMotion:
fGravity
fUserAcceleration
fRotationRate
fAttitude
fMagneticField
fMagneticFieldCalibrationLevel
fDoingYawCorrection
fDoingBiasEstimation
fHeading
decodeBoolForKey:
quaternion
encodeBool:forKey:
magneticField
initWithDeviceMotion:andTimestamp:
attitude
rotationRate
gravity
userAcceleration
magneticFieldCalibrationLevel
doingYawCorrection
doingBiasEstimation
heading
fQuaternion
pitch
roll
rotationMatrix
multiplyByInverseOfAttitude:
setAmbientPressure:
initWithPressure:
initWithPressure:andTimestamp:
ambientPressure
mutableCopy
addEntriesFromDictionary:
resetWithData:timestamp:walltime:identifier:
decodeFloatForKey:
encodeFloat:forKey:
initWithData:timestamp:walltime:identifier:
identifier
_startDateValue
_accelerationValue
_timestampValue
_identifier
temperature
_rotationRate
_temperatureValue
newMetaSinceID:forType:
initWithCapacity:
_updateCurrentBlockProperties
_updatePointers
newMetaFrom:to:forType:
count
objectAtIndexedSubscript:
teardown
dataIdentifier
startTime
offset
addObject:
retainCount
setObject:atIndexedSubscript:
dataSize
newMetaByID:forType:
newDataByID:metaID:forType:
countByEnumeratingWithState:objects:count:
initWithIdentifier:andType:
initFrom:to:withType:
.cxx_construct
fProxy
fDataBuffer
fCurrentBlock
fCurrentBlockIdentifier
fCurrentBlockDataIdentifier
fCurrentBlockStartTime
fCurrentBlockTimestamp
fDataBufferPtr
fDataBufferLength
fCurrentIdentifier
fStartingIdentifier
fRetrievedDataBufferIdentifier
fBlockOffset
fAccelUnpacker
fGyroUnpacker
fCachedData
fMetaArray
fDataType
_newMetaUsingMessage:withIdentifier:forType:
setIdentifier:
setDataType:
sendMessageSync:onConnection:timeoutAfter:withReplyHandler:
setStartTime:
setEndTime:
fileDescriptor
setRate:
setMetaIdentifier:
writeSensorDataToFile:from:to:forType:
setSensorSampleRate:forType:
fInternalQueue
isRecordingAvailableForType:
tccServiceMotionAccessWithLabel:
sensorDataFromDate:toDate:forType:
timeIntervalSinceDate:
dateByAddingTimeInterval:
validateTimesFromDate:toDate:
sendSensorDataToUrl:fromDate:toDate:forType:
fileHandleForWritingToURL:
absoluteString
removeItemAtURL:error:
recordDataType:forDuration:
setDuration:
isAccelerometerRecordingAvailable
isGyroRecordingAvailable
isAuthorizedForRecording
accelerometerDataSinceId:
gyroDataSinceId:
accelerometerDataFromDate:toDate:
gyroDataFromDate:toDate:
sendAccelDataToUrl:fromDate:toDate:
sendGyroDataToUrl:fromDate:toDate:
recordAccelerometerForDuration:
recordGyroForDuration:
accelerometerDataFrom:to:
recordAccelerometerFor:
accelerometerDataSince:
setAccelSampleRate:
setGyroSampleRate:
date
vendor
proxyForService:
dumpDatabase:onCompletion:
initWithMode:
mode
register:forNotification:registrationInfo:
unregister:forNotification:
fTimestamp
_internalLogItem
dataWithPropertyList:format:options:error:
bytes
length
dataWithBytes:length:
propertyListWithData:options:format:error:
initWithBytesNoCopy:length:freeWhenDone:
handleFailureInFunction:file:lineNumber:description:
clientLocation
timeZoneWithName:
initForWritingWithMutableData:
setRequiresSecureCoding:
finishEncoding
initWithString:
isEqualToString:
loadPreferences
stopWakeGestureUpdates
isWakeGestureAvailable
defaultCenter
onNotificationControl:
addObserver:selector:name:object:suspensionBehavior:
removeObserver:name:object:
delegate
wakeGestureManager:didUpdateWakeGesture:
respondsToSelector:
userInfo
invokeDelegateWithState:
onWakeUpdated:
onPowerStateUpdated:
onBacklightServiceUpdated:
stringForNotification:
stringForMode:
stringForStartPose:
stringForViewPose:
stringForGestureState:
playAlert
logWakeLatency
hasSlowBootArgs
startWakeGestureUpdates
simulateGestureWithDelay:Duration:
.cxx_destruct
fPrivateQueue
gestureUpdatesStarted
fWakeDispatcher
fPowerStateDispatcher
fWakeGestureVisitor
fCurrentState
fMeasureLatencyState
fWakePacketTimestamp
fIoNotifyPort
fIoNotification
backlightService
fLastNotificationTime
fScreenDimmingNotificationToken
fLockScreenToken
fLastDisplayOnTime
fProcessName
fIsRunningInPrimaryProcess
fEnableLatencyAlert
fEnableAudioAlert
fLatencyAlertThreshold
_stopOdometerUpdates
odometer
odometer:didUpdateGpsAvailability:
getExecutablePathFromPid:
setTotalDistance:
totalDistance
setStartDate:
setAverageSpeed:
distance
currentSpeed
averageSpeed
initWithDistance:startDate:endDate:currentSpeed:averageSpeed:
initWithOdometer:
_startDaemonConnection
_startOdometerUpdatesWithHandler:
setOdometer:
fCallbackQueue
fGpsAvailability
_odometer
_totalDistance
_averageSpeed
_startDate
odometerProxy
startOdometerUpdatesForActivity:withHandler:
stopOdometerUpdates
setDelegate:
_delegate
_odometerProxy
initWithStartDate:recordId:sourceId:
maxExerciseMinuteDataEntries
setRotationRate:
initWithRotationRate:
initWithRotationRate:andTimestamp:
data
setValid:
setAdaptedNotifier:
initWithData:destructor:
onNotification:withData:
initWithCatherine:confidence:timestamp:
catherine
confidence
_catherine
_confidence
_startWithHandler:
_handleStartStopResponse:handler:
initWithUUIDString:
initWithSessionId:
_isTracking
_stopWithHandler:
_querySpringDataFromRecord:handler:
fTrackingStarted
isTracking
startWithHandler:
stopWithHandler:
querySleepDataFromRecord:handler:
resetBytesInRange:
isCallHandednessAvailable
onCallHandednessStateUpdated:
callHandednessManager:didUpdateState:
startCallHandednessUpdates
stopCallHandednessUpdates
fDispatcher
resourcePath
initWithAge:gender:height:weight:condition:
gender
genderString:
height
weight
condition
initWithAge:gender:height:weight:
fAge
fGender
fHeight
fWeight
fCondition
initWithKey:silo:vendor:
sharedInstance
newIsolatedUniverseWithOnlySilo:
newSharedVendorUniverseWithSilo:
self
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
conformsToProtocol:
zone
hash
superclass
debugDescription
_silo
_vendor
initWithStartDate:firedDate:alarmType:didWake:
firedDate
didWake
alarmType
fFiredDate
fAlarmType
fDidWake
arrayWithCapacity:
arrayWithArray:
_startUpdatesFromRecord:handler:
_queryExerciseMinutesFromRecord:handler:
_startUpdatesWithHandler:
lastObject
numberWithInteger:
UUIDString
UUID
_stopUpdates
fAppQueue
fStartedUpdates
fMostRecentRecord
isExerciseMinuteAvailable
startUpdatesFromRecord:handler:
stopUpdates
startUpdatesWithHandler:
queryExerciseMinutesFromRecord:handler:
initWithBool:
initWithInt:
liftMotionManagerDidRegisterForNotifications:
liftMotionManagerDidUnregisterForNotifications:
liftMotionManagerDidReceiveNotification:liftTransition:
registerForLiftNotifications
unregisterForLiftNotifications
fDelegate
fAccelerometerDispatcher
fLiftDetector
fSender
fPrevLiftState
main
setUnderlyingQueue:
initWithFormat:
stationary
_startListeners
_stopListeners
_handleAlarmFire:
manager
name
setObject:forKey:
alarmDidRegister:error:
copyPropertiesFromAlarm:
alarmDidUnregister:error:
removeObjectForKey:
repeats
alarmId
remoteAppLaunchedWithResult:error:
isValid
alarmDidFire:error:
instance
_registerAlarm:error:
_unregisterAlarm:error:
_acknowledgeAlarm:error:
_launchRemoteAppWithError:delegate:
fAlarms
fListening
initWithName:
initWithName:type:duration:repeats:
setManager:
unregisterAlarmWithName:error:
acknowledgeAlarmWithName:error:
registerAlarmWithName:type:duration:repeats:error:
launchRemoteAppWithError:
unregisterAlarm:error:
acknowledgeAlarm:error:
_name
_setSession:withCompletionHandler:
_handleQueryResponse:withHandler:
unsignedIntegerValue
_queryAbsoluteNatalimetryDataSinceRecord:withHandler:
_queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:
_startAbsoluteNatalimetryDataUpdatesWithHandler:
_stopAbsoluteNatalimetryDataUpdates
_promptsNeeded
fResendActivityOverrideOnInterrupt
fActivityOverride
numberWithFloat:
setUserProfile:error:
isPaceAvailable
_shouldAllowMotionCalibrationPromptsForSession:
briskMinuteMetsThreshold
activeMetsThreshold
userProfile
defaultUserProfile
setUserInfo:error:
resetCalibrationDataWithError:
isNatalimeterAvailable
computeRestingCaloriesAtRate:user:duration:
computeTimeToActiveCalories:user:workoutType:
setSession:withCompletionHandler:
queryAbsoluteNatalimetryDataSinceRecord:withHandler:
queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:
startAbsoluteNatalimetryDataUpdatesWithHandler:
stopAbsoluteNatalimetryDataUpdates
getSupportedMetricsForSession:
promptsNeededForSession:
setMagneticField:
initWithMagneticField:
initWithMagneticField:andTimestamp:
isAnomalyDetectionAvailable
startAnomalyDetection
stopAnomalyDetection
ackAnomalyEvent:withResolution:
contentsOfDirectoryAtPath:error:
reverseObjectEnumerator
objectEnumerator
fDeviceMotionLiteClientQueue
setFDeviceMotionLiteClientQueue:
fDeviceMotionLiteFusedHandler
setFDeviceMotionLiteFusedHandler:
fDeviceMotionLitePhysicalDeviceID
setFDeviceMotionLitePhysicalDeviceID:
fAccelerometerUpdateInterval
fGyroUpdateInterval
fDeviceMotionUpdateInterval
fMagnetometerUpdateInterval
fShowsDeviceMovementDisplay
fDeviceMotionLiteService
_fDeviceMotionLiteClientQueue
_fDeviceMotionLiteFusedHandler
_fDeviceMotionLitePhysicalDeviceID
initWithDeviceMotionLite:andDeviceID:
availableAttitudeReferenceFrames
sharedManager
isAccelerometerAvailable
isAccelerometerActive
setAccelerometerUpdateInterval:
accelerometerUpdateInterval
accelerometerData
startAccelerometerUpdatesToQueue:withHandler:
startAccelerometerUpdates
stopAccelerometerUpdates
isGyroAvailable
isGyroActive
setGyroUpdateInterval:
gyroUpdateInterval
gyroData
startGyroUpdates
startGyroUpdatesToQueue:withHandler:
stopGyroUpdates
isDeviceMotionAvailable
isDeviceMotionActive
setDeviceMotionUpdateInterval:
deviceMotionUpdateInterval
attitudeReferenceFrame
deviceMotion
startDeviceMotionUpdatesToQueue:withHandler:
startDeviceMotionUpdates
startDeviceMotionUpdatesUsingReferenceFrame:
startDeviceMotionUpdatesUsingReferenceFrame:toQueue:withHandler:
stopDeviceMotionUpdates
setShowsDeviceMovementDisplay:
showsDeviceMovementDisplay
dismissDeviceMovementDisplay
isMagnetometerAvailable
isMagnetometerActive
setMagnetometerUpdateInterval:
magnetometerUpdateInterval
magnetometerData
startMagnetometerUpdatesToQueue:withHandler:
startMagnetometerUpdates
stopMagnetometerUpdates
isDeviceMotionLiteAvailable
startDeviceMotionLiteUpdatesForDeviceID:usingConfiguration:toQueue:withFusedHandler:
startDeviceMotionLiteFusedUpdatesForDeviceID:toQueue:withHandler:
stopDeviceMotionLiteUpdatesForDeviceID:
setObject:forKeyedSubscript:
unarchiveObjectWithData:
reason
archivedDataWithRootObject:
initWithSignificantElevationSample:
activity
initWithMotionActivity:
isMoving
isWalking
isRunning
isDriving
maybeExitingVehicle
hasExitedVehicle
fActivity
enumerateKeysAndObjectsUsingBlock:
startWatchdogCheckinsPrivate
stopWatchdogCheckinsPrivate
initWithPriority:
startGestureUpdatesWithHandlerPrivate:
stopGestureUpdatesPrivate
fPriority
fGestureHandler
fWatchDogTimer
isGestureServiceEnabled
isGestureServiceAvailable
setGestureServiceEnabled:
setGestureHandler:
gestureHandler
disconnect
connect
startActivityUpdatesWithHandlerPrivate:
stopActivityUpdatesPrivate
overrideOscarSideband:withState:
simulateMotionState:withState:
fActivityHandler
fSubscribedToMotionState
fSidebandOverrideSemaphore
fSidebandOverrideQueue
fSidebandOverrideWaiting
fSidebandOverrideResult
fMotionStateSimSemaphore
fMotionStateSimQueue
fMotionStateSimWaiting
fMotionStateSimResult
setActivityHandler:
activityHandler
isFloorCountingAvailable
numberOfSteps
numberOfPushes
floorsAscended
floorsDescended
activeTime
currentPace
currentCadence
isOdometerDistance
isOdometerPace
initWithStartDate:endDate:steps:distance:floorsAscended:floorsDescended:recordID:currentPace:currentCadence:activeTime:sourceId:isOdometerDistance:isOdometerPace:pushes:workoutType:
_internalQueryPedometerDataFromDate:toDate:onQueue:withHandler:
isStepCountingAvailable
localizedDescription
_handleRecordQueryResponse:withHandler:
sendMessage:withReply:
_queryPedometerDataFromDate:toDate:withHandler:
_startPedometerUpdatesFromDate:withHandler:
_stopPedometerUpdates
_queryPedometerDataSinceDataRecord:withHandler:
_startPedometerEventUpdatesWithHandler:
_stopPedometerEventUpdates
_strideCalibrationDump
_queryPedometerCalibrationBinsWithHandler:forType:forRemote:
fStepCountFromStart
fPushCountFromStart
fStepCountOffset
fPushCountOffset
fDistanceFromStart
fDistanceOffset
fFloorAscendedStart
fFloorAscendedOffset
fFloorDescendedStart
fFloorDescendedOffset
fActiveTimeFromStart
fActiveTimeOffset
fValidStartDate
fStopUpdates
fFloorCountingAvailable
fPaceAndCadenceAvailable
fEventHandler
fStopEventUpdates
fWorkoutType
pedometerProxy
_pedometerDataWithRecordID:
isFileURL
path
fileExistsAtPath:
createFileAtPath:contents:attributes:
dataWithJSONObject:options:error:
writeToURL:atomically:
isDistanceAvailable
isCadenceAvailable
isPedometerEventTrackingAvailable
queryPedometerDataFromDate:toDate:withHandler:
startPedometerUpdatesFromDate:withHandler:
stopPedometerUpdates
queryPedometerDataSinceRecord:withHandler:
queryPedometerDataSinceDataRecord:withHandler:
startPedometerEventUpdatesWithHandler:
stopPedometerEventUpdates
sendStrideCalibrationHistoryToFile:
queryRawSpeedToKValueBinsWithHandler:
queryRemoteRawSpeedToKValueBinsWithHandler:
queryStepCadenceToStrideLengthBinsWithHandler:
queryRemoteStepCadenceToStrideLengthBinsWithHandler:
_pedometerProxy
getBiasWithMagneticField:acceleration:
setBias:withMagneticField:level:magnitude:inclination:
removeLastObject
becameFatallyBlocked:
sync:
initWithIdentifier:
valid
isSupported
getSilo
performSyncOnSilo:invoker:
beginService
endService
registerDelegate:inSilo:
setOpaqueTag:
forget:
doAsync:
doAsync:withReply:
syncgetDoSync:
syncgetPendingSetBiasCount
syncgetLookupBiasWithMagneticField:acceleration:bias:level:noResults:
initWithInboundProtocol:outboundProtocol:
universe
notifier
adaptee
async:
invalidate
initWithClient:
interfaceWithProtocol:base:
proxyForRecipientObject:inSilo:withInboundInterface:andOutboundInterface:
cl_json_serializeValue:
cl_json_serializeKey
dictionaryWithDictionary:
floatValue
unsignedIntValue
_endDate
_distance
_currentSpeed
fetchGeomagneticModelData:
showCalibrationAlert
dismissCalibrationAlert
_feedFitnessMachineData:
feedFitnessMachineData:
decodeInt64ForKey:
decodeInt32ForKey:
encodeInt64:forKey:
encodeInt32:forKey:
initWithDataType:
setTimestamp:
setDataIdentifier:
setOffset:
setDataSize:
dataType
movement
setMovement:
_movement
_offset
_dataSize
_dataType
_startTime
_timestamp
_dataIdentifier
endTime
_endTime
metaIdentifier
_metaIdentifier
duration
_duration
rate
_rate
unknown
walking
running
automotive
cycling
isVehicleConnected
isVehicleWifiHint
isVehicleGpsHint
isVehicleBasebandHint
isVehicleMotionHint
isVehicleBTHint
fState
isPickupAvailable
onPickupStateUpdated:
pickupManager:didUpdateState:
startPickupUpdates
stopPickupUpdates
initWithInteger:
averageActivePace
maxPedometerEntries
workoutType
fNumberOfSteps
fDistance
fFloorsAscended
fFloorsDescended
fCurrentPace
fCurrentCadence
fActiveTime
fIsOdometerDistance
fIsOdometerPace
fNumberOfPushes
initWithEventDate:type:
eventStringFromType:
fDate
decodeIntForKey:
encodeInt:forKey:
initWithOrientation:andTimestamp:
orientation
fOrientation
onDeviceOrientation:
fSampleLock
fDeviceOrientationDispatcher
fDeviceOrientationHandler
fDeviceOrientationQueue
fDeviceOrientationSemaphore
fDidSignalSemaphore
fOrientationCallbackMode
fEnableOrientationNotification
fLatestDeviceOrientationSample
fLastSignificantOrientationSample
currentThread
isMainThread
isMultiThreaded
dummySelector:
detachNewThreadSelector:toTarget:withObject:
initPrivate
onMotionPreferencesUpdated
deallocPrivate
removeObserver:
stopDeviceOrientationUpdatesPrivate
onNotification:
setDeviceOrientationCallbackModePrivate:
startDeviceOrientationUpdatesPrivateToQueue:withHandler:
isDeviceOrientationAvailable
signalAndReleaseSemaphoreIfNecessaryPrivate
updateAggregateDictionaryPrivate
orientationNotificationsDisabled
stringForOrientation:
initialize
isDeviceOrientationActive
startDeviceOrientationUpdatesToQueue:withHandler:
stopDeviceOrientationUpdates
deviceOrientationBlocking
setMode:
fMode
initWithQueue:andBlock:
dispatchWithState:andError:
fQueryQueue
fQueryBlock
isPocketStateAvailable
onPocketStateUpdated:
queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:
addToAggdScalarWithName:andScalar:
translateInternalState:
externalStateToString:
removeAllObjects
pocketStateManager:didUpdateState:
_disableDispatcher
queryStateOntoQueue:withTimeout:andHandler:
fQueryTimer
fCachedState
fMaxMonitorTime
fQueryBlocks
initWithDate:liftTransition:
liftTransition
fLiftTransition
getUUIDBytes:
initWithRecordId:sourceId:sessionId:eventTime:eventType:
eventTime
eventType
eventTypeName:
convertToSpringTrackerEntry:
initWithSpringEntry:
fEventTime
fEventType
areStatsAvailable
setStatsEnabled:
setStatsEnabled:onCompletion:
sendStatsDataToUrl:
sendStatsDataToUrl:onCompletion:
_feedCatherine:confidence:timestamp:
internal
feedCatherine:confidence:
setDateFormat:
stringFromDate:
arrayWithObjects:count:
componentsJoinedByString:
stringByAppendingPathComponent:
syncgetGyroStatsWithBias:slope:l2Error:isDynamic:deltaBias:deltaSlope:deltaError:isDeltaDynamic:
syncgetMaxDynamicTemperature
startFactoryGYTT
syncgetBiasFit:
syncgetNonFactoryRoundCount
syncgetSupportsMiniCalibration
syncgetLastMiniCalibration
syncgetInsertWithBias:variance:temperature:timestamp:
syncgetWipeDatabase
syncgetNumTemperatures
isServiceEnabled:
begin
state
valueOut
initWithValueOut:begin:end:state:
lowerQuartile
center
upperQuartile
_valueOut
_begin
_end
_state
URLsForDirectory:inDomains:
objectAtIndex:
bundleIdentifier
firstObject
isMotionActivityEntitled
fileHandleForWritingToURL:error:
seekToFileOffset:
readDataOfLength:
writeData:
logDirectory
copyDataFrom:to:
fire
trigger
activityAlarmAvailable
listenForActivityAlarm:
stopListeningForActivityAlarm:
fAlarmCounter
fReplyQueue
fAlarmAvailable
setTrigger:
activityAlarmInfo
initWithTrigger:duration:onQueue:withHandler:
initWithTrigger:duration:onRunLoop:withHandler:
fIsValid
fRunLoop
_trigger
_queryStepCountStartingFromInternal:to:toQueue:withHandler:
_startStepCountingUpdatesToQueue:updateOn:withHandler:
fPrevStepCount
stepcounterProxy
queryStepCountStartingFrom:to:toQueue:withHandler:
startStepCountingUpdatesToQueue:updateOn:withHandler:
stopStepCountingUpdates
enabled
getTotalCountToQueue:withHandler:
deleteHistory
setEnabled:
_stepcounterProxy
decodeObjectForKey:
unsignedLongLongValue
numberWithUnsignedLongLong:
tilt
rawAcceleration
rawRotationRate
machTimestamp
isUsingCompass
physicalDeviceUniqueID
gyroTemperature
compassTemperature
rawMagneticField
fRawAcceleration
fRawRotationRate
fMachTimestamp
fUsingCompass
fGyroTemperature
fCompassTemperature
fRawMagneticField
fPhysicalDeviceUniqueID
assertOutside
newTimer
afterInterval:async:
timer
shouldFire
queue
reflectNextFireTime:fireInterval:
setTimer:
initWithDispatchSilo:
source
setSource:
_source
initInSilo:withScheduler:
setName:
initWithUnderlyingQueue:
initMain
operationQueue
_queue
_operationQueue
updateScheduler
setNextFireAfterDelay:
setNextFireTime:
setFireInterval:
setNextFireAfterDelay:interval:
setNextFireTime:interval:
handler
setHandler:
nextFireTime
fireInterval
_scheduler
_handler
_nextFireTime
_fireInterval
rangeOfString:options:
hasSuffixInsensitive:
numberOfArguments
methodReturnLength
hasPrefix:
getArgumentTypeAtIndex:
initWithSelector:andMethodSignature:
numArguments
replyBlockIndex
returnAddressIndex
returnValueSize
_numArguments
_replyBlockIndex
_returnAddressIndex
_returnValueSize
_sel
_sig
_str
signatureWithObjCTypes:
initWithProtocol:base:
appendString:
appendFormat:
getInfoForSelector:
protocol
_selectors
_protocol
_startElevationUpdatesWithHandler:
_stopElevationUpdates
_startSignificantElevationUpdatesWithHandler:
_stopSignificantElevationUpdates
_querySignificantElevationChangeFromDate:toDate:withHandler:
fFilteredPressureDispatcher
fRelativeAltimeterHandler
fRelativeAltimeterQueue
fBaseAltimeterSample
fBarometricBaseAltitude
fBaselineReceived
fPressureSamples
fSignificantElevationSampleHandler
fElevationAscendedOffset
fElevationDescendedOffset
onFilteredPressure:
cancelAllOperations
stopRelativeAltitudeUpdatesPrivate
isRelativeAltitudeAvailable
startRelativeAltitudeUpdatesPrivateToQueue:withHandler:
isSignificantElevationAvailable
startRelativeAltitudeUpdatesToQueue:withHandler:
stopRelativeAltitudeUpdates
startSignificantElevationUpdatesWithHandler:
stopSignificantElevationUpdates
querySignificantElevationChangeFromDate:toDate:withHandler:
isElevationAvailable
startElevationUpdatesWithHandler:
stopElevationUpdates
_handleUpdates:
strokeCount
lapCount
segment
strokeType
initWithRecordId:sourceId:sessionId:startDate:endDate:strokeCount:distance:avgPace:lapCount:strokeType:segment:
_querySwimUpdatesFromRecord:handler:
fStrokeCountOffset
fLapCountOffset
fSegmentCountOffset
maxSwimDataEntries
querySwimUpdatesFromRecord:handler:
initWithName:type:duration:repeats:alarmId:bundleId:state:
setAlarmId:
bundleId
setBundleId:
setState:
acknowledgeWithError:
unregisterWithError:
_repeats
_type
_alarmId
_bundleId
_manager
avgPace
strokeTypeName:
convertToSwimEntry:
initWithSwimEntry:
fStrokeCount
fAvgPace
fLapCount
fStrokeType
fSegment
initWithDelegateInterface:proxiedInterface:delegateObject:delegateSilo:andUninitializedPeer:
initWithDelegateInterface:proxiedInterface:andUninitializedPeer:
null
selector
argumentsRetained
getArgument:atIndex:
raise:format:
setTarget:
retainArguments
invoke
setArgument:atIndex:
delegateSilo
invokeWithTarget:
methodSignatureForSelector:
forwardInvocation:
delegateInterface
proxiedInterface
_peer
_asymStrongPeer
_last
_opaqueTag
_delegateSilo
_delegateInterface
_proxiedInterface
initWithOnBodyResult:confidence:timestamp:
result
fResult
fConfidence
inboundInterface
outboundInterface
setSilo:
setVendor:
isHydrated
_valid
_inboundInterface
_outboundInterface
setKeyedPayloads:
keyedPayloads
setPayload:forKey:
getPayloadForKey:
removePayloadForKey:
setPayload:forSelector:
removePayloadForSelector:
getPayloadForSelector:
_keyedPayloads
logAssert
initTrackingServiceClass:
svcClass
residentCount
setResidentCount:
synCount
ackCount
_synCount
_ackCount
_residentCount
_svcClass
array
sortUsingComparator:
insertObject:atIndex:
dictionary
rereadConfiguration
allKeys
setWithArray:
unionSet:
containsString:
containsObject:
getServiceWithName:
setServiceReplacementMap:missBehavior:
retireServiceWithName:
isServiceRunning:
ensureServiceIsRunning:
proxyForService:forClient:
getSiloForService:
_catalog
_serviceReplacementMap
_unavailableServiceNames
_missBehavior
setElapsedTime:
setTotalEnergy:
setTotalElevationAscended:
setTotalStrideCount:
setTotalStrokeCount:
setTotalFloorsClimbed:
setInstantaneousSpeed:
setInstantaneousCadence:
setInstantaneousPower:
setInclination:
setResistanceLevel:
convertToCLFitnessMachineData:
elapsedTime
totalEnergy
totalElevationAscended
totalStrideCount
totalStrokeCount
totalFloorsClimbed
instantaneousSpeed
instantaneousCadence
instantaneousPower
inclination
resistanceLevel
_elapsedTime
_totalEnergy
_totalElevationAscended
_totalStrideCount
_totalStrokeCount
_totalFloorsClimbed
_instantaneousSpeed
_instantaneousCadence
_instantaneousPower
_inclination
_resistanceLevel
isOnBodyStatusDetectionAvailable
startOnBodyStatusDetectionPrivateToQueue:withParameters:handler:
stopOnBodyStatusDetectionPrivate
sharedOnBodyStatusManager
startOnBodyStatusDetectionToQueue:withParameters:handler:
stopOnBodyStatusDetection
setPropertiesWithDictionary:
fSubscribedToOnBodyStatusDetection
fOnBodyStatusQueue
fOnBodyStatusHandler
setData:
setDestructor:
destructor
_data
_destructor
_client
notifierClientNumForCoparty:
_clients
_notifier
_handleDaemonEvent:
_startWorkout:
_unregisterForWorkoutEvents
_handleDaemonResponse:
workoutManagerDidFail:workout:error:
workoutManagerDidStartWorkout:workout:startDate:
workoutManagerDidStopWorkout:workout:stopDate:
workoutManagerWillPauseWorkout:workout:pauseDate:
workoutManagerWillResumeWorkout:workout:resumeDate:
workoutManagerSuggestedStop:workout:stopDate:
_stopWorkout:
_setSuggestedStopTimeout:
_registerForWorkoutEvents
fWorkout
fResumeWorkoutOnInterrupt
startWorkout:
stopWorkout:
supportedMetricsForWorkoutType:
setSuggestedStopTimeout:
DeviceMotionLite %s using compass
Jump in message sequence number: last=%d, this=%d
Updating mag timestamp to %llu
FusedWithStatus msgType,%u,infoByte,%u
On-start data from remote seqNo,%u,fLastOnStartDebugSeqNo,%u,bufferSize,%zu
Jump in on-start sequence numbers last,%u,this,%u
OnStartMsg: %s
Discarding %zu bytes from onstart packet
Accumulated %zu bytes for onstart packet
Jump in fused packet sequence number last,%u,this,%u,rtc,%u,byte,%u
handleFusedStruct(WithStatus) fLastFusedSeqNo,%u,seqNo,%u,rtc,%u,byte,%u
Sysdiagnose packet. Write out the data!
Session metrics packet. Push it to the right place
Empty payload, returning
DeviceMotionLite,VendorData,size,%{public}ld
DeviceMotionLite debug fragment, paylaodSize=%lu, fLength=%d, fSequence=%d, fragBufferLen=%lu
Received invalid payload length %d
Dropping remaining %lu bytes in fragment buffer
Not dropping %lu bytes in fragment buffer
Jump in packet sequence number: last=%d, this=%d
Skipping, buffer size %lu < packet size %lu
Zero size struct, or somehow ring buffer size ran out
called event handler function, remaining bytes: %lu
Unknown msgType: %d
msgType=%d, fragBufferLength=%lu
DeviceMotionLite: unhandled size %{public}ld
SedentaryAlarm,Error response,%{public}d
SedentaryAlarm,Error start / stop response,%{public}d
SedentaryAlarm,Error start / stop response.
SedentaryAlarm,Error query response,%{public}d
SedentaryAlarm,Error parsing alarm data.
Error occurred while trying to retrieve motion state update: CMErrorDomain Code:%{public}d
Unable to parse kCLConnectionMessageMotionActivityUpdate message!
[CLFilteredPressure] Unrecognized notification: %d
Type,%s,pressure,%.6f,temperature,%.3f,timestamp,%f
{"msg%{public}.0s":"[CLCompass7FastPath] Fast path unsupported on this platform!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLCompass7FastPath] Initializing fast path
[CLCompass7FastPath] Failed fast path set up for CLCompass,serviceRef,%p
[CLCompass7FastPath] Unable to establish fast path with valid clientID,serviceRef,%p
[CLCompass7FastPath] Fast path has been initialized,clientID,%u,serviceRef,%p,course,%s
[CLCompass7FastPath] Fast path has been closed,clientID,%u
[CLCompass7FastPath] Setting fast path update interval to %f
{"msg%{public}.0s":"[CLIoHidFastPathInterface] buildDevice should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Adding new FastPathDevice
non-matching retain (%p) and release (%p) functions in context, ignoring
Failed to initilize fHeadingCalibrationDisplayMutex, error code: %{public}d
CLClient is deprecated. Will be obsolete soon. (%{public}s)
CL: _CLClientCreateWithBundleIdentifierAndPath
{"msg%{public}.0s":"_CLClientCreateWithBundleIdentifierAndPath", "event":%{public, location:escape_only}s, "effectiveBundleIdentifier":%{public, location:escape_only}@, "effectiveBundlePath":%{public, location:escape_only}@}
{"msg%{public}.0s":"client allocated", "client":"%{public}p"}
Location manager created on a dispatch queue exectuing on non-main thread, notifying client
#warning Could not register with daemon immediately, will retry later
Discarding message for event %{private}d because of too many unprocessed messages
Location callback block not executed in a timely manner!
received client will resign active notification
received client did become active notification
Missing UsageDescription key for requested authorization: %{public}d
Invalid requested authorization: %{public}d
CL: CLClientIsLocationServicesEnabled
{"msg%{public}.0s":"CLClientIsLocationServicesEnabled", "event":%{public, location:escape_only}s}
CLInternalGetLocationServicesEnabled failed: could not reach daemon
Fence: CLClientRequestRegionState, unsupported fence type
function '%{public}s' deprecated - noop
Invalid call to CLClientGetAutopauseState
malformed message: kCLConnectionMessageAutopauseStatus
CL: _CLClientCreateConnection
{"msg%{public}.0s":"_CLClientCreateConnection", "event":%{public, location:escape_only}s, "client":"%{public}p"}
CL: CLClientInterruptionHandler
{"msg%{public}.0s":"CLClientInterruptionHandler", "event":%{public, location:escape_only}s, "client":"%{public}p"}
Got unhandled message %s from daemon
{"msg%{public}.0s":"CLCompass7 requires device motion service", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
VEHICULAR: failed notify_register_check, error, %d
VEHICULAR: failed notify_get_state, error, %d
VEHICULAR: failed notify_cancel, error, %d
VEHICULAR HINTS: failed notify_register_check, error, %d
VEHICULAR HINTS: failed notify_get_state, error, %d
VEHICULAR HINTS: failed notify_cancel, error, %d
***no run loop available***
#Warning Changing CLCommon's runloop after it was already established
#Warning Setting CLCommon's runloop after it was already established
CLCommonSetRunLoop, %p
cannot open source file: %{public}s, errno %{public}d
cannot open target file: %{public}s, errno %{public}d
error reading source file: %{public}s
error writing target file: %{public}s
cannot open compression stream: %{public}s, bzerror %{public}d
error writing target file: %{public}s, bzerror: %{public}d
error closing target file: %{public}s, bzerror: %{public}d
CLCommonGzipDecompressFile, can't stat, %{public}s
CLCommonGzipDecompressFile, from, %s, to, %s, size, %llu, cTime, %.1lf, isOK, %d
CLCommonGzipDecompressFile, can't open, file_path_to, %{public}s, errno %{public}d
CLCommonGzipDecompressFile, can't open, file_path_from, %{public}s, errno, %{public}d
CLCommonGzipDecompressFile, error reading source file: %{public}s, errno, %{public}d, read, %{public}d
CLCommonGzipDecompressFile, can't write, %{public}s, errno, %{public}d, write, %{public}zu
CLCommonGzipDecompressFile, from, %s, to, %s, isOK, %d, fileSize, %llu, totalReadBytes, %u, totalWrittenBytes, %u, compression, %.4lf
http date string is converted to timestamp %.3f and adjusted to %.3f by %.3fs RTT (%.3fs diff from systime)
GPS_NETWORK: enabled %d found %d
Timer set loop: %d %f %f %f %f
CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than their reference frames: (%lf, %lf, %d) (%lf, %lf, %d)
#Warning CLCommonGetFileTimestamps, failed to stat file, %s, ret, %d
CLCommonTouchMTimestamp, utimes failed, ret, %{public}d, file, %{public}s
TILE: delete file, %s
TILE: stat, %s, ret, %d, mtime, %lu, ctime, %lu, size, %lld
TILE: unlink, %s, ret, %d
failed, invalid filename
failedToOpen, errno, %d
failed,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d,errno,%d
done,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d
CL: CLGyroBiasEstimatorClientRemote::registerWithGyroBiasEstimatorPrivate
{"msg%{public}.0s":"CLGyroBiasEstimatorClientRemote::registerWithGyroBiasEstimatorPrivate", "event":%{public, location:escape_only}s, "isBuildingGYTT":%{public}hhd, "client":"%{public}p", "info":"%{public}p"}
Default handler received message %s
Could not get dictionary for message
Message does not contain a valid gyro bias object
CL: CLGyroBiasEstimatorClientRemote::onWatchdogTimerExpiry
{"msg%{public}.0s":"CLGyroBiasEstimatorClientRemote::onWatchdogTimerExpiry", "event":%{public, location:escape_only}s, "client":"%{public}p"}
unable to create fPrivateQueue
Sent kCLConnectionMessageWatchdog message
CL: CLGyroBiasEstimatorClientRemote::unregisterWithGyroBiasEstimatorPrivate
{"msg%{public}.0s":"CLGyroBiasEstimatorClientRemote::unregisterWithGyroBiasEstimatorPrivate", "event":%{public, location:escape_only}s, "client":"%{public}p"}
processed %p %d to (%s)
could not create new mutable dictionary
could not deserialize property list from %{public}s
file %s does not exist... clearing, error, %s
#Warning Error reading file %{public}s: %{public}s
Could not create NSURL for file: %{public}s
Could not write data to disk %{public}s
Could not serialize data for file %{public}s
key %{public}s does not have element %{public}d in array of size %{public}ld
key %{public}s does not have element %{public}d in non-array type %{public}lu
type IDs do not match for key %{public}s - %{public}lu vs %{public}lu
specified index is out of range for key %{public}s (%{public}d of %{public}ld)
specified index %{public}d not applicable to type %{public}lu for key %{public}s
could not create cf type for key %{public}s
could not create write stream
could not open write stream
could not write data, error code, %{public}ld, error domain, %{public}s
could not create intermediate property list - %{public}ld (%{public}s)
dictionary, %s, NULL
%s = <dictionary (%ld entries)>:
%s = %s
%s = %0.6f
%s = %d
%s = <unhandled value type %lu>
could not get value
type IDs do not match - %{public}lu vs %{public}lu
could not convert to C string
can't convert %{public}u data bytes
type IDs do not match - %{public}lu
dictionary, %s, key, %s, value, %s
dictionary, %s, key, %s, value, %.8lf
dictionary, %s, key, %s, value, %d, 0x%08x
dictionary, %s, key, %s, value, %d, [CFBoolean]
dictionary, %s, key, %s, value, %.2lf, [CFDate]
dictionary, %s, key, %s, un-printable value
#Warning TIMEOUT: Waited %f seconds to aquire lock '%s' (%p)
{"msg%{public}.0s":"CSI assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning TIMEOUT: Held lock '%s' (%p) for %f seconds
9-axis sensor fusion is not supported on this platform.  Returning.
North reference overridden as %d by first client
Type,%s,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
correctedCompassExt, %.3f, %.3f, %.3f, %u, %u
unknown hardware type %{private}d
device SN date info type:%{private}zd - date:%{private}d %{private}d %{private}f
Invalid year/week code
Failed to allocate CFCalendar
CFCalendarComposeAbsoluteTime() failed
Cannot get weekday
Cannot get week
Invalid serial number format: %{private}s
CAMP: device id [%d] [%s], camping support [%d]
#Warning SUPL: ignoring hw. forceSuplSupport,%d
#Warning LPP: ignoring hw. forceLppSupport,%d
#Warning Overriding BeaconFenceBestEffortAlways,%d
zoneBestEffortAlwaysEnabled,%d
#Warning GNSSRF: overriding peak antenna gain, %d tenth-dB
GNSSRF: no config for %d
GNSSRF: peakAntennaGain,%d,gpsLoss,%d,gloLoss_0,%d,gloLoss_minus7,%d,gloLoss_plus6,%d
#Warning PLOS: ignoring hw. forceSupport,%d
#Warning OBM, ignoring hw. forceSupport,%d
data for wifi-antenna-sku-info found
Device SKU:%s
wifi-antenna-ski-info property not found.
service for class wlan NOT found.
class wlan NOT found.
Workout, pool length %f for workout is too small and may lead to undefined behavior.
could not get mutable store path for type, %{public}d
Unknown persistent domain: %{public}d
could not create path %{public}s
#Warning persistent store %s has been modified - refreshing will lose changes
#Warning data set %s is not changeable - not storing
%s stored to disk %s
{"msg%{public}.0s":"Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
scheduling to auto-store %s every %.3fs
disabling auto-store for %s
***not supported***
<empty>
Attempt to set key %{public}s for read-only preferences %{public}s/%{public}s!
Error occurred while trying to retrieve accelerometer record!
Error occurred while trying to retrieve accelerometer records!
Successfully wrote accelerometer data to file.
Error occurred while trying to write accelerometer data to file!
Successfully set sensor sample rate.
Error occurred while trying to set sensor sample rate!
Error occurred while trying to retrieve accelerometer data!
Response invalid.
#Notice -[%{public}s %{public}s] fromDate has been adjusted so that the duration requested is <= 12 hours.
#Notice Unable to get file handle for URL %{public}@
registering for keyboard updates
#Warning Failed to register for keyboard updates. Could not register for AppleHIDKeyboardEventDriverV2 service kIOFirstMatchNotification and kIOTerminatedNotification.
#Warning Failed to register for keyboard updates. Could not create KeyboardConnectNotificationPort and KeyboardConnectNotificationPort
unregistering for keyboard updates
Legacy compass, interval (%.3f) gyro (%d)
Legacy compass started. Cover attached %d
Dumped compass cal database with id %@
Compass is requesting device motion with mode 0x%x
Legacy compass stopped.
Notify after %.3f seconds of no event.
Type,%s,compassJustAlignedToStableField,%d,timestamp,%20.20f
Type,%s,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
notified clients. sampleCount,%d,compass.compass.calibrationLevel,%d,compass.timestamp,%f
CL: CLGetControlPlaneStatusReport
{"msg%{public}.0s":"CLGetControlPlaneStatusReport", "event":%{public, location:escape_only}s, "clear":%{public}d}
Blocking Mig routine deferred on Daemon side... waiting and retrying
CL: CLInternalSetAuthorizationStatusByType
{"msg%{public}.0s":"CLInternalSetAuthorizationStatusByType", "event":%{public, location:escape_only}s}
CL: CLSetLocationAuthorizationForApplication
{"msg%{public}.0s":"CLSetLocationAuthorizationForApplication", "event":%{public, location:escape_only}s, "bundleId":%{public, location:escape_only}@, "authorized":%{public}hhd}
CL: CLCopyAppsUsingLocation
{"msg%{public}.0s":"CLCopyAppsUsingLocation", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"not a dictionary", "TypeID":%{public, location:escape_only}@, "description":%{private, location:escape_only}@}
CL: CLCopyTechnologiesInUse
{"msg%{public}.0s":"CLCopyTechnologiesInUse", "event":%{public, location:escape_only}s}
List of technologies in use is not an array -- type ID %{public}lu
CL: CLPingDaemon
{"msg%{public}.0s":"CLPingDaemon", "event":%{public, location:escape_only}s}
CLInternalSetLocationServicesEnabled failed
CLInternalSetGestureServiceEnabled failed
Couldn't send bundle identifier!
Couldn't send bundle path!
CL: CLInternalPerformMigration
{"msg%{public}.0s":"CLInternalPerformMigration", "event":%{public, location:escape_only}s}
_CLIntegrityCheck failed with result: %{public}d
_CLShutdownDaemon failed with result: %{public}d
_CLDisplayStatistics failed with result: %{public}d
_CLDumpLogs failed with result: %{public}d
_CLCopyLastLog failed with result: %{public}d
Returned type is not a dictionary
CL: CLSetLocationDefault
{"msg%{public}.0s":"CLSetLocationDefault", "event":%{public, location:escape_only}s, "key":%{public, location:escape_only}@}
Key is NULL!
Couldn't set location default!
CL: CLGetLocationDefault
{"msg%{public}.0s":"CLGetLocationDefault", "event":%{public, location:escape_only}s, "key":%{public, location:escape_only}@}
CL: CLStartStopAdvertisingBeacon
{"msg%{public}.0s":"CLStartStopAdvertisingBeacon", "event":%{public, location:escape_only}s, "region":%{private, location:escape_only}@, "power":%{public, location:escape_only}@}
Unexpected pressure bias notification.notification,%d
Setting pressure data update interval to %f
Unrecognized pressure notification %d
Pressure Temperature=%d
Could not create instance of CLGestureService. Is wake gesture supported on this platform?
Process: %{public}@, IsPrimary: %{public}d
Failed to register for backlight service notification
Backlight level notification (%{public}llu)
Unable to send display state
Start Wake Gesture Updates
Stop Wake Gesture Updates
Simulating gesture: delay,%f,duration,%f,success,%d
Unable to invoke delegate. Please call startWakeGestureUpdates first.
Loaded Preferences. Latency Alert: %d, Latency Threshold: %d, Audio Alert: %d
Gesture state %{public}zd is invalid!
Gesture state updated to %{public}d
Invalid CMSendWakeGestureNotification payload!
Gesture notification: %{public}d(%{public}@), Mode:%{public}@, Start:%{public}@, End:%{public}@, HostAwake, %{public}d
Gesture state notified,%{public}@,currentTime,%{public}f
No valid delegate found.
Failed with CMError code %{public}d
CMOdometer client connection interrupt, %@, %d, %p
Unable to parse kCLConnectionMessageOdometerUpdate message!
#Warning The requested activity %ld is not yet supported
#Warning Unsupported activity requested
%{public}s; client %{public}d does not exist
%{public}s; notification %{public}s not found
CL: notifyClientsWithData (Fallback)
{"msg%{public}.0s":"notifyClientsWithData", "event":%{public, location:escape_only}s, "name":%{public, location:escape_only}s, "notification":%{public}lld}
%s; client %d has deregistered, not notifying %s
%{public}s; unknown client %{public}d
%s; already shutdown; not listing clients
%s; listing clients, num clients: %zu
%s; clients, id: %d, notification: %d
successfully got GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
Warning: can't get GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
Failed with error, %{public}d
Client connection interrupt, %@, %d, %p
Error responding to start / stop tracking request, handler unavailable.
Error parsing start / stop response.
Error parsing query response.
Invalid cpas data.
The cpas data is not a CFData type.
#Warning Cpas data is NULL.
#Warning Cpas pointer is NULL.
Unexpected cpas version: %u.
Original serial number data is NULL.
Original serial number pointer is NULL.
Invalid back camera serial number data.
Incorrect back camera serial number length. Actual length %ld. Expected length %lu.
Current serial number data is NULL.
Bailing while checking VCM actuator ID.
VCM actuator ID data type %d does not match expected type %d
#Warning CPAS data is NULL.
#Warning CPAS pointer is NULL.
Started CallHandedness updates. Current Time: %f
CallHandedness service already started!
Stopped CallHandedness updates. Current Time: %f
CallHandedness service already stopped!
CallHandedness Detection: %ld
CMPickupService Spectators, %zd
CMPickupService stopped, %zd
CMPickupService started, %zd
CMPickupService expects only 1 client
#Warning No accelerometer; not starting CMPickupDetector detection!
Starting PickupDetector detection with accelFrequency %.1f
Sending CMPickupDetector notification.
Closing PressureSample
Can't open %s: %s
Found PressureSample table already in %s
No PressureSample table in %s
Can't create table in %s: %s
Can't create index in %s: %s
Can't create insert statment in %s: %s
Table PressureSample invalid
Table PressureSample INSERT bind error %d %s
Table PressureSample insertion error %d %s
Can't create query %s
Table %s invalid
%s is invalid
%s has no runs for clause %s
Calculating PRTT median for %s
Feeding %f %f to median estimator
Problem running through %s for %s
Invalid stat for run %s
min kPa = %f for %s
No bin for %d; dropping
n and g are too close %f
Assertion failed: lambda2 != 0, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMOQuaternion.cpp, line 208,invalid weights.
kappa zero!
Assertion failed: i < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMVector.h, line 272,invalid index %zu >= %zu.
Assertion failed: ldx < M*N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 78,invalid element %zu >= %zu.
Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 71,invalid row %zu > %zu.
Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 72,invalid col %zu > %zu.
Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 64,invalid row %zu > %zu.
Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/Math/CMMatrix.h, line 65,invalid col %zu > %zu.
Doing crude accel measurement update.
rotBufferSize, %zu, accelBufferSize, %zuu, peakCount, %d, fMaxStd, %.3f
gyroDt, %.4f, doAccelCheck, %d
omegaMag6, %.3f, omega, %.3f, %.3f, %.3f
[AppleQuaternion] x,%f,y,%f,z,%f,w,%f,timestamp,%f
[Bias,Var] bias.x,%f,bias.y,%f,bias.z,%f,var.x,%f,var.y,%f,var.z,%f
[Accelerometer6] x,%.4f,y,%.4f,z,%.4f,lpf, %.4f, %.4f, %.4f, timestamp,%lf
[RotationRate6X] %.3f, %.3f, %.3f, %.3f, %.3f
rotating and going through.
it's been too long. go through.
grabing gravity, %.4f, %.4f, %.4f
std, %.3f, %.3f, %.3f, mag, %.3f, dot, %.3f, leftover, %.3f
sum, %.3f, %.3f, %.3f, dot, %.3f, leftover, %.3f
===========Skip ahead.
Skip ahead------.
Taking another look.
using mean accel
accM, (%.4f, %.4f, %.4f), mag, %.3f
Doing some crude updates to catch up.
[KalmanFilterStates] %f,%f,%f,%f,%f,%f,%f
Could not create event system client. All bets are off
Event system client initialized successfully
Trying to set properties for unknown event %d
Unknown event %d
Could not convert NSString to C++ string
Unknown event: %d
Unknown event %u
%s hid driver interface for event %u, hidServiceRef %p
Service with event type %d is not ready
IOHIDEventSystemClientCopyServices() returned NULL
Service ref with usage pair {%d,%d} (event %d) is %p
DeviceMotionLite %s compass
IOHIDServiceClientSetProperty() returned false
IOHIDServiceClientSetProperty() successfully set property for event %d
Property for usage pair {%d,%d}: {%s = %@} was set %s
Could not set all properties. Setting timer to fire %f seconds from now
Could not set all properties after too many retries. Giving up.
Properties for event %d:
Removing set matching multiple
Adding touch event,hidUsagePage,%d
Adding match entry for usage pair {%d,%d}
Setting matching multiple
Unhandled usage %d
Received null sender
It looks like our HID event system just become available (again)
New IOHIDServiceClientRef for usage pair {%d,%d} just became available.
Event type %d, old hidserviceref,%p,new,%p
Releasing value for property %s, address = %p
Setting accelerometer update interval to %f
Unrecognized notification
Setting batch interval to %f
Unrecognized notification %d
Type,%s,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f
Could not get ideal gyro update interval, assuming %{public}f s
Setting gyro data update interval to %f
Type,%s,dt,%f
Setting gyro temperature update interval to %f
Unrecognized gyro notification %d
Type,%s,ret=%d
[CLGyro] x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d,now,%f
ExericseMinute, Failed with CMError code %{public}d
ExericseMinute, client connection interrupt, %@, %d, %d, %p
ExerciseMinute, Error stopping updates, no active clients.
ExerciseMinute, Unable to parse update.
ExerciseMinute, Unable to parse query.
Setting magnetometer update interval to: %d us
Setting magnetometer batch interval to: %d us
Setting magnetometer update interval to %f
Unrecognized magnetometer notification %d
Received magnetometer offset (%f, %f, %f)
Unknown notification %d
Requested update interval cannot be == 0.0 and dispatcher cannot be NULL. Use interval < 0.0 for spectator.
CLMotionNotifier::addDispatcherPrivate UpdateInterval is zero!
CLMotionNotifier::addDispatcherPrivate Added dispatcher for notification:%d, Update Interval:%f(%.1fHz)
Unknown (notification,dispatcher) pair: (%d, %p)
CLMotionNotifier::setUpdateIntervalPrivate RequestedUpdateInterval:%f, UpdateInterval:%f
CLMotionNotifier::updateSamplePeriod UpdateInterval:%f
{"msg%{public}.0s":"CMLiftManager does not run on this platform", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Could not get parent thread parameters
Motion runloop ref still not set!
LogSensorAscii,%d
Could not get scheduling parameters for motion thread, error = %{public}d
could not create runloop source
Ping timer fired, resetting watchdog
Motion thread deadlock watchdog after %d petting
Failed to create watchdog timer
Motion thread exiting
CLMotionCore::SleepBounce
CLMotionCore::PoweredOnBounce
willResignActiveBounce
didBecomeActiveBounce
Could not subscribe to system power notifications
enabled detection successfully
Device Stationary?, %s, Orientation, %s, Proximity, %s
Transition, From: %s, To: %s, %s
%f: Device Stationary?, %s, Orientation, %s, Proximity, %s, State, %s
disable Detection
%f: monitorTime, %f, bksMonitorTime, %f, bksDelay, %f, proxStatus, %s
%f: ProxDelay,%f
Proximity detection mask: %u, Last prox state: %s
received WillSleep
received WillPowerOn
received HasPoweredOn
CMMotionAlarmManager client connection interrupt, %@, %d, %d, %p
Tearing down CMMotionAlarmManagerInternal
Unable to stop MotionAlarm data updates as we are are not receiving updates.
Unable to register motion alarm. No delegate assigned.
Unable to register motion alarm. Invalid alarm object.
Unable to parse kCLConnectionMessageMotionAlarmRegister message.
Unable to unregister motion alarm. No delegate assigned.
Unable to unregister motion alarm. Invalid alarm object.
Unable to parse kCLConnectionMessageMotionAlarmUnregister message.
Unable to acknowledge alarm, alarm does not exist.
Unable to call kCLConnectionMessageMotionAlarmAcknowledge message. Code: %d
Unable to parse kCLConnectionMessageMotionAlarmAcknowledge message.
Unable to fire motion alarm. Received invalid message response.
Unable to fire motion alarm %@. Could not locate valid alarm to fire.
Calorie response failed with error %{public}d
Unable to set activity session on interrupted connection.  locationd and framework client states are not in sync!
#Notice %{public}s (%{public}d) setting session %{public}d %{public}p
Unable to set session. Unexpected user error
Unable to set session. Error code %{public}d
#Notice %{public}s (%{public}d) received status %{public}d after setting session %{public}d %{public}p
%@, pid, %d, query since record, %@, %p
%@, pid, %d, update, %@, %p
Error parsing update.
Error stopping calorie updates, not active clients.
Prompts needed response invalid.
Querying for calibration prompts encountered an error: %{public}ld.
UserProfile, Invalid response
UserProfile, Error while setting, %{public}d
Unable to reset calibration data. Error code %{public}ld.
Invalid response to reset calibration.
TimeToActiveCalories is negative: timeToActiveCalories, %f, %{private}@
TimeToActiveCalories, %f, target, %f, workoutType, %ld, %{private}@
Failed parse os_log format specifier for shimming:missing closing brace,format,%{public}s
{"msg%{public}.0s":"Device motion 6 service is not supported on this platform!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning stackshot only available on device
Failed to get current position for fd %{public}d: %{public}s
Failed to get size of fd %{public}d: %{public}s
Failed to restore to original position of fd %{public}d: %{public}s
Failed to create decryptor. status = %{public}d
Failed to open input file '%{public}s' to decrypt: %{public}s
Failed to get size of input file %{public}s
Failed to open temporary output file '%{public}s' to save '%{public}s' to '%{public}s': %{public}s
Decrypting '%s' to '%s' via temporary file '%s'
Failed to read from '%{public}s'.  %{public}lld bytes read successfully.  %{public}s
Failed to decrypt '%{public}s'.  %{public}lld input bytes decrypted successfully. %{public}d
Failed to write to '%{public}s'.  %{public}lld input bytes decrypted & written successfully. %{public}s
Failed to finalize decryption of '%{public}s': %{public}d
Failed to write final %{public}zu bytes to '%{public}s': %{public}s
Failed to rename '%{public}s' to '%{public}s'. Decryption of '%{public}s' failed: '%{public}s'
Decryption of '%{public}s' failed.  Also failed to unlink temporary file '%{public}s': %{public}s
Not an accelerometer packet
Motion manager can not start device motion lite updates, use isDeviceMotionLiteAvailable before using this API
Motion manager asked to start device motion lite updates for device id %@
Motion manager asked to stop device motion lite updates for device id %@
Received fused sample
{"msg%{public}.0s":"deferredDelete() should have nulled out connection", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"deferredDelete() should have nulled out handler", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"CLConnections must always have event queues", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning Unhandled message %s
CL: CLConnection::handleInterruption
{"msg%{public}.0s":"CLConnection::handleInterruption", "event":%{public, location:escape_only}s}
CL: CLConnection::handleDisconnection
{"msg%{public}.0s":"CLConnection::handleDisconnection", "event":%{public, location:escape_only}s}
CL: CLConnection::sendMessageInternal (Fallback)
{"msg%{public}.0s":"CLConnection::sendMessageInternal", "event":%{public, location:escape_only}s, "name":%{public, location:escape_only}s}
Couldn't create XPC message
The received data object is invalid: %{public}s
Unable to send reply, a reply message does not exist.
#Warning Connection interrupted!
#Warning Location connection invalid!
Got unexpected location event
Error on message reply (%{public}s)
Ignoring unexpected event
rotBufferSize9, %zu, accelBufferSize, %zuu, peakCount, %d, compassBufferSize, %zu
gyroDt9, %.4f, doAccelCheck, %d
fAccelBuffer,size,%zu
omegaMag9, %.3f, omega, %.3f, %.3f, %.3f
[AppleQuaternion9] x,%f,y,%f,z,%f,w,%f,timestamp,%f
[Accelerometer9] x,%f,y,%f,z,%f,timestamp,%lf
[RotationRate9] %.3f, %.3f, %.3f, %.3f
[KalmanFilterStates9] %f,%f,%f,%f,%f,%f,%f
[KalmanFilterStates9-AccelUpdate] %f,%f,%f,%f,%f,%f,%f
[CompassIntoKF] timestamp,%f,calibration level %d, compassHasAlignedToStableField %d, useMagneticRefX %d
[CompassIntoKF] fLastAccelTime,%f
[CompassIntoKF] magneticFieldAdjusted!
rotAroundGrav, %.3f, sum, %.3f
[CompassIntoKF] omegaMag, %.3f, omegaVar, %.3f
FieldDiff, %.3f, %.3f, %.3f, %.3f
Aborted yawUpdate.
Checking again for magField. checkcount, %d
fCorrected, %.3f, %.3f, %.3f
[!!!CompassInertialReference] x,%f,y,%f,z,%f,calibrationLevel,%d,timestamp,%lf
Warning: Compass outputs field magnitude 0.
[!!!CompassInertialReference] x,%f,y,%f,z,%f
UpdatingYaw!
[Magnetometer9] x,%f,y,%f,z,%f,timestamp,%lf
Warning: Hey! Compass outputs field magnitude 0.
[ExpectedCompass] %f,%f,%f,%f
[TrueCompass] %f,%f,%f,%d,%f
[MagCCross] %f,%f,%f,%f,%f,%f,%f,%f,%f,%f
[MagCorrectionDX] %f,%f,%f,angle,%.3f,sumRot,%.3f,%f
Setting handler for message %s
CL: CLConnectionClient::sendMessage(cache) (Fallback)
{"msg%{public}.0s":"CLConnectionClient::sendMessage(cache)", "event":%{public, location:escape_only}s}
#Warning Sending an un-cached message '%{public}s' without first clearing the previously cached value
CL: CLConnectionClient::sendMessage(reply) (Fallback)
{"msg%{public}.0s":"CLConnectionClient::sendMessage(reply)", "event":%{public, location:escape_only}s}
received daemon start notification for service %s
Creating connection
Destroying connection
CL: Sending cached messages to daemon
{"msg%{public}.0s":"Sending cached messages to daemon", "event":%{public, location:escape_only}s}
#Warning No cached registration message
Could not get dictionary for kCLConnectionMessageGesture
Unexpected ear gesture state received: %{public}s
#Notice Calling ear gesture handler
Could not get dictionary for kCLConnectionMessageMotionState
Error occurred while trying to retrieve activity update: CMErrorDomain Code:%{public}d
Unable to parse kCLConnectionMessageMotionState message!
Could not parse dictionary for kCLConnectionMessageSidebandOverride
Could not parse dictionary for kCLConnectionMessageMotionStateSim
Timeout occurred after 5 seconds during overrideOscarSideband:withState:.  Wait result = %{public}ld
%s,%f,%s,%f
%s,%f,%s,%d
%s,%f,%s,%f,%s,%f,%s,%f,%s,%d
Unable to parse message (%{public}@) when starting updates to queue
Unable to parse message when starting updates to queue!
nil pedometer event dictionary received
Error pedometer event, %{public}ld
Unrecognizable pedometer event dictionary
CMPedometer client connection interrupt, %@, %d, %p
Error occurred: %{public}@
Unable to parse message (%{public}@) for query response 
Unable to parse message when checking for availability!
Successfully wrote stride calibration data to file.
Error occurred while trying to write stride calibration data to file!
Remote calibrations not available on this platform
handler not set.
fileURL must be a valid fileURL.
File already exists at URL.
URL must point to a file path which you have access to write to.
Unable to dump stride calibration data.
Unable to serialize stride cal data to json. Error: %@
Unable to write stride cal data to output file.
RotationStability buffer not set.
Could not set bias retrieved from database
setting bias (%.3f/%.3f/%.3f) level (%d)
reset internal. levels-data(%d %d %d), pScale=%.3f 
compass calibrator reset
Resetting calibrator states.
Resync after long coasting with mag drift. mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), Age(%d,%d)
DRIFT DETECTED. numBad=%d,s=%.3f,delH(%.3f,%d,%.3f), expectedVec (%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d),deltaTime(%.3f)
fBackupInfoSet(%d), syncAge(%d)
Likely bad resync. Backup. 
RESYNC Rejected. numBad=%d,mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), syncAge(%d)
numBad(%d), delH(%.3f), coastVec(%.3f/%.3f/%.3f), expectedVec(%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d)
Coasting vector not set.
Prolonged high magDiff. Likely bad calibration. Resetting.
Extremely high magnitude.  magDiff (%.3f), magnitude (%.3f), calibrated (%.3f/%.3f/%.3f), coastVector (%.3f/%.3f/%.3f),coastingTime,%.3f,magDiffVar,%.3f,resetInternal,%d
******* scale(%.3f),cAge(%d), magDiff(%.3f), dHeading(%.3f), deltaAngle(%.3f), numBad(%d), calInc(%.3f), incDiffIsStable(%d)
Steep inclination. Likely bad interference or bad database lookup. Resetting. 
Interference is gone.
**INTERFERENCE-1 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
**INTERFERENCE-0 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
Likely bad database lookup. Resetting. 
Divergence!!! Resetting.
new internal estimates (%.3f %.3f %.3f)
taking new estimates, Internal. fIsCoasting (%d)
new estimates denied, fIsCoasting (%d)
taking new estimates, reached database. (%d)
new esitmates disagree with database. (%d,%d,%.3f)
calibrated, first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
taking new estimates, fIsCoasting (%d)
estimates improved.(%.3f/%.3f/%.3f), numImprov=%d 
new estimates needed, fIsCoasting (%d)
first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
new estimates calculated, converged(%d %d %d) Var (%.3f %.3f %.3f), remain (%.3f), level (%d), num=%d 
Bad heading divergence for too long. Prompt user to re-calibrate.
Waiting too long for internal re-calibration. Prompt user.
Waiting too long for high magnitude interference to go away. Exit coasting.
Coasting for too long. Exit coasting.
fCoastingVecPrint: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f
Attitude data not set.
Type,%s,Updating reference frame.
Updating during coasting, fIsResetInternal(%d)
BACKUP resync coasting vector
resync coasting vector. rotM,%.3f,rotV,%.3f
device status: (smooth static) = (%d %d), rotM,%.3f,rotV,%.3f, q.x,%.3f,q.y,%.3f,q.z,%.3f,q.w,%.3f)
coasting vector is mature, no more updating
numSamplesSkipped (%d), deltaQ (%.3f/%.3f/%.3f/%.3f), deltaReadingM (%.3f)
bias.x,%.3f,bias.y,%.3f,bias.z,%.3f,scale.x,%.5f,scale.y,%.5f,scale.z,%.5f,extF.x,%.3f,extF.y,%.3f,extF.z,%.3f
set coasting vector (%.3f/%.3f/%.3f), levels (%d %d) conv(%d %d %d) age (%d) syncAge (%d) DueTo (%d)
enters coasting
compass calibrator logging (%d)
exits coasting
sample rate (%.3f) observation rate (%.3f) observation threshold (%.3f) deviation count threshold (%d) standard deviation threshold (%.3f)
threshold (%f) was exceeded with observed value (%f) and base value (%f) and standard deviation (%f) and count of (%d)
mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd), coverAttached (%d)
mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd)
Begin.
Too few points.  End.
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,1
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,0
End.
using attitude dependent KF calibrator
compass ignoring database (%d)
compass using manual bias (%.3f/%.3f/%.3f)
compass ignoring calibration (%d)
compass input filter is using (%zuu) samples
compass heading output filter samples (%d) scale (%f)
apple compass calculator, sample rate (%.3f) ignoreDatabase (%d) manual (%d)
XYDevice not stable. %d, %d, %.3f, Clearing search buffers.
storing new compass calibration, magneticField (%+.3f,%+.3f,%+.3f), bias (%+.3f/%+.3f/%+.3f), level (%d) magnitude (%+.3f) inclination (%+.3f)
rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f
#Warning Heading  %.2f, is not in bound [0 360]
magnitude max threshold exceeded (%+.3f), resetting calibration
magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
CompassDB restored bias (%+.3f/%+.3f/%+.3f)
{"msg%{public}.0s":"lookupBias was called on the base CLCompassDatabase class"}
Parameters: theta0, %f, theta1, %f, theta2, %f, theta3, %f, theta4, %f, theta5, %f, minLowPower, %f, maxLowPower, %f, maxHighPower, %f, lowBandStart, %d, lowBandStop, %d, highbandStart, %d, highBandStop, %d, wakeThreshold, %f, oddsThreshold, %f, medianFilterSize, %u, confidenceThreshold, %f, useHysteresis, %d, useAngleOverride, %d, angleMetricThreshold, %f
Using the manufacturer specific parameters (%s): %s
Using the default parameters: %s
#Warning Using the hardcoded parameters
Invalid parameters received:
%{public}s
fLocationdConnection is not NULL
Could not get geomagnetic model data for message!
fLocationdConnection is NULL
Unable to load CompassUI framework
Could not load CUICalibrationClass from CompassUI framework
CMFitnessMachine client connection interrupt, %@, %d, %p
Error feeding fitness machine data
Error feeding fitness machine data, %@
CMCallHandednessService Spectators, %zd
CMCallHandednessService stopped, %zd
CMCallHandednessService started, %zd
CMCallHandednessService expects only 1 client
#Warning No accelerometer; not starting CMCallHandedness detection!
Starting CallHandedness detection with accelFrequency %.1f
Sending CMCallHandedness notification.
#Warning CPAS data response was invaild.
#Warning CPAS data is NULL
cpas version is %u, length is %ld bytes
Warning: cpas data was found but did not match any versions. version (%u) length (%ld)
Magnetometer coexistence compensation is disabled
Assertion failed: temperature != 3.40282347e+38F, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMNonlinearTemperatureFit.cpp, line 79,temperature,%f.
{"msg%{public}.0s":"Fast path unsupported on this platform!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Unable to establish fast path with valid clientID,serviceRef,%p,properties,%@
Fast path has been initialized,clientID,%u,serviceRef,%p,useMag,%d,mode,%d,interval,%f
Fast path is being closed,clientID,%u,serviceRef,%p,useMag,%d,mode,%d,interval,%f
Event ref invalid
Unexpected device motion report type %d, returning
Application state changed, %d
%s cover attached logic to %d
Registered for cover state notifications
Could not create timer
Cover %s attached
Cover %s
Keyboard %s
Device still has original rear camera. Using unit-specific calibration info
Rear camera was replaced. VCM actuator ID is %d
Using generic Mitsumi calibration info
Using generic Alps calibration info
Unrecongized VCM actuator. Not performing compensation
Started pickup detection updates
Pickup detection already started!
Stopped pickup detection updates
Pickup detection service already stopped!
Pickup Detection: %{public}ld
VCM Delta.x,%f,VCM Delta.y,%f,VCM Delta.z,%f
Rear camera offset.x,%f,Rear camera offset.y,%f,Rear camera offset.z,%f
Could not register for notification %s
focus position = %d
Could not get state for %s
camera state = %d
camera mode = %d
Received focusing notification
Received camera state notification
Received camera mode notification
Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d
Bad pressure bias from daemon.
Orientation Manager initialized
OrientationCallbackMode,%{public}d,EnableOrientationNotification,%{public}d
The orientation %{public}d is not in bounds
Starting orientation updates
Stopping orientation updates
Notifications disabled
Received orientation. (%{public}@ to %{public}@) Timestamp %{public}f
Updating client handler: Orientation %{public}@, Callback mode: %{public}d
Received deviceOrientationBlocking
No viable convertion for mode 0x%x
No viable convertion for notification 0x%x
CLDeviceMotion::setDeviceMotionUpdateInterval changing update interval to: %f
CLDeviceMotion::addDeviceMotionDispatcher adding dispatcher with property: %s
CLDeviceMotion::removeDeviceMotionDispatcher removing dispatcher with property: %s
CLDeviceMotion::minimumUpdateIntervalChanged,notification,%d,minimumUpdateInterval,%f
CLDeviceMotion::numberOfClientsChanged notification:%d, from:%zu, to:%zu
numberOfClients GyroOnly:%zd, 3AxisDynamicGyro:%zd, 6Axis:%zd, 6AxisThrottledGyro:%zd, 9Axis:%zd, 9AxisWithNorthReference:%zd, BuildGYTT:%zd
{"msg%{public}.0s":"9Axis should be running", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Device motion mode (%d) not supported, can't process client change
Unsupported mode (%d). Returning.
Unsupported mode (%d). Compass not found. Returning.
Unsupported mode (%d). Couldn't do DeviceMotion without Gyro. Returning.
Starting device motion, mode=0x%{public}x,useAccelerometer=%{public}d,useGyro=%{public}d,useCompass=%{public}d,fUseNorthRef=%{public}d,buildingGYTT=%{public}d
Stopping device motion, mode=0x%x
Device motion mode (%d) not supported, unable to disable sensor fusion
Device motion mode (%d) not supported, unable to get device motion
creating the BinaryLog instance
creating fInstance = new CLBinaryLog()
kCLBinaryLogDirectory not set!
#Notice Logging binary sensor data to %{public}s
Failed to determine if log rotation is needed. errno, %{public}d, %{public}s
#Warning Failed to move aside log file %s to %s (%d)
#Warning Unable to open %s
Pocket state disabled by defaults write
disabling dispatcher
ADClient: %s + %llu
QueryRequest,%f
%f: query started with timeout %f
Query aborted
QueryTimerFire,%f
%f: query response external=%u (%s), cbcount=%lu
timer fired even though fQueryTimer is NULL
Attempted to exceed max monitor time %f, %f
Query timer failed to initialize
The pocket state %d is not in bounds
#Warning refAlt < %.1lf,refAlt,%.1lf,using the min
#Warning refAlt > %.1lf,refAlt,%.1lf,using the max
latitude,%.7lf,is out of bounds
#Warning, same coordinates input
Registering for SBHasSeenACaseLatchCoverNotification.
hwType, %{public}d
Unknown iPad HW %{public}d
isPad %{public}d
forceAccelOnly for device %{public}d
fOrientationGyroTimeout,%{public}f,fEnableGyroTimeout,%{public}d,fMaxAccelerationVarianceForStability,%{public}f
Not starting orientation detection since requested accelerometer frequency < 0
No accelerometer; not detecting orientation!
No gyro; not detecting orientation!
fHasSeenACaseLatchCoverOnce, %{public}d
Starting orientation detection with accelFrequency %{public}f, isIpad, %{public}d, decimationRate, %{public}d
Stopping orientation detection.
Sending orientation changed notification
Device is in motion, re-enabling Gyro.
Device is stationary and OrientationGyroTimeout exceeded, disabling Gyro.
GYRO: Sending orientation changed notification
Invalid dynamics, mag, %.2f, xyVarMax, %.2f, xMean, %.2f
Invalid xyNorm, %.2f
Invalid tilt, %.2f
Invalid swivel, %.2f
Swing1. xMag, %.2f, maxXYVar, %.2f, swingX, %.2f
Swing2. X sign flipping.
Passed swing-detect. hand, %d, xMag, %.2f, maxXYVar, %.3f, swingX, %.3f
Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 96,mean() on empty buffer.
Assertion failed: i < fCapacity, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMQueue.h, line 174,i,%zu,capacity,%u.
Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 213,variance() on empty buffer.
Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 148,back() on empty buffer.
Assertion failed: !empty(), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMVectorBuffer.h, line 142,front() on empty buffer.
#Notice Response invalid.
{"msg%{public}.0s":"CLCompass7 requires deviceMotionService", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Compass for AOP started. CoverAttached %d
Compass for AOP stopped.
Setting compass update interval to %f
Unable to set compass update interval
Type,%s,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,calibrated.x,%.8f,.y,%.8f,.z,%.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1f,level,%d,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,initalized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,timestamp,%f
gyroFrequency,%.3f,gyroBufferSize,%d,gyroMeanBufferSize,%d,zRotBufferSize,%d,minRequiredZrots,%d
accelBufferSize,%d
Accelerometer samples data gap or out of order! deltaInterval=%.4f
accel, %.3f, %.3f, %.3f, timestamp, %.20f
Gyro samples data gap or out of order! deltaInterval=%.4f
gyro, %.3f, %.3f, %.3f, gyroMean, %.3f, %.3f, %.3f, fLastDetection,%d,fStartZrot,%d, timestamp, %.10f
zRot (%.3f, %.3f, %.3f), mean(%.3f, %.3f, %.3f), var(%.3f, %.3f, %.3f)
Likely transient.
Slowing. decrement numZRot,delta, %.3f, numZRot, %d
ZDROP detected. deltaDrop, %.3f, fNumZDrops, %d
mostlyZ, %d, zRotMean.z, %.3f, zRot, %.3f, numZRots, %d, estCurr, %.3f, totalZ, %.2f, mag2MinusGrav, %.2f
Going through with 180 turn.
Rotating around Z. numSamples: %d, numAccu, %d, zRotVar, %.3f
SCREEN FLAT. NOT FILLING UP ZROT BUFFER.
Transient!
Rotating! Current max gyro rate %.3f
Setting lastPrimaryOrientation.
Nixed rotationAroundZ state.
Ready for orientation change via rotation
Not filling Zrot buffer.
acc variance, %.3f, %.3f, %.3f, acc mean, %.3f, %.3f, %.3f, maxVar, %.3f, mag2,%.3f
Resetting stable count
Within magic angle limits: Threshold %.4f, Delta %.4f
Ipad %d: screenJustTurnedOn, %d, deltaTime %.5f
allowShallow, %d, magicCaseRest, %d, tiltIn, %d, wasMoving, %d, maxVar, %.5f
onStartup, x, %.3f, y, %.3f, z, %.3f
FaceUp/Down: maxWeight,%.3f, 2ndWeight,%.3f, orientation,%d
deltaWeightThreshold, %.3f, tiltWeightTheshold, %.3f, currAcc, %.3f, %.3f, %.3f, deltaWeight, %.3f, tilt, %.3f, fCurrentOrientation, %d, isMoving, %d, wasMoving, %d, fLastClearOrientation, %d, fStableCount, %d, DetectionTime, %f
Notify from, %{public}s -> %{public}s 
Disabling gyro.
Enabling gyro.
Index out of bound.
Warning: Not implemented.
Type,%s,Time,%llu,RawPressure,%f,FilteredPressureTimeStamp,%llu,FilteredPressure,%f,RawPressurePeriod,%f,StateFOF,%d,StateFIR,%d
CMPressureFilter,Time,%llu,FastPressureRate,%f,PressureDecimation,%d,PressureFilterOffset,%d,PressureFilterDelay,%d
Assertion failed: (offset >= 0) && (offset + fFullTapCount - 1 < samples.size()), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2201/Oscar/CMSymmetricFirFilter.h, line 37,offset,%d,fullTapCount,%d,samplesSize,%zu.
FunctionalCapacity, client connection interrupt, %@, %d, %d, %p
Timeout (after 5 seconds) occurred during wait!
Warning - invoking %@ on main may lead to deadlock.
TCCServiceMotionAccess timeouts!
#Notice URL must specify a file.
#Notice File already exists at URL.
#Notice URL must point to a file path which you have access to write to.
#Notice Unable to get file handle for URL %{public}s: %{public}s
[FastPath] Already initialized
[FastPath] Cannot initialize fast path when service ref is null
[FastPath] Initialization failed,serviceRef,%@,properties,%@
{"msg%{public}.0s":"[FastPath] should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[FastPath] Not initialized, nothing to close
[FastPath] Fast path not initialized! Can't copy property
[FastPath] Cannot copy property when service ref is null
[FastPath] Fast path not initialized! Can't set property %@ to %@
[FastPath] Set property failed! %@, %@
#Warning Did not find the triggered activity alarm in the current set of alarms.
Could not get dictionary for kCLConnectionMessageActivityAlarm
#Warning Was not able to listen for alarm.  Activity alarms are not available for this system.
#Warning Cannot unsubscribe from activity alarm (Trigger:%d, Duration:%f).  This alarm is not being listened for.
Unable to create sharedInstance of CMActivityAlarmProxy.
Unable to parse mesage (%{public}@) when starting updates to queue
Unable to parse mesage (%{public}@) for query response
Unable to start additional step updates while it is already active
Unable to stop step updates as we are are not receiving updates
Starting device motion service 0x%x
GyroUpdateInterval,%.4f,AccelerometerUpdateInterval,%.4f
Dumped gyro cal database with id %@
Stopping device motion service 0x%x
[CLSensorFusionService] q.x,%10.10f,q.y,%10.10f,q.z,%10.10f,q.w,%10.10f,userAccel.x,%10.10f,userAccel.y,%10.10f,userAccel.z,%10.10f,rotationRate.x,%10.10f,rotationRate.y,%10.10f,rotationRate.z,%10.10f,magneticField.x,%10.10f,magneticField.y,%10.10f,magneticField.z,%10.10f,heading,%.3f,accuracy,%.3f,level,%d,mode,%d,status,%#02x,clientID,%d,timestamp,%lf,now,%lf
Set device motion sensor status %ld
Grabbing reference pose while static, %.3f, %.3f, %.3f, varInfNorm, %.8f
Getting new reference in StableState when no reference is available yet.
Entered Stable state from being static/frozen
fStableCount, %d, maxXYVar, %.8f, xyMeanNorm, %.3f, deltaTiltMean, %.3f
Entered Stable state. timestamp, %.6f
deltaTilt, %.3f, fLiftCount, %d, z2xyRatio, %.3f, dt, %.2f
Entered Lift state. timestamp, %.6f
Unable to parse message (%{public}s) when starting updates to queue
Unable to parse message (%{public}s) for query response
relativeAltitude,%f,pressure,%f
Client connection interrupt, %@, %d, %d, %p
Unable to stop swim data updates as we are are not receiving updates.
Unable to parse query message.
%@, %@, %d, %p
Unable to parse update message.
{"msg%{public}.0s":"A delegate must be set before sending messages with byref return address parameters", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"The object passed to byref return address parameters MUST BE the registered delegate", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Adding new Device with usage pair {%d, %d}
{"msg%{public}.0s":"[CLIoHidInterface] initializeHidIfNecessary should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Could not create event system client. All bets are off
[CLIoHidInterface] Event system client initialized successfully
{"msg%{public}.0s":"[CLIoHidInterface] closeHid should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Hid interface closed
{"msg%{public}.0s":"[CLIoHidInterface] refreshDeviceServiceRefs should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Refreshing service refs
[CLIoHidInterface] Check service ref %p with usage pair {%d,%d} as a potential match
[CLIoHidInterface] Service ref with usage pair {%d,%d} is %p
{"msg%{public}.0s":"[CLIoHidInterface] invalidateDeviceServiceRefs should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] invalidating hid service refs
{"msg%{public}.0s":"[CLIoHidInterface] setPropertyIoHid should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] property can not be set for null hidServiceRef
[CLIoHidInterface] IOHIDServiceClientSetProperty() returned false
{"msg%{public}.0s":"[CLIoHidInterface] applyAllDirtyDeviceProperties should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] apply all dirty device properties
[CLIoHidInterface] Service with for device with usage pair {%d,%d} is not ready
[CLIoHidInterface] Property for usage pair {%d,%d}: {%s = %@} was set %s
[CLIoHidInterface] Could not set all properties. Setting timer to fire %f seconds from now
[CLIoHidInterface] Could not set all properties after too many retries. Giving up.
{"msg%{public}.0s":"[CLIoHidInterface] setMatchingForDevices should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] The device is gone!
[CLIoHidInterface] Prox: remove set matching multiple
[CLIoHidInterface] Adding match entry for usage pair {%d,%d}
[CLIoHidInterface] Setting matching multiple for %lu events
[CLIoHidInterface] Received null sender
[CLIoHidInterface] Processing event %d
[CLIoHidInterface] Got null event,sender %p,registryID %llx
[CLIoHidInterface] Fetching historical events
[CLIoHidInterface] Did not fetch historical events
[CLIoHidInterface] The device has no event callback, skipping.
[CLIoHidInterface] It looks like our HID event system just become available (again)
[CLIoHidInterface] New IOHIDServiceClientRef for usage pair {%d,%d} just became available.
[CLIoHidInterface] Device,usagePage,%d,usage,%d,hidserviceref,old,%p,new,%p
[CLIoHidInterface] Releasing value for property %s, address = %p
[CLIoHidInterface] setCallback should be called from motion thread
[CLIoHidInterface] setNewServiceCallback should be called from motion thread
[CLIoHidInterface] setIoHidResetCallback should be called from motion thread
[CLIoHidInterface] Could not set property value for %@
[CLIoHidInterface] setProperty should be called from motion thread
[CLIoHidInterface] copyProperty should be called from motion thread
{"msg%{public}.0s":"[CLIoHidInterface] must have event type set", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
%s hid driver interface for event {%d, %d}, hidServiceRef %p
[CLIoHidInterface] setRegistryIDChangedCallback should be called from motion thread
[CLIoHidInterface] setHistoricalTransitionCallback should be called from motion thread
[CLIoHidInterface] setEventType should be called from motion thread
{"msg%{public}.0s":"[CLIoHidInterface] should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Service for usage pair {%d, %d} is not ready
[CLIoHidInterface] Device,hidUsagePage,%d,hidUsage,%d,hasCallback,%d,serviceRef,%p
[CLIoHidInterface] 
%s = %@,dirty,%d
{"msg%{public}.0s":"The silo associated with a CLIntersiloService may not be changed once set", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"The vendor associated with a CLIntersiloService may not be changed once set", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Overrider didn't call up to super for beginService?", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Only one payload per key at at time", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"A payload must be ready for this key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"A payload must be around to remove for this key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Watch: Gesture Manager Active
Phone: Gesture Manager Active
CMWakeGestureManager is not supported on this platform!
Calling methods directly on an instance of CMWakeGestureManager is not permitted. Please use +[CMWakeGestureManager sharedManager] instead.
{"msg%{public}.0s":"_Locationd should come last?!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Crash deliberately as our final act", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Don't message _Locationd", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Heartbeat tracking commenced", "silo":%{public, location:escape_only}@}
{"msg%{public}.0s":"Heartbeat tracking terminated", "silo":%{public, location:escape_only}@}
{"msg%{public}.0s":"Deltafied deficit should be non-negative", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Heartbeat underflow; going to crash now!", "silo":%{public, location:escape_only}@}
{"msg%{public}.0s":"Only living, non-nil services should be heart-beaten", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning Heartbeat underflow", "silo":%{public, location:escape_only}@, "deficit":%{public}d}
{"msg%{public}.0s":"Heartbeat tracking already enabled", "interval":"%{public}f"}
{"msg%{public}.0s":"Heartbeat tracking resumed", "interval":"%{public}f"}
{"msg%{public}.0s":"Heartbeat tracking suspended"}
{"msg%{public}.0s":"Heartbeat tracking already disabled"}
{"msg%{public}.0s":"Service replacement map must be non-nil if set", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Existing services must not fail to map under new mapping and behavior", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Should be impossible for an existing service to fail to map under existing mapping and behavior, and must be non-nil for next test", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Old and new mappings and behaviors must agree about any service which has started", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Configuring service replacement map", "ReplacementMap":%{public, location:escape_only}@, "MissBehavior":%{public}d}
{"msg%{public}.0s":"Test and Mock services may only be looked up indirectly via -setServiceReplacementMap:", "RequestedServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"Unavailable service requested", "RequestedServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"Service replacement map does not include requested service", "RequestedServiceName":%{public, location:escape_only}@, "ReplacementMap":%{public, location:escape_only}@}
{"msg%{public}.0s":"Looking up service identified by name", "ServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"Tried to look up a service by name that doesn't exist", "RequestedServiceName":%{public, location:escape_only}@, "EffectiveServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"Requested service not isSupported", "RequestedServiceName":%{public, location:escape_only}@, "EffectiveServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"Trying to start an unavailable service", "RequestedServiceName":%{public, location:escape_only}@, "UnavailableServices":%{public, location:escape_only}@}
CL: Manufacturing service
{"msg%{public}.0s":"Manufacturing service", "event":%{public, location:escape_only}s, "RequestedServiceName":%{public, location:escape_only}@, "EffectiveServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"Failed to alloc and init key class for service", "RequestedServiceName":%{public, location:escape_only}@, "EffectiveServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"Key class for service failed to hydrate", "RequestedServiceName":%{public, location:escape_only}@, "EffectiveServiceName":%{public, location:escape_only}@}
{"msg%{public}.0s":"#warning Service retired redundantly or without ever having been started", "RequestedServiceName":%{public, location:escape_only}@}
Close hid driver interface
#Warning Gesture service is not available on this platform
numberOfSpectators,%zi
Undecodable data.,size,%zu,type,%u
Neither the queue nor the handler can be nil
{"msg%{public}.0s":"Device motion service is not supported on this platform!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
%s is enabling power conservative device motion for parallax.
%s is disabling power conservation for parallax.
Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.
Workout, client connection interrupt, %@, %d, %d, %p
Workout, START, %@, %@, %d, %p
Trying to start a swim session without using a CMSwimWorkout!  Treating this swim as an open water swim.
Workout, STOP, %@, %@, %d, %p
Workout, Registering suggested stop timeout, %@, %d, %p
Workout, nil event dictionary, %@
Workout, Error, %d, %@
Workout, ERROR, %d, %@
Workout, DID START at %f, %@
Workout, DID STOP at %f, %@
Workout, WILL PAUSE at %f, %@
Workout, WILL RESUME at %f, %@
Workout, SUGGESTED STOP at %f, %@
Workout, Unrecognized event, %@
Workout, Unrecognizable event dictionary, %@
@16@0:8
v16@0:8
B16@0:8
v40@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16@?32
v24@0:8@?16
v20@0:8B16
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_source>"
^{CLConnectionClient={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@^{CLConnection}B{CLNameValuePair=^^?^{__CFDictionary}}{CLNameValuePair=^^?^{__CFDictionary}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@?@?@@?@?}
v52@0:8@16d24d32B40@?44
v32@0:8@16@?24
@"CMSedentaryTimer_Internal"
q16@0:8
v48@0:8@16@24@32@?40
v48@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16@32@?40
@"NSOperationQueue"
@24@0:8q16
@72@0:8d16q24q32d40d48d56@64
@24@0:8@16
@24@0:8^{_NSZone=}16
v24@0:8@16
@"NSUUID"
v28@0:8{?=fff}16
@28@0:8{?=fff}16
{?="x"f"y"f"z"f}
@36@0:8{?=fff}16d28
{?=ddd}16@0:8
v24@0:8f16f20
@24@0:8f16f20
@32@0:8f16d20f28
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@64@0:8Q16@24@32@40@48@56
@24@0:8r^{CLSignificantElevation=i[16C]ddII}16
Q16@0:8
@"NSDate"
@"NSNumber"
@32@0:8@16@24
@"CMMotionTimeRange"
@"NSString"
q24@0:8q16
@32@0:8@16q24
@40@0:8@16q24d32
d16@0:8
@48@0:8@16q24@32@40
v96@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}iBBBf}16
@96@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}iBBBf}16
{?="x"d"y"d"z"d}
@"CMAttitude"
@104@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}iBBBf}16d96
{?={?=ddd}i}16@0:8
i16@0:8
v48@0:8{?=dddd}16
@48@0:8{?=dddd}16
{?="w"d"x"d"y"d"z"d}
{?=ddddddddd}16@0:8
{?=dddd}16@0:8
v24@0:8{?=ff}16
@24@0:8{?=ff}16
{?="pressure"f"temperature"f}
@32@0:8{?=ff}16d24
{?=dd}16@0:8
@48@0:8^{CMAccel100=fffQ}16Q24d32Q40
v48@0:8^{CMAccel100=fffQ}16Q24d32Q40
@48@0:8^{CMGyro50=ffffQ}16Q24d32Q40
v48@0:8^{CMGyro50=ffffQ}16Q24d32Q40
f16@0:8
Q40@0:8^{?=Q^@^Q[5Q]}16^@24Q32
@28@0:8Q16i24
@36@0:8d16d24i32
@"CMSensorRecorderInternal"
@"NSObject<OS_xpc_object>"
@"CLSensorRecorderSensorMeta"
{AccelUnpacker="fData"*"fBitsLeft"I"fPartial"C"fTimestampLast"Q"fTimestampLastDelta"q"fSampleLast"[3i]}
{GyroUnpacker="fData"*"fBitsLeft"I"fPartial"C"fTimestampLast"Q"fTimestampLastDelta"q"fSampleLast"[4i]}
@"NSMutableArray"
@"NSArray"
@36@0:8r*16Q24i32
B44@0:8@16d24d32i40
B24@0:8I16i20
@36@0:8Q16Q24i32
B20@0:8i16
@24@0:8Q16
B32@0:8^@16@24
@36@0:8@16@24i32
B40@0:8@16@24@32
B44@0:8@16@24@32i40
v24@0:8d16
v28@0:8i16d20
B20@0:8I16
@24@0:8d16
@20@0:8C16
B32@0:8d16d24
v24@0:8q16
v24@0:8r^{Sample=d^{CLGestureReport}}16
v24@0:8r^{Sample=I}16
v20@0:8I16
^{Dispatcher=^^?@}
{unique_ptr<CMWakeGestureVisitor, std::__1::default_delete<CMWakeGestureVisitor> >="__ptr_"{__compressed_pair<CMWakeGestureVisitor *, std::__1::default_delete<CMWakeGestureVisitor> >="__first_"^{CMWakeGestureVisitor}}}
^{IONotificationPort=}
@"CMOdometer"
v32@0:8q16@?24
@"<CMOdometerDelegate>"
@"CMOdometerProxy"
@40@0:8d16q24@32
@40@0:8d16d24d32
@"CMSpringTrackerInternal"
@32@0:8d16d24
v24@0:8r^{Sample=Cd}16
@"<CMCallHandednessDelegate>"
@48@0:8d16q24d32d40
@56@0:8d16q24d32d40q48
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@"CLSilo"16@0:8
@"CLServiceVendor"16@0:8
@40@0:8@16@24@32
@"CLSilo"
@"CLServiceVendor"
@44@0:8d16d24q32B40
@"CMExerciseMinuteData"
@"CMExerciseMinuteInternal"
@"<CMLiftManagerDelegate>"
^{CMLiftDetector={CLRunningVector3d<float>=^^?Q{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}}{CLRunningVector3d<float>=^^?Q{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}}{CLRunningVector3d<float>=^^?Q{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}}Bi}
@"CMLiftManager"
@"CMLiftManagerInternal"
B32@0:8@16^@24
@"NSMutableDictionary"
B44@0:8@16I24I28B32^@36
B24@0:8^@16
@"<CMMotionAlarmDelegateProtocol>"
@40@0:8Q16@24d32
d40@0:8@16@24q32
Q24@0:8q16
B24@0:8q16
@"CMNatalimeterInternal"
v32@0:8@16q24
@"<CMAnomalyDelegate>"
@?16@0:8
{unique_ptr<CLDeviceMotionLiteService, std::__1::default_delete<CLDeviceMotionLiteService> >="__ptr_"{__compressed_pair<CLDeviceMotionLiteService *, std::__1::default_delete<CLDeviceMotionLiteService> >="__first_"^{CLDeviceMotionLiteService}}}
v24@0:8Q16
v40@0:8Q16@24@?32
v44@0:8@16{?=i}24@28@?36
v40@0:8@16@24@?32
@64@0:8Q16@24@32@40Q48Q56
@88@0:8{CLMotionActivity=iiiiBfdBiddii{?=b1b1b1b1b1}}16
{CLMotionActivity=iiiiBfdBiddii{?=b1b1b1b1b1}}16@0:8
{CLMotionActivity="type"i"confidence"i"mountedState"i"mountedConfidence"i"isStanding"B"tilt"f"timestamp"d"isVehicleConnected"B"exitState"i"estExitTime"d"startTime"d"rawType"i"rawConfidence"i"vehicularFlags"{?="motionHint"b1"gpsHint"b1"basebandHint"b1"wifiHint"b1"btHint"b1}}
@20@0:8i16
v28@0:8B16q20
@"NSObject<OS_dispatch_semaphore>"
q28@0:8B16q20
v36@0:8@?16q24B32
@"CMPedometerProxy"
v32@0:8@16@24
v24@0:8^v16
v24@0:8@"NSMutableArray"16
v32@0:8@"CLSilo"16@?<v@?>24
v32@0:8@"<CLIntersiloProxyDelegateProtocol>"16@"CLSilo"24
v36@0:8R@16i24@28
v28@0:8R@16i24
v24@0:8R@16
v36@0:8R@"<CLNotifierServiceClientProtocol>"16i24@"CLNotifierData"28
v28@0:8R@"<CLNotifierServiceClientProtocol>"16i24
v24@0:8R@"<CLNotifierServiceClientProtocol>"16
v32@0:8@?16@?24
B24@0:8@?16
v52@0:8{?=fff}16{?=fff}28i40f44f48
v40@0:8{?=fff}16{?=fff}28
B64@0:8{?=fff}16{?=fff}28^{?=fff}40^i48^B56
v24@0:8@?<v@?^{CLCompassDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}>16
v32@0:8@?<v@?^{CLCompassDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}>16@?<v@?>24
B24@0:8@?<v@?^{CLCompassDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}>16
v32@0:8@"NSString"16@?<v@?@"NSString">24
v28@0:8i16@20
v28@0:8i16@"CLNotifierData"20
^{CLCompassDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}16@0:8
v24@0:8^{value_ostream=B^{ostream}}16
@56@0:8@16@24@32@40@48
v24@0:8@?<v@?^{CLGeomagneticModelProvider=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16
v32@0:8@?<v@?^{CLGeomagneticModelProvider=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16@?<v@?>24
B24@0:8@?<v@?^{CLGeomagneticModelProvider=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16
^{CLGeomagneticModelProvider=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}16@0:8
@"CMFitnessMachineInternal"
I16@0:8
v20@0:8i16
@"<CMPickupDelegate>"
@124@0:8d16d24i32d36@44@52q60@68@76@84@92@100@108i116i120
@28@0:8i16d20
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
{Sample="timestamp"d"orientation"i}
v24@0:8r^{Sample=di}16
@32@0:8@16@?24
v32@0:8q16@24
q20@0:8i16
v32@0:8@16Q24
v40@0:8@16d24@?32
v48@0:8@16d24d32@?40
@"<CMPocketStateDelegate>"
@32@0:8d16Q24
v24@0:8^{CLSpringTrackerEntry=Q[16C][16C]dq}16
@56@0:8Q16@24@32@40q48
@24@0:8r^{CLSpringTrackerEntry=Q[16C][16C]dq}16
B20@0:8B16
v28@0:8B16@?20
v40@0:8d16d24d32
v32@0:8d16d24
@"CMCatherineFeederInternal"
B72@0:8^{?=fff}16^{?=fff}24^{?=fff}32B40^{?=fff}44^{?=fff}52^{?=fff}60B68
B24@0:8^{?=id(?={?={?=fff}{?=fff}}{?=B[241c]})}16
B44@0:8r^{?=fff}16r^{?=fff}24f32d36
v24@0:8@?<v@?^{CLGyroCalibrationDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16
v32@0:8@?<v@?^{CLGyroCalibrationDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16@?<v@?>24
B24@0:8@?<v@?^{CLGyroCalibrationDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16
^{CLGyroCalibrationDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}16@0:8
@48@0:8d16d24d32q40
@"CMFunctionalCapacityInternal"
@32@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16
B56@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16^{CLConnectionClient={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@^{CLConnection}B{CLNameValuePair=^^?^{__CFDictionary}}{CLNameValuePair=^^?^{__CFDictionary}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@?@?@@?@?}32d40@?48
B24@0:8r*16
Q32@0:8@16@24
@44@0:8I16d20@28@?36
@44@0:8I16d20^{__CFRunLoop=}28@?36
^{__CFRunLoop=}
v40@0:8@16q24@?32
@"CMStepCounterProxy"
@144@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}{?=fff}QBff{?=fff}[3C]}16@136
v32@0:8d16@?24
@"CLTimer"16@0:8
v24@0:8@"CLTimer"16
@"CLTimer"
@"<CLTimerScheduler>"
:16@0:8
@"NSMethodSignature"
{map<SEL *, CLIntersiloInterfaceSelectorInfo *, std::__1::less<SEL *>, std::__1::allocator<std::__1::pair<SEL *const, CLIntersiloInterfaceSelectorInfo *> > >="__tree_"{__tree<std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, std::__1::__map_value_compare<SEL *, std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, std::__1::less<SEL *>, true>, std::__1::allocator<std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, void *> > >="__first_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<SEL *, std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, std::__1::less<SEL *>, true> >="__first_"Q}}}
@"Protocol"
{Sample="timestamp"d"pressureData"{?="pressure"f"temperature"f}}
{deque<float, std::__1::allocator<float> >="__map_"{__split_buffer<float *, std::__1::allocator<float *> >="__first_"^^f"__begin_"^^f"__end_"^^f"__end_cap_"{__compressed_pair<float **, std::__1::allocator<float *> >="__first_"^^f}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::__1::allocator<float> >="__first_"Q}}
v24@0:8r^{Sample=d{?=ff}}16
@"CMAltimeterInternal"
@"CMSwimTrackerInternal"
@36@0:8@16I24I28B32
@56@0:8@16I24I28B32Q36@44i52
@"CMMotionAlarmManager"
v24@0:8^{CLSwimEntry=Q[16C][16C]ddddddiiiifffi}16
@104@0:8Q16@24@32@40@48Q56d64d72Q80q88Q96
@24@0:8r^{CLSwimEntry=Q[16C][16C]ddddddiiiifffi}16
@48@0:8@16@24@32@40
@"CLIntersiloProxy"
@"CLIntersiloInterfaceSelectorInfo"
@"<CLIntersiloProxyDelegateProtocol>"
@"CLIntersiloInterface"
@32@0:8i16i20d24
v32@0:8@16:24
v24@0:8:16
v32@0:8@"NSMutableDictionary"16:24
v32@0:8@"NSMutableDictionary"16@"NSString"24
v24@0:8@"NSString"16
@"<CMWakeGestureDelegate>"
@24@0:8#16
v28@0:8@16i24
@"NSDictionary"
@"NSMutableSet"
v24@0:8^{_CLFitnessMachineData=dddddqqqdddddd}16
@32@0:8^v16@?24
^v16@0:8
@24@0:8^{CLNotifierClientBase=^^?}16
^{CLNotifierClientBase=^^?}
v24@0:8^{CLNotifierBase=^^?}16
i24@0:8@16
^{CLNotifierBase=^^?}16@0:8
{map<unsigned long, int, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, int> > >="__tree_"{__tree<std::__1::__value_type<unsigned long, int>, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, int>, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, int> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, int>, void *> > >="__first_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, int>, std::__1::less<unsigned long>, true> >="__first_"Q}}}
^{CLNotifierBase=^^?}
@"<CMWorkoutManagerDelegate>"
@"CMWorkoutManager"
@"CMWorkout"
@"CMWorkoutManagerInternal"
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
