uouarneglppa
?xfuayledlppa
cfuairavlppa
xeps
xfua2bvrlppa
cfuaptunlppa
0Ecfuavnoclppa
xfuatsidlppa
xmuaxmcmlppa
xmualpsmlppa
xfuaqebnlppa
mcpl)
xmuamed3lppa
?mcpl
ngualpsslppa
Mb@?
St11logic_error
St9exception
NSt3__117bad_function_callE
St12out_of_range
St13runtime_error
St12length_error
11CAException
uouaoipvlppa
uouacoirlppa
xfuagpsdlppa
presentationLatency
Td,R,N
audioUnit
T^{OpaqueAudioComponentInstance=},R,N
voiceProcessingEnabled
TB,R,N,GisVoiceProcessingEnabled
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioIONode.mm
-[AVAudioIONode enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:]
ioUnit != nil
com.apple.coreaudio.avfaudio
required condition is false: %s
-[AVAudioOutputNode manualRenderingMaximumFrameCount]
self.isInManualRenderingMode
-[AVAudioOutputNode manualRenderingFormat]
-[AVAudioOutputNode setManualRenderingPCMFormat:maximumFrameCount:]
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
Tf,N
renderingAlgorithm
Tq,N
sourceMode
pointSourceInHeadMode
rate
reverbBlend
obstruction
occlusion
position
T{AVAudio3DPoint=fff},N
volume
voiceProcessingBypassed
TB,N,GisVoiceProcessingBypassed
voiceProcessingAGCEnabled
TB,N,GisVoiceProcessingAGCEnabled
voiceProcessingInputMuted
TB,N,GisVoiceProcessingInputMuted
Tf,D,N
node
T@"AVAudioNode",R,W,N,V_node
TQ,R,N,V_bus
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVCUtils.mm
RegisterObject
UnregisterObject
dataSourceID
T@"NSNumber",R
dataSourceName
T@"NSString",R
location
orientation
supportedPolarPatterns
T@"NSArray",R
selectedPolarPattern
preferredPolarPattern
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/AVAudioSessionDataSourceImpl.mm
Unknown
-[AVAudioSessionDataSourceDescription initWithRawSourceDescription:andOwningPortID:andSessionID:]
<%@: %p, ID = %@; name = %@>
Gain
Frame Qualities
StartTime
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVCPluginRecordingEngine.mm
-[AVVCRemoteInputHost inputPlugin:didUnpublishDevice:]
-[AVVCRemoteInputHost inputPlugin:didPublishDevice:]
-[AVVCRemoteInputHost findFirstBluetoothDevice]
-[AVVCRemoteInputHost findDeviceWithIdentifier:]
-[AVVCRemoteInputHost findDeviceWithIdentifier:]_block_invoke
-[AVVCRemoteInputHost allBundles:]
Audio/Plug-Ins/RemoteInput/
-[AVVCRemoteInputHost invalidatePlugins]
-[AVVCRemoteInputHost dealloc]
-[AVVCRemoteInputHost initializePlugins]
devices
T@"NSArray",R,N
AVVCTestDevice
Error! No RemoteInputDeviceName property
Error! No Remote Device Found
getCurrentDeviceFromActivationContext
AVVCPluginRecordingEngine::destroyRecordEngine
~TraceMethod
destroyRecordEngine_block_invoke
TraceMethod
AVVCPluginRecordingEngine::stopRecording
stopRecording_block_invoke
AVVCPluginRecordingEngine::startRecording
startRecording_block_invoke
v20@?0I8@"NSDictionary"12
createRecordQueue_block_invoke
v32@?0@"AVAudioBuffer"8@"AVAudioTime"16@"NSDictionary"24
handleRecordInput
selectRecordFormat
~AVVCPluginRecordingEngine
AVVCPluginRecordingEngine
SelectedRouteDescription_RouteID
SelectedRouteDescription_DataSourceID
SelectedRouteDescription_MicrophonePolarPattern
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/AVAudioSessionUtilities.mm
FormatNSErrorForReturn
getUInt32
Category Value Converter
Endpoint Value Converter
Speakers
Vehicle
Headphones
Unspecified
Mode Value Converter
Polar Pattern Value Converter
Location Value Converter
Orientation Value Converter
copyPolarPatternPreference
CopyInputSelectionPreferences
0x%x
copyDataSourcePreference
activation trigger
activation device uid
AlertBehavior
No Record Route
ATVRemoteInput
BluetoothDoAP
JarvisRemoteInput
SetSessionActiveTime
SetSessionInactiveTime
BeginHostTime
EndHostTime
DurationMilliSeconds
recordRoute
T@"NSString",R,N,V_recordRoute
isRemoteDevice
TB,R,V_isRemoteDevice
remoteProductIdentifier
T@"NSString",R,N,V_remoteProductIdentifier
remoteDeviceUID
T@"NSUUID",R,N,V_remoteDeviceUID
remoteDeviceCategory
TI,R,N,V_remoteDeviceCategory
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVoiceController.mm
-[AVVCRecordDeviceInfo dealloc]
-[AVVCRecordDeviceInfo initWithRecordingEngine:]
Ti,N,V_type
mode
Tq,N,V_mode
alertEndTime
TQ,N,V_alertEndTime
recordSettings
T@"NSDictionary",R
recording
TB,R,GisRecording
endpointerDelegate
T@"<Endpointer>",&
recordEndpointMode
recordStartWaitTime
recordInterspeechWaitTime
recordEndWaitTime
recordDelegate
T@"<AVVoiceControllerRecordDelegate>",D
meteringEnabled
TB,GisMeteringEnabled
playbackSettings
playing
TB,R,GisPlaying
playbackDelegate
T@"<AVVoiceControllerPlaybackDelegate>",D
playbackVolume
stopOnEndpointEnabled
TB,GisStopOnEndpointEnabled
alertVolume
alertStartTime
TQ,R,V_alertStartTime
metrics
-[AVVoiceController setRecordStatusChangeBlock:]
-[AVVoiceController playAlertSoundForType:overrideMode:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVC_Log.h
~ElapsedTime
-[AVVoiceController playAlert:withOverride:completion:]
-[AVVoiceController setContextForStream:forStream:error:]
-[AVVoiceController deactivateAudioSessionWithOptions:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:error:]
-[AVVoiceController getRecordDeviceInfoForStream:]
-[AVVoiceController getCurrentStreamState:]
-[AVVoiceController stopRecordForStream:error:]
-[AVVoiceController stopRecordOnStream:completion:]
-[AVVoiceController configureAlertBehaviorForStream:error:]
-[AVVoiceController startRecordForStream:error:]
-[AVVoiceController startRecordWithSettings:completion:alertCompletion:audioCallback:]
-[AVVoiceController prepareRecordForStream:error:]
-[AVVoiceController prepareRecordForStream:completion:]
-[AVVoiceController setContext:error:]
-[AVVoiceController initWithError:]
-[AVVoiceController currentRecordDeviceInfo]
-[AVVoiceController setStopOnEndpointEnabled:]
-[AVVoiceController setMeteringEnabled:]
~VCLocker
VCLocker
-[AVVoiceController setPlaybackVolume:]
-[AVVoiceController setAlertVolume:]
-[AVVoiceController isRecording]
-[AVVoiceController setPlaybackBufferDuration:]
-[AVVoiceController setPlaybackDelegate:]
-[AVVoiceController setRecordStartWaitTime:]
-[AVVoiceController setRecordEndpointMode:]
-[AVVoiceController setEndpointerDelegate:]
external
internal Speex
-[AVVoiceController setRecordBufferDuration:]
-[AVVoiceController setRecordDelegate:]
-[AVVoiceController stopPlaying]
-[AVVoiceController startPlaying]
-[AVVoiceController preparePlaybackFromURL:error:]
preparePlaybackFromURL
-[AVVoiceController preparePlaybackWithSettings:error:]
preparePlaybackWithSettings
-[AVVoiceController stopRecording]
-[AVVoiceController startRecordingWithSettings:error:]
-[AVVoiceController startRecordingAtTime:error:]
-[AVVoiceController startRecording:]
-[AVVoiceController startRecording]
-[AVVoiceController playRecordStartingAlertAndResetEndpointer]
-[AVVoiceController resetEndpointer]
-[AVVoiceController playAlertSoundForType:]
playAlertSoundForType
-[AVVoiceController setAlertSoundFromURL:forType:]
-[AVVoiceController prepareRecordWithSettings:error:]
-[AVVoiceController setCurrentContext:error:]
-[AVVoiceController IsDeviceAvailableInLocalRoute:error:]
-[AVVoiceController enableMiniDucking:]
-[AVVoiceController willAcceptContext:]
-[AVVoiceController releaseAudioSession:]
-[AVVoiceController releaseAudioSession]
-[AVVoiceController dealloc]
finalize
-[AVVoiceController prewarmAudioSession]
-[AVVoiceController initWithContext:error:]
activationMode
Tq,N,V_activationMode
activationDeviceUID
T@"NSString",&,N,V_activationDeviceUID
streamID
TQ,N,V_streamID
avAudioSettings
T@"NSDictionary",&,N,V_avAudioSettings
recordBufferDuration
Td,N,V_recordBufferDuration
TB,N,V_meteringEnabled
startAlert
Tq,N,V_startAlert
stopAlert
Tq,N,V_stopAlert
stopOnErrorAlert
Tq,N,V_stopOnErrorAlert
startHostTime
TQ,N,V_startHostTime
bargeInDetectEnabled
TB,GisBargeInDetectEnabled
stopOnBargeInEnabled
TB,GisStopOnBargeInEnabled
playbackRoute
lastRecordStartTime
voiceTriggerInfo
synchronousCallbackEnabled
TB,GisSynchronousCallbackEnabled
pcmRecordBufferFormat
T@"AVAudioFormat",R
duckOthersOption
TB,SsetDuckOthersOption:
numberOfChannels
-[AVVoiceController(AVVoiceController_Priv) numberOfChannels]
-[AVVoiceController(AVVoiceController_Priv) setStopOnBargeInEnabled:]
-[AVVoiceController(AVVoiceControllerInternal) endAudioSessionActivate:]
-[AVVoiceController(AVVoiceControllerInternal) beginAudioSessionActivate:]
-[AVVoiceController(AVVoiceControllerInternal) alertPlaybackFinishedOfType:]
-[AVVoiceController(AVVoiceControllerInternal) finishedPlaying]
-[AVVoiceController(AVVoiceControllerInternal) beganPlaying]
-[AVVoiceController(AVVoiceControllerInternal) endpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) interspeechPointDetected]
-[AVVoiceController(AVVoiceControllerInternal) startpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) finishedRecording:]
-[AVVoiceController(AVVoiceControllerInternal) beganRecording:]
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidUnpublishDevice:withDevice:]
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidPublishDevice:withDevice:]
-[AVVoiceController(AVVoiceControllerInternal) handleRouteChange:]
-[AVVoiceController(AVVoiceControllerInternal) handleInterruption:]
-[AVVoiceController(AVVoiceControllerInternal) hardwareConfigChanged]
-[AVVoiceController(AVVoiceControllerInternal) removeSessionNotifications]
-[AVVoiceController(AVVoiceControllerInternal) setSessionNotifications]
Output
Music Device
Music Effect
Format Converter
Effect
Mixer
Panner
Generator
Offline Effect
MIDI Processor
Apple
AVAudioUnitComponentTagsDidChangeNotification
name
T@"NSString",R,N
typeName
localizedTypeName
manufacturerName
TQ,R,N
versionString
componentURL
T@"NSURL",R,N
availableArchitectures
sandboxSafe
TB,R,N,GisSandboxSafe
hasMIDIInput
TB,R,N
hasMIDIOutput
audioComponent
T^{OpaqueAudioComponent=},R,N
userTagNames
T@"NSArray",C
allTagNames
audioComponentDescription
T{AudioComponentDescription=IIIII},R,N
iconURL
passesAUVal
hasCustomView
configurationDictionary
T@"NSDictionary",R,N
Remote Music Effect
Remote Instrument
Remote Generator
Remote Effect
InitialOutputs
InitialInputs
com.apple.audio.ComponentTagHelper
Request
type
subtype
manufacturer
version
UserTags
AudioUnitTypes
com.apple.audio.units.Components
AudioUnitTags
AVAudioUnitComponentImplementation
%d.%d.%d
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/QualityDetector.cpp
QualityDetector
checkStatus
setStartTimeoutFrameCount
setInterspeechTimeoutFrameCount
setEndTimeoutFrameCount
endpointMode
startWaitTime
interspeechWaitTime
endWaitTime
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/SpeexEndpointer.mm
-[SpeexEndpointer setEndWaitTime:]
-[SpeexEndpointer setInterspeechWaitTime:]
-[SpeexEndpointer setStartWaitTime:]
-[SpeexEndpointer setEndpointMode:]
-[SpeexEndpointer configureWithASBD:andFrameRate:]
-[SpeexEndpointer configureWithSampleRate:andFrameRate:]
-[SpeexEndpointer dealloc]
-[SpeexEndpointer init]
-[SpeexEndpointer(SpeexEndpointer_Priv) getStatus:count:]
bypass
TB,N
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioUnitTimeEffect.mm
-[AVAudioUnitTimeEffect initWithAudioComponentDescription:]
audioComponentDescription.componentType == kAudioUnitType_FormatConverter
inputs
outputs
RouteDetailedDescription_SupportsSoftwareVolume
RouteDetailedDescription_SupportsDoAP
RouteDetailedDescription_SiriInputSource
RouteDetailedDescription_SiriInputDeviceUUID
<%@: %p, 
inputs = %@; 
outputs = %@>
siriRemoteInputIdentifier
siriInputSource
supportsSoftwareVolume
TB,R
supportsDoAP
Imaging
Pitch
MIDI
Bass
Vocal
Guitar
Drums
Sampler
Synthesizer
Time Effect
Delay
Distortion
Reverb
Dynamics Processor
Filter
Equalizer
Effects
AVAudioUnitComponentManagerRegistrationsChangedNotification
tagNames
standardLocalizedTagNames
New tags found, add it to the allTags
No changes
delayTime
Td,N
feedback
lowPassCutoff
wetDryMix
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVCRecordingEngine.mm
cacheRecordRoute
reconfigure
setupASBDAndCreateRecorder
populateRecordSettings
setStreamState
setRecordErrorStatus
setStartRecordCompletionAndAudioCallbackBlocks
setStopRecordCompletionBlock
audioQueueBufferReceived
audioBufferListReceived
avAudioPCMBufferReceived
myAudioQueueBufferReceived
lpcmAudioQueueBufferReceivedForNonLPCMClientFormat
pitch
overlap
duration
Td,R
currentDevice
T@"NSString",C,V_currentDevice
delegate
T@"<AVAudioPlayerDelegate>",W
T@"NSURL",R
data
T@"NSData",R
enableRate
currentTime
deviceCurrentTime
numberOfLoops
settings
format
channelAssignments
T@"NSArray",C,N
AVFileType3GPP2
AVFileType3GPP
AVFileTypeSunAU
AVFileTypeAC3
AVFileTypeMPEGLayer3
AVFileTypeCoreAudioFormat
AVFileTypeAppleM4A
AVFileTypeMPEG4
AVFileTypeWAVE
AVFileTypeAIFC
AVFileTypeAIFF
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioUnitGenerator.mm
-[AVAudioUnitGenerator initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Generator) || (audioComponentDescription.componentType == kAudioUnitType_RemoteGenerator)
processToTap
Ti,N
instantaneousMetering
T@"<AVAudioRecorderDelegate>",W
audioSession
T@"AVAudioSession",&
Null run loop
Invalid completion handler
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/SessionConnector.mm
DoConnectAsync_block_invoke
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/SessionMap.mm
CopySession
map::at:  key not found
AddSession
attempting to add a session with an ID that's already in use
DecrementSessionRefCount
RemoveSession_NoLock
UpdateSessionID
unexpected nil value
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioSequencerImpl.mm
AVAudioSequencerImpl
NewMusicPlayer(&mPlayer)
NewMusicSequence(&mSequence)
MusicPlayerSetSequence(mPlayer, mSequence)
MusicSequenceSetAUGraph(mSequence, nullptr)
error %d
failed call
sequencer_verbose
~AVAudioSequencerImpl
CurrentPosition
MusicPlayerGetTime(mPlayer, &theTime)
SetCurrentPosition
MusicPlayerSetTime(mPlayer, currentPosition)
IsPlaying
MusicPlayerIsPlaying(mPlayer, &isPlaying)
GetRate
MusicPlayerGetPlayRateScalar(mPlayer, &theRate)
SetRate
MusicPlayerSetPlayRateScalar(mPlayer, inRate)
HostTimeForBeats
MusicPlayerGetHostTimeForBeats(mPlayer, inBeats, pOutHostTime)
BeatsForHostTime
MusicPlayerGetBeatsForHostTime(mPlayer, inHostTime, pOutBeats)
NumberOfTracks
GetTrackWithIndex
MusicSequenceGetIndTrack(mSequence, inIndex, &theTrack)
GetTempoTrack
MusicSequenceGetTempoTrack(mSequence, &tempoTrack)
GetSecondsForBeats
MusicSequenceGetSecondsForBeats(mSequence, inBeats, &theSeconds)
GetBeatsForSeconds
MusicSequenceGetBeatsForSeconds(mSequence, inSeconds, &theBeats)
EnableLooping
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, pLen)
DoGetLengthInBeats
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TrackLength, &length, &pLen)
~MusicTrackImpl
SetDestinationAudioUnit
MusicTrackSetDestinationAU(mTrack, inUnit.audioUnit, &desc)
SetDestinationMIDIEndpoint
MusicTrackSetDestMIDIEndpoint(mTrack, inEndPoint)
GetDestinationMIDIEndpoint
MusicTrackGetDestMIDIEndpoint(mTrack, &endPoint)
DoSetLengthInBeats
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_TrackLength, &inLength, sizeof(inLength))
SetLengthInSeconds
MusicTrackGetSequence(mTrack, &seq)
MusicSequenceGetBeatsForSeconds(seq, inLength, &beatLength)
GetLengthInSeconds
MusicSequenceGetSecondsForBeats(seq, DoGetLengthInBeats(), &seconds)
SetOffset
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &inOffset, sizeof(inOffset))
GetOffset
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &offset, &pLen)
SetLoopCount
GetLoopCount
SetLoopStart
GetLoopStart
SetLoopEnd
GetLoopEnd
IsLoopingEnabled
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, pLen)
IsMuted
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, &pLen)
Solo
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, pLen)
IsSoloed
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, &pLen)
UseAutomatedParams
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, pLen)
UsesAutomatedParams
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, &pLen)
GetTimeResolution
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TimeResolution, &timeRes, &pLen)
GetIndex
MusicTrackGetSequence(mTrack, &sequence)
MusicSequenceGetTrackIndex(sequence, mTrack, &index)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioSinkNode.mm
AVAudioSinkNodeImpl
AVAudioSinkNodeImpl::SetOutputFormat(0, format)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioNodeTap.mm
nil != _format
_initialized
channelName
owningPortUID
channelNumber
channelLabel
TI,R
<%@: %p, name = %@; label = %u (0x%x); number = %d; port UID = %@>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/AVAudioSessionChannelImpl.mm
+[AVAudioSessionChannelDescription privateCreate:portUID:channelNumber:]
layoutTag
TI,R,N
layout
Tr^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]},R,N
channelCount
supportsSecureCoding
-[AVAudioChannelLayout initWithCoder:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVFAudioCore/AVAudioChannelLayout.mm
length == len
/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox
AudioFormatGetProperty
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAudioEngineGraph.mm
TraverseGraphNodes
inCurrNode.GetConnection(inDirection, bus, conn)
TraverseGraphNodesBFS
connNode
connNodeFirst
connNodeSecond
TraverseGraphNodesWithLookback
inCurrNode.GetConnection(otherDirection, bus, conn)
InformNodesAboutMixerConnection
inMixerConn.destNode && inMixerConn.destNode->IsMixerNode()
false condition
InformNodesAboutMixerDisconnection
operator()
inGraph.PerformCommand(theNode, AVAudioEngineGraph::kAUSetPropertyMaximumFramesPerSlice, &maxFrames, sizeof(maxFrames))
NodeStateChanged
GetMusicDeviceNode()
GetDefaultMusicDevice
outUnit || outDesc
UninitializeNode
inGraph.PerformCommand(node, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
inGraph.PerformCommand(midiNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
InitializeActiveNodesInOutputChain
inGraph.IsNodeInGraph(inNode.NodeImpl())
inGraph.IsValidSourceNode(*startNode)
inGraph.MakeDisconnection(mixerConn.destNode->NodeImpl(), mixerConn.destBus)
AddPendingConnection
inConn.IsSrcAndDestValid()
MakeDisconnection
IsNodeInGraph(inDestImpl)
true == graphNodeDest->GetConnection(kUpstream, inDestBus, mixerConn)
err = PerformCommand(*graphNodeDest, kAUInitialize, NULL, 0)
PrepareForDisconnection
inGraph.IsNodeInGraph(&inDestNode)
inGraph.PerformCommand(inDestNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
conn.destNode && conn.destNode->IsMixerNode()
0 == inCurrNode.NumberOfValidConnections(kUpstream)
InitializeActiveNodesInInputChain
inGraph.GetInputNode() && (&inNode == inGraph.GetInputNode())
false == isInputConnToConverter
inGraph.MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
inGraph.MakeConnection(inputConn)
inGraph.PerformCommand(*inGraph.GetInputNode(), AVAudioEngineGraph::kAUSetInputCallback, &rc, sizeof(rc))
InputAvailable
isSink || tap != nullptr
CAException
inGraph.MakeDisconnection(inPrevConn->destNode->NodeImpl(), inPrevConn->destBus)
RemovePendingConnection
inConn.srcNode || inConn.destNode
MakeConnection
IsNodeInGraph(inSrcImpl)
err = MakeDisconnection(inDestImpl, inDestBus, outErr)
err = PerformCommand(*graphNodeDest, kAUMakeConnection, &connection, sizeof(connection))
err = PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
err = PerformCommand(midiInput, kAUInitialize, nullptr, 0)
PrepareForConnection
srcNode && inGraph.IsNodeInGraph(srcNode)
destNode && inGraph.IsNodeInGraph(destNode)
srcCurrConn.destNode == NULL || srcCurrConn == inConn
destCurrConn.srcNode == NULL || destCurrConn == inConn
inGraph.PerformCommand(*destNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
inNodeUpstream.IsInitialized()
MakeVirtualConnection
IsNodeInGraph(conn.srcNode) && IsNodeInGraph(conn.destNode)
srcCurrConn.destNode == NULL || srcCurrConn == conn
destCurrConn.srcNode == NULL || destCurrConn == conn
AVAEGraphStateTracker.RunStateQueue
_Stop
ioNode != NULL
(err = PerformCommand(*ioNode, kAUStopIO, NULL, 0))
AVAEGraphNodesToPullRenderGuard
outputNode != nullptr
inputNode != nullptr || outputNode != nullptr
err = PerformCommand(*outputNode, kAUInitialize, NULL, 0)
IsFormatSampleRateAndChannelCountValid(outputHWFormat)
err = _Connect(connNode->NodeImpl(), outputNode->NodeImpl(), 0, 0, format)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainOptimizedTraversal, *GetOutputNode(), isOutputChainActive)
GetOutputNode()->IsInitialized()
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *GetInputNode())
GetInputNode()->IsInitialized()
IsFormatSampleRateAndChannelCountValid(inputHWFormat)
PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
_Uninitialize
(err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0))
(err = MakeConnection(conn, outErr))
(err = PerformCommand(*GetOutputNode(), kAUUninitialize, NULL, 0))
(err = PerformCommand(*GetInputNode(), kAUUninitialize, NULL, 0))
RemoveNode
nil != inAVNode
IsNodeInGraph(inImpl)
!IsRunning() && !graphNode->IsInitialized()
(graphNode->IsNodeState(kAUGraphNodeState_InInputChain) || graphNode->IsNodeState(kAUGraphNodeState_InOutputChain))
!nodeMixerConns.empty() && !hasDirectConnToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus, outErr)
err = MakeDisconnection(currSrcConn.destNode->NodeImpl(), currSrcConn.destBus, outErr)
err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
err = DisconnectInactiveNode(graphNode, true , disjointNodes, outErr)
conn.IsSrcAndDestValid()
graphNode == conn.destNode
err = MakeConnection(conn, outErr)
err = UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
UpdateGraphAfterReconfig
conn.srcNode && conn.destNode && conn.destNode->IsMixerNode()
AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainFullTraversal, *conn.srcNode, isChainActive)
MakeConnection(inputConn)
PerformCommand(*inputConn.srcNode, kAUInitialize, NULL, 0)
PerformCommand(*inputConn.destNode, kAUInitialize, NULL, 0)
MakeConnection(conn)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, inTraversalMode, *GetOutputNode(), isChainActive)
DisconnectInactiveNode
false == inNode->IsInitialized()
err = MakeConnection(itInp->srcNode->NodeImpl(), itOut->destNode->NodeImpl(), itInp->srcBus, itOut->destBus, outErr)
_Connect
IsNodeInGraph(inSrcImpl) && IsNodeInGraph(inDestImpl)
inSrcImpl->NumberOutputs() > 0
inDestImpl->NumberInputs() > 0 || graphNodeDest->CanResizeNumberOfInputs()
!srcNodeMixerConns.empty() && !isSrcNodeConnectedToIONode
!destNodeMixerConns.empty() && !isDestNodeConnectedToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*graphNodeSrc, kAUUninitialize, NULL, 0)
err = MakeDisconnection(inDestImpl, inDestBus)
err = MakeDisconnection(graphNodeSrcCurrConnPoint.node->NodeImpl(), graphNodeSrcCurrConnPoint.bus)
[format isEqual:dstFormat]
inSrcImpl->SetOutputFormat(inSrcBus, dstFormat)
[srcFormat isEqual:format]
inDestImpl->SetInputFormat(inDestBus, srcFormat)
inSrcImpl->SetOutputFormat(inSrcBus, format) && inDestImpl->SetInputFormat(inDestBus, format)
[midiInputImpl->GetOutputFormat(0) isEqual:inSrcImpl->GetOutputFormat(0)]
err = MakeConnection(currentConn)
graphNodeDest != conn.destNode
Start
err = PerformCommand(*ioNode, kAUStartIO, NULL, 0)
inImpl != nil && !IsIONode(inAVNode)
AddIONode
inImpl != nil && IsIONode(inAVNode)
NULL == ioNodeImpl && !IsNodeInGraph(inImpl)
RemoveIONode
(isInputNode && graphNode == GetInputNode()) || (!isInputNode && graphNode == GetOutputNode())
!IsRunning() && !IsInitialized()
err = RemoveNode(inAVNode, outErr)
err = MusicSequenceSetAudioGraph(inSequence, _seqGraphImpl)
GetOutputAudioUnit
outputNode
UnregisterRenderCallback
RegisterRenderCallback
inAVNode
format.sampleRate == inputHWFormat.sampleRate
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *inputNode)
inSrcAVNode && inDestAVNode
inSrcImpl && inDestImpl
inSrcAVNode && inDestAVConnectionPoints && inDestAVConnectionPoints.count > 0
!inSrcNode->IsSplitterNode()
currentConnPoints.size() <= 1
currentConnPoints.size() > 1
avConnPoint
MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*finalSrcNode, kAUUninitialize, NULL, 0)
_DisconnectInput(connPoint.node->NodeImpl(), connPoint.bus)
_Connect(inSrcImpl, [splitter impl], inSrcBus, kAudioUnitElement_Default, format)
RemoveNode(avNode)
PerformCommand(*finalSrcNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
[midiInputImpl->GetOutputFormat(0) isEqual:finalSrcNode->NodeImpl()->GetOutputFormat(0)]
_Connect(finalSrcNode->NodeImpl(), destImpl, srcBus, destBus, format)
UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
_DisconnectInput
!IsRunning()
graphNode != conn.destNode
inDestAVNode
inDestImpl
inSrcAVNode
inSrcImpl
_DisconnectOutput
inImpl
tmpErr = _DisconnectInput(conn.destNode->NodeImpl(), conn.destBus)
inSourceAVNode && inDestAVNodes && inDestAVNodes.count > 0
graphNodeSrc->IsMIDIProcessorNode()
destAVNode
graphNodeDest->IsMusicDevice() || graphNodeDest->IsMIDIProcessorNode()
inSrcImpl->SetOutputFormat(0, newFormat)
PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
err = UpdateGraphAfterReconfig(&disjointNodes, kOutputChainFullTraversal)
PerformCommand(*midiNode, kAUUninitialize, nullptr, 0)
graphNode->IsMIDIProcessorNode()
!graphNode->IsSplitterNode()
!splitterConnPoint.node->IsSplitterNode()
numSplitterConnections == 0 || numSplitterConnections > 1
!connPoint.node->IsSplitterNode()
NodeRenderingStateChanged
GetOutputDeviceLatencyForNode
GraphDescription
________ %s ________
AVAudioEngineGraph %p: initialized = %d, running = %d, number of nodes = %d
 ******** output chain ********
 ******** input chain ********
 ******** pending connections - output ********
 %s, [%s]
 ******** pending connections - input ********
 ******** other nodes ********
______________________________________
(bus%d) %p, {%s} -> 
(bus%d) %p, {%s}
realloc failed
RenderToABL
LastRenderErrorInChain
startNodeImpl
startNode
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioEnvironmentNodeImpl.mm
v16@?0@"NSNotification"8
connection
T@"NSXPCConnection",&,V_connection
serviceDelegateAsync
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateAsync
serviceDelegateSync
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateSync
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioDeviceTest/AVAudioDeviceTest.mm
-[AVAudioDeviceTest startWithSequence:completion:]
v24@?0@"NSArray"8@"NSError"16
-[AVAudioDeviceTest startWithSequence:completion:]_block_invoke
avat
devicetest_verbose
-[AVAudioDeviceTest init]
-[AVAudioDeviceTest init]_block_invoke
com.apple.avfaudio.devicetest.service
inputFormat
T@"AVAudioFormat",R,N
outputFormat
channelMap
T@"NSArray",&,N
magicCookie
T@"NSData",&,N
downmix
dither
sampleRateConverterQuality
sampleRateConverterAlgorithm
T@"NSString",&,N
primeMethod
primeInfo
T{AVAudioConverterPrimeInfo=II},N
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioConverter.mm
FillComplexProc
impl->_inputBufferReceived
[impl->_inputBufferReceived.format isEqual: impl->_inputFormat]
ioData->mNumberBuffers == abl->mNumberBuffers
convert
outputBuffer.frameCapacity >= inputBuffer.frameLength
bitRate
bitRateStrategy
maximumOutputPacketSize
Tq,R,N
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
publicMetrics
T@"NSMutableDictionary",&,V_publicMetrics
avvcProfilingInfoDictionary
T@"NSMutableDictionary",&,V_avvcProfilingInfoDictionary
voiceTriggerStartHostTime
TQ,N,V_voiceTriggerStartHostTime
callToStartRecordHostTime
TQ,N,V_callToStartRecordHostTime
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVCMetricsManager.mm
-[AVVCMetricsManager logProfileMetrics:]
-[AVVCMetricsManager measureElapseTimeForMetric:block:]
v32@?0@8@16^B24
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferToDelegateCallDelta
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferDelta
AVVC_PROFILE_Prop_FirstBufferReceived
AVVC_PROFILE_Delta_StartRecordAudioQueueStartEnd
AVVC_PROFILE_Prop_RecordQueueEnd
AVVC_PROFILE_Prop_RecordQueueStart
AVVC_PROFILE_Delta_PlayAlertQueueStartEnd
AVVC_PROFILE_Prop_PlayAlertEnd
AVVC_PROFILE_Prop_PlayAlertStart
AVVC_PROFILE_Delta_StartRecordAPIStartEnd
AVVC_PROFILE_Prop_StartRecordingEnd
AVVC_PROFILE_Prop_StartRecordingStart
AVVC_PROFILE_Delta_SetupRecordQueueStartEnd
AVVC_PROFILE_Prop_SetupRecordQueueEnd
AVVC_PROFILE_Prop_SetupRecordQueueStart
AVVC_PROFILE_Delta_SetSessionActiveStartEnd
AVVC_PROFILE_Prop_SetSessionActiveEnd
AVVC_PROFILE_Prop_SetSessionActiveStart
AVVC_PROFILE_Delta_GetSessionPropStartEnd
AVVC_PROFILE_Prop_GetPropertiesEnd
AVVC_PROFILE_Prop_GetPropertiesStart
AVVC_PROFILE_Delta_PrepareAPIStartEnd
AVVC_PROFILE_Prop_PrepareEnd
AVVC_PROFILE_Prop_PrepareStart
yyyy-MM-dd'T'HH:mm:ss.SSSSSSSZZZZZ
-[AVVCMetricsManager dealloc]
+[AVVCMetricsManager sharedManager]
+[AVVCMetricsManager destroySharedManager]
+[AVVCMetricsManager createSharedManager]
AVVCMM
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.mm
ConnectInput
nullptr != srcNode
CreateRecordingTap
nil != callbackBlock
nullptr == Tap()
NodeImpl()->SetOutputFormat(bus, format)
DisconnectNode
inNode != nil
AddNode
DestroyMIDIConnection
midiSrc == MIDIInput()
SetTapBlock
GetTapBlock()
i44@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36
DeallocateInputBlock
false == AUI().IsRunning()
AllocateInputHandler
v36@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28
RenderBlock()
i36@?0q8C16q20r*28
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.h
InputMutex
bus < _inMutexes.size()
nodeBussesVec.size() == nodeVec.size()
GetBusForConnectionPoint
GetConnectionPoint
nodeBussesVec.size() >= (inBus + 1)
GetConnection
AUGraphNodeBase
nil != _avNode
nullptr != _avNodeImpl
 node %p {%s}, '%s'
 inputs = %d
 (bus%d, en%d) <- (bus%d) %p, {%s}, [%s]
 outputs = %d
 (bus%d, en%d) -> (bus%d) %p, {%s}, [%s]
AUGraphNodeBaseV3
AUGraphMIDINodeV3
IsMIDIProcessorNode()
AUGraphSourceNodeV3
NodeImpl()->IsAVAudioSourceNode()
InputBlock()
AUGraphSinkNodeV3
NodeImpl()->IsSinkNode()
AllocateRenderBlock
receiverBlock
i52@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36@?<i@?^I^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}Iq^{AudioBufferList=I[1{AudioBuffer=II^v}]}>44
AUGraphMultiBusNode
IsMixerNode() || IsSplitterNode()
preGain
Drums - Bit Brush
Drums - Buffer Beats
Drums - Lo-Fi
Multi - Broken Speaker
Multi - Cellphone Concert
Multi - Decimated 1
Multi - Decimated 2
Multi - Decimated 3
Multi - Decimated 4
Multi - Distorted Funk
Multi - Distorted Cubed
Multi - Distorted Squared
Multi - Echo 1
Multi - Echo 2
Multi - Echo Tight 1
Multi - Echo Tight 2
Multi - Everything is Broken
Speech - Alien Chatter
Speech - Cosmic Interference
Speech - Golden Pi
Speech - Radio Tower
Speech - Waves
outputVolume
nextAvailableInputBus
T@"AVAudioTime",R,N
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioClock.mm
AVAudioClockImpl
_nodeImpl->AUI().AddV2PropertyListener(kAudioUnitProperty_StreamFormat, StreamFormatListener, this)
TB,R,N,GisPlaying
currentPosition
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVMIDIPlayer/AVMIDIPlayer.mm
-[AVMIDIPlayer setCurrentPosition:]
MusicSequenceGetBeatsForSeconds(impl->mSequence, (Float64) currentPosition, &positionInBeats)
MusicPlayerSetTime(impl->mPlayer, positionInBeats)
-[AVMIDIPlayer currentPosition]
MusicPlayerGetTime(impl->mPlayer, &positionInBeats)
MusicSequenceGetSecondsForBeats(impl->mSequence, positionInBeats, &positionInTime)
-[AVMIDIPlayer duration]
MusicSequenceGetSecondsForBeats(impl->mSequence, impl->mLength, &durInSeconds)
-[AVMIDIPlayer setRate:]
MusicPlayerSetPlayRateScalar(impl->mPlayer, rate)
-[AVMIDIPlayer rate]
MusicPlayerGetPlayRateScalar(impl->mPlayer, &scalar)
-[AVMIDIPlayer isPlaying]
MusicPlayerIsPlaying(impl->mPlayer, &playing)
stop
MusicPlayerStop(mPlayer)
start
MusicPlayerStart(mPlayer)
-[AVMIDIPlayer prepareToPlay]
MusicPlayerPreroll(impl->mPlayer)
finishLoad
MusicSequenceGetAUGraph(mSequence, &graph)
SetUpGraph
AUGraphOpen(inGraph)
AUGraphGetNodeCount (inGraph, &nodeCount)
AUGraphGetIndNode(inGraph, i, &node)
AUGraphNodeInfo(inGraph, node, &desc, &unit)
AudioUnitSetProperty (unit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &numFrames, sizeof(numFrames))
AUGraphInitialize(inGraph)
MusicSequenceGetTrackCount(mSequence, &trackCount)
MusicSequenceSetUserCallback(mSequence, userCallback, this)
MusicTrackGetProperty(track, kSequenceTrackProperty_TrackLength, &length, &plength)
-[AVMIDIPlayer dealloc]
~MIDIPlayerImpl
MIDIPlayerImpl
CallbackQueue
avmp
avmidiplayer_verbose
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioUnitMIDIInstrument.mm
-[AVAudioUnitMIDIInstrument sendMIDISysExEvent:]
_IMPL->SendMIDISysexEvent((CFDataRef)midiData)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:]
_IMPL->SendMIDIEvent(midiStatus, data1, 0, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:data2:]
_IMPL->SendMIDIEvent(midiStatus, data1, data2, 0, 0)
-[AVAudioUnitMIDIInstrument sendProgramChange:bankMSB:bankLSB:onChannel:]
_IMPL->SendProgramChange(program, bankMSB, bankLSB, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PatchChange, program, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressureForKey:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_KeyPressure, key, pressureValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressure:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ChannelPressure, pressureValue, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendPitchBend:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PitchBend, value&0x7F, value>>7, 0, channel)
-[AVAudioUnitMIDIInstrument sendController:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ControlChange, controller, controllerValue, 0, channel)
-[AVAudioUnitMIDIInstrument stopNote:onChannel:]
_IMPL->StopNote(note, channel)
-[AVAudioUnitMIDIInstrument startNote:withVelocity:onChannel:]
_IMPL->StartNote(note, velocity, channel)
-[AVAudioUnitMIDIInstrument initWithAudioComponentDescription:]
(description.componentType == kAudioUnitType_MusicDevice) || (description.componentType == kAudioUnitType_RemoteInstrument)
SendProgramChange
true == SendMIDIEvent(kMIDIMessage_ControlChange, 0, bankMSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_ControlChange, bankSelectLSBParam1, bankLSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_PatchChange, programID, 0, 0, channel)
audioBufferList
Tr^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
mutableAudioBufferList
T^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
<%@@%p: %d/%d bytes>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVFAudioCore/AVAudioBuffer.mm
-[AVAudioBuffer setByteLength:]
length <= _imp->_byteCapacity
peakPowerPerChannel
averagePowerPerChannel
frameCapacity
frameLength
TI,N
stride
floatChannelData
T^^f,R,N
int16ChannelData
T^^s,R,N
int32ChannelData
T^^i,R,N
-[AVAudioPCMBuffer setFrameLength:]
length <= _imp->_frameCapacity
-[AVAudioPCMBuffer initWithPCMFormat:frameCapacity:]
isPCMFormat
packetCapacity
packetCount
maximumPacketSize
T^v,R,N
byteCapacity
TI,R,D,N
byteLength
TI,D,N
packetDescriptions
T^{AudioStreamPacketDescription=qII},R,N
-[AVAudioCompressedBuffer setPacketCount:]
length <= _imp->_packetCapacity
-[AVAudioCompressedBuffer initWithFormat:packetCapacity:maximumPacketSize:]
!(fmt.IsPCM() || fmt.mFormatID == kAudioFormatALaw || fmt.mFormatID == kAudioFormatULaw)
maximumPacketSize != 0
filterType
frequency
bandwidth
gain
bands
globalGain
AVAudioSessionCategoryAmbient
AVAudioSessionCategorySoloAmbient
AVAudioSessionCategoryPlayback
AVAudioSessionCategoryRecord
AVAudioSessionCategoryPlayAndRecord
AVAudioSessionCategoryAudioProcessing
AVAudioSessionCategoryMultiRoute
AVAudioSessionCategoryVoiceOver
AVAudioSessionCategoryVoiceCommand
AVAudioSessionCategoryRingtonePreview
AVAudioSessionCategoryRingtone
AVAudioSessionCategoryVoiceMail
AVAudioSessionCategoryPhoneCall
AVAudioSessionCategoryTTYCall
AVAudioSessionCategoryAlarm
AVAudioSessionCategoryPlaybackNoSpeaker
AVAudioSessionCategoryEmergencyAlert
AVAudioSessionCategoryEmergencyAlert_CanBeMuted
AVAudioSessionCategoryFindMyPhone
AVAudioSessionCategoryWaterEjection
AVAudioSessionCategoryFindMyDevice
AVAudioSessionCategorySystemSoundsAndHaptics
AVAudioSessionModeDefault
AVAudioSessionModeVoiceChat
AVAudioSessionModeGameChat
AVAudioSessionModeVideoRecording
AVAudioSessionModeMeasurement
AVAudioSessionModeMoviePlayback
AVAudioSessionModeSpokenAudio
AVAudioSessionModeVoicePrompt
AVAudioSessionModeVideoChat
AVAudioSessionModeSpeechRecognition
AVAudioSessionModeRaw
AVAudioSessionModeVoiceMessages
AVAudioSessionModeLocatePhone
AVAudioSessionModeHearingAccessibility
AVAudioSessionModeLivePhoto
AVAudioSessionModeSOS
AVAudioSessionModeSpatialRecording
AVAudioSessionModeVideoChatForMedia
AVAudioSessionInterruptionNotification
AVAudioSessionRouteChangeNotification
AVAudioSessionMediaServicesWereLostNotification
AVAudioSessionMediaServicesWereResetNotification
AVAudioSessionSilenceSecondaryAudioHintNotification
AVAudioSessionPickableRouteChangeNotification
AVAudioSessionRoutingContextChangeNotification
AVAudioSessionOtherPrimaryAudioPlayStateChangeNotification
AVAudioSessionInterruptionTypeKey
AVAudioSessionInterruptionOptionKey
AVAudioSessionInterruptorNameKey
AVAudioSessionInterruptionWasSuspendedKey
AVAudioSessionRouteChangeReasonKey
AVAudioSessionRouteChangePreviousRouteKey
AVAudioSessionSilenceSecondaryAudioHintTypeKey
activation accessibility preference
activation call direction
LineIn
MicrophoneBuiltIn
MicrophoneWired
LineOut
BluetoothA2DPOutput
Receiver
Speaker
HDMIOutput
AirPlay
S/PDIF
BluetoothLE
BluetoothHFP
USBAudio
CarAudio
Upper
Lower
Bottom
Front
Back
Left
Right
Omnidirectional
Cardioid
Subcardioid
standard
TB,R,N,GisStandard
commonFormat
sampleRate
interleaved
TB,R,N,GisInterleaved
streamDescription
Tr^{AudioStreamBasicDescription=dIIIIIIII},R,N
channelLayout
T@"AVAudioChannelLayout",R,N
formatDescription
Tr^{opaqueCMFormatDescription=},R,N
mBitsPerChannel
mChannelsPerFrame
mBytesPerFrame
mFramesPerPacket
mBytesPerPacket
mFormatFlags
mFormatID
mSampleRate
<AVAudioFormat %p: %s>
cannot convert to CMAudioFormatDescription %d
Audio files cannot be non-interleaved. Ignoring setting AVLinearPCMIsNonInterleaved YES.
AVAudioSession
outputID
Tq,N,V_outputID
inputID
Tq,N,V_inputID
Td,N,V_sampleRate
correlationValue
Td,N,V_correlationValue
T@"NSData",R,N,V_data
Tf,N,V_volume
stimulusURL
T@"NSURL",&,N,V_stimulusURL
inputProcessingChain
T@"AVAudioDeviceTestProcessingChain",&,N,V_inputProcessingChain
outputProcessingChain
T@"AVAudioDeviceTestProcessingChain",&,N,V_outputProcessingChain
outputMode
Tq,N,V_outputMode
T@"NSString",&,V_mode
calculateCrossCorrelationPeak
TB,V_calculateCrossCorrelationPeak
graphURL
T@"NSURL",&,N,V_graphURL
processingStripURL
T@"NSURL",&,N,V_processingStripURL
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioSourceNode.mm
AVAudioSourceNodeImpl
SetInputFormat(0, format)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVCAudioQueueRecordingEngine.mm
getRecordRoute
UpdateRecordDeviceOnQueue
setupAudioCaptureFile
/tmp/Assistant/AVVCCapture/
%s%s(%lu)-%04d%02d%02d-%02d%02d%02d
Capture
.caf
handleAudioInput
RecordEncoderInputDataProc
DeinterleaveAudio
handleRecordQueuePropertyListener
resetAudioEngine
resetAudioEngine:mRecordQueue: AudioQueueReset
updateMeterLevels
enableSiriListeningMode
destroyRecordEngine
queue : AudioQueueStop
destroyRecordEngine: AudioQueueDispose
AudioQueueRecordPropertyListenerProc
stopRecording
mRecordQueue : AudioQueueStop
startRecording
startRecording:AudioQueueReset
delay
past
startRecording : AudioQueueStart
prepareRecording
Initialize
createRecordQueue
With
createAudioConverter
configureRecordConverterFromSettings
AVVoiceController_RecordQueue
AudioQueueRecordInputCallback
~AVVCAudioQueueRecordingEngine
AVVCAudioQueueRecordingEngine
com.apple.speech.voice.Alex
AVSpeechSynthesisIPANotationAttribute
language
T@"NSString",C,D,N
identifier
T@"NSString",&,D,N
quality
Tq,D,N
gender
audioFileSettings
T@"NSDictionary",R,N,V_audioFileSettings
IPHONE_SIMULATOR_ROOT
CFFIXED_USER_HOME
/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle
speechString
T@"NSString",&,N,V_speechString
attributedSpeechString
T@"NSAttributedString",&,N,V_attributedSpeechString
voice
T@"AVSpeechSynthesisVoice",&,N,V_voice
Tf,N,V_rate
pitchMultiplier
Tf,N,V_pitchMultiplier
preUtteranceDelay
Td,N,V_preUtteranceDelay
postUtteranceDelay
Td,N,V_postUtteranceDelay
T@"<AVSpeechSynthesizerDelegate>",W,N,V_delegate
speaking
TB,R,N,GisSpeaking,V_speaking
paused
TB,R,N,GisPaused,V_paused
outputChannels
T@"NSArray",&,N,V_outputChannels
usesApplicationAudioSession
TB,N,V_usesApplicationAudioSession
mixToTelephonyUplink
TB,N,V_mixToTelephonyUplink
isPrimary
channels
Ti,R
bytesCapacity
bytesDataSize
T^v,R
packetDescriptionCapacity
packetDescriptionCount
T^{AudioStreamPacketDescription=qII},R
timeStamp
T^{AudioStreamBasicDescription=dIIIIIIII},R
remoteVoiceActivityAvailable
remoteVoiceActivityRMS
TC,R
remoteVoiceActivityVAD
distanceAttenuationModel
referenceDistance
maximumDistance
rolloffFactor
enable
level
filterParameters
T@"AVAudioUnitEQFilterParameters",R,N
outputType
listenerPosition
listenerVectorOrientation
T{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}},N
listenerAngularOrientation
T{AVAudio3DAngularOrientation=fff},N
distanceAttenuationParameters
T@"AVAudioEnvironmentDistanceAttenuationParameters",R,N
reverbParameters
T@"AVAudioEnvironmentReverbParameters",R,N
applicableRenderingAlgorithms
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/ControllerImpl.mm
getRecordAndPlaybackRoutes
No Playback Route
Unknown Playback Route
_getCurrentRecordingEngine
_lookupEngineForStreamID
com.apple.avfoundation.avvc
fault_on_streamID_violation
~ControllerImpl
getSessionProperties_HWConfig
getSessionProperties
setActivationContext
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/ControllerImpl.h
ILLEGAL
setSessionState
NotConfigured
Inactive
InteruptedWhileRecording
InteruptedWhilePlaying
Deactivating
Prewarming
Activating
Active
setActivationModeAndSessionHWControlFlagsAndOptions
setSessionCategoryModeOptionsAndSampleRateFromMode
AVSystemController_CarPlaySupportsMixableSiriAttribute
setSessionProperties
updateMeters
enableMetering
setDuckOthersOption
resetMiniDuckingStateIfPreviouslyEnabled
unref
AVVC Rec Queue RunLoop
DispatchQueue
SIMULATOR_ROOT
Playback
Session
Alert
Record
ControllerImpl
AVVC Client Notification Queue
duck_others
Haptic
Silent
Beep
setStopWithErrorAlertMode
running
stopping
started
primed
stopped
uninit
setAlertQueueState
setStopAlertMode
setStartAlertMode
profile_avvc
dump_input
/System/Library/Audio/UISounds/jbl_cancel.caf
/System/Library/Audio/UISounds/jbl_confirm.caf
/System/Library/Audio/UISounds/jbl_begin.caf
%s%@
callbackBarrier
setNoResumeOnDeactivate
UsePluginModelForHomeOrBluetoothButtonActivation
getCurrentRecordDeviceUID
getDeviceUIDForHomeOrBluetoothButtonActivation
handlePluginDidPublishDevice
handlePluginDidUnpublishDevice
_removeEngineFromMapWithStreamID
~VCUnlocker
VCUnlocker
createRecordingEngine
Invalid
Plugin
AudioQueue
_createRecordingEngineWithParameters
_insertRecordingEngineIntoMap
test_LEA
configure
setSessionActive
unconfigured
AVAudioSessionSetActive
mPlaybackQueue : AudioQueueStop
setSessionActive1
setSessionActive2
forceDeactivateSessionAndFixupState
deactivateSession
AVAudioSessionDeactivate
destroyAlertQueue
destroyAlertQueue : AudioQueueStop
AlertAQPropertyListenerProc
handleAlertAQPropertyChange
alertFinished
inactive
starting
active
setAlertState
alertStarted
startedRecording
Uninitialized
Stopped
Starting
Running
Stopping
setRecordFromRemoteInput
calculateRecordStartTime
calculateAlertTimes
QueueIsRunning
handleRetrySessionActivationError
B8@?0
setCurrentContext
configureAlerts
setupAlert
AudioQueueReset : mAlertQueue
createAlertQueue
AVVoiceController_AlertQueue
cleanup
destroyPlaybackQueue
destroyPlaybackQueue : AudioQueueStop
PlaybackAQPropertyListenerProc
donePlaying
startedPlaying
getCurrentRecordDeviceInfo
getCurrentRecordSettings
checkSession
AVVCEngine-prepareRecording from checkSession
getPeakPowerForChannel
getAveragePowerForChannel
isMeteringEnabled
setupEndpointer
resetEndpointDetector
getRecordErrorStatus
prepareRecordQueue
configureAlertModeFromModeAndEngine
handsFree
built-in speaker
Auto
Post-Voice
Dictation
Wired/BT ButtonPress
iMessageGestureToHead
No Override
Mute
AVSystemController_CarPlayAuxStreamSupportAttribute
prepareRecord
startRecord
playAlert
startAlertQueue
mAlertQueue : AudioQueueStart
 but failed
mAlertQueue : AudioQueueStop
primeAlertQueue
VibeAlertCompletionProc
vibeStopAlertFinished
vibeStartAlertFinished
secondPassCompletionHostTime
stopRecord
doneRecording
stopRunningEngines
setAlertURL
checkForEndpoint
HandleDeferredContext_block_invoke
HandleConverterError
handleInterruptStart
handleInterruptStop
handleRouteChange
Illegal
interrupted
not (yet) active
_lookupEngineForDeviceUUID
'Unknown'
'Override'
'Wake From Sleep'
'No Suitable Route for Category'
'Configuration Change'
handleServerDeath
handleServerReset
createPlaybackQueue
handleEncodedFileRead
flushAndStopPlaybackQueue
handleEOF
handleAudioPlaybackStream
handleFileRead
AVVoiceController_PlaybackQueue
preparePlaybackQueue
startPlaybackQueue
prepareAudioFile
setupAudioFile
getRecordBufferDuration
setRecordBufferDuration
getStartRecordTime
setStartRecordTime
setContext
prepareRecordForStream
startRecordForStream
stopRecordOnStream
stopRecordForStream
getCurrentStreamStateForStream
getRecordBufferDurationForStream
configureAlertBehaviorForStream
activateAudioSessionForStream
setAudioSessionActive
deactivateAudioSessionWithOptions
setContextForStream
playAlertWithCompletion
getRecordDeviceInfoForStream
getRecordSettingsForStream
isMeteringEnabledForStream
updateMeterLevelForStream
getPeakPowerForStreamAndChannel
getAveragePowerForStreamAndChannel
playAlertWithOverride
playAlertWithOverride_block_invoke
configureAlertOverrides
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVC_Log.cpp
Initialize_Logging
debug_deviceselect
debug_playback
debug_delegate
debug_timing
debug_trace
debug_state
debug_locking
debug_callbacks
debug_endpoint
debug_encoding
debug_level
avvc
avvc_debug
availableCategories
category
categoryOptions
routeSharingPolicy
availableModes
recordPermission
otherAudioPlaying
TB,R,GisOtherAudioPlaying
secondaryAudioShouldBeSilencedHint
currentRoute
T@"AVAudioSessionRouteDescription",R
preferredInput
T@"AVAudioSessionPortDescription",R
availableInputs
promptStyle
allowHapticsAndSystemSoundsDuringRecording
AVAudioSessionSemaphore
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/AVAudioSession.mm
input
output
-[AVAudioSession privateUpdateDataSources:forInput:]
-[AVAudioSession enableNotifications:error:]
AVAudioSessionPropertyListener
HandleRouteChange
-[AVAudioSession privateHandleServerConnectionCompletion:]
-[AVAudioSession privateHandleServerConnectionCompletion:]_block_invoke
-[AVAudioSession privateHandleRoutingContextChange]
-[AVAudioSession privateHandleOtherPrimaryAudioPlayStateChange]
-[AVAudioSession privateHandleSecondaryAudioHintChange:]
-[AVAudioSession privateHandlePickableRoutesChange]
-[AVAudioSession privateHandleServerDied]
-[AVAudioSession privateInterruptionWithInfo:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/AVAudioSessionUtilities.h
GetProperty_DefaultToZero
GetProperty
ValidateActivationContext
-[AVAudioSession audioClockDevice]
-[AVAudioSession pickedRoute]
unknown route sharing policy
-[AVAudioSession privateSetRouteSharingPolicy:error:]
AVAudioSessionRouteSharingPolicyDefault
AVAudioSessionRouteSharingPolicyLongFormAudio
AVAudioSessionRouteSharingPolicyIndependent
AVAudioSessionRouteSharingPolicyLongFormVideo
-[AVAudioSession mode]
-[AVAudioSession activeSessionDisplayIDs]
TRUE
FALSE
-[AVAudioSession setAllowHapticsAndSystemSoundsDuringRecording:error:]
v12@?0C8
-[AVAudioSession recordPermission]
com.apple.AVAudioSessionActivation
-[AVAudioSession setActive:withOptions:error:]
ValidateRouteSharingPolicyParameters
Illegal route sharing policy specified
RouteSharingPolicyException
-[AVAudioSession category]
-[AVAudioSession initWithSessionID:]
outputNumberOfChannels
inputNumberOfChannels
audioFormat
audioFormats
isPiPAvailable
outputDataSources
inputDataSources
inputGain
avas
avaudiosession_verbose
GetNotificationRunLoopThread
-[AVAudioSession initWithSessionType:]
AVAudioSession Notify Thread
/System/Library/Frameworks/CoreMedia.framework/CoreMedia
CMAudioFormatDescriptionGetStreamBasicDescription
CMAudioFormatDescriptionCreate
CMAudioFormatDescriptionGetChannelLayout
CMAudioFormatDescriptionGetMagicCookie
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVCSessionManager.mm
-[AVVCSessionManager isAirplayOneOfTheOutputRoutes:]
-[AVVCSessionManager isSessionOutputInWirelessSplitterMode]
isSessionOutputInWirelessSplitterMode
AVOutputContext
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
-[AVVCSessionManager setSessionBufferSizeForRecordingEngine:]
setSessionBufferSizeForRecordingEngine
-[AVVCSessionManager setSessionSampleRateForActivationMode:]
setSessionSampleRateFromActivationMode
-[AVVCSessionManager setSessionAudioHWControlFlagsForActivationMode:]
setSessionAudioHWControlFlagsFromActivationMode
-[AVVCSessionManager setSessionCategoryModeOptionsForActivationMode:]
setSessionCategoryModeOptionsFromActivationMode
-[AVVCSessionManager getHypotheticalRouteAndUpdateStates]
getHypotheticalRouteAndUpdateStates
BTDetails_SupportsSoftwareVolume
BTDetails_SupportsDoAP
-[AVVCSessionManager shouldEnableMiniDucking:]
shouldEnableMiniDucking
-[AVVCSessionManager setSessionActivationContext:]
setSessionActivationContext
-[AVVCSessionManager setupOneTimeSessionSettings]
setupOneTimeSessionSettings
fileFormat
processingFormat
length
framePosition
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioFile.mm
-[AVAudioFile setFramePosition:]
_imp->CheckClientFormatSet()
ExtAudioFileSeek(_imp->_extAudioFile, pos)
-[AVAudioFile framePosition]
ExtAudioFileTell(_imp->_extAudioFile, &pos)
-[AVAudioFile length]
ExtAudioFileGetProperty(_imp->_extAudioFile, kExtAudioFileProperty_FileLengthFrames, &propSize, &length)
-[AVAudioFile readIntoBuffer:frameCount:error:]
buffer != nil
frames <= buffer.frameCapacity
ExtAudioFileRead(_imp->_extAudioFile, &ioFrames, buffer.mutableAudioBufferList)
-[AVAudioFile writeFromBuffer:error:]
ExtAudioFileWrite(_imp->_extAudioFile, buffer.frameLength, buffer.audioBufferList)
AVAudioFileImpl
ExtAudioFileGetProperty(openFileImpl->_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &openAudioFileID)
ExtAudioFileWrapAudioFileID(openAudioFileID, false, &_extAudioFile)
CheckClientFormatSet()
fileURL != nil
ExtAudioFileCreateWithURL((CFURLRef)fileURL, fileType, &fileASBD, NULL, kAudioFileFlags_EraseFile, &_extAudioFile)
SetFormats(format, interleaved, fileASBD, avacl)
ReadMagicCookie
_fileFormat
_processingFormat
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &fileID)
_initCommonReading
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_FileDataFormat, &propSize, &fileASBD)
ExtAudioFileOpenURL((CFURLRef)fileURL, &_extAudioFile)
portType
portName
hasHardwareVoiceCallProcessing
dataSources
selectedDataSource
T@"AVAudioSessionDataSourceDescription",R
preferredDataSource
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Aspen/AVFAudio/AVAudioSession/AVAudioSessionPortImpl.mm
ValidateRequiredFields
RouteDetailedDescription_HiddenDataSources
RouteDetailedDescription_DataSources
RouteDetailedDescription_SelectedDataSource
-[AVAudioSessionPortDescription initWithRawPortDescription:owningSession:]
RouteDetailedDescriptionKey_EndpointType
RouteDetailedDescription_IsLiveListenSupported
RouteDetailedDescription_IsVoiceProcessingSupported
RouteDetailedDescription_IsHeadphones
RouteDetailedDescription_ID
<%@: %p, type = %@; name = %@; UID = %@; selectedDataSource = %@>
impl
T^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}BB^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}},R,N
T@"AVAudioEngine",R,N
numberOfInputs
numberOfOutputs
lastRenderTime
AUAudioUnit
T@"AUAudioUnit",R,N
latency
outputPresentationLatency
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioNode.mm
-[AVAudioNode destinationForMixer:bus:]
mixer
GetMixingDestination
inMixerAVNode
-[AVAudioNode removeTapOnBus:]
NULL != engine
-[AVAudioNode installTapOnBus:bufferSize:format:block:]
tapBlock
connectionPoint
T@"AVAudioConnectionPoint",R,N
-[AVAudioMixingDestination destinationForMixer:bus:]
WillDisconnectFromMixer
mixingDest
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioNodeImpl.h
AVAE_CheckNodeHasEngine
_engine != nil
stereoPan
masterGain
globalTuning
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioUnitSampler.mm
-[AVAudioUnitSampler loadAudioFilesAtURLs:error:]
error
-[AVAudioUnitSampler loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:]
-[AVAudioUnitSampler loadInstrumentAtURL:error:]
aupreset
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioIONodeImpl.mm
_GetHWFormat
hwFormat
SetInputFormat
!_isInput
IsFormatSampleRateAndChannelCountValid(format)
SetOutputFormat
_isInput
IsFormatSampleRateAndChannelCountValid(hwFormat)
format.sampleRate == hwFormat.sampleRate
AVAudioIOUnit
AUI().AddV2PropertyListener(propID, IOUnitPropertyListener, this)
tracks
tempoTrack
T@"AVMusicTrack",R,N
userInfo
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioSequencer.mm
-[AVAudioSequencer dataWithSMPTEResolution:error:]
impl->WriteToData(&outData, (SInt32)SMPTEResolution)
-[AVAudioSequencer writeToURL:SMPTEResolution:replaceExisting:error:]
impl->WriteToFile((CFURLRef)fileURL, (SInt32)resolution, replace)
-[AVAudioSequencer loadFromData:options:error:]
impl->LoadFromData((CFDataRef)data, (UInt32)options)
-[AVAudioSequencer loadFromURL:options:error:]
impl->LoadFromFile((CFURLRef)fileURL, (UInt32)options)
destinationAudioUnit
T@"AVAudioUnit",&,N
destinationMIDIEndpoint
loopRange
T{_AVBeatRange=dd},N
loopingEnabled
TB,N,GisLoopingEnabled
offsetTime
muted
TB,N,GisMuted
soloed
TB,N,GisSoloed
lengthInBeats
lengthInSeconds
timeResolution
-[AVMusicTrack setNumberOfLoops:]
numberOfLoops != 0
currentPositionInSeconds
currentPositionInBeats
-[AVAudioSequencer(AVAudioSequencer_Player) stop]
impl->Stop()
-[AVAudioSequencer(AVAudioSequencer_Player) startAndReturnError:]
impl->Start()
-[AVAudioSequencer(AVAudioSequencer_Player) prepareToPlay]
impl->PrepareToPlay()
hostTimeValid
TB,R,N,GisHostTimeValid
hostTime
sampleTimeValid
TB,R,N,GisSampleTimeValid
sampleTime
audioTimeStamp
T{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II},R,N
%.6f s
%ld fr (/%.f Hz)
%.6f rs
<AVAudioTime %p: %s %s %s>
dspGraphURL
auProcessingStripURL
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioUnitDSPGraph.mm
/System/Library/Frameworks/AudioToolbox.framework/libAudioDSP.dylib
GetAudioDSPManager
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioUnitEffect.mm
-[AVAudioUnitEffect initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Effect) || (audioComponentDescription.componentType == kAudioUnitType_MusicEffect) || (audioComponentDescription.componentType == kAudioUnitType_Panner) || (audioComponentDescription.componentType == kAudioUnitType_RemoteEffect) || (audioComponentDescription.componentType == kAudioUnitType_RemoteMusicEffect)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioPlayerNode.mm
-[AVAudioPlayerNode playerTimeForNodeTime:]
nodeTime == nil || nodeTime.sampleTimeValid || nodeTime.hostTimeValid
-[AVAudioPlayerNode nodeTimeForPlayerTime:]
playerTime == nil || playerTime.sampleTimeValid || playerTime.hostTimeValid
-[AVAudioPlayerNode scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:]
stream != nil
when == nil || when.sampleTimeValid || when.hostTimeValid
startFrame >= 0
numberFrames > 0
HandleCompletionOfCommand
completionHandler != nil
_fileNumberOfBufferCommands > 0
SignalEndOfRender
completionHandlerWrapperPtr && completionHandlerWrapperPtr->Block()
CallCompletionHandler
completionHandler
ResolveToPlayerSampleTime
when.hostTimeValid
playerTime && playerTime.sampleTimeValid
v16@?0q8
-[AVAudioPlayerNode scheduleFile:atTime:completionCallbackType:completionHandler:]
file != nil
-[AVAudioPlayerNode scheduleBuffer:atTime:options:completionCallbackType:completionHandler:]
ScheduleBuffer
_outputFormat.channelCount == buffer.format.channelCount
AVAudioPlayerNodeImpl.CompletionHandlerQueue
CommandQueue
StartImpl
_engine->IsRunning()
nearFutureTime.sampleTimeValid
inTimeFull.sampleTimeValid
player did not see an IO cycle.
player started when in a disconnected state
avpln
avpln_verbose
voiceTriggerBlock
T@?,C,N,V_voiceTriggerBlock
speakerStateChangedBlock
T@?,C,N,V_speakerStateChangedBlock
speakerMuteStateChangedBlock
T@?,C,N,V_speakerMuteStateChangedBlock
serverCrashedBlock
T@?,C,N,V_serverCrashedBlock
serverResetBlock
T@?,C,N,V_serverResetBlock
listeningEnabledCompletionBlock:
updateVoiceTriggerConfiguration:completionBlock:
enableBargeInMode:completionBlock:
hasBargeInSupport
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVVoiceController/AVVoiceTriggerClient.mm
-[AVVoiceTriggerClient hasBargeInSupport]
v20@?0B8@"NSError"12
hasBargeInSupportCompletionBlock:
speakerStateMuted
-[AVVoiceTriggerClient speakerStateMuted]
speakerStateMutedCompletionBlock:
speakerStateActive
-[AVVoiceTriggerClient speakerStateActive]
speakerStateActiveCompletionBlock:
enableVoiceTriggerListening:
-[AVVoiceTriggerClient enableSpeakerStateListening:]
v16@?0@"NSError"8
enableSpeakerStateListening:completionBlock:
-[AVVoiceTriggerClient enableVoiceTriggerListening:]
voiceTriggerPastDataFramesAvailable
-[AVVoiceTriggerClient voiceTriggerPastDataFramesAvailable]
v24@?0Q8@"NSError"16
voiceTriggerPastDataFramesAvailableCompletion
handleMediaServerReset:
-[AVVoiceTriggerClient callServerResetBlock]
dealloc
-[AVVoiceTriggerClient dealloc]
AVVoiceTriggerClient init
-[AVVoiceTriggerClient init]
has_borealis_xpc
%s %s %s
T@"AUAudioUnit",R,D,N
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioUnit.mm
+[AVAudioUnit instantiateWithComponentDescription:options:completionHandler:]
comp != NULL
v20@?0^{OpaqueAudioComponentInstance=}8i16
AVAudioEngineConfigurationChangeNotification
musicSequence
T^{OpaqueMusicSequence=},N
T@"AVAudioOutputNode",R,N
inputNode
T@"AVAudioInputNode",R,N
mainMixerNode
T@"AVAudioMixerNode",R,N
TB,R,N,GisRunning
autoShutdownEnabled
TB,N,GisAutoShutdownEnabled
attachedNodes
T@"NSSet",R,C
manualRenderingBlock
T@?,R,N
isInManualRenderingMode
manualRenderingMode
manualRenderingFormat
manualRenderingMaximumFrameCount
manualRenderingSampleTime
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAudioEngine.mm
DisconnectAllMIDIOutputs
node != nil
_graph->DisconnectAllMIDIOutputs(node)
com.apple.avfaudio
avae
avae_verbose
DisconnectAllMIDIInputs
_graph->DisconnectAllMIDIInputs(node)
DisconnectMIDI
sourceNode != nil && destNodes != nil && destNodes.count > 0
object && [object isKindOfClass: [AVAudioNode class]]
_graph->DisconnectMIDI(sourceNode, destNodes)
sourceNode != nil && destNode != nil
ConnectMIDI
nil != sourceNode && nil != destNodes && [destNodes count] > 0
[_nodes containsObject: sourceNode]
node1 != nil && node2 != nil && node1 != node2
q28@?0I8^{AudioBufferList=I[1{AudioBuffer=II^v}]}12^i20
UpdateInputNode
[_inputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_inputNode)
 node: 
 (bus: 
ConnectMultipleOutputs
object && [object isKindOfClass: [AVAudioConnectionPoint class]]
[_nodes containsObject: connPoint.node]
sourceNode != connPoint.node
AttachNode
!IsInternalNode(node)
nil == owningEngine || GetEngine() == owningEngine
nodeimpl->HasEngineImpl()
DetachNode
!nodeimpl->HasEngineImpl()
GetOutputConnectionPointsForNode
node != nil && [_nodes containsObject: node]
GetIOUnit
!IsInManualRenderingMode()
UpdateOutputNode
[_outputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_outputNode)
Connect
node1 != nil && node2 != nil
node1 != node2
[_nodes containsObject: node1] && [_nodes containsObject: node2]
GetInputConnectionPointForNode
Uninitialize
_graph->Uninitialize(outErr)
Pause
_graph->Stop(outErr)
GetOutputNode
_outputNode != nil
SetSequence
_graph->SetSequence(inSequence)
CheckCanPerformIO
canPerformIO
DisconnectAllOutputs
[_nodes containsObject: node]
_graph->DisconnectAllOutputs(node)
DisconnectAllInputs
_graph->DisconnectAllInputs(node)
DisconnectOutput
_graph->DisconnectOutput(node, bus)
DisconnectInput
_graph->DisconnectInput(node, bus)
GetInputNode
_inputNode != nil
engine
UpdateIONodesForVP
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:false forceIOUnitReset:true]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:true forceIOUnitReset:true]
CreateGraphNode
_graph->AddNode(inNode)
DestroyGraphNode
_graph->RemoveNode(inNode, outErr)
InstallTapOnNode
_graph->InstallTapOnNode(inNode, bus, bufferSize, format, tapBlock)
RemoveTapOnNode
_graph->RemoveTapOnNode(inNode, bus)
AVFormatIDKey
AVSampleRateKey
AVNumberOfChannelsKey
AVLinearPCMBitDepthKey
AVLinearPCMIsBigEndianKey
AVLinearPCMIsFloatKey
AVLinearPCMIsNonInterleaved
AVAudioFileTypeKey
AVEncoderQualityKey
AVEncoderQualityForVBRKey
AVEncoderBitRateStrategyKey
AVEncoderBitRateKey
AVEncoderBitRatePerChannelKey
AVEncoderBitDepthHintKey
AVSampleRateConverterAlgorithmKey
AVSampleRateConverterQualityKey
AVChannelLayoutKey
AVAudioBitRateStrategy_Constant
AVAudioBitRateStrategy_LongTermAverage
AVAudioBitRateStrategy_VariableConstrained
AVAudioBitRateStrategy_Variable
AVSampleRateConverterAlgorithm_Normal
AVSampleRateConverterAlgorithm_Mastering
AVSampleRateConverterAlgorithm_MinimumPhase
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AUInterface.mm
RemoveRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &rcb, sizeof(rcb))
AddRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &inRenderCallback, sizeof(inRenderCallback))
AddRenderObserver
inRenderCallback.inputProc
v32@?0I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}12I20q24
SendMIDIEvent
nil != ScheduleMIDIEventBlock()
nullptr != midiBytes
SetNumberOutputs
[[auv3() outputBusses] setBusCount:(NSUInteger)numberOutputs error:&nsErr]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/Source/AVFAudio/AVAudioEngine/AVAEInternal.h
true
false
%s: returned %s, error %@
SetNumberInputs
[[auv3() inputBusses] setBusCount:(NSUInteger)numberInputs error:&nsErr]
SetFormat
[[busArray objectAtIndexedSubscript:(NSUInteger)element] setFormat:format error:&nsErr]
AUInterfaceBaseV3
comp != nullptr
AudioComponentInstanceNew(comp, &_auv2)
_auv2 != nullptr
_auv3 == nil
_auv3 != nil
nil != midiEventBlock
spew
minutiae
details
info
notice
note
warning
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/CoreAudioUtility/Source/Utility/CALog.cpp
RegisterScope
v16@?0^v8
ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
ret = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND)
DeviceClassNumber
/9luHerXthRoPoNt/PVkTg
nVh/gwNpy7Jv1NOk00CMrw
%04d-%02d-%02d 
%02d:%02d:%02d.%06d
%02X
, non-inter
, inter
%2d ch, %6.0f Hz, %s%s
%2d ch, %6.0f Hz, 'freq'
%2d ch, %6.0f Hz
%2d ch, %6.0f Hz, %s (0x%08X) 
 little-endian
 big-endian
 unsigned
 signed
integer
float
packed in %d bytes
unpacked in %d bytes
, deinterleaved
 low-aligned
 high-aligned
%d.%d
%s-bit%s%s %s%s%s%s%s
from %d-bit source, 
from UNKNOWN source bit depth, 
%d frames/packet
%d bits/channel, %d bytes/packet, %d frames/packet, %d bytes/frame
Float32
Int16
Int8.24
Float64
Int32
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
RealtimeMessenger.mServiceQueue
v8@?0
/BuildRoot/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-415.3/CoreAudioUtility/Source/Utility/RealtimeMessenger.cpp
PerformAsync
%25s:%-5d required condition is false: [%s:%d:%s: (%s)]
%s:%d:%s: RegisterObject: registering %p
%s:%d:%s: UnregisterObject: unregistering %p
 ASSERTION FAILED: unregistering a nonexistent object!
%s:%d:%s: Unknown ID for DataSource
%s:%d:%s: Unknown name for DataSource
%s:%d:%s: Unknown owning Port ID for DataSource
%s:%d:%s: Unknown selected polar pattern for DataSource.  There are %lu polar patterns
%s:%d:%s: nil data source description
%s:%d:%s: self(%p) controller(%p) plugin(%p), did UNpublish device(%p) with id(%@)
%s:%d:%s: ERROR: Received didUNpublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%s:%d:%s: WARNING: Not forwarding didUNpublish event to AVVC parent because it does not exist, or is deallocating.
%s:%d:%s: self(%p) controller(%p) plugin(%p), did publish device(%p) with id(%@)
%s:%d:%s: ERROR: Received didPublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%s:%d:%s: WARNING: Not forwarding didPublish event to AVVC parent because it does not exist, or is deallocating.
%s:%d:%s: Device(%p). Identifier: %@ (num devices = %d)
%s:%d:%s: Device(%p). Identifier: %@
%s:%d:%s: Cannot find Remote Input device %@
%s:%d:%s: findDeviceWithIdentifier: found the device %@
%s:%d:%s: plugin(%p) - device(%p) - id: %@
%s:%d:%s: Searching plugin path %@
%s:%d:%s: Error enumerating the remote input bundles at %@: %@
%s:%d:%s: invalidatePlugins : invalidating all plugins *** %p
%s:%d:%s: calling invalidate on plugin instance %p
%s:%d:%s: dealloc : releasing all plugins *** %p
%s:%d:%s: *** InitializePlugins *** %p 
%s:%d:%s: Plugin Bundle URL: %@
%s:%d:%s: initialized plugin class %@
%s:%d:%s: Unable to create the plugin bundle
%s:%d:%s: AVVCPluginRecordingEngine::getRecordRoute : no matching device found, error : %d
%s:%d:%s: active device doesn't support remoteInputDeviceName property
%s:%d:%s: finding the first device for activation mode (%{audio:4CC}d)  : %p
%s:%d:%s: device identifier shouldn't be NULL... 
%s:%d:%s: device identifier : %@
%s:%d:%s: Unable to create caf audio dump file '%s'. Error: %d
%s:%d:%s: Dumping caf input to '%s'
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Entering --->
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine: about to call stopRecordingCompletionBlock - previous stop completion block didn't happen
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  calling doneRecording manually
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  skipping doneRecording as we are deallocating
%s:%d:%s: destroyRecordEngine: device found, err : %d
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Exiting <---
%s:%d:%s: << %s
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine -- stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine - stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: >> %s
%s:%d:%s: AVVCPluginRecordingEngine::stopRecording: mRecordIsStopping set to true
%s:%d:%s: stopRecording:  No device found error :%d
%s:%d:%s: AVVCPluginRecordingEngine::stopRecording: resetting alert queue here
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: session state (%s), rec-engine (%p), rec-engine type (%s), stream state (%s), alert state (%s)
%s:%d:%s: (self %p)startRecord : using activeDevice: %p
%s:%d:%s: #### calling startRecordingWithCompletionBlock on device (%p) ####
%s:%d:%s: startRecordQueue:  No device found, err : %d
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING-PAUSED
%s:%d:%s: startRecordingWithCompletionBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: returned error(%d) : %@. Setting the audioInputBlock to nil.
%s:%d:%s: AVVCPluginRecordingEngine(%p)::createRecordQueue -->
%s:%d:%s: AVVCPluginRecordingEngine::createRecordQueue : no matching device found, error : %d
%s:%d:%s: createRecordQueue : using device %p
%s:%d:%s: Record queue state does not match queue (previously assertion failure)
%s:%d:%s: statusChangeBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%s:%d:%s: audioInputBlock (lpcm) called with frameLength : %d
%s:%d:%s: audioInputBlock (opus / speex) called with packetcount : %d
%s:%d:%s: audioInputBlock called with an unsupported audio format ID (%lu).
%s:%d:%s: audioInputBlock called
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: timeStamp : %f
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: Nil VoiceActivity NSData
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: inGain : %f
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: No Gain Value
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: No frame qualities.
%s:%d:%s: In AVVCPluginRecordingEngine::handleRecordInput: %u frames, hostTime : %lld, sampletime : %f
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput: record internally stopped, so throwing away buffer. StreamState(%s). RecordCancelled(%d)
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput - recordState is active, but getting nil buffer
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (opus). bufferLength : %d, packetCount : %d, packetDesc.startOffset %lld, packetDesc.mVariableFramesInPacket %u, packetDesc.DataByteSize = %u
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (opus): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%s:%d:%s: Setting up client buffer
%s:%d:%s: Copying BT audio buffer, size %u
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (speex): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput - Unsupported formatID: %u
%s:%d:%s: AudioFileWritePackets returned error %d, mPacketCount %d, numPackets %u, starting packet index : %d
%s:%d:%s: AudioFileWriteBytes returned error: %d, mLPCMCaptureByteOffset: %u
%s:%d:%s: Exiting AVVCPluginRecordingEngine::handleRecordInput
%s:%d:%s: selectRecordFormat: Supported Formats[%d] : %@ 
%s:%d:%s: Using Format[0] : %@ 
%s:%d:%s: *** createRecordQueue : No Format specified.. Error
%s:%d:%s: createRecordQueue : setting format on active device(%p), format:%@
%s:%d:%s: ~AVVCPluginRecordingEngine()
%s:%d:%s: AVVCPluginRecordingEngine()
%s:%d:%s: Not expected to see error code %d!
%s:%d:%s: -- %s failed to find a match for string "%@"
%s:%d:%s: Invalid parameter.  PortID: %@, DataSourceID: %@
%s:%d:%s: Returning %@
%s:%d:%s: AudioSessionGetProperty failed with code: %d
%s:%d:%s: Nil Port parameter
%s:%d:%s: AVVCRecordDeviceInfo dealloc. self(%p)
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine(%p). self(%p)
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine: recordDeviceName(%@)
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine: remoteDeviceUUID(%@)
%s:%d:%s: AVVCRecordDeviceInfo initWithVoiceController: remoteDeviceCategory(%d)
%s:%d:%s: #### AVVoiceController[self = %p]: setRecordStatusChangeBlock
%s:%d:%s: #### AVVoiceController[self = %p]: playAlertSoundForStream: alertType(%d) overrideMode(%d)
%s:%d:%s: playAlertSoundForStream failed with error : %d
%s:%d:%s: %s : %s : start: %s end: %s duration %.2f ms
%s:%d:%s: %s : start: %s end: %s duration %.2f ms
%s:%d:%s: #### AVVoiceController[self = %p]: playAlert alertType(%d). overrideMode(%d)
%s:%d:%s: #### AVVoiceController[self = %p]: setContextForStream: activationMode(%@), deviceUID(%@). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: deactivateAudioSessionWithOptions(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: getRecordDeviceInfoForStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: getCurrentStreamState: streamHandle(%lu). State(%s)
%s:%d:%s: #### AVVoiceController[self = %p]: stopRecordForStream: streamHandle(%lu)
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: stopRecordOnStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: configureAlertBehaviorForStream: streamHandle(%lu), AlertsOverride(%d,%d,%d)
%s:%d:%s: #### AVVoiceController[self = %p]: startRecordForStream: streamHandle(%lu), startTime(%u). AlertsOverride(%d,%d,%d)
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: startRecordWithSettings: streamHandle(%lu), startTime(%u). AlertsOverride(%d,%d,%d)
%s:%d:%s: #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%s:%d:%s: #### AVVoiceController[self = %p]: setContext: activationMode(%@), deviceUID(%@)
%s:%d:%s: #### AVVoiceController: initWithError (V2): [self == %p]
%s:%d:%s: initWithError: Failed to create ControllerImpl. Returning.
%s:%d:%s: initWithError: Failed to configureAlerts: %ld
%s:%d:%s: #### AVVoiceController: currentRecordDeviceInfo. self(%p) ####
%s:%d:%s: setStopOnEndpointEnabled: endpoint previously detected -- stopping capture
%s:%d:%s: #### AVVoiceController: setMeteringEnabled: %d ####
%s:%d:%s: about to unlock %s
%s:%d:%s: about to lock %s
%s:%d:%s: #### AVVoiceController: setPlaybackVolume: %f ####
%s:%d:%s: #### AVVoiceController: setAlertVolume: %f ####
%s:%d:%s: isRecording: rec-engine type: %s, stream state: %s
%s:%d:%s: #### AVVoiceController: setPlaybackBufferDuration: %f ####
%s:%d:%s: setPlaybackBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: setPlaybackDelegate: Cannot set while playback is active
%s:%d:%s: #### AVVoiceController: recordStartWaitTime: %f ####
%s:%d:%s: #### AVVoiceController: setRecordEndpointMode: %d ####
%s:%d:%s: #### AVVoiceController: setEndpointerDelegate ####
%s:%d:%s: #### setEndpointerDelegate: using %s endpointer ####
%s:%d:%s: #### AVVoiceController: setRecordBufferDuration: %f ####
%s:%d:%s: setRecordDelegate: Cannot set while record is active.
%s:%d:%s: setRecordDelegate: streamID(%lu) state(%s)
%s:%d:%s: #### AVVoiceController: stopPlaying ####
%s:%d:%s: #### AVVoiceController: startPlaying ####
%s:%d:%s: Attempt to play audio without configuring format
%s:%d:%s: startPlaying: called while already playing -- stopping previous play
%s:%d:%s: #### AVVoiceController: preparePlaybackFromURL: %@ ####
%s:%d:%s: preparePlaybackFromURL: audio is already playing
%s:%d:%s: #### AVVoiceController: preparePlaybackWithSettings %@ 
%s:%d:%s: preparePlaybackWithSettings: Can't perform this action while playback is active
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: #### AVVoiceController: stopRecording ####
%s:%d:%s: #### AVVoiceController:[self = %p] startRecordingWithSettings:error %@
%s:%d:%s: AVVoiceController: startRecordingWithSettings: Ignoring old style alert behavior
%s:%d:%s: #### AVVoiceController:[self = %p] startRecordingWithSettings:error = %d
%s:%d:%s: #### AVVoiceController: startRecordingAtTime:error [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecording:(NSError **) [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecordingAtTime:error : %d [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecording [self = %p]####
%s:%d:%s: #### AVVoiceController: playRecordStartingAlertAndResetEndpointer ####
%s:%d:%s: #### AVVoiceController::playRecordStartingAlertAndResetEndpointer current Context  %@ ####
%s:%d:%s: #### AVVoiceController: resetEndpointer ####
%s:%d:%s: call to playAlertSoundForType blocked because mediaserverd is dead
%s:%d:%s: #### AVVoiceController: playAlertSoundForType: %d [self = %p]####
%s:%d:%s: playAlertSoundForType: Session check failed: %s
%s:%d:%s: playAlertSoundForType: Illegal alertType
%s:%d:%s: #### AVVoiceController: setAlertSoundFromURL: forType: %d ####
%s:%d:%s: setAlertSoundFromURL:forType: Illegal alertType
%s:%d:%s: #### AVVoiceController[self = %p]: prepareRecordWithSettings: %@ 
%s:%d:%s: prepareRecordWithSettings failed with internal error %s
%s:%d:%s: #### prepareRecordWithSettings finished ####
%s:%d:%s: #### AVVoiceController[self = %p]: setCurrentContext: with context:%{audio:4CC}d %@
%s:%d:%s: #### setCurrentContext:error finished [self = %p]####
%s:%d:%s: ### unimplemented in this platform
%s:%d:%s: #### AVVoiceController: enableMiniDucking: %d
%s:%d:%s: #### AVVoiceController: willAcceptContext: with context:%{audio:4CC}d %@
%s:%d:%s: #### AVVoiceController: releaseAudioSession:options [self = %p] ####
%s:%d:%s: #### AVVoiceController: releaseAudioSession: [self = %p] ####
%s:%d:%s: #### AVVoiceController: dealloc [self == %p] ####
%s:%d:%s: #### AVVoiceController: exiting dealloc ####
%s:%d:%s: #### AVVoiceController: prewarmAudioSession: ####
%s:%d:%s: #### AVVoiceController: initWithContext: [self == %p]. with context:%{audio:4CC}d %@
%s:%d:%s: initWithContext: calling setSessionProperties
%s:%d:%s: AVVoiceController: initWithContext failure
%s:%d:%s: #### initWithContext finished [self = %p] ####
%s:%d:%s: prepareRecordWithSettings should be called first before asking for number of channels
%s:%d:%s: setStopOnBargeInEnabled: barge-in previously detected -- stopping playback
%s:%d:%s: Calling record delegate's voiceControllerDidSetAudioSessionActive. Going active? : %d
%s:%d:%s: Calling record delegate's voiceControllerWillSetAudioSessionActive. Going active? : %d
%s:%d:%s: Calling alert playback finished delegate. Settings { Type: %d, Mode: %d, alertEndTime: %llu }
%s:%d:%s: Calling alert playback finished delegate. Type: %d
%s:%d:%s: finishedPlaying -> called after object destroyed -- ignoring call
%s:%d:%s: #### finishedPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopPlaying:forReason:
%s:%d:%s: #### beganPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartPlaying:successfully:
%s:%d:%s: endpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### endpointDetected: time %.2f seconds ####
%s:%d:%s: interspeechPointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### interspeechPointDetected: time %.2f seconds ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectEndpoint:ofType:
%s:%d:%s: startpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### startpointDetected: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectStartpoint:
%s:%d:%s: finishedRecording -> called after object destroyed -- ignoring call
%s:%d:%s: finishedRecording -> called after dealloc -- ignoring call
%s:%d:%s: #### AVVoiceController: Recording finished (success = %d status = %d streamID = %llu) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopRecording:forReason:
%s:%d:%s: #### beganRecording: (success = %d status = %d streamID = %llu) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartRecording: variants
%s:%d:%s: Error! handlePluginDidUNpublishDevice: ControllerImpl is NULL
%s:%d:%s: Error! handlePluginDidPublishDevice: ControllerImpl is NULL
 ASSERTION FAILED: handleMediaServerReset: called with NULL impl!
 ASSERTION FAILED: handleMediaServerDeath: called with NULL impl!
 ASSERTION FAILED: handleRouteChange: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleRouteChange: %@
 ASSERTION FAILED: handleInterruption: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleInterruption: %@
%s:%d:%s: #### hardwareConfigChanged: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
%s:%d:%s: removeSessionNotifications: removing all notifications
%s:%d:%s: setSessionNotifications: setting up notifications
%s:%d:%s: QualityDetector: Start thresh: %u Start Timeout: %u End thresh: %u  End Timeout: %u
%s:%d:%s: QualityDetector: NONE => ACTIVE
%s:%d:%s: QualityDetector: NoSpeech; End Counter %u / %u
%s:%d:%s: QualityDetector: NONE => ENDED (TIMEOUT AT START)
%s:%d:%s: QualityDetector: Active; End Counter %u / %u
%s:%d:%s: QualityDetector: Active; Watching for end point (current frame quality: %u)
%s:%d:%s: QualityDetector: ACTIVE => ENDED
%s:%d:%s: QualityDetector: ACTIVE => ENDING
%s:%d:%s: QualityDetector: Speech Ending; End Counter %u / %u
%s:%d:%s: QualityDetector: ENDING => ACTIVE
%s:%d:%s: QualityDetector: ENDING => ENDED
 ASSERTION FAILED: inPastFrameCount <= mFrameHistoryLength
%s:%d:%s: QualityDetector: Start Timeout: %u frames
%s:%d:%s: QualityDetector: Interspeech Timeout: %u frames
%s:%d:%s: QualityDetector: End Timeout: %u frames
%s:%d:%s: SpeexEndpointer setEndWaitTime: %f
%s:%d:%s: SpeexEndpointer setInterspeechWaitTime: %f
%s:%d:%s: SpeexEndpointer setStartWaitTime: %f
%s:%d:%s: SpeexEndpointer setEndpointMode: %d
%s:%d:%s: SpeexEndpointer configureWithASBD:andFrameRate
%s:%d:%s: SpeexEndpointer configureWithSampleRate:
%s:%d:%s: SpeexEndpointer configureWithSampleRate:andFrameRate: illegal frame rate!
%s:%d:%s: SpeexEndpointer dealloc:
%s:%d:%s: SpeexEndpointer init:
 ASSERTION FAILED: getStatus called before object was configured!
%s:%d:%s: SpeexEndpointer getStatus: Raw Speex qlty frame %d/%d: %.2f rnng avrg: %.2f, med: %.2f, cls: %d
%s:%d:%s: #### SpeexEndpointer: Detected start point ####
%s:%d:%s: #### SpeexEndpointer: Detected soft end point ####
%s:%d:%s: #### SpeexEndpointer: Detected hard end point ####
%s:%d:%s: AVVCRecordingEngine::cacheRecordRoute : %@
%s:%d:%s: reconfigure for streamID(%lu) failed to destroy engine (%d)
%s:%d:%s: reconfigure for streamID(%lu) failed to prepareRecording (%d)
%s:%d:%s: AQ HW sample rate (%lf) is > %lf, limiting to %lf
%s:%d:%s: Adjusting AQ HW sample rate: %lf
%s:%d:%s: Adjusting plugin HW sample rate: %lf
 need to get HW samplerate from this engine type
%s:%d:%s: implSR(%.2f) GetSupportedSampleRate(%.2f) = %.2f
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %d
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %{audio:4CC}d
%s:%d:%s: Rebuilding queue for new audio format
%s:%d:%s: prepareRecord: CURRENT FORMAT: %s
%s:%d:%s: prepareRecord: CLIENT NEW FORMAT: %s
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %d
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %{audio:4CC}d
%s:%d:%s: AudioQueueGetProperty kAudioConverterSampleRateConverterQuality failed: %d
%s:%d:%s: AudioQueueGetProperty kAudioConverterPropertyBitDepthHint failed: %d
%s:%d:%s: AudioQueueGetProperty property size of kAudioQueueProperty_ChannelLayout failed: %d
%s:%d:%s: AudioQueueGetProperty kAudioQueueProperty_ChannelLayout failed: %d
%s:%d:%s: setStreamState (%s => %s)
%s:%d:%s: setRecordErrorStatus: %ld
%s:%d:%s: setRecordBufferDuration: Attempting to setRecordBufferDuration while record is active. Stream State(%s)
%s:%d:%s: setRecordBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: setRecordBufferDuration: rebuilding queue
%s:%d:%s: setRecordBufferDuration: Failed at prepareRecording (reconfig) : %d
%s:%d:%s: setRecordBufferDuration: duration now %.3f
%s:%d:%s: getRecordBufferDuration: choice 1 mRecordBasePacketsPerSecond (%lu)
%s:%d:%s: getRecordBufferDuration: choice 2 mRecordBasePacketsPerSecond (%lu)
%s:%d:%s: getRecordBufferDuration: returning %.3f seconds
%s:%d:%s: getPeakPowerForChannel on stream(%llu): returning %f for channel %d
%s:%d:%s: getAveragePowerForChannel on stream(%llu): returning %f for channel %d
%s:%d:%s: setStartRecordCompletionAndAudioCallbackBlocks: startCompletionBlock(%p). audioCallbackBlock(%p)
%s:%d:%s: setStopRecordCompletionBlock: stopCompletionBlock(%p).
%s:%d:%s: myBuffer->mAudioData : %p, myBuffer->mAudioDataByteSize : %d
%s:%d:%s: calling (v2) voiceControllerAudioCallback:forStream:buffer:
%s:%d:%s: Calling audioCallbackBlock for streamID(%lu) with mAudioDataByteSize: %u
%s:%d:%s: calling lpcmRecordBufferReceived:buffer
%s:%d:%s: calling voiceControllerRecordBufferAvailable:buffer
%s:%d:%s: Calling audioCallbackBlock for streamID(%lu) with mAudioDataByteSize: %u, with %u packet descs
%s:%d:%s: Calling audioCallbackBlock with lpcm data for streamID(%lu) with mAudioDataByteSize: %u, with %u packet descs
%s:%d:%s: Aborting (re)try for expired notifier for session %p.
%s:%d:%s: Attempting to contact server for session %p
%s:%d:%s: Calling completion handler for session %p
%s:%d:%s: Connection succeeded, but registration of server death notification failed.
%s:%d:%s: Encountered permanent connection failure for session %p.
%s:%d:%s: Retrying connection for session %p. Attempt count: %d
%s:%d:%s: Session with ID 0x%x not found
%s:%d:%s: Adding session %p with ID 0x%x
%s:%d:%s: Session ID 0x%x is already in use
%s:%d:%s: Did not find session %p in session map
%s:%d:%s: Removing session %p with ID 0x%x
%s:%d:%s: Removed session %p
%s:%d:%s: Session %p not found
%s:%d:%s: Session not valid! New ID is 0x%x
%s:%d:%s: Updating session ID. Old: 0x%x, New: 0x%x
%s:%d:%s: Session %p not found. Proceeding to adding entry with new session ID: 0x%x
%25s:%-5d [%s:%d:%s: (%s): error %d
%s:%d:%s: ---> this = %p
%s:%d:%s: <---
%s:%d:%s: %sabling looping [%.2f - %.2f]
%s:%d:%s: Track's sequence was NULL
%s:%d:%s: Underlying track already destroyed
%s:%d:%s: start -> %.2f [end %.2f]
%s:%d:%s: end -> %.2f [start %.2f]
%25s:%-5d Error fetching from ring buffer, this = %p, err = %d
%s:%d:%s: Unexpected nil channel description
%25s:%-5d graph@%p: couldn't initialize node@%p {%s}, error %d
%25s:%-5d Can't retrieve source node to play sequence because there is no output node!
 STACK_ABL: invalid number of buffers
%25s:%-5d AVAudioEngine (auto shutdown mode): left running idle for %.f s, stopping!
%25s:%-5d AVAudioEngine: left running idle for %.f s
%25s:%-5d AVAudioEngine (auto shutdown mode): starting IO dynamically
%25s:%-5d AVAudioEngine (auto shutdown mode): could not dynamically start the audio hardware, err = %s
%25s:%-5d setting output type = headphones
%25s:%-5d setting output type = built-in speakers
%25s:%-5d setting output type = external speakers
%25s:%-5d multiple outputs active, setting output type = external speakers
%25s:%-5d manual rendering mode, setting output type = external speakers
%s:%d:%s: starting sequence on client side
%s:%d:%s: finishing sequence on client side
%s:%d:%s: result data %@ output %li input %li sample rate %f
%s:%d:%s: Error creating XPC connection to %@
%s:%d:%s: Invalidation Handler: client exited
%s:%d:%s: Interruption Handler: connection got interrupted
%s:%d:%s: %@
%s:%d:%s: Logging PROFILE METRIC : %@
%s:%d:%s: Measuring Elapsed Time for %@ : %f ms
%s:%d:%s: AVVCMetricsManager: dealloc
%s:%d:%s: AVVCMetricsManager: sharedInstance is nil !!!!
%s:%d:%s: AVVCMetricsManager: destroySharedManager : referenceCount after decrementing = %llu
%s:%d:%s: AVVCMetricsManager: createSharedManager: referenceCount after incrementing = %llu
%25s:%-5d Error setting manual rendering mode input PCM format on input node! %s
%s:%d:%s: ---> self = %p
%25s:%-5d Unable to send midi event status(%d), channel(%d), param1(%d), param2(%d)
%25s:%-5d Unable to stop playing the note %d
%25s:%-5d Unable to start playing the note %d
%s:%d:%s: AVVCAudioQueueRecordingEngine::getRecordRoute : Cached record route is nil!
%s:%d:%s: UpdateRecordDeviceOnQueue : AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice) - %@
%s:%d:%s: UpdateRecordDeviceOnQueue: AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice - %d)
%s:%d:%s: setupAudioCaptureFile error from AudioQueueGetProperty (StreamDescription): %d
%s:%d:%s: Unable to create LPCM audio dump file '%s'. Error: %d
%s:%d:%s: Dumping LPCM input to '%s'
%s:%d:%s: (%p) - First callback from AQ -  inStartTime: ht %lld st %lld, Now : ht %lld, tempRecordStartTime : %lld. AQ difference: %0.6f ms
%s:%d:%s: handleRecordAQInput: sample time: %f, host time %llu, %llu frames (%d bytes), %d buffers enqueued
%s:%d:%s: handleRecordAQInput: throwing away zero-length buffer
%s:%d:%s: handleRecordAQInput: record internally stopped, so throwing away buffer
%s:%d:%s: handleRecordAQInput: encoder input: packetsAvailable: %u
%s:%d:%s: handleRecordAQInput: encoder input buffer %p: %u bytes, %u packets
%s:%d:%s: handleRecordAQInput: handing to converter: encoder output buffer: %u bytes, ioOutputDataPackets = %u
%s:%d:%s: handleRecordAQInput: err %s, got from converter %u encoded packets, %u bytes.  totalOutputByteSize = %u
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %{audio:4CC}d
%s:%d:%s: handleRecordAQInput: sending %u bytes of encoded data (addr %p) to client with %u packet descs @time %llu
%s:%d:%s: Re-enqueuing buffer %p (data ptr %p), size %u
 ASSERTION FAILED: AQ enqueue error while actively recording
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: Exiting handleRecordAQInput (%d buffers enqueued)
%s:%d:%s: RecordEncoderInputDataProc: ENTRY: *ioNumberDataPackets passed in: %u, packets remaining: %u, bytes already consumed: %u
%s:%d:%s: RecordEncoderInputDataProc: End of stream -- handing back zero size buffer
%s:%d:%s: RecordEncoderInputDataProc: Handing back ioData buffer %p of size %u
 ASSERTION FAILED: packetsRead <= packetsAvailable!
%s:%d:%s: RecordEncoderInputDataProc: EXIT: *ioNumberDataPackets passed back out: %u, status: %s
%s:%d:%s: nChannel:%d, startChannel:%d, mClientAudioBufferList->mBuffers[nChannel+startChannel].mData : %p
%s:%d:%s: AudioConverterConvertComplexBuffer failed with error : %d
%s:%d:%s: handleRecordAQPropertyChange: queue already destroyed -- noop
%s:%d:%s: handleRecordQueuePropertyListener (%p): Stream State: %s. AQ Running: %d
%s:%d:%s: Record Listener: RUNNING
%s:%d:%s: Record Listener: RUNNING-PAUSED
%s:%d:%s: Record Listener: STOPPED
%s:%d:%s: Record Listener: Converter error: %s
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %d
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %{audio:4CC}d
%s:%d:%s: doneRecording: resetting record queue
%s:%d:%s: AVVCAudioQueueRecordingEngine::updateMeterLevels: not fetching meter levels because one of them is untrue! mMeteringEnabled(%d), mRecordQueue(%d), mRecordMeters(%d)
%s:%d:%s: AVVCAudioQueueRecordingEngine::updateMeterLevels: Error! In fetching meter levels. Sending 'no signal'. Error(%d)
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %{audio:4CC}d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %{audio:4CC}d
%s:%d:%s: AVVCAudioQueueRecordingEngine: Record queue does not exist to enable metering. Caching, and will enable during prepare
%s:%d:%s: AVVCAudioQueueRecordingEngine: Enable Metering?: %d
%s:%d:%s: Calling destroyRecordEngine
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to true
%s:%d:%s: destroyRecordEngine: about to call AudioQueueStop(..., true)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine:  calling doneRecording by hand
%s:%d:%s: destroyRecordEngine:  skipping doneRecording call because we are deallocating
 ASSERTION FAILED: queue was running when destroyed but not asked to stop
%s:%d:%s: destroyRecordEngine: about to call AudioQueueDispose(..., true)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to false
%s:%d:%s: destroyRecordEngine: about to destroy audio converter
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %{audio:4CC}d
%s:%d:%s: AudioQueueRecordPropertyListenerProc called 
 ASSERTION FAILED: Rec AQ listener proc called with NULL impl!
%s:%d:%s: stopRecordQueue: mRecordIsStopping set to true
%s:%d:%s: ERROR: stopRecordQueue: AudioQueueStop err %d
%s:%d:%s: ERROR: stopRecordQueue: AudioQueueStop err %{audio:4CC}d
%s:%d:%s: AVVC stopped record queue%s (%d)
%s:%d:%s: AudioQueue startRecording: record state already started or stopping -- no-op
 ASSERTION FAILED: some buffers already enqueued!
%s:%d:%s: startRecordQueue: enqueing %d buffers
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: #### Starting record queue with delay ####
%s:%d:%s: #### Starting record queue immediately ####
%s:%d:%s: #### Starting record queue at time %llu ####
%s:%d:%s: AVVC starting record queue%s at time (%s) %lld (hosttime)
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: prepareRecord: retrieving voice trigger info
%s:%d:%s: prepareRecord: AudioQueueGetProperty(BorealisTriggerInfo) returned '%s'
%s:%d:%s: Record engine state does not match queue (previously assertion failure)
%s:%d:%s: Record Queue Format: %s
%s:%d:%s: Creating queue with flags 0x%x. %s runloops
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %{audio:4CC}d
%s:%d:%s: FAILED createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %{audio:4CC}d
%s:%d:%s: AQGetProperty - kAudioQueueDeviceProperty_NumberChannels returned : %u
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %{audio:4CC}d
%s:%d:%s: createRecordQueue: createAudioConverter error: %d. Destroying record queue.
%s:%d:%s: AudioConverter is not created.. reason: requested channels is 1 or requested interleaved audio or non-lpcm is requested
%s:%d:%s: FrameCapacity: %d. Buffer duration: %f s
%s:%d:%s: createRecordQueue: creating %u queue buffers %u bytes each
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: Creating AVAudioPCMBuffer with frameCapacity: %d. Buffer duration: %f s
%s:%d:%s: Unexpected Format found.. 
%s:%d:%s: createAudioConverter: INITIAL AUDIOCONVERTER OUTPUT FORMAT:
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %{audio:4CC}d
%s:%d:%s: createAudioConverter: initial frames per buffer = dur %.2f * sr %.2f = %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: corrupted values??? framesPerBuffer = %u, mRecordBufferDuration = %f
 ASSERTION FAILURE: mFramesPerPacket cannot be zero!
%s:%d:%s: createAudioConverter: setting audio converter format to %u frames per packet
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: %u atomic blocks per second
%s:%d:%s: kAudioConverterCurrentOutputStreamDescription ASBD's are different !! 
%s:%d:%s: createAudioConverter: encoded audio needs minimum of %u bytes per output buffer
%s:%d:%s: createAudioConverter: AudioConverterGetProperty(kAudioConverterPropertyMinimumOutputBufferSize) returned status %d
%s:%d:%s: createAudioConverter: final framesPerBuffer: %u
%s:%d:%s: createAudioConverter: mConvertPacketCount: %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: outputSizePerPacket: %u
%s:%d:%s: createAudioConverter: mConvertAudioCapacity %u bytes
%s:%d:%s: FINAL RECORD FORMAT:
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %{audio:4CC}d
%s:%d:%s: AudioQueueRecordInputCallback called 
%s:%d:%s: getRecordAndPlaybackRoutes: Nil recordingEngine!
%s:%d:%s: getRecordAndPlaybackRoutes: Nil currentRoute!
%s:%d:%s: getRecordAndPlaybackRoutes: Nil port type!
%s:%d:%s: getRecordAndPlaybackRoutes: AQ engine couldnt find routes since VSPD is not present!
%s:%d:%s: getRecordAndPlaybackRoutes: New Record Route %@
%s:%d:%s: getRecordAndPlaybackRoutes: New Playback Route: %@
%s:%d:%s: getRecordAndPlaybackRoutes: Nil route returned!
%s:%d:%s: getRecordAndPlaybackRoutes: No routes returned!
%s Likely ambiguous AVVC V2 use case detected. Must pass streamID here! (or V1 engine map integrity problem). numMapEngs(%lu) v1PluginEngInvalid(%d) v1AudioQueueEngInvalid(%d) v1ValidCase(%d) v2AmbiguousCase(%d)
%s:%d:%s: ASSERTION FAILURE [!streamIDViolation is false]: Likely ambiguous AVVC V2 use case detected. Must pass streamID here! (or V1 engine map integrity problem)
%s:%d:%s: ASSERTION FAILURE [eng != nullptr is false]: V1 engine map integrity problem. Couldn't find engine in map.
%s:%d:%s: No recording engine found for stream(%lu)
%s:%d:%s: ControllerImpl::Entering Dealloc
%s:%d:%s: QueueRunLoop stopped
%s:%d:%s: ControllerImpl::Exiting Dealloc
%s:%d:%s: getSessionProperties: unexpected 0.0 value for output latency
%s:%d:%s: getSessionProperties: working around bad input latency value for now
%s:%d:%s: getSessionProperties: input HW latency: %g output HW latency: %g
%s:%d:%s: getSessionProperties: input HW sampling rate %lf
%s:%d:%s: getSessionProperties: plugin mode - resetting to default HW sampling rate %lf
%s:%d:%s: getSessionProperties: Error getting input hardware sample rate
%s:%d:%s: getSessionProperties: Done.  Input HW sampling rate set to %lf - error (%d)
%s:%d:%s: setActivationContext setting audio session activation context to: %@
%s:%d:%s: setActivationContext: HACK: ignore switch away from RemoteSiri
%s:%d:%s: setActivationContext: 'live' switch out of VoiceActivated -- reset session properties
%s:%d:%s: setActivationContext: switching in/out of CarAudio -- reset session properties
%s:%d:%s: setActivationContext: switching out of iMessage -- reset session properties
%s:%d:%s: ERROR: setActivationContext: AVAudioSession setActivationContext err %s, session id:0x%x
%s:%d:%s: setActivationContext: done setting audio session activation context
%s:%d:%s: setActivationContext: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %d
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %{audio:4CC}d
%s:%d:%s: setActivationContext: session re-activated -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is active and mode changed -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is inactive -- route change notification or setSessionActive should generate a call to getSessionProperties
%s:%d:%s: session state => %s
%s:%d:%s: setActivationMode: voice activation
%s:%d:%s: setActivationMode: post-voice activation
%s:%d:%s: setActivationMode: iMessage nudge
%s:%d:%s: setActivationMode: iMessage gesture to head
%s:%d:%s: setActivationMode: ATVRemoteSiri
%s:%d:%s: setActivationMode: standard value (%s)
%s:%d:%s: setActivationMode: Cannot revert from mode %s to mode %s while audio session is active
%s:%d:%s: There are %u output port(s) in the current route:
%s:%d:%s: setActivationMode: will not take control of hardware upon activation for AirPlay output
%s:%d:%s: setActivationMode: setting volume required hardware control flag for 'voic' activation mode (ouput is not Airplay)
%s:%d:%s: ERROR: setActivationMode : Failed at setAudioHardwareControlFlags: %s
%s:%d:%s: setActivationMode: (hdvc / btdt / cpvc / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%s:%d:%s: setActivationMode: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%s:%d:%s: setActivationMode: enabling all 4 hw control flags
%s:%d:%s: ERROR: Failed at setAudioHardwareControlFlags: %s
%s:%d:%s: setActivationMode: Mode already set to %s. No change in AudioSession flags or options
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: iMessage -- setting P&R category, clearing preferred input, etc.
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode carplaySupportsMixableSiri: %d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: about to set Play&Record category, speech recognition/assistant mode. Current category: %@, mode: %@, options: 0x%x
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: category, mode and options are the same..
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: (%ld) mode. Options to set: %ld
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %{audio:4CC}d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: forcing 22050k audio for car audio
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: SR changes from %f to %f
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: SR remains at %f
%s:%d:%s: ASSERTION FAILED: calling setSessionProperties on a configured session. Crashing process!.
%s:%d:%s: setSessionProperties: done
%s:%d:%s: siri remote input device identifier : %@ - provided by siri
%s:%d:%s: updateMeters: Error, current recording engine is nil!
%s:%d:%s: enableMetering: Current recording engine is nil!
%s:%d:%s: setDuckOthersOption: %d. session state => %s
%s:%d:%s: Error (prev Assertion Failure): Calling setDuckOthersOption on an unconfigured session
%s:%d:%s: setDuckOthersOption: done : error : %d
%s:%d:%s: Resetting miniducking
 ASSERTION FAILED: ref'ing a zero-count object!
%s:%d:%s: Increment Ref count. New count: %ld
 ASSERTION FAILED: unref'ing a zero-count object!
%s:%d:%s: Decrementing Ref count. New count: %ld
%s:%d:%s: QueueRunLoop started
%s:%d:%s: Failed to start queue's run loop thread
%s:%d:%s: Dumping input (LPCM) or CAF (from plugin) to file
%s:%d:%s: Profiling AVVC NOW.
%s:%d:%s: Setting duck-others AudioSession option for CarPlay
%s:%d:%s: setStopWithErrorAlertMode: %s
%s:%d:%s: alert queue state => %s
%s:%d:%s: setStopAlertMode: %s
%s:%d:%s: setStartAlertMode: %s
%s:%d:%s: waiting for any in-flight AudioQueue property change message on run loop...
%s:%d:%s: CallbackBarrier: 9 second timeout!
%s:%d:%s: received all AudioQueue property change messages on run loop.
%s:%d:%s: setNoResumeOnDeactivate(TRUE): will not notify others on deactivation
%s:%d:%s: setNoResumeOnDeactivate(FALSE): will notify others on deactivation
%s:%d:%s: siriInputSource = %{audio:4CC}d
%s:%d:%s: currentRoute input count from AudioSession is : %lu : SiriRemoteInputID : %@
%s:%d:%s: Siri Remote Input DeviceID : %@ - provided by audio session
%s:%d:%s: getCurrentRecordDeviceUID: Error, current recording engine is nil!
%s:%d:%s: getDeviceUIDForHomeOrBluetoothButtonActivation : 'sobi'. InputRoutesCount(%u), SiriRemoteID(%@)
%s:%d:%s: getDeviceUIDForHomeOrBluetoothButtonActivation : %d
%s:%d:%s: handlePluginDidPublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%s:%d:%s: handlePluginDidUnpublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%s:%d:%s: removeEngineFromMapWithStreamID: engine(%p) stream(%llu) 
%s:%d:%s: Stopping recording here, plugin engine's remote device has been disconnected.
%s:%d:%s: Engine for streamID(%llu) not found.
%s:%d:%s: unlocker about to relock %s
%s:%d:%s: unlocker about to unlock %s
 ASSERTION FAILED: Unlocker attempted to unlock a mutex not owned by the current thread!
%s:%d:%s: Context is nil. can't decide what recording engine need to be created
%s:%d:%s: switching to %{audio:4CC}d mode - keeping the same recording engine (%p)
%s:%d:%s: current recording engine - %p. type: %s
%s:%d:%s: _createRecordingEngineWithParameters : Fatal Error! Invalid engine type!
%s:%d:%s: setContext: Created new (%s) engine(%p) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: Stopping recording here and removing engine
%s:%d:%s: configure: session not configured -- calling setSessionProperties
%s:%d:%s: setSessionActive: We have to wait for the session to be (re-)initialized
%s:%d:%s: setSessionActive: (re-)init done!
%s:%d:%s: setSessionActive: waiting...
%s:%d:%s: ERROR: setSessionActive: Timed out waiting for mediaserverd err %d
%s:%d:%s: #### AVVoiceController: Activating session [sSessionActiveCount now %d]####
%s:%d:%s: #### Error: negative or zero count detected -- resetting to 1 ####
%s:%d:%s: setSessionActive: setActive: TRUE for prewarming did not succeed
%s:%d:%s: #### AVVoiceController: [sSessionActiveCount back to %d]####
%s:%d:%s: setSessionActive: Activating : session options : %d
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE - err = %s, session id:0x%x
%s:%d:%s: setSessionActive(true): AVAudioSession:setActive has returned
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested - returned error : %d
%s:%d:%s: setSessionActive(true): Route change when we went active: %s -- getting properties
%s:%d:%s: #### AVVoiceController: error [sSessionActiveCount back to %d]####
%s:%d:%s: setSessionActive(false): sSessionActiveCount is %d -- not doing anything
%s:%d:%s: #### AVVoiceController: Deactivating session with notify [sSessionActiveCount = %d]####
%s:%d:%s: #### Error: negative count detected -- resetting to 0 ####
%s:%d:%s: setSessionActive(false): stopping playback queue
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %d
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): destroying record queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): in process of being destroyed -- kill the alert queue
%s:%d:%s: setSessionActive(false): resetting alert queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): alert state %s -- deactivating session asynchronously (NOT HERE) check alertFinished
%s:%d:%s: setSessionActive(true): session state already %s -- no-op
%s:%d:%s: %s - setSessionActive(false): session state already %s [sSessionActiveCount = %d] -- forcing deactivation, setting sSessionActiveCount to 0
%s:%d:%s: ERROR: %s setActive:FALSE withOptions: err %s
%s:%d:%s: #### AVVoiceController: %s - error [sSessionActiveCount back to %d]####
%s:%d:%s: #### AVVoiceController: %s - error AVAudioSessionErrorCodeMediaServicesFailed, sSessionActiveCount is %d####
 ASSERTION FAILED: alert queue NULL but state != Uninitialized
%s:%d:%s: detected unfinished alert, queue up alertFinished
%s:%d:%s: destroyAlertQueue: calling AudioQueueStop
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %{audio:4CC}d
%s:%d:%s: destroyAlertQueue: removing queue listener
%s:%d:%s: destroyAlertQueue: calling AudioQueueDispose
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: Alert Listener: impl or queue is NULL or object is being destroyed -- noop
%s:%d:%s: Alert Listener: in the middle of priming alert queue:  Doing nothing.  [THIS IS NEW BEHAVIOR]
%s:%d:%s: Alert Listener: mAlertQueueState = %s
%s:%d:%s: Alert Listener: RUNNING = %d
%s:%d:%s: Alert Listener: session was interrupted!  Doing nothing here
%s:%d:%s: Alert Listener: state already kAlertQueueRunning.  Doing nothing here
%s:%d:%s: Alert Listener: queue reports stopped on first IsRunning prop notification -- treat this like a regular start
%s:%d:%s: Alert Listener: unhandled inID %s
%s:%d:%s: alertFinished
%s:%d:%s: alertFinished: state = %s mRecordState: %s -- not priming alert
%s:%d:%s: alertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: #### fail [sSessionActiveCount back to %d]####
%s:%d:%s: #### In alertFinished but sSessionActiveCount is %d] !!! check !!!####
%s:%d:%s: alert state => %s
%s:%d:%s: alertStarted: record state != kRecordStarting -- noop
%s:%d:%s: alertStarted: not playing start alert -- noop
%s:%d:%s: Error! startedRecording: Nil recording engine! Bailing.
%s:%d:%s: startedRecording: calling startRecordCompletionBlock. Error: %@
%s:%d:%s: performSelectorOnMainThread: beganRecording:
%s:%d:%s: calling synchronously: beganRecording:
%s:%d:%s: Error setting recording from remote input %d, %@
%s:%d:%s: calculateRecordStartTime: Error, current recording engine is nil!
%s:%d:%s: WARNING: startRecordingAtTime:error was used without 'silent' start alert
%s:%d:%s: calculateRecordStartTime: queue plus HW delay time: %f seconds
%s:%d:%s: calculateRecordStartTime: host time for start of record: %.3f seconds
%s:%d:%s: this is %lld ticks beyond alert end (%.6f seconds in the future)
%s:%d:%s: calculateAlertTimes: alert queue already stopped -- using current time as end time
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %d
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): Deactivating session due to error: %d
%s:%d:%s: ERROR: setSessionActive: setActive: FALSE - err = %s, session id:0x%x
%s:%d:%s: Overwriting an already-deferred context
%s:%d:%s: releasing old device identifier
%s:%d:%s: setCurrentContext - deviceID passed : %@
%s:%d:%s: setCurrentContext:error: record is active -- deferring the context change
%s:%d:%s: setActivationContext in setCurrentContext failed! %d
%s:%d:%s: createRecordingEngine in setCurrentContext failed! %d
%s:%d:%s: setupAlert: NULL alert URL
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: setupAlert: Failed to load alert '%s'
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %{audio:4CC}d
%s:%d:%s: setupAlert: resetting alert queue
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %{audio:4CC}d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %{audio:4CC}d
 ASSERTION FAILED: PB AQ listener proc called with nullptr impl!
%s:%d:%s: Playback Listener: RUNNING = %d
%s:%d:%s: performSelectorOnMainThread: decodeError
%s:%d:%s: calling decodeError synchronously
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackRunning= %d
%s:%d:%s: mPlaybackRunning is true
%s:%d:%s: performSelectorOnMainThread: beganPlaying
%s:%d:%s: calling beganPlaying synchronously
%s:%d:%s: getCurrentRecordDeviceInfo: Current Recording Engine is nil!
%s:%d:%s: getCurrentRecordDeviceInfo: mCurrentRecordDeviceInfo already exists. Deleting old and creating new.
%s:%d:%s: recordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%s:%d:%s: getCurrentRecordSettings: Error, current recording engine is nil!
%s:%d:%s: %s: audio session is inactive or had been interrupted
%s:%d:%s: %s: rebuilding alert queue
%s:%d:%s: %s: calling prepare instead of create record queue
%s:%d:%s: getPeakPowerForChannel: Error, current recording engine is nil!
%s:%d:%s: isMeteringEnabled: Error, current recording engine is nil!
%s:%d:%s: setupEndpointer: configuring SR and wait times
%s:%d:%s: getRecordErrorStatus: Current recording engine is nil!
%s:%d:%s: Error! prepareRecordQueue: Nil recording engine! Bailing.
%s:%d:%s: configureAlertModeFromModeAndEngine: Nil recording engine. Abandon ship!
%s:%d:%s: configureAlertModeFromModeAndEngine: Wired headset output - disable ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: record start time was set -- check for ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: ZLL query - back frames: %u
%s:%d:%s: configureAlertModeFromModeAndEngine: CarPlay supports ZLL. recordStartTime : %llu
%s:%d:%s: configureAlertModeFromModeAndEngine: record start time not set
%s:%d:%s: configureAlertModeFromModeAndEngine: HomeButtonPress/UIButtonPress
%s:%d:%s: configureAlertModeFromModeAndEngine: %s
%s:%d:%s: configureAlertModeFromModeAndEngine: no vibrator support and no ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: Built-In/BT/CarPlay Voice Activation
%s:%d:%s: configureAlertModeFromModeAndEngine: VoiceTriggerTraining
%s:%d:%s: configureAlertModeFromModeAndEngine: iMessage
%s:%d:%s: configureAlertModeFromModeAndEngine: default
%s:%d:%s: configureAlertModeFromModeAndEngine: [final alert modes, overrides] : Start[%s, %s], Stop[%s, %s], StopWError[%s, %s])
%s:%d:%s: prepareRecord: Can't perform this action while record is starting or active
%s:%d:%s: prepareRecord: home/uibp/btbp/vehb button activation : after rechecking which engine to use %p
%s:%d:%s: prepareRecord: recording engine is not selected, %{audio:4CC}d
%s:%d:%s: startListen: Current recording engine is nil! Bailing!
%s:%d:%s: SECOND PASS-Start Record Delta %f ms
%s:%d:%s: Attempt to start recording without calling prepareRecordWithSettings:
%s:%d:%s: startRecord: already starting or active -- no-op
%s:%d:%s: startRecord: failed to play record-start alert. status = %d
%s:%d:%s: startRecord: returning failed record status %d
 ASSERTION FAILED: stream state > stopped after record failure
%s:%d:%s: playAlert: alertType = %d, primeFirst=true
%s:%d:%s: playAlert: using SSS to play haptic (or silence)
%s:%d:%s: playAlert: alert %d already in progress -- stop it now
%s:%d:%s: playAlert: silent start - fake a SS completion callback
%s:%d:%s: playAlert: non-blocking SSS alert for Siri startup
%s:%d:%s: playAlert: silent stop - fake a SS completion callback
%s:%d:%s: playAlert: calling AudioServicesPlaySystemSoundWithOptions with sound ID %u and flags %x
%s:%d:%s: playAlert: using alert queue to play beep
%s:%d:%s: playAlert: alert playback failed -- attempting to re-prime
%s:%d:%s: playAlert: Some Error occured! Not calling startAlertQueue() : %d
 ASSERTION FAILED: no alert buffer is enqueued!
%s:%d:%s: startAlertQueue: calling AudioQueueStart
%s:%d:%s: AVVC started alert queue%s (%d)
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %{audio:4CC}d
 ASSERTION FAILED: re-entrant request for different alert type
%s:%d:%s: primeAlertQueue: alert queue state '%s'.  reentrant or multi-threaded call -- returning
%s:%d:%s: primeAlertQueue: queue is NULL -- returning
%s:%d:%s: primeAlertQueue: type %d (current is %d)
%s:%d:%s: primeAlertQueue: sync-stopping active alert queue
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %{audio:4CC}d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: silent/haptic alert: not queueing a buffer
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: done. current is now %d
%s:%d:%s: primeAlertQueue: no-op
%s:%d:%s: VibeAlertCompletionProc: SSID %u done
%s:%d:%s: VibeAlertCompletionProc -> called after object destroyed -- ignoring call
%s:%d:%s: VibeAlertCompletionProc: object being destroyed -- bailing out
%s:%d:%s: VibeAlertCompletionProc: notified for other ssID %d -- no-op
%s:%d:%s: vibeStopAlertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: #### In vibeStopAlertFinished but sSessionActiveCount is %d, !!! check !!!####
%s:%d:%s: vibeStartAlertFinished: record state != kRecordStarting -- noop
%s:%d:%s: Stop record when stream state is %s
%s:%d:%s: stopRecord: already stopping or inactive -- no-op
%s:%d:%s: stopRecord: stopping queue at time %llu
%s:%d:%s: !!!! stopRecord: Recording engine is null -- this should not happen
%s:%d:%s: Error! doneRecording: Nil recording engine! Bailing.
%s:%d:%s: doneRecording: resetting mRecordIsStopping and mRecordIsPrimed
%s:%d:%s: doneRecording: calling startRecordCompletionBlock (notify start before stop). Error: %@
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls performSelectorOnMainThread: beganRecording:
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls beganRecording: synchronously
%s:%d:%s: doneRecording: calling stopRecordCompletionBlock. Error: %@
%s:%d:%s: doneRecording: calling recordStatusChangeBlock (unexpected didStop). Error: %@
%s:%d:%s: performSelectorOnMainThread: finishedRecording
%s:%d:%s: calling finishedRecording synchronously
%s:%d:%s: Interrupting recording on engine(%p) with streamID(%llu)
%s:%d:%s: checkForEndpoint entered: inBuffer %p
%s:%d:%s: performSelectorOnMainThread: startpointDetected
%s:%d:%s: calling startpointDetected synchronously
%s:%d:%s: performSelectorOnMainThread: interspeechPointDetected
%s:%d:%s: calling interspeechPointDetected synchronously 
%s:%d:%s: #### AVVoiceController: Detected end point but NO START POINT ####
%s:%d:%s: checkForEndpoint: auto-stopping record
%s:%d:%s: performSelectorOnMainThread: endpointDetected
%s:%d:%s: calling endpointDetected synchronously
%s:%d:%s: checkForEndpoint exiting
%s:%d:%s: Record Listener: handling deferred context change
%s:%d:%s:     Reporting encoder error %s via delegate
%s:%d:%s:     performSelectorOnMainThread: encodeError
%s:%d:%s:     calling encodeError synchronously
%s:%d:%s:     No delegate method found -- dropping error
%s:%d:%s: AVVoiceController -> Interruption beginning
%s:%d:%s:   We think our session was not active.  Make sure it isn't. deactivating session with options : %d
%s:%d:%s: deactivating session returned  : %d - error - %@
%s:%d:%s:   We are in the middle of activating!  Ignoring.
%s:%d:%s:   Playback was active
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackWasStarted = %d mPlaybackRunning= %d
%s:%d:%s: performSelectorOnMainThread: beginPlaybackInterruption
%s:%d:%s: calling beginPlaybackInterruption synchronously
%s:%d:%s: performSelectorOnMainThread: finishedPlaying
%s:%d:%s: calling finishedPlaying synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate is nil or does not respond to voiceControllerBeginPlaybackInterruption:
%s:%d:%s:   Record was active
%s:%d:%s:   sending notification with interruptor name
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruptionWithContext:
%s:%d:%s: calling beginRecordInterruptionWithContext synchronously
%s:%d:%s:   sending notification
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruption
%s:%d:%s: calling beginRecordInterruption synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate does not respond to voiceControllerBeginRecordInterruption:
%s:%d:%s:   Nothing active
%s:%d:%s: sSessionActiveCount now %d
%s:%d:%s: AVVoiceController -> Interruption ending
%s:%d:%s:   No longer reactivating audio session on interrupt end
%s:%d:%s:   destroying playback queue on resume (whether we were playing or not)
%s:%d:%s:   Was interrupted during playback
%s:%d:%s: performSelectorOnMainThread: endPlaybackInterruption
%s:%d:%s: calling endPlaybackInterruption synchronously
%s:%d:%s:   Was interrupted during recording -- stopping queue on resume
 Record should never be active when interrupt is ending!
%s:%d:%s: performSelectorOnMainThread: endRecordInterruption
%s:%d:%s: calling endRecordInterruption synchronously
%s:%d:%s:   We were never interrupted to begin with!
%s:%d:%s: AVVoiceController -> Route Change
%s:%d:%s: Route change reason : [%d] = %s
%s:%d:%s: Route really changed -- Re-checking properties
%s:%d:%s: Route really changed but session not-yet-active/interrupted -- set flag to check properties when we are active
%s:%d:%s: New route Category is not ours!
%s:%d:%s: We were waiting for a route change -- Re-checking properties
%s:%d:%s: Route change reason: category change - ignoring
%s:%d:%s: Category change came in while we were %s -- ignoring
%s:%d:%s: Route change reason: route configuration change - ignoring
%s:%d:%s: Route change reason was NULL
%s:%d:%s: No matching engine found for nil deviceUUID
%s:%d:%s: No matching plugin engine found for deviceUUID: %@
%s:%d:%s: AVVoiceController -> Server died!
%s:%d:%s: ControllerImpl::handleServerDeath: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerDeath: session is not configured
%s:%d:%s: ControllerImpl::handleServerDeath: Destroying internal state for later rebuild
%s:%d:%s: AVVoiceController -> Server reset after death
%s:%d:%s: ControllerImpl::handleServerReset: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerReset: restoring activation context and resetting session properties
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue: output queue format:
%s:%d:%s: %s
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %d
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %{audio:4CC}d
%s:%d:%s: createPlaybackQueue: bufferByteSize %u
packetsPerSecond %g
packetSizeUpperBound %u
%s:%d:%s: createPlaybackQueue: bufferByteSize adjusted to %u
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %d
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %{audio:4CC}d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: >>handleEncodedFileRead requesting: pkt pos %qd, %d packets, %d bytes. bytes capacity: %d  buffer: %p
%s:%d:%s: <<handleEncodedFileRead got %d packets, %d bytes, status %d
%s:%d:%s: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters: trim leading: %d, trim trailing: %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: handleAudioPlaybackStream: %d buffers now in queue.  Calling client.
%s:%d:%s: handleAudioPlaybackStream: Client filled buffer %p, size %d bytes
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: enqueued buffer %p mNumPlayBuffersEnqueued %d
%s:%d:%s: preparePlaybackQueue: mNumPlayBuffersEnqueued %d  numFramesPrepared %u  sr %g
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %d
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: numFramesPrepared %u  mNumPlayBuffersEnqueued %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %{audio:4CC}d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %{audio:4CC}d
%s:%d:%s: setupAudioFile: audio format from file:
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %d
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %{audio:4CC}d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %{audio:4CC}d
%s:%d:%s: getRecordBufferDuration: Error! _getCurrentRecordingEngine() is nil!
%s:%d:%s: setRecordBufferDuration: Error! _getCurrentRecordingEngine() is nil!
%s:%d:%s: getStartRecordTime: Error, current recording engine is nil!
%s:%d:%s: setStartRecordTime: Error, current recording engine is nil!
%s:%d:%s: setStartRecordTime: %llu
%s:%d:%s: Iterating through mRecordingEngineMap. AVVCStreamHandle(%lu). AVVCRecordEngine(%p). DeviceUID(%@). EngineType(%s)
%s:%d:%s: Found matching engine of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: Found matching Plugin engine for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: Found matching AudioQueue engine for activation mode(%@) with streamHandle(%lu)
%s:%d:%s: setContext: WARNING! A plugin activation context with null deviceUID passed! No-op, and setting dummy streamID!
%s:%d:%s: setContext: ERROR! No recording engine associated with device for post/auto activation context
%s:%d:%s: setContext: Engine lookup returned nil!
%s:%d:%s: prepareRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: ! DEPRECATED ! prepareRecordForStream: Found engine(%p) of type(%s) for streamID(%lu), with activation mode(%@)
%s:%d:%s: prepareRecordForStream: Failed to setRecordBufferDuration
%s:%d:%s: prepareRecordForStream: Error in prepareRecording: %d
%s:%d:%s: prepareRecordForStream: Error in enableSiriListeningMode(%u): %d
%s:%d:%s: prepareRecordForStream: Error in enableMetering: %d
%s:%d:%s: prepareRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: prepareRecordForStream: Found engine(%p) of type(%s) for streamID(%lu), with activation mode(%@)
%s:%d:%s: prepareRecordForStream: Failed to setRecordBufferDuration : %d
%s:%d:%s: startRecordForStream streamID(%lu)
%s:%d:%s: startRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: startRecordForStream: Attempt to start stream(%ld) without calling prepare.
%s:%d:%s: startRecordForStream: Attempt to start stream(%ld) while stream is already %s. No-op.
%s:%d:%s: ERROR in startRecordForStream, failed at playAlert: %d
%s:%d:%s: startRecordForStream: Error setting up audio capture file for streamID: %lu
%s:%d:%s: startRecordForStream: Error in enableSiriListeningMode(%u): %d
%s:%d:%s: startRecordForStream: Error in startRecording for stream(%lu): %d
%s:%d:%s: startRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: startRecordForStream: Error setting up audio capture file for streamID: %lu. Non-fatal
%s:%d:%s: stopRecordOnStream streamID(%lu)
%s:%d:%s: stopRecordOnStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: stopRecordOnStream: Attempt to stop on an %s stream.
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is already %s. No-op.
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is about to start. Observe this case. NotifyStartBeforeStop? Not doing anything here at the moment.
%s:%d:%s: stopRecordOnStream: Error stopping record engine: %d
%s:%d:%s: stopRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: stopRecordForStream: Attempt to stop on an %s stream.
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is about to start. NotifyStartBeforeStop
%s:%d:%s: stopRecord: record state == kRecordStarting but object being destroyed -- just stop queue
%s:%d:%s: stopRecord: record state == kRecordStarting -- we will need to send a start notify prior to stop
%s:%d:%s: stopRecord: record was just starting -- calling doneRecording ourselves -- watch this case
%s:%d:%s: getCurrentStreamState: Cannot find recording engine for streamID(%lu).
%s:%d:%s: getRecordBufferDurationForStream: Cannot find recording engine for streamID(%lu).
%s:%d:%s: configureAlertBehaviorForStream streamID(%lu)
%s:%d:%s: activateAudioSessionForStream ERROR: Cannot find recording engine for streamID(%lu). Bailing.
%s:%d:%s: About to activate audio session for stream(%lu). Current context: %@
%s:%d:%s: activateAudioSessionForStream for stream(%lu). isPrewarm(%d). CurrentState(%s).
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionActivationContext: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionBufferSizeForRecordingEngine: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed checkSession at setAudioSessionActive. SessionState(%s). OSStatus(%d).
%s:%d:%s: activateAudioSessionForStream [v2] : Previously used to call getSessionProperties_HWConfig here (but duplicate call). Observe if routes are not updated.
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at enableSiriListeningMode : %d
%s:%d:%s: deactivateAudioSessionWithOptions called on platform without AudioSession. No-op.
%s:%d:%s: ERROR: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: setContextForStream: Error! Incoming engine with streamID(%llu) and activation mode (%d) is different from engine that was used to activate the session, streamID(%llu) amd activation mode (%@)
%s:%d:%s: setContextForStream ERROR: Failed at setSessionActivationContext: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%s:%d:%s: setContextForStream: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%s:%d:%s: setContextForStream : Session re-activation failed with error : %d
%s:%d:%s: setContextForStream: session re-activated -- calling getSessionProperties
%s:%d:%s: playAlertWithCompletion: called when session inactive--do nothing and return error
%s:%d:%s: playAlertWithCompletion: Illegal alertType
%s:%d:%s: getRecordDeviceInfoForStream: Nil recording engine for streamID(%llu)
%s:%d:%s: StreamID(%llu). RecordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%s:%d:%s: getRecordSettingsForStream: Nil recording engine
%s:%d:%s: getRecordSettingsForStream: Error updating meter levels: %d
%s:%d:%s: playAlertWithOverride: called when session inactive--do nothing and return error
%s:%d:%s: Current Playback Route %@
%s:%d:%s: playAlertWithOverride: calling AudioServicesPlaySystemSoundWithOptions with sound ID %d
%s:%d:%s: playAlertWithOverride: Finished playing the alert beep
%s:%d:%s: configureAlertOverrides: Session is active. configureAlertModeFromModeAndEngine now. Current recording engine (%p), activation mode (%@)
%s:%d:%s: NOTE: AVVC Details logging is turned on by default for development
%s:%d:%s: debug_encoding on
%s:%d:%s: debug_endpoint on
%s:%d:%s: debug_callbacks on
%s:%d:%s: debug_locking on
%s:%d:%s: debug_state on
%s:%d:%s: debug_trace on
%s:%d:%s: debug_timing on
%s:%d:%s: debug_delegate on
%s:%d:%s: debug_playback on
%s:%d:%s: debug_deviceselect on
%s:%d:%s: debug_level = %d
%s:%d:%s: resetting debug_level to Notify to allow scoped logging
%s:%d:%s: debug priority: %u scopes: 0x%llx
%s:%d:%s: ---> for %s
%s:%d:%s: enableNotifications: inValue = %d
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_AudioInputAvailable
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_InterruptionInfo
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_InputGainScalar
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentHardwareOutputVolume
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_AudioRouteChange
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_PromptStyle
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentAudioFormats
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentHardwareInputNumberChannels
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_CurrentHardwareOutputNumberChannels
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_SecondaryAudioShouldBeSilencedHint
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_OtherPrimaryAudioPlayStateChange
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_PickableRoutesChange
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_PiPAvailable
 AudioSessionAddPropertyListener failed for kAudioSessionProperty_RoutingContextChange
%s:%d:%s: sessionID: 0x%x; property ID: %u
%s:%d:%s: interruption callback
%s:%d:%s: Getting previous route
%s:%d:%s: Getting new route dict
%s:%d:%s: Posting AVAudioSessionRouteChangeNotification. Reason: %@
%s:%d:%s: Updating inputDataSources: %@
%s:%d:%s: Updating outputDataSources: %@
%s:%d:%s: Received a pickable routes change notification
%s:%d:%s: Received a server death notification
%s:%d:%s: Received a routing context change notification
%s:%d:%s: Completion handler called for with invalid session ID
%s:%d:%s: Posting AVAudioSessionMediaServicesWereResetNotification
%s:%d:%s: Notifying listeners that routing context changed
%s:%d:%s: Notifying listeners that play state for other primary audio sessions changed
%s:%d:%s: Posting AVAudioSessionSilenceSecondaryAudioHintNotification
%s:%d:%s: Notifying listeners that pickable routes changed
%s:%d:%s: Posting AVAudioSessionMediaServicesWereLostNotification
%s:%d:%s: Posting AVAudioSessionInterruptionNotification (Begin Interruption). Was suspended:%d
%s:%d:%s: Posting AVAudioSessionInterruptionNotification (End Interruption). Resumable:%d
%s:%d:%s: AudioSessionGetProperty (%s) failed with error: %s
%s:%d:%s: BT activation contexts is missing its Device ID
%s:%d:%s: Call activation context is missing the accesibility preference value
%s:%d:%s: Call activation context is missing the call direction value
%s:%d:%s: Setting route sharing policy to %s
%s:%d:%s: No valid string for mode: %u
%s:%d:%s: ---> %s
%s:%d:%s: Permission already granted
%s:%d:%s: Permission already denied
%s:%d:%s: Permission undetermined
 Illegal permission property value returned from AudioSessionGetProperty
%s:%d:%s: Deactivating an audio session that has running I/O. All I/O should be stopped or paused prior to deactivating the audio session.
%s:%d:%s: %@ category is not supported in combination with %s
%s:%d:%s: %@ mode is not supported in combination with %s
%s:%d:%s: 0x%x category option(s) not supported in combination with %s
%s:%d:%s: No valid string for category: %u
%s:%d:%s: Lookup of session ID: 0x%x failed
%s:%d:%s: Failed to start internal run loop thread
%s:%d:%s: Initialization failed because there is no run loop thread.
%s:%d:%s: Synchronous connection to media server failed. Starting asynchronous connection attempt for session %p.
%s:%d:%s: Client app was linked against SDK version %x
%s:%d:%s: Output Port[%d / %d] : %@
%s:%d:%s: isSessionOutputInWirelessSplitterMode: supportsMultipleBTDevices: %d
%s:%d:%s: Wireless Output Devices: %@
%s:%d:%s: AVOutputDevice %p supports BT sharing: %d
%s:%d:%s: ERROR: AVVCSessionManager::setSessionBufferSize failed: %@
%s:%d:%s: AVVCSessionManager::setSessionBufferSizeForRecordingEngine: Current size: %d
%s:%d:%s: setSessionSampleRateFromActivationMode: forcing 22050k audio for car audio
%s:%d:%s: ERROR: AVVCSessionManager::setPreferredSampleRate for VehicleButtonPress : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: SR changes from %f to %f
%s:%d:%s: ERROR: AVVCSessionManager::setPreferredSampleRate to %f : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: SR remains at %f
%s:%d:%s: setSessionAudioHWControlFlags: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (HomePod) : %@
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags on older watch hardware: will never take control of HW on activation
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: wireless splitter mode, no volume control, yes routing control.
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (wireless splitter) : %@
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: disable mini-ducking. Set all HW control flags
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (disable mini-ducking) : %@
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: will not take control of hardware upon activation for AirPlay output (voic/rais)
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: setting volume required hardware control flag for 'voic/rais' activation mode (ouput is not Airplay)
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : set all hw control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: default mode - set all HW control flags
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags : %@
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions on 'audioOS'. Duck others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions on older watchOS. Interrupt others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: (wireless splitter mode). Interrupt others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: iMessage -- setting P&R category, clearing preferred input, etc.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: Carplay Supports Mixable Siri
%s:%d:%s: AVVCSessionManager : category, mode and options are the same (Current activation: %d, Previous activation: %d). No-op
%s:%d:%s: AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x. (Current activation: %d, Previous activation: %d)
%s:%d:%s: ERROR: AVVCSessionManager : setCategoryModeOptions failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::clearInputPreferences failed with error: %@
%s:%d:%s: getHypotheticalRouteAndUpdateStates: pickedRoute from AudioSession: %@
%s:%d:%s: setupSessionInterruptionOrDuckingBehavior: isSomeOtherAudioPlaying: %d
%s:%d:%s: getHypotheticalRouteAndUpdateStates : shouldDuckOthers(%d), sessionNeedsVolumeControl(%d)
%s:%d:%s: enableMiniDucking: Called on HomePod like device, no-op
%s:%d:%s: shouldEnableMiniDucking: No change, no-op
%s:%d:%s: AVVCSessionManager::setSessionActivationContext : passed 'nil' dictionary, creating empty one.
%s:%d:%s: ERROR: AVVCSessionManager::setActivationContext of sessionID(0x%x) failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeOptions failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setIAmTheAssistant failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setAllowHapticsAndSystemSoundsDuringRecording failed with error: %@
%s:%d:%s: Unknown ID for Port
%s:%d:%s: Unknown type for Port
%s:%d:%s: Unknown name for Port
%s:%d:%s: Unknown UID for Port
%s:%d:%s: Unknown selected data source for Port %@ (type: %@)
%s:%d:%s: Unexpected nil value for port description
%s:%d:%s: Raw port type: %@
%s:%d:%s: Final port type: %@
%25s:%-5d unable to get property kAUDSPGraphProperty_AUStrip %i
%25s:%-5d unable to get property kAUDSPGraphProperty_GraphTextFilePath %i
%25s:%-5d Error: Unable to call RegisterAudioUnits_Internal from libAudioDSP.dylib.
%25s:%-5d Player@%p: Engine is in the middle of a config change, cannot play yet!
%25s:%-5d Player@%p: Engine could not start the audio hardware dynamically, cannot play!
%25s:%-5d Player@%p: Engine config changed when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: IOUnit stopped when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: Engine returned render error: %ld, node: %p {%s}, cannot play!
%s:%d:%s: server timeout
%s:%d:%s: server reset
%s:%d:%s: AVVoiceTriggerClient dealloc %@
%s:%d:%s: AVVoiceTriggerClient init %@
%25s:%-5d Engine@%p: disconnect MIDI outputs on node: %p
%25s:%-5d Engine@%p: disconnect MIDI inputs on node: %p
%25s:%-5d Engine@%p: disconnect MIDI node: %p from nodes: %s
%25s:%-5d Engine@%p: disconnect MIDI node: %p from node: %p
%25s:%-5d Engine@%p: connect MIDI node: %p -> %s, format: %s
%25s:%-5d Engine@%p: connect MIDI node: %p -> node: %p, format: %s
%25s:%-5d Engine@%p: could not disable manual rendering mode
%25s:%-5d Engine@%p: connect node: %p (from bus: %lu) ->%s, format: %s
%25s:%-5d Engine@%p: connect node1: %p (from bus: %lu) -> node2: %p (to bus: %lu), format: %s
%25s:%-5d Engine@%p: stop
%25s:%-5d Engine@%p: uninitialize
%25s:%-5d Engine@%p: pause
%25s:%-5d Engine@%p: could not initialize, error = %d
%25s:%-5d Engine@%p: initialize
%25s:%-5d Engine@%p: start
%25s:%-5d Engine@%p: disconnect all outputs on node: %p
%25s:%-5d Engine@%p: disconnect all inputs on node: %p
%25s:%-5d Engine@%p: disconnect output bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect input bus: %lu on node: %p
%25s:%-5d Engine#%p: error: couldn't connect mixer to output node!
%25s:%-5d Engine@%p: iounit configuration changed > setting flag
%25s:%-5d Engine@%p: iounit configuration changed > stopping the engine
%25s:%-5d Engine@%p: iounit configuration changed > posting notification
%25s:%-5d Engine@%p: iounit configuration changed < posted notification
%25s:%-5d Engine@%p: iounit stopped unexpectedly > pausing the engine
%25s:%-5d Engine@%p: install tap on node %p, bus%lu, bufferSize %d, format: %s
%25s:%-5d Engine@%p: remove tap from node %p, bus%lu
%25s:%-5d [%s:%d:%s: (%s)] returned %s, error %@
%s:%d:%s: ERROR: subscope bits are set in scope: 0x%lx
 ca_verify_noerr: [%s, %d]
 CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)
 CAMutex::Unlock: Could not unlock the mutex
 CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own
 CAMutex::Lock: Could not lock the mutex
 CAMutex::CAMutex: Could not init the mutex
 PackednessIsSignificant only applies for PCM
 CAGuard::NotifyAll: failed
 CAGuard::Notify: failed
 CAGuard::WaitFor: A thread has to have locked a guard be for it can wait
 CAGuard::WaitFor: Wait got an error
 CAGuard::Wait: A thread has to have locked a guard before it can wait
 CAGuard::Wait: Could not wait for a signal
 CAGuard::CAGuard: Could not init the cond var
%s:%d:%s: RealtimeMessenger: trying to enqueue duplicate invocation on message %p
 CAPThread::Start: can't start because the thread is already running
 CAPThread::Start: Thread attributes could not be created.
 CAPThread::Start: A thread could not be created in the detached state.
 CAPThread::Start: Could not create a thread.
 CAPThread::SetTimeConstraints: thread_policy_set failed, Error: %d (%s)
 CAPThread::SetPriority: failed to set the fixed-priority policy, Error: 0x%X
 CAPThread::SetPriority: failed to set the precedence policy, Error: 0x%X
AVAudioIONode
AVAudioOutputNode
NSObject
AVAudioStereoMixing
AVAudio3DMixing
AVAudioMixing
AVAudioInputNode
AVAudioConnectionPoint
AVAudioSessionDataSourceDescription
AVVCRemoteInputHost
AVAudioRemoteInputPluginDelegate
AVAudioRemoteInputPlugin
AVVCRecordDeviceInfo
AVVCAlertInformation
AVVoiceController
AVVCContextSettings
AVVCPrepareRecordSettings
AVVCConfigureAlertBehaviorSettings
AVVCStartRecordSettings
AVVoiceControllerInternal
AVVoiceController_Priv
AVAudioUnitComponent
SpeexEndpointer
Endpointer
SpeexEndpointer_Priv
AVAudioUnitTimeEffect
AVAudioSessionRouteDescription
AVAudioSessionPrivate
AVAudioUnitComponentManager
AVAudioUnitDelay
VoiceVerificationEndpointer
AVAudioUnitVarispeed
AVAudioUnitReverb
AVAudioUnitTimePitch
AudioPlayerImpl
AVAudioPlayer
AVAudioPlayerPriv
AVAudioUnitGenerator
AVAudioRecorder
AVAudioSessionParticipant
AVAudioSinkNode
AVAudioSessionChannelDescription
AVAudioChannelLayout
NSSecureCoding
NSCoding
AVAudioDeviceTest
AVAudioDeviceTestServiceProtocol
AVAudioConverter
Encoding
AVVCMetricsManager
AVAudioUnitDistortion
AVAudioMixerNode
AVAudioClock
AVMIDIPlayer
AVMIDIPlayerPriv
AVAudioUnitMIDIInstrument
AVAudioBuffer
NSMutableCopying
NSCopying
AVAudioPCMBuffer
AVAudioCompressedBuffer
AVAudioUnitSplitter
AVAudioUnitEQFilterParameters
AVAudioUnitEQ
AVAudioFormat
AVAudioDeviceTestResult
AVAudioDeviceTestSequence
AVAudioDeviceTestProcessingChain
AVAudioSourceNode
AVSpeechSynthesisVoice
AVSpeechUtterance
AVSpeechSynthesizer
CommonImplementation
AVVCAudioBuffer
AVVCAudioBufferPriv
AVAudioEnvironmentDistanceAttenuationParameters
AVAudioEnvironmentReverbParameters
AVAudioEnvironmentNode
AVAudioSession
AVVCSessionManager
AVAudioFile
AVAudioSessionPortDescription
AVAudioNode
AVAudioMixingDestination
AVAudioUnitSampler
AVAudioSequencer
AVMusicTrack
AVAudioSequencer_Player
AVAudioTime
AVAudioUnitDSPGraph
AVAudioUnitEffect
AVAudioPlayerNode
AVVoiceTriggerClient
AVAudioUnit
AVAudioEngine
initWithIOUnit:isInput:
presentationLatency
audioUnit
didAttachToEngine:
didDetachFromEngine:error:
isInManualRenderingMode
manualRenderingMode
setVoiceProcessingEnabled:error:
isVoiceProcessingEnabled
enableManualRenderingMode:isInput:
enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:
raise:format:arguments:
setManualRenderingPCMFormat:maximumFrameCount:
manualRenderingFormat
manualRenderingMaximumFrameCount
isEqual:
debugDescription
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
setPan:
renderingAlgorithm
setRenderingAlgorithm:
sourceMode
setSourceMode:
pointSourceInHeadMode
setPointSourceInHeadMode:
rate
setRate:
reverbBlend
setReverbBlend:
obstruction
setObstruction:
occlusion
setOcclusion:
position
setPosition:
destinationForMixer:bus:
volume
setVolume:
setManualRenderingInputPCMFormat:inputBlock:
isVoiceProcessingBypassed
setVoiceProcessingBypassed:
isVoiceProcessingAGCEnabled
setVoiceProcessingAGCEnabled:
isVoiceProcessingInputMuted
setVoiceProcessingInputMuted:
_node
_bus
_reserved
init
initWithNode:bus:
dealloc
node
connectionPointWithNode:bus:
objectForKey:
unsignedIntegerValue
count
dictionaryWithDictionary:
regularExpressionWithPattern:options:error:
firstMatchInString:options:range:
range
substringWithRange:
doubleValue
whitespaceAndNewlineCharacterSet
stringByTrimmingCharactersInSet:
stringWithCString:encoding:
_impl
initWithSessionID:
isEqualToDataSource:
dataSourceID
dataSourceName
location
orientation
selectedPolarPattern
preferredPolarPattern
supportedPolarPatterns
setPreferredPolarPattern:error:
privateGetImplementation
privateMatchesRawDescription:
initWithRawSourceDescription:andOwningPortID:andSessionID:
configurePolarPatterns:
privateGetOwningPortID
initWithInt:
initWithArray:
addObject:
countByEnumeratingWithState:objects:count:
arrayWithCapacity:
isEqualToValue:
arrayWithObject:
dictionaryWithObjectsAndKeys:
numberWithUnsignedInt:
errorWithDomain:code:userInfo:
stringWithFormat:
isEqualToString:
isEqualToNumber:
privateCreateArray:portID:sessionID:
insertObject:atIndex:
objectAtIndex:
initWithCapacity:
mPlugins
mMotherController
inputPlugin:didPublishDevice:
inputPlugin:didUnpublishDevice:
initializePlugins
invalidatePlugins
allBundles:
findDeviceWithIdentifier:
findFirstBluetoothDevice
setParentVoiceController:
deviceIdentifier
deviceCategory
devices
addObjectsFromArray:
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
absoluteString
URLByAppendingPathComponent:
array
URLsForDirectory:inDomains:
defaultManager
invalidate
initWithPluginDelegate:
alloc
principalClass
bundleWithURL:
copy
remoteInputDeviceName
stringWithString:
setStatusChangeBlock:
setAudioInputBlock:
stopRecordingWithCompletionBlock:
code
startRecordingWithCompletionBlock:
numberWithUnsignedLongLong:
startRecordingWithSettings:withCompletionBlock:
getBytes:range:
audioInputBlock
setFormat:
objectAtIndexedSubscript:
supportedFormats
unsignedIntValue
compare:
_isRemoteDevice
_remoteDeviceCategory
_recordRoute
_remoteProductIdentifier
_remoteDeviceUID
initWithRecordingEngine:
recordRoute
isRemoteDevice
remoteProductIdentifier
remoteDeviceUID
remoteDeviceCategory
initWithUUIDString:
_type
_mode
_alertEndTime
initWithAlertType:mode:endTime:
type
setType:
mode
setMode:
alertEndTime
setAlertEndTime:
_alertStartTime
initWithContext:error:
prewarmAudioSession
finalize
releaseAudioSession
releaseAudioSession:
willAcceptContext:
enableMiniDucking:
IsDeviceAvailableInLocalRoute:error:
setCurrentContext:error:
prepareRecordWithSettings:error:
setAlertSoundFromURL:forType:
playAlertSoundForType:
resetEndpointer
playRecordStartingAlertAndResetEndpointer
doStartRecordingAtTime:behavior:
setupAlertBehavior:
startRecording
startRecording:
startRecordingAtTime:error:
startRecordingWithSettings:error:
stopRecording
preparePlaybackWithSettings:error:
preparePlaybackFromURL:error:
startPlaying
stopPlaying
recordDelegate
setRecordDelegate:
recordSettings
getRecordBufferDuration
setRecordBufferDuration:
endpointerDelegate
setEndpointerDelegate:
recordEndpointMode
setRecordEndpointMode:
recordStartWaitTime
setRecordStartWaitTime:
recordInterspeechWaitTime
setRecordInterspeechWaitTime:
recordEndWaitTime
setRecordEndWaitTime:
playbackDelegate
setPlaybackDelegate:
playbackSettings
getPlaybackBufferDuration
setPlaybackBufferDuration:
isPlaying
isRecording
setAlertVolume:
alertVolume
getAlertStartTime
setPlaybackVolume:
playbackVolume
isMeteringEnabled
setMeteringEnabled:
updateMeters
peakPowerForChannel:
averagePowerForChannel:
isStopOnEndpointEnabled
setStopOnEndpointEnabled:
metrics
currentRecordDeviceInfo
initWithError:
setContext:error:
prepareRecordForStream:completion:
prepareRecordForStream:error:
startRecordWithSettings:completion:alertCompletion:audioCallback:
startRecordForStream:error:
configureAlertBehaviorForStream:error:
stopRecordOnStream:completion:
stopRecordForStream:error:
getCurrentStreamState:
getRecordDeviceInfoForStream:
activateAudioSessionForStream:isPrewarm:error:
deactivateAudioSessionWithOptions:
getCurrentSessionState
setContextForStream:forStream:error:
playAlert:withOverride:completion:
playAlertSoundForType:overrideMode:
getRecordBufferDurationForStream:
getRecordSettingsForStream:
isMeteringEnabledForStream:
updateMeterForStream:
getPeakPowerForStream:forChannel:
getAveragePowerForStream:forChannel:
setRecordStatusChangeBlock:
alertStartTime
activationDeviceUID
activationMode
stopOnErrorAlert
stopAlert
startAlert
streamID
startHostTime
avAudioSettings
recordBufferDuration
setSessionNotifications
unsignedLongLongValue
intValue
removeSessionNotifications
_activationMode
_activationDeviceUID
initWithMode:deviceUID:
setActivationMode:
setActivationDeviceUID:
_meteringEnabled
_streamID
_avAudioSettings
_recordBufferDuration
initWithStreamID:settings:bufferDuration:
setStreamID:
setAvAudioSettings:
meteringEnabled
_startAlert
_stopAlert
_stopOnErrorAlert
initWithStreamID:
setStartAlert:
setStopAlert:
setStopOnErrorAlert:
_startHostTime
initWithStreamID:atStartHostTime:
setStartHostTime:
voiceControllerDidStartRecording:successfully:error:
voiceControllerDidStartRecording:successfully:
voiceControllerDidStopRecording:forStream:forReason:
voiceControllerDidStopRecording:forReason:
voiceControllerDidDetectStartpoint:
voiceControllerDidDetectEndpoint:ofType:atTime:
voiceControllerDidDetectEndpoint:ofType:
voiceControllerEncoderErrorDidOccur:error:
voiceControllerDidStartPlaying:successfully:
voiceControllerPlaybackBufferAvailable:buffer:
voiceControllerDidStopPlaying:forReason:
voiceControllerDecoderErrorDidOccur:error:
voiceControllerDidFinishAlertPlayback:withSettings:error:
voiceControllerDidFinishAlertPlayback:ofType:error:
voiceControllerBeginRecordInterruption:
voiceControllerBeginRecordInterruption:withContext:
voiceControllerEndRecordInterruption:
voiceControllerBeginPlaybackInterruption:
voiceControllerEndPlaybackInterruption:
voiceControllerWillSetAudioSessionActive:willActivate:
voiceControllerDidSetAudioSessionActive:isActivated:
impl
hardwareConfigChanged
handlePluginDidPublishDevice:withDevice:
handlePluginDidUnpublishDevice:withDevice:
beganRecording:
finishedRecording:
startpointDetected
interspeechPointDetected
endpointDetected
encodeError
beganPlaying
playbackBufferReceived:
finishedPlaying
decodeError
alertPlaybackFinishedOfType:
beginRecordInterruption
beginRecordInterruptionWithContext:
endRecordInterruption
beginPlaybackInterruption
endPlaybackInterruption
beginAudioSessionActivate:
endAudioSessionActivate:
sendRemoteConnectionMessage:
playbackRoute
lastRecordStartTime
voiceTriggerInfo
isBargeInDetectEnabled
setBargeInDetectEnabled:
isStopOnBargeInEnabled
setStopOnBargeInEnabled:
isSynchronousCallbackEnabled
setSynchronousCallbackEnabled:
pcmRecordBufferFormat
setDuckOthersOption:
duckOthersOption
numberOfChannels
defaultCenter
handleInterruption:
addObserver:selector:name:object:
handleRouteChange:
handleMediaServerDeath:
handleMediaServerReset:
removeObserver:name:object:
voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
unsignedLongValue
voiceControllerMediaServicesWereLost:
voiceControllerMediaServicesWereReset:
pointerValue
voiceControllerDidStartRecording:forStream:successfully:error:
initWithDomain:code:userInfo:
initWithComponentDescription:
initWithComponentDescription:withAVAUManagerImpl:
localeChanged
audioComponent
name
typeName
localizedTypeName
manufacturerName
versionString
iconURL
userTagNames
setUserTagNames:
allTagNames
componentURL
availableArchitectures
version
hasCustomView
passesAUVal
isSandboxSafe
hasMIDIInput
hasMIDIOutput
configurationDictionary
audioComponentDescription
supportsNumberInputChannels:outputChannels:
GetTypeName:
isComponentDescriptionMatch:
containsObject:
numberWithInteger:
dictionary
arrayWithArray:
URLWithString:
postNotificationName:object:
allObjects
isSubsetOfSet:
setWithArray:
substringFromIndex:
whitespaceCharacterSet
substringToIndex:
rangeOfString:
mStartWaitTime
mInterspeechWaitTime
mEndWaitTime
mEndpointMode
mFrameRate
mLastStatus
configureWithSampleRate:andFrameRate:
configureWithASBD:andFrameRate:
getStatus:
reset
endpointMode
setEndpointMode:
startWaitTime
setStartWaitTime:
interspeechWaitTime
setInterspeechWaitTime:
endWaitTime
setEndWaitTime:
getStatus:count:
initWithAudioComponentDescription:
bypass
setBypass:
isEqualToRoute:
inputs
outputs
initWithCategory:owningSession:
initWithRawDescription:owningSession:
boolValue
initWithObjects:
isEqualToArray:
siriRemoteInputIdentifier
siriInputSource
supportsDoAP
supportsSoftwareVolume
sharedAudioUnitComponentManager
privateAllocInitSingleton
allocWithZone:
copyWithZone:
localeChanged:
registrationsChanged:
tagNames
standardLocalizedTagNames
componentsMatchingPredicate:
componentsPassingTest:
componentsMatchingDescription:
filteredArrayUsingPredicate:
arrayWithObjects:count:
removeObjectsInArray:
unionSet:
removeObject:
setWetDryMix:
setDelayTime:
setFeedback:
setLowPassCutoff:
wetDryMix
delayTime
feedback
lowPassCutoff
mutableBytes
initWithObjects:forKeys:count:
voiceControllerAudioCallback:forStream:buffer:
voiceControllerLPCMRecordBufferAvailable:buffer:
voiceControllerRecordBufferAvailable:buffer:
initWithUnsignedInteger:
initWithDouble:
loadFactoryPreset:
setPitch:
setOverlap:
pitch
overlap
_delegate
_data
_url
_actualSettings
_format
_playRetain
_channelAssignments
_audioSession
_sessionListenerWasSet
_endInterruptionFlags
_localPlayer
_gcd
_currentDevice
initWithData:error:
initWithContentsOfURL:error:
initWithContentsOfURL:fileTypeHint:error:
initWithData:fileTypeHint:error:
prepareToPlay
play
playAtTime:
pause
stop
data
delegate
setDelegate:
settings
format
duration
setVolume:fadeDuration:
setEnableRate:
enableRate
currentTime
deviceCurrentTime
setCurrentTime:
setNumberOfLoops:
numberOfLoops
channelAssignments
setChannelAssignments:
audioSession
setAudioSession:
mixToUplink
setMixToUplink:
currentDevice
setCurrentDevice:
privRemoveSessionListener
initWithLength:
finishedPlaying:
initWithBool:
decodeError:
initWithUnsignedInt:
endInterruption
audioPlayerEndInterruption:
endInterruptionWithFlags:
audioPlayerEndInterruption:withOptions:
audioPlayerEndInterruption:withFlags:
performSelectorOnMainThread:withObject:waitUntilDone:
beginInterruption
audioPlayerBeginInterruption:
setObject:forKey:
UTF8String
initBase
audioPlayerDidFinishPlaying:successfully:
audioPlayerDecodeErrorDidOccur:error:
valueForKey:
finishedRecording
privCommonCleanup
privRemoveSessionPropertyListeners
baseInit
initWithURL:format:error:
initWithURL:settings:error:
prepareToRecord
record
recordAtTime:
recordForDuration:
recordAtTime:forDuration:
deleteRecording
endInterruptionWithFlags
setProcessToTap:
processToTap
instantaneousMetering
setInstantaneousMetering:
audioRecorderEndInterruption:
audioRecorderEndInterruption:withOptions:
audioRecorderEndInterruption:withFlags:
audioRecorderBeginInterruption:
removeItemAtPath:error:
path
bytes
pathExtension
audioRecorderDidFinishRecording:successfully:
stringWithUTF8String:
initWithReceiverBlock:
pullInputBlockFromReceiverBlock:
isEqualToChannel:
channelName
owningPortUID
channelNumber
channelLabel
privateCreate:portUID:channelNumber:
privateCreateArray:portUID:
_layoutTag
_layout
supportsSecureCoding
encodeWithCoder:
initWithCoder:
initWithLayoutTag:
initWithLayout:
channelCount
layoutTag
layout
layoutSize
decodeBytesWithReturnedLength:
encodeBytes:length:
layoutWithLayoutTag:
layoutWithLayout:
arrayWithObjects:
removeObserver:
addObserverForName:object:queue:usingBlock:
_connection
_serviceDelegateAsync
_serviceDelegateSync
startWithSequence:completion:
cancel
.cxx_destruct
connection
setConnection:
serviceDelegateAsync
setServiceDelegateAsync:
serviceDelegateSync
setServiceDelegateSync:
resume
setInvalidationHandler:
setInterruptionHandler:
localizedDescription
synchronousRemoteObjectProxyWithErrorHandler:
remoteObjectProxyWithErrorHandler:
setClasses:forSelector:argumentIndex:ofReply:
setWithObjects:
remoteObjectInterface
setRemoteObjectInterface:
interfaceWithProtocol:
initWithServiceName:
initFromFormat:toFormat:
inputFormat
outputFormat
dither
downmix
setDither:
setDownmix:
sampleRateConverterQuality
setSampleRateConverterQuality:
sampleRateConverterAlgorithm
setSampleRateConverterAlgorithm:
magicCookie
setMagicCookie:
channelMap
setChannelMap:
maximumOutputPacketSize
primeMethod
setPrimeMethod:
primeInfo
setPrimeInfo:
convertToBuffer:fromBuffer:error:
convertToBuffer:error:withInputFromBlock:
integerValue
initWithObjects:count:
initWithBytes:length:
numberWithDouble:
bitRate
setBitRate:
bitRateStrategy
setBitRateStrategy:
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
_voiceTriggerStartHostTime
_callToStartRecordHostTime
_publicMetrics
_avvcProfilingInfoDictionary
retrieveMetrics
getStringDate:
resetProfileMetrics
retrieveProfileMetrics
measureElapseTimeForMetric:block:
setAudioIssueDetectorFormat:numFrames:
audioIssueDetectorAnalyzeBuffer:numFrames:timeStamp:
resetAudioIssueDetector
logRecordAudioFormat:
logRecordRoute:andPlaybackRoute:
logProfileMetrics:
voiceTriggerStartHostTime
setVoiceTriggerStartHostTime:
callToStartRecordHostTime
setCallToStartRecordHostTime:
publicMetrics
setPublicMetrics:
avvcProfilingInfoDictionary
setAvvcProfilingInfoDictionary:
date
dictionaryWithObjects:forKeys:count:
enumerateKeysAndObjectsUsingBlock:
timeIntervalSinceDate:
objectForKeyedSubscript:
removeAllObjects
stringFromDate:
setDateFormat:
setTimeZone:
localTimeZone
numberWithInt:
getLock
createSharedManager
destroySharedManager
sharedManager
renderBlock
FillOutAUPreset:
setPreGain:
preGain
setOutputVolume:
outputVolume
setInputVolume:bus:
setInputPan:bus:
inputConnected:
nextAvailableInputBus
initWithNode:
currentAudioTimeStamp
currentIONumberFrames
awaitIOCycle:
initWithContentsOfURL:soundBankURL:error:
initWithData:soundBankURL:error:
hostTimeForBeats:
beatsForHostTime:
play:
currentPosition
setCurrentPosition:
destroyBase
startNote:withVelocity:onChannel:
stopNote:onChannel:
sendController:withValue:onChannel:
sendPitchBend:onChannel:
sendPressure:onChannel:
sendPressureForKey:withValue:onChannel:
sendProgramChange:onChannel:
sendProgramChange:bankMSB:bankLSB:onChannel:
sendMIDIEvent:data1:data2:
sendMIDIEvent:data1:
sendMIDISysExEvent:
mutableCopyWithZone:
initWithFormat:byteCapacity:
byteCapacity
byteLength
setByteLength:
audioBufferList
mutableAudioBufferList
initWithPCMFormat:frameCapacity:
frameCapacity
frameLength
setFrameLength:
stride
_initChannelPtrs
floatChannelData
int32ChannelData
int16ChannelData
appendDataFromBuffer:
appendDataFromBuffer:channel:
splitIntoSingleChannelBuffers
averagePowerPerChannel
peakPowerPerChannel
calculatePower:
calculatePower:forFloatData:stride:frameLength:
numberWithFloat:
initWithFormat:packetCapacity:maximumPacketSize:
initWithFormat:packetCapacity:
packetCapacity
packetCount
maximumPacketSize
packetDescriptions
setPacketCount:
initWithImpl:
setFilterType:
filterType
setFrequency:
frequency
setBandwidth:
bandwidth
setGain:
gain
initWithNumberOfBands:
bands
globalGain
setGlobalGain:
_asbd
_commonFormat
initWithStreamDescription:
initWithStreamDescription:channelLayout:
initStandardFormatWithSampleRate:channels:
initStandardFormatWithSampleRate:channelLayout:
initWithCommonFormat:sampleRate:channels:interleaved:
initWithCommonFormat:sampleRate:interleaved:channelLayout:
initWithSettings:
initWithCMAudioFormatDescription:
formatDescription
streamDescription
channelLayout
isStandard
commonFormat
sampleRate
isInterleaved
decodeObjectOfClass:forKey:
decodeIntegerForKey:
decodeDoubleForKey:
encodeObject:forKey:
encodeInteger:forKey:
encodeDouble:forKey:
settingsFromASBD:channelLayout:
formatWithInvalidSampleRateAndChannelCount
dataWithBytes:length:
setValue:forKey:
numberWithUnsignedInteger:
_inputID
_outputID
_sampleRate
_correlationValue
initWithData:inputID:outputID:sampleRate:correlationValue:
inputID
setInputID:
outputID
setOutputID:
setSampleRate:
correlationValue
setCorrelationValue:
_calculateCrossCorrelationPeak
_volume
_stimulusURL
_inputProcessingChain
_outputProcessingChain
_outputMode
stimulusURL
setStimulusURL:
inputProcessingChain
setInputProcessingChain:
outputProcessingChain
setOutputProcessingChain:
outputMode
setOutputMode:
calculateCrossCorrelationPeak
setCalculateCrossCorrelationPeak:
decodeBoolForKey:
_graphURL
_processingStripURL
graphURL
setGraphURL:
processingStripURL
setProcessingStripURL:
decodeFloatForKey:
encodeBool:forKey:
encodeFloat:forKey:
initWithRenderBlock:
initWithFormat:renderBlock:
pullInputBlockFromRenderBlock:
_audioFileSettings
audioFileSettings
setGender:
setQuality:
setName:
setIdentifier:
setLanguage:
gender
quality
identifier
language
initialize
speechVoices
currentLanguageCode
voiceWithLanguage:
voiceWithIdentifier:
loadAndReturnError:
isLoaded
bundleWithPath:
stringByAppendingString:
_voice
_rate
_pitchMultiplier
_speechString
_attributedSpeechString
_preUtteranceDelay
_postUtteranceDelay
initWithString:
initWithAttributedString:
setPitchMultiplier:
voice
setVoice:
speechString
setSpeechString:
attributedSpeechString
setAttributedSpeechString:
pitchMultiplier
preUtteranceDelay
setPreUtteranceDelay:
postUtteranceDelay
setPostUtteranceDelay:
floatValue
speechUtteranceWithString:
speechUtteranceWithAttributedString:
_speaking
_paused
_usesApplicationAudioSession
_mixToTelephonyUplink
_outputChannels
speakUtterance:
writeUtterance:toBufferCallback:
stopSpeakingAtBoundary:
pauseSpeakingAtBoundary:
continueSpeaking
isSpeaking
isPaused
outputChannels
setOutputChannels:
usesApplicationAudioSession
setUsesApplicationAudioSession:
mixToTelephonyUplink
setMixToTelephonyUplink:
isPrimary
channels
bytesCapacity
bytesDataSize
setBytesDataSize:
packetDescriptionCapacity
packetDescriptionCount
setPacketDescriptions:count:
timeStamp
remoteVoiceActivityRMS
remoteVoiceActivityVAD
remoteVoiceActivityAvailable
initWithAudioQueueBuffer:channels:timeStamp:
initWithEnvironment:
setDistanceAttenuationModel:
distanceAttenuationModel
setMaximumDistance:
maximumDistance
setReferenceDistance:
referenceDistance
setRolloffFactor:
rolloffFactor
setEnable:
enable
setLevel:
level
filterParameters
loadFactoryReverbPreset:
setOutputType:
outputType
applicableRenderingAlgorithms
setListenerPosition:
listenerPosition
setListenerVectorOrientation:
listenerVectorOrientation
setListenerAngularOrientation:
listenerAngularOrientation
distanceAttenuationParameters
reverbParameters
voiceControllerStreamInvalidated:forStream:
boolForKey:
initWithSuiteName:
attributeForKey:
sharedAVSystemController
valueWithPointer:
voiceControllerEndInterruption:
initWithObjectsAndKeys:
fileURLWithPath:
initWithSessionType:
initAuxiliarySession
category
categoryOptions
routeSharingPolicy
availableCategories
setCategory:error:
privateSetOptions:forCategory:error:
setCategory:withOptions:error:
setCategory:mode:options:error:
setCategory:mode:routeSharingPolicy:options:error:
setActive:error:
setActive:withOptions:error:
activateWithOptions:completionHandler:
deactivateAndSetInterruptionPriority:error:
setActive:withFlags:error:
recordPermission
requestRecordPermission:
setPreferredSampleRate:error:
setPreferredIOBufferDuration:error:
setPreferredIOBufferFrameSize:error:
setInterruptionPriority:error:
setPreferredInputNumberOfChannels:error:
setPreferredOutputNumberOfChannels:error:
setInputGain:error:
setInputDataSource:error:
setOutputDataSource:error:
promptStyle
setAllowHapticsAndSystemSoundsDuringRecording:error:
allowHapticsAndSystemSoundsDuringRecording
audioFormats
audioFormat
isDolbyDigitalEncoderAvailable
isEarpieceActiveNoiseCancelationEnabled
isPiPAvailable
forceSoundCheck
setForceSoundCheck:error:
lastActivationStoppedNowPlayingApp
requiresNoAudioResources
setRequiresNoAudioResources:error:
allowMixableAudioWhileRecording
setAllowMixableAudioWhileRecording:error:
recordingFromRemoteInput
setRecordingFromRemoteInput:error:
allowAllBuiltInDataSources
setAllowAllBuiltInDataSources:
setBypassRingerSwitchPolicy:error:
setAudioHardwareControlFlags:error:
setInterruptionFadeDuration:error:
isHardwareFormatFixedToMultiChannel
fixHardwareFormatToMultiChannel:error:
inputGain
privateGetDataSources:
privateGetSelectedDataSource:
inputDataSources
inputDataSource
outputDataSources
outputDataSource
isInputGainSettable
isInputAvailable
isOtherAudioPlaying
secondaryAudioShouldBeSilencedHint
inputLatency
outputLatency
inputSafetyOffset
outputSafetyOffset
activeSessionDisplayIDs
IOBufferDuration
IOBufferFrameSize
interruptionPriority
preferredSampleRate
preferredIOBufferDuration
preferredIOBufferFrameSize
preferredInputNumberOfChannels
preferredOutputNumberOfChannels
inputNumberOfChannels
outputNumberOfChannels
maximumInputNumberOfChannels
maximumOutputNumberOfChannels
availableModes
setMode:error:
privateSetRouteSharingPolicy:error:
privateNeedsTranslationForNoSpeakerCategory:
routingContextUID
selectIndependentRoutingContext:
overrideOutputAudioPort:error:
setPreferredInput:error:
preferredInput
currentRoute
pickedRoute
setAudioClockDevice:error:
audioClockDevice
opaqueSessionID
sessionType
speechDetectionDeviceSampleRate
availableInputs
privateRefreshAvailableInputs
setPreferredHardwareSampleRate:error:
setActivationContext:error:
setDisallowedPorts:error:
silenceOutput:error:
setDefaultChatMode:error:
setIAmTheAssistant:error:
clearInputPreferences:
inputIsAvailable
currentHardwareSampleRate
currentHardwareInputNumberOfChannels
currentHardwareOutputNumberOfChannels
preferredHardwareSampleRate
preferDecoupledIO:error:
setAggregatedIOPreference:error:
decoupledIO
setPreferredInputSampleRate:error:
preferredInputSampleRate
setPreferredOutputSampleRate:error:
preferredOutputSampleRate
inputSampleRate
outputSampleRate
setSpeakerThermalGain:error:
setHapticThermalGain:error:
speakerThermalGain
hapticThermalGain
privateInputIsAvailableChanged:
privateInterruptionWithInfo:
privateMarkKVOPropertiesDirty:
privateHandleServerDied
privateHandlePickableRoutesChange
privateHandleSecondaryAudioHintChange:
privateHandleOtherPrimaryAudioPlayStateChange
privateUpdatePiPAvailabilityChange:
privateHandleRoutingContextChange
privateHandleServerConnectionCompletion:
enableNotifications:error:
privateSetPropertyValue:withBool:error:
privateUpdateOutputVolume:
privateUpdatePromptStyle:
privateUpdateInputGain:
privateUpdateDataSources:forInput:
privateUpdateAudioFormats:
privateUpdateAudioFormat:
privateUpdateInputChannelCount:
privateUpdateOutputChannelCount:
isDolbyAtmosAvailable
didChangeValueForKey:
willChangeValueForKey:
firstObject
postNotificationName:object:userInfo:
initWithFloat:
inputIsAvailableChanged:
exceptionWithName:reason:userInfo:
sharedInstance
retrieveSessionWithID:
primarySession
auxiliarySession
mShouldDuckOthers
mIsMiniDuckingEnabled
mShouldEnableMiniDucking
mShouldDisableMiniDucking
mSessionNeedsVolumeControl
mSessionNeedsRoutingControl
mSessionOutputIsWirelessSplitter
mIsOtherAudioPlaying
mRouteHasDoAPSupport
mOutputSupportsSWVolume
mDeviceIsIOSAccessory
mDeviceIsOlderWatch
mSessionActivationOptions
mPreviousActivationMode
setupOneTimeSessionSettings
setSessionActivationContext:
shouldEnableMiniDucking:
isMiniDuckingEnabled
getHypotheticalRouteAndUpdateStates
setSessionCategoryModeOptionsForActivationMode:
setSessionAudioHWControlFlagsForActivationMode:
setSessionSampleRateForActivationMode:
setSessionBufferSizeForRecordingEngine:
changeDuckOthersOption:
isSessionOutputInWirelessSplitterMode
getSessionActivationOptions
setSessionActivationOptions:
isAirplayOneOfTheOutputRoutes:
supportsBluetoothSharing
outputDevices
supportsMultipleBluetoothOutputDevices
sharedSystemAudioContext
initForReading:error:
initForReading:commonFormat:interleaved:error:
initForReadingFromExtAudioFile:error:
initForReadingFromExtAudioFile:commonFormat:interleaved:error:
initForWriting:settings:error:
initForWriting:settings:commonFormat:interleaved:error:
initSecondaryReader:format:error:
readIntoBuffer:error:
writeFromBuffer:error:
readIntoBuffer:frameCount:error:
fileFormat
processingFormat
length
framePosition
setFramePosition:
initWithSession:
isEqualToPort:compareStrict:
portType
portName
dataSources
hasHardwareVoiceCallProcessing
isLiveListenSupported
isHeadphones
endpointType
selectedDataSource
preferredDataSource
setPreferredDataSource:error:
privateGetID
initWithRawPortDescription:owningSession:
configureChannelsAndDataSources:
initWithPortType:owningSession:
privateCreateArray:owningSession:
resetImpl:
outputFormatForBus:
setOutputFormat:forBus:
inputFormatForBus:
setInputFormat:forBus:
nameForInputBus:
nameForOutputBus:
clock
lastRenderTime
latency
outputPresentationLatency
engine
numberOfInputs
numberOfOutputs
setNumberOfInputs:
setNumberOfOutputs:
installTapOnBus:bufferSize:format:block:
removeTapOnBus:
AUAudioUnit
implementation
connectionPoint
parameterTree
loadInstrumentAtURL:error:
loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:
loadAudioFilesAtURLs:error:
stereoPan
masterGain
globalTuning
setStereoPan:
setMasterGain:
setGlobalTuning:
caseInsensitiveCompare:
mutableCopy
initWithAudioEngine:
numberOfTracks
cleanTracks
setupTrackArray
setupTracks
userInfo
loadFromURL:options:error:
loadFromData:options:error:
writeToURL:SMPTEResolution:replaceExisting:error:
dataWithSMPTEResolution:error:
tracks
getTempoTrack
secondsForBeats:
beatsForSeconds:
setTrackArray:
trackArray
setTempoTrack:
tempoTrack
index
track
setDestinationAudioUnit:
destinationAudioUnit
setDestinationMIDIEndpoint:
destinationMIDIEndpoint
loopRange
setLoopRange:
isLoopingEnabled
setLoopingEnabled:
offsetTime
setOffsetTime:
isMuted
setMuted:
isSoloed
setSoloed:
usesAutomatedParameters
setUsesAutomatedParameters:
lengthInBeats
setLengthInBeats:
lengthInSeconds
setLengthInSeconds:
timeResolution
currentPositionInSeconds
hostTimeForBeats:error:
beatsForHostTime:error:
startAndReturnError:
setCurrentPositionInSeconds:
currentPositionInBeats
setCurrentPositionInBeats:
_ats
initWithHostTime:
initWithSampleTime:atRate:
initWithHostTime:sampleTime:atRate:
isHostTimeValid
isSampleTimeValid
hostTime
sampleTime
extrapolateTimeFromAnchor:
initWithAudioTimeStamp:sampleRate:
audioTimeStamp
secondsForHostTime:
timeWithAudioTimeStamp:sampleRate:
timeWithHostTime:
timeWithSampleTime:atRate:
timeWithHostTime:sampleTime:atRate:
hostTimeForSeconds:
loadAudioDSPManager
loadDSPGraphAtURL:error:
loadAudioUnitProcessingStripAtURL:error:
dspGraphURL
auProcessingStripURL
dictionaryWithContentsOfURL:error:
relativePath
callLegacyCompletionHandlerForType:legacyHandler:
scheduleBuffer:completionHandler:
scheduleBuffer:completionCallbackType:completionHandler:
scheduleBuffer:atTime:options:completionHandler:
scheduleBuffer:atTime:options:completionCallbackType:completionHandler:
scheduleFile:atTime:completionHandler:
scheduleFile:atTime:completionCallbackType:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:
prepareWithFrameCount:
nodeTimeForPlayerTime:
playerTimeForNodeTime:
anyObject
initWithKeyOptions:valueOptions:capacity:
_voiceTriggerBlock
_speakerStateChangedBlock
_speakerMuteStateChangedBlock
_serverCrashedBlock
_serverResetBlock
callServerResetBlock
voiceTriggerServerConnection
voiceTriggerPastDataFramesAvailableCompletion:
voiceTriggerPastDataFramesAvailable
enableVoiceTriggerListening:
enableVoiceTriggerListening:completionBlock:
setListeningProperty:completionBlock:
enableSpeakerStateListening:completionBlock:
enableSpeakerStateListening:
speakerStateActiveCompletionBlock:
speakerStateActive
speakerStateMutedCompletionBlock:
speakerStateMuted
hasBargeInSupportCompletionBlock:
hasBargeInSupport
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:
updateVoiceTriggerConfiguration:completionBlock:
listeningEnabledCompletionBlock:
voiceTriggerNotification:
speakerStateChangedNotification:
speakerMuteStateChangedNotification:
voiceTriggerBlock
setVoiceTriggerBlock:
speakerStateChangedBlock
setSpeakerStateChangedBlock:
speakerMuteStateChangedBlock
setSpeakerMuteStateChangedBlock:
serverCrashedBlock
setServerCrashedBlock:
serverResetBlock
setServerResetBlock:
isAPIAvailable
loadAudioUnitPresetAtURL:error:
setValue:forParam:
valueForParam:
componentsSeparatedByString:
dictionaryWithContentsOfURL:
instantiateWithComponentDescription:options:completionHandler:
attachNode:
detachNode:
outputNode
inputNode
mainMixerNode
connect:to:fromBus:toBus:format:
connect:to:format:
connect:toConnectionPoints:fromBus:format:
disconnectNodeInput:bus:
disconnectNodeOutput:bus:
disconnectNodeInput:
disconnectNodeOutput:
prepare
inputConnectionPointForNode:inputBus:
outputConnectionPointsForNode:outputBus:
setMusicSequence:
musicSequence
isRunning
isAutoShutdownEnabled
setAutoShutdownEnabled:
manualRenderingSampleTime
enableManualRenderingMode:format:maximumFrameCount:error:
disableManualRenderingMode
manualRenderingBlock
renderOffline:toBuffer:error:
connectMIDI:to:format:block:
connectMIDI:toNodes:format:block:
disconnectMIDI:from:
disconnectMIDI:fromNodes:
disconnectMIDIInput:
disconnectMIDIOutput:
attachedNodes
removeRenderObserver:
tokenByAddingRenderObserver:
setRenderingOffline:
isRenderingOffline
setMaximumFramesToRender:
maximumFramesToRender
value
parameterWithAddress:
parameterWithID:scope:element:
setValue:
setBusCount:error:
outputBusses
inputBusses
isEnabled
setEnabled:
setFormat:error:
deallocateRenderResources
allocateRenderResourcesAndReturnError:
setInputHandler:
setOutputProvider:
stopHardware
startHardwareAndReturnError:
setOutputEnabled:
setInputEnabled:
canPerformOutput
canPerformInput
invalidateAudioUnit
auAudioUnitForAudioUnit:
scheduleMIDIEventBlock
setMIDIOutputEventBlock:
isMusicDeviceOrEffect
@28@0:8^{AVAudioIOUnit=^^?@^{AVAudioEngineImpl}{unique_ptr<AUInterfaceIOV3, std::__1::default_delete<AUInterfaceIOV3> >={__compressed_pair<AUInterfaceIOV3 *, std::__1::default_delete<AUInterfaceIOV3> >=^{AUInterfaceIOV3}}}@@{AudioComponentDescription=IIIII}}16B24
d16@0:8
^{OpaqueAudioComponentInstance=}16@0:8
v24@0:8@16
v32@0:8@16^@24
B16@0:8
q16@0:8
B28@0:8B16^@20
B28@0:8q16B24
B32@0:8^{AVAudioIOUnit=^^?@^{AVAudioEngineImpl}{unique_ptr<AUInterfaceIOV3, std::__1::default_delete<AUInterfaceIOV3> >={__compressed_pair<AUInterfaceIOV3 *, std::__1::default_delete<AUInterfaceIOV3> >=^{AUInterfaceIOV3}}}@@{AudioComponentDescription=IIIII}}16B24B28
B28@0:8@16I24
@16@0:8
I16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8@"Protocol"16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
@"NSString"16@0:8
f16@0:8
v20@0:8f16
v24@0:8q16
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@"AVAudioMixingDestination"32@0:8@"AVAudioNode"16Q24
@32@0:8@16Q24
B32@0:8@16@?24
v20@0:8B16
@"AVAudioNode"
v16@0:8
@20@0:8I16
B32@0:8@16^@24
^{DataSourceDescriptionImpl=I@@@@@@@@}16@0:8
@36@0:8@16@24I32
@"NSMutableArray<AVAudioRemoteInputPlugin>"
@"AVVoiceController"
v32@0:8@"<AVAudioRemoteInputPlugin>"16@"<AVAudioRemoteInputDevice>"24
v32@0:8@16@24
@24@0:8^@16
@24@0:8@16
@24@0:8@"<AVAudioRemoteInputPluginDelegate>"16
@"NSArray"16@0:8
@"NSString"
@"NSUUID"
@24@0:8^{AVVCRecordingEngine=^^?{CAStreamBasicDescription=dIIIIIIII}@@?@?@?^{ControllerImpl}^{OpaqueAudioFileID}iqi@I@QBBIdQqB^{AudioQueueLevelMeterState}@}16
@36@0:8i16q20Q28
i16@0:8
v20@0:8i16
v24@0:8Q16
@32@0:8@16^@24
B28@0:8@16i24
B20@0:8i16
i32@0:8Q16@24
B24@0:8^@16
B32@0:8Q16^@24
B24@0:8d16
v24@0:8d16
f24@0:8Q16
Q32@0:8@16^@24
v32@0:8@16@?24
v48@0:8@16@?24@?32@?40
v32@0:8Q16@?24
q24@0:8Q16
@24@0:8Q16
B36@0:8Q16B24^@28
B40@0:8@16Q24^@32
v36@0:8i16q20@?28
B28@0:8i16q20
d24@0:8Q16
B24@0:8Q16
f32@0:8Q16Q24
v24@0:8@?16
@32@0:8q16@24
@"NSDictionary"
@40@0:8Q16@24d32
@32@0:8Q16Q24
^{ControllerImpl=^^?@@^{GenericRunLoopThread}Bf@^{__CFDictionary}I@@{CAStreamBasicDescription=dIIIIIIII}d^{OpaqueAudioQueue}i@I^^{AudioQueueBuffer}iBBBBBBfIq{CAStreamBasicDescription=dIIIIIIII}q^{OpaqueAudioQueue}{map<AVVoiceAlertType, NSURL *, std::__1::less<AVVoiceAlertType>, std::__1::allocator<std::__1::pair<const AVVoiceAlertType, NSURL *> > >={__tree<std::__1::__value_type<AVVoiceAlertType, NSURL *>, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, NSURL *>, std::__1::less<AVVoiceAlertType>, true>, std::__1::allocator<std::__1::__value_type<AVVoiceAlertType, NSURL *> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<AVVoiceAlertType, NSURL *>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, NSURL *>, std::__1::less<AVVoiceAlertType>, true> >=Q}}}{map<AVVoiceAlertType, AudioQueueBuffer *, std::__1::less<AVVoiceAlertType>, std::__1::allocator<std::__1::pair<const AVVoiceAlertType, AudioQueueBuffer *> > >={__tree<std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, std::__1::less<AVVoiceAlertType>, true>, std::__1::allocator<std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<AVVoiceAlertType, std::__1::__value_type<AVVoiceAlertType, AudioQueueBuffer *>, std::__1::less<AVVoiceAlertType>, true> >=Q}}}iiiqqqiifdBQQffBB@^{OpaqueAudioFileID}I^{AudioFormatListItem}IQ*{AudioFilePacketTableInfo=qii}qqBii@BBBBidddBBB@CiBBBIB@@QQBBiBq@[5^{MyMutex}]iiBQQQ@@{map<unsigned long, AVVCRecordingEngine *, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, AVVCRecordingEngine *> > >={__tree<std::__1::__value_type<unsigned long, AVVCRecordingEngine *>, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, AVVCRecordingEngine *>, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, AVVCRecordingEngine *> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, AVVCRecordingEngine *>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, AVVCRecordingEngine *>, std::__1::less<unsigned long>, true> >=Q}}}B@?@?q@}16@0:8
v24@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCC}16
@36@0:8{AudioComponentDescription=IIIII}16
@44@0:8{AudioComponentDescription=IIIII}16^{AVAudioUnitComponentManagerImpl=^^?^{__CFArray}^{__CFArray}^{__CFArray}}36
^{OpaqueAudioComponent=}16@0:8
{AudioComponentDescription=IIIII}16@0:8
B32@0:8q16q24
B36@0:8{AudioComponentDescription=IIIII}16
i24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
B28@0:8d16I24
B28@0:8^{AudioStreamBasicDescription=dIIIIIIII}16I24
i28@0:8^f16I24
^{RouteDescriptionImpl=@@@QBB}16@0:8
@32@0:8@16@24
@24@0:8^{_NSZone=}16
@24@0:8@?16
@"<AVAudioPlayerDelegate>"
@"NSData"
@"NSURL"
@"AVAudioFormat"
@"NSArray"
@"AVAudioSession"
^{AVAudioPlayerCpp=^{__CFData}^{__CFURL}^{__CFDictionary}I{AudioStreamBasicDescription=dIIIIIIII}{AudioStreamBasicDescription=dIIIIIIII}IQ*I^{AudioFormatListItem}I^{OpaqueAudioFileID}I^{OpaqueAudioQueue}qqqddddIdi{AudioFilePacketTableInfo=qii}qqiiBBBBIBBBBdddddd^{__CFString}I^{AudioQueueLevelMeterState}[3^{AudioQueueBuffer}]^{AudioQueueBuffer}i[3I]BBBBB^{AudioQueueBuffer}IBBBBqiII^v^?I@I^{AudioQueueChannelAssignment}}
@"NSObject<OS_dispatch_queue>"
@40@0:8@16@24^@32
v28@0:8f16d20
@"AVAudioSession"16@0:8
v24@0:8@"AVAudioSession"16
^{AudioRecorderImpl=@@@@@@I{AudioStreamBasicDescription=dIIIIIIII}^{OpaqueAudioFileID}^{OpaqueAudioQueue}qqqdddQ*BBBBBBBB^{AudioQueueLevelMeterState}[4^{AudioQueueBuffer}]^{AudioQueueBuffer}BQBi@}16@0:8
B32@0:8d16d24
@?24@0:8@?16
^{ChannelDescriptionImpl=@@II}16@0:8
^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@24@0:8r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16
r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16@0:8
@"NSXPCConnection"
@"<AVAudioDeviceTestServiceProtocol>"
v32@0:8@"AVAudioDeviceTestSequence"16@?<v@?@"NSArray"@"NSError">24
{AVAudioConverterPrimeInfo=II}16@0:8
v24@0:8{AVAudioConverterPrimeInfo=II}16
B40@0:8@16@24^@32
q40@0:8@16^@24@?32
@"NSMutableDictionary"
i60@0:8{CAStreamBasicDescription=dIIIIIIII}16I56
i52@0:8{AudioBufferList=I[1{AudioBuffer=II^v}]}16I40r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}44
v56@0:8{CAStreamBasicDescription=dIIIIIIII}16
^{CAMutex=^^?*^{_opaque_pthread_t}{_opaque_pthread_mutex_t=q[56c]}}16@0:8
{AUPreset=i^{__CFString}}24@0:8q16
v28@0:8f16Q20
@24@0:8^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}BB^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}}16
{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16@0:8
@24@0:8^I16
Q24@0:8d16
^{MIDIPlayerImpl=^{OpaqueAUGraph}^{OpaqueMusicPlayer}^{OpaqueMusicSequence}d@?@}16@0:8
v28@0:8C16C20C24
v24@0:8C16C20
v24@0:8S16C20
v32@0:8C16C20C24C28
@28@0:8@16I24
v20@0:8I16
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^^f16@0:8
^^i16@0:8
^^s16@0:8
B32@0:8@16q24
f44@0:8Q16^f24q32I40
@36@0:8@16I24q28
^{AudioStreamPacketDescription=qII}16@0:8
^v16@0:8
@24@0:8^{AVAudioUnitEQFilterParametersImpl=^^?}16
{AudioStreamBasicDescription="mSampleRate"d"mFormatID"I"mFormatFlags"I"mBytesPerPacket"I"mFramesPerPacket"I"mBytesPerFrame"I"mChannelsPerFrame"I"mBitsPerChannel"I"mReserved"I}
@"AVAudioChannelLayout"
@24@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16
@32@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16@24
@28@0:8d16I24
@32@0:8d16@24
@40@0:8Q16d24I32B36
@44@0:8Q16d24B32@36
@24@0:8^{opaqueCMFormatDescription=}16
r^{opaqueCMFormatDescription=}16@0:8
r^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
@56@0:8@16q24q32d40d48
@"AVAudioDeviceTestProcessingChain"
@32@0:8@16@?24
@"AVSpeechSynthesisVoice"
@"NSAttributedString"
@"<AVSpeechSynthesizerDelegate>"
B24@0:8q16
v28@0:8r^{AudioStreamPacketDescription=qII}16i24
^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
C16@0:8
@36@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCC}16i24Q28
@24@0:8^{AVAudioEnvironmentNodeImpl=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}BB^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}i{unique_ptr<AUInterfaceBaseV3, std::__1::default_delete<AUInterfaceBaseV3> >={__compressed_pair<AUInterfaceBaseV3 *, std::__1::default_delete<AUInterfaceBaseV3> >=^{AUInterfaceBaseV3}}}fqI@{AVAudio3DPoint=fff}{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}{AVAudio3DAngularOrientation=fff}{map<AVAudio3DMixingImpl *, unsigned int, std::__1::less<AVAudio3DMixingImpl *>, std::__1::allocator<std::__1::pair<AVAudio3DMixingImpl *const, unsigned int> > >={__tree<std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, std::__1::__map_value_compare<AVAudio3DMixingImpl *, std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, std::__1::less<AVAudio3DMixingImpl *>, true>, std::__1::allocator<std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<AVAudio3DMixingImpl *, std::__1::__value_type<AVAudio3DMixingImpl *, unsigned int>, std::__1::less<AVAudio3DMixingImpl *>, true> >=Q}}}@Ifff@@Bffff}16
v40@0:8{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16
{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16@0:8
v28@0:8{AVAudio3DAngularOrientation=fff}16
{AVAudio3DAngularOrientation=fff}16@0:8
B40@0:8Q16@24^@32
B48@0:8@16@24Q32^@40
B56@0:8@16@24Q32Q40^@48
B36@0:8B16Q20^@28
B32@0:8q16^@24
B36@0:8B16q20^@28
B32@0:8d16^@24
B28@0:8f16^@20
^{AVAudioSessionImpl=@^{GenericRunLoopThread}{KVOProperty<float>=^^?f@@B}{KVOProperty<float>=^^?f@@B}{KVONSArrayProperty=^^?@@@B}{KVONSArrayProperty=^^?@@@B}{KVOProperty<unsigned int>=^^?I@@B}{KVOProperty<unsigned int>=^^?I@@B}{KVONSObjectProperty<NSArray *>=^^?@@@B}{KVOProperty<unsigned int>=^^?I@@B}@B{KVOProperty<unsigned int>=^^?I@@B}{KVOProperty<unsigned int>=^^?I@@B}IIIB{SessionConnector={shared_ptr<std::__1::function<void (avfaudio::SessionConnector::ConnectionResult)> >=^{function<void (avfaudio::SessionConnector::ConnectionResult)>}^{__shared_weak_count}}}BB}16@0:8
@20@0:8B16
v24@0:8{ConnectionResult=iI}16
B32@0:8I16B20^@24
v28@0:8@16B24
i24@0:8@16
i24@0:8q16
i24@0:8^{AVVCRecordingEngine=^^?{CAStreamBasicDescription=dIIIIIIII}@@?@?@?^{ControllerImpl}^{OpaqueAudioFileID}iqi@I@QBBIdQqB^{AudioQueueLevelMeterState}@}16
@44@0:8@16Q24B32^@36
@32@0:8^{OpaqueExtAudioFile=}16^@24
@44@0:8^{OpaqueExtAudioFile=}16Q24B32^@36
@52@0:8@16@24Q32B40^@44
B36@0:8@16I24^@28
B28@0:8@16B24
^{PortDescriptionImpl=@@@@@BBBQ@@@@}16@0:8
B24@0:8^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}BB^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}}16
B32@0:8@16Q24
v44@0:8Q16I24@28@?36
^{AVAudioNodeImplBase=^^?^{AVAudioEngineImpl}@{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}BB^{AVAudioMixingImpl}^{map<std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *, std::__1::less<std::__1::pair<AVAudioNode *, unsigned int> >, std::__1::allocator<std::__1::pair<const std::__1::pair<AVAudioNode *, unsigned int>, AVAudioMixingDestination *> > >}Bqd{atomic<double>=Ad}}16@0:8
@24@0:8^{AVAudioMixingImpl=^^?ffIIIff{AVAudio3DPoint=fff}ff}16
^{AVAudioMixingImpl=^^?ffIIIff{AVAudio3DPoint=fff}ff}16@0:8
B44@0:8@16C24C28C32^@36
@24@0:8^{AVAudioSequencerImpl=^{OpaqueMusicPlayer}^{OpaqueMusicSequence}@@@@}16
B44@0:8@16q24B32^@36
@32@0:8q16^@24
d24@0:8d16
@24@0:8^{MusicTrackImpl=^{OpaqueMusicTrack}@BI}16
^{OpaqueMusicTrack=}16@0:8
{_AVBeatRange=dd}16@0:8
v32@0:8{_AVBeatRange=dd}16
Q32@0:8d16^@24
d32@0:8Q16^@24
{AudioTimeStamp="mSampleTime"d"mHostTime"Q"mRateScalar"d"mWordClockTime"Q"mSMPTETime"{SMPTETime="mSubframes"s"mSubframeDivisor"s"mCounter"I"mType"I"mFlags"I"mHours"s"mMinutes"s"mSeconds"s"mFrames"s}"mFlags"I"mReserved"I}
@32@0:8q16d24
@40@0:8Q16q24d32
@32@0:8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16d24
v32@0:8q16@?24
v40@0:8@16q24@?32
v48@0:8@16@24Q32@?40
v56@0:8@16@24Q32q40@?48
v40@0:8@16@24@?32
v48@0:8@16@24q32@?40
v52@0:8@16q24I32@36@?44
v60@0:8@16q24I32@36q44@?52
v28@0:8B16@?20
@?16@0:8
B24@0:8f16I20
f20@0:8I16
v48@0:8{AudioComponentDescription=IIIII}16I36@?40
v56@0:8@16@24Q32Q40@48
v40@0:8@16@24@32
v48@0:8@16@24Q32@40
v32@0:8@16Q24
v24@0:8^{OpaqueMusicSequence=}16
^{OpaqueMusicSequence=}16@0:8
^{AVAudioEngineImpl=@{unique_ptr<AVAudioEngineGraph, std::__1::default_delete<AVAudioEngineGraph> >={__compressed_pair<AVAudioEngineGraph *, std::__1::default_delete<AVAudioEngineGraph> >=^{AVAudioEngineGraph}}}@@@@{unique_ptr<AVAudioIOUnit, std::__1::default_delete<AVAudioIOUnit> >={__compressed_pair<AVAudioIOUnit *, std::__1::default_delete<AVAudioIOUnit> >=^{AVAudioIOUnit}}}B@i@?B{unique_ptr<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)>, std::__1::default_delete<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)> > >={__compressed_pair<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)> *, std::__1::default_delete<AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)> > >=^{AVAEBlock<AVAudioEngineManualRenderingStatus (^)(unsigned int, AudioBufferList *, int *)>}}}}16@0:8
B44@0:8q16@24I32^@36
q36@0:8I16@20^@28
v48@0:8@16@24@32@?40
nwku
npdh
lchv
rkps
_ytt
