Unsupported entity mapping type
entityMapping
mappingType
%s(%d): CoreData: Ubiquity:  Migrating %lu transaction log files for '%@' at '%@'
-[PFUbiquityTransactionLogMigrator migrateTransactionLogsForStoreName:andLocalPeerID:atUbiquityRootLocation:error:]
%s(%d): CoreData: Ubiquity:  Destination log file already exits in final location, skipping: %@
-[PFUbiquityTransactionLogMigrator migrateTransactionLogFromLocation:toLocation:error:]
%s(%d): CoreData: Ubiquity:  Destination log file already exits in staging location, skipping: %@
%s(%d): CoreData: Ubiquity:  Migrating src transaction log %@ to %@
%s(%d): CoreData: Ubiquity:  Destination log written succesfully
%s(%d): CoreData: Ubiquity:  Failed to move transaction log to permanent location: %@
%s(%d): CoreData: Ubiquity:  Destination log write failed with error %@
v32@?0@8@16^B24
throttleLogs
TB,R,V_throttleLogs
transactionLog
T@"PFUbiquityTransactionLog",&,N,V_transactionLog
sourceStoreSaveSnapshot
T@"PFUbiquityStoreSaveSnapshot",&,N,V_sourceStoreSaveSnapshot
destinationStoreSaveSnapshot
T@"PFUbiquityStoreSaveSnapshot",&,N,V_destinationStoreSaveSnapshot
 containerIdentifier:%@
 initializeSchema:%@
 ckAssetThresholdBytes:%@
 operationMemoryThresholdBytes:%@
 useEncryptedStorage:%@
 automaticallyDownloadFileBackedFutures:%@
 automaticallyScheduleImportAndExportOperations:%@
 skipCloudKitSetup:%@
 preserveLegacyRecordMetadataBehavior:%@
 useDaemon:%@
 apsConnectionMachServiceName:%@
 containerProvider:%@
 scheduler:%@
 notificationListener:%@
 containerOptions:%@
scheduler
T@"CKScheduler",&,N,V_scheduler
notificationListener
T@"CKNotificationListener",&,N,V_notificationListener
skipCloudKitSetup
TB,N,V_skipCloudKitSetup
containerProvider
T@"PFCloudKitContainerProvider",&,N,V_containerProvider
useDaemon
TB,N,V_useDaemon
useTestDaemon
TB,N,V_useTestDaemon
containerIdentifier
T@"NSString",&,N,V_containerIdentifier
ckAssetThresholdBytes
T@"NSNumber",&,N,V_ckAssetThresholdBytes
initializeSchema
TB,N,V_initializeSchema
containerOptions
T@"CKContainerOptions",&,N,V_containerOptions
useEncryptedStorage
TB,N,V_useEncryptedStorage
operationMemoryThresholdBytes
T@"NSNumber",&,N,V_operationMemoryThresholdBytes
automaticallyDownloadFileBackedFutures
TB,N,V_automaticallyDownloadFileBackedFutures
automaticallyScheduleImportAndExportOperations
TB,N,V_automaticallyScheduleImportAndExportOperations
preserveLegacyRecordMetadataBehavior
TB,N,V_preserveLegacyRecordMetadataBehavior
apsConnectionMachServiceName
T@"NSString",&,N,V_apsConnectionMachServiceName
PFUbiquitySetupLogMigrationSourceModelHashKey
Failed to migrate ubiquitous content, unable to create mapping model
%s(%d): CoreData: Ubiquity:  %@
Error: %@
-[PFUbiquityMigrationManager migrateTransactionLogs:andBaselineIfNecessaryForStoreName:peerID:error:]
reason
%s(%d): CoreData: Ubiquity:  Migrating transaction logs
Failed to migrate ubiquitous content, unable to migrate transaction logs
%s(%d): CoreData: Ubiquity:  Migrating baseline (if necessary)
%s(%d): CoreData: Ubiquity:  Missing baseline archive for the migration destination data model, need to migrate baseline archive from the source version
ubbaselinestoreXXXXXX
Failed to create temp directory for migrating source baseline
errno
%s(%d): CoreData: Ubiquity:  Failed to migrate baseline: %@
src_baseline.store
dst_baseline.store
%s(%d): CoreData: Ubiquity:  Error writing out migrated baseline: %@
Error: %@
%s(%d): CoreData: Ubiquity:  Error gathering contents for migrated baseline: %@
Error: %@
%s(%d): CoreData: Ubiquity:  Missing baseline archive for the migration src data model, let the standard ubiquity awake/launch logic start a new baseline
%s(%d): CoreData: Ubiquity:  Failed to initialize src data model baseline: %@
%s(%d): CoreData: Ubiquity:  Baseline exists in the cloud, the current baseline cache will be created if it is needed.
sourceModel
T@"NSManagedObjectModel",R,V_sourceModel
destinationModel
T@"NSManagedObjectModel",R,V_destinationModel
rootLocation
T@"PFUbiquityLocation",R,V_rootLocation
metadataToWrite
T@"NSDictionary",R,N,V_metadataToWrite
savePlan
T@"NSSQLSavePlan",R,N,V_savePlan
model
T@"NSSQLModel",R,N
request
T@"NSSaveChangesRequest",R,N
faultHandler
T@"NSFaultHandler",R,N,V_faultHandler
originalCachedRows
T@"NSMutableDictionary",R,N,V_originalCachedRows
externalDataReferencesDirectory
T@"NSString",R,N,V_externalDataReferencesDirectory
externalDataLinksDirectory
T@"NSString",R,N,V_externalDataLinksDirectory
fileBackedFuturesDirectory
T@"NSString",R,N,V_fileBackedFuturesDirectory
_ckAsset
CoreData+CloudKit: %s(%d): 
System fields record name doesn't match row: %@
-[PFCloudKitSerializer newCKRecordsFromObject:fullyMaterializeRecords:error:]
System fields record type doesn't match new schema: %@
Failed to reconstruct CKRecord from system fields in object: %@
v32@?0@"NSString"8@"NSAttributeDescription"16^B24
q24@?0@"NSAttributeDescription"8@"NSAttributeDescription"16
Failed to copy CKAsset data for '%@' on '%@' backing record '%@'.
-[PFCloudKitSerializer newCKRecordsFromObject:fullyMaterializeRecords:error:]_block_invoke
Failed to write CKAsset data for '%@' on '%@' backing record '%@'.
v32@?0@"NSAttributeDescription"8Q16^B24
Failed to look up cached mirrored relationship for mtmKey: %@
v32@?0@"NSString"8@"NSRelationshipDescription"16^B24
Record metadata doesn't match row: %@
Deleted relationship failed to update because one or more of the objects in it is already gone: %@
-[PFCloudKitSerializer applyUpdatedRecords:deletedRecordIDs:toStore:inManagedObjectContext:onlyUpdatingAttributes:andRelationships:error:]_block_invoke
Failed to update deleted mirrored relationship: %@
v32@?0@"PFMirroredRelationship"8Q16^B24
Updating relationship: %@
Need to handle fetch errors here and abort serialization. %@
Failed to resolve pending relationship: %@
Marking deleted mirrored relationship fulfilled, one or more of the related objects is missing: %@
v8@?0
Delegate didn't return a file url for asset: %@
Error attempting to read CKAsset file: %@
-[PFCloudKitSerializer updateAttributes:andRelationships:onManagedObject:fromRecord:withRecordMetadata:importContext:]
%@ encountered CKEncryptedData blob on record (%@): %@
Unknown value class (%@) for attribute:
Failed to initialize NSUUID from CKRecord with value: %@
Failed to initialize NSURL from CKAsset with value: %@
Failed to read value from asset at URL: %@
Failed to initialize NSURL from CKRecord with value: %@
Adding mirrored relationship to link for record %@ related to %@ by %@
Failed to get a metadata zone: %@
-[PFCloudKitSerializer getRecordMetadataForObject:inManagedObjectContext:error:]
ckAssetFiles
%@.fxd
%@ - Failed to archive system fields for record: %@
+[PFCloudKitSerializer newArchivedDataForSystemFieldsOfRecord:]
Can't estimate size for unknown value type: %@
CD_recordNames
CD_relationships
CD_entityNames
%@:%@
mirroringOptions
T@"NSCloudKitMirroringDelegateOptions",R,N,V_mirroringOptions
manyToManyRecordNameToRecord
T@"NSDictionary",R,N
delegate
T@"NSObject<PFCloudKitSerializerDelegate>",W,N,V_delegate
recordZone
T@"CKRecordZone",R,N,V_recordZone
writtenAssetURLs
T@"NSArray",R,N
recordNamePrefix
T@"NSString",R,N,V_recordNamePrefix
%@ called after the request was sent to %@
Request: %@
%@.%@ - attribute not found on entity
%@ - entity not found in model
v32@?0@"NSString"8@"NSArray"16^B24
v32@?0@"NSString"8Q16^B24
Invalid '%@'. The following validation failures occured:
objectIDsToFetch
T@"NSArray",C,N,V_objectIDsToFetch
entityNameToAttributesToFetch
T@"NSDictionary",R,C,N
com.apple.coredata
error
unknown
warning
annotation
CloudKit
debug
CoreData: %s: %s
fault
details
_NSCoreDataOptimisticLockingFailureConflictsKey
NSExceptionOmitCallstacks
expression
persistentStore
Bad compound predicate predicateOperator type
Invalid predicate: nil RHS
predicate
%@.%@
Too many KVC aggregates in keypath: %@
NSUnderlyingException
Malformed keypath: %@
valueForKey:
valueForKeyPath:
count:
supportedKVCAggregates
Unsupported KVC aggregate in keypath: %@
average
_NSPredicateUtilities
Reason
Subquery expressions must have a collection expression containing a single keypath
NSCoreDataXPCMessageCode
NSCoreDataXPCMessageBody
NSCoreDataXPCMessageToken
NSCoreDataXPCMessageContextName
NSCoreDataXPCMessageContextTransactionAuthor
NSCoreDataXPCMessageProcessName
supportsSecureCoding
TB,R
messageCode
TQ,V_messageCode
messageBody
T@"NSData",&,N,V_messageBody
token
T@"NSString",&,N,V_token
contextName
T@"NSString",&,N,V_contextName
contextTransactionAuthor
T@"NSString",&,N,V_contextTransactionAuthor
processName
T@"NSString",&,N,V_processName
Token: %@
Interesting:
Changed:
Deleted:
Purged:
interestingZoneIDs
T@"NSSet",R,C,N,V_interestingZoneIDs
changedRecordZoneIDs
T@"NSSet",R,N,V_changedRecordZoneIDs
deletedRecordZoneIDs
T@"NSSet",R,N,V_deletedRecordZoneIDs
purgedRecordZoneIDs
T@"NSSet",R,N,V_purgedRecordZoneIDs
updatedChangeToken
T@"CKServerChangeToken",&,N,V_updatedChangeToken
Relationship fault for %@ on %p
Relationship objects for %@ on %p: %@
source
T@"NSManagedObject",R,N
relationship
T@"NSPropertyDescription",R,N
TB,R,N,GisFault
index
TI,N,V_index
value
T@,&,N,V_value
tableName
T@"NSString",&,N,V_tableName
Relationship '%@' fault on managed object (%p) %@
Relationship '%@' on managed object (%p) %@ with objects %@
add%sObject:
add%s:
remove%sObject:
remove%s:
intersect%s:
set%s:
NSPersistentCloudKitContainerOptionsKey
NSPersistentCloudKitContainerEncryptedAttributeKey
Cannot assign the same iCloud Container Identifier to multiple persistent stores.
com.apple.developer.icloud-container-identifiers
cloudKitContainerOptions
T@"NSPersistentCloudKitContainerOptions",&
IEM_
removedProperties
addedProperties
mappedProperties
couldFailValidation
Each source entity must have a unique renaming identifier
Each destination entity must have a unique renaming identifier
manager
fetchRequestForSourceEntityNamed:predicateString:
TRUEPREDICATE
sourceContext
Each property must have a unique renaming identifier
(migration) destination model property (renaming identifier '%@') matches the renaming identifier for a different type of property (%@) in the source model. Properties cannot be mapped to other property types.
(migration) uninferrable, non-transient property type '%u' for destination model property (renaming identifier '%@'), source model property (renaming identifier '%@').
Remove
Copy
Transform
(migration) attribute mapping for (%@->%@) requires data validation during store migration, mapping a new, mandatory attribute without a default value.
property
entity
Source and destination attribute types are incompatible
(migration) attribute mapping for (%@->%@ to %@->%@) requires data validation during store migration, mapping a previously optional attribute to a mandatory attribute without a default value.
_prependExternalBlobToken:
Unable to use inferred mapping to move external reference into store.
entityPolicy
_nonNilValueOrDefaultValueForAttribute:source:destination:
destination
Unable to infer mapping for attribute
(migration) relationship mapping for (%@->%@) requires data validation during store migration, mapping a new, mandatory relationship.
(migration) relationship mapping for (%@->%@ to %@->%@) requires data validation during store migration, mapping a previously optional relationship to a mandatory relationship.
Can not map from a to-many to a to-one relationship
destinationInstancesForSourceRelationshipNamed:sourceInstances:
Unable to infer mapping for relationship
%@%@_%@
constantValue
_value
Unsupported: (unsupported function)
derived attribute
%@_%@_%@
DROP TRIGGER IF EXISTS %@_INSERT
DROP TRIGGER IF EXISTS %@_DELETE
DROP TRIGGER IF EXISTS %@_%@_INSERT
dropStatements
 WHEN %d <= NEW.Z_ENT AND NEW.Z_ENT <= %d 
 AND %d <= Z_ENT AND Z_ENT <= %d 
 WHERE %d <= Z_ENT AND Z_ENT <= %d 
CREATE TRIGGER IF NOT EXISTS %@_INSERT AFTER INSERT ON %@ FOR EACH ROW
 BEGIN
 UPDATE %@ SET %@ = %@ + 1 WHERE Z_PK = NEW.%@%@ ;
 END
CREATE TRIGGER IF NOT EXISTS %@_DELETE AFTER DELETE ON %@ FOR EACH ROW
 UPDATE %@ SET %@ = %@ - 1 WHERE Z_PK = OLD.%@%@ ;
CREATE TRIGGER IF NOT EXISTS %@_%@_%@_INSERT AFTER INSERT ON %@ FOR EACH ROW%@
 UPDATE %@ SET %@ = (SELECT IFNULL(COUNT(%@), 0) FROM %@ WHERE %@ = NEW.Z_PK) WHERE Z_PK = NEW.Z_PK ;
UPDATE %@ SET %@ = (SELECT IFNULL(COUNT(%@), 0) FROM %@ WHERE %@ = %@.Z_PK)%@;
dataStatements
triggerCreationStatements
Unsupported: (multi-step keypath)
Unsupported: (bad keypath, should be toOne.attribute)
NEW.%@
NSCoreDataCanonical(NEW.%@)
NSCoreDataCanonical(%@)
uppercase(NEW.%@)
uppercase(%@)
lowercase(NEW.%@)
lowercase(%@)
Unsupported: (unsupported function for to one)
Unsupported: (unsupported expression for to one)
DROP TRIGGER IF EXISTS %@_UPDATE
%d <= NEW.Z_ENT AND NEW.Z_ENT <= %d
%d <= Z_ENT AND Z_ENT <= %d
 UPDATE %@ SET %@ = (SELECT %@ from %@ where Z_PK = NEW.%@) WHERE Z_PK = NEW.Z_PK%@ ;
 AND %@
CREATE TRIGGER IF NOT EXISTS %@_UPDATE AFTER UPDATE OF %@ ON %@ FOR EACH ROW%@
 WHEN %@
 UPDATE %@ SET %@ = (SELECT %@ from %@ where Z_PK = NEW.%@) WHERE Z_PK = NEW.Z_PK ;
 UPDATE %@ SET %@ = %@ WHERE %@ = NEW.Z_PK%@ ;
CREATE TRIGGER IF NOT EXISTS %@_UPDATE AFTER UPDATE OF %@ ON %@ FOR EACH ROW
UPDATE %@ SET %@ = (SELECT %@ FROM %@ WHERE Z_PK = %@.%@)%@
WHERE %@
+ IFNULL(NEW.%@, 0)
- IFNULL(OLD.%@, 0)
%@, %@
DROP TRIGGER IF EXISTS %@_UPDATE_INCREMENT
DROP TRIGGER IF EXISTS %@_UPDATE_DECREMENT
CREATE TRIGGER IF NOT EXISTS %@_INSERT AFTER INSERT ON %@ FOR EACH ROW WHEN (NEW.%@ NOT NULL)
 UPDATE %@ SET %@ = %@ %@ WHERE Z_PK = NEW.%@%@ ;
CREATE TRIGGER IF NOT EXISTS %@_UPDATE_INCREMENT AFTER UPDATE OF %@ ON %@ FOR EACH ROW WHEN (NEW.%@ NOT NULL)
CREATE TRIGGER IF NOT EXISTS %@_UPDATE_DECREMENT AFTER UPDATE OF %@ ON %@ FOR EACH ROW WHEN (OLD.%@ NOT NULL)
 UPDATE %@ SET %@ = %@ %@ WHERE Z_PK = OLD.%@%@ ;
CREATE TRIGGER IF NOT EXISTS %@_DELETE AFTER DELETE ON %@ FOR EACH ROW WHEN (OLD.%@ NOT NULL)
 UPDATE %@ SET %@ = (SELECT IFNULL(%@(%@), 0) FROM %@ WHERE %@ = NEW.Z_PK) WHERE Z_PK = NEW.Z_PK ;
COUNT
UPDATE %@ SET %@ = (SELECT IFNULL(%@(%@), 0) FROM %@ WHERE %@ = %@.Z_PK)%@;
 UPDATE %@ SET %@ = %@ WHERE Z_PK = NEW.Z_PK ;
CREATE TRIGGER IF NOT EXISTS %@_UPDATE AFTER UPDATE OF %@ ON %@ FOR EACH ROW %@
WHERE %d <= Z_ENT AND Z_ENT <= %d 
NEW.
UPDATE %@ SET %@ = %@ %@
bad keypath
currently unsupported (bad root property type)
currently unsupported (wrong number of arguments)
bad parameter to function expression canonical: (not a keypath expression)
%@(%@)
NSCoreDataNow()
NSCoreDataCanonical
upper
lower
random
currently unsupported (unsupported function)
Z_OPT
currently unsupported (extended keypath)
problem keypath
WHEN (
 OR 
OLD.%@ != NEW.%@
currently unsupported (unsupported function on to many (not count or sum))
malformed expression (dependent property is to many, derivation expression is not a function)
currently unsupported (unsupported keypath property type)
currently unsupported (unsupported expression type)
currently unsupported (predicate)
currently unsupported (too many steps)
currently unsupported (too many keypaths)
int16
int32
int64
decimal
double
float
string
bool
date
binary
UUID
encodable
_name
_indexTitle
_sectionOffset
_numberOfObjects
(NSFetchedResultsController) section '%@' not found in controller
name
T@"NSString",R,N
indexTitle
numberOfObjects
TQ,R,N
objects
sectionOffset
TQ,R,N,V_sectionOffset
sectionNumber
oldSectionNumber
TQ,N,V_oldSectionNumber
T@"NSString",R,N,V_name
T@"NSString",R,N,V_indexTitle
TQ,R,N,V_numberOfObjects
Invalid RHS for rtree query (should be an array but isn't) %@
properties
Invalid RHS for rtree query (array should have 2 elements) %@
Invalid RHS  element for rtree query (should be a constant value) %@
Mismatch between number of properties and number of ranges for rtree query
ranges
Invalid index name expression (should be a constant value)
indexNameExpression
Invalid index name (should be a string)
indexName
nestingLevel
Invalid LHS for rtree query %@
Unsupported predicate; can't generate SQL for %@
Unable to generate SQL for keypath %@
Invalid ranged property (relationship?!?) %@
(no index name specified, multiple indices available)
(no index found for name %@)
Can't find index for rtree query %@
Can't generate SQL; crosscheck failed
Invalid RHS for rtree query %@
%@ <= %@.%@_MIN AND %@.%@_MAX <= %@
 AND 
%@ IN (SELECT %@.Z_PK FROM %@ %@ WHERE (%@))
 WHERE  (1 = 1) 
INSERT OR IGNORE INTO 
INSERT INTO 
) VALUES(?, ?, ?
INSERT OR REPLACE INTO 
) VALUES (?, ?
UPDATE OR FAIL 
 SET 
 = ? WHERE 
 = ? AND 
 = ?
 WHERE 
DELETE FROM 
 WHERE Z_PK = ? AND (Z_OPT = ? OR Z_OPT IS NULL)
 WHERE Z_PK = ? AND Z_OPT = ?
Updating a constrained entity generated an UPDATE statement with no columns on entity %@
 WHERE Z_PK = ?
 WHERE %@ = ? AND %@ = ?
limitedStatement
T@"NSSQLiteStatement",&,N,V_limitedStatement
unlimitedStatement
T@"NSSQLiteStatement",&,N,V_unlimitedStatement
substitutionBindVariableOrder
T@"NSArray",&,N,V_substVarBindOrdering
substitutionBindIntarrayOrder
T@"NSArray",&,N,V_substIntarrayBindOrdering
%@: index (%lu) beyond bounds (%lu)
@"NSObject"40@?0@"NSCachingFetchRequest"8@"NSManagedObjectContext"16@"NSDictionary"24@32
Error attempted to convert unknown Ancillary Entity: %@
iBooks
Music
batch
v32@?0@8Q16^B24
%@: index (%lu) beyond bounds (%u)
%@ (%p) of %lu items for request %@
You're doing it wrong
Skanky class can only be used skankily.
NSOrderedSet wrapper '%@' for fetch request results: %@
objectID
batched fetch array received an error %@ with userInfo %@
 batched fetch request asked to fetch %d objects but received %d objects as %@
self
ZT_%@_%@_%@
%@_%@_INSERT_INCREMENT
DROP TRIGGER IF EXISTS %@
CREATE TRIGGER IF NOT EXISTS %@ AFTER INSERT ON %@ FOR EACH ROW
 UPDATE %@ SET %@ = IFNULL(%@,0) + 1
 WHERE NEW.%@ IN (SELECT %@ FROM %@ WHERE %@)
 AND NEW.%@ = %@;
 SELECT NSCoreDataTriggerUpdateAffectedObjectValue('%@', %@, %@, '%@', %@) FROM %@ WHERE %@ = NEW.%@;
%@_UPDATE_INCREMENT
CREATE TRIGGER IF NOT EXISTS %@
 AFTER UPDATE OF %@ ON %@ FOR EACH ROW
 WHERE %@ IN (SELECT %@ FROM %@ WHERE %@ = NEW.%@ AND (%@));
%@_UPDATE_DECREMENT
 UPDATE %@ SET %@ = MAX(0,IFNULL(%@,0) - 1)
%@_%@_DELETE_DECREMENT
CREATE TRIGGER IF NOT EXISTS %@ AFTER DELETE ON %@ FOR EACH ROW
 WHERE OLD.%@ IN (SELECT %@ FROM %@ WHERE %@)
 AND OLD.%@ = %@;
 SELECT NSCoreDataTriggerUpdateAffectedObjectValue('%@', %@, %@, '%@', %@) FROM %@ WHERE %@ = OLD.%@;
%@_DELETE_DECREMENT
CREATE TRIGGER IF NOT EXISTS %@ AFTER DELETE ON %@ FOR EACH ROW WHEN %@
 WHERE %@ IN (SELECT %@ FROM %@ WHERE %@ = OLD.%@ AND (%@));
COUNT_%@
CREATE TEMP TABLE %@ AS
 SELECT %@, COUNT(DISTINCT(%@.%@)) AS COUNT
 FROM %@, %@
 WHERE %@ AND %@.%@ == %@.%@
 GROUP BY %@;
 CREATE INDEX %@_INDEX ON %@(%@,COUNT);
 UPDATE %@ SET %@ = IFNULL((SELECT COUNT FROM %@ WHERE %@ = %@),0);
 DROP TABLE %@;
%@_INSERT_INCREMENT
 AFTER INSERT ON %@ FOR EACH ROW WHEN %@
 WHERE NEW.%@ = %@;
 AFTER UPDATE OF %@ ON %@
 FOR EACH ROW WHEN (%@) AND (%@) AND (NEW.%@ == OLD.%@)
 FOR EACH ROW WHEN (%@) AND (%@) AND (OLD.%@ == NEW.%@)
 WHERE OLD.%@ = %@;
 AFTER DELETE ON %@ FOR EACH ROW WHEN %@
 UPDATE %@ SET %@ = MAX(0,IFNULL(%@,0) - 1) WHERE OLD.%@ = %@;
 AFTER INSERT ON %@ FOR EACH ROW
 UPDATE %@ SET %@ = (SELECT COUNT(%@) FROM %@ WHERE (%@ = NEW.%@) AND (%@)) WHERE %@ = NEW.%@;
%@_%@_UPDATE_INCREMENT
 AFTER UPDATE OF %@ ON %@ WHEN (%@) AND
 ((NEW.%@ IS NOT NULL AND OLD.%@ IS NULL) OR (NEW.%@ != OLD.%@))
 UPDATE %@ SET %@ = IFNULL(%@,0) + 1 WHERE %@ = NEW.%@;
%@_%@_UPDATE_DECREMENT
 ((OLD.%@ IS NOT NULL AND NEW.%@ IS NULL) OR (NEW.%@ != OLD.%@))
 UPDATE %@ SET %@ = MAX(0,IFNULL(%@,0) - 1) WHERE %@ = OLD.%@;
 FROM %@
 WHERE %@
 UPDATE %@ SET %@ = IFNULL((SELECT COUNT FROM %@ WHERE %@ = %@), 0);
 FOR EACH ROW WHEN (%@) AND (%@)
%@_%@_UPDATE_TO_NULL
 AFTER UPDATE OF %@ ON %@ WHEN
 (NEW.%@ IS NULL AND OLD.%@ IS NOT NULL)
 UPDATE %@ SET %@ = 0 WHERE %@ = NEW.%@;
 UPDATE %@ SET %@ = (SELECT COUNT(%@) FROM %@ WHERE %@ = NEW.%@ AND (%@)) WHERE %@ = NEW.%@;
 SELECT %@, COUNT(DISTINCT(%@)) AS COUNT
offendingString
Unable to parse trigger predicate to an instance of NSPredicate.
 %@ 
offendingPredicate
Invalid trigger predicate, compound predicates must be AND or OR predicates.
Invalid trigger predicate, predicate must evaluate to an instance of NSComparisonPredicate or NSCompoundPredicate.
 OR (NEW.%@ %@ %ld AND OLD.%@ %@ %ld)
(NEW.%@ %@ %ld AND OLD.%@ %@ %ld)
NEW.%@ != OLD.%@
%@ %@ %ld
OLD.%@ %@ %ld
NEW.%@ %@ %ld
offendingAttribute
Invalid trigger predicate, unable to find the attribute specified by this predicate.
Invalid trigger predicate, this predicate appears to reference a different relationship than other predicates in this trigger.
Invalid trigger predicate, failed to find the relationship identified by the keyPath.
Invalid trigger predicate, predicate operator must be one of:
NSLessThanPredicateOperatorType,
NSLessThanOrEqualToPredicateOperatorType,
NSGreaterThanPredicateOperatorType,
NSGreaterThanOrEqualToPredicateOperatorType,
NSEqualToPredicateOperatorType,
NSNotEqualToPredicateOperatorType
Invalid trigger predicate, right expression must evaluate to a constant integer value.
Invalid trigger predicate, right expression must evaluate to an instance of NSConstantValueExpressionType.
Invalid trigger predicate, left expression must be a key-path with only two components.
Invalid trigger predicate, left expression must evaluate to an instance of NSKeyPathExpressionType.
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
insertSQLStrings
dropSQLStrings
bulkUpdateSQLStrings
T@"NSSQLEntity",R,V_entity
attribute
T@"NSSQLAttribute",R,V_attribute
predicateString
T@"NSString",R,V_predicateString
T@"NSPredicate",R,V_predicate
T@"NSSQLRelationship",R,V_relationship
destinationEntity
T@"NSSQLEntity",R,V_destinationEntity
destinationAttributes
T@"NSArray",R,V_destinationAttributes
toManyInnerFetchWhereClause
T@"NSString",R
toManyDecrementWhenClause
toManyIncrementWhenClause
ofClause
oldMatchingClause
newMatchingClause
columnChangedClause
T@"NSArray",R,N,V_insertSQLStrings
 { %@ }
purgedRecordZoneID
T@"CKRecordZoneID",R,N,V_purgedRecordZoneID
hw.activecpu
hw.cpufrequency
hw.memsize
%@ is not a valid initializer for %@. Use %@ instead.
com.apple.CoreData
CoreData
 Can't find CoreData image header.
Can't find the hash for some reason, using empty data
B16@?0@"NSManagedObject"8
.interim
Can't open externalDataReference interim file : %d
Problem Path
Can't create externalDataReference interim file : %d
Can't copy interim file to permanent location : %d
Problem object
Unable to open file with path %s (%d)
Unable to open file with path: %s (%d)
Missing bytes from file at path %s, expected %lu, got %lu
Unable to read content of file with path: %s (%d)
Unable to read requested number of bytes from path: %s (got %lu)
/dev/null
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~_
self IN %@
object
T@,R
address
Tq,R
_LOCK
.LINKS
_PFEncodedData
NSKnownKeysMappingStrategy2
Corrupted archive (unexpected data in pointer space).
Corrupted archive (failed to read row).
Corrupted branch row in optimized model detected:
Background Core Data task threw an exception.  Exception = %@ and userInfo = %@
_NSZombie_%s
_NSZombie_
 %@-%@:%@-%@-%@:%@
New many to many relationship type?: %@
q24@?0@"NSRelationshipDescription"8@"NSRelationshipDescription"16
type
TQ,R,N,V_type
relationshipDescription
T@"NSRelationshipDescription",R,N,V_relationshipDescription
inverseRelationshipDescription
T@"NSRelationshipDescription",R,N,V_inverseRelationshipDescription
manyToManyRecordID
T@"CKRecordID",R,N,V_manyToManyRecordID
manyToManyRecordType
T@"NSString",R,N,V_manyToManyRecordType
ckRecordID
T@"CKRecordID",R,N,V_ckRecordID
relatedCKRecordID
T@"CKRecordID",R,N,V_relatedCKRecordID
Linking object with record name %@ to %@ via %@
-[PFMirroredOneToManyRelationship updateRelationshipValueUsingImportContext:andManagedObjectContext:error:]
Couldn't find related object to link for object with record name %@ to %@ via %@
T@"NSManagedObjectID",R,N,V_objectID
recordID
T@"CKRecordID",R,N,V_recordID
relatedObjectRecordID
T@"CKRecordID",R,N,V_relatedRecordID
metadataForPersistentStoreWithURL:error: must be overriden by your store class to provide metadata
NSMappedObjectStore must be initialized with initWithPersistentStoreCoordinator:configurationName:URL:options
Atomic stores do not support file backed futures
save: must be overriden by your store class to save data to the store
load: must be overriden by your store class to load data from the store
Store %@ cannot hold instances of entity %@
newCacheNodeForManagedObject: must be overriden by your store class to create a cache node from a managed object
updateCacheNode:fromManagedObject: must be overriden by your store class to update a cache node from a managed object
Cannot retrieve referenceObject from an objectID that was not created by this store
Store Type does not support Persistent History
Unknown command type %@
Unsupported fetch request: store %@ does not support GROUP BY
NSCoreDataPrimaryError
Error saving the persistent store.
v32@?0@"NSSQLAttribute"8@"NSSet"16^B24
NSAddStoreAsynchronouslyOption
NSInvokeCompletionHandlerConcurrently
%@ (type: %@, url: %@)
NSPersistentStoreMirroringOptionsKey
T@"NSString",C,V_type
configuration
T@"NSString",C,V_configuration
T@"NSURL",C,V_url
options
readOnly
TB,GisReadOnly
timeout
sqlitePragmas
shouldAddStoreAsynchronously
shouldMigrateStoreAutomatically
shouldInferMappingModelAutomatically
NSAtomicStoreCacheNodes must be initialized using initWithObjectID:(NSManagedObjectID *)
NSAtomicStoreCacheNodes must be created with an objectID
T@"NSManagedObjectID",R,N
propertyCache
T@"NSMutableDictionary",&,N
NSAttributeType
NSAttributeValueClassName
NSDefaultValue
NSValueTransformerName
NSIsIndexed
NSFlagsKey
NSSecureUnarchiveFromDataTransformerName
NSMaxValueName
NSMinValueName
NSIsFileBackedFuture
%@, attributeType %lu , attributeValueClassName %@, defaultValue %@, preserveValueOnDeletionInPersistentHistory %@
Can't set attributeValueClassName to nil for a non-transient attribute.
Can't set attribute type to undefined for non-transient attribute.
'%@' is only supported for use with '%@'.
Can't find class for type %lu
_NSCreateIndex
SELF >= %@
SELF =< %@
length >= %@
length =< %@
timeIntervalSinceReferenceDate >= %@
timeIntervalSinceReferenceDate =< %@
self >= %@
self =< %@
B24@?0@"NSURL"8@"NSDictionary"16
attributeType
attributeValueClassName
T@"NSString",C
defaultValue
T@,&
versionHash
T@"NSData",R,C
valueTransformerName
allowsExternalBinaryDataStorage
preservesValueInHistoryOnDeletion
TB,VpreserveValueOnDeletionInPersistentHistory
preserveValueOnDeletionInPersistentHistory
NSDoubleAttributeType
NSDateAttributeType
NSFloatAttributeType
NSStringAttributeType
NSBooleanAttributeType
NSDecimalAttributeType
NSObjectIDAttributeType
NSInteger16AttributeType
NSInteger32AttributeType
NSInteger64AttributeType
NSBinaryDataAttributeType
NSTransformableAttributeType
NSURIAttributeType
NSUUIDAttributeType
NSUndefinedAttributeType
length
timeIntervalSinceReferenceDate
no NSValueTransformer with class name '%@' was found for attribute '%@' on entity '%@'
xctest
cplctl
One or more models in this application are using transformable properties with transformer names that are either unset, or set to NSKeyedUnarchiveFromDataTransformerName. Please switch to using "%@" or a subclass of NSSecureUnarchiveFromDataTransformer instead. At some point, Core Data will default to using "%@" when nil is specified, and transformable properties containing classes that do not support NSSecureCoding will become unreadable.
Property '%@' on Entity '%@' is using nil or an insecure NSValueTransformer.  Please switch to using "%@" or a subclass of NSSecureUnarchiveFromDataTransformer instead.
NSTriggerKey
Error decoding default value for %@ : %@
isFileBackedFuture
INTEGER
NUMERIC
DOUBLE
TEXT
BOOLEAN
TIMESTAMP
BLOB
Undefined attribute type.
"%@" %@
abstract
_NSCoreManagedObjectID
Entity name must not be nil.
Store must not be nil.
_NSObjectID_%s_%x
%@://%@/%@/p%@
x-coredata
x-coredata://
%@://%@/%@/p%qu
_NSCoreDataTaggedObjectID
-initWithObject: is not implemented on tagged objectIDs
-_referenceData is not implemented on tagged objectIDs
%@://%@/%@/t%@%d
Cannot create a binary store with a nil URL.
CoreData binary stores only support file URLs (got %@).
Error validating url for store
Attempt to add read-only file at path %@ read/write. Adding it read-only instead. This will be a hard error in the future; you must specify the NSReadOnlyPersistentStoreOption.
Attempt to add read-only store read-write
NSBinaryObjectStore only supports file URLs right now.
Can't save store to %@ (read-only store)
subresults
T@"NSArray",R,V_subresults
progress
T@"NSProgress",&,V_requestProgress
operationError
T@"NSError",&,V_requestError
requestCompletionBlock
T@,C,V_requestCompletionBlock
managedObjectContext
T@"NSManagedObjectContext",R,V_requestContext
finalResult
T@"NSArray",&,V_finalResult
intermediateResultCallback
T@?,C,V_intermediateResultCallback
fetchRequest
T@"NSAsynchronousFetchRequest",R,V_fetchRequest
 %@.%@ = %@
The trigger on %@.%@ is not valid: Only expressions of the form 'relationship.@count' are supported.
The trigger on %@.%@ is not valid: could not turn '%@' in to an instance of %@
The trigger on %@.%@ is not valid: an exception was thrown while trying to parse the expression: %@:%@
The trigger on %@.%@ is not valid: empty string is not a valid expression.
The trigger on %@.%@ is not valid: must be an instance of %@.
The trigger on %@.%@ is not valid: nil is not a valid expression.
The trigger on %@.%@ is not valid: '%@' does not evaluate to a keypath expression.
The trigger on %@.%@ is not valid: The function '%@' is not supported, only 'count' is supported at this time.
The trigger on %@.%@ is not valid: '%@' does not evaluate to a function expression.
The trigger on %@.%@ is not valid: property '%@' is not an integer.
The trigger on %@.%@ is not valid: Must be set on an attribute of type %@.
The trigger on %@.%@ is not valid: property '%@' not found.
The trigger on %@.%@ is not valid: relationship '%@' is not a to-many.
The trigger on %@.%@ is not valid: keypath '%@' is not a relationship.
The trigger on %@.%@ is not valid: '%@' is not a property of '%@'.
 AFTER DELETE ON %@
 UPDATE %@ SET %@ = (SELECT COUNT(%@) FROM %@ WHERE (%@ = NEW.%@)) WHERE %@ = NEW.%@;
objectFromUserInfo
T@,R,N,V_objectFromUserInfo
keypath
T@"NSString",R,N,V_keypath
T@"NSSQLEntity",R,N,V_entity
T@"NSSQLAttribute",R,N,V_attribute
countedRelationship
T@"NSSQLRelationship",R,N,V_countedRelationship
T@"NSArray",R,N,V_dropSQLStrings
T@"NSArray",R,N,V_bulkUpdateSQLStrings
Keyed archiver failure
metadata
mapData
NSAttributeValues
NSAttributes
Can't read binary data from file
Can't load binary data from file (file was created by an incompatible version of CoreData)
_NSStoreMapArchiveVersion
_NSStoreMapArchiveMetadata
_NSStoreMapArchiveNextPK
_NSStoreMapArchiveData
Can't load data from archived data (archived data was created by an incompatible version of CoreData)
Directory does not exist : %@
Not a directory : %@
Directory is not writable : %@
Binary store save failed.
Can't construct a node from nil.
Source object
Destination Object
Relationship
CoreData does not support persistent cross-store relationships
Can't find entity for object
_CoreDataEntityDescription
_CoreDataEntityName
NSKeyValueUndefinedSetter
NSKeyValueUndefinedGetter
+entityForName: nil is not a legal NSManagedObjectContext parameter searching for entity name '%@'
+entityForName: nil is not a legal NSPersistentStoreCoordinator for searching for entity name '%@'
+entityForName: could not locate an NSManagedObjectModel for entity name '%@'
+entityForName: could not locate an entity named '%@' in this model.
NSEntityName
NSClassNameForEntity
NSIsAbstract
NSManagedObjectModel
NSSuperentity
NSSubentities
NSProperties
NSUserInfo
NSVersionHashModifier
NSRenamingIdentifier
NSUniqueTuples
NSCoreSpotlightDisplayName
NSFetchIndexDescriptions
NSCompoundIndexes
ascending
desc
descending
rtree
NSSupplementalIndexes
(%@) name %@, managedObjectClassName %@, renamingIdentifier %@, isAbstract %u, superentity name %@, properties %@, subentities %@, userInfo %@, versionHashModifier %@, uniquenessConstraints %@
NSManagedObject
B16@?0@"NSPropertyDescription"8
Can't add a subentity to an entity (missing name or bad properties).
Invalid property passed to setProperties: property has nil name or is an NSExpressionDescription.
Can't change name of entity from %@ to %@
can't find attribute named %@
can't find relationship named %@
can't create index %@, unsupported index element property type
element
Indexes must be declared at the highest applicable level. All properties are declared on superentity.
Cannot merge uniqueness constraints { %@ } on entity '%@' due to relationship '%@' having a mandatory to-one inverse relationship '%@' and not using a cascade delete rule on '%@'
Can't find property named %@
Problem name
Cannot create unique constraints for to-many relationships.
Cannot create unique constraints to-one relationships where the entity has subentities.
Property type is not valid for unique constraints.
Uniqueness constraints must be defined at the highest level possible. All properties in constraint %@ are defined on parent entity.
Problem constraint
managedObjectModel
T@"NSManagedObjectModel",R
managedObjectClassName
TB,GisAbstract
subentitiesByName
T@"NSDictionary",R,C
subentities
T@"NSArray",&
superentity
T@"NSEntityDescription",R
propertiesByName
userInfo
T@"NSDictionary",&,N
attributesByName
relationshipsByName
versionHashModifier
renamingIdentifier
indexes
T@"NSArray",C
uniquenessConstraints
compoundIndexes
coreSpotlightDisplayNameExpression
T@"NSExpression",&,N
Can't add an entity to multiple superentities.
Can't add unnamed subentity.
Can't add multiple entities with duplicate names.
Can't add unnamed property to entity.
Entity already contains a property named %@.
Can't add NSExpressionDescriptions to NSEntityDescriptions
tried to add property %p '%@' to entity %p '%@' but it already belongs to entity %p '%@'
UNIQUE
Model must be immutable before mapping strategy can be created
Can't use an entity in two models.
B24@?0@"NSPropertyDescription"8^B16
Unable to load class named '%@' for entity '%@'.  Class not found, using default NSManagedObject instead.
Class '%s' for entity '%@' is not a subclass of NSManagedObject
"%@" is not a subclass of NSManagedObject.
Class '%s' for entity '%@' has an illegal override of NSManagedObject -isEqual:
Class '%s' for entity '%@' has an illegal override of NSManagedObject -hash
Cannot make an immutable entity editable again.
Can't set superentity of self to self.
Bad model.  For entity '%@' superentity '%@' does not think I am a subentity
Bad model.  For entity '%@' subentity '%@' does not think I am its superentity
Bad model.  For entity '%@' subentity '%@ (%p)' is not registered in NSManagedModelModel.  Model has a reference to %@ (%p)
Can't remove property '%@' - doesn't belong to this entity.
Property named '%@' in entity '%@' conflicts with property inherited from parent entity '%@'
Entity %@ already has an index with name %@
Entity
Entity '%@' has unique constraints { %@ } with relationship '%@' and mandatory to-one inverse '%@' but is not using a cascade delete rule .
inverse
Entity '%@' has unique constraints { %@ } with a relationship and mandatory to-one inverse but is not using a cascade delete rule .
Entity wasn't finalized properly before use
Can't read entity into shell: Missing entity frontside delimiter
Root cause
Can't read entity: Not enough bytes left
Can't read entity: Missing version hash value
Can't read entity: Missing entity name
Cant' read entity: Miswired subentities dictionary
Cant' read entity: Mismatched subentity count
Cant' read entity: Properties dictionary has content
Cant' read entity: Properties buffer has content
Cant' read entity: Property entity does not match entity being decoded (1)
Cant' read entity: Property entity does not match entity being decoded (2)
Can't decode coreSpotlightDisplayNameExpression for entity %
Cant' read entity: Mismatched number of fetch indexes
Cant' read entity: Mismatched number of fetch index elements
Unable to decode userInfo for entity '%@' : %@
Can't read entity into shell: Missing entity back-end delimiter
Relationship properties should be @dynamic, not ivars (entity %@, class %s, property %@).  This will be an error in the future.
validate%s:error:
(%@), name %@, mappingType %u, sourceEntityName %@, sourceEntityVersionHash %@, destinationEntityName %@, destinationEntityVersionHash %@, attributeMappings %@, relationshipMappings %@, sourceExpression %@, entityMigrationPolicyClassName %@, userInfo %@
%@->%@
sourceEntityName
sourceEntityVersionHash
T@"NSData",C
destinationEntityName
destinationEntityVersionHash
attributeMappings
relationshipMappings
sourceExpression
T@"NSExpression",&
entityMigrationPolicyClassName
NSMappingName
NSMappingType
NSSourceEntityName
NSSourceEntityVersionHash
NSDestinationEntityName
NSDestinationEntityVersionHash
NSSourceExpression
NSEntityMigrationPolicyClassName
NSAttributeMappings
NSRelationshipMappings
NSEntityMigrationPolicy
Couldn't create mapping policy for class named (%@)
Entity Mappings cannot become mutable after being marked immutable.
Can't modify an immutable entity mapping.
propertyMapping
Can't find source for destination in default mapping policy
More than one source for destination in default mapping policy
Unknown/unsupported type for ordered toMany relationship destination
relationshipDestinations
Unknown/unsupported type for toMany relationship destination
More than one relationship destination for a toOne relationship
Unknown/unsupported type for toOne relationship destination
%@ -> %@
property.name
"%@" INTEGER PRIMARY KEY
columnDefinition
CREATE TABLE "%@" (%@);
NSExpression
NSExpressionType
(<%@ : %p>), name %@, expression %@, resultType %lu, userInfo %@
Unable to decode expression for expression description %@ : %@
expressionResultType
Conflicts
destinations
mtmObjects
message
T@"NSCoreDataXPCMessage",R,N,V_message
store
T@"NSXPCStore",R,N,V_store
result
T@"NSDictionary",&,N,V_result
T@"NSError",&,N,V_error
%@/%@
exportedAt
T@"NSDate",&,D,N
identifier
T@"NSString",&,D,N
historyToken
T@"NSPersistentHistoryToken",&,D,N
operations
T@"NSSet",&,D,N
NSKeyValueIvarSetter
NSKeyValueMethodSetter
NSKeyValueIvarGetter
NSKeyValueMethodGetter
During prefetching, materialized to-many relationship '%@' on object %@ was null
During prefetching, materialized to-one relationship '%@' on object %@ was not a managed object but instead %@
FETCH_SOURCE
FETCHED_PROPERTY
CoreData could not fulfill a fetched property because '%@'
Fetched Property
CoreData Debug Logging: Exception = %@ with error code = %ld and userInfo = %@
failed to retrieve ordering information from fault for object %@ and relationship %@ due to nil NSManagedObjectContext
An NSManagedObject must have a valid NSEntityDescription.
CoreData could not fulfill a fault for '%@'
<UNKNOWN objectID>
An NSManagedObjectContext delegate overrode fault handling behavior to silently substitute nil/0 for all property values for the object with ID '%@'.  This is very unwise.
An NSManagedObjectContext delegate returned an illegal result
Unhandled error occurred during faulting: %@ (%@)
Unhandled error (%@, %ld) occurred during faulting and was ignored: %@
Unhandled error (%@, %ld) occurred during faulting and was thrown: %@
Client ill advisedly ignored an I/O or unknown error from faulting: %@
faulting failed to record an error for an serious condition
 Found no possible URLs for directory type %lu
 Failed to create directory %@: %@
 File %@ already exists and is not a directory!
+[%@ %@] Could not conjure up a useful location for writing persistent stores.
 View context accessed for persistent container %@ with no stores loaded
Failed to call designated initializer on '%@' 
momd
 Failed to load model at path: %@
 Failed to load model named %@
-[NSPersistentContainer initWithName:managedObjectModel:] called with the empty string as its container name
-[NSPersistentContainer initWithName:managedObjectModel:] called with invalid container name '%@'
%@.sqlite
Unhandled exception finding default Directory URL '%@'
-[NSPersistentContainer loadPersistentStoresWithCompletionHandler:] called on an instance with no store descriptions
 Background context created for persistent container %@ with no stores loaded
T@"NSString",R,C,V_name
viewContext
T@"NSManagedObjectContext",R,V_viewContext
persistentStoreCoordinator
T@"NSPersistentStoreCoordinator",R,V_storeCoordinator
persistentStoreDescriptions
T@"NSArray",C,V_storeDescriptions
cachedModelForPersistentStoreWithURL failed with error %@ and userInfo of %@
Store failed to load.  %@ with error = %@ with userInfo %@
v24@?0@"NSPersistentStoreDescription"8@"NSError"16
persistentStoreDescriptionClass
NSFetchRequest
_NSFetchRequestEntityName
%@, fetchRequest %@
Can't use fetch request with fetched property description (entity model mismatch).
T@"NSFetchRequest",&
NSValuesToGroupBy
NSHavingPredicate
NSFetchOffset
NSValuesToFetch
NSEntity
NSPredicate
NSSortDescriptors
NSFetchLimit
NSBatchSize
NSRelationshipKeyPathsForPrefetching
NSResultType
NSAllocationType
NSAllocationSize
NSHasFetchRequestFlags
NSFetchRequestFlags
%@ (entity: %@; predicate: (%@); sortDescriptors: (%@); 
limit: %u; 
offset: %u; 
batch size: %u; 
unknown request type
NSManagedObjectResultType
NSManagedObjectIDResultType
NSDictionaryResultType
NSCountResultType
type: %@; 
affected stores: (%@); 
includesSubentities: NO; 
includesPropertyValues: NO; 
returnsObjectsAsFaults: NO; 
includesPendingChanges: NO; 
returnsDistinctResults: YES; 
shouldRefreshRefetchedObjects: YES; 
NSFetchRequestBufferAllocationType
NSFetchRequestVMBufferAllocationType
allocation type: %@; 
allocation size: %u; 
relationshipKeyPathsForPrefetching: (%@); 
propertiesToFetch: (%@); 
havingPredicate: (%@); 
propertiesToGroupBy: (%@); 
Cannot fetch without an NSManagedObjectContext in scope
This fetch request (%p) was created with a string name (%@), and cannot respond to -entity until used by an NSManagedObjectContext
Invalid keypath %@ passed to %@
setPropertiesToGroupBy:
setPropertiesToFetch:
Invalid keypath %@ passed to setPropertiesToGroupBy:
Invalid keypath %@ passed to %@:
Invalid keypath %@ passed to %@ (non-terminal attribute)
Invalid to many relationship in setPropertiesToFetch: (%@)
Invalid keypath %@ passed to %@ (invalid property type)
Invalid property %@ passed to %@ (property is transient)
Attribute/relationship description names passed to %@ must match name on fetch entity (%@)
Invalid property (%@) passed to setPropertiesToFetch: (entity mismatch)
Invalid to many relationship (%@) passed to %@:
Invalid keypath expression (%@) passed to setPropertiesToFetch:
T@"NSEntityDescription",&,N
entityName
T@"NSPredicate",&,N
sortDescriptors
T@"NSArray",&,N
fetchLimit
TQ,N
affectedStores
resultType
includesSubentities
TB,N
includesPropertyValues
returnsObjectsAsFaults
relationshipKeyPathsForPrefetching
T@"NSArray",C,N
includesPendingChanges
returnsDistinctResults
propertiesToFetch
fetchOffset
fetchBatchSize
shouldRefreshRefetchedObjects
propertiesToGroupBy
havingPredicate
NSFetchRequest could not locate an NSEntityDescription for entity name '%@'
Can't modify a named fetch request in an immutable model.
Invalid groupByProperty type in archive
Can't decode predicate for fetch request
Invalid propertyToFetch type in archive
Can't decode sortDescriptor for fetch request
NSFRExpression
NSMOCExpression
NSCountOnlyFlag
NSFetchRequestExpression could not evaluate its request or context.
FETCH(%@, %@, %@)
Cannot substitute a nil substitution dictionary.
NSFetchRequestExpressionType is not valid here
requestExpression
T@"NSExpression",R
contextExpression
countOnlyRequest
TB,R,GisCountOnlyRequest
NSSourceAttributeName
NSDestinationAttributeName
branch row pointer is NULL
[%d]
branch row pointer%@ = %p flags.size = %d flags.operation = %d flags.parameter = %d flags.offset = %d lowerBound = %d lowerSlot = %d upperBound = %d upperSlot = %d generalSlots pointer = %p with contents = %@
mapping table pointer is NULL
mapping table has 0 branch rows
mapping table %p has %d branch rows:
NSConstantString
__NSCFString
%@ supports a maximum of 32,768 elements.  parameter was %lu
keys
version
mapping table %p has %d branch rows: (...)
%@ (%p) table of length %d with known keys:%@ and %@
*** -%s sent to an NSKnownKeysDictionary object
searchMapping
emptyToken
values
__empty_slot_token_4c24_98dc_ac1e_b773__
The key '%@' is not defined for this NSKnownKeysDictionary
NSTargetObjectUserInfoKey
NSUnknownUserInfoKey
T^@,R,N
mapping
T@"NSKnownKeysMappingStrategy",R,N
activityType
storePath
TQ,R,N,V_activityType
T@"NSString",R,N,V_storePath
NSDetailedErrors
NSValidationErrorObject
NSValidationErrorKey
NSValidationErrorPredicate
NSValidationErrorValue
NSAffectedStoresErrorKey
NSAffectedObjectsErrorKey
NSOriginalSnapshot
NSInsertedObjects
NSDeletedObjects
NSCurrentObjects
NSSQLiteErrorDomain
Delete: %@
Insert: %@ at index: %lu
Move: %@ to index: %lu
(...not nil..)
<relationship fault: %p '%@'>
(...and %ld more...)
%@ (entity: %@; id: %@; data: %@)
<fault>
%@ (entity: <null>; id: %@; data: <fault>)
An NSManagedObject of class '%@' must have a valid NSEntityDescription.
NSEntityDescription '%@' can only support a single custom class (tried to instantiate class '%@'). Use a subentity with 0 properties to further specialize the NSManagedObject subclass.
CoreData: error: Failed to call designated initializer on NSManagedObject class '%@' 
[<%@ %p> valueForUndefinedKey:]: the entity %@ is not key value coding-compliant for the key "%@".
Mutating a managed object %@ (%p) after it has been removed from its context.
NSManagedObjects of entity '%@' do not support -mutableArrayValueForKey: for the property '%@'
NSManagedObjects of entity '%@' do not support -mutableSetValueForKey: for the property '%@'
NSManagedObjects of entity '%@' do not support -mutableOrderedSetValueForKey: for the property '%@'
[<%@ %p> setValue:forUndefinedKey:]: the entity %@ is not key value coding-compliant for the key "%@".
[<%@ %p> setNilValueForKey]: instance of entity %@ could not set nil as the value for the key %@.
<null>
contextShouldIgnoreUnmodeledPropertyChanges
T@"NSManagedObjectContext",R,N
T@"NSEntityDescription",R,N
inserted
TB,R,N,GisInserted
updated
TB,R,N,GisUpdated
deleted
TB,R,N,GisDeleted
hasChanges
TB,R,N
hasPersistentChangedValues
faultingState
Unacceptable type of value for attribute: property = "%@"; desired type = %@; given type = %@; value = %@.
A class implementing the NSFileBackedFuture protocol
Cannot set value for attribute with undefined type: property = "%@"; entity = "%@"; value = %@
Illegal attempt to establish a relationship '%@' between objects in different contexts (source = %@ , destination = %@)
Unacceptable type of value in to-many relationship: property = "%@"; problem = %@; desired type = %@; given type = %@; value = %@.
Unacceptable type of value for %@ relationship: property = "%@"; desired type = %@; given type = %@; value = %@.
ordered to-many
to-many
Unacceptable type of value for to-one relationship: property = "%@"; desired type = %@; given type = %@; value = %@.
Impossible information to maintain inverse relationship "%@" for relationship: %@.
Insufficient information to maintain inverse relationship "%@" for relationship: %@.
Cannot maintain read-only inverse relationship "%@" for relationship: %@.
%{ENTITY}@
%{PROPERTY}@
Illegal validation warning: property = "%@"; predicate/warning index = %lu; warning = %@.
i24@?0r^v8r^v16
Object has pending changes
com.apple.CoreData.%@.%p
Exception thrown posting NSRemotePersistentStoreDidChangeNotification: %@
Unknown exception thrown posting NSRemotePersistentStoreDidChangeNotification
v12@?0i8
 Failed to setup notification listener: %d
%@: null selector
%s_%s_
%s_%s_%x
contextShouldIgnoreChangesFor
_cd_bits_%p
Incorrect ivar generation
[%dI]
class_addIvar failed
Multiple NSEntityDescriptions claim the NSManagedObject subclass '%s' so +entity is unable to disambiguate.
 '%@' (%p) from NSManagedObjectModel (%p) claims '%s'.
No NSEntityDescriptions in any model claim the NSManagedObject subclass '%s' so +entity is confused.  Have you loaded your NSManagedObjectModel yet ?
Multiple NSEntityDescriptions in NSManagedObjectModel (%p) claim the NSManagedObject subclass '%s' so +entity is unable to disambiguate.  Both entities '%@' (%p) and '%@' (%p)
This NSManagedObjectContext (%p) does not have a coordinator and model assigned yet so +entity on '%s' is sad.
+[%s entity] Failed to find a unique match for an NSEntityDescription to a managed object subclass
Snapshot class was nil
NULL _cd_rawData but the object is not being turned into a fault
automaticallyNotifiesObserversOf
managedObjectOriginal_
Property '%s' is a 64 bit scalar type on class '%s' that does not match its entity's property's 32 bit scalar type.  Implicit coercion to 32 bits in the database is not recommended.
Property '%s' is a scalar type on class '%s' that does not match its Entity's property's scalar type.  Dynamically generated accessors do not support implicit type coercion.  Cannot generate a getter method for it.
Property '%s' is a scalar type on class '%s'.  Cannot generate a getter method for it.
dynamic accessors failed to find @property implementation for '%s' for entity '%@' while resolving selector '%s' on class '%s'.  Did you remember to declare it @dynamic or @synthesized in the @implementation ?
setPrimitive
primitive
Property '%s' is marked __weak on class '%s'.  Cannot generate a setter method for it.
Property '%s' is a scalar type on class '%s' that does not match its Entity's property's scalar type.  Dynamically generated accessors do not support implicit type coercion.  Cannot generate a setter method for it.
Property '%s' is a scalar type on class '%s'.  Cannot generate a setter method for it.
Property '%s' is marked copy on class '%s'.  Cannot generate a copying setter method for NSManagedObject's to-one relationship.
Property '%s' is marked readonly on entity '%@'.  Cannot generate a setter method for it.
Object:
remove
AtIndex:
removeObjectFrom
v@:Q
AtIndexes:
insert
insertObject:in
v@:@Q
:AtIndexes:
v@:@@
replace
replaceObjectIn
AtIndex:withObject:
v@:Q@
AtIndexes:with
validate
:error:
will
Change
Access
v@:@
v@:I
v24@?0@8d16
v20@?0@8f16
d16@?0@8
^v16@?0@8
@16@?0@8
@24@?0@8@16
@32@?0@8@16@24
generateAccessor failed with paramIndex %d
@24@?0@8Q16
@20@?0@8I16
@32@?0@8Q16@24
v@:I@
@28@?0@8I16@20
@32@?0@8@16Q24
v@:@I
@28@?0@8@16I24
generateAccessorWithFunctionPtrSignature failed with unknown signature '%s'
v16@?0@"NSKeyValueSetter"8
refreshed
invalidated
invalidatedAll
newQueryGeneration
newChangeToken
_NSTriggerModifiedObjectsKey
_NSTriggerModifiedObjectIDsKey
inserted_objectIDs
updated_objectIDs
deleted_objectIDs
refreshed_objectIDs
invalidated_objectIDs
NSObjectsChangedByMergeChangesKey
NSObjectsChangedInManagingContextNotification
_NSObjectsChangedInManagingContextPrivateNotification
NSManagingContextDidSaveChangesNotification
NSManagingContextWillSaveChangesNotification
NSManagedObjectContextDidSaveObjectIDsNotification
_NSManagedObjectContextDidSaveObjectIDsPrivateNotification
NSManagedObjectContextDidMergeChangesObjectIDsNotification
_NSManagedObjectContextDidMergeChangesObjectIDsPrivateNotification
ImplicitObservation
com.apple.CoreData.ConcurrencyDebug
com.apple.CoreData.Logging.oslog
com.apple.CoreData.Logging.stderr
com.apple.CoreData.Toolchain.EnableToolchainBehaviors
CommCenter
symptomsd
SpringBoard
News
assetsd
accountsd
CalendarAgent
soagent
Radio
Core Data multi-threading assertions enabled.
Context already has a coordinator;  cannot replace.
An NSManagedObjectContext's retain policy cannot be changed while it has registered objects.  Trying using reset() first.
%@: %@
NSManagedObjectContext over-release triggered improper dealloc here:
Parameter #1 to -assignObject:toPersistentStore: must be an NSManagedObject or subclass.
Can't assign an object to a store that does not contain the object's entity.
Can't reassign an object to a different store once it has been saved.
newStoreURL
originalStoreURL
Cannot insert '%@' in this managed object context because it is not found in the associated managed object model.
-deleteObject: requires a non-nil argument
An NSManagedObjectContext cannot delete objects in other contexts.
Context does not have a coordinator;  cannot obtain permenant ids without a coordinator.
fatal: Unable to recover from optimistic locking failure.
fatal: This NSManagedObjectContext was created on the main thread and illegally passed to a background thread.
Attempting to generate a constraint exception for non constraint error.
constraint validation failure
Exception while resetting query generation during exception recovery for save %@ %@
Unknown exception while resetting query generation during exception recovery for save
attempt to recursively call -save: on the context aborted
stack trace
failed to resolve optimistic locking failure: %@ with %@
failed to resolve optimistic locking failure.  Old save request was: %@
failed to resolve optimistic locking failure.  Next attempt will be: %@
nil is not a valid object ID
NSSaveChangesRequest is not supported by executeRequest:error:
%@ %@ is not a valid NSFetchRequest.
%@ A fetch request must have an entity.
The fetch request's entity %p '%@' appears to be from a different NSManagedObjectModel than this context's
NSConfinementConcurrencyType context %@ cannot support asynchronous fetch request %@.
managed objects
An NSManagedObjectContext cannot refresh objects in other contexts.
NSConcurrencyType
NSFetchTimestamp
NSRetainsRegisteredObjects
NSPropagatesDeleted
NSMergePolicy
An NSManagedObjectContext cannot detect conflicts for objects in other contexts.
Can only use -performBlock: on an NSManagedObjectContext that was created with a queue.
Can only use -performBlockAndWait: on an NSManagedObjectContext that was created with a queue.
Parent NSManagedObjectContext must not be nil.
Parent NSManagedObjectContext must use either NSPrivateQueueConcurrencyType or NSMainQueueConcurrencyType.
NSManagedObjectContext %p: 
NSManagedObjectContext %p
reasom
Cannot set a query generation on an NSManagedObjectContext that does not have a coordinator
Child contexts inherit parent context generations and may not have their own
Automatic merging is not supported by contexts using NSConfinementConcurrencyType
isEditing
T@"NSPersistentStoreCoordinator",&
parentContext
T@"NSManagedObjectContext",&
undoManager
T@"NSUndoManager",&,N
T@"NSMutableDictionary",R,N
concurrencyType
insertedObjects
T@"NSSet",R,N
updatedObjects
deletedObjects
registeredObjects
propagatesDeletesAtEndOfEvent
retainsRegisteredObjects
shouldDeleteInaccessibleFaults
stalenessInterval
mergePolicy
queryGenerationToken
T@"NSQueryGenerationToken",R,N
automaticallyMergesChangesFromParent
transactionAuthor
-performFetch:error: was called on a MOC of NSConfinementConcurrencyType unexpectedly.
cannot record object with null globalID
An NSManagedObject may only be in (or observed by) a single NSManagedObjectContext.
fatal: Failed to re-registered lost fault. fault %p with oid %@ has a moc of %p but we expected %p
deallocated NSManagedObjectContext
_NSManagedObjectContextPrivateDidMutateObjectIDsNotification
_NSManagedObjectContextObjectIDMutationMappingKey
Could not allocate memory.
Multiple threads illegally accessing an NSManagedObjectContext (%p) during %@
The current thread is not the recognized owner of this NSManagedObjectContext(%p).  Illegal access during %@
attempt to insert a null object into this context
repairing validation failure %@ (%@) by deleting %@ because it no longer exists and the merge policy allows it
null
NSValidationErrorShouldAttemptRecoveryKey
validation recovery attempt FAILED with %@ and %@.
An observer of NSManagedObjectContextDidSaveNotification illegally threw an exception.  Objects saved = %@ and exception = %@ with userInfo = %@ at %@
Objects should not be both modified and additional
Mutating a managed object %@ (%p) that has a different context %p than the receiver %p.
Failed to process pending changes before save.  The context is still dirty after 1000 attempts.  Typically this recursive dirtying is caused by a bad validation method, -willSave, or notification handler.
Serious application error.  Exception was caught during Core Data change processing.  This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification.  %@ with userInfo %@
Serious application error.  Unidentifiable exception was caught during Core Data change processing.  This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification.
SELF IN %@
Delete propagation prefetching failed with error: %@
Delete propagation prefetching failed with exception: %@
illegally invoked -performWithOptions* on dying NSManagedObjectContext at:
-performWithOptions:andBlock: was called on a MOC of NSConfinementConcurrencyType unexpectedly.
Mismatched PSCs in parameter contexts
Context has pending changes
Destination object is not kind of [relationship destinationEntity]
Relationship must be a to-many.
Can't find the order of objects in an unordered relationship
com.apple.CoreData.NSManagedObjectContext.mainQueue
Temporary object ID refers to object in different NSPersistentStoreCoordinator
Object's persistent store is not reachable from this NSManagedObjectContext's coordinator
Invalid state for objectID or NSManagedObjectContext
%p <%@>
T@"NSPersistentStore",R,W
temporaryID
TB,R,GisTemporaryID
_NSPredicateOperatorUtilities
+mergedModelFromBundles: Failed to load model at URL '%@'
Can't merge models with two different entities named '%@'
Can't merge models with two different fetch request templates for name'%@'
NSEntities
PF_DEFAULT_CONFIGURATION_NAME
NSConfigurations
NSFetchRequestTemplates
NSVersionIdentifiers
(%@) isEditable %u, entities %@, fetch request templates %@
Can't add an entity to a managed object model (missing name or bad properties).
Entities for a configuration must already be in the model.
Cannot set fetch request template.  This model does not contain entity '%@'.
entitiesByName
entities
configurations
T@"NSArray",R
localizationDictionary
T@"NSDictionary",&
fetchRequestTemplatesByName
versionIdentifiers
T@"NSSet",C
entityVersionHashesByName
VersionInfo.plist
Unable to model NSManagedObjectModel
Invalid property; can't optimize
Base error
Property
Invalid value in warnings array
momv2$8129374fj;a30[5yo-]0-87ujuhok'p0907ljnlmmji870-oi43902[349
Can't find hashorder for entity '%@'
Base Problem
Can't add unnamed entity to model.
Model already contains an entity named %@.
Unknown archive format
Corrupted archive: malformed header
Malformed archive: skipping
Corrupted archive: Mismatched entity count
Corrupted archive: failed to read property name
Corrupted archive: Mismatched string count
Corrupted archive: failed to read entity name or warning string
Corrupted archive: Mismatched data count
Corrupted archive: failed to read data
Corrupted archive: Mismatched strategy count
Corrupted archive: failed to read kkd strategy
NSKnownKeysDictionary2
Allocation failure: unable to allocate properties buffer
Allocation failure: unable to allocate attributes buffer
Allocation failure: unable to allocate derived attributes buffer
Allocation failure: unable to allocate relationships buffer
Allocation failure: unable to allocate expressions buffer
Allocation failure: unable to allocate fetched properties buffer
Allocation failure: unable to allocate fetch requests buffer
Allocation failure: unable to allocate entities buffer
Allocation failure: unable to allocate fetchIndexes buffer
Allocation failure: unable to create attributes
Allocation failure: unable to create derived attributes
Allocation failure: unable to create relationships
Allocation failure: unable to create expressions
Allocation failure: unable to create fetched properties
Allocation failure: unable to create fetch requests
Allocation failure: unable to create entities
Allocation failure: unable to create fetchIndexDescriptions
Allocation failure: unable to create fetchIndexElementDescriptions
Corrupt archive: mismatch between header and contents for attribute count
Corrupt archive: mismatch between header and contents for relationship count
Corrupt archive: mismatch between header and contents for expression count
Corrupt archive: mismatch between header and contents for fetched properties count
Corrupt archive: unable to read property at index: %lu
Corrupt archive: relationship with name (%@) has bad inverse index %@
Corrupt archive: mismatch between header and contents for entity count
Corrupt archive: unable to read entity at index: %lu
Bad: decoding optimized model smashed memory. Bailing.
Corrupt archive: mismatch between header and contents for fetch request count
Corrupt archive: unable to read fetch request at index: %lu
 Cannot load NSManagedObjectModel.  nil is an illegal URL parameter
CoreData: Cannot load NSManagedObjectModel.  nil is an illegal URL parameter
 Failed to load model bundle at path '%@'
 Failed to load model as no file exists at path '%@'
 Failed to load optimized model at path '%@'
root
 Failed to load keyed archive model at path '%@' with error '%@'
 Failed to load NSManagedObjectModel with URL '%@'
com.apple.CoreData.OptimizedModelLayoutDebug
Mismatch: strategy has %lu length, archive has %u values
Mismatch: frt strategy has %d length, archive has %u values
Mismatch: frt strategy has %lu length, archive has %u values
Unable to decode versionIdentifiers for model: %@
Corrupted archive (missing pointer space).
System
Library
Cannot use uniqueness constraints { %@ } on entity '%@' due to relationship '%@' having a mandatory to-one inverse relationship '%@' and not using a cascade delete rule on '%@'
v24@?0@"NSEntityDescription"8@"NSString"16
Models cannot become mutable after being marked immutable.
Can't modify an immutable model.
Can't remove entity - doesn't belong to this model.
Cannot assign a negative reference ID offset to a managed object model.
_modelsReferenceIDOffset
Tq,N,S_setModelsReferenceIDOffset:
<NSXPCStoreServerConnectionInfo: 
entitlements = %@ ;
coordinator = %@ ;
userInfo = %@>
<NSXPCStoreServerConnectionContext: 
entitlements = %@ ;
context = %@ ;
info = %@>
core data xpc: query generations
coordinator
T@"NSPersistentStoreCoordinator",R,N,V_coordinator
NSManagedObjectModel_CurrentVersionName
NSManagedObjectModel_VersionHashes
VersionInfo
plist
Info
Exception while loading versioned model plist for %@.
Name: %@
Reason: %@
UserInfo: %@
NSMappedObjectStore must be initialized with initWithPersistentStoreCoordinator:configurationName:URL:options:
Core Data provided atomic stores do not support file backed futures
Core Data provided atomic stores do not support derived properties
file:/
com.apple.CoreData.MigrationDebug
(migration) checking mapping model %@
 source hashes: 
 destination hashes: %@
(migration) mismatched %@%@%@ hashes for mapping model %@
 and 
(migration) no match found for %d of %d mapping model source hashes
(migration) no match found for %d of %d mapping model destination hashes
(migration) found compatible mapping model %@
Cannot create an inferred NSMappingModel with a nil source model
Cannot create an inferred NSMappingModel with a nil destination model
(migration) inferring a mapping model between data models with 
 source hashes: 
 destination hashes: %@
(migration) inferring mapping model failed with error: %@ userInfo: %@
(%@), entityMappings %@
entityMappings
entityMappingsByName
(migration) looking for mapping model with 
 source hashes: 
 destination hashes: %@
(migration) no suitable mapping model found
NSEntityMappings
NSEntityMappingsByName
Can't add unnamed entity mapping to model.
Model already contains an entity mapping named %@.
Mapping Models cannot become mutable after being marked immutable.
Can't modify an immutable mapping model.
Can't generate new column values for %@ - incompatible destination: %@
Can't generate new column value from destination: %@
 = %@
, %@ = %u
Can't generate new column values for destination - incompatible entity foreign key state: %@
%@ = %@
, %@ = %@
Can't generate new column value from value: %@
= %@
aliasGenerator
Can't generate SQL for keypath %@ : invalid location of keypath aggregate function
Can't generate SQL for keypath %@ : invalid keypath
Can't generate SQL for keypath %@ : invalid attribute name location
Can't generate SQL for keypath %@ : multiple to many keypath components
Can't generate SQL for keypath %@ : unexpected problem
Unable to generate sql for components %@
Invalid keypath for update (not an attribute or a to one) %@
Attempting to insert a relationship value into an attribute or vice versa is not supported %@/%@
Invalid keypath expression (%@) in propertiesToUpdate - joins unsupported here
Unable to generate sql for update expression %@
Can't find property %@ on entity %@
Invalid property for update (not an attribute or a to one) %@/%@
Invalid property for update (can't batch update derived attributes) %@/%@
Fetch request expression evaluation (%@) failed
Invalid fetch expression (%@) in propertiesToUpdate - fetch has multiple results
Invalid new constant value %@ for %@ (not a managed object)
Invalid value expression (%@) in propertiesToUpdate : what does it mean to update a relationship to the result of a function?
Invalid expression (%@) in propertiesToUpdate
Can't generate new column value from expression %@
, Z_OPT = (Z_OPT + 1) 
serviceName
agentOrDaemon
NSXPCStoreServerEndpointFactory
NSXPCStoreListenerEndpoint
 Unable to create NSXPCConnection; no service name, factory, or endpoint provided.
 Unable to create NSXPCConnection
 Connection interrupted.
XPC connection was invalidated
 Connection invalidated.
PSCKey
Connection is nil
XPC: synchronousRemoteObjectProxyWithErrorHandler encountered error: %@
v16@?0@"NSError"8
reply
Created reply dict: %@
Threw obc exception handling request %@
XPCStore sendMessage: Unhandled exception handling request.  %@
Threw unknown exception handling request
XPCStore sendMessage: Unhandled unknown exception handling request
v24@?0@"NSCoreDataXPCMessage"8@"NSData"16
Returning reply dict %@
Failed send (no reply dict).
x-coredata://%@/%@/p%@
createRecordID called before the record has the necessary properties: %@
Cannot create objectID: called before the record has the necessary properties: %@
Cannot create objectID. Unable to find entity with id '%@' in store '%@'
Found more than one instance of NSCKRecordMetadata for object: %s
Somehow got a temporary objectID for export: %s
entityId = %@ and entityPK in %@
Exporter got record metadata back but doesn't have a corresponding objectID: %s
ckRecordName = %@ and recordZone.ckRecordZoneName = %@ and recordZone.ckOwnerName = %@
Found more than one instance of NSCKRecordMetadata for record: %s
Invalid query for record metadata (by recordIDs): %@ returned no metadata or record names
recordZone = %@ AND ckRecordName in %@
%@_%@
Failed to get a metadata zone while creating metadata for object: %@
+[NSCKRecordMetadata insertMetadataForObject:inZone:recordNamePrefix:error:]
entityPath
ckRecordName
ckRecordSystemFields
T@"NSData",&,D,N
entityId
T@"NSNumber",&,D,N
entityPK
ckShare
T@"NSCKRecordZoneMetadata",&,D,N
NSCloudKitMirroringDelegateInitializedZoneDefaultsKey
NSCloudKitMirroringDelegateInitializedZoneSubscriptionDefaultsKey
NSCloudKitMirroringDelegateCKIdentityRecordNameDefaultsKey
NSCloudKitMirroringDelegateCheckedCKIdentityDefaultsKey
NSCloudKitMirroringDelegateInitializedDatabaseSubscriptionKey
<%@: %p; %@
loaded
not-loaded
,changed:%d
,initZone:%d
,initZoneSub:%d
,initDatabaseSub:%d
,identity:%@
,checkedIdentity:%d
,changeTokens:
,%@:%@
v32@?0@"NSString"8@"CKServerChangeToken"16^B24
empty
historyToken:%@
<%@: %@>
Has Changes:%d
Has Initialized Zone: %d
Has Initialized Zone Subscription: %d
Has Initialized Database Subscription: %d
CK Identity Record Name: %@
Has Checked CK Identity: %d
Server Change Tokens:
%@:%@
 empty
Last Exported History Token: %@
%@:%@ called before load.
Failed to deserialize '%@' out of the metadata for store: %@
Failed to serialize '%@' from '%@' for store: %@
.%@.%@
public
shared
private
Unknown database scope: %lu
T@"NSPersistentStore",R,W,N,V_store
keyToPreviousServerChangeToken
T@"NSDictionary",R,N,V_keyToPreviousServerChangeToken
TB,R,N,V_loaded
TB,R,N,V_hasChanges
hasInitializedZone
hasInitializedZoneSubscription
hasInitializedDatabaseSubscription
ckIdentityRecordName
T@"NSString",&,N,SsetCKIdentityRecordName:
hasCheckedCKIdentity
lastHistoryToken
T@"NSPersistentHistoryToken",&,N
_NSInMemoryStoreArchivedData
memory://%lx
T@"PFCloudKitImporterOptions",R,N,V_options
T@"NSCloudKitMirroringImportRequest",R,N,V_request
@count
conflictList
object snapshot
cached row
database row
%@ (%p) for NSManagedObject (%p) with objectID '%@' with oldVersion = %d and newVersion = %d and old %@ = %@ and new %@ = %@
%@ (%p) for NSManagedObject (%p) with objectID '%@' with oldVersion = %d and newVersion = <deleted> and old %@ = %@
Coder = %@ (%@)
Delegate = %@ (%@)
This is probably not where you want to be
_source
_snapshot1
_snapshot2
_snapshot3
_oldVersion
_newVersion
snapshot
cachedRow
databaseRow
newVersion
oldVersion
sourceObject
T@"NSManagedObject",R,&,V_source
objectSnapshot
T@"NSDictionary",R,&,V_snapshot1
cachedSnapshot
T@"NSDictionary",R,&,V_snapshot2
persistedSnapshot
T@"NSDictionary",R,&,V_snapshot3
newVersionNumber
TQ,R,V_newVersion
oldVersionNumber
TQ,R,V_oldVersion
_constraint
_conflictedValues
_databaseObject
_databaseSnapshot
_conflictingObjects
%@ (%p) for constraint %@: database: %@, conflictedObjects: %@
constraint
T@"NSArray",R,C,V_constraint
constraintValues
T@"NSDictionary",R,C,V_conflictedValues
databaseObject
T@"NSManagedObject",R,&,V_databaseObject
databaseSnapshot
T@"NSDictionary",R,&,V_databaseSnapshot
conflictingObjects
T@"NSArray",R,C,V_conflictingObjects
conflictingSnapshots
T@"NSArray",R,C,V_conflictingSnapshots
NSTypeCode
Got non-object value back for property '%@' which returned an objectID from the snapshot.
Can't merge conflict : missing context
Can't merge conflict : conflicting objects have different entities.
Can't merge conflict : resolution stage failed
That was unexpected. Error trying to get %@ from %@ (%@)
B24@?0@"NSMergeConflict"8@"NSDictionary"16
errorMergePolicy
T@"NSMergePolicy",R
rollbackMergePolicy
overwriteMergePolicy
mergeByPropertyObjectTrumpMergePolicy
mergeByPropertyStoreTrumpMergePolicy
mergeType
%@:%@
_ubiquityRootLocation: %@
transactions: %ld
size: %ld:%ld
reqs: %Lf:%ld
kv: %@:%@
%s(%d): CoreData: Ubiquity:  Tried to stat missing file: %@
-[PFUbiquityBaselineHeuristics bytesForFileAtPath:]
%s(%d): CoreData: Ubiquity:  Error getting the size of a file (%d): %@
%s(%d): CoreData: Ubiquity:  %@
This is confusing, baseline > current for peer: %@(%lu:%lu)
-[PFUbiquityBaselineHeuristics haveEnoughTransactionsToRoll]
%s(%d): CoreData: Ubiquity:  %@
This is confusing, baseline has a transaction for %@(%@) but the current kv doesn't: %@
%s(%d): CoreData: Ubiquity:  Asked to roll baseline, enough disk space has been consumed by logs.
-[PFUbiquityBaselineHeuristics logsConsumeEnoughDiskSpace]
%s(%d): CoreData: Ubiquity:  Asked to roll baseline but not enough space has been consumed yet by the transaction logs.
Store Bytes: %@
Log Bytes: %@
%s(%d): CoreData: Ubiquity:  Enough transactions have passed to roll baseline: %@
-[PFUbiquityBaselineHeuristics canRollBaseline:]
%s(%d): CoreData: Ubiquity:  Asked if rolling the baseline is possible, but the root location does not appear to exist: %@
localPeerID
T@"NSString",R,N,V_localPeerID
storeName
T@"NSString",R,N,V_storeName
ubiquityRootLocation
T@"PFUbiquityLocation",R,N,V_ubiquityRootLocation
modelVersionHash
T@"NSString",R,N,V_modelVersionHash
numRequiredTransactions
Tq,N,V_numRequiredTransactions
storeSize
Tq,R,N,V_storeSize
logSize
Tq,R,N,V_logSize
logToStoreSizeRatio
TD,N,V_logToStoreSizeRatio
minLogBytes
Tq,N,V_minLogBytes
currentBaselineKV
T@"PFUbiquityKnowledgeVector",&,N,V_currentBaselineKV
currentKV
T@"PFUbiquityKnowledgeVector",&,N,V_currentKV
currentEntityMapping
currentPropertyMapping
migrationProgress
T@"NSEntityMapping",&
T@"NSPropertyMapping",&
currentMigrationStep
Cannot create an NSMigrationManager with a nil source model
Cannot create an NSMigrationManager with a nil destination model
CoreData: Schema migration (manager)
Manager requires an entity mapping for associations
Can't find mapping for name (%@).
(migration) got more destinations for source than we expected. (%@, %@, %@)
Property mapping %@.%@ missing required relationship name argument to destinationInstancesForSourceRelationshipNamed:sourceInstances:
Can't find relationship for name (%@) for entity (%@) in source model.
more
fewer
(migration) got %@ destinations[%lu] for sources[%lu] than we expected. (%@, %@)
(migration) got more sources for destination than we expected. (%@, %@, %@)
usesStoreSpecificMigrationManager
mappingModel
T@"NSMappingModel",R
T@"NSManagedObjectContext",R
destinationContext
T@"NSEntityMapping",R
Tf,R
Can't find entity named %@ in source model
Mismatch between mapping and source/destination models
Can't add source store
journal_mode
journal_mode]
Can't add destination store
Failed to save new store after first pass of migration.
Failed to save new store after second pass of migration.
Failed to save new store.
%@ (URL: %@)
T@"NSPersistentStoreCoordinator",R,W,N
configurationName
T@"NSDictionary",R
T@"NSURL",&
coreSpotlightExporter
T@"NSCoreDataCoreSpotlightDelegate",R,N
Store does not support encryption
Unable to unload store file because file at path '%@' could not be removed
File appeared during sanity check; this seems suspicious
Failed to create file; code = %d
Component of path %@ is not a directory
Failed to access file: %d
Error opening store: %@
Could not write to file.
Store does not support this method
NSStoreType
NSStoreUUID
NSStoreModelVersionHashes
NSStoreModelVersionIdentifiers
added
removed
changedUUID
NSPersistentStoreCoordinatorStoresWillChangeNotification
NSPersistentStoreCoordinatorStoresDidChangeNotification
_NSPersistentStoreCoordinatorStoresDidChangePrivateNotification
NSPersistentStoreCoordinatorWillRemoveStoreNotification
NSPersistentStoreCoordinatorDidAutomigrateStoreNotification
_NSPersistentStoreCoorindatorPrivateWillRemoveStoreNotification
NSPersistentStoreTypeKey
SQLite
Binary
InMemory
NSXPCStore
NSReadOnlyPersistentStoreOption
NSSQLitePragmasOption
NSSQLitePersistWALOption
NSIgnorePersistentStoreVersioningOption
NSMigratePersistentStoresAutomaticallyOption
NSInferMappingModelAutomaticallyOption
NSPersistentStoreTimeoutOption
NSPersistentStoreOSCompatibility
NSPersistentStoreConnectionPoolMaxSize
NSPersistentStoreUnlinkDestroyOption
NSPersistentStoreForceDestroyOption
NSPersistentStoreUbiquitousContentNameKey
NSPersistentStoreUbiquitousContentURLKey
NSPersistentStoreUbiquitousPeerTokenOption
NSUbiquityIdentityTokenOverrideKey
NSPersistentStoreUbiquitousTransitionTypeKey
NSUbiquityImporterPrivateStoreKey
NSPersistentStoreUbiquitousContainerIdentifierKey
NSPersistentStoreRebuildFromUbiquitousContentOption
NSPersistentStoreUbiquitousSeedStoreURLKey
NSUbiquityOptionsRemovedDuringAutomaticMigrationKey
NSPersistentStoreFileProtectionKey
NSPersistentStoreRemoveUbiquitousMetadataOption
NSPersistentStoreForceLightweightMigrationOption
NSCoreDataCoreSpotlightExporter
NSExternalRecordsDirectoryOption
NSExternalRecordExtensionOption
NSSQLiteAnalyzeOption
NSSQLiteManualVacuumOption
_NSSQLitePageSizeStoreOption
_NSNotifyObserversOfStoreChange
NSStoreModelVersionHashesVersion
NSPersistenceFrameworkVersion
NSStoreLastReferecedObjectKey
NSPersistentStoreOrderKeyUpdateNotification
NSPersistentHistoryTrackingKey
NSPersistentHistoryTombstoneAttributes
NSPersistentHistoryTrackingEntitiesToInclude
NSPersistentHistoryTrackingEntitiesToExclude
NSPersistentHistoryUseContextObjectsForDeletes
_NSBinaryStoreInsecureDecodingCompatibilityOption
NSBinaryStoreSecureDecodingClasses
NSPersistentStoreRemoteChangeNotificationOptionKey
NSPersistentStoreRemoteChangeNotification
com.apple.coredata.NSPersistentStoreRemoteChangeNotification.remotenotification
NSPersistentStoreCoordinatorResourceBundlesForMigration
storeURL
NSPersistentStoreServiceConfigurationOptionKey
Can only use -performBlock: on an NSPersistentStoreCoordinator that was created with a queue.
Can only use -performBlockAndWait: on an NSPersistentStoreCoordinator that was created with a queue.
 API Misuse: Attempt to serialize store access on non-owning coordinator (PSC = %p, store PSC = %p)
NSPersistentStoreCoordinator %p: 
NSPersistentStoreCoordinator %p
Cannot register a store class using a 'nil' type.
Store type '%@' is reserved for Core Data, and cannot be re-registered.
Invalid store URL: nil
This is not the API you're looking for.
This is not the API you're looking for
Can't create store
Unknown
Cannot set metadata in read-only store.
v16@?0@"NSPersistentStore"8
An NSPersistentStore illegally threw an exception from -willRemoveFromPersistentStoreCoordinator:
client failed to call designated initializer on NSPersistentStoreCoordinator
Cannot create an NSPersistentStoreCoordinator with a nil model
%@: Attempting recovery from error encountered during addPersistentStore: %@
Use of the mirroring options requires that a mirroring delegate also be provided. The following options were set, but a mirroring delegate was not found at '%@':
Unhandled exception in developer completion handler for addPersistentStoreWithDescription %@
Unhandled unknown exception in developer completion handler for addPersistentStoreWithDescription
NSPersistentStoreMirroringDelegateOptionKey
%@ is only valid as a mirroring option. It should be set using '%@' on '%@'
Store options for external records must specify both the external records directory and the extension to be used
_UNITTESTING_IGNORE_EXTERNAL_RECORDS_PATH
/CoreData/
/Metadata/CoreData/
External records directory must live under ~/Library/CoreData/ or ~/Library/Caches/Metadata/CoreData/
CoreData: Adding persistent store
unknown or nil storeType argument or otherwise unable to infer storeType argument.  Inference requires an existing file with valid metadata.
Unsupported store type.
Default
Unable to initialize store.
Caught exception trying to load store metadata during error recovery: %@
Can't read store metadata.
The store type in the metadata does not match the specified store type.
The version hash version (and associated hashes) are incompatible with the current Core Data version.
 NOT 
Incompatible version schema for persistent store '%@'.  store metadata = %@ and current model versions = %@
(migration)
 will%@attempt automatic schema migration
CoreData: error: (migration) migration failed with error %@
Error User Info: %@
Underlying error: %@
(migration)
 Automatic schema migration succeeded for store at '%@'
The model used to open the store is incompatible with the one used to create the store
%s(%d): CoreData: Ubiquity:  Post store setup succeded. %@
-[NSPersistentStoreCoordinator addPersistentStoreWithType:configuration:URL:options:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  An error occurred while setting up the ubiquity integration: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error: A persistent store which has been previously added to a coordinator using the iCloud integration options must always be added to the coordinator with the options present in the options dictionary. If you wish to use the store without iCloud, migrate the data from the iCloud store file to a new store file in local storage. %@
This will be a fatal error in a future release.
-addPersistentStoreWithType:%@ configuration:%@ URL:%@ options:%@ ... returned error %@ with userInfo dictionary %@
NSPersistentStoreCoordinator's current model hashes are %@
store is nil or not registered with this coordinator
nil is not a valid store.
nil is not a valid persistent store
nil is not a valid persistent store URL
The specified URI is not a valid Core Data URI: %@
(unknown)
(schema mismatch or migration failure)
(corrupt file)
(device locked)
(can't open)
(permission denied)
(I/O error)
(disk full)
This NSPersistentStoreCoordinator has no persistent stores %@.  It cannot perform a save operation.
Illegal attempt to save to a file that was never opened.  "%@".  Last recorded error = %@ / %@
Illegal attempt to save to a file that was never opened. "%@". No last error recorded.
Q8@?0
Store - %@ not found in token - %@
Unable to write to file opened Read Only.
File is in Read Only mode due to Persistent History being detected but NSPersistentHistoryTrackingKey was not included.
NSPersistentStoreOptions
optimistic locking failure
Save partially failed: %@
NSPersistentHistoryResultTypeChangesOnly unsupported for multiple stores
NSPersistentStoreRequest
NSPersistentStore
Store returned nil but no error.
NSPersistentStores
Operation unsupported by all stores on this coordinator.
Underlying errors
One or more stores returned an error.
Coordinator failed to create a new query generation post save
v16@?0@"NSArray"8
Must pass in a store name
%s(%d): CoreData: Ubiquity:  Couldn't delete store file: %@
Will still try to nuke the container.
+[NSPersistentStoreCoordinator removeUbiquitousContentAndPersistentStoreAtURL:options:error:]
OldUbiquitousContent-%@
%s(%d): CoreData: Ubiquity:  Unable to move content directory to new location: %@
New: %@
+[NSPersistentStoreCoordinator removeUbiquitousContentAndPersistentStoreAtURL:options:error:]_block_invoke
v24@?0@"NSURL"8@"NSURL"16
%s(%d): CoreData: Ubiquity:  The coordinated write to remove the ubiquitous contents failed: %@
registeredStoreTypes
persistentStores
com.apple.CoreData.PowerAssertionsDebug
UIApplication
beginBackgroundTaskWithName:expirationHandler:
Registration for _beginPowerAssertionNamed completed with class %p on app %p and result %@
sucess
failure
Unexpected background task assertion cancellation.
Failed to acquire background task assertion for task '%@'.
Successfully acquired background task assertion %d for task '%@'.
Ended background task assertion %d.
URI is not a valid Core Data URI
Can't add the same store twice
Store is not valid for this context's generation
context
NSManagedObjectContext is nil for objects passed to obtainPermanentIDsForObjects
Can't resolve how to assign objects to stores; Coordinator does not have any stores
Can't resolve how to assign objects to stores; some objects may have been assigned to stores; use [[managedObject objectID] persistentStore] to find out what is going where now; use [managedObjectContext assignObject:toStore:] to straighten things out
problemObject
Cannot insert objects into a read only store.
Cannot update objects into a read only store.
Cannot update object that was never inserted.
Cannot delete objects into a read only store.
Cannot delete object that was never inserted.
Cannot lock object that was never inserted.
Can't find store type for store %@ (class == %@) in %@.
Cannot change an NSPersistentStoreCoordiantor's QoS after use
Fetch instances of entity %@ from store %@ failed, reason: %@
Referential integrity problem found during migratePersistentStore:toURL:options:withType:error: %@
Save failed during during migratePersistentStore:toURL:options:withType:error:, object added to store during fetch.
Save failed during migratePersistentStore:toURL:options:withType:error:, %d objects in store were removed during fetch.
Save failed.
%s(%d): CoreData: Ubiquity:  Threw while trying to create the actual store url.
token: %@
ubiquityName: %@
+[NSPersistentStoreCoordinator(_NSInternalMethods) ubiquityStoreURLForStoreURL:ubiquityIdentityToken:localPeerID:ubiquityName:]
modelMap
T@"_PFModelMap",R,N
Invalid destination store URL: nil
Invalid source store URL: nil
source and destination store are different classes of store: %@ != %@
Store currentQueryGeneration returned nil unexpectedly
Invalid generation token: this persistent store coordinator does not have any of the referenced stores
Provided persistent store must be of type NSSQLiteStoreType: %@
Provided persistent store must be from this coordinator: %@
Invalid store URL
%@ - One or more unknown attributes: %@
%@ - `@""` is not a valid value.
%@ - Wrong type: %@ but should be %@
The following entities did not have a valid configuration for %@. It should be a string of comma separated attribute names to tombstone on delete.
%@ expects an instance of %@ as its value but found: %@
Exception was caught during NSPersistentStoreCoordinator -performBlock: %@ with userInfo %@
Unidentifiable exception was caught during NSPersistentStoreCoordinator -performBlock.
Exception thrown during autorelease pool drain.
Move
Update
Delete
Insert
Unset
<%@: %p> { object: %p, type: %@%@%@ }
, startIndex: %@
, finalIndex: %@
T@"NSManagedObject",R,&,N,V_object
changeType
TQ,N,V_changeType
startIndexPath
T@"NSIndexPath",&,N,V_startIndexPath
finalIndexPath
T@"NSIndexPath",&,N,V_finalIndexPath
startSectionInfo
T@"_NSDefaultSectionInfo",&,N,V_startSectionInfo
finalSectionInfo
T@"_NSDefaultSectionInfo",&,N,V_finalSectionInfo
NSIsOptional
NSIsReadOnly
NSIsTransient
NSIndexedBySpotlight
NSIsStoredInTruth
NSIsOrdered
NSPropertyName
NSValidationPredicates
NSValidationWarnings
(%@), name %@, isOptional %d, isTransient %d, entity %@, renamingIdentifier %@, validation predicates %@, warnings %@, versionHashModifier %@
 userInfo %@
Can't change name of property from %@ to %@
Mismatch between length of validation predicates and warnings
T@"NSString",C,N
optional
TB,GisOptional
transient
TB,GisTransient
validationPredicates
validationWarnings
indexed
TB,GisIndexed
indexedBySpotlight
TB,GisIndexedBySpotlight
storedInExternalRecord
TB,GisStoredInExternalRecord
Can't read property into shell: Not enough bytes left
Can't read property into shell: Unknown type
Can't read property into shell: Missing version hash value
Corrupted archive (missing property name).
Can't read property into shell: Can't read validation predicates
Unable to decode validation predicate for property %@ : %@
Can't read property into shell: Can't read validation warnings
Unable to decode validation warning for property %@ : %@
Unable to decode userInfo for property %@ : %@
<NSBatchUpdateRequest : entity = %@, properties = %@, subentities = %d, predicate = %@
This batch update request (%p) was created with a string name (%@), and cannot respond to -entity until used by an NSManagedObjectContext
Invalid string keypath %@ passed to propertiesToUpdate:
Invalid string key %@ passed to propertiesToUpdate:
Attribute/relationship description names passed to propertiesToUpdate must match name on fetch entity (%@)
Invalid property %@ passed as key to propertiesToUpdate:
Invalid expressionDescription %@ passed as key to propertiesToUpdate:
Invalid relationship (%@) passed to propertiesToUpdate:
Can't find entity for batch update (%@)
shouldPerformSecureOperation
TB,N,G_secureOperation,S_setSecureOperation:
T@"NSEntityDescription",R,V_entity
T@"NSPredicate",&,V_predicate
propertiesToUpdate
T@"NSDictionary",C,V_columnsToUpdate
Mismatched result types during aggregation of batch update results
Results
T@,R,V_aggregatedResult
TQ,R,V_resultType
NSPropertyTransformMandatoryPropertyValidation
(%@), name %@, valueExpression %@, userInfo %@
valueExpression
NSDestinationPropertyName
NSValueExpression
NSPropertyTransforms
Property Mappings cannot become mutable after being marked immutable.
Can't modify an immutable property mapping.
Z_RT_%@_%@
latitude
longitude
'%@' is not a valid description for a location index, it should include two comma separated components or be an array of two string identifying the attributes which make up the location index.
%@.%@ has an invalid description for a location index. It must be either an array or a comma separated string of two components identifying the latitude / longitude properties to use.
Unable to configure location index: %@.%@ type is %@ but should be %@.
RTree tables can only be created to back transient attributes. %@.%@ is not transient.
Unable to configure location index: couldn't find an attribute named '%@' on '%@'
Unable to configure location index (invalid %@ on %@.%@): 
Unable to configure location index (invalid %@ on %@.%@): %@.%@ is of type %@ and should be of type %@.
%@.%@ is a transient attribute.
%@.%@ is a relationship.
couldn't find an attribute named '%@' on '%@' to use as the %@.
CREATE VIRTUAL TABLE IF NOT EXISTS %@ USING RTREE (Z_PK INTEGER PRIMARY KEY, %@_MIN FLOAT, %@_MAX FLOAT, %@_MIN FLOAT, %@_MAX FLOAT)
DROP TABLE IF EXISTS %@
CREATE TRIGGER IF NOT EXISTS %@_INSERT AFTER INSERT ON %@ FOR EACH ROW BEGIN INSERT OR REPLACE INTO %@ (Z_PK, %@_MIN, %@_MAX, %@_MIN, %@_MAX) VALUES (NEW.Z_PK, NEW.%@ ,NEW.%@, NEW.%@, NEW.%@) ; END
CREATE TRIGGER IF NOT EXISTS %@_UPDATE AFTER UPDATE ON %@ FOR EACH ROW BEGIN DELETE FROM %@ WHERE Z_PK = NEW.Z_PK ; INSERT INTO %@ (Z_PK, %@_MIN, %@_MAX, %@_MIN, %@_MAX) VALUES (NEW.Z_PK, NEW.%@ ,NEW.%@, NEW.%@, NEW.%@) ; END
CREATE TRIGGER IF NOT EXISTS %@_DELETE AFTER DELETE ON %@ FOR EACH ROW BEGIN DELETE FROM %@ WHERE Z_PK = OLD.Z_PK ; END
INSERT OR REPLACE INTO %@ (Z_PK, %@_MIN, %@_MAX, %@_MIN, %@_MAX) SELECT Z_PK, %@, %@, %@, %@ from %@ where %@ NOT NULL and %@ NOT NULL
userInfoObject
T@"NSObject",R,N,V_userInfoObject
components
T@"NSArray",R,N,V_components
attributeDescription
T@"NSAttributeDescription",R,N,V_attributeDescription
sqlEntity
T@"NSSQLEntity",R,N,V_sqlEntity
rtreeTableName
T@"NSString",R,N,V_rtreeTableName
latProp
T@"NSAttributeDescription",R,N,V_latProp
longProp
T@"NSAttributeDescription",R,N,V_longProp
NSPrerequisiteTransform
NSReplaceMissingValueOnly
(%@), propertyName %@, valueExpression %@, prerequisiteTransform %@, replaceMissingValueOnly %@
propertyName
T@"NSString",&,N,V_propertyName
T@"NSExpression",&,N,V_valueExpression
prerequisiteTransform
T@"NSPropertyTransform",&,N,V_prerequisiteTransform
replaceMissingValueOnly
TB,V_replaceMissingValueOnly
Validating options: %@
storeOptions: %@
-[PFCloudKitOptionsValidator validateOptions:andStoreOptions:error:]
NSCloudKitMirroringDelegateOptions.containerIdentifier requires a value with a length greather than 0
NSCloudKitMirroringDelegateOptions.containerIdentifier only accepts values of type '%@'. The following is not a valid value:
A container identifier is required for the CloudKit integration.
%@ is required for the CloudKit integration.
NSCloudKitMirroringDelegateOptions.containerOptions only accepts values of type '%@'. The following is not a valid value:
The value for 'NSCloudKitMirroringDelegateOptions.ckAssetThresholdBytes' must be at least %@ bytes. The following value is invalid: %@
The value for 'NSCloudKitMirroringDelegateOptions.ckAssetThresholdBytes' must be an instance of '%@'. The following value is invalid: %@
The value for 'NSCloudKitMirroringDelegateOptions.operationMemoryThresholdBytes', %@, must be larger than the value of 'NSCloudKitMirroringDelegateOptions.ckAssetThresholdBytes', %@.
The value for 'NSCloudKitMirroringDelegateOptions.operationMemoryThresholdBytes' must be at least %@ bytes. The following value is invalid: %@
The value for 'NSCloudKitMirroringDelegateOptions.operationMemoryThresholdBytes' must be an instance of '%@'. The following value is invalid: %@
parsedOptions
T@"NSCloudKitMirroringDelegateOptions",R,N,V_parsedOptions
NSMaxCount
NSMinCount
NSDeleteRule
NSDestinationEntity
_NSDestinationEntityName
NSInverseRelationship
_NSInverseRelationshipName
%@, destination entity %@, inverseRelationship %@, minCount %lu, maxCount %lu, isOrdered %d, deleteRule %lu
T@"NSEntityDescription",N
inverseRelationship
T@"NSRelationshipDescription",N
maxCount
minCount
deleteRule
toMany
TB,R,GisToMany
ordered
TB,GisOrdered
repairing missing delete propagation for to-one relationship %@ on object %p (%@) with bad fault %p (%@)
Dangling reference to an invalid object.
Illegal container for relationship: value = %@; relationship = "%@".
repairing missing delete propagation for to-many relationship %@ on object %p (%@) with bad fault %p (%@)
"%@" INTEGER
FOREIGN KEY ("%@") REFERENCES "%@" ("%@")
%@ { inserts (%@), updates (%@), deletes (%@) locks (%@) }
T@"NSSet",R
lockedObjects
n%u_t%cu
__n%u_var%cu
__var%u
_Z_intarray%u
 - %d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%ld
%s(%d): CoreData: Ubiquity:  Tried to stat a file but part of the directory structure has gone missing: %@
-[PFUbiquityLocationStatus checkFileURLState]
%s(%d): CoreData: Ubiquity:  Error trying to read file (%d): %@
%s(%d): CoreData: Ubiquity:  Error reading resource values for URL: %@
isLive
TB,R,N,V_isLive
isDeleted
TB,R,N,V_isDeleted
isDownloaded
TB,R,N,V_isDownloaded
isDownloading
TB,N,V_isDownloading
isUploaded
TB,R,N,V_isUploaded
isUploading
TB,R,N,V_isUploading
isScheduled
TB,R,N,V_isScheduled
isImported
TB,R,N,V_isImported
isExported
TB,R,N,V_isExported
isFailed
TB,R,N,V_isFailed
numBytes
Tq,R,N,V_numBytes
T@"NSError",R,N,V_error
location
T@"PFUbiquityLocation",R,N,V_location
numNotifications
Tq,R,N,V_numNotifications
NSSQLAttributeTriggerAssociationKey
triggerKeys
<NSBatchInsertRequest : entity = %@ resultType = %@ and %@>
%lu objects
block provided
Status Only
Count
Object IDs
'%ld' is an unknown NSBatchInsertResultType value
NSBatchInsertResultTypeStatusOnly
NSBatchInsertResultTypeCount
NSBatchInsertResultTypeObjectIDs
This batch insert request (%p) was created with a string name (%@), and cannot respond to -entity until used by an NSManagedObjectContext
Can't find entity for batch insert (%@)
objectsToInsert
T@"NSArray",C,V_objectsToInsert
insertDictionaryBlock
T@?,C,V_insertDictionaryBlock
insertManagedObjectBlock
T@?,C,V_insertManagedObjectBlock
Mismatched result types during aggregation of batch insert results
com.apple.coredatad.cloudkit.
CDDCloudKitServer
cdck.sqlite
Failed to load persistent stores for CloudKit integration: %@
Failed to initialize storage:
Failed to create directory for persistent storage: %@
Called to accept connection for unknown listener: %@
Unknown message: %@
The server is not initialized due to: %@
The server was unable to process the request because it timed out waiting for initialization.
Bug in CoreData CloudKit Server: Response success == NO but error is also nil.
CloudKit Server is attempting to send back a nil response: %@
bundleIdentifier = %@ AND storeConfigurationName = %@ AND storePath = %@
Failed to register store for message '%@' due to the following error: %@
Provided file handle is invalid, the file is not writable.
%@: Asked to schedule activity for store: %@
-[CDDCloudKitServer _handleScheduleMessage:]
storePath = %@
Multiple clients registered for the same store path: %@
Found unknown activity type: %@
Scheduling activity: %@ for client: %@ with scheduler: %@
-[CDDCloudKitServer _handleScheduleMessage:]_block_invoke
Asked to run activity but no server: %@
v24@?0@"CKSchedulerActivity"8@?<v@?q>16
Already have scheduled activity for client: %@
Saving changes for client: %@
Failed to save changes: %@
No change to save for client: %@
Failed to get a container for '%@
No client is registered for: %@
Asked to run activity: %@
-[CDDCloudKitServer runActivity:completionHandler:]
activityUUID = %@
Looking up activities matching the identifier: %@
-[CDDCloudKitServer runActivity:completionHandler:]_block_invoke
Found more than one scheduled activities matching the identifier '%@': %@
Running scheduled activity: %@
Client: %@
v16@?0@"NSNotification"8
Store initialized waiting for the mirroring delegate to set up.
Mirroring delegate initialized.
Backup export failed: %@
-[CDDCloudKitServer runActivity:completionHandler:]_block_invoke_3
v16@?0@"NSCloudKitMirroringResult"8
Failed to execute export request: %@
Timed out waiting for the mirroring delegate to set up.
Failed to load persistent store for client: %@
Failed to load managed object model for registered client: %@
No activity registered with identifier: %@
Failed to handle activity because initialization took longer than expected: %@
Successfully finished activity, pruning: %@
-[CDDCloudKitServer finishedActivity:withResult:inManagedObjectContext:]_block_invoke
Failed to prune activity after successful execution: %@
Execution of activity failed: %@
Provided file handle is invalid, it doesn't point to the requested store.
Failed to fstat file descriptor (%d:%d): %d
Failed to stat file at url (%d:%d): %@
Failed to get a real path for the provided store path.
metadataContainer
T@"NSPersistentContainer",R,N,V_metadataContainer
initializationGroup
T@"NSObject<OS_dispatch_group>",R,N,V_initializationGroup
initialized
TB,R,N,V_initialized
lastInitializationError
T@"NSError",R,N,V_lastInitializationError
listener
T@"NSXPCListener",R,N,V_listener
T@"CDDCloudKitServerConfiguration",R,C,N,V_configuration
T@"PFCloudKitContainerProvider",R,N,V_containerProvider
T@"CKScheduler",R,N,V_scheduler
%@: columnName = %@, type = %d, slot = %d, fetchIndex = %d propertyType = %d
Problem with subpredicate %@
 NOT (
Unknown compound predicate type %@
Unable to generate compound where clause for predicate (%@) (unknown problem)
entitySpecificationKeypath
entitySpecificationKeypathContainsToMany
selectBindVars
bindVars
'%@'
Can't specify non string/number/date value as part of index
valueSpecified
 (%@, %@:%@ -> %@:%@, %@, %@)
originalTransactionNumber
T@"NSNumber",R,N,V_originalTransactionNumber
originalChangeType
Tq,R,N,V_originalChangeType
finalTransactionNumber
T@"NSNumber",R,N,V_finalTransactionNumber
finalChangeType
Tq,R,N,V_finalChangeType
tombstone
T@"NSDictionary",R,N,V_tombstone
finalHistoryToken
T@"NSPersistentHistoryToken",R,N,V_finalHistoryToken
finalChangeAuthor
T@"NSString",R,N,V_finalChangeAuthor
_NSSQLiteSEEKeychainItemOption
com.apple.CoreData.SQLDebug
com.apple.CoreData.ConcurrentFetching
com.apple.CoreData.BufferAllocations
Dictionary Result type overriden to use Buffered Results with level - %ld!!!
Keychain failed to return key for database encryption (error %d)
Keychain did not return a key for database encryption
entityForObjectID was passed a nil objectID
entityForObjectID failed to retrieve an NSSQLEntity for objectID %@
entityForObjectID passed a nil entity description from %@
_sqlCoreLookupSQLEntityForEntityDescription failed to return a result for objectID %@ with entity %@
path's fileSystemRepresentation returned NULL
 failed to open file due to illegal URL encoding.  error = %@ with userInfo %@
Cannot create an SQL store with a nil URL.
CoreData SQL stores only support file URLs (got %@).
Error - In Memory store at /dev/null can only have NSPersistentStoreConnectionPoolMaxSizeKey equal to 1
NSPersistentStoreRemoveStoreOnCleanup
Got a nil sqlmodel
NSPersistentHistoryTrackingKey must be a NSNumber
NSPersistentHistoryTrackingEntitiesToInclude must be an NSArray of NSString
NSPersistentHistoryTrackingEntitiesToInclude has entities not included in the Managed Object Model
NSPersistentHistoryTrackingEntitiesToExclude must be an NSArray
NSPersistentHistoryTrackingEntitiesToExclude & NSPersistentHistoryTrackingEntitiesToInclude are mutually exclusive, you cannot set both options
NSPersistentHistoryTrackingEntitiesToExclude must be an NSArray of NSString
Entity (%@) was not found in model.
Persistent History is disabled - %@
NSXPCStoreDelegate
VersionSkewIntermediateFixTable
Bad correlation tables in read-only database
Can't find table for entity '%@' in database at URL '%@'
Error encountered during index recreation %@ with userInfo %@
Exception caught during index recreation %@
Repairing old triggers failed with error = %@ and userInfo = %@
Error encountered during trigger recreation %@ with userInfo %@
Exception caught during trigger recreation %@
pragma auto_vacuum
pragma auto_vacuum=1
vacuum
Error caught during autovacuum check %@ with userInfo %@
Exception caught during autovacuum check %@
Exception caught during drop of old history tracking tables %@ with userInfo %@
Exception caught during drop of old history tracking tables %@
coreduetd
Exception caught during drop/create of history tracking tables %@ with userInfo %@
Exception caught during drop/create of history tracking tables %@
Exception caught during add of tombstone columns %@ with userInfo %@
Exception caught during add of tombstone columns %@
found Ancillary Entities in Persistent History - %@
Exception caught during checking for Ancillary Entities %@ with userInfo %@
Exception caught during checking for Ancillary Entities %@
Exception caught during adding transaction string table %@ with userInfo %@
Exception caught during adding transaction string table %@
Exception caught during create of history tracking tables %@ with userInfo %@
Exception caught during create of history tracking tables %@
Store opened without NSPersistentHistoryTrackingKey but previously had been opened with NSPersistentHistoryTrackingKey - Forcing into Read Only mode store at '%@'
Error caught during cached model check %@
Exception caught during cached model check %@
Exception caught during model caching %@ with userInfo %@
Exception caught during model caching %@
Exception trying to update primary key table
finished upgrade checks, bumping metadata
Exception caught during _ensureDatabaseMatchesModel %@ with userInfo %@
Exception caught during _ensureDatabaseMatchesModel %@
v16@?0@"NSSQLiteConnection"8
v16@?0@"NSSQLStoreRequestContext"8
unable to check registration for posting store changed notification
cannot find data for a temporary oid: %@
_NSSQLCoreTransactionStateChangeNotification
_NSSQLCoreTransactionType
_NSSQLCoreTransientSequenceNumber
_NSSQLCoreActiveSavingContext
No history tracking option detected on store
Store - %@ is not found in token - %@
CoreData: Executing write request
-executeRequest: encountered exception = %@ with userInfo = %@
_SUPPORT
Can't write external data to non-file URL
_FBF
Can't create support directory (can't create directory)
Can't create fbf directory (file exists)
_EXTERNAL_DATA
Can't create external reference directory (file exists)
Could not connect to database.
_NSAutoVacuumLevel
URL is not a file URL or is nil
Only persistent stores backed by files can be destroyed
CoreData: Destroying store
Failed to delete support directory for store: %@
Both source and destination stores must be backed by files
CoreData: Replacing entire store
_transsrc_4052146efa0d85c9fbe0634c0e8bc4457ed82f7c
_transdst_878d188f109e9f52ae70b0b25413f6a38c8267a8
Failed to delete staging area for external support directory for store: %@
Failed to copy support directory from store: %@ to store: %@.  %@
Failed to delete support directory for store: %@.  %@
Failed to copy support directory from store: %@ to store: %@ (failed to move %@ to %@ due to %@)
Failed to unlink support directory %@ from old store location: %@ due to %@
Only persistent stores backed by files can be rekeyed
CoreData: Rekeying entire store
Unsupported feature in this configuration
Failed to adopt query generation from remote change
SQLCore failed to get a currentQueryGeneration
SQLCore dispatchRequest: exception handling request: %@ , %@ with userInfo of %@
YouTube
Can't fetch UUIDs for non-root entities
databaseValue
UPDATE OR FAIL %@ set %@=%@ where %@ = '%@'
Invalid parameter value (missing parameter)
Invalid parameter value (bad entity)
Invalid parameter value (zero)
This persistent store is not associated with a mirroring delegate, it cannot process this request: %@
failed to retrieve ordering information from fault for object %@ and relationship %@
v32@?0@"NSObject<NSSQLAttributeExtension>"8Q16^B24
Refreshing trigger values failed to adopt post transaction query generation with error %d
presentedItemURL
T@"NSURL",R,C
presentedItemOperationQueue
T@"NSOperationQueue",R,&
primaryPresentedItemURL
observedPresentedItemUbiquityAttributes
isInitialized
ancillaryModels
T@"NSDictionary",R,N,V_ancillaryModels
remoteStoresDidChange
isInMemory
%@.queue.%p
Exception thrown posting NSPersistentStoreRemoteChangeNotification: %@
Unknown exception thrown posting NSPersistentStoreRemoteChangeNotification
 Failed to setup notification listener for NSPersistentStoreRemoteChangeNotification: %d
Threw during attempt to purge SQL row cache data
Invalid collation type (rtree indexes can only be created on attributes).
Invalid collation type (rtree indexes can only be created for floats or integers < 32 bit).
Can't create an index element without a property
Can't create an index element with an unnamed property
Can't create an index element with non-attribute property
NSIndexedProperty
NSFetchIndexElementType
NSFetchIndexDescription
NSAscending
<NSFetchIndexElementDescription : (%@ (%@), %d, %@)>
modeled property
Broken logic around index elements
offender
T@"NSPropertyDescription",R,&
T@"NSString",R,&,V_propertyName
collationType
TB,GisAscending
indexDescription
T@"NSFetchIndexDescription",R,N
TEMP_CD%@
B12@?0C8
columnName
q24@?0@8@16
Invalid keypaths found in derived attribute (derivationExpression)
Invalid keypaths found in derived attribute (filteringPredicate)
Invalid keypaths found in derived attribute (unsupported function)
Invalid keypaths found in derived attribute (can't find keypath component)
component
Invalid keypaths found in derived attribute (derived attribute found in dependency chain)
Invalid keypaths found in derived attribute (non-terminal attribute not followed by a function)
<NSSQLEntity %@ id=%d>
Trying to add a non-attribute, non-to-one property to an entity: %@
rtreeIndexes
changeTypeNum
typeNum
zoneName
Tq,N
operation
T@"NSCKExportOperation",&,D,N
bundleIdentifier
fileProtectionType
storeConfigurationName
activityUUID
activityTypeNum
scheduledAt
isUserRequestedBackupTask
registeredClient
scheduledActivities
storeRequest
Z_PK
SELECT
COUNT(
DISTINCT
t0.Z_PK)
FROM
SELECT COUNT(*) FROM %@
SELECT COUNT(*) FROM (
 AND (
WHERE 
GROUP BY 
HAVING 
database
T@"CKDatabase",R,N,V_database
mirroringDelegateOptions
T@"NSCloudKitMirroringDelegateOptions",R,N,V_mirroringDelegateOptions
perOperationBytesThreshold
TQ,N,V_perOperationBytesThreshold
perOperationObjectThreshold
TQ,N,V_perOperationObjectThreshold
%@%d_%@
%@%@
T@"NSUUID",R,N,V_identifier
Unable to generate sql for %@ as part of  expression (%@)
Wrong number of arguments to function add:to: (%@)
Unable to generate sql for add:to: argument 0(%@)
Unable to generate sql for add:to: argument 1(%@)
Unsupported expression in index description (%@)
(SELECT 
) FROM 
restrictingEntityPredicate
 WHERE (
 >= 
Can't generate sql for entityID
 <= 
Unsupported expression in index description (%@), '%@' not supported in this context
Unsupported join (min/max(key.path) not allowed in updates)
Invalid keypath element (not a relationship or attribute): %@
Invalid keypath (continues after attribute name): %@
Invalid keypath (request for aggregate operation on a toOne-only keypath): %@
Invalid keypath (too many toMany relationships): %@
count
Invalid keypath (no terminal attribute in call to math aggregate): %@
Failed to generate SQL for function expression: %@
Unsupported expression in index description (%@), aggregates not allowed here.
Non-attribute property passed to math function: %@
Unable to generate sql for %@, empty max/etc expression
Unable to generate sql for %@
Unable to generate sql for subquery: %@
Unsupported expression %@
Unable to generate sql for %@() : argument (%@) not supported
Unsupported expression in index description (%@), aggregate operations not allowed here
Unable to generate sql for %@, empty %@ expression
Unable to generate sql for %@, empty expression
Bad argument to upper/lower function (needs to be a keypath or a string) : %@
Invalid number of parameters passed to uppercase: function
Bad value
Unable to generate sql for %@, can't drop index on non-keypath
Invalid number of parameters passed to function (%@)
Unsupported expression in index description (%@), 'count' not supported in this context
Invalid number of arguments to count (requires at least 1 argument)
Unable to generate SQL for count expression %@
count(*)
COUNT(*)
.@count
distinct:
Unable to generate SQL for expression: %@
COUNT (
Unsupported function expression : %@
Invalid number of arguments to avg function : %@
Bad argument to %@ (can't get the %@ of collection) : %@
Bad argument to sum (non-numeric, non-collection argument) : %@
Unable to generate SQL for keypath: %@
Bad argument to aggregate %@ in select (must be a keypath or constant value) : %@
Non-attribute property passed to sum: %@
Unable to generate SQL for subquery: %@
Unsupported argument to sum : %@
Unsupported expression in index description (%@), 'distinct' not allowed here
Invalid number of arguments to distinct : %@
Invalid argument to distinct : %@
Unable to generate SQL for distinct : %@
DISTINCT 
Unsupported expression in index description (%@), 'now' not allowed here
Invalid number of arguments to now function : %@
Invalid number of arguments to length: function : %@
Invalid argument to length: : %@
Unable to generate SQL for length : %@
length(
You should not have made it here, scope failed at its job : %@
NSCoreDataToUpper(
NSCoreDataToLower(
abs(
total
 << 
 >> 
Unsupported function type passed as index component (either not a valid function at all, or just not valid in this context).
Unsupported function type passed to SQL store
Invalid rowCache row is nil
Optimistic locking failure for %@.  Original row was missing while recording to-many changes.  New row = %@
Optimistic locking failure for %@.  Original row was missing while recording to-many changes.
%u-%lld
saveRequest
savingContext
transactionInMemorySequence
Ti,N
externalDataReferencesToSave
T@"<_NSCoreDataCollectionWithoutKeys>",R,N,V_externalDataReferencesToSave
externalDataReferencesToDelete
T@"<_NSCoreDataCollectionWithoutKeys>",R,N,V_externalDataReferencesToDelete
fileBackedFuturesToCopy
T@"<_NSCoreDataCollectionWithoutKeys>",R,N,V_fileBackedFuturesToCopy
fileBackedFuturesToDelete
T@"<_NSCoreDataCollectionWithoutKeys>",R,N,V_fileBackedFuturesToDelete
Updating relationship described by record: %@
-[PFCloudKitImportZoneContext initializeCachesWithManagedObjectContext:andObservedStore:error:]_block_invoke
%@ - Skipping unknown updated relationship record: %@
-[PFCloudKitImportZoneContext initializeCachesWithManagedObjectContext:andObservedStore:error:]_block_invoke_2
%@ - Skipping mirrored relationship for unknown relationships: %@
Failed to serialize many to many relationship from record: %@
%@ - Skipping unknown updated record: %@
It is not a part of: %@
v32@?0@"CKRecord"8Q16^B24
Deleting record with id (%@): %@
%@ - Skipping unknown deleted relationship recordID: %@ - %@
%K = %@
Skipping mirrored relationship with record id (not found locally): %@
Import context failed to fetch mirrored relationships during import: %@
%@ - Skipping unknown deleted record: %@ - %@
Linking %@ to %@
-[PFCloudKitImportZoneContext registerObject:forInsertedRecord:withMetadata:]
v32@?0@"NSString"8@"NSMutableArray"16^B24
Populating unresolved relationships:
-[PFCloudKitImportZoneContext populateUnresolvedIDsInStore:withManagedObjectContext:error:]_block_invoke
deletedObjectIDs
T@"NSSet",R,N,V_deletedObjectIDs
modifiedRecords
T@"NSArray",R,N,V_modifiedRecords
deletedRelationships
T@"NSArray",R,N,V_deletedRelationships
deletedMirroredRelationshipRecordIDs
T@"NSArray",R,N,V_deletedMirroredRelationshipRecordIDs
updatedRelationships
T@"NSArray",R,N,V_updatedRelationships
importOperations
T@"NSArray",R,N,V_importOperations
invalidatedPendingRelationships
T@"NSArray",R,N,V_invalidatedPendingRelationships
pendingRelationshipsToTry
T@"NSArray",R,N,V_pendingRelationshipsToTry
T@"NSURL",R,N,V_fileBackedFuturesDirectory
<%@: %p> %@ -> %@
insertedObject
T@"NSManagedObject",R,N,V_insertedObject
recordMetadata
T@"NSCKRecordMetadata",R,N,V_recordMetadata
ignoreInheritance
outerFetch
Bad NSFetchRequestExpression (%@ propertiesToFetch)
Too few
Too many
Bad fetch request (NSManagedObjectResultType not compatible with contents of propertiesToFetch)
ZZ_PK
Unknown predicate type for predicate: %@
informationGatherer
havingPredicateAnalyser
Invalid fetch request: HAVING with no GROUP BY
Invalid fetch request: GROUP BY requires NSDictionaryResultType
substitutionVariables
Unsupported predicate %@
Unsupported nested update inside of %@
@min
@max
@sum
@avg
nestedWhereSelect
duringPrefetching
subOrder
columnSubOrder
SELECT 0 FROM %@ WHERE 0 = 1
bindIntarrays
fabricatedSQLEntityForReadOnlyFetch
bindIntarraysSubstitutionOrder
Unable to generate index for %@
Reason: %@, %@
Reason: predicate always evaluates to false
v16@?0@"CDDCloudKitResponse"8
Failed to acquire a valid file handle to: %@
connection
T@"NSXPCConnection",R,N,V_connection
interrupted
TB,R,N,V_interrupted
TB,R,N,V_invalidated
NSRemotePersistentStoreDidChangeNotification
skipModelCheck
com.apple.CoreData.XPCDebug
current
unpinned
No service name, endpoint factory, or endpoint supplied
XPC store does not currently allow models containing external data references
XPC store does not currently allow models containing ordered relationships
Unable to load model
Unable to initialize client
sendMessage: failed #%d
Unable to sendMessage: to server
Got reply pointer: %p
Got reply: %@
Unable to connect to server with options %@
Unable to send to server; failed after %d attempts.
Problem
 Request failed: (%@).
Send failed with no error; probably something wrong here
 Got success, but also an error. Ignoring the error (%@).
sendMessage: apparently succeeded, but no response or error
No data, cause unknown
CoreData: XPC: Can't move an XPC store from the client
CoreData: XPC: Can't change store identifier from the client
NSXPCStorePostUpdateNotifications
notificationName
Failed to enable remote store notifications: Can't get notification name. %@
Failed to enable remote store notifications: %@
NSFileBackedFuturePathKey
missing faults directory URL in store whose model contains faults
NSMetadataKey
Server did not return model version info. (Unsupported configuration.)
Server schema is incompatible and ignore version enabled. (Unsupported configuration.)
Server side store changed, remove and re-add this client store
Unable to load metadata: %@
Unable to decode query generation
Nil result for query generation request
Unable to get query generation: %@
Unable to release query generation: %@
Attempt to release query generation failed: %@
Attempt to reopen query generation failed: %@
Executing fetch %@
exception info
controlled exception
Fetch threw on server (%@)
Fetch retrieved %lu results from server
Fetch retrieved null, error %@
Attempting to resend what looks like it may be a reinsert
Reinsert hit optimistic locking error, will discard and let the next save resolve it.
Something threw out of NSXPCStore executeSaveRequest:, got exception %@
Nil response received
NSFetchRequestExpression is unsupported for the XPC Store
Invalid request type
Something unexpected happened: %@ 
Unexpected number of property values returned from server
Firing fault %@
Returning cached value %@
Retrieved node from server %@
Decoded value for %@ - %@ : %@
Got a bad relationship value for %@, %@ (%@)
Wrong number of object IDs returned from server
Wrong number of object IDs returned from server (2)
remoteStoreChangedNotificationName
T@"NSString",R,C,V_remoteStoreChangedNotificationName
com.apple.internetaccounts
com.apple.preferences.internetaccounts.remoteservices
Unable to decode history token
Nil result for history token request - %@
NSUnderlyingExceptionKey
Unsupported function expression %@
Undefined variable expression %@
Unsupported: collections not allowed in index expressions.
Unsupported element in aggregate expression %@
(SELECT * FROM %@) 
Fetch request expressions not allowed in indexes
Unsupported fetch request expression in update - too many results
Unsupported subquery collection expression type
subquery
Unsupported expression type (%u, %@)
disambiguatingEntity
T@"NSSQLEntity",R,N
disambiguationKeypath
disambiguationKeypathHasToMany
DECIMAL
CHAR
VARCHAR
FLOAT
CLOB
UNDEFINED
INTEGER PRIMARY KEY
entity required
statement required
empty row
missing original
missing fetch request
DELETE FROM %@ WHERE Z_PK = OLD.%@ ; 
UPDATE OR FAIL %@ SET Z_OPT = (Z_OPT + 1) WHERE Z_PK = OLD.%@ ; 
%@; %@
Delete rule is not supported for batch deletes
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_%@_TRIGGER AFTER DELETE ON %@ FOR EACH ROW BEGIN %@%@ END
DROP TRIGGER IF EXISTS ZQ_%@_TRIGGER
CREATE TABLE 
%@ %@
CREATE TEMP TABLE 
%@ %@ UNIQUE
, CONSTRAINT %@ UNIQUE (
 INTEGER PRIMARY KEY, 
 VARCHAR, 
 INTEGER, 
 INTEGER)
INSERT INTO %@(%@, %@, %@, %@) VALUES(%u, '%@', %u, %qd)
UPDATE OR FAIL %@ SET %@ = MAX((SELECT %@ FROM %@ WHERE %@ = '%@'), (SELECT CASE WHEN (SELECT COUNT(*) FROM %@ )== 0 THEN 0 ELSE (SELECT MAX(%@) FROM %@) END)) WHERE %@ = '%@'
SELECT CASE WHEN (SELECT COUNT(*) FROM %@) == 0 THEN 0 ELSE (SELECT MAX (%@) FROM %@) END
MAX((SELECT %@ FROM %@ WHERE %@ = '%@'), (%@))
MAX((SELECT %@ FROM %@ WHERE %@ = '%@'),
(%@)
UPDATE OR FAIL %@ SET %@ = (%@) WHERE %@ = '%@'
ALTER TABLE 
 RENAME TO 
) SELECT 
 FROM 
DROP TABLE IF EXISTS 
DROP TABLE 
, PRIMARY KEY (
%@_%@_INDEX
CREATE INDEX IF NOT EXISTS %@ ON %@ (%@)
CREATE INDEX IF NOT EXISTS %@ ON %@ (%@, %@)
_NSEntityOmitSubentityColumnIndex
_NSLocationAttributeDerivedComponents
Entity named:%@ not found for relationship named:%@
MissingEntity
Name: %@ Destination Entity:%@
DELETE FROM %@ WHERE Z_PK = OLD.%@
DELETE FROM %@ WHERE %@ = OLD.Z_PK
SELECT RAISE(FAIL, 'Batch delete failed due to mandatory OTO nullify inverse on %@/%@') FROM %@ WHERE Z_PK = OLD.%@
UPDATE OR FAIL %@ SET %@ = NULL , %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK
UPDATE OR FAIL %@ SET %@ = NULL , Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK
UPDATE OR FAIL %@ SET Z_OPT = (Z_OPT + 1) WHERE Z_PK = OLD.%@
SELECT RAISE(FAIL, 'Batch delete failed due to manadatory OTM nullify inverse on %@/%@') FROM %@ WHERE %@ = OLD.Z_PK
UPDATE OR FAIL %@ SET %@ = NULL, %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK
UPDATE OR FAIL %@ SET %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK
WITH ZCTE_INTERMEDIATE AS (SELECT %@, %@ FROM %@ WHERE %@ = OLD.Z_PK) SELECT RAISE(FAIL, 'Batch delete failed due to mandatory MTM nullify inverse on %@/%@') FROM ZCTE_INTERMEDIATE T0 WHERE (0 == (SELECT COUNT(*) FROM %@ T1 where T1.%@ = T0.%@ and T1.%@ != OLD.Z_PK))
(SELECT NSPersistentHistoryBatchDeleteUpdateTrigger(Z_ENT, '%@'))
ON CONFLICT(%@, %@) DO UPDATE SET %@ = NSPersistentHistoryBatchDeleteUpdateTriggerDataBlobOperator(%@, excluded.%@)
FROM %@ WHERE Z_PK = OLD.Z_PK
INSERT INTO %@ (%@, %@, %@, %@, %@) SELECT %u, Z_PK, Z_ENT, %ld, %@ %@ %@;
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_%@_%@_HISTORYBATCHDELETEUPDATE_TRIGGER AFTER UPDATE OF %@ ON %@ FOR EACH ROW BEGIN %@ END
DROP TRIGGER IF EXISTS ZQ_%@_%@_HISTORYBATCHDELETEUPDATE_TRIGGER
%@-%@
(SELECT NSPersistentHistoryBatchDeleteUpdateTrigger(OLD.%@, '%@'))
WHERE OLD.%@ > 0 AND OLD.%@ > 0
INSERT INTO %@ (%@, %@, %@, %@, %@) SELECT %u, OLD.%@, OLD.%@, %ld, %@ %@ %@
(SELECT NSPersistentHistoryBatchDeleteUpdateTrigger(%@.Z_ENT, '%@'))
FROM %@ WHERE Z_PK = OLD.%@
INSERT INTO %@ (%@, %@, %@, %@, %@) SELECT %u, Z_PK, Z_ENT, %ld, %@ %@ %@
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_%@_TRIGGER AFTER DELETE ON %@ FOR EACH ROW BEGIN %@ END
INSERT OR REPLACE INTO %@ 
%@, %@, %@, %@
v16@?0@"NSSQLEntity"8
, Z%@%u
SELECT %d, %@, %@, %ld
, OLD.%@
, CASE %@ 
WHEN %@ THEN (SELECT %@) 
ELSE NULL 
END 
(%@) %@ FROM %@ WHERE %@ = OLD.%@;
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_%@_HISTORYBATCHDELETE_TRIGGER BEFORE DELETE ON %@ FOR EACH ROW BEGIN %@ END
DROP TRIGGER IF EXISTS ZQ_%@_HISTORYBATCHDELETE_TRIGGER
ZQ_BATCH_DELETE_MARSHALLING
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_EDR_%@_%@ BEFORE DELETE ON %@ FOR EACH ROW WHEN OLD.%@ IS NOT NULL BEGIN INSERT INTO %@ VALUES (OLD.%@); END
DROP TRIGGER ZQ_EDR_%@_%@
CREATE TEMP TABLE ZQ_BATCH_DELETE_MARSHALLING(refToDelete)
SELECT refToDelete FROM ZQ_BATCH_DELETE_MARSHALLING
DROP TABLE ZQ_BATCH_DELETE_MARSHALLING
Can't fetch source objects
NSBatchDeleteRequest could not locate an Entity for entity name '%@'
Model Configuration
t0.Z_ENT, 
DELETE FROM %@
DELETE FROM %@ WHERE Z_PK IN (%@)
SELECT %@, %@, %@ FROM %@ WHERE Z_PK = %u
T1.%@
SELECT T0.%@, %@, T0.%@ from %@ T0 JOIN %@ T1 on t0.%@ = t1.Z_PK where T0.%@ = %u
SELECT %@, %@, %@ FROM %@ WHERE %@ = %u
Z_PK, Z_ENT
, %@
%@ IN (
Unsupported property type for unique attribute on entity '%@': %@
SELECT %@ FROM %@ WHERE (
SELECT Z_PK FROM %@ WHERE %@ IN (
SELECT %@, %@ FROM %@ WHERE Z_PK IN (
 INTERSECT 
v32@?0@"<NSSQLAttributeExtension>"8Q16^B24
Invalid trigger configuration.
Invalid location index configuration.
NSSQLConnectionBeginTransactionNotification
NSSQLConnectionCommitTransactionNotification
NSSQLConnectionRollbackTransactionNotification
%s (%p) : %@
data
T@"NSData",R,N
bytes
Tr^v,R,N
sqlite3_db_config for SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE failed: %d
Failed to activate SQLite encryption extension
SQLQueue %p for %@
Force checkpointing -wal while initializing query generations due to its large size (%lld)
main
sqlite3_snapshot_recover failed with %d
Failed to initialize query generation tracking connection due to exception %@ (%@) with error (%@), retries left: %d
Failed to initialize query generation tracking connection with error (%@), retries left: %d
Attempted to perform an operation without an open database
Attempted to perform another operation with a statement prepared
Attempted to perform another operation with a fetch already in progress
Nested transactions are not supported
[32msql: 
[34m
[47m%@
I/O error for database at %@.  SQLite error code:%d, '%s' errno:%d
I/O error for database at %@.  SQLite error code:%d, '%s'
Fatal error.  The database at %@ is corrupted.  SQLite error code:%d, '%s'
[31m
[47mERROR:
[31m (%d) %s
(%d) %s
error during execution of SQL string '%s' : %s
The database operation timed out after %.2f seconds.
[31m
[47mERROR:
[31m (%d) %@
(%d) %@
error during SQL execution : %@
sql execution time: 
[31m%.4f
[0ms
sql execution time: %.4fs
SELECT MAX(%@) FROM %@
Fetching maximum primary key for entity failed
Y_UBRANGE
synchronous
integrity_check
Unable to create index: %@ due to error (%@)
Unable to create index: %@ due to exception (%@)
Unsupported derivedAttribute
CREATE TABLE %@ (%@ INTEGER PRIMARY KEY, %@ VARCHAR(255), %@ BLOB)
CREATE TABLE %@ (%@ BLOB)
CREATE TABLE IF NOT EXISTS Y_UBMETA (Y_PK INTEGER PRIMARY KEY ASC, YPEERID VARCHAR UNIQUE, YTRANSACTIONNUMBER INTEGER)
CREATE TABLE IF NOT EXISTS Y_UBRANGE (Y_PK INTEGER PRIMARY_KEY ASC, YPEERID VARCHAR, YENTITYNAME VARCHAR, YRANGESTART INTEGER, YRANGEEND INTEGER, YPEERSTART INTEGER, YPEEREND INTEGER)
CREATE TABLE IF NOT EXISTS Y_UBKVS (Y_PK INTEGER PRIMARY KEY ASC, YKEY VARCHAR UNIQUE, YVALUE VARCHAR)
page_size
pragma %@=%@
pragma %@
pragma recursive_triggers=1
Database failed integrity check.  Corrupted SQLite database at path: %@
lock_proxy_file
pragma %@='%@'
pragma %@=''
auto_vacuum
incremental
:memory:
/dev/null/
file:%@?mode=memory&cache=shared
Connecting to sqlite database file at "%@"
recursive_triggers
delete
memory
File at path does not appear to be a SQLite database: %@
sqlite3_db_config for SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE failed (_qGTC): %d
sqlite3_db_config for SQLITE_DBCONFIG_LOOKASIDE failed: %d
pragma cache_spill = 64
Cannot create a new database file with the read only option at path: %@
ANALYZE
VACUUM
:auto:
pragma lock_proxy_file='%@'
Failed to set file locking on source database
Failed to open source database
Failed to set file locking on destination database
Failed to open destination database
Failed to replace destination database
Source database Path
%@ failed to close destination database %@
%@ failed to close source database %@
-journal
-wal
ignoring unsupported page_size specified as truncate option: %@
full
unsupported auto_vacuum setting specified as truncate option: %@
-shm
-conch
Failed to truncate database
In-memory stores do not support rekeying
New key value must not be empty
CoreData: SQLite disconnection (forced error)
Disconnecting from sqlite database due to an error.
CoreData: SQLite disconnection
Disconnecting from sqlite database.
Marking -wal eligible for checkpointing in -disconnect due to its large size (%lld)
Disconnected from database with pending transactions: %@
Un-finalized statement: %p
BEGIN EXCLUSIVE
BEGIN TRANSACTION
%@ -- %@ %p: attempted to commit a transaction while a fetch was in progress
COMMIT
%@ -- %@ %p: attempted to rollback a transaction while a fetch was in progress
ROLLBACK
Can't demote a connection from being a writer
Optimistic locking failure for %@.  During updateRow.  Original row = %@ New Row = %@ context version match = %d
Optimistic locking failure for %@. During updateRow.  Original row = %p context version match = %d
Optimistic locking failure for %@.  During updateRow, rows processed = %d.  Original row = %@ New row = %@
Optimistic locking failure for %@.  During updateRow, rows processed = %d.
Optimistic locking failure for %@.  During updateConstrainedValuesForRow, rows processed = %d.  New Row = %@
Optimistic locking failure for %@.  During updateConstrainedValuesForRow, rows processed = %d.  Row was updated.
Optimistic locking failure for %@.  During deleteRow.  Original row = %@ New Row = %@ context version match = %d
Optimistic locking failure for %@. During deleteRow. version match = %d
correlation bindings: %qu, %qu, %qu, %qu
v48@?0Q8Q16Q24Q32^B40
correlation bindings:  %qu, %qu
v32@?0Q8Q16^B24
correlation bindings: %qu, %qu, %qu
v40@?0Q8Q16Q24^B32
SQL statement is still active / leaked.  sql:'%@'
statement is still active
Statement
error during prepareSQL for SQL string '%s' : %s
CoreData: SQLite: error: Can't bind intarray. SQLite error code: %d
Bound intarray %@
Bound intarray value %lu at %d
Bound intarray values.
sqlite3_bind* failed
SQLite bind[%ld] = %@
<NSData len=%lu>
SQLite bind[%ld] = "%@"
SQLite bind[%ld] = (timestamp)%f
SQLite bind[%ld] = (int64)%qd
SQLite bind[%ld] = nil
binding not implemented for this SQLType %d
Unexpected or improperly formatted URI parameter type %@, expected NSURL or well-formed NSString
%lu/%lu
Unexpected or improperly formatted UUID parameter with type %@, expected NSUUID or well-formed NSString
fetching not implemented for this value type
[31m
[47mERROR:
[31m %@
The database appears corrupt.  (invalid entity key)
The database appears corrupt.  (invalid primary key)
Row (pk = %lld) for entity '%@' is missing mandatory text data for property '%@'
BufferAllocations found a bad Object ID
Row (pk = %ld) for entity '%@' is missing mandatory text data for property '%@'
pragma secure_delete=1
pragma secure_delete=0
pragma locking_mode=EXCLUSIVE
pragma locking_mode=NORMAL
pragma integrity_check
performIntegrityCheck encountered an error %@
performIntegrityCheck encountered an exception %@
SELECT TBL_NAME FROM SQLITE_MASTER WHERE TYPE = "table" ORDER BY TBL_NAME
TBL_NAME
Encountered exception %@ with userInfo %@ while fetchTableNames from store: %@
SELECT TBL_NAME, SQL FROM SQLITE_MASTER WHERE TYPE = "%@" ORDER BY TBL_NAME
Ubiquity: Encountered exception %@ with userInfo %@ while fetchTableCreationSQL from store: %@
table
SELECT 
 FROM %@ WHERE (
(%@ >= ?)
SELECT TBL_NAME FROM %@ WHERE TBL_NAME = '%@'
SQLITE_TEMP_MASTER
SQLITE_MASTER
Encountered exception %@ with userInfo %@ while checking table name from store: %@
metadata is not a dictionary: %@
The metadata is not a dictionary: %@
DELETE FROM %@ WHERE %@ = ?
failure writing metadata plist with data bytes: %@
An error %@ occurred converting the metadata plist data: %@
INSERT INTO %@ (%@, %@, %@) VALUES (?, ?, ?)
Saving new meta data; version = %@ ; UUID = %@
SELECT %@, %@, %@ FROM %@
failure reading metadata plist with data bytes: %@
Metadata table is missing database UUID.
Could not initialize compression decoder.
Failed to decompress model cache.
SELECT %@ FROM %@
Could not initialize compression encoder.
INSERT INTO %@ (%@) VALUES (?)
Saving new model cache
unable to cache model: %@
An internal error occurred while configuring functions in the SQLite database.
primary keys must be generated within a transaction
SELECT %@ FROM %@ WHERE %@ = ?
getting max pk for entityID = %u
Fetching maximum primary key failed
UPDATE OR FAIL %@ SET %@ = ? WHERE %@ = ? AND %@ = ?
updating max pk for entityID = %u with old = %qd and new = %qd
Updating max pk failed: %@
pragma auto_vacuum=%@
pragma page_size=%d
pragma journal_mode=wal
creating schema.
Creating primary key table.
re-adding all indices
pragma page_count
pragma freelist_count
pragma incremental_vacuum(%d)
performPostSaveTasks threw something (1). ex = %@
pragma wal_checkpoint(TRUNCATE)
performPostSaveTasks threw something (2). ex = %@
EXPLAIN QUERY PLAN %s
SQLite: %s
     
%d %d %d %s
select YPEERID, YTRANSACTIONNUMBER, Y_PK from Y_UBMETA
YPEERID
YTRANSACTIONNUMBER
Y_PK
%s(%d): CoreData: Ubiquity:  Database not open: %@
-[NSSQLiteConnection fetchUbiquityKnowledgeVector]
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Had trouble fetching ubiquity knowledge vector from store: %@
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while fetching ubiquity knowledge vector from store: %@
OLDYTRANSACTIONNUMBER
UPDATE OR FAIL Y_UBMETA set YPEERID="%@", YTRANSACTIONNUMBER=%@ where YTRANSACTIONNUMBER=%@ AND Y_PK=%@
INSERT INTO Y_UBMETA(YPEERID, YTRANSACTIONNUMBER) VALUES("%@", %@)
offendingPeerID
import
offendingOperation
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while updating ubiquity knowledge vector from store: %@
-[NSSQLiteConnection updateUbiquityKnowledgeVector:]
DELETE FROM Y_UBMETA WHERE YPEERID = "%@"
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while replacing ubiquity knowledge vector from store: %@
-[NSSQLiteConnection replaceUbiquityKnowledgeVector:]
UPDATE OR FAIL Y_UBMETA set YPEERID="%@", YTRANSACTIONNUMBER=%@ WHERE YPEERID="%@"
export
sqlString
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while updating ubiquity knowledge for peer from store: %@
-[NSSQLiteConnection updateUbiquityKnowledgeForPeerWithID:andTransactionNumber:]
%s(%d): CoreData: Ubiquity:  Peer already exists in the local knownledge vector
INSERT INTO Y_UBRANGE(YPEERID, YENTITYNAME, YRANGESTART, YRANGEEND, YPEERSTART, YPEEREND) VALUES("%@", "%@", %@, %@, %@, %@)
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while adding peer range for store: %@
-[NSSQLiteConnection addPeerRangeForPeerID:entityName:rangeStart:rangeEnd:peerRangeStart:peerRangeEnd:]
SELECT YPEERID, YENTITYNAME, YRANGESTART, YRANGEEND, YPEERSTART, YPEEREND FROM Y_UBRANGE
YENTITYNAME
YRANGESTART
YRANGEEND
YPEERSTART
YPEEREND
-[NSSQLiteConnection allPeerRanges]
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while fetching all peer ranges for store: %@
Z_NAME
SELECT Z_NAME, Z_MAX FROM Z_PRIMARYKEY WHERE Z_NAME IN (
, '%@'
) GROUP BY Z_NAME
Got the wrong number of rows back for the range max query
fetchResultRows
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while creating maps for entities for store: %@
-[NSSQLiteConnection createMapOfEntityNameToPKMaxForEntitiesFromPKTable:]
SELECT YENTITYNAME, MAX(YRANGEEND) FROM Y_UBRANGE WHERE YENTITYNAME IN (
) GROUP BY YENTITYNAME
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while creating maps for entities with range for store: %@
-[NSSQLiteConnection createMapOfEntityNameToPKMaxForEntitiesFromUBRangeTable:]
REPLACE INTO Y_UBKVS(YKEY, YVALUE) VALUES("%@", "%@")
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while setting value in ubiquity table for store: %@
-[NSSQLiteConnection setUbiquityTableValue:forKey:]
select YKEY, YVALUE from Y_UBKVS
YKEY
YVALUE
-[NSSQLiteConnection ubiquityTableKeysAndValues]
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while fetching ubiquity table and keys from store: %@
select YVALUE from Y_UBKVS where YKEY = "%@"
-[NSSQLiteConnection ubiquityTableValueForKey:]
DROP TABLE IF EXISTS Y_UBMETA
DROP TABLE IF EXISTS Y_UBRANGE
DROP TABLE IF EXISTS Y_KVS
Ubiquity: Encountered exception %@ with userInfo %@ while dropping tables from store: %@
ATRANSACTION
ACHANGE
ATRANSACTIONSTRING
UPDATE OR FAIL %@ set %@=0 where %@ = '%@'
v32@?0@"NSManagedObjectID"8@"NSManagedObjectID"16^B24
ZCHANGETRACK
ZCHANGETRACKHISTORY
select sql from sqlite_master where name = 'ZCHANGETRACK'
ZCHANGETIMESTAMP FLOAT
ZBUNDLEID VARCHAR
ZCONTEXTNAME VARCHAR
ZPROCESSID VARCHAR
Unable to determine if old history table 1 Exists - %s
select sql from sqlite_master where name = 'ZCHANGETRACKHISTORY'
 ZCHANGETRACKHISTORYCHANGETYPE INTEGER
ZCHANGETRACKHISTORYENTITY INTEGER
ZCHANGETRACKHISTORYENTITYVERSION INTEGER
ZCHANGETRACKINGHISTORYTRANSACTIONID INTEGER
ZCHANGETRACKHISTORYTOMBSTONE BLOB
ZCHANGETRACKEHISTORYNTITYCOLUMNS BLOB
Unable to determine if old history table 2 Exists - %s
ZCHANGE
ZTRANSACTION
select sql from sqlite_master where name = 'ZCHANGE'
ZENTITY INTEGER, ZENTITYPK INTEGER
ZCHANGETYPE INTEGER
ZCOLUMNS BLOB
ZTRANSACTIONID INTEGER
select sql from sqlite_master where name = 'ZTRANSACTION'
 ZBUNDLEID VARCHAR
ZTIMESTAMP FLOAT
DROP TABLE ZCHANGETRACK
DROP TABLE ZCHANGETRACKHISTORY
DROP TABLE ZCHANGE
DROP TABLE ZTRANSACTION
SELECT COUNT(Z_PK) FROM %@ WHERE %@ = %@
SELECT Z_PK FROM %@ WHERE %@ = '%@'
ALTER TABLE %@ ADD Z%@%lu BLOB;
select sql from sqlite_master where name = '%@'
Unable to determine if tombstones for change table - %s
ALTER TABLE %@ ADD Z%@ INTEGER;
SELECT MAX(%@) FROM %@ WHERE %@ >= 16000
DELETE FROM %@ WHERE Z_PK <= %@
DELETE FROM %@ WHERE %@ <= %@
externalRef
unable to generate primary keys for transaction
@"NSNumber"16@?0@"NSString"8
v24@?0@"NSMutableDictionary"8^B16
v32@?0@"NSDictionary"8Q16^B24
Relationships are not supported with NSBatchInsertRequest
unable to generate primary keys for batch insert
mandatory property not set
unable to generate primary keys
SELECT count(*) FROM 
SELECT count(*) FROM %@ LIMIT 1
SELECT ENTITYID, PrimeKey FROM %@
ENTITYID
PrimeKey
%lld
DELETE FROM %@ WHERE %@ IN %@
UPDATE %@ SET Z%@ = %lld
INSERT INTO %@ (%@) SELECT %@ FROM %@
An internal error occurred while configuring migration functions in the SQLite database.
INSERT INTO Z_METADATA (Z_VERSION) VALUES (999)
DELETE FROM Z_METADATA where Z_VERSION = 999
database connection must not be nil here
connection %p created snapshot:
ss %@ value: 
pointer value:%@
pointer: %p
connection %p adopting snapshot:
ss value: %@
pointer value:%@
pointer: %p
sqlite3_snapshot_open failed with %ld
sqlite3_snapshot data was unexpectedly NULL
_registerNewQueryGenerationSnapshot failed to adopt query generation with error %d
Connection can't register generation: Uncaught exception: %@
B32@?0@8Q16^B24
Failed to geta currentQueryGeneration: %@
connection %p attempting to reopen snapshot: %p
Attempt to reopen sqlite3_snapshot_open failed %d
Failed to free sqlite3_snapshot
isWriter
Invalid class type '%@' for lock_proxy_file pragma value, must be an NSNull or NSString
Constraint violation
Constraint violation: %s
no message
error during SQL execution : %s
success
T@"CDDCloudKitMessage",R,N,V_message
TB,R,N,V_success
NSCoreDataNow
NSCoreDataPrependExternalReferenceMarker
NSCoreDataLike
NSCoreDataStringSearch
NSCoreDataToUpper
NSCoreDataToLower
NSCoreDataMatches
NSCoreDataStringCompare
NSCollateNoCase
NSCollateNumericallyNoCase
NSCollateLocaleSensitive
NSCollateLocaleSensitiveNoCase
NSCollateFinderlike
NSCoreDataTriggerUpdateAffectedObjectValue
NSPersistentHistoryBatchDeleteUpdateTrigger
NSPersistentHistoryBatchDeleteUpdateTriggerDataBlobOperator
NSCoreCanonical
NSCoreToUpper
NSPersistentHistoryMigrateUpdates
NSCoreDataNow: requires no arguments
NSCoreDataPrependExternalReferenceMarker: malloc failure
NSCoreDataPrependExternalReferenceMarker: wrong number of parameters
NSCoreDataLike: variant must be an integer in the range [0,3]
NSCoreDataLike: requres 3 arguments (value, pattern, variant)
NSCoreStringSearch: requires 4 arguments (string1, string2, flags, localized)
NSCoreDataTo(Uppercase|Lowercase): requires one argument
NSCoreDataCanonical: requires one argument
NSCoreDataMatches: variant must be an integer in the range [0,3]
NSCoreDataMatches: requres 3 arguments (value, pattern, variant)
NSCoreDataStringCompare: unknown operation type
NSCoreDataStringCompare: incorrect number of arguments
NSPersistentHistoryBatchDeleteUpdateTrigger: malloc failure
_NSPersistentHistoryBatchDeleteUpdateTriggerDataBlobOperator: malloc failure
NSPersistentHistoryMigrateUpdates: malloc failure
q24@?0@"NSNumber"8@"NSNumber"16
CloudKit/NSCKExportMetadata
identifier = %@
%@: Set system fields (%lu) on object with ID: %@ from record with recordID: %@
-[PFCloudKitExportContext modifyRecordsOperationWithID:finishedForStore:withSavedRecord:deletedRecordIDs:operationError:managedObjectContext:error:]_block_invoke
%@: Can't find metadata for recordID '%@' even though it was supposedly saved in these records: %@
%@: Can't find record for recordID '%@' even though it was supposedly saved in these records: %@
Failed to fetch record metadata for saved records: %@
B32@?0@"NSCKMirroredRelationship"8@"CKRecord"16^@24
CloudKit/%@
T@"NSArray",R,N,V_operations
T@"NSArray",R,N,V_writtenAssetURLs
exportMetadataIdentifier
T@"NSString",R,N,V_exportMetadataIdentifier
Join being created outside a fetch scope for keypath %@ entity %@
subqueryCollectionContext
Join being created inside an update scope for keypath %@ entity %@
source (%@, %@), destination (%@, %@), correlation (%@)
INNER 
LEFT OUTER 
JOIN 
 ON 
 INNER
 LEFT OUTER
 JOIN 
Unsupported property %@ in update
Unsupported property %@ in update - no joins allowed here
keypathExpressionDestinationRelationship
transient property used in fetch request
to-many key not allowed here
multiple to-many keys not allowed here
this should be inside a fetch or an update
keypaths (joins) not supported in batch update statements
invalid keypath : %@
invalid keypath %@
ambiguous keypath %@
found
propertyDescription
Ambiguous keypath %@
keypath %@ not found in entity %@
LastKeyPathWasTransientProperty
Keypath containing KVC aggregate where there shouldn't be one; failed to handle %@
Bad keypath: too many joins for an index
Bad keypath: can't find property
Unable to generate SQL for keypath
Bad keypath: indexes may not contain to many relationshps
SELECT clauses in queries with GROUP BY components can only contain properties named in the GROUP BY or aggregate functions (%@ is not in the GROUP BY)
substitutePK
TB,N,V_substitutePK
Unable to generate SQL - non-constant expression for limit substitution.
Unable to generate SQL - non-NSNumber value for limit substitution.
Invalid variable substitution - multiple values not supported for limit %@
 LIMIT %@
 LIMIT -1
CoreData: warning: Fetch Limit is too large, please set it to a value less than or equal to NSIntegerMax
 LIMIT %lu
%@_%d%@
REFLEXIVE
FOK_REFLEXIVE
cloudKitMachServiceName
com.apple.coredatad
storeDirectoryPath: %@
machServiceName: %@
storeDirectoryPath
machServiceName
T@"NSString",&,N,V_storeDirectoryPath
T@"NSString",&,N,V_machServiceName
Failed to save import operation: %@
Error fetching previous server change token for zone: %@
v16@?0@"CKRecord"8
v24@?0@"CKRecordID"8@"NSString"16
v44@?0@"CKRecordZoneID"8@"CKServerChangeToken"16@"NSData"24B32@"NSError"36
%@ - Importing updated records:
Deleted RecordIDs:
-[PFCloudKitImporterZoneChangedWorkItem newMirroringResultByApplyingAccumulatedChanges:]_block_invoke_2
Unable to fetch zone metadata for zone: %@
Failed to save changes from import: %@
Failed to purge mirrored relationships during import: %@
Failed to fetch import operation with identifier '%@': %@
Finished importing changes for request: %@
-[PFCloudKitImporterZoneChangedWorkItem newMirroringResultByApplyingAccumulatedChanges:]_block_invoke
%@ - Exception thrown during import: %@
Request '%@' was cancelled because the store was removed from the coordinator.
Failed to read attributes of asset file at URL: %@
-[PFCloudKitImporterZoneChangedWorkItem addUpdatedRecord:]
Failed to copy asset to URL: %@
Unable to complete import because the requested operation would violate the in memory threshold of '%@' bytes. Estimated size of the import is '%lu' bytes.
%@ - Fetch finished with error:
-[PFCloudKitImporterZoneChangedWorkItem fetchOperationFinishedWithError:completion:]_block_invoke
Unable to delete processed asset file: %@
-[PFCloudKitImporterZoneChangedWorkItem removeDownloadedAssetFiles]
T@"NSArray",R,N,V_changedRecordZoneIDs
resolvedRelationships
T@"NSArray",R,N,V_resolvedRelationships
importOperationIdentifier
T@"NSUUID",R,N,V_importOperationIdentifier
assetPathToSafeSaveURL
T@"NSDictionary",R,N,V_assetPathToSafeSaveURL
encounteredErrors
T@"NSArray",R,N,V_encounteredErrors
updatedRecords
T@"NSArray",R,N,V_updatedRecords
recordTypeToDeletedRecordID
T@"NSDictionary",R,N,V_recordTypeToDeletedRecordID
allRecordIDs
T@"NSArray",R,N,V_allRecordIDs
totalAssetBytes
TQ,R,N,V_totalAssetBytes
fetchedZoneIDToChangeToken
T@"NSDictionary",R,N,V_fetchedZoneIDToChangeToken
fileHandle
storeFileProtectionClass
storeType
T@"NSString",R,N,V_bundleIdentifier
storeFileHandle
T@"NSFileHandle",R,N,V_storeFileHandle
T@"NSString",R,N,V_storeFileProtectionClass
T@"NSString",R,N,V_storeType
T@"NSString",R,N,V_storeConfigurationName
T@"NSString",R,N,V_containerIdentifier
Unable to generate optimized model (sql model generation failed %@)
Unknown model offset is in use, this method should be updated to include it: %d
Unsupported join (offsets not allowed in updates)
Invalid SQL (must specify a limit with an offset)
Unable to generate SQL - non-constant expression for offset substitution.
Unable to generate SQL - non-NSNumber value for offset substitution.
 OFFSET %@
 OFFSET %lu
Unsupported property type for index.
Can't mix and match collation types.
Can't create an index with no name
NSIndexName
NSIndexElements
NSPartialIndexPredicate
<NSFetchIndexDescription : (%@:%@, elements: %@, predicate: %@)>
Can't set an index name to nil
IndexDescription
Can't change an collation type in a multi-element index
Index
elements
partialIndexPredicate
T@"NSPredicate",C
Unsupported join (ordering by mtm not allowed in updates): %@
Unsupported join (ordering by tm not allowed in updates): %@
ORDER BY
unsupported NSSortDescriptor (comparator blocks are not supported)
 COLLATE NSCollateNoCase 
 COLLATE NSCollateNumericallyNoCase 
 COLLATE NSCollateLocaleSensitive 
 COLLATE NSCollateLocaleSensitiveNoCase 
 COLLATE NSCollateFinderlike 
unsupported NSSortDescriptor selector: %@
 DESC
*** vm_allocate(size=%lld) failed (error code=%d)
Unable to allocate VM Memory
VMErrorCode
*** vm_deallocate(size=%lld) oldSize= %lld, failed (error code=%d)
Unable to deallocate VM Memory
*** vm_deallocate(size=%lld), failed (error code=%d)
sql connection fetch time: 
[31m%.4f
[0ms
sql connection fetch time: %.4fs
exception raised during multi-threaded fetch %@ (%@)
unidentifiable exception during multi-threaded fetch
result array has %lu entries, but we fetched %d rows
fetch using %@ returned %lu rows
 with values: %@
total fetch execution time: 
[31m%.4f
[0ms for %d rows.
total fetch execution time: %.4fs for %d rows.
Fetch cancelled.  Total fetch execution time: 
[31m%.4f
[0ms.
Fetch cancelled.  Total fetch execution time: %.4fs.
exception %@ raised processing result of multi-threaded fetch (%@)
unidentifiable processing result of multi-threaded fetch
exception %@ raised processing result of multi-threaded fetch while prepopulating objects (%@)
unidentifiable processing result of multi-threaded fetch while prepopulating objects
NSXPCStoreEntitlementNames
NSXPCStoreDaemonize
NSXPCStoreServiceName
NSXPCStoreListener
Can't create server - misconfigured server : %@, %@
application-identifier
Can't create server - misconfigured server : no service name supplied
Options dict contains service name and anonymous listener, using name
Can't create server - unable to load model
com.apple.CoreData.NSXPCStoreServer.%p
Attempting to create non-mach listener with service name: %@
Can't create server - misconfigured server, missing modelURL
%@: Listening
%@: Stopping Listening.
%@: Unable to find model
Can't create coordinator - attempting SQLite recovery
Can't create coordinator - just failing
Unable to load store: %@
 Server Connection interrupted.
 Server Connection invalidated.
%@ - Incoming connection: %@
Unable to create stack
Unable to create connection context
NSConnectionInfo
Starting event handler
XPCStore server handling request: %@
Policy rejected connection from client: %@
Token mismatch
Metadata
Fetch
Save
Fault
Rel fault
Request notification name
Illegal input: %u from connection %p
SQLite exception on server: %@, recovery to be attempted
SQLite exception on server: %@, no recovery attempt
SQLite exception on server: %@, no recovery attempt (weird)
Unexpected Core Data exception on server: %@
Unexpected exception on server: %@
Unexpected unknown exception on server
Done event handler
request failed, store identifier mismatch
request failed, insufficient permission
request failed, exception raised during processing
SQLite error on server: %@, recovery being attempted
SQLite error on server: %@, no recovery being attempted
request failed (no result, no error)
Reply handler threw: %@, %@, %@
Request failed, threw in request handler logic (check console for details)
CoreData: XPC: Reply handler threw unknown exception.
Request failed, threw in request handler logic (unknown exception)
Sending reply %p, %p
Sent reply
Failed to set query generation on context: %@ -> %@ (%@)
Got oid  request for %@
Returning result %@
NSMetadata
Got save request: %@
Updating metadata
locked
Locking objects :%@
Not locking %@ because it's not in the db
Locking %@
Deleting object :%@
Inserting object with ID %@
Made save request: %@
Got relationship fault request: %@
Can't fulfill relationship fault request: can't find query generation: %@
unrecognized query generation
generation
Attempting to fire fault for %@, %@
originalRequest
Wrong in all kinds of ways. Less colloquially, that should be an object ID, but it's an instance of %@ instead
Fired relationship fault %@ - %@, returning values: %@
Attempted to fire relationship fault %@ - %@, no such luck
Attempting to fire fault for %@
Can't fulfill fault request: can't find query generation: %@
target
missing objectID
Got a fetch request %@
Can't fulfill fetch request: can't find query generation: %@
Which had result %d (%d)
Which archived %d (%d)
Fetch failed returning error %@
Fetch failed with no error.
no store
Got metadata %@
what on earth happened?
Which archives to %@
Got pull changes result %@
Got queryGeneration %@
Reopened generation %@
Unable to reopen generation %@
Bad parameter to reopen generation %@
Attempting to free nothing (or too many things) %@
Nil batch update request
Which had result %@
Nil batch delete request
Nil persistent history request
Got historyToken %@
%@, attributeType %lu , attributeValueClassName %@, derivationExpression %@, filteringPredicate %@, preserveValueOnDeletionInPersistentHistory %@
NSDerivationExpression
NSFilteringPredicate
.@sum
sum:
Can't set a default value for a derived attribute
offending property
Can't set renaming identifiers for derived attributes
expression failed to generate keypaths
Can't get keypaths for derived attribute validation
predicate failed to generate keypaths
Bad keypath for derived property (unresolved variable)
Bad keypath for derived property (misplaced operator)
Bad keypath for derived property (missing keypath component)
Bad keypath for derived property (attribute in non-terminal location not followed by operator)
Bad keypath for derived property (attribute has multiple keys following)
Bad keypath for derived property (unsupported property type in keypath)
derivationExpression
Unknown request class: %@
Request '%@' was cancelled because there is already a pending request of type '%@'.
Dequeue called during an active request: %@
requestFinished called with a different request than the active request: %@
Called with: %@
requestFinished called without an active request: %@
pendingImportRequest
T@"NSCloudKitMirroringImportRequest",R,N,V_pendingImportRequest
pendingExportRequest
T@"NSCloudKitMirroringExportRequest",R,N,V_pendingExportRequest
pendingSetupRequest
T@"NSCloudKitMirroringDelegateSetupRequest",R,N,V_pendingSetupRequest
pendingDelegateResetRequest
T@"NSCloudKitMirroringDelegateResetRequest",R,N,V_pendingDelegateResetRequest
pendingResetRequest
T@"NSCloudKitMirroringResetZoneRequest",R,N,V_pendingResetRequest
pendingFetchRecordsRequest
T@"NSCloudKitMirroringFetchRecordsRequest",R,N,V_pendingFetchRecordsRequest
pendingResetMetadataRequest
T@"NSCloudKitMirroringResetMetadataRequest",R,N,V_pendingResetMetadataRequest
activeRequest
T@"NSCloudKitMirroringRequest",R,N,V_activeRequest
TRANSACTION
BUNDLEID
PROCESSID
CONTEXTNAME
AUTHOR
QUERYGEN
CHANGES
Transaction
transactionNumber
timestamp
bundleID
processID
author
changes
BUNDLEIDTS
PROCESSIDTS
CONTEXTNAMETS
AUTHORTS
CHANGE
ENTITY
ENTITYPK
CHANGETYPE
COLUMNS
TOMBSTONE
TRANSACTIONID
changeID
changedObjectID
changedEntity
TRANSACTIONSTRING
NAME
NSPersistentHistoryTrackingKey only supports a max of 100 tombstones per entity in the Model
v24@?0@"NSSQLEntity"8@"NSMutableOrderedSet"16
%@%lu
TransactionTimestampIndex
TransactionAuthorIndex
PersistentHistory
PersistentFetchHistory
%@: Exporter / importer finished after %d tries. Allowing store to deallocate.
-[PFCloudKitStoreMonitor pfcloudstoremonitor_is_holding_your_store_open_waiting_for_cloudkit_activity_to_finish]
%@: Exporter / importer didn't tear down after 5 seconds, retrying (%d).
Called after the store is dead. This method needs to be called inside a performBlock on the store monitor: %@
monitorGroup
T@"NSObject<OS_dispatch_group>",R,N,V_monitorGroup
monitoredCoordinator
T@"NSPersistentStoreCoordinator",R,W,N,V_monitoredCoordinator
monitoredStore
T@"NSPersistentStore",R,W,N,V_monitoredStore
retryCount
Ti,R,N,V_retryCount
timeoutSeconds
Ti,R,N,V_timeoutSeconds
declaredDead
TB,R,N,V_declaredDead
storeIsAlive
TB,R,N,V_storeIsAlive
storeIdentifier
T@"NSString",R,N,V_storeIdentifier
causedByError
T@"NSError",R,N,V_causedByError
<NSPersistentHistoryToken - %@>
%@ is not supported for %@, use %@
q24@?0@"NSString"8@"NSString"16
Tokens have different number of stores.
Tokens have different set of stores.
v32@?0@"NSString"8@"NSNumber"16^B24
NSPersistentHistoryTokenDictionary
T@"NSEntityDescription",R,D
T@"NSManagedObjectID",R,D
Z_%@_%@
%@%@_MIN, %@_MAX
%@NEW.%@, NEW.%@
%@%@, %@
%@%@ NOT NULL
CREATE VIRTUAL TABLE IF NOT EXISTS %@ USING RTREE (Z_PK INTEGER PRIMARY KEY, %@)
CREATE TRIGGER IF NOT EXISTS %@_INSERT AFTER INSERT ON %@ FOR EACH ROW BEGIN INSERT OR REPLACE INTO %@ (Z_PK, %@) VALUES (NEW.Z_PK, %@) ; END
CREATE TRIGGER IF NOT EXISTS %@_UPDATE AFTER UPDATE ON %@ FOR EACH ROW BEGIN DELETE FROM %@ WHERE Z_PK = NEW.Z_PK ; INSERT INTO %@ (Z_PK, %@) VALUES (NEW.Z_PK, %@) ; END
INSERT OR REPLACE INTO %@ (Z_PK, %@) SELECT Z_PK, %@ from %@ where %@
T@"NSString",R,&,N,V_tableName
<%@ %@ (%@)>
constrained
TB,N,GisConstrained
Unable to resolve variable expression: %@
Can't generate select target token for expression: %@
Constant select targets must be values, not collections
Can't generate select target token for constant: %@
Can't generate select target token for fetch request expression: %@
Can't generate SQL for ternary expression: %@
Currently unsupported (%@), try again later
Unsupported value passed to valuesToFetch: (%@) not supported
 AS %@
%@{%@ %d-%qd-%qi
 %@=NULL
 %@=<NSData len=%lu>
 %@="%@"
 %@=%@
 %@=%qd
 %@=%u
 and to-manys=%p}
unexpected key found for: %@
COUNT( 
XPCConnectionManager:%p
Something has gone badly awry initializing the XPC connection pool: %@
 NSSQLConnectionManager tried to blow a lock
manager sendMessageWithContext: unable to checkout connection.
manager sendMessageWithContext: failed with exception (how? it should never throw): %@
manager sendMessageWithContext failed with unknown exception
disconnectAllConnections failed with excception: %@
disconnectAllConnections failed with unknown excception
maxConnections
TQ,R,N,V_maxConnections
availableConnections
T@"NSArray",R,N,V_availableConnections
Unknown predicate operator type parameter
illegal comparison with NULL
IS NULL
IS NOT NULL
Unable to generate SQL for predicate (%@) (problem on LHS)
Unable to generate SQL for predicate (%@) (problem on RHS)
Unable to generate SQL for predicate (%@) (problem with operator)
You really shouldn't be here
NSCoreDataStringCompare(
 , %d, %lu, %d)
%lu) 
Unimplemented SQL generation for predicate (%@)
Unimplemented SQL generatio for predicate (%@)
 NSCoreDataStringSearch(
%lu, %u)
unimplemented SQL generation for predicate (%@).
Invalid input string
Unknown error during string conversion
Malformed string (%@)
Bad string
Malformed string 2 (%@)
%@%C
Unsupported join (not allowed in updates): %@
Unsupported clause (not allowed in updates): %@.
 IN (SELECT 
unimplemented SQL generation for predicate : (%@) (bad LHS)
unimplemented SQL generation for predicate : (%@) (bad RHS)
unimplemented SQL generation for predicate : (%@) (LHS and RHS both keypaths)
 IN 
unimplemented SQL generation for predicate : (%@)
 BETWEEN 
Unimplemented SQL generation for predicate : (%@)
Unsupported predicate, LHS of boundedBy: must be a keypath
Unsupported predicate, LHS of boundedBy: is a bad keypath a keypath
Unsupported predicate, LHS of boundedBy: has a keypath (can't find %@)
Malformed keypath: non-terminal attribute %@
Unsupported predicate, LHS of boundedBy: does not terminate with a location attribute
Bad LHS attribute, missing derived lat/long names
Unsupported predicate, LHS of boundedBy: does not terminate with a location
Unsupported predicate, LHS of boundedBy: can't find location attribute
%@.Z_PK IN 
(%@) 
ALL modifier is not implemented
can't use NULL on left hand side
 NSCoreDataLike(
 NSCoreDataMatches(
Unknown/unsupported comparison predicate operator type
Unable to generate where clause for predicate (%@) (unknown problem)
%@: Unable to set query generation on moc: %@
-[PFCloudKitExporter exportIfNecessaryWithCompletion:]_block_invoke_2
Unable to read the last history token: %@
%@: Exporting changes since: %@
%@: Got an inconsistent history token back: %@
v32@?0@"NSArray"8@"NSArray"16@"NSError"24
Modify records finished: %@
-[PFCloudKitExporter exportOperationFinished:withSavedRecords:deletedRecordIDs:operationError:completion:]
Failed to fetch metadata while trying to update the last history token entry: %@
-[PFCloudKitExporter exportOperationFinished:withSavedRecords:deletedRecordIDs:operationError:completion:]_block_invoke_2
Failed to save record name updates: %@
%@ - Failed to update metadadata after operation finished (%@): %@
Failed to delete asset file: %@
-[PFCloudKitExporter exportOperationFinished:withSavedRecords:deletedRecordIDs:operationError:completion:]_block_invoke
Metadata Inconsistency: Missing metadata for record: %@
%@ - Failed to fetch metadata for post-export update: %@
-[PFCloudKitExporter updateMetadataForSavedRecords:deletedRecordIDs:inStore:withManagedObjectContext:]
T@"PFCloudKitExporterOptions",R,C,N,V_options
workQueue
T@"NSObject<OS_dispatch_queue>",R,N,V_workQueue
T@"NSCloudKitMirroringRequest",R,N,V_request
T@"NSObject<PFCloudKitExporterDelegate>",W,N,V_delegate
exportContext
T@"PFCloudKitExportContext",R,N,V_exportContext
%s <%p> on entity '%@' with sql text '%@'
cachedStatementInfo
T@"NSCachedFetchRequestInfo",&,N,V_cachedStatementInfo
trackChangedRowCount
TB,N,V_trackChangedRowCount
Z_ENT
Z_FOK
_ent
_opt
Z_METADATA
Z_VERSION
Z_UUID
Z_PLIST
Z_MODELCACHE
Z_CONTENT
Z_PRIMARYKEY
Z_SUPER
Z_MAX
%c%@
COUNT(%@)
COUNT(%@.%@)
@total
Aggregate functions need to work on attributes: %@
Unsupported KVC function in trailing keypath %@, %@
Can't have a non-relationship collection element in a subquery%@
Bad collection keypath (%@) can't find property named (%@) 
Only allowed one toMany/manyToMany relationship in subquery expression collection (%@)
Bad collection keypath in subquery %@ (attribute in non-terminal position)
Unsupported subquery with multiple joins in update columns %@
Unsupported subquery collection type (%@)
Subquery expressions not allowed in indexes
Unsupported subquery (too many functions): %@
.@min
.@max
.@avg
Unsupported subquery (non-aggregate not allowed in select or update column): %@
Unknown predicate type
pflogFaultLog
T@"NSObject<OS_os_log>",R
Failed to acquire permanent objectIDs during schema generation: %@
An example core data string
Some example data
http://www.apple.com
T@"NSManagedObjectContext",R,N,V_managedObjectContext
T@"NSManagedObjectModel",R,N,V_model
T@"NSString",R,N,V_configurationName
T@"NSRelationshipDescription",R,N,V_relationship
sqlModel
Failed to fetch metadata for database: %@
-[PFCloudKitImporter importIfNecessaryWithCompletion:]_block_invoke
v16@?0@"CKRecordZoneID"8
v16@?0@"CKServerChangeToken"8
v28@?0@"CKServerChangeToken"8B16@"NSError"20
%@: Database fetch for request: %@ failed with error: %@
-[PFCloudKitImporter databaseFetchFinishWithContext:error:completion:]
%@: Error fetching database metadata update for request: %@
-[PFCloudKitImporter databaseFetchFinishWithContext:error:completion:]_block_invoke_2
%@: Import request finished with no work to do: %@
-[PFCloudKitImporter databaseFetchFinishWithContext:error:completion:]_block_invoke
%@: Processing work items: %@
-[PFCloudKitImporter processWorkItemsWithCompletion:]
T@"PFCloudKitImporterOptions",R,C,N,V_options
workItems
T@"NSArray",R,N,V_workItems
workItemResults
T@"NSArray",R,N,V_workItemResults
missing variable binding for %@
bad substitution variable for %@, must be a constant value
bad substitution variable for %@, must not be a collection
bad substitution variable for %@, must be a collection
bad substitution variable for %@, must be a collection of objects or objectIDs
oid = %@ [oid class] = %s expecting entity %@
T@"NSSQLFetchRequestContext",R,N,V_parentContext
T@"NSFetchRequest",R,N
fetchStatement
T@"NSSQLiteStatement",&,N
T@"NSFetchRequest",R,N,V_originalRequest
storeIsUbiquitized
TB,R,N,V_storeIsUbiquitized
fileProtectionLevel
Ti,R,N,V_fileProtectionLevel
T@"NSSQLModel",R,N,V_sqlModel
sqlEntityForFetchRequest
fetchPlan
T@"_PFFetchPlanHeader",R,N,V_fetchPlan
objectIDsToRegisterWithContext
objectsToAwaken
isFaultRequest
TB,N,V_isFaultRequest
shouldUseBatches
TB,R,N,V_shouldUseBatches
isUsingCachedStatement
TB,N,V_isUsingCachedStatement
prefetchingSubstitutionVariables
T@"NSDictionary",&,N,V_prefetchingSubstitutionVariables
faultsThatWereFired
T@"NSArray",R,&,N,V_resultFaultsThatWereFired
%d%@
NSPrimaryKey64
NSKey
NSRelatedNodes
Can't find entity %@ in model %@
Coalesced prefetch keypaths to : %@
Process fetch request got nil result (check system log for details).
Process fetch request got %d results.
Source object %@ does not exist for relationship fault.
Source object does not match restricting predicate, so returning an error
Threw evaluating predicate for %@: %@
relationship name
self == %@
%@ IN %K
%K == %@
Prefetching inverse to-one relationship "%@".
Prefetched for many-to-many relationship "%@".  Got %lu rows
Which means oidSets %@
Prefetched for one-to-many relationship "%@".  Got %lu rows
Decoding prefetched rows for fetch %@
Prefetched %@/%@ and got no results, stopping now
Prefetched %@/%@ and got %@
swallowed an exception during prefetching of %@, %@: %@
swallowed an exception during XPC store prefetching of %@, %@: %@
Prefetched for source entity %@, key '%@'.  Got data with length %lu.
Recursively prefetching subkeys %@ of fetch %@ using OIDs %@ for objects %@
swallowed an exception during recursive prefetching for %@, %@: %@
swallowed an exception during XPC store recursive prefetching of %@, %@: %@
Done prefetching for %@, %@
Process fetch request aborting (predicate is nil)
Process fetch request returning no results (predicate is false)
Saving.
Inserted = %@
Updated = %@
Deleted = %@
Request description was nil.
Request
Prefetching keypaths %@, for fetch %@, sources %@
Prefetching %@, subkeypaths = %@
sourceAttributeName
Index beyond buffer: %ld, %ld, %ld, %ld
Unsupported property type: %@
Unsupoorted type for buffer allocated dictionary: %@
BufferAllocations Result Object has an invalid Object ID
NSManagedObjectIDURI
NSConnectionContext
XPC: Possible API misuse: Unable to find object for managed object URI %@, returning null instead
XPC: Missing oid uri
NSMOIDArchivingToken escaping un-de-tokenized (secured %d).
_sourceModelForVersionHashes: testing model at path '%@'
 Choosing model at path '%@'
sourceModelForStoreAtURL: Testing models searched via resourceBundles
sourceModelForStoreAtURL: Testing models searched via mainBundle
sourceModelForStoreAtURL: Testing model cached in database file
 Choosing model from cache table in db at '%@'
sourceModelForStoreAtURL: Testing models searched via allBundles
sourceModelForStoreAtURL: allBundles is %@
sourceModelForStoreAtURL: Testing models searched via allFrameworks
sourceModelForStoreAtURL: allFrameworks is %@
Last ditch review of models with skewed hashing
Can't find model for source store
force
Can't find or automatically infer mapping model for migration
Can't find mapping model for migration
.migrationdestination_41b5a6b5c6e848c462a8480cd24caef3
_NSAutomaticMigrationResourceBundlesOption
CoreData: Schema migration (policy)
Unable to delete file (backup external data references URL)
Migration source and destination URLs must be different
sourceURL
destinationURL
(migration) Failed to remove orphaned, partially migrated store file %@: %@
(migration) leaving incompletely migrated store on disk after automatic migration failure. (%@)
NSTemporaryObjectID
NSTemporaryObjectID_default
%s_%x
%@://%@/%@/t%@
Contents
Model
strings
Entity/
Property/
/Entity/
ErrorString/
An instance of %@ requires a non-nil fetchRequest and managedObjectContext
An instance of %@ requires a fetch request with sort descriptors
NSDiffableDataSourceSnapshot
_PFDiffableDataSourceSnapshot
Difference delegate method is not supported when fetched results controller is configured with a sectionNameKeyPath
%@ does not support both change tracking and fetch request's with NSDictionaryResultType
NSFetchedResultsController: cannot access fetched objects before -performFetch:
NSFetchedResultsController: no section at index %lu in sections list
cannot access fetched objects before -performFetch:
no section at index %lu
NSFetchedResultsController: no object at index %lu in section at index %lu
no object at index %lu in section at index %lu
invalid Section Index offset%li
Index title at %li is not equal to '%@'
T@"NSFetchRequest",R,N,V_fetchRequest
sectionNameKeyPath
T@"NSString",R,N,V_sectionNameKeyPath
cacheName
T@"NSString",R,N,V_cacheName
T@"<NSFetchedResultsControllerDelegate>",N
fetchedObjects
sectionIndexTitles
sections
41b5a6b5c6e848c462a8480cd24caef3
The fetched object at index %lu has an out of order section name '%@. Objects must be sorted by section name'
(%@) %@
sectionCount
Fetching ERROR during section computation with request = %@ and error = %@ and userInfo = %@
(NSFetchedResultsController) A section returned nil value for section name key path '%@'. Objects will be placed in unnamed section
q24@?0@"_PFChangeInfo"8@"_PFChangeInfo"16
(NSFetchedResultsController) rebuilding section caches
(NSFetchedResultsController) error refetching objects after context update: %@
B24@?0@"_PFChangeInfo"8@"NSDictionary"16
Serious application error.  An exception was caught from the delegate of NSFetchedResultsController during a call to -controllerDidChangeContent:.  %@ with userInfo %@
Serious application error.  Unidentifiable exception was caught from the delegate of NSFetchedResultsController during a call to -controllerDidChangeContent:.
 (%@): couldn't read cache file to update store info timestamps
 (%@): error writing section cached info at %@ with error %d
 (%@): couldn't create section info cache directory at %@ : %@
 (%@): couldn't create section info file at %@ : %d
.CoreDataCaches
SectionInfoCaches
Name: %@ offset: :%lu count: %lu
sectionInfo
d69e6c783a242772974cfc99189691b88e9d37c3
Can't generate intermediate for ternary expression predicate.
Can't generate intermediate for ternary expression predicate (unknown type)
Ternary expression not supported as index component
(CASE (
Can't generate SQL for ternary expression predicate.
) when 1 then (
Can't generate SQL for ternary expression trueExpression.
) else (
Can't generate SQL for ternary expression falseExpression.
) end)
PFCloudKitMetadataModelVersionHashesKey
PFCloudKitMetadataFrameworkVersionKey
PFCloudKitMetadataNeedsMetadataMigrationKey
com.apple.CoreData.cloudkit.metadata.transformer
PFCloudKitMetadataClientVersionHashesKey
ZENTITYNAME
cdEntityName
ZISDELETED
needsDelete
ALTER TABLE %@ ADD COLUMN %@ INTEGER
integerValue
CREATE TABLE ANSCKRECORDZONEMETADATA
CREATE TABLE ANSCKDATABASEMETADATA
CREATE TABLE ANSCKMETADATAENTRY
dateValue
lastFetchDate
Invalid configuration for migrating the existing metadata entity to the new column: %@:%@ - %@
ALTER TABLE %@ ADD COLUMN %@ %@
Skipping migration for '%@' because it already has a column named '%@'
+[PFCloudKitMetadataModel checkAndRepairSchemaOfStore:withManagedObjectContext:error:]_block_invoke
v32@?0@"NSString"8@"NSString"16^B24
Exception caught during execution of migration statement for cloudkit metadata tables %@ with userInfo %@
Exception caught during execution of migration statement for cloudkit metadata tables %@
records
mirroredRelationships
_NSStoreAncillaryModelVersionHashesMetadataKey
%K != nil
ZNSCKEXPORTEDOBJECT
ZNSCKEXPORTMETADATA
ZNSCKEXPORTOPERATION
ZNSCKIMPORTOPERATION
ZNSCKIMPORTPENDINGRELATIONSHIP
ALTER TABLE %@ RENAME COLUMN %@ TO %@
Unable to find attribute to migrate to '%@' from '%@' on entity: %@
ZNSCK
NOT (entityId IN %@)
relatedEntityName
Trying to return failure without an error set.
DELETE FROM %@ WHERE Z_ENT = %@
UPDATE %@ SET Z_ENT = %@
Exception caught during cleanup of cloudkit metadata primary keys %@ with userInfo %@
Exception caught during cleanup of cloudkit metadata primary keys %@
Found record metadata that points to missing entity: %@
+[PFCloudKitMetadataModel checkForCorruptedRecordMetadataInStore:inManagedObjectContext:error:]
Found record metadata that points to an entity that is no longer part of the store's configuration: %@
Successfully purged record metadata during migration due to corrupted metadatas.
Failed to purged corrupted record metadata during migration: %@
NSCKExportMetadata
NSCKExportedObject
NSCKExportOperation
exportUUID
operationUUID
sortIndex
status
exportMetadata
NSCKImportOperation
NSCKImportPendingRelationship
importDate
changeTokenBytes
pendingRelationships
recordName
relatedRecordName
relationshipName
isPending
NSCKMirroredRelationship
statusNum
changeToken
stringValue
transformedValue
boolValueNum
databaseName
databaseScopeNum
hasSubscriptionNum
currentChangeToken
ckRecordZoneName
ckOwnerName
hasRecordZoneNum
rootEntityId
uniqueIdentifier
recordZones
allowedTopLevelClasses
T@"NSArray",R,C
%@ : %@ -> %@
Unrecognized destination property type in transform
transform
Invalid constant expression type for property type in transform
Unrecognized source property type in transform
Properties cannot be renamed in stores that are used with CloudKit. Cannot rename '%@.%@' to '%@.%@'.
NSCoreDataPrependExternalReferenceMarker(length(%@), %@)
Invalid source property type in transform
Unsupported value expression type in transform
Entity mapping includes property transform with unresolved prerequisite
pendingTransforms
CloudKit integration forbids renaming '%@' to '%@'. Older devices can't process the new relationships.
UPDATE ANSCKRECORDMETADATA SET ZENTITYID = %@ WHERE ZENTITYID = %@
CloudKit integration forbids renaming '%@' to '%@'. Older devices can't process the new records.
sourceEntity
T@"NSSQLEntity",R,N,V_srcEntity
T@"NSSQLEntity",R,N,V_dstEntity
T@"NSEntityMapping",R,N,V_entityMapping
migrationType
Ti,R,N,V_migrationType
migrationNeedsCopyDueToConstraintMigration
TB,N,V_updateUsingCopy
intarrayTable
T^{sqlite3_intarray=},N,V_intarrayTable
intarrayTableName
T@"NSString",&,N,V_intarrayTableName
UPDATE OR FAIL %@ SET 
ALTER TABLE %@ RENAME TO %@_ORIG
UPDATE OR FAIL %@ SET %@ = (SELECT %@ FROM %@_ORIG WHERE %@ = %d) WHERE %@ = %d
UPDATE OR FAIL %@ SET %@ = 0 WHERE %@ = %d
DROP TABLE %@_ORIG
Failed to generate statements to perform migration
DROP INDEX IF EXISTS %@_Z_ENT_INDEX
Dropping Persistent History b/c of an issue with migration
NSSQLiteInPlaceMigrationManager
migrationManagerClass
pragma wal_checkpoint(truncate)
Failed to create migration statements
Failed to execute migration statements
constraint violation during attempted migration
 is NULL
 = %d
 NOT IN (SELECT 
 IS NOT NULL)
Validation error missing attribute values on mandatory destination attribute
Validation error missing attribute values on mandatory destination relationship
Validation error missing relationship values on mandatory destination destination
Unrecognized transform validation in property mapping
ANSCKRECORDMETADATA
tableMigration returned nil cloudkit update statements: %@
 = ( CASE
 WHEN 
 = %d THEN %d
 ELSE 
 END ) WHERE 
 IN (
v24@?0@"NSArray"8@"NSArray"16
Can't find entity migration description for entity
 UNIQUE
Unsupported entity mapping type with empty entity name
_AsCopy
UPDATE %@ SET Z%@%lu = NULL
UPDATE 
Z%@%lu
 = NULL
 == 
DELETE FROM %@ WHERE Z_PK <= (SELECT MAX(%@) FROM %@ WHERE %@ IN (%@))
DELETE FROM %@ WHERE %@ <= (SELECT MAX(%@) FROM %@ WHERE %@ IN (%@))
UPDATE OR FAIL %@ SET %@ = NSPersistentHistoryMigrateUpdates(3, %d, %d, %@) WHERE %@ == %d AND %@ == %ld;
adapter
T@"NSSQLiteAdapter",R,N,V_adapter
dstModel
T@"NSSQLModel",R,N,V_dstModel
srcModel
T@"NSSQLModel",R,N,V_srcModel
historyMigrationCache
T@"NSMutableDictionary",&,N,V_historyMigrationPropertyDataForEntityCache
hasCloudKitTables
TB,N,V_hasCloudKitTables
Joins not supported in index
Can't find property for keypath
Indexes cannot contain to many relationships
Indexes can only contain attribute/relationship properties
Unsupported expression type in index
CREATE %@INDEX IF NOT EXISTS Z_%@_%@ ON %@ (
UNIQUE 
Unsupported property in index
DESC
%@ COLLATE BINARY %@
SQL generation failure for property
SQL generation failure for index
SQL generation failure for index with predicate (1)
SQL generation failure for index with predicate (2)
%@ : %@ 
Unrecognized entity migration type
entityMigration
Cannot merge multiple root entity source tables into one destination entity root table
sourceRootEntities
destinationRootEntity
Unrecognized source property type for many-to-many migration
sourceRelationship
Unrecognized column in entity
column
Wrong number of columns in migration insert statement
Mismatched columns and values in migration insert statement
UPDATE %@ SET 
%@ = ?
 AND %@ IS NULL
_T_%@
 = (SELECT _EKT.
 _EKT WHERE 
 = _EKT.
 WHERE %@ is NULL
, 2000
 IS NOT NULL
 NOT IN (
Migration: CloudKit tables detected. Adding migration statements for removed table: %@
DELETE FROM ANSCKRECORDMETADATA WHERE ZENTITYID IN %@
Migration returned nil cloudkit statements: %@
Cannot construct cloudkit metadata update statements for unimplemented migration type: %@
rootEntity
T@"NSSQLEntity",R,N,V_rootEntity
TB,V_useEncryptedStorage
shouldInitializeSchema
TB,V_shouldInitializeSchema
T@"NSString",R,C,V_containerIdentifier
NSSQLiteInPlaceMigrationManager requires that the source and destination stores to be NSSQLiteStoreType
sourceStore
Failed to open the store
Invalid destination data model
Cannot migrate store in-place: 
Cannot migrate store in-place
(migration) leaving incompletely migrated store on disk after in-place migration error. (%@, %@)
unknown error
(migration) in-place migration completed successfully in %2.2f seconds
T@"NSFetchIndexDescription",R,&,N,V_indexDescription
createTableStatements
T@"NSMutableArray",&,N,V_createStrings
dropTableStatements
T@"NSMutableArray",&,N,V_dropStrings
updateTableStatements
T@"NSMutableArray",&,N,V_updateStrings
Unsupported clause (group by not allowed in updates)
Failed to generate SQL for group by property: %@
Unknown predicate type for having predicate: %@
Unsupported clause (having not allowed in updates)
Unable to find a configuration named '%@' in the specified managed object model.
The configuration named '%@' does not contain any entities.
Cannot be used without an instance of %@.
%@: %@ - Cannot locate value transformer with name '%@'
%@: %@ - Claims to return instances of %@
%@: %@ - Doesn't allow reverse transformation
%@: %@ - Unsupported attribute type (%@)
%@: %@ - Value must be an instance of '%@' or '%@' that evalutes to YES or NO using '%@'
%@: %@ - attribute is not optional
%@: %@ - %@
%@:%@ - %@
%@:%@ - preserveValueOnDeletionInPersistentHistory should be YES
%@: Estimated size %lu bytes
CloudKit integration requires that all relationships have an inverse, the following do not:
CloudKit integration requires that all attributes be optional, or have a default value set. The following attributes are marked non-optional but do not have a default value:
CloudKit integration requires that all relationships be optional, the following are not:
CloudKit integration does not support all attribute types. The following entities have attributes of an unsupported type:
CloudKit integration requires that the value transformers for transformable attributes are available via +[%@ %@], return instances of NSData, and allow reverse transformation:
CloudKit integration does not allow relationships to objects that aren't sync'd. The following relationships have destination entities that not in the specified configuration.
CloudKit integration requires that all entities tombstone %@ and %@ on delete if configured. The following entities are not properly configured:
CloudKit integration requires that all entities can be materialized in a CKRecord of less than %lu bytes. The following entities cannot:
The following attributes have invalid values for '%@':
CloudKit integration does not support ignored relationships. The following entities and relationships are marked ignored using '%@':
CloudKit integration does not support encrypted relationships. The following entities and relationships are marked with '%@':
The following relationships are configured with unsupported delete rules:
%@: %@ - incorrect type: %@ required, but was %@.
%@: %@ - not an attribute
%@: %@ - missing
Nullify
Deny
cascade
No-Action
skipValueTransformerValidation
TB,N,V_skipValueTransformerValidation
validateLegacyMetadataAttributes
TB,N,V_validateLegacyMetadataAttributes
requestType
%@ with fetch request %@
T@"NSFetchRequest",R,V_fetchRequest
completionBlock
T@?,R,V_requestCompletionBlock
estimatedResultCount
Tq,N,V_estimatedResultCount
NSUnderlyingProperty
NSReferenceID
NSEntityDescription
Proxy for prop named %@ on ed %@, real %@
Unable to initialize %s.  stat() failed on '%s' with errno %d
NSData [%s] with address %p backed by file at '%@'
Could not open file.
Could not map file.
Tr^v,R
Data may not be nil
%@_%p
v16@?0@"NSURL"8
External data reference can't find underlying file.
File URL
External data reference; unknown problem.
External data reference can't load ubiquitous file.
External Data Reference: <self = %p ; path = %s ; length = %qu>
External Data Reference: <self = %p ; path = nil ; length = %qu>
range {%lu, %lu} exceeds data length %lu
B16@?0@"NSSQLStoreRequestContext"8
filter
T@?,C,N,V_filter
SQLQueue: %@ : %p
dispatch_queue_attr_make_with_qos_class() returned NULL in %s
NSSQLConnection manager failed to initialize with error domain '%s' code '%ld' reason:'%s' from %@
NSSQLConnection manager failed to initialize with exception %@
handleStoreRequest failed with excception: %@
handleStoreRequest failed with unknown excception
scheduleBarrierBlock failed with excception: %@
scheduleBarrierBlock failed with unknown excception
scheduleConnectionsBarrier failed with excception: %@
scheduleConnectionsBarrier failed with unknown excception
Cannot mutate an immutable faulting NSOrderedSet
Index of object > number of objects
_NSFaultingMutableOrderedSet
nil order keys and %d objects in real set
bad input oidsAndLocations => should have an even number
monitor
T@"PFCloudKitStoreMonitor",R,N,V_monitor
T@"NSCloudKitMirroringDelegateOptions",R,N,V_options
assetStorageURL
T@"NSURL",R,N,V_assetStorageURL
_CDSnapshot
_cd_nullFlags2_
[%dC]
_cd_nullFlags_
<deferred relationship fault>
%@ (entity: %@; id: %@ ; data: %@)
snapshot is marked read only
warning snapshot_get_value_as_object called on NULL
warning snapshot_set_value_as_object called on NULL
instruments
_NSMetadataLastIdentifier
Unknown failure
Failed to load metadata
Keyspace exhausted
%@=%@
Unable to add up file actions
Unable to add open file actions
Unable to init file actions
Unable to destroy file actions
Ti,R
terminationStatus
<NSPersistentHistoryChange: %lld %@ %@ %lld %@ %@>
NSPersistentHistoryChangeType
NSPersistentHistoryChangeTypeInsert
NSPersistentHistoryChangeTypeUpdate
NSPersistentHistoryChangeTypeDelete
'%ld' is an unknown NSPersistentHistoryChangeType value
entityDescription
T@"NSFetchRequest",R
T@"NSManagedObjectID",R,C
transaction
T@"NSPersistentHistoryTransaction",R
updatedProperties
T@"NSSet",R,C
NSPersistentHistoryChangeObjectID
NSPersistentHistoryChangeID
NSPersistentHistoryChangeTombstone
NSPersistentHistoryChangeTransaction
NSPersistentHistoryChangeColumn
<NSConstraintCacheKey: %@>
<NSConstraintCache : entity = %@, constraint = %@, extension = %@>
v32@?0@8@"NSArray"16^B24
T@"NSArray",R,&,N,V_constraint
extension
T@"NSArray",R,&,N,V_extension
children
T@"NSArray",R,&,N,V_children
%@ - %u
Unable to generate SQL for fetch
Bad request
SELECT COUNT(*) from (%@)
insertObject:in%sAtIndex:
insert%s:atIndexes:
removeObjectFrom%sAtIndex:
remove%sAtIndexes:
replaceObjectIn%sAtIndex:withObject:
replace%sAtIndexes:with%s
automaticallyPruneTransientRecords
TB,N,V_automaticallyPruneTransientRecords
migrationStatements
T@"NSArray",R,N,V_migrationStatements
sqlEntitiesToCreate
T@"NSArray",R,N,V_sqlEntitiesToCreate
hasWorkToDo
TB,R,N,V_hasWorkToDo
Failed to initialize CloudKit metadata: %@
-[PFCloudKitSetupAssistant _checkAndInitializeMetadata:]_block_invoke
The mirroring delegate could not initialize because it's store was removed from the coordinator.
Failed to asset file (and unlink:%d) at url: %@
-[PFCloudKitSetupAssistant _initializeAssetStorageURLError:]_block_invoke
Failed to create largeBlobDirectoryURL with observed store: %@
%@: Could not create cloudkit container: %@
Unable to determine the status of the iCloud account (CKAccountStatusCouldNotDetermine).
Unable to initialize without a valid iCloud account (CKAccountStatusRestricted).
Unable to initialize without an iCloud account (CKAccountStatusNoAccount).
Unknown account status: %d
v24@?0q8@"NSError"16
Failed to get a container back for the identifier: %@
Failed to get a database back from -privateCloudDatabase for container: %@
%@ unable to recover from error: %@
Encountered subsequent error: %@
-[PFCloudKitSetupAssistant _createZoneIfNecessary:]
v24@?0@"CKRecordID"8@"NSError"16
%@: CKIdentity record has changed from %@ to %@
-[PFCloudKitSetupAssistant _checkUserIdentity:]_block_invoke_2
%@: CKIdentity record matches store: %@
-[PFCloudKitSetupAssistant _checkUserIdentity:]_block_invoke
%@: CKIdentity record changed from nil to %@
%@: Identity fetch failed due to authentication but store was never assigned to a user record: %@
%@: First identity fetch failed due to authentication but store was never assigned to a user record: %@
%@: Identity fetch failed with unknown error: %@
-[PFCloudKitSetupAssistant _checkUserIdentity:]
container
T@"CKContainer",R,N,V_container
databaseSubscription
T@"CKDatabaseSubscription",R,N,V_databaseSubscription
largeBlobDirectoryURL
T@"NSURL",R,N,V_largeBlobDirectoryURL
cloudKitSemaphore
T@"NSObject<OS_dispatch_semaphore>",R,N,V_cloudKitSemaphore
storeMonitor
T@"PFCloudKitStoreMonitor",R,N,V_storeMonitor
CDDCloudKitScheduledActivity
T@"NSUUID",&,D,N
T@"CDDCloudKitRegisteredClient",&,D,N
Unhandled exception in rowCacheForGeneration %@
%s(%d): CoreData: Ubiquity:  %@
Successfully prefetched managed objects.
-[_PFUbiquityRecordImportOperation applyChangesFromStoreSaveSnapshot:withImportContext:withError:]
%s(%d): CoreData: Ubiquity:  %@
 Error pre-fetching managed objects: %@
 User Info: %@
The operation will attempt to continue, but may fail if it cannot talk to the database.
%s(%d): CoreData: Ubiquity:  %@: Beginning parse of log file: %@
-[_PFUbiquityRecordImportOperation main]
%s(%d): CoreData: Ubiquity:  Aborting cancelled operation: %@
%s(%d): CoreData: Ubiquity:  %@
 Cancelling due to missing switchboard entry
%s(%d): CoreData: Ubiquity:  Error loading comparison metadata for transaction log: %@
%s(%d): CoreData: Ubiquity:  Threw trying to get the knowledge vector from the store: %@
-[_PFUbiquityRecordImportOperation main]_block_invoke
%s(%d): CoreData: Ubiquity:  Ignoring log: %@
The local database has already seen this transaction log: %@
%s(%d): CoreData: Ubiquity:  %@ - Cache KV: %@ matches initial KV: %@
%s(%d): CoreData: Ubiquity:  %@ - Knowledge Vector mismatch, reloading cache
%s(%d): CoreData: Ubiquity:  %@
Metadata store doesn't match local store: (%@:%@)
%s(%d): CoreData: Ubiquity:  import operation's context lost its stack's managedobjectcontext
import operation's context lost its stack
%s(%d): CoreData: Ubiquity:  About to apply changes from log contents.
%s(%d): CoreData: Ubiquity:  %@
Deleting conflict loser because it was orphaned (%@): %@
%s(%d): CoreData: Ubiquity:  Changes applied for transaction log content, managed object context changes: 
inserted: %@
updated: %@
deleted: %@.
Error encountered while importing transaction log at URL: %@, an error occurred saving changes to the persistent store mutated during the import process.
%s(%d): CoreData: Ubiquity:  %@
Successfully wrote changes.
%s(%d): CoreData: Ubiquity:  Import operation: %@
Was beat to the database, rolling back and retrying later.
%s(%d): CoreData: Ubiquity:  Error saving managed object context changes for transaction log: %@
Error: %@
 User Info: %@
 Managed Object Context Changes, inserted: %@
updated: %@
deleted: %@
%s(%d): CoreData: Ubiquity:  About to save stack updates, metadata moc changes: 
inserted: %@
updated: %@
deleted: %@.
%s(%d): CoreData: Ubiquity:  %@
Successfully wrote metadata changes.
%s(%d): CoreData: Ubiquity:  %@
Error writing pending entries: %@
%s(%d): CoreData: Ubiquity:  Error updating peer metadata during import of log file: %@ error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Rolling back metadata changes due to rolled back transaction: %@
%s(%d): CoreData: Ubiquity:  Executing SQL hack to fix primary key issue in SQLite database in import operation: %@
%s(%d): CoreData: Ubiquity:  About to issue update command to primary key table for store: %@
%s(%d): CoreData: Ubiquity:  Import operation interrupted during import: %@
%s(%d): CoreData: Ubiquity:  %@
Bailing because a required external data reference failed to download: %@
%s(%d): CoreData: Ubiquity:  Error importing transaction log: %@, exception: %@
 User Info: %@
exception
CoreData: Ubiquity: Could not find local URI for global ID index: %@
%s(%d): CoreData: Ubiquity:  %@
Got transaction history: %@
For object: %@
Object ID: %@
Initial KV: %@
Import Context: %@
-[_PFUbiquityRecordImportOperation processObjects:withState:andImportContext:outError:]
B24@?0@8@"NSDictionary"16
%s(%d): CoreData: Ubiquity:  %@
Skipping object: %@
Resolved type: %d / %d
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Can't find entity for name: %@ in model: %@
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Unable to locate updated or deleted object with ID: %@, translated from global ID: %@, error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  %@
Object (%@): %@ was resolved to a delete and will not be processed.
%s(%d): CoreData: Ubiquity:  Transaction log: %@ appears an updated object: %@ was deleted.
%s(%d): CoreData: Ubiquity:  Object (%d): %@ which resolved to a delete but appears to already have been deleted from the local store.
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Transaction log: %@
 Error creating object to work with (with state: %d), skipping %@, globalID: %@
%s(%d): CoreData: Ubiquity:  %@
Got nil content for comprssed globalID Index: %@
%s(%d): CoreData: Ubiquity:  Error encountered trying to resolve conflict: %@, error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  %@ successfully applied changes for object with global id: %@
Object ID: %@
%s(%d): CoreData: Ubiquity:  %@ had trouble applying changes for object with global id: %@
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Couldn't find missing object for objectID string: %@
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Couldn't find missing object for objectID: %@
%s(%d): CoreData: Ubiquity:  %@
 Unable to find relationship destination object: %@
localPeerID: %@
logScore: %@
transactionLog: %@
T@"NSManagedObjectContext",R,V_moc
T@"NSPersistentStoreCoordinator",R,V_psc
T@"PFUbiquityTransactionLog",R,N,V_transactionLog
insertedObjectIDs
T@"NSMutableSet",R,N,V_insertedObjectIDs
updatedObjectIDs
T@"NSMutableSet",R,N,V_updatedObjectIDs
T@"NSMutableSet",R,N,V_deletedObjectIDs
resolvedConflicts
T@"NSMutableDictionary",R,N,V_resolvedConflicts
logScore
T@"PFUbiquityKnowledgeVector",&,N,V_logScore
T@"NSObject<_PFUbiquityRecordImportOperationDelegate>"
lockedExistingCoord
TB,V_lockedExistingCoord
initialStoreKnowledgeVector
T@"PFUbiquityKnowledgeVector",R,V_initialStoreKnowledgeVector
updatedStoreKnowledgeVector
T@"PFUbiquityKnowledgeVector",&,N,V_updatedStoreKnowledgeVector
importContext
T@"PFUbiquityImportContext",&,N,V_importContext
transactionDidRollBack
TB,R,N,V_transactionDidRollback
T@"NSError",R,N,V_operationError
wroteKV
TB,R,N,V_wroteKV
PFUbiquityExporterWillUpdateKnowledgeVectorNotification
localPeerID: %@
ubiquityRootLocation: %@
lastTransactionDate: %@
%s(%d): CoreData: Ubiquity:  Exporter considering response to save: %@
Store: %@
Options: %@
-[_PFUbiquityRecordsExporter shouldRespondToSaveNotification:]
_NSSQLCoreActiveSaveRequest
%s(%d): CoreData: Ubiquity:  Exporter: %@
Will respond.
%s(%d): CoreData: Ubiquity:  Didn't find peer state for local peer ID: %@ after transacation rolled back: %@
-[_PFUbiquityRecordsExporter cleanUpFromRolledbackPendingTransaction:withNotification:]
%s(%d): CoreData: Ubiquity:  %@
Looks like log file was never written: %@
-[_PFUbiquityRecordsExporter cleanUpFromRolledbackPendingTransaction:withNotification:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error deleting invalidated log file at url: %@
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Error trying to recover store metadata from rolled back transaction: %@
 User Info: %@
Store Metadata: %@
Transaction log: %@
%s(%d): CoreData: Ubiquity:  Got notification that store is about to commit: %@
-[_PFUbiquityRecordsExporter managedObjectContextDidSave:]
debug.kvStr
exportingPeerID
%s(%d): CoreData: Ubiquity:  %@
Error moving log to permanent location: %@
Error: %@
 User Info: %@
Just testing
%s(%d): CoreData: Ubiquity:  %@
Failed to save to the database after 100 tries to optimistically lock the knowledge vector: %@
%s(%d): CoreData: Ubiquity:  %@ Successfully wrote transaction log: %@
%s(%d): CoreData: Ubiquity:  %@
Skipping transaction history caching, using local storage.
%s(%d): CoreData: Ubiquity:  %@
Transaction Entries: %@
%s(%d): CoreData: Ubiquity:  Added transaction entries to cache
%s(%d): CoreData: Ubiquity:  Error caching transaction entries after export: %@
%s(%d): CoreData: Ubiquity:  Wrote pending entries to disk and purged cache, it will be rebuilt
%s(%d): CoreData: Ubiquity:  Error purging cache for transaction entries: %@
%s(%d): CoreData: Ubiquity:  No transaction history cache found for store: %@
%s(%d): CoreData: Ubiquity:  Error writing transaction log: %@.
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Export of save notification encountered the following errors: %@, 
Save Notification: %@
%s(%d): CoreData: Ubiquity:  An exception occurred during a log file export: %@ save notification contents: %@
_NSSQLCoreTransactionExternalDataReferencesToDelete
%s(%d): CoreData: Ubiquity:  %@ exporting inserted objects: %@
-[_PFUbiquityRecordsExporter createDictionaryForObjectsInSaveNotification:forTransactionOfType:withExportContext:andSaveSnapshot:]
%s(%d): CoreData: Ubiquity:  %@ exporting updated objects: %@
%s(%d): CoreData: Ubiquity:  %@ exporting deleted objects: %@
%s(%d): CoreData: Ubiquity:  Skipping object from a store that this exporter is not responsible for. Object ID: %@, exporter: %@
%s(%d): CoreData: Ubiquity:  Unable to delete ubiquitous external reference file during aborted transaction: %@
 User Info: %@
-[_PFUbiquityRecordsExporter createDictionaryForObjectsInSaveNotification:forTransactionOfType:withExportContext:andSaveSnapshot:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error adding object to save snapshot: %@
 User Info: %@
 Object: %@
offendingObject
CoreData: Ubiquity: Unable to export content for managed object.
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Exception trying to transfer logs from temporary directory to ubiquity sync'd directory. Exception: %@
 User Info: %@
-[_PFUbiquityRecordsExporter moveLogsFromTempDirectory]
%s(%d): CoreData: Ubiquity:  %@
Encountered an error while trying to move logs out of the temporary directory: %@
 Rescheduling move timer.
%s(%d): CoreData: Ubiquity:  %@
Asked to schedule a temporary log move without a queue
-[_PFUbiquityRecordsExporter scheduleTempLogMove]
T@"PFUbiquityLocation",&,N,V_ubiquityRootLocation
localRootLocation
T@"PFUbiquityLocation",R,N,V_localRootLocation
currentRootLocation
T@"PFUbiquityLocation",R,N
lastTransactionDate
T@"NSDate",&,V_lastTransactionDate
pendingTempLogMove
TB,R,N,V_pendingTempLogMove
allowTempLogStorage
TB,N,V_allowTempLogStorage
useLocalStorage
TB,N,V_useLocalStorage
throwOptimisticLockingException
TB,N,V_throwOptimisticLockingException
v32@?0@"NSManagedObjectID"8@"NSCKRecordMetadata"16^B24
v32@?0@"NSString"8@"NSCKMirroredRelationship"16^B24
Expected to get an instance of NSCKMirroredRelationship for this recordID: %@ but got: %@
Expected to get an instance of NSCKRecordMetadata for this recordID: %@ but got: %@
Already have a mirrored relationship registered for this key: %@
Didn't find record metadata for record in mirrored relationship: %@
Didn't find record metadata for related record to mirrored relationship: %@
Attempting to cache zone metadata but already have one: %@
TEMP_CDBATCHINSERTOBJECTIDS
INSERT INTO %@ (ENTITYID, PrimeKey) SELECT NEW.Z_ENT, NEW.Z_PK;
CREATE TEMP TABLE IF NOT EXISTS %@ (ENTITYID INTEGER, PrimeKey INTEGER)
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_BATCHINSERTOBJECTID_TRIGGER AFTER INSERT ON %@ FOR EACH ROW BEGIN %@ END
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_BATCHINSERTUPDATEOBJECTID_TRIGGER AFTER UPDATE ON %@ FOR EACH ROW BEGIN %@ END
DROP TRIGGER IF EXISTS ZQ_BATCHINSERTOBJECTID_TRIGGER
DROP TRIGGER IF EXISTS ZQ_BATCHINSERTUPDATEOBJECTID_TRIGGER
T@"NSBatchInsertRequest",R,N
com.apple.coredata.ubiquity.importer.didfinishimport
com.apple.coredata.ubiquity.monitorqueue.root
com.apple.coredata.ubiquity.importer.privateQueue
ubiquityRootLocation: %@
localPeerID: %@
%s(%d): CoreData: Ubiquity:  Log locations: %@
-[_PFUbiquityRecordsImporter createSortedOperationsArrayWithMetadata:isFirstImport:]
%s(%d): CoreData: Ubiquity:  Skipping (storeName): %@
%s(%d): CoreData: Ubiquity:  Skipping (model version hash): %@
%s(%d): CoreData: Ubiquity:  Transaction log went missing: %@
%s(%d): CoreData: Ubiquity:  Error loading comparison metadata for transaction log: %@
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Transaction log was ignored because it could not be opened, there was no error, so this probably means it was unreadable by the local peer (a different type than this peer accepts). %@
%s(%d): CoreData: Ubiquity:  %@
Skipping log because it is of unknown type: %@
%s(%d): CoreData: Ubiquity:  %@
Skipping log because it has already been imported into the local store: %@
storeKV: %@
logKV: %@
%s(%d): CoreData: Ubiquity:  Couldn't find transaction number in log at URL: %@
Log Contents: %@
%s(%d): CoreData: Ubiquity:  Created operations: %@
%s(%d): CoreData: Ubiquity:  %@ will process operation: %@
%s(%d): CoreData: Ubiquity:  %@
Skipping incompatible operation (%@): %@
%s(%d): CoreData: Ubiquity:  Checking for forked Peer from op %@ and local KV %@
-[_PFUbiquityRecordsImporter isPeerForked:andLocalKV:]
%s(%d): CoreData: Ubiquity:  Peer only knew of itself...forking
%s(%d): CoreData: Ubiquity:  Peer has possibly never been seen...forking
%s(%d): CoreData: Ubiquity:  Peer has never been seen...forking
%s(%d): CoreData: Ubiquity:  Peer has not been seen in a long while...forking
%s(%d): CoreData: Ubiquity:  Peers are not that far off from each other, maybe the logs are on their way
%s(%d): CoreData: Ubiquity:  Peer not found in all peers - has never been seen...forking
%s(%d): CoreData: Ubiquity:  %@
Can't process log with score: %@ after log with score: %@
 It is ahead of the local peer.
-[_PFUbiquityRecordsImporter canProcessTransactionLogWithScore:afterLogWithScore:]
%s(%d): CoreData: Ubiquity:  %@
Cannot process log with score: %@ after log with score: %@
It will attempt to increment two peers simultaneously.
%s(%d): CoreData: Ubiquity:  %@
Encountered errors trying to download logs, but can continue import: %@
-[_PFUbiquityRecordsImporter checkSchedulingContextForMissingLocalPeerOperations:error:]
Unable to import logs because of failed requisit foreign peer logs.
schedulingContext
%s(%d): CoreData: Ubiquity:  %@ importing operations: 
-[_PFUbiquityRecordsImporter scheduleTransactionLogOperations:synchronous:error:]
%s(%d): CoreData: Ubiquity:  Import operation failed while synchronously restoring logs, aborting: %@
Error: %@
 User Info: %@
Operations: %@
%s(%d): CoreData: Ubiquity:  %@
Asked to schedule but nothing to schedule in the context: %@
-[_PFUbiquityRecordsImporter schedulePendingLogs:error:]
%s(%d): CoreData: Ubiquity:  Ignoring pending log (exisitng op): %@
%s(%d): CoreData: Ubiquity:  %@
No more logs to schedule
%s(%d): CoreData: Ubiquity:  %@
Created sorted operations (%d): %@
%s(%d): CoreData: Ubiquity:  %@
Scheduling operations (%d): %@
%s(%d): CoreData: Ubiquity:  %@
Finished scheduling logs with context: %@
%s(%d): CoreData: Ubiquity:  %@
Will reschedule pending logs: %@
Container may be forked
Container is forked
%s(%d): CoreData: Ubiquity:  Starting scan of location: %@
-[_PFUbiquityRecordsImporter discoverAndImportAllAvailableLogs:error:]
%s(%d): CoreData: Ubiquity:  Started download for logs: %@
-[_PFUbiquityRecordsImporter discoverAndImportAllAvailableLogs:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error while starting download for logs: %@
Logs: %@
%s(%d): CoreData: Ubiquity:  Exception while scanning for logs to import: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Librian returned a serious error for starting downloads %@ with userInfo %@
-[_PFUbiquityRecordsImporter batchDownloadTransactionLogsAtLocations:error:]_block_invoke
-[_PFUbiquityRecordsImporter batchDownloadTransactionLogsAtLocations:error:]
%s(%d): CoreData: Ubiquity:  Initiated download for urls: %@
%s(%d): CoreData: Ubiquity:  %@
Didn't get an object ID back for the application's coordinator: %@
-[_PFUbiquityRecordsImporter createNewSetOfObjectIDsForCoordinator:fromObjectIDs:]
%s(%d): CoreData: Ubiquity:  %@
Got set of persistent store coordinators for store named: %@
Coordinators: %@
-[_PFUbiquityRecordsImporter postImportNotificationForStoreName:andLocalPeerID:withUserInfo:]
NSApplication
%s(%d): CoreData: Ubiquity:  Posting import notification: %@
For coordinator: %p
-[_PFUbiquityRecordsImporter postImportNotificationForStoreName:andLocalPeerID:withUserInfo:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@ throttling notification for operation: %@
-[_PFUbiquityRecordsImporter operationDidFinish:]
%s(%d): CoreData: Ubiquity:  %@
Operation missing transaction log location: %@
%s(%d): CoreData: Ubiquity:  %@
Wrote pending entries to disk after imports finished.
%s(%d): CoreData: Ubiquity:  %@
Error attempting to write pending transaction history to disk: %@
User Info: %@
%s(%d): CoreData: Ubiquity:  Import operation encountered had trouble importing log file, %@
 User Info: %@
 The log file is at: %@.
Operation: %@
-[_PFUbiquityRecordsImporter operation:failedWithError:]
%s(%d): CoreData: Ubiquity:  Import operation was beat into the data store: %@
%s(%d): CoreData: Ubiquity:  Import operation had trouble with the fileystem, %@
 User Info: %@
 The log file is at: %@.
Operation: %@
%s(%d): CoreData: Ubiquity:  Import operation had trouble with conflict resolution: %@
userInfo: %@
 It appears that the operation was beat to the database.
%s(%d): CoreData: Ubiquity:  Import operation encountered an error: %@
userInfo: %@. While trying to import the log file at the URL: %@
%s(%d): CoreData: Ubiquity:  Operation was interrutped by import: %@
-[_PFUbiquityRecordsImporter operationWasInterruptedDuringImport:]
%s(%d): CoreData: Ubiquity:  Restart timer fired for importer: %@
-[_PFUbiquityRecordsImporter scheduleRecoveryTimer]_block_invoke
%s(%d): CoreData: Ubiquity:  Ubiquity root url: %@ did not pass processing sanity check. Error: %@
userInfo: %@
+[_PFUbiquityRecordsImporter canProcessContentsOfUbiquityRootPath:]
.cdmetadata
%s(%d): CoreData: Ubiquity:  Scheduling response to baseline: %@
-[_PFUbiquityRecordsImporter scheduleBaselineRollResponseOperationForBaselineAtLocation:]
%s(%d): CoreData: Ubiquity:  Registered coordinators: %@
%s(%d): CoreData: Ubiquity:  store name: %@ - %@
%s(%d): CoreData: Ubiquity:  Store: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to schedule baseline roll response operation for location (store active but not found): %@
%s(%d): CoreData: Ubiquity:  Adding operation
%s(%d): CoreData: Ubiquity:  %@
Unable to schedule roll response operation for location (store not active): %@
%s(%d): CoreData: Ubiquity:  %@
Unable to schedule roll response operation for location (monitoring): %@
%s(%d): CoreData: Ubiquity:  %@
Scheduling baseline recovery operation on behalf of: %@
-[_PFUbiquityRecordsImporter scheduleBaselineRecoveryOperationWithActiveBaselineOperation:]
%s(%d): CoreData: Ubiquity:  %@
Refreshed peer range cache after baseline roll.
-[_PFUbiquityRecordsImporter recoveryOperation:didReplaceLocalStoreFileWithBaseline:]
%s(%d): CoreData: Ubiquity:  %@
Error attempting to refresh peer range cache: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully adopted baseline: %@
-[_PFUbiquityRecordsImporter rollResponseOperation:successfullyAdoptedBaseline:]
%s(%d): CoreData: Ubiquity:  Refreshed peer range cache
%s(%d): CoreData: Ubiquity:  %@
Encountered an error while trying to respond to the roll of baseline: %@
Error: %@
userInfo: %@
-[_PFUbiquityRecordsImporter rollResponseOperation:encounteredAnError:whileTryingToAdoptBaseline:]
%s(%d): CoreData: Ubiquity:  %@
Successfully recovered metadata for store: %@
-[_PFUbiquityRecordsImporter metadataInconsistencyDetectedForStore:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Error during metadata recovery for store: %@
Error: %@
User Info: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully recached transaction history
%s(%d): CoreData: Ubiquity:  %@
Error attempting to recache transaction history: %@
User Info: %@
%s(%d): CoreData: Ubiquity:  %@
Error attempting to drop the transaction history cache: %@
%s(%d): CoreData: Ubiquity:  %@
Error scheduling root scan after metadata recovery: %@
%s(%d): CoreData: Ubiquity:  Error while trying to create the import coordinator as store URL is nil.
+[_PFUbiquityRecordsImporter addPrivateStore:toCoordinator:atURL:error:]
%s(%d): CoreData: Ubiquity:  Error while trying to create the import coordinator: %@
importQueue
T@"NSOperationQueue",R,V_importQueue
T@"NSString",R,V_localPeerID
T@"NSString",R,V_storeName
isMonitoring
TB,R,V_isMonitoring
logRestartTimer
T@"NSObject<OS_dispatch_source>",V_logRestartTimer
schedulingLock
T@"NSRecursiveLock",R,N,V_schedulingLock
importOnlyActiveStores
TB,V_importOnlyActiveStores
throttleNotifications
TB,V_throttleNotifications
allowBaselineRoll
TB,V_allowBaselineRoll
T@"PFUbiquityRecordsImporterSchedulingContext",R,N,V_schedulingContext
sideLoadCacheWrapper
T@"PFUbiquitySwitchboardCacheWrapper",&,N,V_sideLoadCacheWrapper
privateStore
T@"NSPersistentStore",R,N,V_privateStore
privatePSC
T@"NSPersistentStoreCoordinator",R,N,V_privatePSC
.cdmetadata.nosync
metadata.nosync
metadata.store
%s(%d): CoreData: Ubiquity:  Initializing stack(%@) with metadata entry: %@
-[_PFUbiquityStack initWithMetadataEntry:]
%s(%d): CoreData: Ubiquity:  Setting up metadataMOC for stack: %@
%@: 
localPeerID: %@
ubiquityRootURL: %@
metadataContainerURL: %@
-[_PFUbiquityStack purgeAndInitializeMetadataStoreFileWithError:]
max:(transactionNumber)
PFUbiquityTransactionEntry
actingPeer.peerKey
%s(%d): CoreData: Ubiquity:  Error getting knowledge vector from metadata store: %@
-[_PFUbiquityStack createMetadataStoreKnowledgeVector:]
min:(transactionNumber)
-[_PFUbiquityStack createMinMetadataStoreKnowledgeVector:]
metadataMOC
T@"NSManagedObjectContext",R,N,V_metadataMOC
metadataEntry
T@"PFUbiquityMetadataFactoryEntry",R,N,V_metadataEntry
ubiquityRootURL
T@"PFUbiquityLocation",R,N,V_ubiquityRootURL
metadataStoreFileLocation
T@"PFUbiquityLocation",R,N,V_metadataStoreFileLocation
T@"NSBatchDeleteRequest",R,N
fetchRequestForObjectsToDelete
T@"NSFetchRequest",R,&,N
deleteStatements
T@"NSArray",R,&,N,V_deleteStatements
fetchContext
T@"NSSQLFetchRequestContext",R,&,N
affectedObjectIDs
T@"NSArray",&,N,V_deletedObjectIDs
exernalDataReferenceStatements
T@"NSArray",&,N,V_externalDataReferenceTriggerStatements
tempTableName
T@"NSString",&,N,V_tempTableName
T@"NSArray",&,N,V_externalDataReferencesToDelete
T@"NSArray",&,N,V_fileBackedFuturesToDelete
PFUbiquityPeer
peerKey == %@
%s(%d): CoreData: Ubiquity:  Error getting peer: %@
+[PFUbiquityPeer(UbiquityMethods) peerForPeerID:inManagedObjectContext:createIfMissing:]
%s(%d): CoreData: Ubiquity:  Found more than one peer object for peer ID: %@
peerCode
%s(%d): CoreData: Ubiquity:  Error getting all peers: %@
+[PFUbiquityPeer(UbiquityMethods) allPeersInManagedObjectContext:]
PFUbiquityPeerState
storeName == %@ AND peer.peerKey == %@ AND storeMetadata.ubiquityName == %@
%s(%d): CoreData: Ubiquity:  Error or too many peer states: %@, error: %@
+[PFUbiquityPeerState(UbiquityMethods) peerStateForStoreName:andPeerID:inManagedObjectContext:createIfMissing:]
storeName == %@ AND peer.peerKey != %@
%s(%d): CoreData: Ubiquity:  Error while fetching all peer states: %@
+[PFUbiquityPeerState(UbiquityMethods) peerStatesMatchingStoreName:inManagedObjectContext:omittingLocalPeerID:]
storeName == %@
+[PFUbiquityPeerState(UbiquityMethods) peerStatesMatchingStoreName:inManagedObjectContext:]
T@"NSCKImportOperation",&,D,N
lastProcessedTransactionLogURL
peer
T@"PFUbiquityPeer",&,D,N
storeMetadata
T@"PFUbiquityStoreMetadata",&,D,N
API misuse: there shouldn't be a connection here
Database connection failed to adopt query generation
Caught a non-object exception in the connectionManager
*RequestContext connection may not be reset
sqlCore
T@"NSSQLCore",R,N
T@"NSSQLiteConnection",&,N,V_connection
storeIsInMemory
TB,R,N,V_storeIsInMemory
transactionID
T@"NSNumber",R,N,V_transactionID
persistentStoreRequest
T@"NSPersistentStoreRequest",R,N,V_persistentStoreRequest
T@"NSManagedObjectContext",R,N,V_context
localError
debugLogLevel
Ti,R,N
useColoredLogging
TB,R,N,V_useColoredLogging
useConcurrentFetching
TB,R,N,V_useConcurrentFetching
T@,&,N,V_result
T@,&,N,V_exception
rowCache
T@"NSSQLRowCache",R,N
isWritingRequest
shouldRegisterQueryGeneration
PFUbiquityStoreMetadata
%s(%d): CoreData: Ubiquity:  Error locating metadata for local persistent store: %@, stores: %@
+[PFUbiquityStoreMetadata(UbiquityMethods) allStoreMetadataInManagedObjectContext:]
ubiquityName == %@
+[PFUbiquityStoreMetadata(UbiquityMethods) storeMetadatasWithName:inManagedObjectContext:]
%s(%d): CoreData: Ubiquity:  Looks like the container URL moved for store metadata: %@
New Container URL: %@
Old: %@
-[PFUbiquityStoreMetadata(UbiquityMethods) updateWithStore:andRootLocation:]
PFUbiquityPeerRange
%s(%d): CoreData: Ubiquity:  loadFromBaselineMetadata: lost its stack and failed.
-[PFUbiquityStoreMetadata(UbiquityMethods) loadFromBaselineMetadata:withLocalPeerID:]
peer.peerKey == %@ AND storeName == %@
%s(%d): CoreData: Ubiquity:  Error fetching peer state for peerID: %@, error: %@
-[PFUbiquityStoreMetadata(UbiquityMethods) peerStateForPeerID:]
%s(%d): CoreData: Ubiquity:  Error fetching peer state for peerID: %@, too many peer states found: %@
baseline.store
baseline.model
baseline.gcmodel
meta.plist
.baseline
CoreData: Ubiquity: baseline directory unreachable: %@
%s(%d): CoreData: Ubiquity:  Error setting store options on store metadata: %@, options: %@
NSKeyedUnarchiveFromData transformer returned nil
-[PFUbiquityStoreMetadata(UbiquityMethods) setStoreOptions:]
storeOptions
T@"NSURL",R,N
T@"PFUbiquityLocation",R
PFUbiquityRemotePeerState
%s(%d): CoreData: Ubiquity:  Error while fetching all remote peer states for store name: %@
error: %@
+[PFUbiquityRemotePeerState(UbiquityMethods) remotePeerStatesMatchingStoreName:inManagedObjectContext:]
storeName == %@ AND peerID == %@
%s(%d): CoreData: Ubiquity:  Error while fetching all remote peer states for store identifier: %@
error: %@
+[PFUbiquityRemotePeerState(UbiquityMethods) remotePeerStatesMatchingStoreName:andPeerID:inManagedObjectContext:]
peerID
initWithRequest passed an error (%@) on a succes condition
initWithRequest illegally passed nil instead of an error on a failure condition
madeChanges
TB,R,N,V_madeChanges
T@"NSPersistentHistoryToken",R,N,V_historyToken
T@"CKServerChangeToken",R,N,V_changeToken
%@ doesn't know how to handle it's specified value. Please file a bug with this outpout and send to Core Data | New Bugs.
-[NSCKMetadataEntry describeValue]
key IN (%@)
v16@?0@"NSCKMetadataEntry"8
boolValue
T@"NSObject<NSSecureCoding>",&,D,N
peerStart
peerEnd
rangeStart
rangeEnd
globalIDStr == %@
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Trouble fetching transaction entries from metadata store: %@
userInfo: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesMatchingGlobalObjectID:inManagedObjectContext:]
localIDStr == %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesMatchingLocalObjectID:inManagedObjectContext:]
(actingPeer.peerKey == %@ AND transactionNumber > %@ AND storeMetadata.ubiquityName == %@)
transactionDate
globalIDStr
knowledgeVectorString
%s(%d): CoreData: Ubiquity:  Conflict metadata fetch failed with error: %@
userInfo: %@
 Conflict resolution will not work. Original Fetch Request: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:]
+[PFUbiquityTransactionEntry(UbiquityMethods) deleteTransactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:]
actingPeer.peerKey == %@ AND transactionNumber == %@
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Error fetching transaction entries: %@
userInfo: %@ with fetch request: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesForPeerID:withTransactionNumber:inManagedObjectContext:]
(actingPeer.peerKey == %@ AND transactionNumber < %@ AND storeMetadata.ubiquityName == %@)
%s(%d): CoreData: Ubiquity:  Got nil transaction entries for fetch request: %@
Error: %@
userInfo: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesForPeerID:beforeTransacationNumber:forStoreNamed:inManagedObjectContext:]
actingPeer.peerKey == %@ AND transactionNumber == %@ AND globalIDStr == %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntryForGlobalIDString:withActingPeerID:atTransactionNumber:inManagedObjectContext:]
transactionType
transactionLogURL
T@"NSURL",R
com.apple.coredata.ubiquity.logLevel
%s(%d): CoreData: Ubiquity:  Checking log level threw: %@
-[PFUbiquityLogging init]_block_invoke
desiredLogLevel
Ti,N,V_desiredLogLevel
Invalid EventType %u
idString
T@"NSString",R,N,V_idString
Tq,R,N,V_hash
eventType
Tq,R,N,V_eventType
%@:%@->%ld:%@
Begin
Diagnostic
Debug
Warning
Error
Fatal
logLevel
Tq,V_logLevel
PFUbiquitySetup
PFUbiquityTransactionExport
PFUbiquityTransactionImport
PFUbiquityTransactionConflict
PFUbiquityBaselineRoll
DROP INDEX IF EXISTS Z_%@_%@
PFUbiquityFilePresenterDiscoveredLogLocationsNotification
PFUbiquityFilePresenterBaselineFileChangedNotification
PFUbiquityLocationsWereScheduledNotification
PFUbiquityLocationImportCancelledNotification
PFUbiquityLocationWasImportedNotification
PFUbiquityLocationWasExportedNotification
PFUbiquityFilePresenterAddPathsNotification
PFUbiquityFilePresenterPrintStatusNotification
PFLogLocationsKey
PFBaselineLocationKey
/System/Library/PrivateFrameworks/CloudDocs.framework/CloudDocs
BRStartDownloadForItems
CloudDocs.framework missing symbol BRStartDownloadForItems
BRRegisterInitialSyncHandlerForContainer
CloudDocs.framework missing symbol BRRegisterInitialSyncHandlerForContainer
BRUbiquitousContainersRootFolderName
CloudDocs.framework missing symbol BRUbiquitousContainersRootFolderName
Unable to dynamically link CloudDocs.framework
Mobile Documents
com.apple.coredata.ubiquity.fpqueue
ubiquityRootLocation: %@
localPeerID: %@
%s(%d): CoreData: Ubiquity:  %@
Got change notification for url: %@
-[PFUbiquityFilePresenter presentedSubitemDidChangeAtURL:]
%s(%d): CoreData: Ubiquity:  %@
Processing pending urls: %@
-[PFUbiquityFilePresenter processPendingURLs]
%s(%d): CoreData: Ubiquity:  Didn't get a location back for url: %@
%s(%d): CoreData: Ubiquity:  Skipping location (wrong root location): %@
%s(%d): CoreData: Ubiquity:  Skipping location (wrong store name): %@
%s(%d): CoreData: Ubiquity:  Skipping location (imported):
%s(%d): CoreData: Ubiquity:  Skipping location (exported):
%s(%d): CoreData: Ubiquity:  URL is a promise file, skipping file URL state check for:%@
%s(%d): CoreData: Ubiquity:  Starting download for promise base dir: %@
%s(%d): CoreData: Ubiquity:  Starting download for: %@
%s(%d): CoreData: Ubiquity:  File isn't live yet: %@
.nosync
%s(%d): CoreData: Ubiquity:  Starting download for file that is not live: %@
%s(%d): CoreData: Ubiquity:  Librarian returned a serious error for starting downloads %@ with userInfo %@ for these urls: %@
-[PFUbiquityFilePresenter processPendingURLs]_block_invoke
%s(%d): CoreData: Ubiquity:  Found transaction log locations: %@
%s(%d): CoreData: Ubiquity:  %@
Status: %@
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while processing pending logs: %@
%s(%d): CoreData: Ubiquity:  %@
Export notification was missing transaction log location: %@
-[PFUbiquityFilePresenter logWasExported:]
-[PFUbiquityFilePresenter logWasImported:]
-[PFUbiquityFilePresenter logImportWasCancelled:]
%s(%d): CoreData: Ubiquity:  %@ logs were scheduled: %@
-[PFUbiquityFilePresenter logsWereScheduled:]_block_invoke
-[PFUbiquityFilePresenter logsWereScheduled:]
-[PFUbiquityFilePresenter setupAssistantDiscoveredPathsFromMetadataQuery:]
%@:%ld: 
live:
not-live:
deleted:
imported:
exported:
downloaded:
downloading:
uploaded:
uploading:
failed:
unknown status
%s(%d): CoreData: Ubiquity:  %@
-[PFUbiquityFilePresenter printStatus:]_block_invoke
T@"PFUbiquityLocation",R,V_ubiquityRootLocation
T@"NSOperationQueue",R
locationToStatus
T@"NSDictionary",R,N,V_locationToStatus
locationToSafeSaveFile
T@"NSDictionary",R,N,V_locationToSafeSaveFile
%s(%d): CoreData: Ubiquity:  Resulting source object: %@
-[PFUbiquityRecordImportConflict resolveMergeConflictForLogContent:previousSnapshot:andAncestorSnapshot:withOldVersion:andNewVersion:error:]
%s(%d): CoreData: Ubiquity:  Resolve conflict called on: %@
-[PFUbiquityRecordImportConflict resolveConflict:]
%s(%d): CoreData: Ubiquity:  %@ aborting conflict resolution, unable to create snapshot for transaction entry: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Elected ancestor vector: %@ and snapshot: %@
New vector: %@
%s(%d): CoreData: Ubiquity:  Got nil snapshot for peerID: %@ and transaction number: %@
new knowledge vector: %@
import conflict: %@
%s(%d): CoreData: Ubiquity:  Sorting snapshots: %@
%s(%d): CoreData: Ubiquity:  Comparing:
%f - %@
%f - %@
-[PFUbiquityRecordImportConflict resolveConflict:]_block_invoke
%s(%d): CoreData: Ubiquity:  Got snapshots to merge: %@
%s(%d): CoreData: Ubiquity:  Error encountered trying to reset the source object to the ancestor state: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Merging snapshot into current snapshot: %@
%s(%d): CoreData: Ubiquity:  Merging current snapshot: %@
With previous snapshot: %@
 and ancestor snapshot: %@
%s(%d): CoreData: Ubiquity:  Error encountered trying to resolve conflict: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Done resolving conflict: %@
%s(%d): CoreData: Ubiquity:  Exception encountered while performing setup for conflict: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unknown Exception encountered while performing setup for conflict: %@
%s(%d): CoreData: Ubiquity:  Skipping inserted object with globalID: %@ because it was later deleted, and the re-inserted by the transaction with entry: %@
+[PFUbiquityRecordImportConflict resolvedTypeForConflictingLogType:andLatestTransactionEntry:skipObject:]
%s(%d): CoreData: Ubiquity:  Skipping inserted object with globalID: %@ because it was later deleted by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Skipping updated object with globalID: %@ because it was later inserted (meaning it had to have also been deleted by some prior transaction) by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Skipping updated object with globalID: %@ because it was later deleted by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Object with globalID: %@ was later inserted by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Skipping deleted object with globalID: %@ because it was already deleted, and then deleted by the transaction with entry: %@ and thus no longer exists in the store.
%s(%d): CoreData: Ubiquity:  Deleting existing object with globalID: %@ because previously deleted in a log file.
%s(%d): CoreData: Ubiquity:  Unknown property type: %@
+[PFUbiquityRecordImportConflict createSnapshotFromManagedObject:withSourceObject:]
-[PFUbiquityRecordImportConflict createSnapshotFromLogContent:withTransactionLog:]
Unable to map objectIDs
%s(%d): CoreData: Ubiquity:  Unable to find transaction log for entry: %@
+[PFUbiquityRecordImportConflict createTransactionLogForTransactionEntry:withImportContext:error:]
%s(%d): CoreData: Ubiquity:  Unknown change type for transaction entry: %@
conflictingObjectGlobalIDStr: %@
sourceObject: %@
conflictingLogContent: %@
conflictingLogTransactionType: %d
conflictLogDate: %@
conflictingLogKnowledgeVector: %@
transactionHistory: %@
globalIDStrToLocalIDURIMap: %@
conflictingObjectGlobalIDStr
T@"NSString",&,N,V_conflictingObjectGlobalIDStr
T@"NSManagedObject",&,N,V_sourceObject
conflictingLogContent
T@"NSDictionary",&,N,V_conflictingLogContent
conflictingLogKnowledgeVector
T@"PFUbiquityKnowledgeVector",&,N,V_conflictingLogKnowledgeVector
currentKnowledgeVector
T@"PFUbiquityKnowledgeVector",&,N,V_currentKnowledgeVector
conflictingLogTransactionType
Ti,N,V_conflictingLogTransactionType
conflictLogDate
T@"NSDate",&,N,V_conflictLogDate
conflictingLogTransactionNumber
T@"NSNumber",&,N,V_conflictingLogTransactionNumber
transactionHistory
T@"NSArray",&,N,V_transactionHistory
globalIDIndexToLocalIDURIMap
T@"NSDictionary",&,N,V_globalIDIndexToLocalIDURIMap
relationshipToObjectIDsToCheck
T@"NSDictionary",R,N,V_relationshipsToObjectIDsToCheck
ancestorSnapshot
T@"NSDictionary",&,V_ancestorSnapshot
cdutil-stub-container
Failed to load persistent store at url: %@
Timed out waiting for the mirroring delegate to finish setting up. This is a bug. Please re-run and attach a sample of cdutil if you can.
CloudKit Metadata:
q24@?0@"NSCKMetadataEntry"8@"NSCKMetadataEntry"16
%@: %@
Failed to fetch metadata entries:
Database: %@ (%ld): hasSubscription: %@, currentChangeToken: %@
Zone: %@:%@: hasRecordZone: %@, hasSubscription: %@, currentChangeToken: %@
Failed to fetch database metadata entries:
Unable to create a copy of the store at url: %@
This store has never been used with CloudKit (use cdutil dumpmetadata [storePath] to show store metadata): %@
Unable to load model from store: %@
cdutil
Failed to create temporary directory: %@
Generated records:
Failed to generate records: %@
Failed to load a managed object model. Arguments:
storeURL: %@
modelURL: %@
Encountered error: %@
Failed to move store to a temporary location: %@
Failed to create a temporary directory for working on the store.
ANSCKMIRROREDRELATIONSHIP
Attepmting to check for CloudKit tables failed: %@
Failed to tear down read-only store: %@
Failed to open store: %@
cloudKitMetadataTransformerName
forConflictAnalysis
TB,N,V_forConflictAnalysis
com.apple.coredata.ubiquity.eat
%@: 
storeNameToEntry: %@
rootLocationToFilePresenter: %@
All stores registered with the same NSPersistentStoreUbiquitousContentNameKey must use the same location on the file system.
%s(%d): CoreData: Ubiquity:  %@
Asked to unregister non-ubiquitized store: %@
-[PFUbiquitySwitchboard unregisterPersistentStore:inCoordinator:]
com.apple.coredata.ubiquity.entry.pq
%@: 
localPeerID: %@
ubiquityRootURL: %@
registeredCoordinators: %@
%s(%d): CoreData: Ubiquity:  %@
Scheduled logs for importer: %@
-[PFUbiquitySwitchboardEntry filePresenterWasNotifiedTransactionLogs:]
%s(%d): CoreData: Ubiquity:  Unable to import transaction log: %@
%s(%d): CoreData: Ubiquity:  %@
Scheduling encountered an error: %@
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while processing transaction logs: %@ with userInfo: %@
%s(%d): CoreData: Ubiquity:  Error purging transaction history cache after account change: %@
-[PFUbiquitySwitchboardEntry containerIdentifierChanged:]
%s(%d): CoreData: Ubiquity:  Error loading new temporary coordinator after account change with options { %@ } and URL %@ and error = %@
keyboardservicesd
%s(%d): CoreData: Ubiquity:  Error loading new store metadata after account change: %@
-[PFUbiquitySwitchboardEntry containerIdentifierChanged:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Registered store: %@ with entry: %@
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while trying to recover from account change: %@ (%@)
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while trying to recover from account change: %@
%s(%d): CoreData: Ubiquity:  Beginning to watch for changes from: %@
-[PFUbiquitySwitchboardEntry finishSetupForStore:withSetupAssistant:synchronously:error:finishBlock:]
activeStoreCount
TQ,V_activeStoreCount
T@"PFUbiquityLocation",R,V_localRootLocation
filePresenter
T@"PFUbiquityFilePresenter",R,V_fp
localFilePresenter
T@"PFUbiquityFilePresenter",R,V_localFP
T@"PFUbiquityContainerMonitor",R,V_monitor
finishingSetupAssistant
T@"PFUbiquitySetupAssistant",R,V_finishingSetupAssistant
T@"PFUbiquitySwitchboardEntryMetadata",&,N,V_metadata
-[PFUbiquitySwitchboardEntryMetadata addPersistentStore:]
%s(%d): CoreData: Ubiquity:  %@:%@
Using local storage: %d for new NSFileManager current token %@
-[PFUbiquitySwitchboardEntryMetadata setUseLocalStorage:]
cacheWrapper
T@"PFUbiquitySwitchboardCacheWrapper",&,N,V_cacheWrapper
importer
T@"_PFUbiquityRecordsImporter",R,N,V_importer
exporter
T@"_PFUbiquityRecordsExporter",R,N,V_exporter
stores
T@"NSSet",R,N,V_stores
activeModelVersionHash
T@"NSString",R,N,V_activeModelVersionHash
T@"NSSQLCore",R,N,V_privateStore
useLocalAccount
TB,N,V_useLocaAccount
baselineHeuristics
T@"PFUbiquityBaselineHeuristics",R,N,V_baselineHeuristics
Invalid attempt to process transaction '%@' twice.
Invalid invocation of '%@', cannot be called after '%@'
q24@?0@"PFHistoryAnalyzerObjectState"8@"PFHistoryAnalyzerObjectState"16
v32@?0@"PFHistoryAnalyzerObjectState"8Q16^B24
objectIDToState
T@"NSDictionary",R,N,V_objectIDToState
processedTransactionIDs
T@"NSSet",R,N,V_processedTransactionIDs
sortedStates
T@"NSArray",R,N,V_sortedStates
entityNameToObjectIDs
T@"NSDictionary",R,N,V_entityNameToObjectIDs
isFinished
TB,R,N,V_isFinished
T@"NSSQLManyToMany",R,N,V_relationship
%@ '%@': %@ %f
-[PFCloudKitImporterFetchRecordsWorkItem doWorkWithCompletion:]_block_invoke
v24@?0@"CKRecordID"8d16
v32@?0@"CKRecord"8@"CKRecordID"16@"NSError"24
v24@?0@"NSDictionary"8@"NSError"16
%@ - Exception thrown during fetch records operation: %@
-[PFCloudKitImporterFetchRecordsWorkItem newMirroringResultByApplyingAccumulatedChanges:]_block_invoke
Failed to process changes for request (%@):
-[PFCloudKitImporterFetchRecordsWorkItem addUpdatedRecord:]
%@ encountered error while fetching record %@
-[PFCloudKitImporterFetchRecordsWorkItem fetchFinishedForRecord:withID:error:]
%@ - Fetch: %@ finished with error: %@
-[PFCloudKitImporterFetchRecordsWorkItem fetchOperationFinishedWithError:completion:]_block_invoke
-[PFCloudKitImporterFetchRecordsWorkItem removeDownloadedAssetFiles]
updatedRecordIDs
T@"NSArray",R,N,V_updatedRecordIDs
%s(%d): CoreData: Ubiquity:  Error checking the uploaded status for: %@
Error: %@
-[PFUbiquityFileCoordinator coordinateReadingItemAtLocation:options:retryOnError:error:byAccessor:]
%s(%d): CoreData: Ubiquity:  Unlinking orphaned file: %@
%s(%d): CoreData: Ubiquity:  %@
Replacing error with file upload error: %@
%s(%d): CoreData: Ubiquity:  %@
Coordinated read returned an error: %@
userInfo: %@
 Retrying (%u).
LibrarianErrorDomain
%s(%d): CoreData: Ubiquity:  %@
Encountered unknown librarian error: %@
userInfo: %@
-[PFUbiquityFileCoordinator shouldRetryForError:ignoreFile:]
UBErrorDomain
%s(%d): CoreData: Ubiquity:  %@
Encountered unknown ubiquity error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Encountered unrecoverable error: %@
userInfo: %@
%@ only accepts a NSFetchRequest that has the entity set to a Persistent History Entity
ANY TRANSACTIONID IN %@
ANY %@ %@ %lld
ANY %@.%@ %@ %f
_pk %@ %lld
%@ %@ %f
NSPersistentHistoryChangeRequest : %@ < %@ - %@-%@> %lu
NSPersistentHistoryChangeRequest : %@ <%@ - %@-%@> limit - %lu, batchSize - %lu, resultType - %lu, fetchRequest - %@
Tq,V_resultType
T@"NSPersistentHistoryToken",R,V_token
T@"NSFetchRequest",&,N
Mismatched result types during aggregation of history status results
Mismatched result types during aggregation of history count results
Mismatched result types during aggregation of history object IDs results
Mismatched result types during aggregation of history results
%s <%p> with @property result: %@
Tq,R,V_resultType
%@: Failed to execute a history fetch: %@
T@"PFHistoryAnalyzerOptions",R,C,N,V_options
com.apple.coredata.ubiquity.baseline.roll
baseline.zip
baseline.meta
current.nosync
staging.nosync
storeName: %@
modelVersionHash: %@
baselineArchiveLocation: %@
%s(%d): CoreData: Ubiquity:  %@ Successfully removed contents of staging area.
-[PFUbiquityBaseline clearOutStagingLocationWithError:]
%s(%d): CoreData: Ubiquity:  %@
Error while preparing for baseline roll: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully created staging directory: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to create staging directory path, failing now: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully copied store to staging directory: %@
-[PFUbiquityBaseline prepareForBaselineRollOfPersistentStore:andLocalPeerID:error:]
%s(%d): CoreData: Ubiquity:  Unable to open staging store as URL is nil
%s(%d): CoreData: Ubiquity:  %@
Error removing the orphaned -shm file: %@
%s(%d): CoreData: Ubiquity:  %@
Error connecting to the staged baseline store file: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to copy store file to staging directory: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  No store file found at url: %@
Baseline: %@
Error: %@
userInfo: %@
-[PFUbiquityBaseline gatherContentsFromMigratedBaseline:withStoreFileURL:error:]
%s(%d): CoreData: Ubiquity:  Got more than one path component for subpath: %@ of baseline staging directory: %@
-[PFUbiquityBaseline gatherContentsAndConstructArchiveWithError:]
%s(%d): CoreData: Ubiquity:  Got nil data for staged store file at path: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to crate compressed archive of baseline contents: %@
userInfo: %@
-[PFUbiquityBaseline constructBaselineArchive:]
Coordinated read of baseline archive file succeeded, but the file could not be read: %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Coordinated read of baseline archive file: %@ did not succed: %@
userInfo: %@
-[PFUbiquityBaseline loadFileFromLocation:error:]
%s(%d): CoreData: Ubiquity:  Encountered baseline without any metadata in it's archive: %@
offendingBaseline
gcmodel
%s(%d): CoreData: Ubiquity:  Encountered baseline without any model data in it's archive: %@
%s(%d): CoreData: Ubiquity:  Failed to decode model from archive: %@
storeFilenameToData
storeFilename
%s(%d): CoreData: Ubiquity:  Encountered baseline without any filenames data in it's archive: %@
%s(%d): CoreData: Ubiquity:  Encountered baseline without any filename data in it's archive: %@
%s(%d): CoreData: Ubiquity:  Encountered baseline without any file data in it's archive for file named: %@
Baseline: %@
-[PFUbiquityBaseline unpackStoreFilesToStagingLocation:]
offendingFilename
%s(%d): CoreData: Ubiquity:  Failed to clear out staging directory after store replacement: %@
userInfo: %@
-[PFUbiquityBaseline replaceLocalPersistentStoreAtURL:ofType:withOptions:usingPersistentStoreCoordinator:error:]
%s(%d): CoreData: Ubiquity:  %@
Checking to see if it can replace store with knowledge vector: %@
-[PFUbiquityBaseline canReplaceStoreAtKnowledgeVector:]
%s(%d): CoreData: Ubiquity:  %@
Local store is current with the baseline
%s(%d): CoreData: Ubiquity:  %@
Local store has a zero vector
%s(%d): CoreData: Ubiquity:  %@
Local store is an ancestor of the baseline
%s(%d): CoreData: Ubiquity:  %@
Baseline is an ancestor of the local store
%s(%d): CoreData: Ubiquity:  %@
Beginning knowledge vector inspection
%s(%d): CoreData: Ubiquity:  %@
Finished check: %d
%s(%d): CoreData: Ubiquity:  %@
Need logs for peer %@ between %ld and %ld to adopt
-[PFUbiquityBaseline haveTransactionLogsForPeer:between:and:]
%s(%d): CoreData: Ubiquity:  %@
Unable to load log: %@ while checking for baseline adoption: %@
%s(%d): CoreData: Ubiquity:  We are forked from baseline...force it
Unable to find missing transaction files
%s(%d): CoreData: Ubiquity:  we found some logs but the peer is still behind...should we force fork??
%s(%d): CoreData: Ubiquity:  %@
Didn't find all the required logs for baseline adoption, giving up
offendingPeers
%s(%d): CoreData: Ubiquity:  Receipt file has no write date: %@
+[PFUbiquityBaseline isPeerReceiptTooOld:]
%s(%d): CoreData: Ubiquity:  Error encountered making this baseline: %@ the current baseline: %@
userInfo: %@
-[PFUbiquityBaseline importBaselineForStoreAtURL:ofType:options:withLocalPeerID:stack:andPersistentStoreCoordinator:error:]
%s(%d): CoreData: Ubiquity:  Error initializing the baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Didn't get persistent store from the baseline coordinator: %@
-[PFUbiquityBaseline updateCurrentStoreIdentifier:error:]
%s(%d): CoreData: Ubiquity:  %@
Making current: %@
-[PFUbiquityBaseline makeCurrentBaselineWithError:]
%s(%d): CoreData: Ubiquity:  Error attempting to create the stores directory for the current baseline: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error attempting to create the directory for the current baseline: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error cleaning out current baseline directory: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error creating directory for baseline file: %@
Error: %@
userInfo: %@
-[PFUbiquityBaseline writeFileToLocation:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error writing new baseline file to URL: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error attempting to write new baseline archive to url: %@, error: %@
userInfo: %@
-[PFUbiquityBaseline writeFileToLocation:error:]
%s(%d): CoreData: Ubiquity:  Removing identifiers from: %@
+[PFUbiquityBaseline removePeerSpecificIdentifiersFromStore:withLocalPeerID:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Unable to open store file: %@
-[PFUbiquityBaseline _createPersistentStoreCoordinatorForCurrentBaseline:error:]
%s(%d): CoreData: Ubiquity:  %@
Unable to open store file: %@ as URL is nil
%s(%d): CoreData: Ubiquity:  Got nil model for baseline: %@
Error: %@
userInfo: %@
-[PFUbiquityBaseline createManagedObjectModel]
%s(%d): CoreData: Ubiquity:  Failed to read gc model data: %@
%s(%d): CoreData: Ubiquity:  Couldn't load optimized model at url: %@
+[PFUbiquityBaseline createBaselineOptimizedModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Cannot find optimized model at URL: %@.
It appears there is no current baseline.
%s(%d): CoreData: Ubiquity:  Couldn't load model at url: %@
+[PFUbiquityBaseline createBaselineGCModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Cannot find model at URL: %@.
It appears there is no current baseline.
%s(%d): CoreData: Ubiquity:  Didn't get baseline metadata back from metadata url: %@
Error: %@
userInfo: %@
+[PFUbiquityBaseline metadataFromCurrentBaselineForStoreWithName:peerID:modelVersionHash:andUbiquityRootLocation:withError:]
%s(%d): CoreData: Ubiquity:  Failed to baseline metadata: %@
+[PFUbiquityBaseline metadataFromBaselineArchive:]
%s(%d): CoreData: Ubiquity:  Error getting data for optimized encoding: %@
userInfo: %@
Model: %@
+[PFUbiquityBaseline createArchiveWithModel:metadata:storeFilenameToData:storeFilename:error:]
%s(%d): CoreData: Ubiquity:  Error getting data for regular encoding: %@
userInfo: %@
Model: %@
/.baseline
%s(%d): CoreData: Ubiquity:  %@ does not appear to be a baseline path
+[PFUbiquityBaseline createStringOfContentsOfBaselineFile:]
1234UUID
storeFilename: %@
storeName: %@
modelVersionHash: %@
%s(%d): CoreData: Ubiquity:  Couldn't read contents of baseline: %@
%s(%d): CoreData: Ubiquity:  Couldn't get metadata from current location: %@
baselineArchiveLocation
baselineStagingLocation
T@"PFUbiquityLocation",R,V_baselineStagingLocation
baselinePeerArchiveLocation
T@"PFUbiquityBaselineMetadata",R,V_metadata
T@"NSDictionary",R,V_storeFilenameToData
T@"NSString",R,V_storeFilename
T@"NSString",R,V_modelVersionHash
baselineArchive
T@"_PFZipFileArchive",R,V_baselineArchive
T@"NSPersistentStore",R,V_store
createRecordZoneID called before object has an owner name and zone name: %@
%K = %@ AND %K = %@ AND database.databaseScopeNum = %@
T@"CKServerChangeToken",&,D,N
T@"NSCKDatabaseMetadata",&,D,N
hasRecordZone
hasSubscription
storeName: %@
authorPeerID: %@
modelVersionHash: %@
knowledgeVector: %@
peerRanges: %@
%s(%d): CoreData: Ubiquity:  Got a bad gap for range: %@
Previous range: %@
Store: %@
-[PFUbiquityBaselineMetadata gatherMetadataWithStore:andError:]
exception %@ with userInfo %@ during -gatherMetadataWithStore:andError:
authorPeerID
peerStates
%s(%d): CoreData: Ubiquity:  Not sure what to do with baseline metadata knowledge vector object: %@
-[PFUbiquityBaselineMetadata initWithCoder:]
previousKnowledgeVector
peerRanges
T@"NSString",R,V_authorPeerID
T@"PFUbiquityKnowledgeVector",R,N,V_pKV
knowledgeVector
T@"PFUbiquityKnowledgeVector",R,V_kv
T@"NSDictionary",R,V_peerRanges
nostore
<NSQueryGenerationToken: %p>
currentQueryGenerationToken
T@"NSQueryGenerationToken",R
unsupported
NSQueryTokenIsSingleton
NSQueryTokenWhichSingleton
NSQueryTokenIsCompound
NSQueryTokenStoreIdentifier
NSQueryTokenGenerationIdentifier
<NSQueryGenerationToken : {
, %p
<NSQueryGenerationToken : %@/%@>
Can't reattach all stores specified by token
expected stores
Array with content where there should be a set.
forceUpdates
TB,R,N,V_forceUpdates
interrupts
TQ,N,V_interrupts
changeCache
rowsToDelete
operationUUID == %@
Duplicate operations for identifier: %@
q24@?0@"CKRecordID"8@"CKRecordID"16
Stores don't match because they do not have the same mirroring configuration:
%@ - %@
%@ - %@
Stores don't match because they do not have the same mirroring options:
%@ - %@
%@ - %@
System fields shouldn't be set anymore: %@
Record name does not match recordID, even though our metadata linked this row with '%@': %@
Record name appears to point to two different objects: %@ / %@
Objects appear to be from different entities:
Store: %@
Other Store: %@
Failed to retrieve object with recordID '%@' from store %@
Stores do not contain the same record names. (%@:%lu / %@:%lu)
Mirrored relationships don't match for stores:
Store has these extra keys: %@
Other Store has these extra keys: %@
Ignored attribute (%@:%@) appears to have been synced:
Value: %@
Other value: %@
Attribute values do not match (%@):
Store: %@
Other Store: NULL
Attribute values do not match (%@):
Store: NULL
Other Store: %@
Attribute values do not match (%@):
Store: %@
Other Store: %@
Unknown value type '%@' for attribute: %@
Not sure what to do with undefined attributes
Unknown attribute type: %lu
Ignored relationship (%@:%@) appears to have been synced:
Value: %@
Other value: %@
Mirrored relationships don't match actual record for '%@' in %@
Object: %@
Mirrored Relationships: %@
Mirrored relationships don't match for object with record name (%@): 
Store: %@
Other Store: %@
Relationship doesn't match for object with record name (%@): %@
Store: %@
Other Store: %@
Found mirrored relationship for ignored relationship: %@
Found mirrored relationship not marked uploaded, but this method is supposed to make sure store contents are equal, so shouldn't it be?
Found mirrored relationship that's marked deleted but the objects are linked.
Found pending mirrored relationship for linked objects (%@).
v32@?0@"NSManagedObject"8Q16^B24
Stores disagree about whether or not CloudKit metadata tables are present: %@
Stores don't have the same number of mirrored relationships: %lu / %lu
Trimmed: %@
checkCloudKitMetadata
TB,R,N,V_checkCloudKitMetadata
cache
T@"PFCloudKitStoreComparisonCache",R,N,V_cache
_executeObjectFaultRequest passed a nil objectID
exception fetching row for object with ID: %@ with userInfo of %@
Asked to fault objectID %@ but database returned row with different objectID %@
Database appears corrupt.  Asked to fault objectID %@ but database returned row with different objectID %@
Asked to fault objectID %@ but database returned multiple rows
failed to resolve fault to exactly one object for %@
fault fulfilled from database for : %@ with row values: %@
fault fulfilled from database for : %@
orderKey
exception during newFetchedPKsForSourceID: %@ with userInfo of %@
to-many relationship fault "%@" for objectID %@ fulfilled from database.  Got %d rows with values: %@
to-many relationship fault "%@" for objectID %@ fulfilled from database.  Got %d rows
Batch insert failed to generate a post transaction query generation with error %d
Batch insert did not affect any rows, not registering a query generation
Batch delete failed to generate a post transaction query generation with error %d
Batch delete did not affect any rows, not registering a query generation
Unhandled error from executeBatchDeleteRequest %@ and userInfo %@
Unhandled exception from executeBatchDeleteRequest %@
drop triggers during NSBatchDeleteRequest failed because %@ with userInfo %@
rollback during NSBatchDeleteRequest failed because %@ with userInfo %@
Unable to generate updateStatement for affected object IDs (cause unknown)
Short-circuiting batch update: impossible condition in where clause (2)
Batch update failed to generate a post transaction query generation with error %d
Batch update did not affect any rows, not registering a query generation
Persistent history request failed to adopt a query generation with error %d
Persistent History Token is expired for store at %@
Unhandled error encountered during change request %@ with userInfo %@
Unhandled exception encountered during change request: %@ with userInfo %@
Missing transaction scope for change tracking of changes.
, %qi
SELECT %@,%@ FROM %@ WHERE %@ IN (%@) ORDER BY %@
Optimistic locking failure for %@.  Row was deleted.  Original row = %@ New Row = <deleted>
Optimistic locking failure for %@.  Row was deleted.
Optimistic locking failure for %@.  Row was updated.  Original row = %@ New Row = %@
Optimistic locking failure for %@.  Row was updated.
Unsupported unique attribute type: %@
Optimistic locking failure for %@.  During write changes, deletion failed.  Row was updated.  Original row = %@ New Row = %@
Optimistic locking failure for %@.  During write changes, deletion failed.  Row was updated.
SaveChanges: NSSQLCore: %p Transactions cannot be nested
requestContext
Save changes failed to generate a post transaction query generation with error %d
Missing transaction scope for commit changes.
addedOrUpdated
logically false count request %@ short circuits.
count request %@ returned %d
total count request execution time: 
[31m%.4f
[0ms for count of %d.
total count request execution time: %.4fs for count of %d.
%@ %@ JOIN %@ %@ %@%@
SELECT %@%@, %@%@ FROM 
SELECT %@%@ FROM 
SELECT 0, %@%@ FROM 
 %qi
 %@, %@
, %@.%@
%@ IN ( 
%qu, 
%qu ) 
AND 
q24@?0@"NSManagedObjectID"8@"NSManagedObjectID"16
Prefetching from join table for many-to-many relationship "%@" from database.  Got %lu rows with values: %@
Prefetching from join table for many-to-many relationship "%@" from database.  Got %lu rows
Prefetching with request %@.  Got %lu rows with values: %@
Prefetching with key '%@'.  Got %lu rows.
com.apple.CoreData.BufferAllocations.VMMemory
com.apple.CoreData.BufferAllocations.OneBuffer
VM Memory is already One Buffer Row that grows!!!
com.apple.CoreData.BufferAllocations.ManyResultSets
VM Memory does not support multiple result sets!!!
logically false fetch request %@ short circuits.
sql connection fetch statement: '%@'
XPC Store fetch encountered an error : %@
XPC Store fetch raised an exception : %@
localPeerID: %@
storeNameToStoreExportContext: %@
ubiquityRootLocation: %@
localPeerID: %@
storeName: %@
transactionEntries: %@
transactionEntries
T@"NSSet",R,N,V_transactionEntries
T@"NSSQLCore",&,N,V_store
<%@: %p> %@
requestIdentifier
T@"NSUUID",R,N,V_requestIdentifier
T@"NSCloudKitMirroringRequestOptions",R,C,N,V_options
T@?,R,C,N,V_requestCompletionBlock
<NSPersistentHistoryTransaction: %lld, %@, %@, %@, %@, %@, %@>
T@"NSDate",R,C
storeID
T@"NSPersistentHistoryToken",R
NSPersistentHistoryTransactionStoreID
NSPersistentHistoryTransactionRowID
NSPersistentHistoryTransactionTimestamp
NSPersistentHistoryTransactionChangeSet
NSPersistentHistoryTransactionBundleID
NSPersistentHistoryTransactionProcessID
NSPersistentHistoryTransactionContextName
NSPersistentHistoryTransactionAuthor
NSPersistentHistoryTransactionQueryGen
p%lu
%@ (%@)
T@"NSString",R,N,V_entityName
primaryKey
T@"NSString",R,N,V_primaryKey
owningPeerID
T@"NSString",R,N,V_owningPeerID
TQ,R,N,V_hash
managedObjectID
T@"NSManagedObjectID",&,N,V_managedObjectID
primaryKeyInteger
TQ,R,N,V_primaryKeyInteger
com.apple.CoreData.CloudKitDebug
Checking log level threw: %@
transactionDate: %@
modelVersionHash: %@
exportingPeerID: %@
storeNameToSaveSnapshots: %@
T@"NSDate",&,N,V_transactionDate
T@"NSString",R,N,V_exportingPeerID
storeNames
Must supply a non-zero number of objectIDs to request during initialization
mismatched objectIDs in batch delete initializer
objectIDs
Must supply a fetch request during initialization
Fetch must have an entity
<NSBatchDeleteRequest : resultType : %ld, fetch :%@ >
TQ,V_resultType
T@"NSFetchRequest",R,C
Mismatched result types during aggregation of batch delete results
com.apple.coredata.ubiquity.snapshot
entityNames: %@
peerIDs: %@
globalObjectIDs: %@
primaryKeys: %@
managedObjectIDToGlobalObjectID: %@
entityNameToIndex: %@
peerIDToIndex: %@
primaryKeyToIndex: %@
insertedObjects: %@
updatedObjects: %@
deletedObjects: %@
peerStates: %@
transactionNumber: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to convert compressed object ID string: %@ to index number.
-[PFUbiquityStoreSaveSnapshot globalObjectIDFromCompressedObjectID:]
%s(%d): CoreData: Ubiquity:  %@
Reserved transaction knowledge vector: %@ (%@)
-[PFUbiquityStoreSaveSnapshot reserveTransactionNumberWithStoreExportContext:]
%s(%d): CoreData: Ubiquity:  %@
Generating Peer States: %@
-[PFUbiquityStoreSaveSnapshot generatePeerStates]
%s(%d): CoreData: Ubiquity:  Hrm found something in empty array did you? %@
i: %lu
NSNotFound: %lu
-[PFUbiquityStoreSaveSnapshot replaceGlobalObjectID:withGlobalObjectID:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@ replacing global object id:
old: %@
new: %@
%s(%d): CoreData: Ubiquity:  %@ wasn't in this snapshot: %@
Failed to copy external reference to ubiquity container
Underlying error
%s(%d): CoreData: Ubiquity:  Got final value for relationship: %@
Object: %@
-[PFUbiquityStoreSaveSnapshot createUbiquityDictionary:withStoreExportContext:error:]
entityNames
T@"NSArray",R,N,V_entityNames
peerIDs
T@"NSArray",R,N,V_peerIDs
globalObjectIDs
T@"NSArray",R,N,V_globalObjectIDs
primaryKeys
T@"NSArray",R,N,V_primaryKeys
T@"NSDictionary",R,N,V_insertedObjects
T@"NSDictionary",R,N,V_updatedObjects
T@"NSDictionary",R,N,V_deletedObjects
T@"NSDictionary",R,N,V_peerStates
T@"NSNumber",&,N,V_transactionNumber
T@"NSString",&,N,V_exportingPeerID
T@"NSString",&,N,V_localPeerID
storeKV
T@"PFUbiquityKnowledgeVector",&,N,V_storeKV
globalObjectIDToPermanentManagedObjectID
T@"NSDictionary",R,N,V_globalObjectIDToPermanentManagedObjectID
managedObjectIDToGlobalObjectID
T@"NSDictionary",R,N,V_managedObjectIDToGlobalObjectID
entityNameToIndex
T@"NSDictionary",R,N,V_entityNameToIndex
peerIDToIndex
T@"NSDictionary",R,N,V_peerIDToIndex
primaryKeyToIndex
T@"NSDictionary",R,N,V_primaryKeyToIndex
globalObjectIDToIndex
T@"NSDictionary",R,N,V_globalObjectIDToIndex
globalObjectIDCache
T@"PFUbiquityGlobalObjectIDCache",&,N,V_gidCache
tempLogs.nosync
.stage.nosync
Core Data: Ubiquity: Unable to process transaction log location: %@, doesn't appear to actually represent a transaction log location.
transactionLogLocation: %@
transactionNumber: %@
%s(%d): CoreData: Ubiquity:  Error encountered while trying to load the comparison metadata for transaction log: %@
Error: %@
userInfo: %@
-[PFUbiquityTransactionLog loadContents:]
%s(%d): CoreData: Ubiquity:  %@
Missing transaction date from contents: %@
-[PFUbiquityTransactionLog loadComparisonMetadataWithError:]
compressedGlobalIDs
%s(%d): CoreData: Ubiquity:  Got nil zip archive: %@
Error: %@
-[PFUbiquityTransactionLog loadPlistAtLocation:withError:]
%s(%d): CoreData: Ubiquity:  %@
Unable to read data from extended attributes: %@
Setup assistant was torn down.  Error reading the log file at location: %@
missingFile
Error encountered trying to read data inside coordinated accessor: %@
userInfo: %@, local error: %@
userInfo: %@
Error reading the log file at location: %@
userInfo: %@
contents
Error during property list parsing during import or opening of log file at location: %@, error: %@
Error getting data during property list parsing during import or opening of log file at location: %@
externalDataReferencesInfo
%s(%d): CoreData: Ubiquity:  Encountered an error attempting to remove external data reference (%@): %@
userInfo: %@
-[PFUbiquityTransactionLog cleanupExternalDataReferences]_block_invoke
%s(%d): CoreData: Ubiquity:  Error deleting log file: %@
Error: %@
userInfo: %@
-[PFUbiquityTransactionLog deleteLogFileWithError:]
CoreData: Ubiquity: Error writing export log to file: %@
error: %@
userInfo: %@
-[PFUbiquityTransactionLog moveFileToPermanentLocationWithError:]
CoreData: Ubiquity: Error creating data for export: %@
userInfo: %@
 from transaction log: %@
-[PFUbiquityTransactionLog writeToDiskWithError:andUpdateFilenameInTransactionEntries:]
CoreData: Ubiquity: Error writing export log to file (%d:%d): %@
error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Error deleting existing log file: %@
-[PFUbiquityTransactionLog rewriteToDiskWithError:]
%s(%d): CoreData: Ubiquity:  %@
Error deleting existing log file (t): %@
%s(%d): CoreData: Ubiquity:  %@
Error deleting existing log file (s): %@
%s(%d): CoreData: Ubiquity:  Log file truncation failed to get a stack: %@
userInfo: %@
+[PFUbiquityTransactionLog truncateLogFilesForPeerID:storeName:modelVersionHash:beforeKnowledgeVector:withLocalPeerID:andUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Successfully deleted transaction entries before %@ for peer %@
%s(%d): CoreData: Ubiquity:  Error deleting transaction entries before %@ for peer %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error trying to inspect log files after baseline roll at location: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error encountered attempting to delete an old log file after the baseline rolled: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Error moving transaction log from temporary location: %@ to permanent location:
+[PFUbiquityTransactionLog pruneTemporaryLogDirectoryForPeerRootLocation:error:]
%@.%d.%@
cdVersion
kvStr
%s(%d): CoreData: Ubiquity:  Error encountered while updating the modification time for file (%d): %@
+[PFUbiquityTransactionLog updateModificationTimesForLocation:]
useTemporaryLogLocation
TB,N,V_useTemporaryLogLocation
inTemporaryLocation
TB,R,N,V_inTemporaryLocation
inStagingLocation
TB,R,N,V_inStagingLocation
inPermanentLocation
TB,R,N,V_inPermanentLocation
fileProtectionOption
T@"NSString",R,N,V_fileProtectionOption
T@"NSNumber",R,N
transactionLogFilename
transactionLogType
Ti,R,N,V_transactionLogType
transactionLogLocation
T@"PFUbiquityLocation",R,N,V_transactionLogLocation
temporaryTransactionLogLocation
T@"PFUbiquityLocation",R,N,V_temporaryTransactionLogLocation
stagingTransactionLogLocation
T@"PFUbiquityLocation",R,N,V_stagingTransactionLogLocation
saveSnapshot
T@"PFUbiquitySaveSnapshot",R,N,V_saveSnapshot
currentLocation
T@"PFUbiquityKnowledgeVector",R,N,V_knowledgeVector
loadUsingRetry
TB,N,V_loadUsingRetry
loadedComparisonMetadata
TB,R,N,V_loadedComparisonMetadata
loadedImportMetadata
TB,R,N,V_loadedImportMetadata
loadedInsertedObjectData
TB,R,N,V_loadedInsertedObjectData
loadedUpdatedObjectData
TB,R,N,V_loadedUpdatedObjectData
loadedDeletedObjectData
TB,R,N,V_loadedDeletedObjectData
%s(%d): CoreData: Ubiquity:  %@ didn't get entity description back for entity named: %@
MOC: %@
PSC: %@
-[PFUbiquityImportContext prefetchManagedObjectsInContext:error:]
stack
T@"_PFUbiquityStack",&,N,V_stack
T@"PFUbiquityStoreMetadata",&,N,V_storeMetadata
actingPeer
T@"PFUbiquityPeer",R,N,V_actingPeer
T@"PFUbiquityKnowledgeVector",&,N,V_kv
storeSaveSnapshot
T@"PFUbiquityStoreSaveSnapshot",&,N,V_storeSaveSnapshot
globalIDToLocalIDURICache
T@"NSDictionary",&,N,V_globalIDToLocalIDURICache
globalIDToFetchedObject
T@"NSMutableDictionary",R,N,V_globalIDToFetchedObject
heuristics
T@"PFUbiquityBaselineHeuristics",&,N,V_heuristics
/System/Library/Frameworks/CoreSpotlight.framework/CoreSpotlight
NSCoreDataCoreSpotlightDelegate tried to load a store '%@' twice
NSCoreDataCoreSpotlightDelegate failed to find its store '%@'.  Possibly it was removed from the coordinator.
NSCoreDataCoreSpotlightDelegate failed to load a store '%@' due to %@ with %@
Attempt to illegally register multiple NSCoreDataCoreSpotlightDelegate for a single store with description '%@'
CoreData: Spotlight Indexing
public.item
Error indexing (insert/update): %@
Error indexing (delete): %@
v24@?0@"NSData"8@"NSError"16
Unable to decode corespotlight token for entity '%@', doing full reimport (error: %@)
cdcs_done
Reindexing Spotlight details threw an unknown exception
SELF
SELF > %@
Full reimport failed for: %@ due to %@
Reindexing Spotlight details threw an unknown exception faulting managed object
Full reimport failed for %@ (reindex):
Full reimport failed for %@ (delete):
Full reimport failed for %@ (batch):
Invalid previous transaction token: %@. Current token is %@. Trying to start over.
coreSpotlightImportProgress
spotlight_%@_%@
spotlight_%@_%@_HistoryTracking_tracker
Unable to decode corespotlight token for %@, doing full reimport (error: %@)
Spotlight history token failed to decode with an unknown exception
Error indexing (insert/update 2): %@
Error indexing (delete 2): %@
NSCoreDataCoreSpotlightDelegate initializing support for persistent store for %@
NSCoreDataCoreSpotlightDelegate finished initialization for persistent store for %@
NSCoreDataCoreSpotlightDelegate initialization cancelled for persistent store for %@
_context
this initializer requires an SQLite store type
CSSearchableIndex
CSSearchableItem
CSSearchableItemAttributeSet
CSCustomAttributeKey
.externalData
ubRoot
Library/Mobile Documents
CoreDataUbiquitySupport
/private
%s(%d): CoreData: Ubiquity:  Path: %@ is a ubiquity root url.
Matches: %@
+[PFUbiquityLocation createUbiquityLocationForPath:withUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Path: %@ does not appear to be a descendant of the root url: %@
%s(%d): CoreData: Ubiquity:  It appears the store file is nested inside the container log directory. This is a really bad idea: %@
%s(%d): CoreData: Ubiquity:  Truncated path: %@ is a ubiquity root url.
Matches: %@
.icloud
%s(%d): CoreData: Ubiquity:  Changing path component to remove promise suffix previous: %@
%s(%d): CoreData: Ubiquity:  Changing path component to remove promise suffix new: %@
EXTERNAL_DATA
.0.cdt
.0.cdt.nosync
.cdt
.cdt.nosync
%s(%d): CoreData: Ubiquity:  Unable to continue parse components of URL: %@
Confused by: %@
%s(%d): CoreData: Ubiquity:  Ignoring private file: %@
%d is not a valid baseline location type.
%d is not a valid current baseline location type.
%@.0.cdt.nosync
%@.0.cdt
Core Data's ubiquity integration requires that the value for NSPersistentStoreUbiquitousContentURLKey point inside ~/Library/Mobile Documents. Given value: %@
offendingPath
%s(%d): CoreData: Ubiquity:  Got nil location for subpath: %@ of location: %@
+[PFUbiquityLocation createArrayOfSubLocationsAtLocation:error:]
ubiquityRootLocationPath
T@"NSString",R,N,V_ubiquityRootLocationPath
isRootUbiquitous
TB,R,N,V_isRootUbiquitous
ubiquityLocationType
Ti,R,N,V_ubiquityLocationType
filename
T@"NSString",R,N,V_filename
usesStagingLogDirectory
usesTemporaryLogDirectory
usesCurrentBaselineDirectory
usesBaselineStagingDirectory
usesBaselineDirectory
usesNosyncDirectory
otherPathComponents
T@"NSArray",R,N,V_otherPathComponents
isTransactionLogLocation
TB,R,N,GisTransactionLogLocation
isDirectory
TB,R,N,V_isDirectory
%@: Purging metadata for entity: %@
-[PFCloudKitImporterZoneDeletedWorkItem wipeCloudMetadataFromMirroredObjects:]_block_invoke
Failed to purge cloudkit metadata entity (%@): %@
deletedRecordZoneID
T@"CKRecordZoneID",R,N,V_deletedRecordZoneID
%K IN %@ OR recordName IN %@ OR relatedRecordName IN %@
isPending == 1
recordName = %@ and relationshipName = %@ and recordZone.ckRecordZoneName = %@ and recordZone.ckOwnerName = %@
relatedRecordName = %@ and relationshipName = %@ and recordZone.ckRecordZoneName = %@ and recordZone.ckOwnerName = %@
ckRecordID = %@
Found more than one mirrored relationship matching a many to many: %@
%K IN %@ OR (needsDelete = 1 AND isPending = 0)
%K IN %@ OR %K IN %@ OR needsDelete = 1
Attempted to update a mirrored relationship with a non-mirrored-relationship record: %@
%K = %@ AND %K = %@ AND %K = %@
Found more than one mirrored relationship for a many-to-many: %@
Unsupported predicate, RHS of boundBy: must contain 2 values
Unsupported predicate, topLeft parameter of boundBy: RHS must be a constant or keypath
Unsupported predicate, bottomRight parameter of boundBy: RHS must be a constant or keypath
Unsupported predicate, RHS of boundBy: must be an aggregate or constant
Unsupported predicate, constant topLeft parameter of boundBy: RHS must respond to coordinate
Unsupported predicate, constant lowerRight parameter of boundBy: RHS must respond to coordinate
SELECT %@.Z_PK FROM %@ %@ WHERE ? <= %@.%@_MAX AND %@.%@_MIN <= ? AND ? <= %@.%@_MAX AND %@.%@_MIN <= ?
entitiesAndCounts
T@"NSDictionary",R,N,V_entitiesAndCounts
T@"NSSQLModel",R,N,V_model
%s(%d): CoreData: Ubiquity:  Successfully initialized baseline: %@
-[PFUbiquityBaselineRollOperation haveConsistentStateForBaselineRoll]
%s(%d): CoreData: Ubiquity:  Error attempting to initialize baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Didn't download latest version: %@
%s(%d): CoreData: Ubiquity:  Got nil metadata for current baseline in operation: %@
%s(%d): CoreData: Ubiquity:  %@
Got an unknown error back from canRollBaseline: %@
-[PFUbiquityBaselineRollOperation rollBaselineWithError:]
%s(%d): CoreData: Ubiquity:  %@ successfully rolled baseline: %@
%s(%d): CoreData: Ubiquity:  %@ successfully rolled baseline but encountered an error trying to make it the current baseline: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Removed unused external data references
%s(%d): CoreData: Ubiquity:  %@
Error removing unused external data references: %@
%s(%d): CoreData: Ubiquity:  %@ encountered an error trying to write the baseline archive to disk: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@ Error encountered trying to roll baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unable to delete transaction log for peer: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to remove logs from peer: %@
%s(%d): CoreData: Ubiquity:  Exception encountered while trying to roll the baseline for operation: %@
Exception: %@
-[PFUbiquityBaselineRollOperation main]
T@"NSObject<PFUbiquityBaselineRollOperationDelegate>"
allObjectIDs
T@"NSSet",R,N,V_allObjectIDs
allDeletedObjectIDs
T@"NSSet",R,N,V_allDeletedObjectIDs
NSZipFileArchiveHeaderOffset
NSZipFileArchiveCompressionType
NSZipFileArchiveCRC
NSZipFileArchiveCompressedLength
NSZipFileArchiveUncompressedLength
CoreData: Ubiquity: Error writing file '%@', rename failed with errno %d
offsetOfConfusingBytes
readError
statError
closeError
CRC Mismatch: %@
1.2.11
lseekError
openError
entryNames
%@ - %@
versionMadeBy
TS,N,V_versionMadeBy
versionNeededToExtract
TS,N,V_versionNeededToExtract
generalPurposeBit
TS,N,V_generalPurposeBit
compressionMethod
TS,N,V_compressionMethod
lastModTime
TS,N,V_lastModTime
lastModDate
TS,N,V_lastModDate
crc32
TI,N,V_crc32
compressedSize
TI,N,V_compressedSize
uncompressedSize
TI,N,V_uncompressedSize
filenameLength
TS,R,N,V_filenameLength
extraFieldLength
TS,R,N,V_extraFieldLength
fileCommentLength
TS,R,N,V_fileCommentLength
fileStartDiskNumber
TS,N,V_fileStartDiskNumber
internalFileAttrs
TS,N,V_internalFileAttrs
externalFileAttrs
TI,N,V_externalFileAttrs
localFileHeaderRelativeOffset
TI,N,V_localFileHeaderRelativeOffset
T@"NSString",&,N,V_filename
extraFieldData
T@"NSData",&,N,V_extraFieldData
fileComment
T@"NSString",&,N,V_fileComment
%@ - %d:%d:%d:%d:%d:%d
numberOfDisk
TS,N,V_numberOfDisk
diskWhereCentralDirectoryStarts
TS,N,V_diskWhereCentralDirectoryStarts
numberOfCentralDirectoryRecordsOnThisDisk
TS,N,V_numberOfCentralDirectoryRecordsOnThisDisk
totalNumberOfCentralDirectoryRecords
TS,N,V_totalNumberOfCentralDirectoryRecords
byteSizeOfCentralDirectory
TI,N,V_byteSizeOfCentralDirectory
centralDirectoryOffset
TI,N,V_centralDirectoryOffset
commentLength
TS,R,N,V_commentLength
comment
T@"NSString",&,N,V_comment
totalHeaderLength
TI,R,N
peerKey
remoteStates
primaryKeyRanges
localPeerStates
transactionTypeNum
localIDStr
%@: %@
exportingPeerID: %@, transactionNumber: %@, transactionDate: %@
Log Snapshot: %@
Diff: %@
logSnapshot
T@"NSDictionary",R,N,V_logSnapshot
diffFromPrevious
T@"NSDictionary",R,N,V_diffFromPrevious
T@"PFUbiquityKnowledgeVector",R,N,V_kv
T@"NSNumber",R,N,V_transactionNumber
T@"NSDate",R,N,V_transactionDate
NSFileSize
No file exists at URL '%@'
_NSDataFileBackedFuture : <%@, %llu, %@ (%@)>
NSUUID
NSFileURL
NSOriginalFileURL
Underlying file for this file backed future has not been downloaded.
<null url>
Exception reading data for file backed future.  %@
<no error>
%@: First attempt at moving file to interim location failed: %@
Failed to copy file from %@ to %@ (%@)
%@: First attempt at moving in to place failed with error: %@
fileURL
fileSize
T@"NSUUID",R
TQ,R,V_fileSize
T@"NSUUID",R,V_uuid
_fileURLForSaving
T@"NSURL",R,&
originalFileURL
T@"NSURL",&,V_originalFileURL
%s(%d): CoreData: Ubiquity:  Generated diff for snapshot: %@
 Previous snapshot: %@
-[PFUbiquityPeerSnapshotCollection calculateSnapshotDiffsWithError:]
insertedObjectIDs: %@
deletedObjectIDs: %@
relationshipKey
T@"NSString",R,N,V_relationshipKey
%@: %@
v32@?0@"PFCloudKitErrorLogEntry"8Q16^B24
entries
T@"NSString",R,N,V_annotation
%s(%d): CoreData: Ubiquity:  %@
Error removing version: %@
Error: %@
userInfo: %@
-[PFUbiquityBaselineRecoveryOperation resolveConflictsForBaseline:withError:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
 Got nil store metadata for store named: %@
-[PFUbiquityBaselineRecoveryOperation replaceLocalStoreWithBaseline:error:]
%s(%d): CoreData: Ubiquity:  %@
Error trying to load the baseline archive: %@
userInfo: %@
-[PFUbiquityBaselineRecoveryOperation main]
%s(%d): CoreData: Ubiquity:  Found conflicts for baseline: %@
%s(%d): CoreData: Ubiquity:  Successfully resolved conflicts for baseline: %@
%s(%d): CoreData: Ubiquity:  Unable to resolve conflicts for baseline: %@, the baseline will not be adopted.
%s(%d): CoreData: Ubiquity:  %@
Current baseline directory exists however an error was encountered while trying to read the current metadata: %@
userInfo: %@
Will attempt to adopt the existing baseline.
%s(%d): CoreData: Ubiquity:  %@
Adopted older baseline: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to adopt older baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Encountered an error trying to replace the local store file with a baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unable to safe save peer baseline file: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error trying to read peer baseline file: %@
%s(%d): CoreData: Ubiquity:  %@
Got nil for current baseline metadata, %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Will attempt to adopt existing baseline: %@.
%s(%d): CoreData: Ubiquity:  Exception encountered while trying to clean up baseline: %@
Exception: %@
userInfo: %@
T@"NSObject<PFUbiquityBaselineRecoveryOperationDelegate>"
storeOptionsBinaryPlistData
modelVersionHashString
storeURLString
ubiquityName
ubiquityRootURLString
ubiquityRelativePath
databaseScopeNum = %@
Public
Shared
Private
databaseScope
~~[[NO CHANGE]]~~
NSPredicates and NSExpressions cannot be encoded by non-keyed archivers
NSConstantValue_XPCStoreObjectIDs
NSConstantValue
NSPredicates and NSExpressions cannot be decoded by non-keyed archivers
inputStream
secure
T@"NSString",R,&,N,V_entityName
T@"NSArray",R,&,N,V_objectsToInsert
T@"NSInputStream",R,&,N,V_inputStream
TQ,R,N,V_resultType
TB,R,N,V_secure
Unsupported Expression with the XPC Store: %@
columnsToUpdate
includeSubEntities
Unsupported Expression for the XPC Store: %@
T@"NSPredicate",R,&,N,V_predicate
T@"NSDictionary",R,&,N,V_columnsToUpdate
Tq,R,N,V_resultType
TB,R,N,V_includeSubEntities
fetch
fetchData
T@"NSData",R,&,N,V_fetchData
transactionFromToken
T@"NSDictionary",R,&,N,V_token
T@"NSDate",R,&,N,V_date
TB,R,N,V_delete
TB,R,N,V_transactionFromToken
TQ,R,N,V_fetchLimit
TQ,R,N,V_fetchBatchSize
Seriously what? Got a non-singleton generational token, but can't find my part
Someone tried to log something but failed because they didn't tell me what to log.
CoreData: XPC: %@
_NSXPCStoreObjectIDArrayConstantValueExpression
exception name
exception reason
Error: Exception raised: %@
Error: Callstack: %@
Error: UserInfo: %@
CoreData: XPC: Suspect response from server (bad size)
CoreData: XPC: Suspect response from server (no result)
CoreData: XPC: Suspect response from server (missing size)
CoreData: XPC: Suspect response from server (not enough room for fetch results header)
CoreData: XPC: Suspect response from server (not enough room for buffers and sizes)
/dev/null/CDInternalXPCStore
CoreData: XPC: Suspect response from server (not enough room for first row)
Decoding failed: No oids.
Decoding failed: No rows.
CoreData: XPC: Suspect response from server (not enough room for row %d)
CoreData: XPC: Suspect response from server (remaining space for %d smaller than estimated size)
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (3))
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (1))
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (2))
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (4))
peerEntityName
start
/System/Library/Frameworks/CloudKit.framework/CloudKit
CKContainer
CKContainerOptions
CKRecordZone
CKRecordZoneID
CKRecord
CKRecordID
CKFetchDatabaseChangesOperation
CKModifyRecordZonesOperation
CKModifyRecordsOperation
CKFetchRecordsOperation
CKDatabaseSubscription
CKModifySubscriptionsOperation
CKAsset
CKReference
CKFetchRecordZoneChangesConfiguration
CKFetchRecordZoneChangesOperation
CKServerChangeToken
CKNotificationInfo
CKEncryptedData
CKOperationConfiguration
CKScheduler
CKSchedulerActivity
CKNotificationListener
CKShare
CKCurrentUserDefaultName
CKErrorDomain
CKPartialErrorsByItemIDKey
CKAccountChangedNotification
CKIdentityUpdateNotification
%s(%d): CoreData: Ubiquity:  Unable to create knowledge vector from string: %@
-[PFUbiquityKnowledgeVector initWithKnowledgeVectorString:]
%s(%d): CoreData: Ubiquity:  Got empty knowledge vector from string: %@
kvDict
operationConfiguration
T@"CKOperationConfiguration",&,N,V_operationConfiguration
qualityOfService
allowsCellularAccess
receipt.0.cdt
kv: %@
%s(%d): CoreData: Ubiquity:  Successfully loaded receipt: %@
-[PFUbiquityPeerReceipt loadFileFromLocation:error:]
%s(%d): CoreData: Ubiquity:  Unable to load knowledge vector from location: %@. Error (%d): %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unable to load receipt file: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@: Successfully wrote to file.
-[PFUbiquityPeerReceipt writeFileToLocation:error:]
%s(%d): CoreData: Ubiquity:  %@: Unable to write receipt file. Error: %@
userInfo: %@
receiptFileLocation
writeDate
T@"NSDate",&,N,V_writeDate
localPeerID: %@
storeName: %@
ubiquityRootLocation: %@
T@"NSPersistentStore",R,N,V_store
T@"NSObject"
CDDCloudKitRegisteredClient
%s(%d): CoreData: Ubiquity:  Beginning metadata recovery for store: %@
-[PFUbiquityStoreMetadataMedic recoverMetadataWithError:]
%s(%d): CoreData: Ubiquity:  Metadata recovery for store: %@
Creating new store metadata.
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Created new store metadata: %@
Moving on to recreating the peer ranges.
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Finished creating new peer ranges, moving to knowledge vector, peer states, and transaction entries.
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Fetched knowledge vector: %@
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Finished.
%s(%d): CoreData: Ubiquity:  %@
No global ID for managed object ID: %@
-[PFUbiquityStoreMetadataMedic addTransactionHistoryEntriesForObjectIDs:withImportContext:error:]
%s(%d): CoreData: Ubiquity:  addTransactionHistoryEntriesForObjectIDs: lost its stack
%s(%d): CoreData: Ubiquity:  %@ skipping non-transaction log location returned from sub locations: %@
-[PFUbiquityStoreMetadataMedic recoverTransactionLogMetadataWithImportContext:error:]
%s(%d): CoreData: Ubiquity:  Successfully rebuilt metadata for log: %@
%s(%d): CoreData: Ubiquity:  %@
Had trouble loading the deleted objects for a the transaction log: %@
Error: %@
userInfo: %@
Failing now.
-[PFUbiquityStoreMetadataMedic cacheMetadataForTransactionLog:withImportContext:error:]
%s(%d): CoreData: Ubiquity:  %@
Had trouble loading the updated objects for a the transaction log: %@
Error: %@
userInfo: %@
Failing now.
%s(%d): CoreData: Ubiquity:  %@
Had trouble loading the inserted objects for a the transaction log: %@
Error: %@
userInfo: %@
Failing now.
T@"NSSQLiteConnection",R,N
localStoreKV
baseline
%s(%d): CoreData: Ubiquity:  Responding to baseline: %@
-[PFUbiquityBaselineRollResponseOperation main]
%s(%d): CoreData: Ubiquity:  Didn't get latest version: %@
%s(%d): CoreData: Ubiquity:  %@
Error trying to load the current metadata: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Current baseline matches the baseline archive, returning.
%s(%d): CoreData: Ubiquity:  Can adopt: %d replace: %d
kv: %@
%s(%d): CoreData: Ubiquity:  Adopted: %d
%s(%d): CoreData: Ubiquity:  Made current w/o replace: %d
%s(%d): CoreData: Ubiquity:  %@
Error while attempting to load the baseline in response to a baseline roll: %@
userInfo: %@
T@"NSObject<PFUbiquityBaselineRollResponseOperationDelegate>"
modelVersionHash: %@
TEMP_CDBATCHUPDATEOBJECTIDS
INSERT INTO %@ (ENTITYID, PrimeKey) SELECT OLD.Z_ENT, OLD.Z_PK;
CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_BATCHUPDATEOBJECTID_TRIGGER AFTER UPDATE ON %@ FOR EACH ROW BEGIN %@ END
DROP TRIGGER IF EXISTS ZQ_BATCHUPDATEOBJECTID_TRIGGER
T@"NSBatchUpdateRequest",R,N
updateStatement
T@"NSSQLiteStatement",R,N
error: unexpected type of change : %lu
Invalid entity for NSPersistentHistoryChangeRequest: %@
T@"NSPersistentHistoryChangeRequest",R,N
com.apple.coredata.ubiquity.ubiquitized
com.apple.coredata.ubiquity.localImportComplete
com.apple.coredata.ubiquity.token
com.apple.coredata.ubiquity.baseline.timestamp
PFUbiquitySetupPreviousModelVersionHashKey
PFUbiquitySetupContainerIdentifierKey
PFUbiquitySetupSynchronousSideLoadKey
PFUbiquitySetupTokenAndIDArray
PFUbiquitySetupOriginalStoreURLAbsoluteStringKey
PFUbiquitySetupNotifyAboutProgressKey
PFSetupLocalPeerIDOverride
PFSetupLocationSentinelOverrideKey
PFUbiquitySetupMigrateTransactionLogsKey
PFUbiquitySetupCheckForFork
PFUbiquitySetupDoFork
PFUbiquitySetupStoreFilePeerIDKey
PFUbiquitySetupWillInitializeReceiptNotification
PFUbiquitySetupWillInitializeBaselineNotification
PFUbiquitySetupWillCheckReceiptNotificaton
PFUbiquitySetupWillSideLoadStoreNotification
PFUbiquitySetupWillFinishNotification
PFUbiquitySetupDidFinishNotification
PFUbiquitySetupWillSeedStoreNotification
PFUbiquitySetupDidSeedStoreNotification
options: %@
psc: %@
store: %@
storeURL: %@
actualStoreURL: %@
storeMetadata: %@
storeKV: %@
storeFileExists: %d
storeFileIsReadOnly: %d
ubiquityEnabled: %d
ubiquityIdentityToken: %@
ubiquityRootURL: %@
ubiquityRootSubpath: %@
ubiquityName: %@
ubiquityContainerIdentifier: %@
localPeerID: %@
ubiquityRootLocation: %@
localRootLocation: %@
metaKV: %@
baseline: %@
baselineFileExists: %d
hasUploadingBaseline: %d
monitorBaslineUploadAsync: %d
didBaselineCopy: %d
baselineKV: %@
hasStoreMetadataFile: %d
hasStoreMetadataEntry: %d
hasContainerUUID: %d
hasContainerUUIDInStore: %d
needsMetadataRecovery: %d
localPeerReceipt: %@
receiptKV: %@
containerIdentifier: %@
preStoreContainerUUID: %@
usedExistingUUIDMapping: %d
hasLocalTransactionLogs: %d
votedOffIsland: %d
reapUbiquitousLogs: %d
respondToBaselineRoll: %d
hasMigrationOptions: %d
didMigrateBaseline: %d
storeWasMigrated: %d
replayLogsSynchronously: %d
useLocalAccount: %d
abortSetup: %d
gotExportNotification: %d
%s(%d): CoreData: Ubiquity:  Invalid option: the value for NSPersistentStoreUbiquitousContentNameKey should not contain periods: %@
-[PFUbiquitySetupAssistant validateOptionsWithError:]
The %@ persistent store type does not support iCloud integration.
No value for NSPersistentStoreUbiquitousContentNameKey was given however there is a value for NSPersistentStoreUbiquitousContentURLKey, did you forget to pass the value for NSPersistentStoreUbiquitousContentNameKey to the options dictionary for this store?
NSPersistentStoreUbiquitousPeerTokenOption must be an alpha numeric string, %@ has invalid characters
%s(%d): CoreData: Ubiquity:  Invalid value for NSPersistentStoreUbiquitousPeerTokenOption: %@
Unable to generate a peer ID for this peer.
The value passed for NSPersistentStoreUbiquitousContentURLKey cannot be the same as the store URL.
NSPersistentStoreUbiquitousContentNameKey: %@
storeURL: %@
The value passed for NSPersistentStoreUbiquitousContentURLKey cannot be inside a .nosync, nothing will ever sync.
%@ is not a valid value for NSPersistentStoreUbiquitousContentURLKey, it must be a relative path.
%@ is not a valid value for NSPersistentStoreUbiquitousContentURLKey, it must be an instance of NSString or NSURL.
%@ is not a valid file URL
The provided ubiquity name is already in use.
Received a nil or non file URL value for the store URL.
Core Data Ubiquity integration can only be enabled on SQLite stores, you must pass store type NSSQLiteStoreType to -addPersistentStoreWithType:configuration:URL:storeURL:options:error:.
Unable to get a model version hash from this coordinator's managed object model: %@
%s(%d): CoreData: Ubiquity:  No model version hash for coordinator: %@
Model: %@
%s(%d): CoreData: Ubiquity:  Current identity token: %@
-[PFUbiquitySetupAssistant doPostValidationInit:]
%s(%d): CoreData: Ubiquity:  %@
Store file exists: %d - %@
%s(%d): CoreData: Ubiquity:  Unable to destroy persistent store: %@
The store name: %@ is already in use.
Store URL: %@
In Use Store URL: %@
-[PFUbiquitySetupAssistant performCoordinatorPostStoreSetup:error:]
%s(%d): CoreData: Ubiquity:  %@
No one agrees
container: %@
preStore: %@
store: %@
-[PFUbiquitySetupAssistant initializeContainerIdentifierWithStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Couldn't identify container: %@
%s(%d): CoreData: Ubiquity:  Setup failed because of a missing file, retrying(%ld): %@
-[PFUbiquitySetupAssistant finishSetupWithRetry:]
%s(%d): CoreData: Ubiquity:  %@: Retrying after delay: %ld
%s(%d): CoreData: Ubiquity:  %@
Couldn't clean up from failed setup, giving up until the next time -addPersistentStore is called: %@
-[PFUbiquitySetupAssistant finishSetupWithRetry:]_block_invoke
-[PFUbiquitySetupAssistant finishSetupForStore:error:]
setupAssistant
UserDictionary
PhraseLearning_zh_Han
com.apple.CoreData.ForceUbiquityForkRecovery
%s(%d): CoreData: Ubiquity:  %@
User Defaults didn't synchronize fork removal
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to read the ubiquity root location.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the receipt file.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the container identifier.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the metadata stack.
%s(%d): CoreData: Ubiquity:  %@
Error encountered while preparing store metadata: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the baseline.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to check the knowledge vectors.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to side load the store.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting metadata recovery.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to cache the metadata entry.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after waiting for the baseline file to upload.
%s(%d): CoreData: Ubiquity:  %@
Moved local log files.
%s(%d): CoreData: Ubiquity:  %@
Error moving local log files to the ubiquity directory: %@
%s(%d): CoreData: Ubiquity:  %@
Pruned staging directory
%s(%d): CoreData: Ubiquity:  %@
Error prungin the staging directory: %@
%s(%d): CoreData: Ubiquity:  %@
Started Monitor
%s(%d): CoreData: Ubiquity:  %@
Error starting monitor: %@
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to finish setup.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to save the metadata changes.
%s(%d): CoreData: Ubiquity:  CoreData: error: Caught Exception %@ with userInfo %@ in -finishSetupForSet:error:
failed finishing setup for store during asynchronous iCloud initialization
%s(%d): CoreData: Ubiquity:  %@
Local peer receipt exists in cloud: %@
-[PFUbiquitySetupAssistant initializeReceiptFile:]
%s(%d): CoreData: Ubiquity:  %@
Removed dangling temporary peer receipt: %@
%s(%d): CoreData: Ubiquity:  %@
Error attempting to remove dangling temporary peer receipt: %@
Error: %@
UserInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Removed conflicting versions of receipt file: %@
%s(%d): CoreData: Ubiquity:  %@
Error attempting to remove conflicts for the receipt file: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Error reading receipt file, will remove so it can be replaced later: %@
%s(%d): CoreData: Ubiquity:  %@
Error checking receipt file status: %@
%s(%d): CoreData: Ubiquity:  %@
Error removing peer receipt from safe save location: %@
Didn't get a container URL back from URLForUbiquityContainerIdentifier:, giving up now. Please ensure the application is signed with the proper entitlements to read from the container.
%s(%d): CoreData: Ubiquity:  Coordinated read finished for ubiquity root url: %@
-[PFUbiquitySetupAssistant canReadFromUbiquityRootLocation:]_block_invoke
%s(%d): CoreData: Ubiquity:  Read finished: %d
-[PFUbiquitySetupAssistant canReadFromUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Read finished: %d / %d / %@
%s(%d): CoreData: Ubiquity:  Blocking for initial sync: %@
%s(%d): CoreData: Ubiquity:  Initial sync handler called, %@
 iCloud: Error: failed to receive initial sync notification call back in 90 seconds
%s(%d): CoreData: Ubiquity:  Initial sync complete: %@
 iCloud: Error: initial sync notification returned an error (%@)
%s(%d): CoreData: Ubiquity:  Found Peer: %@
%s(%d): CoreData: Ubiquity:  Starting download of all known peers: %@
%s(%d): CoreData: Ubiquity:  Attempting to download Peers hit a serious error for peers to download %@ with userInfo %@
%s(%d): CoreData: Ubiquity:  %@
Unable to scan root location: %@
%s(%d): CoreData: Ubiquity:  %@
All the faults are live
%s(%d): CoreData: Ubiquity:  Store file exists: %d
%s(%d): CoreData: Ubiquity:  Error attempting to read ubiquity root url: %@.
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Starting download on root URL: %@
%s(%d): CoreData: Ubiquity:  Attempting to download root URL (%@) hit a serious error: %@ with userInfo: %@
-[PFUbiquitySetupAssistant canReadFromUbiquityRootLocation:]_block_invoke_2
%s(%d): CoreData: Ubiquity:  %@
Baseline exists: %d
-[PFUbiquitySetupAssistant initializeBaselineForStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Unable to find a previous baseline file to use for migration. %@
%s(%d): CoreData: Ubiquity:  %@
Can't perform migration because there is no previous baseline file from which to get the managed object model: %@
%s(%d): CoreData: Ubiquity:  Baseline migration failed for store with ubiquity name: %@
Error: %@
userInfo: %@
Failed to migrate baseline, unable to create ubiquity migration manager
%s(%d): CoreData: Ubiquity:  %@
Found existing baseline file that needs to upload (%d, %d): %@
%s(%d): CoreData: Ubiquity:  %@
Baseline file is still uploading: %@
%s(%d): CoreData: Ubiquity:  %@
The baseline file exists, but could not be read: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
The baseline file exists but could not be downloaded: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Purged temporary store directory.
%s(%d): CoreData: Ubiquity:  %@
Unable to remove temporary store directory: %@
%s(%d): CoreData: Ubiquity:  %@
Created temporary store directory: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to create temproary store directory: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to create store for baseline: %@
%s(%d): CoreData: Ubiquity:  Transaction log migration failed for store: %@
Error: %@
userInfo: %@
-[PFUbiquitySetupAssistant checkAndPerformMigrationForStore:error:]
Failed to migrate ubiquitous content, unable to create ubiquity migration manager
%s(%d): CoreData: Ubiquity:  %@
Successfully recovered metadata
-[PFUbiquitySetupAssistant attemptMetadataRecoveryForStore:error:]
Store metadata recovery appears to have failed, please try adding the store to the coordinator again. If that is unsuccessful, migrate the data to a new ubiquitized persistent store.
%s(%d): CoreData: Ubiquity:  gethostuuid returned -1. Giving up now.
+[PFUbiquitySetupAssistant generateMachineUUIDString]
%s(%d): CoreData: Ubiquity:  Detecting Fork and is force:%@
-[PFUbiquitySetupAssistant detectAndFixForkedContainer:store:error:]
%s(%d): CoreData: Ubiquity:  Fork detected, will fork now
fork~%@
%s(%d): CoreData: Ubiquity:  Removed old fork directory: %@
-[PFUbiquitySetupAssistant detectAndFixForkedContainer:store:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error moving log: %@
%s(%d): CoreData: Ubiquity:  Unable to load baseline from %@
%@:1
fork~%@.nosync
%s(%d): CoreData: Ubiquity:  Unable to delete forked contents: %@
shortcut
phrase
partOfSpeech
UserDictionaryEntry
defaultReading
extraInteger1
extraInteger2
extraString1
extraString2
frequency
reading
seed
surface
syllables
LearningDictionaryEntry
firstSurface
secondReading
secondSurface
nobody
~sim
affectedDirectory
fileAttributes
CoreData: Ubiquity: must be able to write to the affected path as a directory.
CoreData: Ubiquity: requires at least 1mb of free space to allocate it's metadata storage.
%s(%d): CoreData: Ubiquity:  Metadata migration failed: %@
-[PFUbiquitySetupAssistant migrateMetadataRoot:]
%s(%d): CoreData: Ubiquity:  %@
Error fetching metadata store knowledge vector, metadata will be recovered: %@
-[PFUbiquitySetupAssistant initializeStack:]
%s(%d): CoreData: Ubiquity:  %@
Error trying to open metadata store: %@
CoreDataStores
sideLoad.store
%s(%d): CoreData: Ubiquity:  Cleared out store for side-load: %@
-[PFUbiquitySetupAssistant sideLoadStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Error removing side-load store %@: %@
%s(%d): CoreData: Ubiquity:  %@
Error removing side-load store: %@
%s(%d): CoreData: Ubiquity:  Cleared out directory for side-load: %@
%s(%d): CoreData: Ubiquity:  %@
Error removing side-load directory: %@
%s(%d): CoreData: Ubiquity:  Created directory for side-load: %@
%s(%d): CoreData: Ubiquity:  %@
Error creating side-load directory: %@
%s(%d): CoreData: Ubiquity:  %@
Pruned local root directory: %@
%s(%d): CoreData: Ubiquity:  %@
Error pruning local root directory: %@
%s(%d): CoreData: Ubiquity:  %@
Pruned ubiquity root directory: %@
%s(%d): CoreData: Ubiquity:  %@
Error pruning ubiquity root directory: %@
%s(%d): CoreData: Ubiquity:  Import started (Side load)
%s(%d): CoreData: Ubiquity:  Import finished (Side load)
%s(%d): CoreData: Ubiquity:  Failed to remove sideload store: %@
%s(%d): CoreData: Ubiquity:  %@
Purged history cache
%s(%d): CoreData: Ubiquity:  %@
Error purging history cache: %@
%s(%d): CoreData: Ubiquity:  Side load finish: %@ / %@
%s(%d): CoreData: Ubiquity:  %@
Error reading local log directory: %@
-[PFUbiquitySetupAssistant createSetOfLocalLogLocations:]
%s(%d): CoreData: Ubiquity:  Created ubiquity peer log directory: %@
-[PFUbiquitySetupAssistant moveLocalLogFilesToUbiquityLocation:]
%s(%d): CoreData: Ubiquity:  %@
Unable to write to peer transaction log directory: %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Moved local log: %@ to %@
%s(%d): CoreData: Ubiquity:  %@
Error moving local log: %@ to %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Error trying to read peer version directory: %@
%s(%d): CoreData: Ubiquity:  Rewriting save snapshot (%@)
-[PFUbiquitySetupAssistant rewriteTransactionLogs:toMatchStore:error:]
%s(%d): CoreData: Ubiquity:  Finished rewriting save snapshot (%@)
%s(%d): CoreData: Ubiquity:  %@
 Rewrote log: %@
%s(%d): CoreData: Ubiquity:  %@
 Error rewriting log: %@
%s(%d): CoreData: Ubiquity:  %@
Moved log to temporary location: %@
%s(%d): CoreData: Ubiquity:  %@
 Error moving log: %@
%s(%d): CoreData: Ubiquity:  %@
Removed old local log: %@
%s(%d): CoreData: Ubiquity:  %@
File went missing: %@
%s(%d): CoreData: Ubiquity:  %@
Error deleting old local log: %@
%s(%d): CoreData: Ubiquity:  %@
Moved log file to local directory: %@
%s(%d): CoreData: Ubiquity:  %@
Error moving log file to local directory: %@
%s(%d): CoreData: Ubiquity:  Error moving local log: %@
-[PFUbiquitySetupAssistant rewriteTransactionLogs:toMatchStore:error:]_block_invoke_4
%s(%d): CoreData: Ubiquity:  Tried deleting file: %@
%s(%d): CoreData: Ubiquity:  %@
Imported local logs: %@
-[PFUbiquitySetupAssistant tryToReplaceLocalStore:withStoreSideLoadedByImporter:]
%s(%d): CoreData: Ubiquity:  %@
Error side loading local logs: %@
Error: %@
%s(%d): CoreData: Ubiquity:  Looks like the store was changed in will change, trying again: %@
%s(%d): CoreData: Ubiquity:  %@
Attempting to replace store: %@ with store: %@
%s(%d): CoreData: Ubiquity:  %@
Replaced %@ with %@
-[PFUbiquitySetupAssistant tryToReplaceLocalStore:withStoreSideLoadedByImporter:]_block_invoke_2
%s(%d): CoreData: Ubiquity:  Error loading new store metadata after side load: %@
%s(%d): CoreData: Ubiquity:  %@
Updated store knowledge vector to: %@
%s(%d): CoreData: Ubiquity:  %@
Refreshed peer range cache: %@
%s(%d): CoreData: Ubiquity:  %@
Error refreshing peer range cache: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to reinitialize store knowledge vector: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to replace %@ with side loaded store: %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully wrote peer receipt file: %@
-[PFUbiquitySetupAssistant checkKnowledgeVectorsAndBaselineWithStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Error writing local peer receipt file to disk: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Local store knowledge vector matches receipt knowledge vector.
%s(%d): CoreData: Ubiquity:  %@
Local store file is behind receipt.
Store: %@
Receipt: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to get the mod time for baseline (%d): %@
%s(%d): CoreData: Ubiquity:  Moved orphaned log to sync'd directory: %@
-[PFUbiquitySetupAssistant pruneStagingDirectoryForStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Unable to move log to permanent location: %@
%s(%d): CoreData: Ubiquity:  Deleted orphaned log: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to delete log: %@
%s(%d): CoreData: Ubiquity:  Successfully migrated seed store: %@
-[PFUbiquitySetupAssistant seedStore:error:]
failed to seed store during asynchronous iCloud setup
%s(%d): CoreData: Ubiquity:  Couldn't load baseline metadata from baseline: %@
-[PFUbiquitySetupAssistant respondToBaselineRoll:]
%s(%d): CoreData: Ubiquity:  Looks like we were passed the full URL, not the store file URL: %@
+[PFUbiquitySetupAssistant createActualStoreURLForStoreURL:localPeerID:containerIdentifier:andStoreName:]
%s(%d): CoreData: Ubiquity:  Created actual store url: %@
for url: %@
%s(%d): CoreData: Ubiquity:  Using the original store URL (linked on or after 10.9 / 7.0): %@
%s(%d): CoreData: Ubiquity:  %@
User Defaults didn't synchronize
+[PFUbiquitySetupAssistant setContainerIdentifierUUID:forIdentityToken:forStoreName:]
+[PFUbiquitySetupAssistant cleanUserDefaultsForStore:]
%s(%d): CoreData: Ubiquity:  Unable to load baseline: %@
+[PFUbiquitySetupAssistant createBaselineFromMostRecentLocation:localPeerID:error:]
%s(%d): CoreData: Ubiquity:  %@
Error checking uploaded status of baseline file: %@
%s(%d): CoreData: Ubiquity:  %@
Aborting setup because store removed from coordinator. %@
-[PFUbiquitySetupAssistant coordinatorWillRemoveStore:]
T@"NSDictionary",R,N,V_options
ubiquityEnabled
TB,R,N,V_ubiquityEnabled
needsMetadataRecovery
TB,R,N,V_needsMetadataRecovery
T@"NSURL",R,N,V_ubiquityRootURL
T@"PFUbiquityContainerIdentifier",R,N,V_containerIdentifier
TB,R,N,V_useLocalAccount
storeWasMigrated
TB,N,V_storeWasMigrated
actualStoreFileURL
T@"NSURL",R,N,V_actualStoreFileURL
abortSetup
TB,N,V_abortSetup
T@"PFUbiquityKnowledgeVector",R,N,V_storeKV
retryDelaySec
TQ,N,V_retryDelaySec
cacheFilePresenterForUbiquityRoot
TB,N,V_cacheFilePresenterForUbiquityRoot
failSetup
TB,N,V_failSetup
failSetupError
T@"NSError",&,N,V_failSetupError
containerId
PFUbiquityContainerIdentifierDeleteNotificaton
local
uuidString
T@"NSString",R,N,V_uuidString
uuidFileLocation
T@"PFUbiquityLocation",R,N,V_uuidFileLocation
usedExistingUUIDFile
TB,R,N,V_usedExistingUUIDFile
T@"NSURL",R,C,V_presentedItemURL
NSCloudKitMirroringDelegateIgnoredPropertyKey
NSCloudKitMirroringDelegateWillResetSyncNotificationName
NSCloudKitMirroringDelegateDidResetSyncNotificationName
NSCloudKitMirroringDelegateResetSyncReasonKey
NSCloudKitMirroringDelegateReadOnlyOptionKey
com.apple.coredata.cloudkit.zone
com.apple.coredata.cloudkit.zone.subscription
com.apple.coredata.cloudkit.private.subscription
PFCloudKitServerChangeTokenKey
NSCloudKitMirroringDelegateServerChangeTokensKey
CD_M2M_
CD_FAKE_
PFCloudKitWillExportNotificationName
PFCloudKitDidExportNotificationName
PFCloudKitDidImportNotificationName
PFCloudKitDidInitializeNotificationName
PFCloudKitFailedToInitializeNotificationName
NSCloudKitMirroringDelegate.schemaGenerator
CDMR
PFCloudKitNewUserIdentityKey
PFCloudKitOldUserIdentityKey
NSCloudKitMirroringDelegateLastHistoryTokenKey
NSCloudKitMirroringDelegate.import
NSCloudKitMirroringDelegate.export
NSCloudKitMirroringDelegate.reset
NSCloudKitMirroringDelegate.migration
com.apple.coredata.cloudkit.activity.export
com.apple.coredata.cloudkit.activity.import
com.apple.coredatad.cloudkit
com.apple.coredata.testcloudkit
com.apple.coredata.cloudkit.queue
CloudKit integration is only supported for %@ stores.
Instances of NSCloudKitMirroringDelegate are not reusable and should have a lifecycle tied to a given instance of NSPersistentStore.
%@: Successfully enqueued setup request.
-[NSCloudKitMirroringDelegate _setUpCloudKitIntegration]
%@: Failed to enqueue setup request, this likely means one is already scheduled and this has collided: %@
resetAfterError illegally passed nil instead of an error on a failure condition
%@ - resetting internal state after error: %@
-[NSCloudKitMirroringDelegate resetAfterError:andKeepContainer:]
%@ - Beginning automated export.
-[NSCloudKitMirroringDelegate _beginWatchingForChanges]_block_invoke
%@ - Finished automatic export with result: %@
-[NSCloudKitMirroringDelegate _beginWatchingForChanges]_block_invoke_2
Failed to execute mirroring request: %@
Got called back for an export activity but the mirroring delegate is gone.
%@ - Beginning automated import in response to activity:
%@ - Finished automatic import with result: %@
Got called back for activity: %@, but the mirroring delegate is gone.
%@ - Got notification for subscription: %@
%@: Submitting activity for import: %@
Got called back for subscription: %@, but the mirroring delegate is gone. Notification:
v24@?0@"CKNotification"8@"CKSubscription"16
%@: Scheduling post-setup export
-[NSCloudKitMirroringDelegate _beginWatchingForChanges]
com.apple.coredata.cloudkit.setup.operations
Finished sandbox scheduled export: %@
Sandbox scheduled export failed: %@
Failed to schedule export after setup: %@
Finished sandbox scheduled import: %@
-[NSCloudKitMirroringDelegate _beginWatchingForChanges]_block_invoke_3
Sandbox scheduled import failed: %@
v16@?0@"NSObject<OS_os_transaction>"8
%@ - Recieved account or identity change notification: %d - %@
-[NSCloudKitMirroringDelegate ckAccountOrIdentityChangedHandler:]
CoreData: Account Change Observer
%@ - Scheduled account change block with task assertion(%lu, %@): %@
%@: Executing account or identity change block clearning %d iterations.
-[NSCloudKitMirroringDelegate ckAccountOrIdentityChangedHandler:]_block_invoke
%@ - ending power assertion: %lu, %@
%@ - Already scheduled a block to respond to account or identity change notifications, %d notifications since.
%@: Executing request: %@
-[NSCloudKitMirroringDelegate executeMirroringRequest:error:]
Instances of '%@' are ambiguous and not understood by '%@', use one of the subclasses instead.
com.apple.coredata.cloudkit.schedule.enqueue
Enqueued request: %@
-[NSCloudKitMirroringDelegate _enqueueRequest:]_block_invoke
Failed to enqueue request: %@
%@: Asked to execute a request that isn't understood yet: %@
Reset request was scheduled without a root cause error: %@
com.apple.coredata.cloudkit.setup.reset
Setup request executed with a completion block that will never be called: %@
com.apple.coredata.cloudkit.setup
%@: Successfully set up CloudKit integration for store: %@
-[NSCloudKitMirroringDelegate _performSetupRequest:]_block_invoke
Failed to register store with coredatad: %@
%@: Failed to set up CloudKit integration for store: %@
com.apple.coredata.cloudkit.import
%@: Import failed with error:
-[NSCloudKitMirroringDelegate _performImportWithRequest:]_block_invoke_2
com.apple.coredata.cloudkit.export
Finished export: %@
-[NSCloudKitMirroringDelegate _performExportWithRequest:]_block_invoke_2
%@: Export failed with error:
com.apple.coredata.cloudkit.zone.reset
Zone reset request failed: %@
Failed to clear metadata from store: %@
-[NSCloudKitMirroringDelegate _performResetZoneRequest:]_block_invoke_2
Request '%@' was aborted because the mirroring delegate failed to reset the local store's metadata: %@
%@: Asked to schedule a zone reset operation without a zoneID: %@
-[NSCloudKitMirroringDelegate _performResetZoneRequest:]_block_invoke
The mirroring delegate could not complete request '%@' because it does not have a zone.
com.apple.coredata.cloudkit.fetch.records
-[NSCloudKitMirroringDelegate _performFetchRecordsRequest:]_block_invoke_2
com.apple.coredata.cloudkit.metadata.reset
Purged cloudkit metadata from store: %@
Result: %@
-[NSCloudKitMirroringDelegate _performMetadataResetRequest:]_block_invoke
Failed to purge cloudkit metadata from store: %@
%@ - Never successfully initialized and cannot execute request '%@' due to error: %@
-[NSCloudKitMirroringDelegate _requestAbortedNotInitialized:]
Request '%@' was aborted because the mirroring delegate never successfully initialized and cannot reset the zone due to error: %@
handleErrorInResult illegally passed nil instead of a result
handleErrorInResult passed a sucessful result (%@) with an illegal error object (%@)
handleErrorInResult illegally passed a failed result (%@) with nil instead of an error on a failure condition
recoverFromError illegally passed nil instead of an error on a failure condition
%@ - Attempting recovery from error: %@
-[NSCloudKitMirroringDelegate recoverFromError:]
The store was removed before the mirroring delegate could recover from an error:
-[NSCloudKitMirroringDelegate recoverFromError:]_block_invoke
Invalid recursion detected, this method should never have been passed a partial error: %@
-[NSCloudKitMirroringDelegate _recoverFromError:withMonitor:]
The mirroring delegate can no longer export because it cannot stay under the CloudKit operation limits.
%@ - Failed to recover from error: %@
Recovery encountered the following error: %@
%@ - Recovered from error: %@
%@: Found unknown error as part of a partial failure: %@
-[NSCloudKitMirroringDelegate _recoverFromPartialError:withMonitor:]_block_invoke
%@: Found unknown itemID (%@) as part of a partial failure: %@
v32@?0@"NSObject"8@"NSError"16^B24
Unknown error passed to partial error handler: %@
-[NSCloudKitMirroringDelegate _recoverFromPartialError:withMonitor:]
%@ - Removing cloud metadata from mirrored objects.
-[NSCloudKitMirroringDelegate purgeMetadataFromStore:inMonitor:withOptions:forRecordZones:error:]_block_invoke
%@ - Purging row metadata
%@ - Removed cloud metadata %@
com.apple.coredata.cloudkit.schedule
%@ - Ignoring remote change notification because it's for a different store: %@ / %@
-[NSCloudKitMirroringDelegate remoteStoreDidChange:]_block_invoke_2
%@ - Ignoring remote change notification because the coordinator doesn't have a store for this URL: %@
%@ - Ignoring remote change notification because it doesn't have a store URL
%@: Failed to schedule backup task: %@
-[NSCloudKitMirroringDelegate scheduleExportWithMonitor:]
%@: Deferring export because the mirroring delegate is not initialized:
%@: Checking to see if an automated import should be scheduled.
-[NSCloudKitMirroringDelegate checkAndScheduleImportIfNecessary]_block_invoke
Failed to fetch database metadata during automatic import check: %@
%@: Scheduling automated import with activity: %@
%@: Cancelling import check because the store is dead.
-[NSCloudKitMirroringDelegate checkAndScheduleImportIfNecessary]_block_invoke_2
%@: Checking for pending requests.
-[NSCloudKitMirroringDelegate checkAndExecuteNextRequest]
%@: Manager has an active request, deferring scheduling any more: %@
-[NSCloudKitMirroringDelegate checkAndExecuteNextRequest]_block_invoke
Finished request: %@ with result: %@
-[NSCloudKitMirroringDelegate _finishedRequest:withResult:]
T@"NSCloudKitMirroringDelegateOptions",R,C,N,V_options
ckDatabaseName
T@"NSString",R,N,V_ckDatabaseName
cloudKitQueueSemaphore
T@"NSObject<OS_dispatch_semaphore>",R,N,V_cloudKitQueueSemaphore
cloudKitQueue
T@"NSObject<OS_dispatch_queue>",R,N,V_cloudKitQueue
T@"CKNotificationListener",R,N,V_notificationListener
observedStore
T@"NSPersistentStore",R,W,N,V_observedStore
observedCoordinator
T@"NSPersistentStoreCoordinator",R,W,N,V_observedCoordinator
hadObservedStore
TB,R,N,V_hadObservedStore
successfullyInitialized
TB,R,N,V_successfullyInitialized
exporterOptions
T@"PFCloudKitExporterOptions",R,N,V_exporterOptions
requestManager
T@"NSCloudKitMirroringRequestManager",R,&,N,V_requestManager
T@"NSCKExportMetadata",&,D,N
localPeerID: %@
storeName: %@
Cached Ranges:
All Entity Ranges: %lu
Translated Global IDs: %lu
Cached Ranges:
All Entity Ranges: %@
Translated Global IDs: %@
peerStart <= %@ AND peerEnd >= %@
rangeStart <= %@ AND %@ <= rangeEnd
%s(%d): CoreData: Ubiquity:  %@
Found multiple ranges for entity: %@ and local primary key: %@
-[PFUbiquityPeerRangeCache cachedRangeForLocalPrimaryKey:ofEntityNamed:]
Couldn't parse numeric primary key out of the provided object ID.
rangeStart <= %@ AND rangeEnd >= %@
p%ld
Unable to resolve global object IDs: %@
translatedGlobalIDs
T@"NSDictionary",R,N,V_translatedGlobalIDs
owningPeerID: %@
entityName: %@
rangeStart: %@
rangeEnd: %@
peerStart: %@
peerEnd: %@
T@"NSNumber",R,N,V_rangeStart
T@"NSNumber",R,N,V_rangeEnd
T@"NSNumber",R,N,V_peerStart
T@"NSNumber",R,N,V_peerEnd
rootLocationToPeerIDToEntry: %@
%s(%d): CoreData: Ubiquity:  %@ unable to construct metadata entry.
Entry: %@
localPeerID: %@
rootLocation: %@
Error: %@
userInfo: %@
-[PFUbiquityMetadataFactory newMetadataEntryForLocalPeerID:storeName:andUbiquityRootLocation:error:]
metadataStoreFileLocation: %@
psc: %@
store: %@
filePresenter: %@
%s(%d): CoreData: Ubiquity:  Creating file: %@
-[PFUbiquityMetadataFactoryEntry initializePersistentStoreCoordinator:]
%s(%d): CoreData: Ubiquity:  %@
Error removing metaDataStore: %@
%s(%d): CoreData: Ubiquity:  %@
Trouble adding the metadata store to the coordinator: %@
userInfo: %@
T@"PFUbiquityMetadataFactoryFilePresenter",R,N,V_filePresenter
T@"NSPersistentStoreCoordinator",R,N,V_psc
x-coredata://%@/%@/%@
T@"NSManagedObjectContext",R,N,V_moc
numRangesToReserve
Tq,R,N,V_numRangesToReserve
peerEntityNameRangeStartSet
T@"NSDictionary",R,N,V_peerEntityNameRangeStartSet
Managed object model with offset %lu is not known to %@
Illegal attempt to register a client managed object model with a non-zero offset (%ld).
q24@?0#8#16
Attempt to register ancillary model with offset %ld but different entity count.
Entity slot past the end of the ordered entities (%lu - %lu):
Slot past the end of the ordered entities (%lu): %lu
clientModel
T@"NSManagedObjectModel",R,N,V_clientModel
allEntities
T@"NSArray",R,N,V_allEntities
entitiesByPath
T@"NSDictionary",R,N,V_entitiesByPath
clientEntityCount
TQ,R,N,V_clientEntityCount
models
T@"NSArray",R,N,V_models
entityCount
TQ,R,N,V_entityCount
%s(%d): CoreData: Ubiquity:  Got delete for metadata store: %@
-[PFUbiquityMetadataFactoryFilePresenter accommodatePresentedItemDeletionWithCompletionHandler:]
presentedItemLocation
T@"PFUbiquityLocation",R,N,V_presentedItemLocation
%s(%d): CoreData: Ubiquity:  %@
 Error loading transaction log: %@
Error: %@
userInfo: %@
-[PFUbiquityTransactionLogCache retainedCachedLogForLocation:loadWithRetry:error:]
logLocation
FETCH_REQUEST_LIMIT_SUBSTITUTION
FETCH_REQUEST_OFFSET_SUBSTITUTION
Unsupported substitution variable type for key %@
Mismatched variables dictionaries (count)
Mismatched variables dictionaries (missing value)
Mismatch: that which was once a collection is no longer (%@)
_identifier
T@,R,N,V_identifier
T@"NSDictionary",C,N
Invalid variable substitution - multiple values not supported here %@
unable to resolve variable expression: %@
localPeerID: %@
storeName: %@
cacheKV: %@
minCacheKV: %@
Cached Entries:
Global ID To History: %lu
Entries to write: %lu
peerIDToHistoryArray: %@
globalIDToHistoryArray: %@
entriesToWrite: %@
%s(%d): CoreData: Ubiquity:  %@
Error while writing pending transaction history entries to disk: %@
userInfo: %@
-[PFUbiquityTransactionHistoryCache purgeCacheAndWritePendingEntries:error:]_block_invoke
T@"PFUbiquityLocation",R,N,V_rootLocation
globalIDCache
T@"PFUbiquityGlobalObjectIDCache",&,N,V_globalIDCache
cacheKV
T@"PFUbiquityKnowledgeVector",R,N,V_cacheKV
minCacheKV
T@"PFUbiquityKnowledgeVector",R,N,V_minCacheKV
cachedGlobalIDs
Baseline
storeName: %@
actingPeerID: %@
transactionNumber: %@
transactionDate: %@
transactionType: %d
globalID: %@
knowledgeVector: %@
transactionLogLocation: %@
globalID
T@"PFUbiquityGlobalObjectID",&,N,V_globalID
Ti,N,V_transactionType
actingPeerID
T@"NSString",&,N,V_actingPeerID
T@"NSString",&,N,V_storeName
T@"PFUbiquityLocation",&,N,V_transactionLogLocation
%s(%d): CoreData: Ubiquity:  %@
Registering for application will resign active.
-[PFUbiquitySwitchboardCacheWrapper initWithStoreName:privateStore:forLocalPeerID:andUbiquityRootLocation:]
UIApplicationWillResignActiveNotification
%s(%d): CoreData: Ubiquity:  %@
Unregistering for application will resign active.
-[PFUbiquitySwitchboardCacheWrapper cacheWrapperWillBeRemovedFromEntry]
%s(%d): CoreData: Ubiquity:  %@
 Error purging transaction history cache: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Receipt file write failed: %@
%s(%d): CoreData: Ubiquity:  %@ ignoring schedule request because it is not allowed: %@
-[PFUbiquitySwitchboardCacheWrapper scheduleReceiptFileWrite:]
%s(%d): CoreData: Ubiquity:  %@ encountered an error while trying to write receipt: %@ to disk: %@
userInfo: %@
-[PFUbiquitySwitchboardCacheWrapper scheduleReceiptFileWrite:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error writing receipt file before switchboard removal: %@
userInfo: %@
-[PFUbiquitySwitchboardCacheWrapper writeReceiptFile:error:]
-[PFUbiquitySwitchboardCacheWrapper _appWillResignActive:]
T@"PFUbiquityGlobalObjectIDCache",R,N,V_globalIDCache
peerRangeCache
T@"PFUbiquityPeerRangeCache",R,N,V_peerRangeCache
transactionLogCache
T@"PFUbiquityTransactionLogCache",R,N,V_transactionLogCache
transactionHistoryCache
T@"PFUbiquityTransactionHistoryCache",R,N,V_transactionHistoryCache
peerReceipt
T@"PFUbiquityPeerReceipt",R,N,V_peerReceipt
T@"PFUbiquityKnowledgeVector",&,V_kv
baselineKV
T@"PFUbiquityKnowledgeVector",&,V_baselineKV
%@(%d)
permanentLocation: %@
safeLocation: %@
currentLocation: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to remove file at location: %@
errno: %d
-[PFUbiquitySafeSaveFile removeFileFromLocation:error:]
The file upload timed out.
%s(%d): CoreData: Ubiquity:  %@
Safe save failed for file, error: %@
-[PFUbiquitySafeSaveFile waitForFileToUpload:]
%s(%d): CoreData: Ubiquity:  %@
Successfully moved file from: %@ to: %@
-[PFUbiquitySafeSaveFile moveToPermanentLocation:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Had trouble file from: %@ to: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Checking peer file upload: %@
-[PFUbiquitySafeSaveFile checkSafeSaveFileUpload]
The file download timed out.
%s(%d): CoreData: Ubiquity:  %@
Download failed for file, error: %@
-[PFUbiquitySafeSaveFile waitForFileToDownload:]
%s(%d): CoreData: Ubiquity:  %@
Checking file download: %@
-[PFUbiquitySafeSaveFile checkFileDownload]
permanentLocation
T@"PFUbiquityLocation",R,N,V_permanentLocation
safeSaveLocation
T@"PFUbiquityLocation",R,N,V_safeSaveLocation
T@"PFUbiquityLocation",&,N,V_currentLocation
safeSaveError
T@"NSError",R,N,V_safeSaveError
isRegistered
TB,R,N,V_isRegistered
continueCheckingUpload
TB,R,N,V_continueCheckingUpload
safeSaveSuccess
TB,R,N,V_safeSaveSuccess
moveAfterSave
TB,R,N,V_moveAfterSave
existsAtSafeSaveLocation
existsAtPermanentLocation
existsInCloud
downloadSuccess
TB,R,N,V_downloadSuccess
continueCheckingDownload
TB,R,N,V_continueCheckingDownload
downloadError
T@"NSError",R,N,V_downloadError
pendingLogs: %@
scheduledLogs: %@
failedLogs: %@
ignoredlogs: %@
encounteredErrors: %@
%s(%d): CoreData: Ubiquity:  Ignoring file: %@
Error: %@
-[PFUbiquityRecordsImporterSchedulingContext transactionLogAtLocation:failedToOpenWithError:]
pendingLogLocations
T@"NSSet",R,N,V_pendingLogLocations
scheduledLogLocations
T@"NSSet",R,N,V_scheduledLogLocations
failedLogLocations
T@"NSSet",R,N,V_failedLogLocations
ignoredLogLocations
T@"NSSet",R,N,V_ignoredLogLocations
logLocationsToEncounteredErrors
T@"NSDictionary",R,N,V_logLocationsToEncounteredErrors
%s(%d): CoreData: Ubiquity:  Failed to get sublocations for %@ %@, %@
-[PFUbiquityMigrationAssistant _populateBaselineAndTransactionLogLocations]
previousModelVersionHash
T@"NSString",R,N,V_previousModelVersionHash
currentModelVersionHash
T@"NSString",R,N,V_currentModelVersionHash
com.apple.coredata.ubiquity.container.state.willChange
com.apple.coredata.ubiquity.container.state.didChange
com.apple.coredata.ubiquity.monitor.state.willChange
PFUbiquityContainerMonitorWillChangeContainerIdentifierNotification
PFUbiquityContainerMonitorDidChangeContainerIdentifierNotification
currentIdentityToken: %@
%s(%d): CoreData: Ubiquity:  %@
Registering for application resumed notification.
-[PFUbiquityContainerMonitor startMonitor:]
UIApplicationResumedNotification
%s(%d): CoreData: Ubiquity:  Trouble identifying container: %@
-[PFUbiquityContainerMonitor containerDeleteDetected:]
%s(%d): CoreData: Ubiquity:  %@
Application resumed, scheduling check.
-[PFUbiquityContainerMonitor _applicationResumed:]
-[PFUbiquityContainerMonitor checkStoresAndContainer:]
containerState
Ti,N,V_containerState
monitorState
Ti,N,V_monitorState
currentIdentityToken
T@"<NSObject><NSCopying><NSCoding>",R,N,V_currentIdentityToken
CoreData: Failed to reconstruct CKRecord from system fields in object: %@
CoreData: Failed to look up cached mirrored relationship for mtmKey: %@
CoreData: Record metadata doesn't match row: %@
CoreData: Need to handle fetch errors here and abort serialization. %@
CoreData: Delegate didn't return a file url for asset: %@
%{public}s: %{public}s
CoreData: %{public}s: %{public}s
CoreData: Updating a constrained entity generated an UPDATE statement with no columns on entity %@
CoreData: Background Core Data task threw an exception.  Exception = %@ and userInfo = %@
CoreData: New many to many relationship type?: %@
CoreData: One or more models in this application are using transformable properties with transformer names that are either unset, or set to NSKeyedUnarchiveFromDataTransformerName. Please switch to using "%@" or a subclass of NSSecureUnarchiveFromDataTransformer instead. At some point, Core Data will default to using "%@" when nil is specified, and transformable properties containing classes that do not support NSSecureCoding will become unreadable.
CoreData: Unhandled error (%@, %ld) occurred during faulting and was ignored: %@
CoreData: faulting failed to record an error for an serious condition
CoreData: -[NSPersistentContainer initWithName:managedObjectModel:] called with the empty string as its container name
CoreData: -[NSPersistentContainer initWithName:managedObjectModel:] called with invalid container name '%@'
CoreData: Unhandled exception finding default Directory URL '%@'
CoreData: Unknown exception thrown posting NSRemotePersistentStoreDidChangeNotification
CoreData: NULL _cd_rawData but the object is not being turned into a fault
CoreData: Unknown exception while resetting query generation during exception recovery for save
CoreData: An observer of NSManagedObjectContextDidSaveNotification illegally threw an exception.  Objects saved = %@ and exception = %@ with userInfo = %@ at %@
CoreData: Delete propagation prefetching failed with exception: %@
CoreData: XPCStore sendMessage: Unhandled exception handling request.  %@
CoreData: XPCStore sendMessage: Unhandled unknown exception handling request
CoreData: createRecordID called before the record has the necessary properties: %@
CoreData: Cannot create objectID. Unable to find entity with id '%@' in store '%@'
CoreData: Cannot create objectID: called before the record has the necessary properties: %@
CoreData: Found more than one instance of NSCKRecordMetadata for object: %s
CoreData: Somehow got a temporary objectID for export: %s
CoreData: Exporter got record metadata back but doesn't have a corresponding objectID: %s
CoreData: Found more than one instance of NSCKRecordMetadata for record: %s
CoreData: Invalid query for record metadata (by recordIDs): %@ returned no metadata or record names
CoreData: Got non-object value back for property '%@' which returned an objectID from the snapshot.
CoreData: An NSPersistentStore illegally threw an exception from -willRemoveFromPersistentStoreCoordinator:
CoreData: Unhandled exception in developer completion handler for addPersistentStoreWithDescription %@
CoreData: Unhandled unknown exception in developer completion handler for addPersistentStoreWithDescription
Save
Fetch
CoreData: Exception was caught during NSPersistentStoreCoordinator -performBlock: %@ with userInfo %@
CoreData: Unidentifiable exception was caught during NSPersistentStoreCoordinator -performBlock.
CoreData: Exception thrown during autorelease pool drain.
CoreData: Called to accept connection for unknown listener: %@
CoreData: Bug in CoreData CloudKit Server: Response success == NO but error is also nil.
CoreData: CloudKit Server is attempting to send back a nil response: %@
CoreData: Multiple clients registered for the same store path: %@
CoreData: Found unknown activity type: %@
CoreData: Asked to run activity but no server: %@
CoreData: Found more than one scheduled activities matching the identifier '%@': %@
CoreData: Failed to handle activity because initialization took longer than expected: %@
CoreData: entityForObjectID was passed a nil objectID
CoreData: entityForObjectID failed to retrieve an NSSQLEntity for objectID %@
CoreData: entityForObjectID passed a nil entity description from %@
CoreData: _sqlCoreLookupSQLEntityForEntityDescription failed to return a result for objectID %@ with entity %@
CoreData: Exception caught during index recreation %@
CoreData: Exception caught during trigger recreation %@
CoreData: Exception caught during autovacuum check %@
CoreData: Exception caught during drop of old history tracking tables %@ with userInfo %@
CoreData: Exception caught during drop of old history tracking tables %@
CoreData: Exception caught during drop/create of history tracking tables %@ with userInfo %@
CoreData: Exception caught during drop/create of history tracking tables %@
CoreData: Exception caught during add of tombstone columns %@ with userInfo %@
CoreData: Exception caught during add of tombstone columns %@
CoreData: Exception caught during checking for Ancillary Entities %@ with userInfo %@
CoreData: Exception caught during checking for Ancillary Entities %@
CoreData: Exception caught during adding transaction string table %@ with userInfo %@
CoreData: Exception caught during adding transaction string table %@
CoreData: Exception caught during create of history tracking tables %@ with userInfo %@
CoreData: Exception caught during create of history tracking tables %@
CoreData: Exception caught during cached model check %@
CoreData: Exception caught during model caching %@ with userInfo %@
CoreData: Exception caught during model caching %@
CoreData: Exception caught during _ensureDatabaseMatchesModel %@ with userInfo %@
CoreData: Exception caught during _ensureDatabaseMatchesModel %@
CoreData: Failed to adopt query generation from remote change
CoreData: Refreshing trigger values failed to adopt post transaction query generation with error %d
CoreData: Exception thrown posting NSPersistentStoreRemoteChangeNotification: %@
CoreData: Unknown exception thrown posting NSPersistentStoreRemoteChangeNotification
CoreData:  Failed to setup notification listener for NSPersistentStoreRemoteChangeNotification: %d
CoreData: Threw during attempt to purge SQL row cache data
CoreData: Unsupported property type for unique attribute on entity '%@': %@
CoreData: Unable to create index: %@ due to exception (%@)
CoreData: performIntegrityCheck encountered an exception %@
CoreData: unable to cache model: %@
CoreData: performPostSaveTasks threw something (1). ex = %@
CoreData: performPostSaveTasks threw something (2). ex = %@
CoreData: sqlite3_snapshot data was unexpectedly NULL
CoreData: Connection can't register generation: Uncaught exception: %@
CoreData: Failed to free sqlite3_snapshot
CoreData: Failed to save import operation: %@
CoreData: Error fetching previous server change token for zone: %@
CoreData: %@ - Exception thrown during import: %@
CoreData: exception raised during multi-threaded fetch %@ (%@)
CoreData: unidentifiable exception during multi-threaded fetch
CoreData: exception %@ raised processing result of multi-threaded fetch (%@)
CoreData: unidentifiable processing result of multi-threaded fetch
CoreData: exception %@ raised processing result of multi-threaded fetch while prepopulating objects (%@)
CoreData: unidentifiable processing result of multi-threaded fetch while prepopulating objects
CoreData: Unexpected unknown exception on server
CoreData: Unknown request class: %@
CoreData: Dequeue called during an active request: %@
CoreData: requestFinished called with a different request than the active request: %@
Called with: %@
CoreData: requestFinished called without an active request: %@
CoreData: Called after the store is dead. This method needs to be called inside a performBlock on the store monitor: %@
CoreData: Something has gone badly awry initializing the XPC connection pool: %@
CoreData:  NSSQLConnectionManager tried to blow a lock
CoreData: manager sendMessageWithContext: failed with exception (how? it should never throw): %@
CoreData: manager sendMessageWithContext failed with unknown exception
CoreData: disconnectAllConnections failed with unknown excception
CoreData: Metadata Inconsistency: Missing metadata for record: %@
CoreData: Failed to acquire permanent objectIDs during schema generation: %@
CoreData: swallowed an exception during XPC store prefetching of %@, %@: %@
CoreData: swallowed an exception during XPC store recursive prefetching of %@, %@: %@
CoreData: Serious application error.  An exception was caught from the delegate of NSFetchedResultsController during a call to -controllerDidChangeContent:.  %@ with userInfo %@
CoreData: Serious application error.  Unidentifiable exception was caught from the delegate of NSFetchedResultsController during a call to -controllerDidChangeContent:.
CoreData: Invalid configuration for migrating the existing metadata entity to the new column: %@:%@ - %@
CoreData: Exception caught during execution of migration statement for cloudkit metadata tables %@ with userInfo %@
CoreData: Exception caught during execution of migration statement for cloudkit metadata tables %@
CoreData: Unable to find attribute to migrate to '%@' from '%@' on entity: %@
CoreData: Trying to return failure without an error set.
CoreData: Exception caught during cleanup of cloudkit metadata primary keys %@ with userInfo %@
CoreData: Exception caught during cleanup of cloudkit metadata primary keys %@
CoreData: tableMigration returned nil cloudkit update statements: %@
CoreData: Migration returned nil cloudkit statements: %@
CoreData: Cannot construct cloudkit metadata update statements for unimplemented migration type: %@
CoreData: NSSQLConnection manager failed to initialize with exception %@
CoreData: handleStoreRequest failed with unknown excception
CoreData: scheduleBarrierBlock failed with unknown excception
CoreData: scheduleConnectionsBarrier failed with unknown excception
CoreData: %@: Could not create cloudkit container: %@
CoreData: Unhandled exception in rowCacheForGeneration %@
CoreData: Expected to get an instance of NSCKMirroredRelationship for this recordID: %@ but got: %@
CoreData: Expected to get an instance of NSCKRecordMetadata for this recordID: %@ but got: %@
CoreData: Already have a mirrored relationship registered for this key: %@
CoreData: Didn't find record metadata for record in mirrored relationship: %@
CoreData: Didn't find record metadata for related record to mirrored relationship: %@
CoreData: Attempting to cache zone metadata but already have one: %@
CoreData: initWithRequest passed an error (%@) on a succes condition
CoreData: initWithRequest illegally passed nil instead of an error on a failure condition
CoreData: %@ - Exception thrown during fetch records operation: %@
CoreData: createRecordZoneID called before object has an owner name and zone name: %@
CoreData: Duplicate operations for identifier: %@
CoreData: System fields shouldn't be set anymore: %@
CoreData: Record name does not match recordID, even though our metadata linked this row with '%@': %@
CoreData: Record name appears to point to two different objects: %@ / %@
CoreData: Objects appear to be from different entities:
Store: %@
Other Store: %@
CoreData: Unknown value type '%@' for attribute: %@
CoreData: Not sure what to do with undefined attributes
CoreData: Unknown attribute type: %lu
CoreData: Found mirrored relationship for ignored relationship: %@
CoreData: Found mirrored relationship not marked uploaded, but this method is supposed to make sure store contents are equal, so shouldn't it be?
CoreData: Found mirrored relationship that's marked deleted but the objects are linked.
CoreData: Found pending mirrored relationship for linked objects (%@).
CoreData: _executeObjectFaultRequest passed a nil objectID
Fault
%@ - %@
RelationshipFault
CoreData: Batch insert failed to generate a post transaction query generation with error %d
CoreData: Batch delete failed to generate a post transaction query generation with error %d
CoreData: Unhandled exception from executeBatchDeleteRequest %@
CoreData: Batch update failed to generate a post transaction query generation with error %d
CoreData: Persistent history request failed to adopt a query generation with error %d
CoreData: Unhandled exception encountered during change request: %@ with userInfo %@
CoreData: Unsupported unique attribute type: %@
CoreData: Save changes failed to generate a post transaction query generation with error %d
### Failed to Soft Link: /System/Library/Frameworks/CoreSpotlight.framework/CoreSpotlight
CoreData: NSCoreDataCoreSpotlightDelegate failed to load a store '%@' due to %@ with %@
CoreData: Attempt to illegally register multiple NSCoreDataCoreSpotlightDelegate for a single store with description '%@'
CoreData: Reindexing Spotlight details threw an unknown exception
CoreData: Reindexing Spotlight details threw an unknown exception faulting managed object
CoreData: Spotlight history token failed to decode with an unknown exception
CoreData: Found more than one mirrored relationship matching a many to many: %@
CoreData: Attempted to update a mirrored relationship with a non-mirrored-relationship record: %@
CoreData: Found more than one mirrored relationship for a many-to-many: %@
CoreData: Exception reading data for file backed future.  %@
### Failed to Soft Link: /System/Library/Frameworks/CloudKit.framework/CloudKit
CoreData: resetAfterError illegally passed nil instead of an error on a failure condition
CoreData: Failed to execute mirroring request: %@
CoreData: %@: Asked to execute a request that isn't understood yet: %@
CoreData: Reset request was scheduled without a root cause error: %@
CoreData: Setup request executed with a completion block that will never be called: %@
CoreData: handleErrorInResult illegally passed nil instead of a result
CoreData: handleErrorInResult passed a sucessful result (%@) with an illegal error object (%@)
CoreData: handleErrorInResult illegally passed a failed result (%@) with nil instead of an error on a failure condition
CoreData: recoverFromError illegally passed nil instead of an error on a failure condition
CoreData: Failed to fetch database metadata during automatic import check: %@
333333
62a8480cd24caef341b5a6b5c6e848c4
@@(#)PROGRAM:CoreData  PROJECT:PersistenceFramework-947.1
PFUbiquityTransactionLogMigrator
_PFUbiquityMigrationContext
NSCloudKitMirroringDelegateOptions
PFUbiquityMigrationManager
NSSQLSaveChangesRequestContext
PFCloudKitSerializer
NSCloudKitMirroringFetchRecordsRequest
_NSCoreDataException
_NSCoreDataOptimisticLockingException
_NSCoreDataConstraintViolationException
_NSCoreDataSQLPredicateCategories
NSCoreDataXPCMessage
NSSecureCoding
NSCoding
PFCloudKitImportDatabaseContext
_NSFaultingMutableArray
NSSQLBindIntarray
_NSFaultingMutableSet
_NSFaultingMutableSetMutationMethods
NSPersistentCloudKitContainer
NSPersistentCloudKitContainerAdditions
_NSMappingModelBuilder
_NSMemoryStorePredicateRemapper
_NSChildContextPredicateRemapper
_NSPersistentHistoryPredicateRemapper
_NSXPCStorePredicateRemapper
NSSQLDerivedAttributeSQLGenerator
_NSNotifyingWrapperMutableSet
_CoreData_Extensions
_nop_missing_selectors
_NSPersistenceUtilities
_NSDefaultSectionInfo
NSFetchedResultsSectionInfo
NSSQLRTreeIndexQueryIntermediate
_NSProxyWrapperMutableSet
_NSSQLGenerator
NSCachedFetchRequestThunk
NSCachedFetchRequestInfo
_PFArray
_PFBatchFaultingArray
_PFBatchHistoryFaultingArray
_PFMutableProxyArray
_PFEncodedArray
_PFFetchedResultOrderedSetWrapper
_PFCachedNumber
NSSQLAttributeTrigger
NSSQLAttributeExtension
NSObject
PFCloudKitImporterZonePurgedWorkItem
_PFContextMapTable
_PFTask
NSPrivateCoreDataClassForFindingBundle
_PFRoutines
_PFWeakReference
_PFLock
NSLocking
_PFGarbageManager
_PFString
_PFEncodedString
_PFResultString
PFMirroredRelationship
PFMirroredManyToManyRelationship
PFMirroredManyToManyRelationshipV2
PFMirroredOneToManyRelationship
NSAtomicStore
_NSInternalMethods
NSSQLEntity_DerivedAttributesExtension
NSPersistentStoreDescription
NSCopying
NSAtomicStoreCacheNode
NSAttributeDescription
CoreDataSPI
NSAttributeStoreMapping
_NSCoreManagedObjectID
NSBasicObjectID
_NSScalarObjectID
NSScalarObjectID64
NSScalarObjectID48
_NSCoreDataTaggedObjectID
_NSCoreDataTaggedObjectIDFactory
NSBinaryObjectStore
NSPersistentStoreResult
NSUnknownRequestTypeResult
NSPersistentStoreAsynchronousResult
NSAsynchronousFetchResult
NSSQLKeypathTriggerAttributeExtension
NSBinaryObjectStoreFile
NSDictionaryMapNode
NSDictionaryStoreMap
NSEntityDescription
NSFastEnumeration
_NSEntityDescriptionPrivateMethods
NSEntityMapping
NSEntityMigrationPolicy
NSEntityStoreMapping
NSExpressionDescription
NSConstraintValidator
NSSQLitePrefetchRequestCache
NSPersistentCacheRow
NSXPCStoreMessageContext
NSXPCRow
NSCKExportMetadata
NSFaultHandler
NSPersistentContainer
NSFetchedPropertyDescription
NSFetchedResultSupport
NSFetchRequestResult
NSFetchRequest
_NSCoreDataSPI
NSFetchRequestExpression
NSJoin
NSKnownKeysMappingStrategy1
NSKnownKeysMappingStrategy2
NSKnownKeysDictionary1
_NSKnownKeysEnumerator
NSKnownKeysDictionary2
NSKnownKeysMappingStrategy
NSKnownKeysDictionary
CDDCloudKitScheduleActivityMessage
_NSOrderedSetDiff
_NSOrderedSetDiffDelete
_NSOrderedSetDiffChange
_NSOrderedSetDiffInsert
_NSOrderedSetDiffMove
NSManagedObject
_PhotosOrderKeyUpdateSupport
NSXPCStoreNotificationObserver
_PFDynamicAccessorsAndPropertySupport
_NSManagedObject_st
NSManagedObjectContext
_NSInternalAdditions
_NSInternalChangeProcessing
_NSInternalNotificationHandling
_PFManagedObjectReferenceQueue
_NestedContextSupport
_PFTempNestedSnapshot
NSManagedObjectID
NSManagedObjectModel
NSXPCStoreConnectionInfo
InternalMethods
NSXPCStoreServerConnectionContext
NSXPCStoreServerPerConnectionCache
NSManagedObjectModelBundle
NSMappedObjectStore
NSMappingModel
NSSQLUpdateColumnsIntermediate
NSXPCServerProtocol
NSXPCStoreConnection
PFCloudKitStoreComparisonCache
NSCKRecordMetadata
NSCloudKitMirroringDelegatePreJazzkonMetadata
_PFFreeMapEntry
NSMemoryObjectStore
NSMemoryStoreEqualityPredicateOperator
NSMemoryStoreInPredicateOperator
PFCloudKitImporterWorkItem
PFCloudKitHistoryAnalyzer
NSSQLAttributeExtensionFactory
NSMergeConflict
NSConstraintConflict
NSMergePolicy
PFUbiquityBaselineHeuristics
NSMigrationContext
NSMigrationManager
NSPersistentStore
NSPersistentStoreCache
NSPersistentStoreCoordinator
_NSPersistentStoreCoordinatorPrivateMethods
QueryGenerations
Triggers
PersistentHistory
PersistentHistoryInternal
Platform
_PFChangeInfo
NSPersistentStoreMap
NSPropertyDescription
_NSPropertyDescriptionPrivateMethods
NSBatchUpdateRequest
NSPredicatedStoreRequest
NSBatchUpdateResult
NSPropertyMapping
NSSQLLocationAttributeRTreeExtension
NSPropertyStoreMapping
NSPropertyTransform
PFCloudKitOptionsValidator
NSRelationshipDescription
NSRelationshipStoreMapping
NSSaveChangesRequest
NSSaveChangesRequest_Internal
NSSQLAliasGenerator
PFUbiquityLocationStatus
NSSQLAttribute
NSSQLBindVariable
NSBatchInsertRequest
NSBatchInsertResult
CDDCloudKitServerProxy
CDDCloudKitServer
NSXPCListenerDelegate
_PFCoreDataCloudKitServer
NSSQLColumn
NSSQLCompoundWhereIntermediate
NSSQLConstantValueIntermediate
PFHistoryAnalyzerObjectState
NSSQLCore
NSFilePresenter
NSSQLModelProvider
_NSSQLCoreConnectionObsever
NSFetchIndexElementDescription
NSSQLEntity
porting
NSCKExportedObject
CDDCloudKitMetadataModel
NSSQLEntityKey
NSSQLExpressionIntermediate
NSSQLFetchCountIntermediate
NSSQLFetchIntermediate
PFCloudKitExporterOptions
NSSQLForeignEntityKey
NSSQLForeignKey
CDDCloudKitMessage
NSSQLForeignKeyIntermediate
NSSQLFunctionExpressionIntermediate
NSSQLSavePlan
PFCloudKitImportZoneContext
_PFCKInsertedMetadataLink
NSSQLGenerator
CDDCloudKitClient
NSXPCStore
Internal
NSSQLIntermediate
NSSQLiteAdapter
_PFSQLiteSnapshotWrapper
NSSQLiteConnection
CDDCloudKitResponse
PFCloudKitExportContext
NSSQLBlockRequestContext
NSSQLJoinIntermediate
NSSQLKeypathExpressionIntermediate
NSSQLLimitIntermediate
NSSQLManyToMany
_PFCoreDataDaemonExtension
CDDCloudKitServerConfiguration
PFCloudKitImporterZoneChangedWorkItem
PFCloudKitSerializerDelegate
CDDCloudKitRegistrationMessage
NSSQLModel
NSSQLOffsetIntermediate
NSFetchIndexDescription
NSSQLOptLockKey
NSSQLOrderIntermediate
_PFFetchPlanHeader
NSXPCStoreServer
PFCloudKitContainerProvider
NSSQLPredicateAnalyser
NSPredicateVisitor
NSSQLUbiquitizedStoreConnectionManager
NSDerivedAttributeDescription
NSCloudKitMirroringRequestManager
PFStoreComparisonCache
_PFPersistentHistoryModel
_PFAncillaryModelFactory
_PFPersistentHistoryFetchModel
PFCloudKitStoreMonitor
NSCloudKitMirroringDelegateResetRequest
NSSQLiteStatementCache
NSSQLPrimaryKey
_NSPersistentHistoryToken
NSPersistentHistoryToken
NSManagedImmutableObject
NSSQLRTreeIndex
NSSQLProperty
NSSQLReadOnlySelectIntermediate
NSSQLRelationship
NSSQLRow
NSSQLRowCache
NSSQLSelectIntermediate
NSXPCStoreConnectionManager
NSSQLSimpleWhereIntermediate
PFCloudKitExporter
NSSQLiteStatement
NSSQLStoreMappingGenerator
NSSQLSubqueryExpressionIntermediatePredicateVisitor
NSSQLSubqueryExpressionIntermediate
NSSQLToMany
_NSCoreDataInternal
PFCloudKitSchemaGenerator
NSSQLRelationshipFaultRequestContext
PFCloudKitImporter
NSSQLFetchRequestContext
NSSQLXPCFetchRequestContext
NSSQLObjectIDSetFetchRequestContext
NSSQLToOne
NSSQLWhereIntermediate
NSStoreMapNode
NSXPCStoreServerRequestHandlingPolicy
NSStoreMapping
NSStoreMappingGenerator
_PFResultArray
_PFResultObject
_PFResultObjectKeyEnumerator
NSXPCStoreManagedObjectArchivingToken
NSStoreMigrationPolicy
_NS128bitWrapper
NSTemporaryObjectID
_NSTemporaryObjectID2
NSValidationErrorLocalizationPolicy
NSMergedPolicyLocalizationPolicy
NSFetchedResultsController
PrivateMethods
NSSQLTernaryExpressionIntermediate
PFCloudKitMetadataModel
PFCloudKitMetadataValueTransformer
_NSSQLEntityMigrationDescription
NSSQLiteIntarrayTable
NSSQLUpdateIntermediate
_NSSQLiteStoreMigrator
NSSQLIndexIntermediate
_NSSQLTableMigrationDescription
NSPersistentCloudKitContainerOptions
NSSQLiteInPlaceMigrationManager
NSSQLIndex
NSSQLGroupByIntermediate
NSSQLHavingIntermediate
PFCloudKitModelValidator
NSPersistentStoreRequest
NSAsynchronousFetchRequest
_NSPropertyDescriptionProxy
_NSPropertyDescriptionProxy2
_PFEvanescentData
_PFEncodedData
_PFResultData
_PFExternalReferenceData
NSSQLCountRequestContext
NSSQLConnectionManager
NSSQLDefaultConnectionManager
_NSFaultingMutableOrderedSet
NSSQLCoreDispatchManager
PFCloudKitImporterOptions
NSSQLForeignOrderKey
_CDSnapshot
NSMutableCopying
NSIncrementalStore
_PFSpawn
NSPersistentHistoryChange
_NSPersistentHistoryChange
NSConstraintCacheKey
NSConstraintCache
NSIncrementalStoreNode
NSSQLFetchDictionaryCountIntermediate
_NSNotifyingWrapperMutableOrderedSet
_NSFaultingMutableOrderedSetMutationMethods
PFHistoryAnalyzerOptions
PFCloudKitMetadataMigrationContext
_NSProxyWrapperMutableOrderedSet
PFCloudKitSetupAssistant
CDDCloudKitScheduledActivity
NSGenerationalRowCache
_PFUbiquityRecordImportOperation
NSManagedObjectContextFaultingDelegate
_PFUbiquityRecordsExporter
PFCloudKitMetadataCache
NSSQLBatchInsertRequestContext
_PFUbiquityRecordsImporter
_PFUbiquityRecordImportOperationDelegate
PFUbiquityBaselineRollOperationDelegate
PFUbiquityBaselineRecoveryOperationDelegate
PFUbiquityBaselineRollResponseOperationDelegate
_PFUbiquityStack
NSSQLBatchDeleteRequestContext
UbiquityMethods
NSCKImportPendingRelationship
PFUbiquityPeerState
NSSQLStoreRequestContext
PFUbiquityRemotePeerState
NSCloudKitMirroringResult
NSCKMetadataEntry
PFUbiquityLogging
PFUBLogEventID
PFUbiquityEventLogging
NSSQLBinaryIndex
PFUbiquityFilePresenter
PFUbiquityRecordImportConflict
PFUbiquityMergeConflict
PFUbiquityMergePolicy
__CLI
NSSQLObjectFaultRequestContext
PFUbiquitySwitchboard
PFUbiquitySwitchboardEntry
PFUbiquitySwitchboardEntryMetadata
PFHistoryAnalyzerContext
NSSQLCorrelationTableUpdateTracker
PFCloudKitImporterFetchRecordsWorkItem
PFUbiquityFileCoordinator
NSPersistentHistoryChangeRequest
NSPersistentHistoryResult
PFHistoryAnalyzer
PFUbiquityBaseline
NSCKRecordZoneMetadata
PFUbiquityBaselineMetadata
NSQueryGenerationToken
_NSQueryGenerationToken
_NSXPCQueryGenerationToken
NSXPCSaveRequestContext
NSCKImportOperation
PFCloudKitStoreComparer
PFUbiquityExportContext
PFUbiquityStoreExportContext
NSCloudKitMirroringRequest
NSCloudKitMirroringExportRequest
NSCloudKitMirroringImportRequest
NSCloudKitMirroringResetZoneRequest
NSCloudKitMirroringResetMetadataRequest
NSPersistentHistoryTransaction
_NSPersistentHistoryTransaction
PFUbiquityGlobalObjectID
PFCloudKitLogging
PFUbiquitySaveSnapshot
NSBatchDeleteRequest
NSBatchDeleteResult
PFUbiquityStoreSaveSnapshot
PFUbiquityTransactionLog
PFUbiquityImportContext
NSCoreDataCoreSpotlightDelegate
PFUbiquityLocation
PFCloudKitImporterZoneDeletedWorkItem
NSCKMirroredRelationship
NSSQLBoundedByIntermediate
NSSQLObjectIDRequestContext
PFUbiquityBaselineRollOperation
NSSQLStatementIntermediate
PFCloudKitHistoryAnalyzerContext
_PFZipFileArchive
PFZipCentralDirectoryFileHeader
PFZipEndOfCentralDirectoryRecord
PFZipLocalFileHeader
PFUbiquityPeer
PFUbiquityTransactionEntry
PFUbiquityPeerSnapshot
FileBackedFutures
_NSDataFileBackedFuture
_NSFileBackedFuture
_NSCloudKitDataFileBackedFuture
PFUbiquityPeerSnapshotCollection
PFUbiquityToManyConflictDiff
PFCloudKitErrorLog
PFCloudKitErrorLogEntry
PFUbiquityBaselineRecoveryOperation
PFUbiquityStoreMetadata
NSCKDatabaseMetadata
_NSNoChangeToken
_NSXPCStoreObjectIDArrayConstantValueExpression
XPCStoreSupport
NSBatchInsertRequestEncodingToken
NSBatchUpdateRequestEncodingToken
NSBatchDeleteRequestEncodingToken
NSPersistentHistoryChangeRequestToken
_NSXPCStoreUtilities
PFUbiquityPeerRange
PFUbiquityKnowledgeVector
NSCloudKitMirroringRequestOptions
PFUbiquityPeerReceipt
PFUbiquityImportOperation
CDDCloudKitRegisteredClient
PFUbiquityStoreMetadataMedic
PFUbiquityBaselineRollResponseOperation
PFUbiquityBaselineOperation
NSSQLBatchUpdateRequestContext
NSCloudKitMirroringDelegateSetupRequest
NSCloudKitMirroringDelegateSetupResult
NSSQLPersistentHistoryChangeRequestContext
PFUbiquitySetupAssistant
PFUbiquityContainerIdentifier
NSCloudKitMirroringDelegate
PFCloudKitExporterDelegate
NSPersistentStoreMirroringDelegate
NSCKExportOperation
PFUbiquityPeerRangeCache
PFUbiquitySQLCorePeerRange
PFUbiquityMetadataFactory
PFUbiquityMetadataFactoryEntry
PFUbiquityPeerRangeReservationContext
_PFModelMap
PFUbiquityMetadataFactoryFilePresenter
PFUbiquityTransactionLogCache
NSCachingFetchRequest
NSSQLVariableExpressionIntermediate
PFUbiquityTransactionHistoryCache
PFUbiquityTransactionEntryLight
PFUbiquityGlobalObjectIDCache
PFUbiquitySwitchboardCacheWrapper
PFUbiquitySafeSaveFile
PFUbiquityRecordsImporterSchedulingContext
PFUbiquityMigrationAssistant
PFUbiquityContainerMonitor
init
populateMappingsByEntityName
dealloc
entityMappings
countByEnumeratingWithState:objects:count:
sourceEntityName
mappingType
addObject:
name
null
numberWithUnsignedInteger:
dictionaryWithObjectsAndKeys:
exceptionWithName:code:reason:userInfo:
initWithObjects:forKeys:
initWithArray:
createPeerStoreLocationForPeerID:andStoreName:withUbiquityRootLocation:
createMapOfLocationsForOldManagedObjectModel:andNewManagedObjectModel:inUbiquityPeerStoreLocation:
canLogMessageAtLevel:
count
allKeys
objectForKey:
migrateTransactionLogFromLocation:toLocation:error:
createVersionHashStringForModel:
createBaselineLocation:forStoreName:andModelVersionHash:withUbiquityRootLocation:
migrateBaselineFromLocation:toLocation:error:
fileExistsAtLocation
createTemporaryTransactionLogLocationFromTransactionLogLocation:
initWithTransactionLogLocation:andLocalPeerID:
throttleLogs
moveFileToPermanentLocationWithError:
loadImportMetadataWithError:
loadInsertedObjectsDataWithError:
loadDeletedObjectsDataWithError:
loadUpdatedObjectsDataWithError:
saveSnapshot
storeName
storeSaveSnapshotForStoreName:
transactionDate
setTransactionDate:
transactionNumber
peerStates
peerIDs
setTransactionNumber:peerStates:andPeerIDs:
setTransactionLog:
setSourceStoreSaveSnapshot:
setDestinationStoreSaveSnapshot:
insertedObjects
createDestinationObjectsFromSourceObjects:migrationContext:
updatedObjects
deletedObjects
setInsertedObjects:
setUpdatedObjects:
setDeletedObjects:
setUseTemporaryLogLocation:
writeToDiskWithError:andUpdateFilenameInTransactionEntries:
entityName
destinationEntityName
primaryKey
owningPeerID
initWithStoreName:entityName:primaryKey:andPeerID:
attributeMappings
_propertyTransforms
prerequisiteTransform
replaceMissingValueOnly
valueExpression
expressionType
constantValue
isEqual:
setObject:forKey:
keyPath
destinationStoreSaveSnapshot
entitiesByName
relationshipMappings
objectAtIndex:
isNSArray__
initWithObjects:count:
initWithCapacity:
sourceGlobalObjectIDFromCompressedID:
createDestinationGlobalObjectIDFromSourceGlobalObjectID:
compressedGlobalObjectIDFromGlobalObjectID:
propertiesByName
isToMany
createDestinationObjectContentFromSourceObjectContent:withEntityMapping:migrationContext:
enumerateKeysAndObjectsUsingBlock:
initWithSourceModel:destinationModel:mappingModel:localPeerID:
migrateTransactionLogsForStoreName:andLocalPeerID:atUbiquityRootLocation:error:
_srcModel
_dstModel
_mappingModel
_localPeerID
_mappingsByEntityName
_removedEntities
_throttleLogs
globalObjectIDFromCompressedObjectID:
transactionLog
sourceStoreSaveSnapshot
_transactionLog
_sourceStoreSaveSnapshot
_destinationStoreSaveSnapshot
containerIdentifier
initWithContainerIdentifier:
shouldInitializeSchema
useEncryptedStorage
apsConnectionMachServiceName
copy
description
mutableCopy
appendFormat:
initWithCloudKitContainerOptions:
setContainerIdentifier:
initializeSchema
setInitializeSchema:
setUseEncryptedStorage:
ckAssetThresholdBytes
setCkAssetThresholdBytes:
operationMemoryThresholdBytes
setOperationMemoryThresholdBytes:
containerOptions
setContainerOptions:
automaticallyDownloadFileBackedFutures
setAutomaticallyDownloadFileBackedFutures:
automaticallyScheduleImportAndExportOperations
setAutomaticallyScheduleImportAndExportOperations:
scheduler
setScheduler:
notificationListener
setNotificationListener:
skipCloudKitSetup
setSkipCloudKitSetup:
containerProvider
setContainerProvider:
useDaemon
setUseDaemon:
useTestDaemon
setUseTestDaemon:
preserveLegacyRecordMetadataBehavior
setPreserveLegacyRecordMetadataBehavior:
setApsConnectionMachServiceName:
_containerIdentifier
_ckAssetThresholdBytes
_useEncryptedStorage
_initializeSchema
_automaticallyDownloadFileBackedFutures
_automaticallyScheduleImportAndExportOperations
_operationMemoryThresholdBytes
_containerOptions
_scheduler
_notificationListener
_skipCloudKitSetup
_containerProvider
_apsConnectionMachServiceName
_useDaemon
_useTestDaemon
_preserveLegacyRecordMetadataBehavior
createModelFromBaselineModelWithModelVersionHash:peerID:storeName:andUbiquityRootLocation:
initWithDestinationModel:sourceModel:ubiquityRootLocation:localPeerID:
sourceModel
destinationModel
rootLocation
inferredMappingModelForSourceModel:destinationModel:error:
errorWithDomain:code:userInfo:
initWithLocalPeerID:ubiquityRootLocation:forStoreWithName:andManagedObjectModel:
existsInCloud
loadFile:
metadata
_migrateToModelVersionHash:
storeData
stringByAppendingPathComponent:
length
fileSystemRepresentation
numberWithInt:
stringWithCString:encoding:
fileURLWithPath:
URLByAppendingPathComponent:
writeToURL:atomically:
initWithSourceModel:destinationModel:
dictionaryWithObjects:forKeys:count:
migrateStoreFromURL:type:options:withMappingModel:toDestinationURL:destinationType:destinationOptions:error:
gatherContentsFromMigratedBaseline:withStoreFileURL:error:
safeSaveFile:moveToPermanentLocation:error:
makeCurrentBaselineWithError:
defaultManager
stringWithFormat:
removeItemAtPath:error:
initWithDestinationModel:storeName:previousModelVersionHash:ubiquityRootLocation:localPeerID:
migrateTransactionLogs:andBaselineIfNecessaryForStoreName:peerID:error:
_destinationModel
_sourceModel
_rootLocation
initWithRequest:context:sqlCore:
metadataToWrite
initForRequestContext:
faultHandler
isInMemory
externalDataReferencesDirectory
externalDataLinksDirectory
fileBackedFuturesDirectory
hasChangesForWriting
sqlCore
model
persistentStoreRequest
rowCacheForContext:
prepareRows
setException:
rowCache
forgetRowForObjectID:
context
_addObjectIDsUpdatedByTriggers:
removeAllObjects
setResult:
connection
createSetOfObjectIDsUpdatedByTriggers
clearObjectIDsUpdatedByTriggers
setConnection:
setLocalError:
exception
localError
result
rowForObjectID:
_mergeOldMask:andNewMask:
request
isWritingRequest
executePrologue
executeEpilogue
executeRequestCore:
originalRowForObjectID:
setOriginalRow:forObjectID:
addDataMask:forEntityKey:
dataMaskForKey:
savePlan
originalCachedRows
_metadataToWrite
_savePlan
_faultHandler
_objectIDsToPruneTrigger
_originalCachedRows
_updateMasksForHistoryTracking
_externalDataReferencesDirectory
_externalDataLinksDirectory
_fileBackedFuturesDirectory
initWithZone:mirroringOptions:metadataCache:recordNamePrefix:
managedObjectContext
entity
objectID
persistentStore
zoneID
zoneMetadataForZoneID:
zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:
cacheZoneMetadata:
getRecordMetadataForObject:inManagedObjectContext:error:
ckRecordSystemFields
initForReadingFromData:error:
alloc
initWithCoder:
recordID
ckRecordName
recordName
isEqualToString:
stringByAppendingString:
recordType
hasPrefix:
stringWithUTF8String:
finishDecoding
initWithRecordName:zoneID:
recordTypeForEntity:
initWithRecordType:recordID:
applyCDPrefixToName:
setValue:forKey:usingEncryption:onRecord:
attributesByName
valueForKey:
attributeType
encodeObjectValue:forTransformableAttribute:
representativeValueFor:
UUIDString
absoluteString
allValues
isVariableLengthAttributeType:
sizeOfVariableLengthAttribute:withValue:
compare:
sortedArrayUsingComparator:
shouldTrackAttribute:
unsignedIntegerValue
ckAssetAttributeNameForAttributeName:
isFileBackedFuture
size
shouldEncryptValueForAttribute:
generateCKAssetFileURLForObjectInStore:
fileURL
copyItemAtURL:toURL:error:
initWithFileURL:
_storeMetadata
writeToURL:options:error:
dataUsingEncoding:allowLossyConversion:
enumerateObjectsUsingBlock:
relationshipsByName
shouldTrackRelationship:
inverseRelationship
mtmKeyForObjectWithRecordName:relatedToObjectWithRecordName:byRelationship:withInverse:
mirroredRelationshipForKey:
isUploaded
boolValue
UUID
createRecordID
initWithRecordID:forRecordWithID:relatedToRecordWithID:byRelationship:withInverse:andType:
insertMirroredRelationshipForManyToMany:inZoneWithMetadata:inStore:withManagedObjectContext:
setIsUploaded:
setNeedsDelete:
setIsPending:
getValueStoreForRecord:
populateRecordValues:
mtmKeysRelatedToObjectWithID:byRelationshipWithName:
minusSet:
applyUpdatedRecords:deletedRecordIDs:toStore:inManagedObjectContext:onlyUpdatingAttributes:andRelationships:error:
initWithUpdatedRecords:deletedRecordTypeToRecordIDs:options:fileBackedFuturesDirectory:
initializeCachesWithManagedObjectContext:andObservedStore:error:
modifiedRecords
metadataForRecord:inManagedObjectContext:fromStore:error:
recordZone
setRecordZone:
getValueFromRecord:forKey:isEncrypted:
entityNameForRecordType:
objectIDForRecordWithID:ofType:
objectWithID:
entityID
entityId
longValue
_referenceData64
entityPK
integerValue
insertNewObjectForEntityForName:inManagedObjectContext:
registerObject:forInsertedRecord:withMetadata:
updateAttributes:andRelationships:onManagedObject:fromRecord:withRecordMetadata:importContext:
deletedObjectIDs
deleteObject:
allObjects
metadataForObjectIDs:inStore:withManagedObjectContext:error:
deletedRelationships
updateRelationshipValueUsingImportContext:andManagedObjectContext:error:
domain
code
cloudKitSerializer:failedToUpdateRelationship:withError:
populateUnresolvedIDsInStore:withManagedObjectContext:error:
updatedRelationships
ckRecordID
relatedCKRecordID
relationshipDescription
inverseRelationshipDescription
mirroredRelationshipForManyToMany:inStore:withManagedObjectContext:error:
invalidatedPendingRelationships
cloudKitSerializer:resolvedPendingRelationship:
persistentStoreCoordinator
managedObjectModel
pendingRelationshipsToTry
cdEntityName
relationshipName
relatedRecordName
relatedEntityName
arrayWithObjects:count:
ckRecordNameForOrderedRecordNames:
ckRecordTypeForOrderedRelationships:
needsDelete
mirroredRelationshipWithDeletedRecordType:recordID:andManagedObjectModel:
initWithRecordID:recordType:managedObjectModel:andType:
existingObjectWithID:error:
mirroredRelationshipWithManagedObject:withRecordID:relatedToObjectWithRecordID:byRelationship:
fetchPendingMirroredRelationshipsInStore:withManagedObjectContext:error:
createRecordIDForRecord
createRecordIDForRelatedRecord
updateRelationshipValueUsingImportContext:andManagedObjectContext:isDelete:error:
deletedMirroredRelationshipRecordIDs
purgeMirroredRelationshipsWithRecordIDs:withManagedObjectContext:error:
linkInsertedObjectsAndMetadataInContext:error:
performBlockAndWait:
isInserted
setValue:forKey:
newArchivedDataForSystemFieldsOfRecord:
setCkRecordSystemFields:
isPrivateAttribute:
isTransient
userInfo
defaultValue
cloudKitSerializer:safeSaveURLForAsset:
initWithStoreMetadata:directory:originalFileURL:
initWithStoreMetadata:directory:
originalFileURL
initWithURL:
data
isNSData__
decodeValue:forTransformableAttribute:
initWithUUIDString:
initWithContentsOfURL:encoding:error:
initWithString:
addMirroredRelationshipToLink:
encryptedValuesByKey
hasSuffix:
encryptedValueStore
recordMetadataForObject:
metadataForObject:inManagedObjectContext:error:
insertMetadataForObject:inZone:recordNamePrefix:error:
registerRecordMetadata:forObject:
_isInMemoryStoreURL:
identifier
URLByDeletingLastPathComponent
URLByAppendingPathComponent:isDirectory:
assetStorageDirectoryURLForStore:
_rootEntity
substringFromIndex:
initRequiringSecureCoding:
encodeSystemFieldsWithCoder:
encodedData
finishEncoding
isNSDate__
isNSNumber__
isNSString__
estimatedByteSizeOfValue:andKey:
exceptionWithName:reason:userInfo:
estimateByteSizeOfRecordID:
addObjectsFromArray:
zoneName
entitiesForConfiguration:
newSetOfRecordKeysForEntity:includeCKAssetsForFileBackedFutures:
unionSet:
newSetOfRecordKeysForAttribute:includeCKAssetsForFileBackedFutures:
newSetOfRecordKeysForRelationship:
shouldTrackProperty:
orderRelationships:
componentsJoinedByString:
isMirroredRelationshipRecordType:
assetsOnRecord:withOptions:
estimateByteSizeOfRecord:
newSetOfRecordKeysForEntitiesInConfiguration:inManagedObjectModel:includeCKAssetsForFileBackedFutures:
manyToManyRecordNameToRecord
setMtmRecord:toMtmRecordName:
writtenAssetURLs
addURLToWrittenAssetURLs:
newCKRecordsFromObject:fullyMaterializeRecords:error:
applyUpdatedRecords:deletedRecordIDs:toStore:inManagedObjectContext:error:
.cxx_destruct
mirroringOptions
recordNamePrefix
delegate
setDelegate:
_recordZone
_manyToManyRecordNameToRecord
_recordNamePrefix
_mirroringOptions
_delegate
_writtenAssetURLs
_metadataCache
initWithOptions:completionBlock:
throwNotEditable:
executeRequest:error:
validateForUseWithStore:error:
sortUsingSelector:
initWithFormat:
_entityNameToAttributeNamesToFetch
entityNameToAttributesToFetch
setEntityNameToAttributesToFetch:
setEntityNameToAttributeNamesToFetch:
setObjectIDsToFetch:
_isEditable
objectIDsToFetch
_objectIDsToFetch
_entityNameToAttributesToFetch
_editable
initWithFormat:arguments:
UTF8String
initWithName:code:reason:userInfo:
initWithDictionary:
addEntriesFromDictionary:
removeObjectForKey:
initWithName:reason:userInfo:
_setDomain:
errorObjectWithUserInfo:
_code
_domain
initWithObjectsAndKeys:
defaultInstance
minimalFormInContext:
_keypathsForDerivedPropertyValidation:
minimalFormInContext:ofPredicate:
rightExpression
operatorType
leftExpression
isNSSet__
isNSOrderedSet__
isNSDictionary__
expressionForConstantValue:
comparisonPredicateModifier
options
predicateWithLeftExpression:rightExpression:modifier:type:options:
array
initWithType:subpredicates:
minimalFormInContext:ofPredicates:
isTemporaryID
predicateOperatorType
allowEvaluation
evaluateWithObject:
dictionaryWithObject:forKey:
predicateOperator
_isForeignObjectExpression:givenContext:
initWithPredicateOperator:leftExpression:rightExpression:
drain
subpredicates
collection
predicateFormat
selector
valueForKeyPath:
operand
arguments
_newKeyPathExpressionForString:
initWithOperand:andKeyPath:
arrayWithObject:
initWithExpressionType:operand:selector:argumentArray:
_mapKVCOperatorsToFunctionsInContext:
substringWithRange:
expressionForKeyPath:
initWithObject:
componentsSeparatedByString:
removeLastObject
removeObjectAtIndex:
expressionForFunction:selectorName:arguments:
expressionForFunction:arguments:
characterAtIndex:
appendString:
containsObject:
initWithObjects:
rangeOfString:
rangeOfString:options:
canonical:
predicate
variableExpression
initWithExpression:usingIteratorExpression:predicate:
anyObject
localizedStandardRangeOfString:
stringByReplacingOccurrencesOfString:withString:
trueExpression
falseExpression
decodeIntegerForKey:
decodeObjectOfClass:forKey:
encodeInteger:forKey:
encodeObject:forKey:
supportsSecureCoding
encodeWithCoder:
messageCode
setMessageCode:
messageBody
setMessageBody:
token
setToken:
contextName
setContextName:
contextTransactionAuthor
setContextTransactionAuthor:
processName
setProcessName:
_messageCode
_messageBody
_token
_contextName
_contextTransactionAuthor
_processName
initWithInterestingZoneIDs:
hasWorkToDo
zoneWithIDChanged:
zoneWithIDWasDeleted:
zoneWithIDWasPurged:
changedRecordZoneIDs
deletedRecordZoneIDs
purgedRecordZoneIDs
updatedChangeToken
setUpdatedChangeToken:
interestingZoneIDs
_interestingZoneIDs
_changedRecordZoneIDs
_deletedRecordZoneIDs
_purgedRecordZoneIDs
_updatedChangeToken
_faultHandler__
retainedFulfillAggregateFaultForObject:andRelationship:withContext:
initWithSource:forRelationship:asFault:
setArray:
copyWithZone:
descriptionWithLocale:
descriptionWithLocale:indent:
willRead
enumerateObjectsWithOptions:usingBlock:
enumerateObjectsAtIndexes:options:usingBlock:
indexOfObjectWithOptions:passingTest:
indexOfObjectAtIndexes:options:passingTest:
indexesOfObjectsWithOptions:passingTest:
indexesOfObjectsAtIndexes:options:passingTest:
objectEnumerator
insertObject:atIndex:
replaceObjectAtIndex:withObject:
getObjects:
accessInstanceVariablesDirectly
allocWithZone:
retain
release
retainCount
_tryRetain
_isDeallocating
isFault
turnIntoFault
source
relationship
mutableCopyWithZone:
_cd_rc
_realArray
_source
_relationship
_flags
initWithValue:
index
setIndex:
value
setValue:
tableName
setTableName:
_index
_value
_tableName
_isRelationship
deleteRule
_entitysReferenceID
willReadWithContents:
_retainedObjectWithID:optionalHandler:withInlineStorage:
_commitPhotoshoperyForRelationshipAtIndex:newValue:
setSet:
member:
removeObject:
objectsWithOptions:passingTest:
intersectsSet:
isEqualToSet:
isSubsetOfSet:
makeObjectsPerformSelector:
makeObjectsPerformSelector:withObject:
intersectSet:
initWithSource:destinations:forRelationship:inContext:
_shouldProcessKVOChange
_isIdenticalFault:
classForCoder
replacementObjectForCoder:
classForArchiver
_realSet
_createMutationMethodsForClass:forKey:
_addObjectMethod
_removeObjectMethod
_addMethod
_removeMethod
_intersectMethod
_setMethod
initWithName:managedObjectModel:
discoverDefaultContainerIdentifier
persistentStoreDescriptions
lastObject
setCloudKitContainerOptions:
cloudKitContainerOptions
setPersistentStoreDescriptions:
setMirroringDelegate:
setOption:forKey:
_loadStoreDescriptons:withCompletionHandler:
recordForManagedObjectID:
recordsForManagedObjectIDs:
recordIDForManagedObjectID:
recordIDsForManagedObjectIDs:
migrationDebugLevel
setMigrationDebugLevel:
_resetCaches
renamingIdentifier
initWithDomain:code:userInfo:
newEntityMappingWithSource:destination:
inferPropertyMappingsForEntityMapping:
setEntityMappings:
expressionForVariable:
arrayWithObjects:
expressionForFetch:context:countOnly:
setSourceExpression:
_propertyType
newInferredPropertyMappingWithSourceAttribute:destinationAttribute:
newInferredPropertyMappingWithSourceRelationship:destinationRelationship:
setAttributeMappings:
setRelationshipMappings:
setUserInfo:
_isSchemaEqual:
setSourceEntityName:
versionHash
setSourceEntityVersionHash:
setName:
setDestinationEntityName:
setDestinationEntityVersionHash:
checkForSchemaMatchBetween:andDestination:
_setChangeIsSchemaCompatible:
setMappingType:
isOptional
initWithPropertyName:valueExpression:
_canTransformSourceAttributeType:toDestinationAttributeType:
storesBinaryDataExternally
expressionForEvaluatedObject
setPrerequisiteTransform:
setReplaceMissingValueOnly:
setValueExpression:
_setPropertyTransforms:
numberWithBool:
_setTransformValidations:
minCount
newInferredMappingModel:
_currentEntityMapping
_error
createPredicateForFetchFromPredicate:withContext:
_hasIDMappings
acceptVisitor:flags:
initWithContext:
modifier
isNegation
initWithOperatorType:modifier:negate:options:
initWithOperatorType:modifier:options:
setContext:
setPredicateOperator:
createPredicateForFetchFromPredicate:
visitPredicate:
visitPredicateExpression:
_context
_mappedForParentStoreID:
replacementValueForValue:
predicateWithValue:
_backingObjectID
storeTokens
replacementValueForKeyPath:
initWithStoreIdentifier:
_storeID
initialize
propertyDescription
derivationExpression
objectAtIndexedSubscript:
propertyNamed:
columnName
count:
correlationTableName
dictionary
initWithEntity:sqlString:
hasInheritance
subentityMaxID
propertyType
destinationEntity
_parameterPropertyTokenForDerivedAttribute:andKeypath:onEntity:
uppercase:
lowercase:
sum:
_computeNewColumnTokenForKeypathExpression:governingEntity:
firstObject
_computeSingleParameterTokenForFunctionAttribute:functionName:
random
_computeNowTokenForFunctionAttribute:
_triggerColumnListComponentForAttributeKeypaths:startingAt:
_triggerColumnWhereComponentForAttributeKeypaths:startingAt:
_computeNewColumnTokenForKeypathAttribute:
_generateTriggerForAttribute:newToken:triggerColumnListComponent:triggerColumnWhereComponent:
_generateSQLForToOneDerivationForDerivedAttribute:toOneKeypath:
_computeNewColumnTokenForFunctionAttribute:
_generateIncrementDecrementTriggersForDerivedAttribute:toManyKeypath:
_generateIncrementDecrementTriggersForDerivedAttribute:manyToManyKeypath:
_generateSQLForAttributeKeypathDerivationForDerivedAttribute:keypaths:
_generateSQLForToOneKeypathDerivationForDerivedAttribute:keypaths:
_generateSQLForAttributeFunctionDerivationForDerivedAttribute:keypaths:
_generateSQLForToManyFunctionDerivationForDerivedAttribute:keypaths:
_generateSQLForManyToManyFunctionDerivationForDerivedAttribute:keypaths:
_generateSQLForToOneFunctionDerivationForDerivedAttribute:keypaths:
filteringPredicate
_generateSQLForDerivedAttributeWithOneParameterKeypath:keypaths:
generateSQLForDerivedAttribute:keypaths:
initWithSet:copyItems:
willChangeValueForKey:withSetMutation:usingObjects:
didChangeValueForKey:withSetMutation:usingObjects:
initWithContainer:key:mutableSet:
_container
_key
_mutableSet
compare:options:range:
_caseInsensitiveNumericCompare:
_disableAutomaticTerminationWithoutSettingRelaunchable:
_enableAutomaticTerminationWithoutSettingRelaunchable:
setURL:forPersistentStore:
_setURL:forPersistentStore:withCoordinator:
attributeTypeForXMLInfo:
numberWithUnsignedInt:
decodeObjectForKey:
unsignedIntValue
clearSectionObjectsCache
_sections
indexOfObject:
_fetchedObjects
fetchedObjects
subarrayWithRange:
indexOfObject:inRange:
indexTitle
numberOfObjects
objects
initWithController:name:indexTitle:sectionOffset:
setNumberOfObjects:
setSectionOffset:
sectionNumber
setController:
sectionOffset
oldSectionNumber
setOldSectionNumber:
_controller
_name
_indexTitle
_sectionOffset
_numberOfObjects
_oldSectionNumber
_sectionObjects
initWithScope:
entityDescription
initWithNestingLevel:
generateTableAlias
isSimpleKeypath:
keypathExpressionIsSafeLHSForIn:
initWithExpression:allowToMany:inScope:
setSubstitutePK:
generateSQLStringInContext:
rtreeIndexForIndexNamed:
_validateCollection:context:
_validateExpression:context:
_generateSQLForConstantValue:inContext:
initForIndexNamed:onEntity:properties:ranges:inScope:
_entity
_indexName
_properties
_ranges
initWithContainer:key:mutableSet:mutationMethods:
_mutationMethods
appendSQL:
prepareInsertStatementWithRow:includeConstraints:
sqlEntity
foreignKeyColumns
foreignEntityKeyColumns
foreignOrderKeyColumns
attributeColumns
subentityKey
optLockKey
_startSQL:
toOneRelationship
isConstrained
pk64
sqlType
initWithInt64:sqlType:
addBindVariable:
sqlEntityID
initWithUnsignedInt:sqlType:
optLock
slot
foreignKeyForSlot:
foreignEntityKeyForSlot:
foreignOrderKeyForSlot:
attributeValueForSlot:
attributeDescription
initWithValue:sqlType:attributeDescription:
isReflexive
inverseColumnName
inverseOrderColumnName
orderColumnName
appendWhereClause:
newUpdateMaskForConstrainedValues
setOptLock:
buildWhereClauseForRow:optLock:
appendWhereClauseToSQL
initWithStatement:forAdapter:
sqlString
prepareInsertStatementWithRow:
prepareInsertStatementForRelationship:
prepareMasterReorderStatementForRelationship:
prepareMasterReorderStatementPart2ForRelationship:
prepareReorderStatementForRelationship:
prepareDeleteStatementForRelationship:
prepareConstrainedValuesUpdateStatementWithRow:
prepareUpdateStatementWithRow:originalRow:withMask:
prepareDeleteStatementWithRow:
_statement
_adapter
_sqlString
_whereClause
_selectList
clearCaches
retainedObject
clearCaches:
performAndWait:
cachedSQLiteStatement
initForConnection:
limitedStatement
unlimitedStatement
setLimitedStatement:
setUnlimitedStatement:
_limitedStatement
_unlimitedStatement
_connection
substitutionBindVariableOrder
setSubstitutionBindVariableOrder:
substitutionBindIntarrayOrder
setSubstitutionBindIntarrayOrder:
_substVarBindOrdering
_substIntarrayBindOrdering
initWithObjects:count:andFlags:
initWithObjects:count:andFlags:andContext:
concurrencyType
newArrayFromObjectIDs
indexOfObjectIdenticalTo:inRange:
methodForSelector:
_registerAsyncReferenceCallback
raise:format:
_objectsPointer
arrayFromObjectIDs
indexOfObjectIdenticalTo:
indexOfManagedObjectForObjectID:
managedObjectIDAtIndex:
getObjects:range:
_setShouldRelease:
_setShouldUseExtendedRelease:
_count
_array
_weakContext
initWithDictionary:andObjectID:
relationshipKeyPathsForPrefetching
numberWithUnsignedLongLong:
initWithTransactionIDs:
fetchLimit
setFetchBatchSize:
affectedStores
setAffectedStores:
_setTransaction:
_setChanges:
initWithDictionary:andChangeObjectID:
setEntity:
setIncludesPendingChanges:
setSortDescriptors:
setFetchOffset:
setHavingPredicate:
setPropertiesToGroupBy:
resultType
setResultType:
includesSubentities
setIncludesSubentities:
includesPropertyValues
setIncludesPropertyValues:
returnsObjectsAsFaults
setReturnsObjectsAsFaults:
setRelationshipKeyPathsForPrefetching:
returnsDistinctResults
setReturnsDistinctResults:
propertiesToFetch
setPropertiesToFetch:
shouldRefreshRefetchedObjects
setShouldRefreshRefetchedObjects:
_disablePersistentStoreResultCaching
_setDisablePersistentStoreResultCaching:
initWithLeftExpression:rightExpression:modifier:type:options:
setPredicate:
fetchBatchSize
setFetchLimit:
initWithPFArray:inRange:
_newSubArrayInRange:asMutable:
_internalDealloc
_processReferenceQueue:
rangeCount
rangeAtIndex:
retainedObjectAtIndex:
indexSet
addIndex:
initWithIndexesInRange:
_turnAllBatchesIntoObjects
sortedArrayUsingFunction:context:
sortedArrayUsingFunction:context:hint:
sortedArrayUsingSelector:
sortedArrayWithOptions:usingComparator:
filteredArrayUsingPredicate:
sortedArrayUsingDescriptors:
initWithPFArray:andRequest:andContext:
isEqualToArray:
_turnAllBatchesIntoFaults
objectsAtIndexes:
_pinnedObjectAtIndex:
_entryFlags
_moc
_request
_batchSize
_LRUBatches
initWithPFBatchFaultingArray:
transaction
_transaction
finalize
_rehash
initWithPFArray:
_editCount
_offset
_limit
_originalArray
_updatedObjectsArray
_indicesVeneer
_replaceObject:atIndex:
_values
_sourceData
isEqualToOrderedSet:
initWithArray:andContext:
_underlyingArray
_weakmoc
_allowAncillaryEntities
_modelsReferenceIDOffset
setSubstitutionVariables:
executeFetchRequest:error:
dictionaryWithCapacity:
stringValue
valueWithBytes:objCType:
value:withObjCType:
autorelease
initWithBytes:objCType:
getValue:
objCType
charValue
unsignedCharValue
shortValue
unsignedShortValue
intValue
unsignedLongValue
longLongValue
unsignedLongLongValue
floatValue
doubleValue
attributeNamed:
predicateString
attribute
parseTriggerPredicateError:
validatePredicate:error:
createSQLStrings:
isManyToMany
isToOne
predicateWithFormat:
validateComparisonPredicate:error:
compoundPredicateType
initWithOperatorType:
symbol
isSupportedOperatorType:
relationshipNamed:
inverseOperatorSymbolForOperator:
_setIsBackedByTrigger:
addKeyForTriggerOnRelationship:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
zone
hash
superclass
debugDescription
initWithObjectFromUserInfo:onAttributeNamed:onEntity:
validate:
isEqualToExtension:
insertSQLStrings
dropSQLStrings
bulkUpdateSQLStrings
toManyDecrementWhenClause
toManyIncrementWhenClause
toManyInnerFetchWhereClause
ofClause
oldMatchingClause
newMatchingClause
columnChangedClause
destinationAttributes
_predicate
_predicateString
_attribute
_destinationEntity
_destinationAttributes
_mToManyInnerFetchWhereClause
_mToManyDecrementWhenClause
_mToManyIncrementWhenClause
_mOfClause
_mOldMatchingClause
_mNewMatchingClause
_mColumnChangedClause
_mSqlDropStrings
_mBulkChangeStrings
_insertSQLStrings
initWithOptions:request:
wipeAllCloudDataAndPurgeHistoryToken:error:
initWithRequest:success:madeChanges:error:changeToken:historyToken:
monitor
retainedMonitoredCoordinator
storeIdentifier
persistentStoreForIdentifier:
defaultCenter
postNotificationName:object:userInfo:
newBackgroundContextForMonitoredCoordinator
setTransactionAuthor:
configurationName
fetchRequestWithEntityName:
initWithFetchRequest:
database
databaseScope
save:
initWithPurgedRecordZoneID:options:request:
doWorkWithCompletion:
purgedRecordZoneID
_purgedRecordZoneID
modelMap
entityCount
_dispose
initWithWeaksReferences:
setForUseWithCoordinator:
getAllObjects:
setCapacityHint:forSlot:
clearTemporaryIDs
_slotLimit
_objectsByTemporaryID
_objectsByPermanentObjectID
_objectsBy64bitPKID
_capacitiesFor64bitPKMappings
_modelMap
getNumActiveProcessors
getProcessorSpeed
getPhysicalMemory
initWithFunction:withArgument:andPriority:
_task
lock
condition
isFinishedFlag
bundleForClass:
mainBundle
bundleWithPath:
localizedStringForKey:value:table:
objectIDFactoryForEntity:
initWithPK64:
initWithBytes:length:
initWithInteger:
_rootEntityGroupsForObjects:passingBlock:
getCString:maxLength:encoding:
processInfo
valueForProcessArgument:
environment
standardUserDefaults
stringForKey:
integerForKey:
boolForKey:
hasExternalReferenceContent
_externalReferenceLocation
_originalData
_safeguardLocation
preferredProtectionLevel
_bytesLengthForExternalReference
getBytes:range:
doCleanupOnDealloc
_safeguardLocationString
initWithContentsOfFile:options:error:
externalReferenceLocationString
fileExistsAtPath:
isFileURL
path
type
bytes
initWithBytesNoCopy:length:encoding:freeWhenDone:
valueTransformerForName:
reverseTransformedValue:
transformedValue:
valueTransformerName
transformDecodeValue:forTransformerNamed:
transformEncodeValue:forTransformerNamed:
initWithOrderedSet:
newCollection:fromCollection:byAddingItems:
_newCollectionFromCollection:forParentContext:andClass:
newOrderedSetFromCollection:byRemovingItems:
newMutableOrderedSetFromCollection:
newOrderedSetFromCollection:byAddingItems:
indexSetWithIndexesInRange:
replaceObjectsAtIndexes:withObjects:
removeObjectsAtIndexes:
insertObjects:atIndexes:
caseInsensitiveCompare:
createDictionaryPartitioningObjectsByRootEntity:
_createDictionaryPartitioningObjects:intoHierarchies:
_createDictionaryPartitioningObjectIDs:intoHierarchies:
isUbiquitousItemAtURL:
getResourceValue:forKey:error:
_generateObjectIDMaptableForArray:withMapping:andEntries:
_newObjectIDsArrayWithMapping:andEntries:andCoordinator:
_frameworkHash
_getPFBundleVersionNumber
_remoteChangeNotificationNameForStore:
_groupObjectsByRootEntity:
_coalescedPrefetchKeypaths:
_generateHashForString:
_getUUID
_doNameAndTypeCheck:
convertCString:toUnsignedInt64:withBase:
attributeClassesForSecureCoding
plistClassesForSecureCoding
stringValueForOverride:
integerValueForOverride:
boolValueForOverride:
writePFExternalReferenceDataToInterimFile:
moveInterimFileToPermanentLocation:
readExternalReferenceDataFromFile:
readBytesForExternalReferenceData:intoBuffer:range:
newMappedDataForExternalReference:
lengthOfFileAtExternalReferenceLocation:
deleteFileForPFExternalReferenceData:
createExternalReferenceLinkFromPath:toPath:protectionLevel:
cleanupExternalReferenceLink:
attemptToUpdatePermissionsForFileAtPath:toLevel:
_isInMemoryStore:
setOrRemoveValue:forKey:inDictionary:
_createNicksBase64EncodedStringFromData:
getIndexes:fromCollection:forObjectsInCollection:
newOrderedSetFromCollection:
anyObjectFromCollection:
newArrayOfObjectIDsFromCollection:
newSetOfObjectIDsFromCollection:
newOrderedSetOfObjectIDsFromCollection:
_objectsInOrderedCollection:formSubstringInOrderedCollection:
newOrderedSetFromCollection:byInsertingItems:atIndex:
newSetFromCollection:byAddingItems:
newMutableSetFromCollection:byRemovingItems:
newMutableSetFromCollection:byIntersectingWithCollection:
newMutableArrayFromCollection:byRemovingItems:
newMutableArrayFromCollection:forParentContext:
newMutableSetFromCollection:forParentContext:
newMutableOrderedSetFromCollection:forParentContext:
_replaceBaseline:inOrderedSet:withOrderedSet:
_expressionIsCompoundIndexCompatible:
fetchHeterogeneousCollectionByObjectIDs:intoContext:
createDictionaryPartitioningObjectsByEntity:
createDictionaryPartitioningObjectsIDByEntity:
createDictionaryPartitioningObjectsIDByRootEntity:
isUbiquitousURLUploaded:error:
isUbiquitousURLDownloaded:error:
isSanitizedVersionOf:equalTo:
sanitize:
weakReferenceWithObject:
object
address
_object
_objectAddress
unlock
tryLock
_lock
_owner
_init__
contentsOfDirectoryAtPath:error:
_deleteIfNecessary:
stringByDeletingLastPathComponent
numberWithInteger:
_doCleanupForDir:exceptURLs:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
registerURLForCleanup:
lastPathComponent
temporaryLinksDirectoryForStore:
doCleanupForURL:
_storeLinksDirs
_filesToCleanUp
appendBytes:length:
getCharacters:
initWithCharactersNoCopy:length:freeWhenDone:
getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
appendData:
initWithBytesNoCopy:length:freeWhenDone:
indexForKey:
_underlyingProperty
keys
_setupForKeys:count:table:inData:
initWithUTF8String:
cStringUsingEncoding:
getCharacters:range:
fastestEncoding
smallestEncoding
_isCString
cString
_fastCStringContents:
_fastCharacterContents
getCString:
cStringLength
_length
bufferOffset
setParentObject:
_parentObject
initWithManagedObject:withRecordName:relatedToRecordWithRecordName:byRelationship:
initWithRecord:andValues:withManagedObjectModel:andType:
mirroredRelationshipWithManyToManyRecord:values:andManagedObjectModel:
orderedRelationshipsForRecordType:andManagedObjectModel:
recordNamesFromManyToManyCKRecordName:
_setManyToManyRecordID:manyToManyRecordType:ckRecordID:relatedCKRecordID:relationshipDescription:inverseRelationshipDescription:type:
compare:options:
sortUsingComparator:
recordTypeToRecordID
manyToManyRecordID
manyToManyRecordType
_type
_relationshipDescription
_inverseRelationshipDescription
_manyToManyRecordID
_manyToManyRecordType
_ckRecordID
_relatedCKRecordID
recordTypesToRecordIDs
relatedObjectRecordID
_objectID
_relatedRecordID
_recordID
initWithPersistentStoreCoordinator:configurationName:URL:options:
_persistentStoreCoordinator
_registerCacheNode:
setWithArray:
_referenceData
setMetadata:
_updatedMetadataWithSeed:includeVersioning:
metadataForPersistentStoreWithURL:error:
load:
addCacheNodes:
cacheNodes
willRemoveCacheNodes:
cacheNodeForObjectID:
newCacheNodeForManagedObject:
updateCacheNode:fromManagedObject:
newReferenceObjectForManagedObject:
objectIDForEntity:referenceObject:
referenceObjectForObjectID:
_rawMetadata__
_nodeCache
_entityCache
_nextReference
_reserved4
_reserved5
_insertNodeIntoMainCache:
_insertNodeIntoEntityCache:
requestType
executeFetchRequest:withContext:
executeSaveChangesRequest:withContext:
executeCountRequest:withContext:
executeRefreshRequest:withContext:
propertiesToGroupBy
_retrieveNodesSatisfyingRequest:
_retrieveNodeForObjectID:
_setHasRetainedStoreResources__:
values
expression
expressionValueWithObject:context:
isCountOnlyRequest
requestExpression
initForKeys:count:
initWithSearchStrategy:
setValues:
fetchOffset
removeObjectsInRange:
numberWithUnsignedLong:
hasChanges
_isMetadataDirty
_getNewIDForObject:
_changeIDsForManagedObjects:toIDs:
_setChangedObjectIDsNotification:
_addObject:
_retrieveNodeForObject:
_removeObject:
_updateObject:
_storeNextReferenceInMetadata
_setMetadataDirty:
arrayWithCapacity:
sortDescriptors
_subentitiesIncludes:
sortUsingDescriptors:
_deleteNodeFromMainCache:
_deleteNodeFromEntityCache:
_versionNumber
_setVersionNumber:
executeRequest:withContext:error:
newValuesForObjectWithID:withContext:error:
newValueForRelationship:forObjectWithID:withContext:error:
_didLoadMetadata
_preflightCrossCheck
managedObjectContextDidRegisterObjectsWithIDs:
managedObjectContextDidUnregisterObjectsWithIDs:
obtainPermanentIDsForObjects:error:
_retainedObjectIDForEntity:referenceObject:
_generateTriggerSQL
initWithEntity:
derivedAttributes
addDerivationKeypath:forAttribute:
triggerSQL
migrationSQL
_derivedAttributes
_triggerSQL
_migrationSQL
setType:
setURL:
numberWithDouble:
sqlitePragmas
configuration
setOption:forMirroringKey:
persistentStoreDescriptionWithURL:
inMemoryPersistentStoreDescription
isReadOnly
setReadOnly:
timeout
setTimeout:
setValue:forPragmaNamed:
shouldAddStoreAsynchronously
setShouldAddStoreAsynchronously:
shouldInvokeCompletionHandlerConcurrently
setShouldInvokeCompletionHandlerConcurrently:
shouldMigrateStoreAutomatically
setShouldMigrateStoreAutomatically:
shouldInferMappingModelAutomatically
setShouldInferMappingModelAutomatically:
mirroringDelegate
usesPersistentHistoryTracking
setUsesPersistentHistoryTracking:
setConfiguration:
_options
_configuration
_url
_propertyNamed:
initWithObjectID:
knownKeyValuesPointer
_snapshot_
propertyCache
setPropertyCache:
__versionNumber
_propertyCache
_reserved1
encodeInt:forKey:
attributeValueClassName
isIndexed
encodeBool:forKey:
_storeBinaryDataExternally
preserveValueOnDeletionInPersistentHistory
encodeInt32:forKey:
numberWithFloat:
decodeIntForKey:
decodeObjectOfClasses:forKey:
_sortOutDefaultNumericValuesBecauseDoublesAndFloatsDontCompareEqualAndThatBreaksTests
initWithInt:
decodeInt32ForKey:
decodeInt64ForKey:
_extraIVars
decodeDoubleForKey:
_isFileBackedFuture
decodeBoolForKey:
setIndexed:
_attributeTypeIsSchemaEqual:
_throwIfNotEditable
stringForAttributeType:
_classNameForType:
setAttributeValueClassName:
_hasMinValueInExtraIvars
_hasMaxValueInExtraIvars
validationPredicates
arrayWithArray:
numberWithLongLong:
predicateWithBlock:
validationWarnings
_preserveValueOnDelete
_setPreserveValueOnDeletionInPersistentHistory:
setAttributeType:
setDefaultValue:
setValueTransformerName:
allowsExternalBinaryDataStorage
setAllowsExternalBinaryDataStorage:
setPreserveValueOnDeletionInPersistentHistory:
preservesValueInHistoryOnDeletion
setPreservesValueInHistoryOnDeletion:
_attributeValueClass
_valueTransformerName
_attributeValueClassName
_defaultValue
_initWithName:
_isTriggerBacked
timeIntervalSinceReferenceDate
_rawValidationPredicates
_rawValidationWarnings
_canConvertPredicate:andWarning:
_comparePredicatesAndWarnings:
_comparePredicatesAndWarningsWithUnoptimizedAttributeDescription:
_createCachesAndOptimizeState
_replaceValidationPredicates:andWarnings:
_nonPredicateValidateValue:forKey:inObject:error:
_generateErrorWithCode:andMessage:forKey:andValue:additionalDetail:
_versionHash:inStyle:
_initWithName:type:withClassName:
_initWithName:type:
initWithDouble:
initWithFloat:
initWithTimeIntervalSinceReferenceDate:
unarchivedObjectOfClasses:fromData:error:
_appendPropertyFieldsToData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:entitiesSlots:
replaceBytesInRange:withBytes:
setIsFileBackedFuture:
_epsilonEquals:rhs:withFlags:
_initWithType:
setStoresBinaryDataExternally:
_writeIntoData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:entitiesSlots:fetchRequests:
initWithProperty:
setExternalType:
setExternalPrecision:
setExternalScale:
externalType
externalPrecision
externalScale
property
externalName
columnDefinition
_externalType
_externalPrecision
_externalScale
_modelsReferenceID
generatedNameSuffix
_retain_1
_release_1
isSubclassOfClass:
initWithUnsignedLongLong:
initWithBytes:length:encoding:
pathComponents
initWithEntity:andUUIDString:
_setPersistentStore:
setObjectStoreIdentifier:
_getURIBytes:length:
_retainedURIString
URLWithString:
automaticallyNotifiesObserversForKey:
classWithStore:andEntity:
allocateBatch:count:
version
managedObjectIDFromUTF8String:length:
managedObjectIDFromURIRepresentation:
_setStoreInfo1:
_storeInfo1
_storeDeallocated
_storeIdentifier
_isPersistentStoreAlive
URIRepresentation
entityForEntityDescription:
_fallbackFactory
_referenceData48_cd_rc16
_initCoreWithTaggedIndex:
_taggedPoolIndex
_fallbackFactories
_storeInfoForEntityDescription:
doURLStuff:createdStubFile:readOnly:error:options:
doFilesystemCleanupOnRemove:
initWithStore:fromPath:
initWithStore:
_setMap:
_theMap
saveToPath:
metadataForPersistentStoreWithURL:options:error:
setMetadata:forPersistentStoreWithURL:options:error:
readMetadataFromFile:securely:error:
fullMetadata
setMetadata:forPersistentStoreWithURL:error:
setFullMetadata:
writeMetadataToFile:error:
_classesForPropertyValues
saveDocumentToPath:
initWithSubresults:
subresults
_subresults
progress
cancel
initWithContext:andProgress:completetionBlock:
_cancelProgress
_isCancelled
setProgress:
operationError
setOperationError:
requestCompletionBlock
setRequestCompletionBlock:
_requestProgress
_requestError
_requestContext
_requestCompletionBlock
initForFetchRequest:withContext:andProgress:completetionBlock:
fetchRequest
finalResult
setFinalResult:
intermediateResultCallback
setIntermediateResultCallback:
_fetchRequest
_finalResult
_intermediateResultCallback
stringByAppendingFormat:
expressionWithFormat:
validateExpression:error:
validateAttribute:
validateKeypath:
reason
isAttribute
isRelationship
generateSQLStrings
keypath
objectFromUserInfo
countedRelationship
_objectFromUserInfo
_keypath
_dropSQLStrings
_bulkUpdateSQLStrings
_countedRelationship
setDatabaseVersion:
setPrimaryKeyGeneration:
setMapData:
subdataWithRange:
setRequiresSecureCoding:
setDecodingFailurePolicy:
error
clearCurrentValues
readBinaryStoreFromData:originalPath:error:
fileHandleForUpdatingAtPath:
readDataOfLength:
seekToFileOffset:
initForWritingWithMutableData:
_writeMetadataData:andMapDataData:toFile:error:
closeFile
fileHandleForReadingAtPath:
databaseVersion
primaryKeyGeneration
writeToFile:options:error:
mapData
readFromFile:error:
writeToFile:error:
_databaseVersion
_fullMetadata
_primaryKeyGeneration
_mapData
_storeOptions
allowedClasses
_propertySearchMapping
fastIndexForKnownKey:
_doAttributeDecoding
dataForKey:
initWithValues:objectID:
attributeValues
_attributes
_attributesAsEncoded
_setMetadata:
fileExistsAtPath:isDirectory:
store
willAccessValueForKey:
_isValidRelationshipDestination__
setDestinations:forRelationship:
_nodeFromObject:objectIDMap:
removeObject:objectIDMap:
addObject:objectIDMap:
destinationsForRelationship:
dataWithCapacity:
initWithStore:fromArchivedData:
_theDictionary
updateObject:objectIDMap:
retainedObjectIDsForRelationship:forObjectID:
handleFetchRequest:
_archivedData
entityForPath:
entityForName:inManagedObjectContext:
_entityClass
allocWithEntity:
initWithEntity:insertIntoManagedObjectContext:
_entityDeallocated
_initializeExtraIVars
isAbstract
encodeConditionalObject:forKey:
superentity
versionHashModifier
_oldCompoundIndexStyleIndexes
initWithPropertyName:collationType:
_setAscending:
_indexElementFromJSONArray:
initWithName:elements:
_setEntity:
_indexDescriptionFromJSONArray:
_addSupplementalIndexes:
_setIndexes:
setWithObjects:
setRenamingIdentifier:
setCompoundIndexes:
_setUniquenessConstraints:
dataWithBytes:length:
JSONObjectWithData:options:error:
_setIndexesFromJSONObject:supplemental:
_setSubentities:preserveIndices:
_setProperties:preserveIndices:
indexes
_uniquenessConstraints
setUniquenessConstraints:
coreSpotlightDisplayNameExpression
setCoreSpotlightDisplayNameExpression:
managedObjectClassName
subentitiesByName
_propertiesMatchingBlock:
_propertiesOfType:
_dropIndexes
getObjects:andKeys:count:
_removeSubentity:
_addSubentity:
_valueCountByEnumeratingWithState:objects:count:
_removeProperty:
_addProperty:
_isFlattened
_MOClassName
_entityForName:
_subentityNamed:
_removeEntity:
_addEntity:
getBytes:length:
properties
sortDescriptorWithKey:ascending:
_versionHashInStyle:
_validateIndexNameChangeFrom:to:
elements
_attributeNamed:
_relationshipNamed:
_validateIndex:
_isMappedSinglePropertyIndex
_propertiesOnlySubsetFromIndexes:
string
lowercaseString
setExpression:
setExpressionResultType:
initWithProperty:collationType:
containsString:
propertyName
collationType
isAscending
initWithPropertyName:property:collationType:ascending:
_hasIndexForProperty:
uniquenessConstraints
_collectSubentities
_checkSelfForNonCascadeNoInverses
_checkForNonCascadeNoInverses
subentities
isKindOfEntity:
setSubentities:
relationshipsWithDestinationEntity:
setProperties:
setManagedObjectClassName:
setAbstract:
_newVersionHashInStyle:
setVersionHashModifier:
setIndexes:
compoundIndexes
_snapshotClass
_versionHashModifier
_versionHash
_model
_classNameForEntity
_instanceClass
_rootentity
_superentity
_subentities
_propertyMapping
_propertyRanges
_entityDescriptionFlags
_extraIvars
_userInfo
_flattenedSubentities
_kvcPropertyAccessors
_modelsReferenceIDForEntity
_keypathsToPrefetchForDeletePropagation
_setSuperentity:
_setEntityAndMaintainIndices:
setElementID:
elementID
keypathsToPrefetchForDeletePropagation
_setIsUnique:
_constraintAsIndex:
isEditable
_keypathsToPrefetchForDeletePropagationPrefixedWith:toDepth:processedEntities:
initWithObjects:forKeys:count:
_propertyKeys:matchingBlock:
maxCount
_relationshipNamesByType:
instanceMethodForSelector:
_isGeneratedClass
classForEntity:
_setIsEditable:
_localPropertyDescriptionNamed:
_localRelationshipNamed:
_flattenProperties
sortUsingFunction:context:
isIndexedBySpotlight
isStoredInExternalRecord
isOrdered
mapping
_isInheritedPropertyNamed:
_setEntitysReferenceID:
_newMappingForPropertiesOfRange:
_commonCachesAndOptimizedState
_removePropertyNamed:
_propertyRangesByType
initWithKey:ascending:selector:
_isOptimizedForEncoding
initWithPropertyDescription:
_setIsFlattened:
_stripForMigration
_restoreValidation
_compoundIndexRepresentation
_isIndexForProperty:
_constraintIsExtension:
_setValues:retain:
setWithObject:
unarchivedObjectOfClass:fromData:error:
initWithName:predicate:elements:entity:
partialIndexPredicate
_hasUniquePropertiesRaw
_addFactoryToRetainList:
_uniquenessConstraintsAsFetchIndexes
_propertyWithRenamingIdentifier:
knownKeysMappingStrategy
_nukeMOClassName__
_keypathsForDeletions
_setManagedObjectModel:
attributeKeys
toManyRelationshipKeys
toOneRelationshipKeys
inverseForRelationshipKey:
_hasCustomPrimitiveProperties
_inheritanceDepth
_hasPotentialHashSkew
_offsetRelationshipIndex:fromSuperEntity:andIsToMany:
_allPropertyNames
_newSnowLeopardStyleDictionaryContainingPropertiesOfType:
_leopardStyleRelationshipsByName
_leopardStyleAttributesByName
_new_implicitlyObservedKeys
_setModelsReferenceID:
_sortedSubentities
_skipValidation
_hasAttributesWithFileBackedFutures
_hasAttributesWithExternalDataReferences
_hasPropertiesIndexedBySpotlight
_hasPropertiesStoredInTruthFile
_addIndexForProperty:
_removeIndexForProperty:
_finalizeIndexes
_isPathologicalForConstraintMerging:
_setValidationRequiredUniquePropertiesUpInheritanceHierachy
_setHasUniqueProperties:
_setHasUniquePropertiesUpInheritanceHierachy
_hasUniqueProperties
_extensionsOfParentConstraint:
_hasUniquedPropertyNamed:
_writeIntoData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:uniquedMappings:entities:
_createValuePrimitiveSetterWithContainerClassID:key:
ivar
method
containerClassID
_createValuePrimitiveGetterWithContainerClassID:key:
_createValueSetterWithContainerClassID:key:
_createValueGetterWithContainerClassID:key:
_initWithSourceEntityDescription:destinationEntityDescription:
sourceEntityVersionHash
destinationEntityVersionHash
sourceExpression
entityMigrationPolicyClassName
initWithData:
setEntityMigrationPolicyClassName:
_reserved
_mappingsByName
_mappingType
_sourceEntityName
_sourceEntityVersionHash
_destinationEntityName
_destinationEntityVersionHash
_sourceExpression
_entityMigrationPolicyClassName
_attributeMappings
_relationshipMappings
_entityMappingFlags
_migrationPolicy
_addAttributeMapping:
_addRelationshipMapping:
_hasInferredMappingNeedingValidation
_changeIsSchemaCompatible
destinationContext
_migrationContext
setCurrentPropertyMapping:
associateSourceInstance:withDestinationInstance:forEntityMapping:
sourceInstancesForEntityMappingNamed:destinationInstances:
destinationEntityForEntityMapping:
orderedSetWithSet:
orderedSetWithArray:
orderedSetWithObject:
mutableSetValueForKey:
beginEntityMapping:manager:error:
createDestinationInstancesForSourceInstance:entityMapping:manager:error:
endInstanceCreationForEntityMapping:manager:error:
createRelationshipsForDestinationInstance:entityMapping:manager:error:
endRelationshipCreationForEntityMapping:manager:error:
performCustomValidationForEntityMapping:manager:error:
endEntityMapping:manager:error:
_nonNilValueOrDefaultValueForAttribute:source:destination:
defaultMappingGenerator
externalNameForEntityName:
initWithExternalName:
setPropertyMappings:
setPrimaryKeys:
setSingleTableEntity:
setSubentityColumn:
setSubentityID:
propertyMappings
primaryKeys
isSingleTableEntity
subentityColumn
subentityID
initWithKey:ascending:
columnDefinitions
constraintDefinitions
primaryKeyColumnDefinitions
attributeColumnDefinitions
foreignKeyColumnDefinitions
foreignKeyConstraintDefinitions
createTableStatement
_propertyMappings
_primaryKeys
_isSingleTableEntity
_subentityColumn
_subentityID
expressionResultType
_reservedtype1_1
_reservedtype1_2
_reservedtype1_3
_reservedtype1_4
_reservedtype1_5
_reservedtype1_6
_reservedtype2_1
_reservedtype2_2
_reservedtype2_3
_expression
_expressionResultType
entitiesForContext:configuration:
createCachesForEntity:forValidator:
registerObject:
validateForSave:
validateCaches
reset
initWithManagedObjectContext:
_addConstraintRoot:forEntity:
registerObjects:
validateForSave
_entities
_cachesByEntity
entities
_disableSQLStatementCaching
initWithKeyPath:
foreignKey
foreignOrderKey
initWithSQLCore:
inverseIsToOnePrefetchRequestForRelationshipNamed:onEntity:
manyToOnePrefetchRequestForRelationshipNamed:onEntity:
manyToManyPrefetchRequestsForRelationshipNamed:onEntity:
_sqlCore
_prefetchRequestsByEntity
_initializeRelationshipCaches
toManyOffsetForProperty:
initWithOptions:andTimestamp:
timestamp
setTimestamp:
incrementRefCount
decrementRefCount
externalReferenceCount
incrementExternalReferenceCount:
copyRelationshipCachesFrom:
releaseRelationshipCaches
updateMissingRelationshipCachesFromOriginal:
relatedObjectIDsForProperty:
timestampForProperty:
setRelatedObjectIDs:forProperty:options:andTimestamp:
ancillaryOrderKeysForProperty:
setAncillaryOrderKeys:forProperty:options:andTimestamp:
_externalReferenceCount
_externalRefFlags
_toManyMap
_birth
initForMessage:store:
message
setError:
_store
_message
_result
initWithNode:
node
_node
ancillaryModelNamespace
entityPath
initWithPersistenceStore:
willFireFault
_disableChangeNotifications
_willChangeValuesForKeys:
lockObjectStore
_parentStore
unlockObjectStore
_didChangeValuesForKeys:
_enableChangeNotifications
didFireFault
awakeFromFetch
_isToManyRelationship
fulfillFault:withContext:forIndex:
predicateWithSubstitutionVariables:
localizedDescription
_newOrderedRelationshipInformationForRelationship:forObjectWithID:withContext:error:
willTurnIntoFault
_setSuppressingChangeNotifications__:
_clearRawPropertiesWithHint:
didTurnIntoFault
fulfillFault:withContext:error:
fulfillFault:withContext:
retainedOrderedFaultInformationForAggregateFaultForObject:andRelationship:withContext:error:
turnObject:intoFaultWithContext:
_fireFirstAndSecondLevelFaultsForObject:withContext:
_isUnprocessedDeletion__
_isPendingDeletion__
context:shouldHandleInaccessibleFault:forObjectID:andTrigger:
shouldHandleInaccessibleFault:forObjectID:triggeredByProperty:
_hasRetainedStoreResources__
_queryGenerationToken__
managedObjectContextDidRegisterObjectsWithIDs:generation:
_setSuppressingKVO__:
_forceRegisterLostFault:
_handleError:withError:
initWithName:
URLsForDirectory:inDomains:
persistentStores
initWithConcurrencyType:
_setPersistentStoreCoordinator:
URLForResource:withExtension:
initWithContentsOfURL:
_newModelForName:
stringByStandardizingPath
initWithManagedObjectModel:
defaultDirectoryURL
persistentStoreDescriptionClass
addPersistentStoreWithDescription:completionHandler:
parentContext
setParentContext:
setPersistentStoreCoordinator:
newBackgroundContext
performBlock:
persistentContainerWithName:
persistentContainerWithName:managedObjectModel:
viewContext
loadPersistentStoresWithCompletionHandler:
performBackgroundTask:
_viewContext
_storeCoordinator
_storeDescriptions
persistentContainerWithPath:managedObjectModel:
cachedModelForPersistentStoreWithURL:options:error:
persistentContainerWithPath:
persistentContainerWithPath:modelNamed:
persistentContainerUsingCachedModelWithPath:
setFetchRequest:
setTransient:
_reserved6
_lazyFetchRequestEntityName
initWithBool:
havingPredicate
allocationType
allocationSize
includesPendingChanges
setAllocationType:
_newValidatedProperties:groupBy:error:
initWithEntityName:
execute:
setAllocationSize:
groupByProperties
setGroupByProperties:
_groupByProperties
_havingPredicate
_additionalPrivateIvars
_valuesToFetch
_sortDescriptors
_fetchLimit
_allocationSize
_relationshipKeyPathsForPrefetching
_isCachingFetchRequest
_setAsyncResultHandle:
_asyncResultHandle
_copyForDirtyContext
_resolveEntityWithContext:
_incrementInUseCounter
stores
_XPCEncodedFlags
_setFlagsFromXPCEncoding:
initWithExpressionType:
initForFetch:context:countOnly:
countForFetchRequest:error:
contextExpression
_expressionWithSubstitutionVariables:
_reserved2
_reserved3
_managedObjectContext
initWithSourceAttributeName:destinationAttributeName:
sourceAttributeName
destinationAttributeName
joinWithSourceAttributeName:destinationAttributeName:
_sourceAttributeName
_destinationAttributeName
numberWithShort:
_makeBranchTableForKeys:count:
_coreCreationForKeys:count:
_coreDealloc:
encodeInt64:forKey:
initForKeys:
_reserved64
_table
_keys
getObjects:andKeys:
initWithDictionary:copyItems:
_recount
initWithArray:forTarget:withReferenceValues:andRange:andCopyItems:
_countByEnumeratingWithState:objects:count:forKeys:
getKeys:
isEqualToDictionary:
setValue:atIndex:
valueAtIndex:
keyEnumerator
_keySearch
_invalidate
nextObject
_target
_list
_referenceItems
_range
newInstanceWithSearchStrategy:inData:
initWithActivityType:forStoreWithPath:
activityType
storePath
_activityType
_storePath
applyToSet:
_diffObject
initWithObject:index:
_setGenericValue:forKey:withIndex:flags:
_genericValueForKey:withIndex:flags:
dateWithTimeIntervalSinceReferenceDate:
_PFPlaceHolderSingleton
willChangeValueForKey:
didChangeValueForKey:
willChange:valuesAtIndexes:forKey:
didChange:valuesAtIndexes:forKey:
alloc_10_4
allocWithZone_10_4:
_queueForDealloc:
substringToIndex:
_descriptionValues
insertObject:
_isPendingUpdate__
_isUnprocessedUpdate__
_transientPropertiesChangesMask__
didAccessValueForKey:
_validateValue:forProperty:andKey:withIndex:error:
isDeleted
_chainNewError:toOriginalErrorDoublePointer:
_validateForSave:
mutableArrayValueForKey:
_genericMutableSetValueForKey:withIndex:flags:
_genericMutableOrderedSetValueForKey:withIndex:flags:
mutableOrderedSetValueForKey:
setValuesForKeysWithDictionary:
_updateToManyRelationship:from:to:with:
_allProperties__
dictionaryWithValuesForKeys:
_originalSnapshot__
_newPersistentPropertiesWithRelationshipFaultsIntact__
_persistentProperties__
raise
_reservedCurrentEventSnapshot
entityForClassName:inContext:
_PFPlaceHolderSingleton_core
contextShouldIgnoreUnmodeledPropertyChanges
_batch_release__
isUpdated
hasFaultForRelationshipNamed:
setObservationInfo:
observationInfo
awakeFromInsert
awakeFromSnapshotEvents:
prepareForDeletion
willSave
didSave
validateValue:forKey:error:
validateForDelete:
validateForInsert:
validateForUpdate:
primitiveValueForKey:
setPrimitiveValue:forKey:
dictionaryWithPropertyValues
committedValuesForKeys:
changedValues
valueForUndefinedKey:
setValue:forUndefinedKey:
setNilValueForKey:
faultingState
changedValuesForCurrentEvent
hasPersistentChangedValues
objectIDsForRelationshipNamed:
_cd_lockingInfo
_cd_stateFlags
_cd_extraFlags
_cd_rawData
_cd_managedObjectContext
_cd_objectID
_cd_extras
_cd_queueReference
willRefresh:
didRefresh:
_lastSnapshot__
_calculateDiffsBetweenOrderedSet:andOrderedSet:
_newPropertiesForRetainedTypes:andCopiedTypes:preserveFaults:
_newPersistentPropertiesForConflictRecordFaultsIntact__
_transientProperties__
initWithIndex:
_implicitObservationInfoForEntity:forResultingClass:
decimalNumberWithString:
_isKindOfEntity:
addObjects:count:
initWithContainer:key:mutableOrderedSet:
initWithContainer:key:mutableOrderedSet:mutationMethods:
_excludeObject:fromPropertyWithKey:andIndex:
_includeObject:intoPropertyWithKey:andIndex:
_maintainInverseRelationship:forProperty:oldDestination:newDestination:
_maintainInverseRelationship:forProperty:forChange:onSet:
_propagateDelete:
_localizationPolicy
localizedEntityNameForEntity:
localizedPropertyNameForProperty:
replaceOccurrencesOfString:withString:options:range:
_generateErrorDetailForKey:withValue:
_substituteEntityAndProperty:inString:
_useFastValidationMethod
_validatePropertiesWithError:
localizedModelStringForKey:
dictionaryWithDictionary:
diffOrderedSets:::::::
removeObjectsInArray:
_genericUpdateFromSnapshot:
initWithSet:
_newSetFromSet:byApplyingDiffs:
_initWithEntity:withID:withHandler:withContext:
wasForgotten
_hasAnyObservers__
_hasPendingChanges
_clearPendingChanges__
_hasUnprocessedChanges__
_clearUnprocessedChanges__
_clearAllChanges__
_isSuppressingChangeNotifications__
_isSuppressingKVO__
_setPendingDeletion__:
_isPendingInsertion__
_setPendingInsertion__:
_setPendingUpdate__:
_setUnprocessedDeletion__:
_isUnprocessedInsertion__
_setUnprocessedInsertion__:
_setUnprocessedUpdate__:
_stateFlags
_setLastSnapshot__:
_nilOutReservedCurrentEventSnapshot__
_changedValuesForCurrentEvent
_versionReference__
_setVersionReference__:
_setObjectID__:
_setOriginalSnapshot__:
_referenceQueue__
_newChangedValuesForRefresh__
_newNestedSaveChangedValuesForParent:
_newSnapshotForUndo__
_newAllPropertiesWithRelationshipFaultsIntact__
_newCommittedSnapshotValues
_changedTransientProperties__
_implicitObservationInfo
_didChangeValue:forRelationship:named:withInverse:
_propagateDelete
_prepropagateDeleteForMerge
_updateFromSnapshot:
_updateFromRefreshSnapshot:includingTransients:
_updateFromUndoSnapshot:
_orderedObjectsAndKeys
_reorderObjectsToLocationsByOrderKey:error:
_orderKeysForRelationshipWithName__:
_updateLocationsOfObjectsToLocationByOrderKey:inRelationshipWithName:error:
postNotificationName:object:
_postStoreRemoteChangeNotificationsForStore:andState:
initForObservationWithName:store:
setStore:
_queue
signatureWithObjCTypes:
_isGeneratedClass_1
_PFMOClassFactoryData
allocBatch:withEntity:count:
allocateBatch:forEntity:count:
_initializeAccessorStubs
_initializePrimitiveAccessorStubs
_isOrdered
_defaultValidation:error:
methodSignatureForSelector:
implementsSelector:
batchAllocateWithEntity:insertIntoManagedObjectContext:count:
_hasOverriddenAwake
resolveClassMethod:
resolveInstanceMethod:
lastIndex
getIndexes:maxCount:inIndexRange:
replaceObjectsInRange:withObjects:count:
numberWithChar:
_setRetainsRegisteredObjects:
shouldDeleteInaccessibleFaults
discardEditing
_forgetObject:propagateToObjectStore:removeFromRegistry:
_resetAllChanges
managedObjectContextDidUnregisterObjectsWithIDs:generation:
_postObjectsDidChangeNotificationWithUserInfo:
_isEnabled
currentQueryGenerationToken
_setQueryGenerationFromToken:error:
assertOnImproperDealloc
_unregisterRunloopObservers
_unregisterForNotifications
_dispose:
callStackSymbols
_dealloc__
_stopObservingUndoManagerNotifications
_startObservingUndoManagerNotifications
_setUndoManager:
_processRecentChanges:
_retainedRegisteredObjects
_persistentStoreForIdentifier:
managedObjectIDForURIRepresentation:error:
_ignoringChangeNotifications
_insertObjectWithGlobalID:globalID:
_registerClearStateWithUndoManager
_establishEventSnapshotsForObject:
_enqueueEndOfEventNotification
_parentObtainPermanentIDsForObjects:context:error:
_retainedCurrentQueryGeneration
unpinnedQueryGenerationToken
_prepareForPushChanges:
_newSaveRequestForCurrentState
models
_hasEntityWithUniquenessConstraints
_doPreSaveConstraintChecksForObjects:error:
_generateOptLockExceptionForConstraintFailure:
_informParentStore:ofInterestInObjects:
setDebugDefault:
mergePolicy
resolveConflicts:error:
_advanceQueryGenerationForSave
_thereIsNoSadnessLikeTheDeathOfOptimism
_didSaveChanges
refreshAllObjects
objectRegisteredForID:
_retainedObjectWithID:
_retainedObjectWithID:error:
stalenessInterval
_setStalenessInterval:
initWithFetchRequest:completionBlock:
_executeAsynchronousFetchRequest:
_attemptCoalesceChangesForFetch
_countWithNoChangesForRequest:error:
_countWithMergedChangesForRequest:possibleChanges:possibleDeletes:error:
_createStoreFetchRequestForFetchRequest:
currentProgress
initWithParent:userInfo:
estimatedResultCount
setTotalUnitCount:
setKind:
completionBlock
setCancellationHandler:
completedUnitCount
setCompletedUnitCount:
propagatesDeletesAtEndOfEvent
setPropagatesDeletesAtEndOfEvent:
processPendingChanges
_committedSnapshotForObject:
_refaultObject:globalID:boolean:
_prepareUnprocessedDeletionAfterRefresh:
undo
redo
_initWithParentObjectStore:
decodeFloatForKey:
setMergePolicy:
encodeFloat:forKey:
_forceRemoveFromDeletedObjects:
_mergeRefreshObject:mergeChanges:withPersistentSnapshot:
_mergeRefreshEpilogueForObject:mergeChanges:
_mergeChangesFromRemoteContextSave:intoContexts:
_mergeChangesFromDidSaveDictionary:usingObjectIDs:
registeredObjects
refreshObject:mergeChanges:
performWithOptions:andBlock:
_registerForNotificationsWithCoordinator:
_setParentContext:
nostoresQueryGenerationToken
_validateQueryGeneration:error:
automaticallyMergesChangesFromParent
setAutomaticallyMergesChangesFromParent:
_changeTrackingToken__
_setAutomaticallyMergesChangesFromParent:
removeObserver:name:object:
_automaticallyMergeChangesFromContextDidSaveNotification:
addObserver:selector:name:object:
mergeChangesFromContextDidSaveNotification:
isEditing
commitEditing
invocationWithMethodSignature:
setSelector:
setArgument:atIndex:
invokeWithTarget:
performSelector:withObject:afterDelay:inModes:
_managedObjectContextEditor:didCommit:contextInfo:
_sendCommitEditingSelectorToTarget:sender:selector:flag:contextInfo:delayed:
commitEditingWithDelegate:didCommitSelector:contextInfo:
__Multithreading_Violation_AllThatIsLeftToUsIsHonor__
mergeChangesFromRemoteContextSave:intoContexts:
setRetainsRegisteredObjects:
retainsRegisteredObjects
setShouldDeleteInaccessibleFaults:
setStalenessInterval:
setUndoManager:
undoManager
assignObject:toPersistentStore:
observeValueForKeyPath:ofObject:change:context:
_youcreatedanNSManagedObjectContextOnthemainthreadandillegallypassedittoabackgroundthread
_checkObjectForExistenceAndCacheRow:
rollback
detectConflictsForObject:
transactionAuthor
setQueryGenerationFromToken:error:
_setChangeTrackingTokenFromToken:error:
changeTrackingToken
queryGenerationToken
objectDidBeginEditing:
objectDidEndEditing:
commitEditingAndReturnError:
_queueOwner
_dispatchQueue
_spinLock
_parentObjectStore
_unprocessedChanges
_unprocessedDeletes
_unprocessedInserts
_insertedObjects
_deletedObjects
_changedObjects
_lockedObjects
_refreshedObjects
_infoByGID
_cachedObsInfoByEntity
_undoTransactionID
_lockCount
_objectStoreLockCount
_fetchTimestamp
_referenceCallbackRegistration
_referenceQueue
_ignoreChangeNotification
_contextLabel
_newUnchangedLockedObjects
initWithInsertedObjects:updatedObjects:deletedObjects:lockedObjects:
_setSecureOperation:
substitutionVariables
_fetchLimitForRequest:
_unlimitRequest:
_registerObject:withID:
_informParentStore:noLongerInterestedInObjects:
_performCoordinatorActionAndWait:
_disposeObjects:count:notifyParent:
_contextDidDealloc
initWithName:object:userInfo:
setGroupsByEvent:
initForContext:
currentQueue
maxConcurrentOperationCount
_clearUnprocessedUpdates
_clearUpdates
_clearUnprocessedInsertions
_clearInsertions
_clearUnprocessedDeletions
_clearDeletions
_clearLockedObjects
_clearRefreshedObjects
isUndoRegistrationEnabled
removeAllActions
_incrementUndoTransactionID
_globalIDForObject:
_clearOriginalSnapshotForObject:
_validateObjects:forOperation:error:exhaustive:forSave:
mergeType
_clearOriginalSnapshotAndInitializeRec:
_postContextDidSaveNotificationWithUserInfo:
_forgetObject:propagateToObjectStore:
_informParentStoreNoLongerInterestedInObjectIDs:generation:
_unsafeName
_unsafeTransactionAuthor
performFetch:error:
_globalIDsForObjects:
_batchRetainedObjects:forCount:withIDs:optionalHandler:withInlineStorage:
_validateDeletesUsingTable:withError:
_validateChangesForSave:
_informParentStoreOfInterestInObjectIDs:generation:
_retainedObjectsFromRemovedStore:
_stopsValidationAfterFirstError
_setStopsValidationAfterFirstError:
_debuggingOnly_localObjectForGlobalID:
_currentEventSnapshotForObject:
_growRegistrationCollectionForEntitySlot:toSize:
_setIsUbiquityImportContext:
_isImportContext
_isPreflightSaveInProgress
_setDisableDiscardEditing:
_isXPCServerContext
_setXPCServerContext:
_disableDiscardEditing
_setPostSaveNotifications:
_postSaveNotifications
_persistentStoreDidUpdateAdditionalRowsWithNewVersions:
_setAllowAncillaryEntities:
objectWillChange:
_undoInsertions:
_registerUndoForOperation:withObjects:withExtraArguments:
_undoDeletionsMovedToUpdates:
registerUndoWithTarget:selector:object:
_createAndPostChangeNotification:deletions:updates:refreshes:deferrals:wasMerge:
_undoDeletions:
_undoUpdates:
groupsByEvent
isUndoing
isRedoing
beginUndoGrouping
_clearChangedThisTransaction:
disableUndoRegistration
enableUndoRegistration
_postRefreshedObjectsNotificationAndClearList
_updateUnprocessedOwnDestinations:
_propagatePendingDeletesAtEndOfEvent:
_processPendingDeletions:withInsertions:withUpdates:withNewlyForgottenList:withRemovedChangedObjects:
_processPendingInsertions:withDeletions:withUpdates:
_processPendingUpdates:
_registerUndoForModifiedObjects:
_registerUndoForInsertedObjects:
_registerUndoForDeletedObjects:withDeletedChanges:
_updateUndoTransactionForThisEvent:withDeletions:withUpdates:
_processRecentlyForgottenObjects:
_postContextDidMergeChangesNotificationWithUserInfo:
_processDeletedObjects:
endUndoGrouping
_processEndOfEventNotification:
_prefetchObjectsForDeletePropagation:
_propagateDeletesUsingTable:
_forceInsertionForObject:
_undoManagerCheckpoint:
_noop:
_processObjectStoreChanges:
_processNotificationQueue
removeAllActionsWithTarget:
_storeConfigurationChanged:
_sendOrEnqueueNotification:selector:
_processChangedStoreConfigurationNotification:
postNotification:
defaultQueue
enqueueNotification:postingStyle:
_registerMutatedObjectIDsNotifications
_objectsChangedInStore:
setShouldRefreshAfterSave:
shouldRefreshAfterSave
setShouldPerformSecureOperation:
shouldPerformSecureOperation
performBlockWithResult:
_setDelegate:
_orderedSetWithResultsFromFetchRequest:
_stopConflictDetectionForObject:
_mergeChangesFromRemoteContextSave:
_queueCount
_signal
_queueBatchForDealloc:
_signalRunloop
_rlObserver
_processing
_copyChildObject:toParentObject:fromChildContext:
_parentObjectsForFetchRequest:inContext:error:
_parentProcessSaveRequest:inContext:error:
initWithOwnedKKsD:andVersion:
_snapshot
_version
_allOrderKeysForDestination:inRelationship:error:
_orderKeysForRelationshipWithName__:onObjectWithID:
_updateLocationsOfObjectsToLocationByOrderKey:inRelationshipWithName:onObjectWithID:error:
_newArchiveForScalarObjectIDs:
unarchivedScalarObjectIDsFromData:withCoordinator:
newStringFrom:usingUnicodeTransforms:
_modelPathsFromBundles:
modelByMergingModels:
fetchRequestTemplatesByName
fetchRequestTemplateForName:
addPolicy:
_setLocalizationPolicy:
_deepCollectEntitiesInArray:entity:
_addEntities:toConfiguration:
setFetchRequestTemplate:forName:
versionIdentifiers
_addVersionIdentifiers:
initWithPath:
fileURLWithPath:isDirectory:
modelByMergingModels:forStoreMetadata:
_modelForVersionHashes:
removeObjectsForKeys:
_initWithEntities:
_initWithContentsOfURL:options:
_setModelsReferenceIDOffset:
setEntities:
setEntities:forConfiguration:
setVersionIdentifiers:
_ensureFullLocalizationDictionaryIsLoaded
localizationDictionary
setLocalizationDictionary:
_entityVersionHashesByNameInStyle:
_isConfiguration:inStyle:compatibleWithStoreMetadata:
mergedModelFromBundles:
mergedModelFromBundles:forStoreMetadata:
configurations
fetchRequestFromTemplateWithName:substitutionVariables:
entityVersionHashesByName
isConfiguration:compatibleWithStoreMetadata:
_dataForOptimization
_optimizationHints
_configurations
_fetchRequestTemplates
_versionIdentifiers
_managedObjectModelFlags
pathExtension
dictionaryWithContentsOfURL:error:
_setIsEditable:optimizationStyle:
_optimizedEncoding:
initWithManagedObjectModel:configurationName:retainHashHack:
archivedDataWithRootObject:requiringSecureCoding:error:
entityNamed:
_odiousHashHack
initWithContentsOfURL:forStoreMetadata:
versionsHashesForModelAtURL:error:
versionHashes:compatibleWithStoreMetadata:
_newModelFromOptimizedEncoding:error:
_updateInverse:
optimizedVersionURL
currentVersionURL
initWithContentsOfOptimizedURL:
initWithContentsOfFile:
bundlePath
pathsForResourcesOfType:inDirectory:
_hasPrecomputedKeyOrder
_traverseTombstonesAndMark:
_markTombstones
_removeEntities:fromConfiguration:
_removeEntityNamed:
initWithLong:
immutableCopy
_precomputedKeysForEntity:
_skipUserInfoTombstones:
_isSkippingUserInfoTombstones
_unmarkTombstones
_configurationsByName
_sortedEntitiesForConfiguration:
_entitiesByVersionHash
_versionIdentifiersAsArray
_debugOptimizedModelLayout
coordinator
entitlements
auditToken
_entitlements
_cache
initForToken:entitlementNames:cache:
cache
initWithConnectionInfo:
setManagedObjectContext:
notificationManager
setNotificationManager:
_info
_manager
initWithCoordinator:
localGenerationForRemoteGeneration:
registerQueryGeneration:forRemoteGeneration:
releaseQueryGenerationForRemoteGeneration:
_coordinator
_prefetchRequestCache
_generationTokenMap
pathForResource:ofType:
dictionaryWithContentsOfFile:
versionInfoDictionary
versionHashInfo
bundle
currentVersion
urlForModelVersionWithName:
URLsForResourcesWithExtension:subdirectory:
modelVersions
_modelForVersionHashes:inStyle:
_bundle
_versionInfoDictionary
getNewIDForObject:
_addObject:objectIDMap:
_removeObject:objectIDMap:
_updateObject:objectIDMap:
save
nextPK64
databaseUUID
_pathFromURI:
_entitiesToFetch
_mappingModelFromBundles:forSourceModel:destinationModel:
_initWithEntityMappings:
dataWithContentsOfURL:
_addEntityMapping:
_newMappingModelFromBundles:forSourceHashes:destinationHashes:
mappingModelFromBundles:forSourceModel:destinationModel:
entityMappingsByName
_entityMappings
_entityMappingsByName
_modelMappingFlags
allBundles
allFrameworks
_isInferredMappingModel
_sourceEntityVersionHashesByName
_destinationEntityVersionHashesByName
isDestination:compatibleDestinationFor:
initWithConstantValue:inScope:context:
entityIDForName:
foreignEntityKey
isRelationship:compatibleWith:
initWithConstantValue:ofType:inScope:context:
generateVariableAlias
expressionForSubquery:usingIteratorVariable:predicate:
initWithExpression:trailingKeypath:inScope:
_subqueryIntermediateForToManyKeypathWithComponents:withFunction:inContext:
_generateSQLForKeypathWithComponents:onSQLEntity:inContext:
_generateSQLForRelationshipUpdate:sourceRelationship:inContext:
_generateSQLForAttributeUpdate:sourceAttribute:inContext:
_generateSQLToUpdateProperty:fromMultiStepKeypathComponents:inContext:
_generateSQLToUpdateProperty:fromSingleStepKeypath:inContext:
_generateSQLForRelationshipUpdate:destination:inContext:
_generateSQLForAttributeUpdate:value:inContext:
_generateSQLForExpression:allowToMany:inContext:
_generateSQLToUpdateProperty:fromKeypath:inContext:
_generateSQLToUpdateProperty:fromSubquery:inContext:
initWithProperties:values:inScope:
isUpdateColumnsScoped
governingAliasForKeypathExpression:
_propertiesToUpdate
_valuesToUpdateTo
initWithServiceName:
initWithMachServiceName:options:
newEndpoint
initWithListenerEndpoint:
debugDefault
setInterruptionHandler:
logMessage:forComponent:
setInvalidationHandler:
handleRequest:reply:
interfaceWithProtocol:
setRemoteObjectInterface:
resume
createConnectionWithOptions:
invalidate
disconnect
synchronousRemoteObjectProxyWithErrorHandler:
classesForErrorArchive
decodeSecureArchivedData:usingDelegate:classes:
sendMessage:store:error:
initForStore:
reconnect
sendMessageWithContext:
recordIDForObjectID:
entityForID:
managedObjectIDForURIRepresentation:
cacheMirroredRelationship:withManagedObjectModel:
mirroredRelationshipForObject:relatedToObject:byRelationship:
mtmKeysForStore:
recordIDsRelatedToRecordID:byRelationshipNamed:inStore:
cacheRecordMetadata:
metadataForObjectWithID:
recordIdsForStore:
objectIDForRecordID:inStore:
_mtmKeyToStoreUUIDToMirroredRelationship
_storeUUIDToMtmKeys
_storeUUIDToRecordIDToRelationshipNameToRelatedRecordIDs
_recordIDToStoreUUIDToMetadata
_objectIDToRecordMetadata
_storeIdentifierToRecordIDs
_recordIDToStoreUUIDToObjectID
_objectIDToRecordID
createRecordZoneID
newObjectIDForEntity:pk:
ownerName
setCkRecordName:
setEntityId:
setEntityPK:
createMapOfMetadataMatchingObjectIDs:inStore:inManagedObjectContext:error:
metadataForRecordIDs:fromStore:inManagedObjectContext:error:
createMapOfMetadataMatchingRecords:andRecordIDs:inStore:withManagedObjectContext:error:
createObjectIDForLinkedRow
safeString:isEqualToString:
safeDictionary:isEqualToDictionary:
_keyForZoneWithID:inDatabase:
_keyForZoneName:owner:databseScope:
_keyForDatabase:
_keyForDatabaseScope:
_setChangeToken:forKey:
updateStoreMetadata:
allDefaultsKeys
cliDescription
hasInitializedZone
setHasInitializedZone:
hasInitializedZoneSubscription
setHasInitializedZoneSubscription:
hasInitializedDatabaseSubscription
setHasInitializedDatabaseSubscription:
ckIdentityRecordName
setCKIdentityRecordName:
hasCheckedCKIdentity
setHasCheckedCKIdentity:
changeTokenForZoneWithID:inDatabase:
changeTokenForZoneWithID:inDatabaseWithScope:
changeTokenForDatabase:
changeTokenForDatabaseScope:
setChangeToken:forZoneWithID:inDatabase:
setChangeToken:forDatabase:
purgeCachedChangeTokens
countChangeTokens
lastHistoryToken
setLastHistoryToken:
loaded
keyToPreviousServerChangeToken
_loaded
_hasChanges
_hasInitializedZone
_hasInitializedZoneSubscription
_hasInitializedDatabaseSubscription
_ckIdentityRecordName
_hasCheckedCKIdentity
_keyToPreviousServerChangeToken
_lastHistoryToken
addOwner:
removeOwner:
removeAllOwners
decrement
_retainCount
_owners
performPrimitiveOperationUsingObject:andObject:
setAutomaticallyPruneTransientRecords:
initWithOptions:
isPrivateTransaction:
author
processTransaction:withContext:
isPrivateTransactionAuthor:
isPrivateContextName:
initWithRecordZone:
instantiateNewAnalyzerContext
createUnvalidatedTriggerForString:onAttribute:
whitespaceAndNewlineCharacterSet
stringByTrimmingCharactersInSet:
newExtensionsForAttribute:error:
replacementObjectForXPCConnection:encoder:object:
requiresSecureCoding
initWithSource:newVersion:oldVersion:snapshot1:snapshot2:snapshot3:
_generationalComponentForStore:
_cachedRowForObjectWithID:generation:
initWithSource:newVersion:oldVersion:cachedSnapshot:persistedSnapshot:
_doCleanupForXPCStore:context:
ancestorSnapshot
sourceObject
objectSnapshot
cachedSnapshot
persistedSnapshot
newVersionNumber
oldVersionNumber
_snapshot1
_snapshot2
_snapshot3
_newVersion
_oldVersion
constraint
databaseObject
conflictingObjects
initWithConstraint:databaseObject:databaseSnapshot:conflictingObjects:conflictingSnapshots:
_isDBConflict
constraintValues
conflictingSnapshots
databaseSnapshot
_constraint
_databaseObject
_databaseSnapshot
_conflictedValues
_conflictingObjects
_conflictingSnapshots
initWithMergeType:
_valuesOnObject:matchAgainstValues:
_mergeToManyUnionRelationshipsForObject:andObject:
_mergeToManyUnionRelationshipsForConstraintConflict:
_mergeToManyRelationshipsForObject:ontoObject:
_mergeToManyRelationshipsForConstraintConflict:withDesignatedOriginal:
_byPropertyObjectTrumpMergeObject:ontoObject:writeAll:
_electPreexistingDesignatedOriginalFrom:
_electNewlyInsertedDesignatedOriginalFrom:
_mergeValuesForObject:ontoObject:
_electDesignatedOriginalForConflict:
_mergeContendersResolveConstraintConflict:withKeeper:
_eliminateContendersResolveConstraintConflict:withKeeper:
_didSomethingElseResolveDBConflict:
_unresolvedObjectsForContextConflict:
_unresolvedConflictFor:
_byPropertyStoreTrumpResolveConstraintConflict:
_byPropertyObjectTrumpResolveConstraintConflict:
_rollbackResolveConstraintConflict:
_overwriteResolveConstraintConflict:
_resolveContextConstraintConflict:
_mergeChangesStoreUpdatesTrumpForObject:withRecord:
_mergeChangesObjectUpdatesTrumpForObject:withRecord:
_clearCachedRowForObjectWithID:generation:
mergeToManyRelationshipForSourceObject:withOldSnapshot:newSnapshot:andAncestor:andLegacyPath:
valueForPropertyDescription:
_mergeDeletionWithStoreChangesForObject:withRecord:
resolveOptimisticLockingVersionConflicts:error:
resolveConstraintConflicts:error:
resolveConstraintConflict:error:
resolveConflict:
errorMergePolicy
mergeByPropertyStoreTrumpMergePolicy
mergeByPropertyObjectTrumpMergePolicy
overwriteMergePolicy
rollbackMergePolicy
initWithType:
setCurrentBaselineKV:
setCurrentKV:
initWithLocalPeerID:storeName:modelVersionHash:andUbiquityRootLocation:
setNumRequiredTransactions:
setStoreSize:
setLogSize:
setLogToStoreSizeRatio:
setMinLogBytes:
stringWithString:
sharedSwitchboard
retainedEntryForStoreName:andLocalPeerID:
privateStore
bytesForFileAtPath:
filePresenter
copyStatusDictionary
ubiquityLocationType
modelVersionHash
numBytes
createSetOfAllPeerIDsInKnowledgeVectors:
transactionNumberForPeerID:
createFullPath
dateWithTimeIntervalSinceNow:
haveEnoughTransactionsToRoll
logsConsumeEnoughDiskSpace
checkPeerReceiptsUnderRootLocation:forAgreementWithLocalPeerID:storeName:modelVersionHash:error:
updateHeuristics
canRollBaseline:
localPeerID
ubiquityRootLocation
numRequiredTransactions
storeSize
logSize
logToStoreSizeRatio
minLogBytes
currentBaselineKV
currentKV
_storeName
_ubiquityRootLocation
_modelVersionHash
_numRequiredTransactions
_storeSize
_logSize
_logToStoreSizeRatio
_minLogBytes
_currentBaselineKV
_currentKV
clearAssociationTables
setCurrentMigrationStep:
_createAssociationsBySource:withDestination:forEntityMapping:
_createAssociationsByDestination:fromSource:forEntityMapping:
initWithMigrationManager:
currentEntityMapping
setCurrentEntityMapping:
currentPropertyMapping
currentMigrationStep
destinationInstancesForEntityMapping:sourceInstance:
sourceInstancesForEntityMapping:destinationInstance:
_bySourceAssociationTable
_byDestinationAssociationTable
_byMappingBySourceAssociationTable
_byMappingByDestinationAssociationTable
_migrationManager
_currentMapping
_currentStep
_currentPropertyMapping
_doCleanupOnFailure:
_beginPowerAssertionNamed:withAssert:
usesStoreSpecificMigrationManager
registeredStoreTypes
isNSValue__
pointerValue
migrationManagerClass
_canMigrateWithMappingModel:
_migrateStoreFromURL:type:options:withMappingModel:toDestinationURL:destinationType:destinationOptions:error:
_endPowerAssertionWithAssert:andApp:
_mappingNamed:
sourceEntityForEntityMapping:
mappingModel
sourceContext
destinationInstancesForEntityMappingNamed:sourceInstances:
destinationInstancesForSourceRelationshipNamed:sourceInstances:
migrationProgress
cancelMigrationWithError:
setUsesStoreSpecificMigrationManager:
_sourceEntitiesByVersionHash
_destinationEntitiesByVersionHash
_sourceManagedObjectContext
_destinationManagedObjectContext
_migrationManagerFlags
_migrationCancellationError
fetchRequestForSourceEntityNamed:predicateString:includesSubentities:
_evaluateSourceExpressionForMapping:entityPolicy:
_performSanityCheckForMapping:fromSourceModel:toDestinationModel:
addPersistentStoreWithType:configuration:URL:options:error:
_copyMetadataFromStore:toStore:migrationManager:
_doFirstPassForMapping:error:
_doSecondPassForMapping:error:
_validateAllObjectsAfterMigration:
_doThirdPassForMapping:error:
removePersistentStore:error:
_performedInPlaceMigration
_setPerformedInPlaceMigration:
fetchRequestForSourceEntityNamed:predicateString:
isWritableFileAtPath:
classForStore:
setIdentifier:
_unload:
willRemoveFromPersistentStoreCoordinator:
didAddToPersistentStoreCoordinator:
loadMetadata:
coreSpotlightExporter
_configurationName
_oidFactories
_defaultFaultHandler
_temporaryIDClass
_coreSpotlightDelegate
faultHandlerClass
_objectIDClass
initForNonGenerationalStore:
identifierIsForNonGenerationalStore:
currentQueryGeneration
_setCoreSpotlightDelegate:
objectIDClassForEntity:
_resetObjectIDFactoriesForStoreUUIDChange
_prepareForExecuteRequest:withContext:error:
_defaultMetadata
_updateMetadata
_setupObserver
supportsConcurrentRequestHandling
supportsGenerationalQuerying
freeQueryGenerationWithIdentifier:
reopenQueryGenerationWithIdentifier:error:
currentChangeToken
ancillaryModels
rowCacheClass
_replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:error:
_destroyPersistentStoreAtURL:options:error:
_rekeyPersistentStoreAtURL:options:withKey:error:
_figureOutWhereExternalReferencesEndedUpRelativeTo:
_createExternalDataDictWithValueCallbacks:
initWithValueCallbacks:preserveToManyRelationships:
_forgetRowForObjectID:
_registerRow:forObjectID:options:
registerRow:forObjectID:options:
rowForObjectID:afterTimestamp:
_registerToMany:withOrderKeys:forSourceObjectID:forProperty:options:andTimestamp:
registerToMany:withOrderKeys:forSourceObjectID:forProperty:options:andTimestamp:
initWithPersistentStore:
growRegistrationCollectionTo:
forgetAllExternalData
decrementRefCountForObjectID:
incrementRefCountForObjectID:
refCountForObjectID:
registerRow:forObjectID:
registerToMany:withOrderKeys:forSourceObjectID:forProperty:andTimestamp:
toManyInformationForSourceObjectID:forProperty:afterTimestamp:
toManyForSourceObjectID:forProperty:afterTimestamp:
ancillaryOrderKeysForSourceObjectID:forProperty:afterTimestamp:
_externalData
_capacity
_externalDataValueCallbacks
_persistentStoreCacheFlags
_registerDefaultStoreClassesAndTypes
_retainedPersistentStores
valueWithPointer:
isReadableFileAtPath:
_storeClassForStoreType:
_classForPersistentStoreAtURL:
metadataForPersistentStoreOfType:URL:options:error:
_metadataForPersistentStoreOfType:URL:options:error:
_setMetadata:forPersistentStoreOfType:URL:options:error:
_routeLightweightBlock:toStore:
_isRegisteredWithUbiquity
unregisterCoordinator:
_hasHistoryTracking:
resetCaches
initWithClientModel:
_checkForPostLionWriter:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
validateManagedObjectModel:forUseWithStoreWithDescription:error:
_attemptRecoveryFromAddPersistentStoreError:withDescription:
persistentStoreCoordinator:didSuccessfullyAddPersistentStore:withDescription:
isMainThread
_doAddPersistentStoreWithDescription:privateCopy:completeOnMainThread:withHandler:
initWithPersistentStoreCoordinator:andStoreOptions:forPersistentStoreOfType:atURL:
validateOptionsWithError:
validateManagedObjectModel:forHistoryTrackingWithOptions:error:
stringByExpandingTildeInPath
_realStoreTypeForStoreWithType:URL:options:error:
ubiquityEnabled
actualStoreFileURL
_checkForSkewedEntityHashes:metadata:
_hasTombstonesInUserInfo:
_checkForTombstoneSkew:metadata:configuration:
setPersistentStoreCoordinator:sourceURL:configuration:metadata:options:
_gatherDataAndPerformMigration:
setStoreWasMigrated:
_addPersistentStore:identifier:
_postStoresChangedNotificationsForStores:changeKey:options:
performCoordinatorPostStoreSetup:error:
_removePersistentStore:
removeUbiquityMetadataFromStore:
_initializePersistentStore
_removePersistentStore:error:
_storeTypeForStore:
_retainedAllMigratedObjectsInStore:toStore:
_destroyPersistentStoreAtURL:withType:options:error:
_replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:
_exceptionNoStoreSaveFailureForError:recommendedFrame:
_coordinator_you_never_successfully_opened_the_database_corrupted:
_coordinator_you_never_successfully_opened_the_database_schema_mismatch:
_coordinator_you_never_successfully_opened_the_database_device_locked:
_coordinator_you_never_successfully_opened_the_database_missing_directory:
_coordinator_you_never_successfully_opened_the_database_no_permission:
_coordinator_you_never_successfully_opened_the_database_cant_open:
_coordinator_you_never_successfully_opened_the_database_disk_full:
_coordinator_you_never_successfully_opened_the_database_io_error:
_coordinator_you_never_successfully_opened_the_database_so_saving_back_to_it_is_kinda_hard:
_storesForRequestRoutingFrom:error:
_routableStoresForContext:fromStores:
_retryHandlerCount
_setRetryHandlerCount:
_introspectLastErrorAndThrow
_coordinator_no_idea_what_kind_of_request_that_was_supposed_to_be
hasHistoryTracking
_checkRequestForStore:withContext:originalRequest:andOptimisticLocking:
_updateSpotlightIndexFromSaveRequest:
_doPreSaveAssignmentsForObjects:intoStores:
_saveRequestForStore:withContext:originalRequest:andOptimisticLocking:
_processStoreResults:forRequest:
_retainedIdentifierFromStores:
_retainedChangeTokenFromStores:
_changedObjectIDsNotification
_routeHeavyweightBlock:
sharedFactory
newMetadataManagedObjectModel
setCacheFilePresenterForUbiquityRoot:
canReadFromUbiquityRootLocation:
ubiquityRootURL
initWithFilePresenter:
removeItemAtURL:error:
moveItemAtURL:toURL:error:
coordinateWritingItemAtURL:options:writingItemAtURL:options:error:byAccessor:
_registerCoreDataStoreClass:forStoreType:
registerStoreClass:forStoreType:
metadataForPersistentStoreOfType:URL:error:
setMetadata:forPersistentStoreOfType:URL:options:error:
setMetadata:forPersistentStoreOfType:URL:error:
removeUbiquitousContentAndPersistentStoreAtURL:options:error:
setMetadata:forPersistentStore:
metadataForPersistentStore:
_removeAllPersistentStores:
persistentStoreForURL:
URLForPersistentStore:
migratePersistentStore:toURL:options:withType:error:
destroyPersistentStoreAtURL:withType:options:error:
replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:
_canRouteToStore:forContext:
_reserved32
_miniLock
_managedObjectModel
_persistentStores
sharedApplication
endBackgroundTask:
removeObjectIdenticalTo:
managedObjectIDFromUTF8String:length:error:
arrayByAddingObject:
_canSaveGraphRootedAtObject:intoStore:withPreviouslyChecked:withAcceptableEntities:
_assignObjects:toStore:
_newObjectGraphStyleRecordForRow:andObject:withContext:
_newConflictRecordForObject:andOriginalRow:withContext:
_conflictsWithRowCacheForObject:withContext:andStore:
lockedObjects
initWithTransactionNumber:andStoreID:
_fetchAllInstancesFromStore:intoContext:underlyingException:
_assignObject:toPersistentStore:forConfiguration:
ubiquityStoreURLForStoreURL:ubiquityIdentityToken:localPeerID:ubiquityName:
findContainerIDForToken:storeName:haveExistingMappings:
createDefaultLocalPeerID
createActualStoreURLForStoreURL:localPeerID:containerIdentifier:andStoreName:
_lastOpenError
_setQosClassOptions:
_qosClassOptions
_storeClassForStoreWithType:URL:options:
_setIsRegisteredWithCloudKit:
_isRegisteredWithCloudKit
_setIsRegisteredWithUbiquity:
ubiquityStoreURLForStoreURL:ubiquityIdentityToken:ubiquityName:
_disconnectAllConnections
_destroyPersistentStoreAtURL:withType:error:
_rekeyPersistentStoreAtURL:type:options:withKey:error:
currentPersistentHistoryTokenFromStores:
initWithCompoundValue:
_reopenQueryGenerationWithIdentifier:inStoreWithIdentifier:error:
_refreshTriggerValues:
_refreshTriggerValuesInStore:error:
dropPersistentHistoryforPersistentStoreWithURL:options:error:
removePersistentHistoryFromPersistentStoreAtURL:options:error:
localizedCaseInsensitiveCompare:
_setXPCBundleIdentifier:
_setXPCProcessName:
_xpcBundleIdentifier
_xpcProcessName
_retainedCurrentChangeTrackingToken
__platformOptions
initWithObject:changeType:
changeType
startIndexPath
finalIndexPath
startSectionInfo
finalSectionInfo
setChangeType:
setStartSectionInfo:
setFinalSectionInfo:
setFinalIndexPath:
setStartIndexPath:
_changeType
_startIndexPath
_finalIndexPath
_startSectionInfo
_finalSectionInfo
mappingsDictForConfigurationWithName:inModel:
setDatabaseUUID:
externalMapping
_cheatAndLookAtCurrentValueOfnextPK64
_storeMetadataForSaving
_databaseUUID
_nextPK64
_mappings
setOptional:
setValidationPredicates:withValidationWarnings:
setIndexedBySpotlight:
setStoredInExternalRecord:
_validationPredicates
_validationWarnings
_propertyDescriptionFlags
_entitysReferenceIDForProperty
_setOrdered:
isSpotlightIndexed
setSpotlightIndexed:
isStoredInTruthFile
setStoredInTruthFile:
isStoredInTruth
setStoredInTruth:
_newValidatedPropertiesToUpdate:error:
_setValidatedPropertiesToUpdate:
batchUpdateRequestWithEntityName:
propertiesToUpdate
setPropertiesToUpdate:
_secureOperation
_columnsToUpdate
initWithResultType:andObject:
_aggregatedResult
_resultType
_initWithDestinationName:valueExpression:
_transformValidations
_valueExpression
_propertyMappingFlags
initWithName:valueExpression:
newRTReeTableNameForAttribute:onEntity:
components
validatePropertyWithDescription:andName:forUseAs:onAttributeNamed:onEntityNamed:error:
userInfoObject
rtreeTableName
latProp
longProp
_userInfoObject
_components
_sqlEntity
_attributeName
_rtreeTableName
_attributeDescription
_latProp
_longProp
externalNameForPropertyName:
setProperty:
_property
setPropertyName:
_propertyName
_prerequisiteTransform
_replaceMissingValueOnly
_validateContainerIdentifier:error:
_validateHistoryTrackingOptions:error:
_validateContainerOptions:error:
_validateAssetThreshold:error:
_validateMemoryThreshold:error:
validateOptions:andStoreOptions:error:
parsedOptions
_parsedOptions
setMaxCount:
setMinCount:
setDestinationEntity:
setDeleteRule:
setInverseRelationship:
setOrdered:
_lazyDestinationEntityName
_inverseRelationship
_lazyInverseRelationshipName
_maxCount
_minCount
_deleteRule
_versionHash:inStyle:proxyContext:
_validateValuesAreOfDestinationEntity:source:
_setLazyDestinationEntityName:
setDestinationEntityExternalName:
setForeignKeys:
setJoins:
destinationEntityExternalName
foreignKeys
joins
joinSemantic
setJoinSemantic:
_destinationEntityExternalName
_foreignKeys
_joins
_joinSemantic
_updatedObjects
_optimisticallyLockedObjects
_mutatedObjectIDsNotification
generateSubqueryVariableAlias
generateTempTableName
_nextTableAlias
_nextVariableAlias
_nextTempTableAlias
_tableBase
_variableBase
ubiquityRootLocationPath
pathByTruncatingBeforeLibraryMobileDocuments:
createRelativePath
removeObserver:
isRootUbiquitous
createFullURL
usesCloudDocsFramework
resourceValuesForKeys:error:
statusDidChange
initWithLocation:
checkFileURLState
logWasImported
logWasScheduled
logImportWasCancelled
logWasExported
encounteredError:
recoveredFromError
isLive
isDownloaded
isDownloading
setIsDownloading:
isUploading
isImported
isExported
isScheduled
isFailed
location
numNotifications
_isLive
_isDeleted
_isDownloaded
_isDownloading
_isUploaded
_isUploading
_isImported
_isScheduled
_isExported
_isFailed
_location
_hash
_numBytes
_numNotifications
initWithEntity:propertyDescription:
_sqlTypeForAttributeType:flags:
_setSQLType:
initForReadOnlyFetching
setAllowAliasing:
triggerKeys
setByAddingObject:
initForReadOnlyFetchWithExpression:
shouldIndex
isDerivedAttribute
isBackedByTrigger
initWithValue:sqlType:attributeDescription:allowCoercion:
setInt64:
setUnsignedInt:
int64
unsignedInt
setSQLType:
hasObjectValue
allowsCoercion
_sqlType
_int64
initWithEntityName:andObjects:
initWithEntityName:andDictionaryBlock:
initWithEntityName:andManagedObjectBlock:
stringForResultType:
objectsToInsert
batchInsertRequestWithEntityName:andObjects:
batchInsertRequestWithEntityName:andDictionaryBlock:
batchInsertRequestWithEntityName:andManagedObjectBlock:
shortStringForResultType:
initWithEntity:andObjects:
initWithEntity:andDictionaryBlock:
initWithEntity:andManagedObjectBlock:
_resolveEntityWithSQLCore:
insertDictionaryBlock
setInsertDictionaryBlock:
insertManagedObjectBlock
setInsertManagedObjectBlock:
setObjectsToInsert:
_objectsToInsert
_insertDictionaryBlock
_insertManagedObjectBlock
machServiceName
initWithMachServiceName:
tearDown
_setUpAsync
newMetadataModel
storeDirectoryPath
checkAndCreateDirectoryAtURL:wipeIfExists:error:
setExportedObject:
handleMessage:reply:
setExportedInterface:
_handleRegistrationMessage:
_handleScheduleMessage:
initWithMessage:success:error:
success
storeFileHandle
verifyFileHandle:matchesPath:error:
createRealPathForPath:error:
bundleIdentifier
storeConfigurationName
setBundleIdentifier:
setStorePath:
storeFileProtectionClass
setFileProtectionType:
setStoreConfigurationName:
scheduledActivities
containerWithIdentifier:
setActivityUUID:
setActivityType:
setRegisteredClient:
date
setScheduledAt:
activityUUID
initWithIdentifier:container:priority:
setAdditionalXPCActivityCriteria:
additionalXPCActivityCriteria
populateFromCriteria:
runActivity:completionHandler:
registerActivityIdentifier:handler:
submitActivity:
registeredClient
fileProtectionType
addObserverForName:object:queue:usingBlock:
finishedActivity:withResult:inManagedObjectContext:
unregisterActivityIdentifier:
xpcActivityCriteria
fileDescriptor
initWithCString:encoding:
listener:shouldAcceptNewConnection:
setUp
initWithListener:configuration:
listener
metadataContainer
initializationGroup
initialized
lastInitializationError
_initialized
_listener
_metadataContainer
_initializationGroup
_lastInitializationError
mappingGenerator
newGeneratedPropertyName:
_setColumnName:
copyValuesForReadOnlyFetch:
allowAliasing
initWithColumnName:sqlType:
roughSizeEstimate
fetchIndex
_setFetchIndex:
_setSlotIfDefault:
cloneForReadOnlyFetching
_columnName
initWithPredicate:inScope:
initWithPredicate:inScope:inContext:
disambiguatingEntity
disambiguationKeypath
disambiguationKeypathHasToMany
_generateMulticlauseStringInContext:
scope
isOrScoped
setDisambiguatingEntity:withKeypath:hasToMany:
_subclauses
_disambiguatingEntity
_disambiguationKeypath
_disambiguationKeypathHasToMany
isTargetColumnsScoped
governingEntityForKeypathExpression:
adapter
sqlTypeForExpressionConstantValue:
_lastScopedItem
isVariableBasedKeypathScopedBySubquery:
propertyAtEndOfKeyPathExpression:
sqlTypeForProperty:
_addBindVarForConstId:ofType:inContext:
isIndexScoped
_addBindVarForConstVal1:inContext:
_constantValue
changedObjectID
tombstone
stringForChangeType:
initWithOriginalChange:
updateWithChange:
originalTransactionNumber
originalChangeType
finalTransactionNumber
finalChangeType
finalHistoryToken
finalChangeAuthor
_originalTransactionNumber
_originalChangeType
_finalTransactionNumber
_finalChangeType
_tombstone
_finalHistoryToken
_finalChangeAuthor
ancillarySQLModels
distantPast
distantFuture
_databaseKeyFromValue:
_newZeroingDataWithBytes:length:
objectIDFactoryForSQLEntity:
readMagicWordFromPath:options:
initWithManagedObjectModel:configurationName:brokenHashVersion:
coloredLoggingDefault
hasAttributesWithFileBackedFutures
hasAttributesWithExternalDataReferences
newMetadataModelForFrameworkVersion:
addManagedObjectModel:
initWithManagedObjectModel:configurationName:
newPersistentHistoryManagedObjectModelForSQLModel:options:
newPersistentHistorySQLModelForSQLModel:options:
newFetchHistoryModelForCoordinator:andOptions:
databaseKeyFromOptionsDictionary:
_ensureDatabaseMatchesModel
isLocalFS
setConnectionsAreLocal:
initWithSQLCore:seedConnection:
sourceEntity
newRenameTableStatementFromManyToMany:toManyToMany:orToRandomSpot:
uniqueNameWithBase:
newCreateTableStatementForManyToMany:
newCopyAndInsertStatementForManyToMany:toManyToMany:intermediateTableName:invertColumns:
newDropTableStatementForTableNamed:
connect
beginTransaction
prepareAndExecuteSQLStatement:
commitTransaction
rollbackTransaction
_checkAndRepairCorrelationTables:storeVersionNumber:usingConnection:
whitespaceCharacterSet
fetchTableCreationSQL
manyToManyRelationships
_dissectCorrelationTableCreationSQL:
_collectSkewedComponents:usingConnection:
_repairDatabaseCorrelationTables:brokenHashModel:storeVersionNumber:recurse:usingConnection:
fetchTableNames
isRootEntity
recreateIndices
_rebuildTriggerSchemaUsingConnection:recomputeValues:error:
copyRawIntegerRowsForSQL:
_hasPersistentHistoryTables
_hasHistoryTransactionStringTable
hasHistoryRows
_hasOldHistoryTrackingTables
_dropOldHistoryTrackingTables
dropHistoryTrackingTables
numberOfTombstones
_maxCountOfTombstonesInModel:
createTablesForEntities:
addTombstoneColumnsForRange:
hasAncillaryEntitiesInHistory
dropHistoryBeforeTransactionID:
hasTransactionStringColumnsInTransactionTable
addTransactionStringColumnsToTransactionTable
hasCachedModelTable
saveCachedModel:
fetchMetadata
saveMetadata:
newSimplePrimaryKeyUpdateStatementForEntity:
_updateToVersion640PrimaryKeyTableUsingStatements:connection:
newComplexPrimaryKeyUpdateStatementForEntity:
_fixPrimaryKeyTableFromEntitiesAndJoinsUsingConnection:
_fixPrimaryKeyTableFromEntitiesUsingConnection:
schemaValidationConnection
canConnect
databaseIsEmpty
hasMetadataTable
_doBasicTableNameCheckUsingConnection:
_checkAndRepairSchemaUsingConnection:
_doUnboundedGrowthCheckAndConstraintUsingConnection:
_cacheModelIfNecessaryUsingConnection:
_checkAndRepairTriggersUsingConnection:
_checkAndRepairHistoryTrackingUsingConnection:
_fixPrimaryKeyTablesUsingConnection:
_setMetadata:clean:
initWithBlock:context:sqlCore:
dispatchRequest:withRetries:
_loadAndSetMetadata
notifyPostName
_clearBinding
disconnectAllConnections
rowCacheForGeneration:
removeRowCacheForGenerationWithIdentifier:
initWithObjectID:context:sqlCore:
initWithObjectID:relationship:context:sqlCore:
_newValuesForRelationship:forObjectWithID:withContext:error:
initWithRequest:context:sqlCore:idSets:columnName:
setPrefetchingSubstitutionVariables:
entityForFetchRequest:
setTransactionInMemorySequence:
transactionInMemorySequence
notificationWithName:object:userInfo:
isDelete
isFetchTransactionForToken
initWithTransactionID:delete:transactionOnly:
entityForObject:
rootEntity
_entityOffset
initForEntitiesAndCounts:context:sqlCore:
_obtainPermanentIDsForObjects:withNotification:error:
processFetchRequest:inContext:
processCountRequest:inContext:
processSaveChanges:forContext:
processRefreshObjects:inContext:
processBatchInsert:inContext:error:
processBatchUpdate:inContext:error:
processBatchDelete:inContext:error:
processChangeRequest:inContext:error:
processCloudKitMirroringRequest:inContext:error:
stringByDeletingPathExtension
_supportDirectoryPath
fetchCachedModel
sanityCheckFileAtURL:options:error:
cachedModelWithError:
initAsQueryGenerationTrackingConnectionForSQLCore:
supportsComplexFeatures
_registerNewQueryGenerationSnapshot:
_initializeQueryGenerationTrackingConnection
remoteStoresDidChange
registerCurrentQueryGenerationWithStore:
currentQueryGenerationIdentifier
initWithValue:store:freeValueOnDealloc:
routeStoreRequest:
isUbiquitized
initForSQLCore:
resetExternalDataReferencesDirectories
_useModel:
setExclusiveLockingMode:
newFetchUUIDSForSubentitiesRootedAt:
dropUbiquityTables
fetchUbiquityKnowledgeVector
updateUbiquityKnowledgeVector:
updateUbiquityKnowledgeForPeerWithID:andTransactionNumber:
replaceUbiquityKnowledgeVector:
allPeerRanges
addPeerRange:
addPeerRangeForPeerID:entityName:rangeStart:rangeEnd:peerRangeStart:peerRangeEnd:
createMapOfEntityNameToPKMaxForEntitiesFromUBRangeTable:
createMapOfEntityNameToPKMaxForEntitiesFromPKTable:
createMapOfEntityNameToPKMaxForEntities:
setUbiquityTableValue:forKey:
ubiquityTableKeysAndValues
ubiquityTableValueForKey:
configureUbiquityMetadataTable
databaseValue
newStatementWithSQLString:
unregisterPersistentStore:inCoordinator:
executeMirroringRequest:error:
generateSQLStatmentForSourcesAndOrderKeysForDestination:inToMany:
generateSQLStatmentForSourcesAndOrderKeysForDestination:inManyToMany:
_forceDisconnectOnError
endFetchAndRecycleStatement:
_isQueryGenerationSupportActive
fetchMaxPrimaryKeyForEntity:
_dropHistoryTables
_dropKnownHistoryTrackingTables
setColoredLoggingDefault:
useConcurrentFetching
bufferedAllocationsOverride
presentedItemURL
presentedItemOperationQueue
relinquishPresentedItemToReader:
relinquishPresentedItemToWriter:
savePresentedItemChangesWithCompletionHandler:
accommodatePresentedItemDeletionWithCompletionHandler:
presentedItemDidMoveToURL:
presentedItemDidChange
presentedItemDidChangeUbiquityAttributes:
presentedItemDidGainVersion:
presentedItemDidLoseVersion:
presentedItemDidResolveConflictVersion:
accommodatePresentedSubitemDeletionAtURL:completionHandler:
presentedSubitemDidAppearAtURL:
presentedSubitemAtURL:didMoveToURL:
presentedSubitemDidChangeAtURL:
presentedSubitemAtURL:didGainVersion:
presentedSubitemAtURL:didLoseVersion:
presentedSubitemAtURL:didResolveConflictVersion:
primaryPresentedItemURL
observedPresentedItemUbiquityAttributes
entityForObjectID:
objectIDFactoryForPersistentHistoryEntity:
_newObjectIDForEntityDescription:pk:
newForeignKeyID:entity:
_postChangeNotificationWithTransactionID:
newObjectIDSetsForToManyPrefetchingRequest:andSourceObjectIDs:orderColumnName:
_newRowDataForXPCFetch:variables:context:error:
externalLocationForFileWithUUID:
safeguardLocationForFileWithUUID:
_updateAutoVacuumMetadataWithValues:
recordRemoteQueryGenerationDidChange
dispatchManager
connectionForMigration
_debugConnection
fileProtectionLevel
isInitialized
_cacheRows:
_uncacheRows:
shouldNotifyFOKChanges
_purgeRowCache
removeUbiquityMetadata
_ubiquityDictionaryForAttribute:onObject:
recomputePrimaryKeyMaxForEntities:
_newReservedKeysForEntities:counts:
_newObjectIDForEntity:referenceData64:
hasAncillaryModels
_setHasAncillaryModels:
dbKey
entitiesToInclude
entitiesToExclude
addTransactionStringName:forPK:
transactionStringPKForName:
_schemaValidationConnection
_dispatchManager
_generationalRowCache
_observer
_sqlCoreStateLock
_fileBackedFuturesPath
_transactionInMemorySequence
_metadataIsClean
_sqlCoreFlags
_queryGenerationTrackingConnection
_ancillaryModels
_ancillarySQLModels
_historyTrackingOptions
_transactionStringPKForName
_dbKey
_remoteStoresDidChange
_remoteNotificationToken
_postRemoteChangeNotificationWithTransactionID:
_retainedBinding
_purgeCaches:
_core
_validateCollationType:forProperty:
_resolveProperty
_validateCollationTypeChangeFrom:to:
setCollationType:
setAscending:
_isUnique
_setUniqueBit:
indexDescription
_setIndexDescription:
_collationType
_indexDescription
_indexElementDescriptionFlags
rtreeIndexes
initForIndexDescription:sqlEntity:
generateTableName:isAncillary:
_generateIndexes
_doPostModelGenerationCleanup
entitySpecificPropertiesPassing:
subhierarchyColumnMatching:
isColumn
columnsToFetch
isVirtual
hasSubentities
_addRootColumnToFetch:
_addColumnToFetch:
_addForeignOrderKeyForToOne:entity:
_modelHasPrecomputedKeyOrder
_recordHasVirtualToOnes
initWithEntity:inverseToMany:
_setInverseRelationship:
_addVirtualToOneForToMany:withInheritedProperty:
_useLeopardStyleHashing
_useSnowLeopardStyleHashing
_precomputedKeyOrderForEntity:
_setInverseManyToMany:
addDerivedAttribute:
_generateProperties
setSuperentity:
_addIndexedEntity:
_generateIDWithSuperEntity:nextID:
multicolumnUniquenessConstraints
setConstrained:
uniqueProperties
containsIndex:
addIndexes:
_collectFKSlots:error:
_isValidFunctionForDerivations:
derivedAttributesExtension
setEntityForReadOnlyFetch:
_isBinary
binaryIndexForIndexDescription:
rtreeIndexForIndexDescription:
initWithModel:entityDescription:
tempTableName
toManyRelationships
entitySpecificProperties
entitySpecificRelationships
entitySpecificAttributes
fetchIndexForKey:
columnsToCreate
virtualForeignKeyColumns
setEntityID:
isKindOfSQLEntity:
_sqlPropertyWithRenamingIdentifier:
_generateInverseRelationshipsAndMore
_organizeConstraints
_generateMulticolumnUniquenessConstraints
addUniquedProperty:
_entityIsBroken:
_generateAttributeDerivations:
_toOneRange
addPropertiesForReadOnlyFetch:keys:context:
propertyMapping
indexForIndexDescription:
_entityDescription
_propertyAllCache
_propertiesAllToManysCache
_propertyManyToManyCache
_columnsToFetch
_ekColumns
_fkColumns
_fokColumns
_attrColumns
_virtualFKs
_primaryKey
_entityKey
_optLockKey
_mappingGenerator
_entityID
_subentityMaxID
_uniqueProperties
_multicolumnUniquenessConstraints
_fetch_entity_plan
_rtreeIndices
_odiousHashHackStorage
_derivedAttributeExtension
_sqlentityFlags
attributes
typeNum
setTypeNum:
changeTypeNum
setChangeTypeNum:
addAttributes:toPropertiesOfEntity:
addRelationships:toPropertiesOfEntity:
cloudKitMetadataTransformerName
_allowToMany
setLimitIntermediate:
selectIntermediate
setFetchColumns:
setUseDistinct:
setIsCount:
isFunctionScoped
setJoinType:
whereIntermediate
_promoteJoinsForSubqueryScopedKeypaths
correlationToken
orderIntermediate
_generateJoinSQLStringInContext:
limitIntermediate
fetchIntermediateForKeypathExpression:
fetchIntermediate
isDictionaryCountFetch
setDictionaryCountFetch:
setSelectIntermediate:
groupByIntermediate
setGroupByIntermediate:
addGroupByKeypath:
groupByClauseContainsKeypath:
havingIntermediate
setHavingIntermediate:
setOffsetIntermediate:
addJoinIntermediate:atKeypathWithComponents:
finalJoinForKeypathWithComponents:
promoteToOuterJoinsAlongKeypathWithComponents:
promoteToOuterJoinAtKeypathWithComponents:
joinIntermediates
selectDistinct
_selectClause
_groupByClause
_havingClause
_offsetClause
_groupByKeypaths
_isDictionaryCountFetch
_joinIntermediates
_joinKeypaths
initWithZone:database:options:
setPerOperationObjectThreshold:
setPerOperationBytesThreshold:
mirroringDelegateOptions
perOperationBytesThreshold
perOperationObjectThreshold
_database
_mirroringDelegateOptions
_perOperationBytesThreshold
_perOperationObjectThreshold
uppercaseString
_setName:
initWithEntity:foreignKey:
initForReadOnlyFetchingOfEntity:toOneRelationship:
setFKForReadOnlyFetch:
_foreignKey
initWithEntity:toOneRelationship:
_toOne
_identifier
_addBindVarForConstVal2:inContext:
initWithConstantValue:inScope:
max:
min:
average:
isUpdateScoped
_generateUncorrelatedSubqueryStringWithSymbol:forAttribute:inContext:
_generateCorrelatedSubqueryStringWithSymbol:forExpression:inContext:
_generateArgumentStringForCollection:inContext:
_generateSQLForSubqueryExpression:trailingKeypath:inContext:
_functionExpressionIsSubqueryFollowedByKeypath:
onlyFetchesAggregates
_generateSelectForAggregateStringWithSymbol:argument:inContext:
isHavingScoped
function
generateType1SQLString:inContext:
generateType2SQLString:inContext:
onesComplement:
generateType3SQLString:keypathOnly:inContext:
abs:
noindex:
_generateType4SQLForSymbol:inContext:
_generateSQLForCountInContext:
add:to:
_generateMathStringWithSymbol:inContext:
from:subtract:
multiply:by:
divide:by:
modulus:by:
bitwiseAnd:with:
bitwiseOr:with:
leftshift:by:
rightshift:by:
distinct:
_generateDistinctStringInContext:
_generateNowStringInContext:
length:
_generateLengthStringInContext:
indexed:by:
_generateRtreeIndexStringInContext:
functionIsAcceptableAsAggregate:
_knownPrimaryKeyForObjectID:
_knownEntityKeyForObjectID:
_hasOrderKeys
numberWithLong:
_populateOrderKeysUsingSnapshot:orderKeys:newIndexes:reorderedIndexes:
_populateOrderKeysInOrderedSet:usingSourceObjectID:inverseRelationship:newIndexes:reorderedIndexes:
_orderKeyForObject:
_orderKeyForObject:fromSourceObjectID:inverseRelationship:inOrderedSet:
initWithArray:range:copyItems:
inverseToOne
_updateOrderKeysFromOrderOfObjectIDs:
createNestedObjectFaultContextForObjectWithID:
setForeignOrderKeySlot:orderKey:
_registerChangedFOKs:deletions:forSourceObject:andRelationship:
setForeignKeySlot:int64:
initForRelationship:
_newOrderKeys
_newRowCacheRowForToManyUpdatesForRelationship:rowCacheOriginal:originalOrderKeys:originalSnapshot:value:added:deleted:sourceRowPK:properties:sourceObject:newIndexes:reorderedIndexes:
_findOrCreateChangeSnapshotForGlobalID:
isMaster
_correlationTableUpdateTrackerForRelationship:
trackInserts:deletes:reorders:forObjectWithID:
trackReorders:forObjectWithID:
_fileURLForSaving
_knownPrimaryKeyForObject:
_knownEntityKeyForObject:
setForeignEntityKeySlot:entityKey:
_knownOrderKeyForObject:from:inverseToMany:
_addFileBackedFutureToDelete:
_addExternalReferenceDataToDelete:
_createdByUbiquityImport
_isCloudKitSupportOriginated
_addFileBackedFutureToCopy:
fileSize
initWithURL:UUID:size:
initWithDirectoryURL:UUID:originalURL:
isEqualToData:
initForExternalLocation:safeguardLocation:data:protectionLevel:
_addExternalReferenceDataToSave:
_recordToManyChangesForObject:inRow:usingTimestamp:inserted:
allocForSQLEntity:
initWithSQLEntity:objectID:
_entityForObject:
_prepareForDeletionOfDatabaseExternalPropertiesForObject:
_populateRow:fromObject:timestamp:inserted:
_prepareForDeletionOfExternalDataReferencesForObject:
_prepareForDeletionOfFileBackedFuturesForObject:
_createCorrelationTrackerUpdatesForDeletedObject:
_createRowsForSave
_computeUpdatedRowSplit
saveRequest
savingContext
newObjectsForFastLockConflictDetection
newObjectsForExhaustiveLockConflictDetection
newObjectsForUniquenessConflictDetectionGivenReportedFailures:
newRowsToRemoveFromRowCache
newRowsToAddToRowCache
newPrimaryRowsUpdatedForRowCache
newAncillaryRowsUpdatedForRowCache
newCorrelationTableUpdates
toManyRelationshipChanges
foreignOrderKeysBeingUpdated
foreignOrderKeysBeingDeleted
externalDataReferencesToSave
externalDataReferencesToDelete
fileBackedFuturesToCopy
fileBackedFuturesToDelete
_changeCache
_insertCache
_toManyCache
_rowsToDelete
_updatedByRequest
_updatedByForeignKey
_updatedFOKRowsInCurrentSave
_deletedFOKRowsInCurrentSave
_externalDataReferencesToSave
_externalDataReferencesToDelete
_fileBackedFuturesToCopy
_fileBackedFuturesToDelete
_toManyRelationshipChanges
initFileURLWithPath:
fetchMirroredRelationshipsMatchingPredicate:fromStore:inManagedObjectContext:error:
fetchMirroredRelationshipsMatchingRelatingRecords:andRelatingRecordIDs:fromStore:inManagedObjectContext:error:
addObjectID:toCache:andRecordID:
fetchUnfinishedImportOperationsInStore:withManagedObjectContext:error:
initWithZoneName:ownerName:
pendingRelationships
addUnresolvedRecordID:forRecordType:toCache:
initWithManagedObject:andRecordMetadata:
addObjectID:toCache:forRecordWithType:andUniqueIdentifier:
insertedObject
recordMetadata
importOperations
_updatedRecords
_deletedRecordTypeToRecordID
_deletedObjectIDs
_modifiedRecords
_updatedRelationships
_deletedRelationships
_deletedMirroredRelationshipRecordIDs
_recordTypeToRecordIDToObjectID
_recordTypeToUnresolvedRecordIDs
_metadatasToLink
_importOperations
_invalidatedPendingRelationships
_pendingRelationshipsToTry
_recordMetadata
_insertedObject
initWithUnsignedInt:
_predicateRestrictingSuperentitiesForEntity:
_predicateRestrictingToSubentitiesForEntity:
andPredicateWithSubpredicates:
_predicateForSpecificEntity:
governingAlias
initWithEntity:alias:fetchColumns:inScope:
setWhereIntermediate:
initWithSortDescriptors:inScope:
setOrderIntermediate:
initWithLimit:inScope:
initWithOffset:inScope:
initWithProperties:inScope:
allModifierPredicates
initWithEntity:alias:inScope:
generateWhereIntermediatesInContext:
generateGroupByIntermediatesForProperties:inContext:
generateHavingIntermediateForPredicate:inContext:
generateSelectIntermediateInContext:
generateOrderIntermediateInContext:
generateIntermediateForLimit:inContext:
generateIntermediateForOffset:inContext:
initWithFetchIntermediate:inScope:
setUpdateColumnsIntermediate:
initWithEntity:inScope:
generateUpdateColumnsIntermediateInContext:
updateColumnsIntermediate
predicateForRequestInContext:
initializeContextForRequest:ignoreInheritance:nestingLevel:
prefetchingSubstitutionVariables
initializeContextForFetchRequest:ignoreInheritance:nestingLevel:nestIsWhereScoped:requestContext:
initializeContextForUpdateRequest:
newStatementWithEntity:
setImpossibleCondition:
setSQLString:
generateIntermediatesForFetchInContext:countOnly:
generateIntermediatesForUpdateInContext:
setBindIntarrays:
setBindVariables:
cacheFakeEntityForFetch:
setCachedStatementInfo:
newSQLStatementForRequest:ignoreInheritance:countOnly:nestingLevel:nestIsWhereScoped:requestContext:
initializeContextForIndexGeneration:inStore:
initForIndex:withScope:
newSQLStatementForFetchRequest:ignoreInheritance:countOnly:nestingLevel:nestIsWhereScoped:requestContext:
newSQLStatementForUpdateRequest:
newSQLStatementForChangeRequest:
newSQLStatmentForBinaryIndex:inStore:
_persistentStore
_setInvalidated
_setInterrupted
fileHandleForWritingToURL:error:
initWithFileHandle:forStoreWithDescription:andBundleIdentifier:
_valid
registerClientStore:withMirroringOptions:error:
scheduleBackupTaskForClientStore:error:
interrupted
invalidated
_interrupted
_invalidated
initWithURI:
newUserInfoFromException:
archiver:willEncodeObject:
_isOnExtendedTimeout
sendMessage:fromContext:interrupts:error:
remoteStoreChangedNotificationName
setupRemoteStoreObserver
_setMetadata:includeVersioning:
propertyListWithData:options:format:error:
_sanityCheckToken
_setSanityCheckToken:
initWithValue:store:
newSecureArchivedDataWithRootObject:
_freeQueryGenerationWithIdentifier:
_decodeResultSetData:forFetchRequest:options:store:context:rowCacheRows:error:
_decodeBufferResultSetData:forFetchRequest:options:store:context:rowCacheRows:error:
cacheFetchedRows:forManagedObjects:generation:
decodePrefetchArray:forSources:context:
encodeForXPC
decodeResults:forFetch:context:error:
changeCache
rowsToDelete
newEncodedSaveRequest
setInterrupts:
_commitChangesForRequestContext:
initForStore:request:metadata:forceInsertsToUpdates:context:
_executeSaveRequestForContext:error:
interrupts
initWithResultType:andResult:
executeSaveRequest:withContext:error:
executeFetchRequest:withContext:error:
executeBatchInsertRequest:withContext:error:
executeBatchUpdateRequest:withContext:error:
executeBatchDeleteRequest:withContext:error:
executePersistentHistoryRequest:withContext:error:
initWithObjectID:withValues:version:
classesForSaveArchive
_createAndCacheRowForObjectWithID:propertyValues:inContext:error:
decodeResults:forFaultOfObjectWithID:context:error:
decodeValue:forRelationship:onSource:inContext:error:
cacheContents:ofRelationship:onObjectWithID:generation:
unarchiver:didDecodeObject:
serviceName
_metadata
_connectionManager
_remoteStoreChangedNotificationName
_stateLock
cacheContents:ofRelationship:onObjectWithID:withTimestamp:generation:
decodePrefetchResult:forSources:context:
initWithObjectID:fromSQLRow:
setSQLCore:
_cachedRowForRelationship:onObjectWithID:generation:
connectionManager
isWhereScoped
isIndexExpressionScoped
expressionIsBasicKeypath:
governingEntity
_entitySpecificationKeypath
_setEntitySpecificationKeypath:
_promoteJoinsForSubqueryScopedKeypath:
promoteJoinsInKeypathsForExpression:
_promoteJoinsForKeypathExpression:
_promoteJoinsForFunctionExpression:
_promoteJoinsForAggregateExpression:
_promoteJoinsForTernaryExpression:
_generateSQLForKeyPathExpression:allowToMany:inContext:
_generateSQLForConstantCollection:reboundFrom:inContext:
_generateSQLForVariableExpression:allowToMany:inContext:
_canDoASubselectForExpression:inContext:
bindVariables
_generateSQLForFunctionExpression:allowToMany:inContext:
_generateSQLForExpressionCollection:allowToMany:inContext:
_generateSQLForFetchExpression:allowToMany:inContext:
_generateSQLForTernaryExpression:allowToMany:inContext:
isSimpleNoIndexFunction:
_scope
isPrimaryKey
newGeneratorWithStatement:
_statementForFetchRequestContext:ignoreInheritance:countOnly:nestingLevel:
newStatementWithoutEntity
generateBatchDeleteUpdateHistoryStatementEntity:andRelationship:useInverse:
generateBatchDeleteUpdateHistoryStatementEntity:andRelationship:
typeStringForColumn:
isUnique
_generateFragmentsForEntity:inArray:
columnSQLType
typeStringForSQLType:
orderColumnSQLType
newCreateIndexStatementForColumnWithName:inTableWithName:
generateStatementsForStore:
newCreateIndexStatementForColumn:
newCreateIndexStatementForCorrelationTable:
generateBinaryIndexStatementsForIndex:onEntity:
generateRTreeIndexStatementsForIndex:onEntity:
newCreateIndexStatementsForEntity:defaultIndicesOnly:
createSQLStatementsForTriggerAttribute:withSQLEntity:
createSQLStatementsForRTreeTriggersForLocationAttribute:withSQLEntity:existingRtreeTables:
generateCorrelationTableTriggerStatementsForRelationship:existing:correlationTableTriggers:error:
generateTriggerForEntity:alreadyCreated:correlations:batchHistory:fragments:error:
generateBatchDeleteUpdateHistoryTriggerForEntity:andRelationship:batchHistory:error:
_tombstonesColumnsForEntity:
createCleanupSQLForRelationship:existing:correlationTableTriggers:batchHistory:error:
generateTriggerStatementsForEntity:usingRelationshipCleanupSQL:error:
ancillaryEntityOffset
generateDeleteHistoryTriggerForEntity:error:
setTempTableName:
fetchRequestForObjectsToDelete
affectedObjectIDs
newSelectStatementWithFetchRequest:ignoreInheritance:
stringByReplacingCharactersInRange:withString:
isImpossibleCondition
setTrackChangedRowCount:
bindIntarrays
_cachedTriggersForEntity:
storeIsInMemory
_generateExternalDataRefStatementsForEntities:inRequestContext:
setExernalDataReferenceStatements:
_cacheTriggers:forEntity:
generateSubselectForColumn:givenObjects:
generateStatementForCheckingUniquePropertiesOnObjects:usingSQLCore:
generateStatementForCheckingMulticolumnConstraint:onObjects:usingSQLCore:
sqliteVersion
newInsertStatementWithRow:
newUpdateStatementWithRow:originalRow:withMask:
newConstrainedValuesUpdateStatementWithRow:
newDeleteStatementWithRow:
newSelectStatementWithFetchRequestContext:ignoreInheritance:
newCountStatementWithFetchRequestContext:
newCorrelationInsertStatementForRelationship:
newCorrelationDeleteStatementForRelationship:
newCorrelationMasterReorderStatementForRelationship:
newCorrelationMasterReorderStatementPart2ForRelationship:
newCorrelationReorderStatementForRelationship:
newCreateTableStatementForEntity:
newCreateTempTableStatementForEntity:withAttributesToConstrain:
newCreatePrimaryKeyTableStatement
newPrimaryKeyInitializeStatementForEntity:withInitialMaxPK:
newDropTableStatementOrFailForTableNamed:
newRenameTableStatementFrom:to:
newCreateIndexStatementForColumns:name:
newCreateIndexStatementsForEntity:
newCreateTriggersForEntity:existingRtreeTables:
generateDeleteStatementsForRequest:error:
_cachedDeleteTriggersByEntity
initWithSnapshot:
incrementExternalReferenceCount
decrementExternalReferenceCount
_externalReferences
_ensureWalFileExists
_performPostSaveTasks:andForceFullVacuum:
beginReadTransaction
_currentQueryGenerationSnapshot:
releaseSQLStatement
clearCachedStatements
_ensureNoStatementPrepared
_ensureNoFetchInProgress
_ensureDatabaseOpen
_fetchMaxPrimaryKeyForEntity:
isOpen
openAtPath:withKey:handle:flags:module:checkpointOnClose:
createTableForEntity:
createManyToManyTablesForEntity:
createIndexesForEntity:
createTriggersForEntities:
_executeSQLString:
performIntegrityCheck
setDictionary:
query
_databaseOpenURLStringForURL:
_registerExtraFunctions
_restoreBusyTimeOutSettings
_configureSynchronousMode
_configureIntegrityCheck
createSchema
_configurePragmaOptions:createdSchema:
forceTransactionClosed
_clearTransactionCaches
_clearCachedStatements
_finalizeStatement
hasOpenTransaction
_ensureNoTransactionOpen
prepareSQLStatement:
cacheCurrentDBStatementOn:
resetSQLStatement
transactionDidBegin
_setupVacuumIfNecessary
transactionDidCommit
transactionDidRollback
statementCacheForEntity:
insertStatement
setCachedSQLiteStatement:forConnection:
cacheInsertStatement:
addVMCachedStatement:
_bindVariablesWithInsertedRow:
execute
_clearBindVariablesForInsertedRow
_rowsChangedByLastExecute
debugLogLevel
newUpdateMaskFrom:
cachedUpdateStatementForEntity:andDeltasMask:
cacheUpdateStatement:forEntity:andDeltasMask:
_bindVariablesWithUpdatedRow:andOriginalRow:forDeltasMask:
_clearBindVariablesForUpdateStatement:forDeltasMask:
newUpdateMaskWithChangedConstraintsFrom:
_dataMaskForEntity:andDeltaMask:
cachedUpdateConstrainedValuesStatmentForEntity:
cacheUpdateConstrainedValuesStatement:forEntity:
_bindVariablesForConstrainedValuesWithRow:
_clearBindVariablesForConstrainedValuesUpdateStatement:
deletionStatement
cacheDeletionStatement:
_bindVariablesWithDeletedRow:
hasInserts
correlationInsertStatementForRelationship:
cacheCorrelationInsertStatement:forRelationship:
executeCorrelationChangesForValue1:value2:value3:value4:
enumerateInsertsUsingBlock:
hasDeletes
correlationDeleteStatementForRelationship:
cacheCorrelationDeleteStatement:forRelationship:
enumerateDeletesUsingBlock:
hasMasterReorders
correlationMasterReorderStatementForRelationship:
cacheCorrelationMasterReorderStatement:forRelationship:
enumerateMasterReordersUsingBlock:
correlationMasterReorderStatementPart2ForRelationship:
enumerateMasterReordersPart2UsingBlock:
hasReorders
correlationReorderStatementForRelationship:
cacheCorrelationReorderStatement:forRelationship:
enumerateReordersUsingBlock:
writeCorrelationInsertsFromTracker:
writeCorrelationDeletesFromTracker:
writeCorrelationMasterReordersFromTracker:
writeCorrelationReordersFromTracker:
bindTempTableForBindIntarray:
bindTempTablesForStatementIfNecessary:
_endFetch
isFetchInProgress
setIntarrayTableName:
setIntarrayTable:
intarrayTable
sqlStatement
rangeValue
_bytesPtrForStore
_bytesLengthForStore
getUUIDBytes:
setColumnsToFetch:
_clearOtherStatements
_countOfVMCachedStatements
_clearSaveGeneratedCachedStatements
initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:
stringWithFileSystemRepresentation:length:
ubiquitousExternalReferenceLocationForUUID:inStore:
initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:ubiquitousLocation:
initWithUUIDBytes:
valueWithRange:
_newValueForColumn:atIndex:inStatement:
handleCorruptedDB:
newFetchedArray
fetchCreationSQLForType:
_hasTableWithName:isTemp:
createMetadata
dataWithPropertyList:format:options:error:
metadataColumns
_hasTableWithName:
_decompressedModelWithData:
createCachedModelTable
_compressedDataWithModel:
_configurePageSize
_configureAutoVacuum
willCreateSchema
didCreateSchema
createPrimaryKeyTableForModel:knownEmpty:
_getCurrentAutoVacuumValue
isEqualToNumber:
rangeStart
rangeEnd
peerStart
peerEnd
initWithOwningPeerID:entityName:rangeStart:rangeEnd:peerStart:peerEnd:
initWithLongLong:
_tableHasRows:
processRelationshipUpdatesForRequestContext:
_insertTransactionStringsForRequestContext:
_insertTransactionForRequestContext:andStrings:
insertChanges:type:transactionID:context:
setTransactionID:
enumerateInsertsOIDsUsingBlock:
enumerateReordersOIDsUsingBlock:
enumerateMasterReordersOIDsUsingBlock:
enumerateDeletesOIDsUsingBlock:
_propertyDataForEntity:withSetOfPropertyNames:
insertUpdates:transactionID:updatedAttributes:
_hasOldHistoryTrackingTablesV0
_hasOldHistoryTrackingTablesV1
_dropOldHistoryTrackingTablesV0
_dropOldHistoryTrackingTablesV1
_hasTempTableWithName:
insertBatchDeleteChangesForTransactionID:
exernalDataReferenceStatements
setExternalDataReferencesToDelete:
setFileBackedFuturesToDelete:
generatePrimaryKeysForEntity:batch:
prepareInsertStatementForAncillaryEntity:
_lastInsertRowID
transactionStringForName:
dateWithTimeIntervalSince1970:
insertDictionaryBlock:forEntity:
_batchInsertThrowWithErrorCode:andMessage:forKey:andValue:additionalDetail:
prepareInsertStatementForEntity:
_validateProperty:withValue:
rowsChangedByLastStatement
_useContextObjects
_tombstonesForEntity:
_countOfRowsInTable:
_adoptQueryGenerationWithSnapshot:
registerCurrentQueryGenerationWithStore:retries:
indexOfObjectPassingTest:
_setDebugFlags:
__INode_Changed_AllThatIsLeftToUsIsHonor__
_isQueryGenerationTrackingConnection
isWriter
setIsWriter:
insertRow:
prefetchRequestCache
clearPrefetchRequestCache
updateRow:forRequestContext:
updateConstrainedValuesForRow:
deleteRow:forRequestContext:
uncacheVMStatement:
writeCorrelationChangesFromTracker:
selectRowsWithStatement:cached:
selectCountWithStatement:
fetchResultSet:usingFetchPlan:
fetchBufferResultSet:usingFetchPlan:
setSecureDeleteMode:
_vmstatement
fetchIndexCreationSQL
hasPrimaryKeyTable
_buffersForRegisteredFunctions
logQueryPlanForStatement:
processSaveRequest:
processInsertRequest:withOIDs:
processUpdateRequest:withOIDs:forAttributes:
hasHistoryTransactionWithNumber:
processDeleteRequest:
processExternalDataReferenceFilesDeletedByRequest:
insertArray:forEntity:
insertManagedObjectBlock:forEntity:
gatherObjectIDsFromTable:
registerMigrationUpdateFunctionWithMigrator:
executeAttributeUniquenessCheckSQLStatement:returningColumns:
executeMulticolumnUniquenessCheckSQLStatement:returningColumns:
adoptQueryGenerationWithIdentifier:
_checkActiveGenerationsForIdentfier:
triggerUpdatedRowInTable:withEntityID:primaryKey:columnName:newValue:
_workingURL
_dbPath
_transactionIsOpen
_transactionIsCurrentlyReadOnly
_useSyntaxColoredLogging
_sqlStatement
_metadataColumns
_rowsProcessedCount
_lastEntityKey
_finalEntity
_lastEntity
_fetchPKStatement
_updatePKStatement
_beginStatement
_commitStatement
_rollbackStatement
_vmCachedStatements
_pragmaSettings
_mObjectIDsUpdatedByTriggers
_statementCachesByEntity
_cachedEntityUpdateStatements
_cachedEntityConstrainedValuesUpdateStatements
_timeOutOption
_timeOutIncrement
_extraBuffersForRegisteredFunctions
_dbPathRegisteredWithBackupd
_vacuumTracker
_temporaryTables
_sqliteConnectionFlags
_debugInode
_activeGenerations
supportedErrorClasses
_success
operatorWithType:modifier:options:
performOperationUsingObject:andObject:
retainedLocale
lengthOfBytesUsingEncoding:
historyMigrationCache
srcModel
dstModel
_updatedPropertiesForEntity:andData:
initWithRecordsToSave:recordIDsToDelete:
setExportMetadata:
operationID
setStatus:
setObjects:
setZoneName:
setOperation:
resetCurrentState
processedTransactionIDs
setHistoryToken:
setExportedAt:
allObjectIDs
cacheMetadataForObjectsWithIDs:andRecordsWithIDs:inStore:withManagedObjectContext:error:
sortedStates
processObjectState:withSerializer:analyzerContext:store:managedObjectContext:exportMetadata:error:
markRelationshipsForDeletedRecordIDs:withManagedObjectContext:error:
processDeletedRecordID:withExportMetadata:inContext:
addOperationForCurrentState:withExportMetadata:
recordMetadataForObjectID:
purgeExportMetadataFromStore:withContext:error:
operations
updateMirroredRelationshipsMatchingRecords:forStore:withManagedObjectContext:usingBlock:error:
processAnalyzerContext:withStore:inManagedObjectContext:error:
persistMetadataChangesIfNecessary:error:
modifyRecordsOperationWithID:finishedForStore:withSavedRecord:deletedRecordIDs:operationError:managedObjectContext:error:
exportMetadataIdentifier
_latestTransactionNumber
_currentRecords
_currentRecordIDs
_currentSerializer
_currentBytes
_operations
_exportMetadataIdentifier
_currentExportedObjects
_allDeletedRecordIDs
_workBlock
destinationAlias
initForRelationship:sourceAlias:destinationAlias:correlationAlias:direct:inScope:
createToOneJoinIntermediateForProperty:lastStep:inScope:context:
createToManyJoinIntermediateForProperty:lastStep:inScope:context:
createManyToManyJoinIntermediateForProperty:direct:lastStep:inScope:context:
sourceAlias
setSourceAlias:
_generateToOneSQLStringInContext:
_generateToManySQLStringInContext:
_generateManyToManySQLStringInContext:
createJoinIntermediatesForKeypath:startEntity:startAlias:forScope:inStatementIntermediate:inContext:
isDirect
setDirect:
setDestinationAlias:
correlationAlias
joinType
_sourceAlias
_destinationAlias
_correlationAlias
_direct
_propertyDescriptionForKeypath:startingAtEntity:allowToMany:lastKeyVisited:inContext:
_propertyDescriptionsForKeypath:rootedAtEntity:allowToMany:lastKeyVisited:inContext:
_generateSQLForProperty:startEntity:startAlias:keypath:inContext:
substitutePK
_substitutePK
inverseManyToMany
_setCorrelationTableName:
_setOrderColumnName:
isTableSchemaEqual:
_correlationTableName
_orderColumnName
setMachServiceName:
setStoreDirectoryPath:
cloudKitMachServiceName
createCloudKitServerWithMachServiceName:andStorageDirectoryPath:
initFromOriginal:
_storeDirectoryPath
_machServiceName
setOperationUUID:
setImportDate:
setPreviousServerChangeToken:
setDesiredKeys:
initWithRecordZoneIDs:configurationsByRecordZoneID:
applyToOperation:
addUpdatedRecord:
setRecordChangedBlock:
addDeletedRecordID:ofType:
setRecordWithIDWasDeletedBlock:
fetchFinishedForZoneWithID:serverChangeToken:error:
setRecordZoneFetchCompletionBlock:
fetchOperationFinishedWithError:completion:
setFetchRecordZoneChangesCompletionBlock:
addOperation:
storeIsAlive
fetchOperationWithIdentifier:fromStore:inManagedObjectContext:error:
setCurrentChangeToken:
setLastFetchDate:
insertPendingRelationshipForFailedRelationship:forOperation:inStore:withManagedObjectContext:
purgeFinishedImportOperationsInStore:withManagedObjectContext:error:
removeDownloadedAssetFiles
requestIdentifier
assetStorageURL
attributesOfItemAtPath:error:
workQueue
newMirroringResultByApplyingAccumulatedChanges:
initWithChangedRecordZoneIDs:options:request:
resolvedRelationships
importOperationIdentifier
assetPathToSafeSaveURL
totalAssetBytes
updatedRecords
recordTypeToDeletedRecordID
allRecordIDs
encounteredErrors
fetchedZoneIDToChangeToken
_assetPathToSafeSaveURL
_resolvedRelationships
_importOperationIdentifier
_totalAssetBytes
_recordTypeToDeletedRecordID
_allRecordIDs
_encounteredErrors
_fetchedZoneIDToChangeToken
_failedRelationships
storeType
_bundleIdentifier
_storeFileHandle
_storeFileProtectionClass
_storeType
_storeConfigurationName
_generateModel:error:
initWithManagedObjectModel:configurationName:retainHashHack:brokenHashVersion:
_entityMapping
_sqlEntityWithRenamingIdentifier:
_lastEntityID
_retainHashHack
_mom
_entitiesByName
_entityDescriptionToSQLMap
_brokenHashVersion
_retainLeopardStyleDictionaries
_hasVirtualToOnes
_entityIDOffset
_checkElements:
_isCompoundIndexCompatible
setElements:
setPartialIndexPredicate:
_isPurelyModeledIndex
_elements
_partialIndexPredicate
ascending
_generateSQLForOrderedManyToManyInverse:inContext:
_generateSQLForOrderedToManyInverse:inContext:
comparator
localizedCompare:
localizedStandardCompare:
fetch_request
requested_batch_size
sql_core
sql_model
statement_entity
current_context
row_cache
entity_for_ek_funptr
flags
fetchPlan
fetchStatement
isUsingCachedStatement
totalUnitCount
isCancelled
useColoredLogging
sqlModel
newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:
storeIsUbiquitized
ubiquitousExternalReferenceLocationForUUID:
initWithSQLEntity:ownedObjectID:andTimestamp:
addFaultsThatWereFired:
serviceListener
initWithKeyPointerFunctions:valuePointerFunctions:capacity:
initForStoreWithURL:usingModel:options:policy:
willPerformRecoveryForError:fromContext:
performRecoveryForError:fromContext:
errorIsPlausiblyAnSQLiteIssue:
setupRecoveryForConnectionContext:ifNecessary:
_createCoordinator
removeCachesForConnection:
retainedCacheForConnection:
currentConnection
shouldAcceptConnectionsFromClientWithContext:
handleMetadataRequestInContext:
handleFetchRequest:inContext:error:
handleSaveRequest:inContext:error:
postRemoteChangeNotificationForContext:
handleObtainRequest:inContext:error:
handleFaultRequest:inContext:error:
handleRelationshipFaultRequest:inContext:error:
handleNotificationNameRequestInContext:error:
handleQueryGenerationRequestInContext:error:
handleQueryGenerationReopenRequest:inContext:error:
handleQueryGenerationReleaseRequest:inContext:error:
handleBatchDeleteRequest:inContext:error:
handlePersistentHistoryRequest:inContext:error:
handlePersistentHistoryTokenRequest:inContext:error:
handleBatchUpdateRequest:inContext:error:
handleBatchInsertRequest:inContext:error:
initForStoreWithURL:usingModelAtURL:options:policy:
errorHandlingDelegate
setErrorHandlingDelegate:
startListening
stopListening
requestHandlingPolicy
_modelURL
_storeURL
_entitlementNames
_policy
_connectionToCoordinatorMap
_postRemoteChangeNotifications
_retainedPersistentStore
localGenerationForXPCToken:withContext:
processObtainRequest:inContext:error:
shouldAcceptMetadataChangesFromClientWithContext:
restrictingWritePredicateForEntity:fromClientWithContext:
_populateObject:withValuesFromClient:
processRequest:fromClientWithContext:error:
unpackQueryGeneration:withContext:
processFaultForRelationshipWithName:onObjectWithID:fromClientWithContext:error:
processFaultForObjectWithID:fromClientWithContext:error:
decodeFromXPCArchive:withContext:
retainedXPCEncodableGenerationTokenForOriginal:inContext:
containerID
initWithContainerID:options:
containerWithIdentifier:options:
visitPredicateOperator:
keypaths
subqueries
setExpressions
_compoundPredicate
_allModifierPredicates
_setExpressions
_subqueries
initWithSQLCore:priority:seedConnection:
handleStoreRequest:
executeRequestUsingConnection:
scheduleBarrierBlock:
initializationConnection
scheduleConnectionsBarrier:
_validateKeypaths:
setDerivationExpression:
setFilteringPredicate:
_derivationExpression
_filteringPredicate
duplicateRequestErrorForRequest:
enqueueRequest:error:
dequeueNextRequest
requestFinished:
pendingImportRequest
pendingExportRequest
pendingSetupRequest
pendingDelegateResetRequest
pendingResetRequest
pendingFetchRecordsRequest
pendingResetMetadataRequest
activeRequest
_pendingImportRequest
_pendingExportRequest
_pendingSetupRequest
_pendingDelegateResetRequest
_pendingResetRequest
_pendingFetchRecordsRequest
_pendingResetMetadataRequest
_activeRequest
objectIDForIdentifier:inStore:
setObjectID:forIdentifier:
identifiersForStore:
_identifierToStoreUUIDToObjectID
_storeUUIDToIdentifiers
_entitiesWithTooManyTombstonesInModel:
createModelsWithTombstoneCount:andOptions:
ancillaryEntityCount
coordinatorWillRemoveStore:
declareStoreDead
pfcloudstoremonitor_is_holding_your_store_open_waiting_for_cloudkit_activity_to_finish
monitorGroup
monitoredCoordinator
monitoredStore
retryCount
timeoutSeconds
declaredDead
_monitorGroup
_aliveLock
_storeIsAlive
_declaredDead
_retryCount
_timeoutSeconds
_monitoredCoordinator
_monitoredStore
initWithError:completionBlock:
causedByError
_causedByError
cacheFaultingStatement:
createCorrelationCacheDictionary
insertOrReplaceStatement:forRelationship:inDictionary:
faultingStatement
cacheCorrelationMasterReorderStatementPart2:forRelationship:
preparedFaultingCachesForRelationship:
cacheFaultingStatement:andFetchRequest:forRelationship:
_insertStatementCache
_deletionStatementCache
_faultingStatementCache
_toManyRelationshipStatementCache
_correlationInsertCache
_correlationDeleteCache
_correlationMasterReorderCache
_correlationMasterReorderCachePart2
_correlationReorderCache
sqlTypeString
compareToken:error:
_storeTokens
setCreateTableStatements:
setDropTableStatements:
setUpdateTableStatements:
createTableStatements
dropTableStatements
updateTableStatements
dropStatementsForStore:
bulkUpdateStatementsForStore:
setPropertyDescription:
isForeignKey
isForeignEntityKey
isForeignOrderKey
isEntityKey
isOptLockKey
_propertyDescription
_fetchIndex
_slot
variable
initForReadOnlyFetchWithEntity:propertyDescription:
inverseOrderKey:
resolveVariableExpression:inContext:
_onlyFetchesAggregates
_variableToAliasMappings
_propertyToAliasMappings
_setForeignOrderKey:
_inverse
newBatchAllocation:count:withOwnedObjectIDs:
newObjectIDForToOne:
_validateToOnes
newColumnMaskFrom:columnInclusionOptions:
setObjectID:
hasUniqueConstraintDiffFrom:
_debug
initForCorrelationTarget:alias:fetchColumns:inScope:
setColumnAlias:
setFetchEntity:
_entityAlias
_correlationTarget
_fetchColumns
_useDistinct
_columnAlias
_isCount
_checkoutConnection
_checkinConnection:
maxConnections
availableConnections
_availableConnections
_allConnections
_maxConnections
_poolCounter
_connectionLock
_processingQueue
_isNilExpression:
_generateSQLType3InContext:
_sqlTokenForPredicateOperator:inContext:
_cfStringOptionsFromPredicateOptions:
insertString:atIndex:
_generateSQLForString:expressionPath:wildStart:wildEnd:allowToMany:inContext:
_upperBoundSearchStringForString:context:
_generateSQLSubstringWildStart:wildEnd:inContext:
_entityDestinationIfKeyOfSomeSort:
_prefetchSourceOfUnidirectionalVirtualInverse:
_generateSQLForConstKeyArray:targetEntity:reboundFrom:inContext:
_generateSQLForConst:inManyToMany:expression:inContext:
_generateSQLForConst:inToMany:inContext:
_generateSQLForConst:inAttribute:expression:inContext:
initWithWorkingEntity:target:bounds:scope:
_generateSQLType1InContext:
_generateSQLType2InContext:
_generateSQLForMatchingOperator:inContext:
_generateSQLBeginsWithStringInContext:
_generateSQLEndsWithStringInContext:
_generateSQLContainmentStringInContext:
_generateSQLBetweenStringInContext:
_generateSQLBoundByStringInContext:
_generateSQLForWildSubStringForGlob:wildStart:wildEnd:
_comparisonPredicateScopedItem
_effectiveLeftExpression
_effectiveRightExpression
entryForKey:fromStore:inManagedObjectContext:error:
transformedValue
historyToken
fetchHistoryAfterToken:
newAnalyzerContextForStore:sinceLastHistoryToken:inManagedObjectContext:error:
exporter:willScheduleOperations:
executeOperationsInContext:completion:
setSavePolicy:
exportOperationFinished:withSavedRecords:deletedRecordIDs:operationError:completion:
setModifyRecordsCompletionBlock:
updateMetadataForSavedRecords:deletedRecordIDs:inStore:withManagedObjectContext:
updateOrInsertMetadataEntryWithKey:transformedValue:forStore:intoManagedObjectContext:error:
initWithOptions:request:monitor:workQueue:
exportIfNecessaryWithCompletion:
exportContext
_monitor
_workQueue
_exportContext
removeAllBindVariables
addBindIntarray:
removeAllBindIntarrays
fakeEntityForFetch
cachedStatementInfo
trackChangedRowCount
_bindVariables
_bindIntarrays
_isImpossibleCondition
_trackChangedRowCount
_fakeEntityForFetch
_cachedStatementInfo
_cachedSQLiteStatement
newUniqueNameWithBase:withLength:
_names
checkPredicate:
_foundKeypath
_isKeypathScopedToSubquery:
setGoverningAlias:
setCorrelationToken:
_setVariableColumn:
setGoverningEntity:
canDoDirectJoinGivenPredicate:
_createCollectionJoinsForFetchInContext:
_createSelectClauseInFetchWithContext:
_trailingKeypath
_variableExpression
_fetchIntermediate
_selectFromEntity
_selectFromCorrelationTarget
_selectEntityAlias
_governingEntityForVariable
_variableColumn
_variableAlias
_targetColumn
_targetAlias
_keypathsToPromote
_hasTrailingFunction
_onlyTrailIsCount
_subqueryHasTruePredicate
pflogFaultLog
initWithObservedStore:zone:mirroringOptions:
representativeObjectForEntity:withManagedObjectContext:cache:populate:
populateValuesOnObject:
populateRelationshipsOnObject:withCache:
initWithRecordType:
dataUsingEncoding:
newRepresentativeRecordForStaticFieldsInEntity:
newRepresentativeRecords:
processWorkItemsWithCompletion:
databaseMetadataForScope:forStore:inContext:error:
setRecordZoneWithIDChangedBlock:
setRecordZoneWithIDWasDeletedBlock:
setRecordZoneWithIDWasPurgedBlock:
setChangeTokenUpdatedBlock:
databaseFetchFinishWithContext:error:completion:
setFetchDatabaseChangesCompletionBlock:
processDatabaseImportContext:completion:
initWithDeletedRecordZoneID:options:request:
dequeueWorkItem
workItemFinished:withResult:completion:
madeChanges
importIfNecessaryWithCompletion:
workItemResults
workItems
_workItems
_workItemResults
initWithRequest:connection:context:sqlCore:parentContext:
_cachedInfoForRequestor:
_cacheInfo:forRequestor:
_setupBindVariablesForCachedStatement:usingValues:
cachedStatement
_createStatement
cacheStatement:
_fireFaultsForValue:
_preparePredicate:
objectIDsToRegisterWithContext
persistRows:
createChildContextForNestedFetchRequest:
addObjectIDsToRegister:
addObjectsToAwaken:
objectsToAwaken
setFetchStatement:
sqlEntityForFetchRequest
isFaultRequest
setIsFaultRequest:
originalRequest
shouldUseBatches
faultsThatWereFired
setIsUsingCachedStatement:
_sqlModel
_fetchPlan
_objectIDsToRegister
_objectsToAwaken
_resultFaultsThatWereFired
_parentContext
_fileProtectionLevel
_isFaultRequest
_originalRequest
_shouldUseBatches
_storeIsUbiquitized
_isUsingCachedStatement
_concurrentFetchingPipelineRows
_prefetchingSubstitutionVariables
_idSets
initWithEntity:propertyDescription:virtualForToMany:
_foreignEntityKey
_foreignOrderKey
_isVirtual
_relatedNodes
_map
_entityName
restrictingReadPredicateForEntity:fromClientWithContext:
processFetchResults:prefetchedObjects:ofType:
prefetchRelationships:forFetch:sourceOIDs:fromClientWithContext:
_coreFaultForObjectWithID:fromClientWithContext:error:
_coreProcessFetchRequest:fromClientWithContext:error:
processRelationshipSourceObjectID:fromClientWithContext:error:
notPredicateWithSubpredicate:
processFetchRequest:fromClientWithContext:error:
processSaveRequest:fromClientWithContext:error:
processBatchInsertRequest:fromClientWithContext:error:
processBatchUpdateRequest:fromClientWithContext:error:
processBatchDeleteRequest:fromClientWithContext:error:
processPersistentHistoryRequest:fromClientWithContext:error:
restrictingPullChangeHistoryPredicateForEntity:fromClientWithContext:
_prefetchRelationshipKey:sourceEntityDescription:sourceObjectIDs:prefetchRelationshipKeys:inContext:
getIDsForEntity:count:inContext:error:
setExternalName:
_externalName
capitalizedString
mappingForAttribute:forConfigurationWithName:
mappingForRelationship:forConfigurationWithName:
primaryKeyForEntity:
joinsForRelationship:
mappingForEntity:forConfigurationWithName:
mappingsForConfigurationWithName:inModel:
internalNameForEntityName:version:
internalNameForPropertyName:version:
_setParentBuffer:
hydratedRowAtIndex:
initWithObjects:count:store:metadata:
_resultSet
_weakRequestStore
_columnOffsets
number32FromPtr:
number64FromPtr:
doubleFromPtr:
taggedStringFromPtr:withLength:
stringFromPtr:
dataFromPtr:
objectIDFromPtr:
initWithArray:forTarget:withReferenceValues:andRange:
_parent_buffer
_sql_entity_id
_primary_key
_managedObjectReferenceURI
arrayByAddingObjectsFromArray:
resourceBundles
_sourceModelForVersionHashes:withMetadata:inBundles:outPaths:
sourceType
sourceOptions
sourceMetadata
setSourceMetadata:
destinationURL
destinationType
migrateStoreAtURL:toURL:storeType:options:withManager:error:
migrationStoreOptionsFromStoreOptions:
sourceModelForStoreAtURL:metadata:error:
createMigrationManagerForSourceModel:destinationModel:error:
migrateStoreAtURL:withManager:metadata:options:error:
_sourceURL
_sourceConfiguration
_sourceOptions
_sourceMetadata
_destinationURL
_destinationType
_destinationConfiguration
_destinationOptions
_resourceBundles
_workingWithSkewedSource
URLForDirectory:inDomain:appropriateForURL:create:error:
sourceConfiguration
sourceURL
stringByAppendingPathExtension:
externalDataReferencesURLForDestination:forStoreOfType:
setSourceModel:
mappingModelForSourceModel:destinationModel:error:
setMappingModel:
destinationOptionsForMigration:sourceMetadata:error:
setDestinationOptions:
destinationOptions
destinationTypeForMigration:sourceMetadata:error:
setDestinationType:
setMigrationManager:
migrationManager
destinationURLForMigrationSourceURL:createDocumentReplacementDirectory:error:
setDestinationURL:
willPerformMigrationWithManager:
handleMigrationError:inManager:
didPerformMigrationWithManager:
destinationConfiguration
addMigratedStoreToCoordinator:withType:configuration:URL:options:error:
setSourceURL:
setSourceConfiguration:
setSourceOptions:
setDestinationConfiguration:
destinationConfigurationForMigration:sourceMetadata:error:
setResourceBundles:
initWithBytes:
bits
_counter
_uuid128
_ensureLocalizationDictionaryIsInitialized
_localizedStringForKey:value:
_cachedObjectForKey:value:
_localizedPropertyNameForProperty:entity:
_localizationBundle
_modelStringsFileName
_localizationDictionary
_hasSetLocalizationDictionary
_mergedPolicies
_keyPathContainsNonPersistedProperties:
_managedObjectContextDidSave:
controller:sectionIndexTitleForSectionName:
controller:didChangeContentWithSnapshot:
controller:didChangeContentWithDifference:
controllerDidChangeContent:
controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:
controller:didChangeSection:atIndex:forChangeType:
controllerWillChangeContent:
_managedObjectContextDidChange:
_managedObjectContextDidChangeObjectIDs:
_managedObjectContextDidMutateObjectIDs:
_restoreCachedSectionInfo
_computeSectionInfo:error:
_core_managedObjectContextDidSave:
_recursivePerformBlockAndWait:withContext:
indexAtPosition:
_sectionNameForObject:
indexPathWithIndexes:length:
sectionIndexTitles
_CoreDataSectionCachesPath
_set__PF_LINKEDAFTERNORTHSTAR:
_set__PF_LINKEDAFTERWILDCAT:
_set__PF__SkipSimulatorAsserts:
deleteCacheWithName:
initWithFetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:
performFetch:
objectAtIndexPath:
indexPathForObject:
sectionIndexTitleForSectionName:
sections
sectionForSectionIndexTitle:atIndex:
sectionNameKeyPath
cacheName
_sectionNameKeyPath
_sectionNameKey
_cacheName
_remappedPredicate
_originalPredicate
_cachePath
_sortKeys
_sectionsByName
_sectionIndexTitles
_sectionIndexTitlesSections
_sectionCachePath
initWithContentsOfMappedFile:
dictionaryWithObjects:forKeys:
_computeSectionInfoWithGroupBy:error:
_resolveSectionIndexTitleForSectionName:
_makeMutableFetchedObjects
_indexOfFetchedID:
_objectInResults:
_createNewSectionForObject:
_insertIndexForObject:inArray:lowIdx:highIdx:sortDescriptors:
_insertObjectInFetchedObjects:atIndex:
_updateSectionOffsetsStartingAtSection:
_indexPathForIndex:
_sectionNumberForIndex:
_removeObjectInFetchedObjectsAtIndex:
_updateFetchedObjectsWithDeleteChange:
_updateFetchedObjectsWithInsertChange:
_fetchedObjectsArrayOfObjectIDs
_preprocessInsertedObjects:insertsInfo:newSectionNames:
_preprocessDeletedObjects:deletesInfo:sectionsWithDeletes:
_preprocessUpdatedObjects:insertsInfo:deletesInfo:updatesInfo:sectionsWithDeletes:newSectionNames:treatAsRefreshes:
_updateFetchedObjectsWithInsertedObjects:deletedObjects:updatedObjects:
filteredSetUsingPredicate:
_lowerMoveOperationsToUpdatesForSection:withInsertedObjects:deletedObjects:updatedObjects:
appendSectionsWithIdentifiers:
appendItemsWithIdentifiers:intoSectionWithIdentifier:
changeWithObject:type:index:
changeWithObject:type:index:associatedIndex:
initWithChanges:
_core_managedObjectContextDidChange:
objectForKeyedSubscript:
_appendAffectedStoreInfoToData:adjustedOffset:
_updateCachedStoreInfo
compareObject:toObject:
_hasFetchedObjects
_dumpSectionInfo
_generateSQLForPredicate:inContext:
setValueTransformer:forName:
_newMetadataModelV1
_newMetadataModelV2
_newMetadataModelV3
_newMetadataModelV4
_newMetadataModelV5
_newMetadataModelV6
_newMetadataModelV7
identifyModelForStoreWithConnection:hasOldMetadataTables:
addDropTableStatementsForOldMetadataTablesToContext:withAdapter:
addSQLEntityToCreate:
addMigrationStatementToContext:forRenamingAttributeNamed:withOldColumnName:toAttributeName:onOldSQLEntity:andCurrentSQLEntity:
addMigrationStatement:
entriesForKeys:onlyFetchingProperties:fromStore:inManagedObjectContext:error:
migrationStatements
sqlEntitiesToCreate
computeAncillaryEntityPrimaryKeyTableEntriesForStore:error:
setHasSubscription:
setHasRecordZone:
updateOrInsertMetadataEntryWithKey:stringValue:forStore:intoManagedObjectContext:error:
updateOrInsertMetadataEntryWithKey:boolValue:forStore:intoManagedObjectContext:error:
ckOwnerName
ckRecordZoneName
mirroredRelationships
records
setDatabase:
checkForCorruptedRecordMetadataInStore:inManagedObjectContext:error:
cleanUpAfterClientMigrationWithStore:andContext:error:
updateOrInsertMetadataEntryWithKey:integerValue:forStore:intoManagedObjectContext:error:
migrateMetadataForObjectsInStore:toNSCKRecordMetadataUsingContext:error:
migrateBatchOfObjects:forStore:inContext:error:
initWithZoneID:
doesMetadataModel:matchConnection:hasOldMetadataTables:
initWithObjectIDs:
checkAndRepairSchemaOfStore:withManagedObjectContext:error:
currentMetadataVersionHashesMatchCachedMetadataVersionHashes:
applyPurgeStatementsForStore:usingConnection:
allMetadataModels
allowedTopLevelClasses
_populateSQLValuesByPropertyFromTransforms:migrationContext:
_populateSQLValuesForVirtualToOnesWithMigrationContext:
entityMigrationDescriptionForEntity:
entityMapping
_populateSQLValuesForDestinationToOne:fromSourceToOne:
_unmappedRelationshipForFormerlyVirtualToOne:migrationContext:
hasCloudKitTables
_generateSQLValueMappingsWithMigrationContext:
transformedManyToManys
initWithEntityMapping:sourceEntity:destinationEntity:
_changeToCopyMigrationType
sourceEntitiesByToOneWithNewEntityKey
sqlValueForColumnName:migrationContext:
populateForeignKeyUpdateDataWithMigrationContext:
addedManyToManys
removedManyToManys
nextPropertyTransform
newCloudKitMetadataUpdateStatements
migrationType
migrationNeedsCopyDueToConstraintMigration
setMigrationNeedsCopyDueToConstraintMigration:
_sqlValuesByColumnName
_sourceEntitiesByToOneWithNewEntityKey
_dstEntity
_srcEntity
_migrationType
_addedManyToManys
_removedManyToManys
_transformedManyToManys
_processedTransforms
_pendingTransforms
_updateUsingCopy
intarrayTableName
_intarrayTable
_intarrayTableName
_updateColumns
_originalRootsForAddedEntity:
createEntityMigrationStatements
createStatementsForUpdatingEntityKeys
generatePKTableUpdateStatements
deleteStatementsForHistory
updateStatementsForHistoryChanges
_annotatesMigrationMetadata
validateMigratedDataFromEntityMapping:error:
_countNullsInColumn:forEntity:
_countUnreferencedPrimaryKeysForEntity:inForeignKeyColumnName:fromTable:
validateMandatoryAttribute:onEntity:error:
validateMandatoryRelationship:onEntity:error:
_populateTableMigrationDescriptions
appendStatementsToRenameTables:migrationContext:
appendStatementsToCreateOrDropTables:migrationContext:
appendStatementsToPerformMigration:migrationContext:
appendStatementsToCompleteMigration:migrationContext:
_determinePropertyDependenciesOnIDForEntity:
_determineAttributeTriggerToMigrateForAttributeNamed:withSourceEntity:andDestinationEntity:
_determineRTreeExtensionsToMigrateForAttributeNamed:withSourceEntity:andDestinationEntity:
_determineIndexesToMigrateForSourceEntity:andDestinationEntity:
_determineUniquenessConstraintsToMigrateForSourceEntity:andDestinationEntity:
_determineDerivedAttributesToMigrateForSourceEntity:andDestinationEntity:
_indexMigrationBlockForSourceEntity:andDestinationEntity:
_sourceTableIsClean:
_determineReindexedEntitiesAndAffectedProperties
_populateEntityMigrationDescriptionsAndEntityMap
_determineAncillaryModelIndexesForMigration
_addEntityMigration:toTableMigrationForRootEntity:tableMigrationType:
initWithRootEntity:migrationType:
addEntityMigrationDescription:
isEqualToValue:
shiftTombstones
clearTombstoneColumnsForRange:
_setAnnotatesMigrationMetadata:
initWithStore:destinationModel:mappingModel:
_disconnect
performMigration:
tableMigrationDescriptionForEntity:
_addReindexedProperty:toSetForEntity:
setHistoryMigrationCache:
setHasCloudKitTables:
_tableGenerationSQL
_existingTableNames
_reindexedEntities
_reindexedPropertiesByEntity
_sourceToDestinationEntityMap
_addedEntityMigrations
_removedEntityMigrations
_transformedEntityMigrations
_copiedEntityMigrations
_tableMigrationDescriptionsByEntity
_hasPKTableChanges
_pkTableUpdateStatements
_attributeExtensionsToUpdate
_indexesToCreate
_indexesToDrop
_derivationsToDrop
_derivationsToRun
_historyMigrationPropertyDataForEntityCache
_cloudKitUpdateStatements
_hasCloudKitTables
_generateSQLForExpressionDescription:inContext:
_isHandlingExpressions
_sourceRootEntity
_doAttributesHaveChangesRequiringCopyForMigration:
_doRelationshipsHaveChangesRequiringCopyForMigration:inContext:
_determineSchemaTransformationComplexityInMigrationContext:
_hasComplexSchemaTransformationsInMigrationContext:
_tempNameForTableName:
createDeleteStatementForEntityMigrations:migrationContext:
createInsertStatementForEntityMigration:migrationContext:
createFEKUpdateStatementsForEntityMigration:migrationContext:
createUpdateStatementForEntityMigration:migrationContext:
createDefaultValuePopulationStatementsForAddedColumnsEntityMigration:migrationContext:
newCopyAndInsertStatementForToOne:toManyToMany:fromTableName:invertColumns:migrationContext:
_retainedRemovedSubEntitiesOfEntity:
_migrationByEntity
_tempTableNames
_hasComplexSchemaTransformations
_addedColumnSet
_raisedColumnSet
_droppedEntitySet
_columnsUpgradedToMandatory
setShouldInitializeSchema:
_shouldInitializeSchema
_createStrings
_dropStrings
_updateStrings
_validateManagedObjectModel:error:
validateEntities:error:
transformedValueClass
allowsReverseTransformation
stringFromDeleteRule:
initWithManagedObjectModel:configuration:
validateEntity:hasAttributeNamed:ofType:andReturnFailureReason:
skipValueTransformerValidation
setSkipValueTransformerValidation:
validateLegacyMetadataAttributes
setValidateLegacyMetadataAttributes:
_skipValueTransformerValidation
_validateLegacyMetadataAttributes
_affectedStores
setEstimatedResultCount:
_estimatedResultCount
forwardingTargetForSelector:
_sourceBuffer
_destroyMapping
_openMapping
_closeMapping
enumerateByteRangesUsingBlock:
getBytes:
_fileURL
_openfd
_activeMap
_mapRefCount
initWithBytesNoCopy:length:
privateCopy
rangeOfData:options:range:
writeToFile:atomically:
_aData
_byteCount
_updateFileDescriptorsInUseReserveNew:
constructSafeguardStringFromString:
_releaseReservedMapFileDescriptor
_doCleanup
_bytesPtrForExternalReference
newFileCoordinatorForUbiquitousExternalDataReferenceLocation:
coordinateReadingItemAtLocation:options:retryOnError:error:byAccessor:
_reserveMapFileDescriptor
_attemptToMapData:
_exceptionForReadError:
_retrieveExternalData
_isEqualHelper:
initForUbiquityDictionary:store:
_setBytesForExternalReference:
_writeExternalReferenceToInterimLocation
_moveExternalReferenceToPermanentLocation
_deleteExternalReferenceFromPermanentLocation
_externalReferenceLocationString
filename
_ubiquitousLocation
_externalDataFlags
willHandleStoreRequest:
filter
setFilter:
_filter
_initializeConnectionsWithSeed:
_checkoutConnectionOfType:
_assignOrderKeysUsingCount:
willChange
insertObjects:count:atIndex:
firstIndex
minusOrderedSet:
unionOrderedSet:
sortRange:options:usingComparator:
_setProcessingIdempotentKVO:
sortWithOptions:usingComparator:
_orderKeys
_grottyHack
_forcedKeys
initWithArray:copyItems:
indexOfObject:inSortedRange:options:usingComparator:
indexSetWithIndex:
moveObjectsAtIndexes:toIndex:
_connectionManagers
initWithOptions:monitor:assetStorageURL:workQueue:zone:andDatabase:
_assetStorageURL
resetGeneratedClasses
_cd_version
_cd_flags
_cd_nullFlags_
identifierForNewStoreAtURL:
newObjectIDForEntity:referenceObject:
_lastIdentifier
_reserveda
_reservedb
launchedTaskWithLaunchPath:arguments:environment:
launchedTaskWithLaunchPath:arguments:environment:redirect:
launchedTaskWithLaunchPath:arguments:
waitUntilExit
processID
terminationStatus
_pid
_termstatus
entityDescriptionWithContext:
changeID
shortStringForChangeType:
updatedProperties
initWithLength:
mutableBytes
_changeID
_changedObjectID
_columns
initWithValues:
_constraint:extends:
_alreadyHasChildForEntity:constraint:
initForEntity:constraint:extension:
_addChild:
extendConstraint:onParentEntity:parentCache:
keyForValues:
registerObject:forValues:
_intraStoreConflictsExistForValues:
extension
children
_extension
_knownValues
_children
updateWithValues:version:
updateFromSQLRow:
_realFetch
initWithOrderedSet:copyItems:
intersectsOrderedSet:
isSubsetOfOrderedSet:
reverseObjectEnumerator
reversedOrderedSet
indexesOfObjectsPassingTest:
exchangeObjectAtIndex:withObjectAtIndex:
setObject:atIndex:
intersectOrderedSet:
_mutableOrderedSet
_insertObjectMethod
_insertMethod
_replaceMethod
_replaceObjectMethod
automaticallyPruneTransientRecords
_automaticallyPruneTransientRecords
_migrationStatements
_sqlEntitiesToCreate
_hasWorkToDo
_checkAndInitializeMetadata:
_checkAccountStatus:
_checkUserIdentity:
_createZoneIfNecessary:
_setupDatabaseSubscriptionIfNecessary:
_initializeAssetStorageURLError:
_createSchemaIfNecessary:
subpathsAtPath:
accountStatusWithCompletionHandler:
privateCloudDatabase
hasRecordZone
_saveZone:error:
_shouldAttemptRecoveryForZone:byDeletingExistingZone:afterError:
_deleteZone:error:
initWithRecordZonesToSave:recordZoneIDsToDelete:
setModifyRecordZonesCompletionBlock:
_createSchema:
hasSubscription
initWithSubscriptionsToSave:subscriptionIDsToDelete:
setModifySubscriptionsCompletionBlock:
fetchUserRecordIDWithCompletionHandler:
entriesForKeys:fromStore:inManagedObjectContext:error:
insertMetadataEntryWithKey:boolValue:forStore:intoManagedObjectContext:
setBoolValue:
insertMetadataEntryWithKey:stringValue:forStore:intoManagedObjectContext:
setStringValue:
initWithMirroringOptions:observedStore:zone:databaseSubscription:
_initializeCloudKitForObservedStore:
_setDatabase:
_setContainer:
_setStoreMonitor:
container
databaseSubscription
largeBlobDirectoryURL
cloudKitSemaphore
storeMonitor
_databaseSubscription
_largeBlobDirectoryURL
_cloudKitSemaphore
_storeMonitor
activityTypeNum
setActivityTypeNum:
setIsUserRequestedBackupTask:
isUserRequestedBackupTask
removeRowCacheForGeneration:
_primaryCache
_rowCachesByGenerationToken
transactionLogLocation
initWithPersistentStore:localPeerID:andUbiquityRootLocation:
setLogScore:
initWithTransactionLog:persistentStore:andLocalPeerID:
retainedDelegate
operation:failedWithError:
cacheWrapper
peerRangeCache
cachePeerRanges:
createMapOfManagedObjectIDsForStoreSaveSnapshot:error:
setGlobalIDToLocalIDURICache:
prefetchManagedObjectsInContext:error:
processObjects:withState:andImportContext:outError:
releaseContents:
loadComparisonMetadataWithError:
newStackForLocalPeerID:storeName:andUbiquityRootLocation:error:
metadataMOC
metadataForStoreWithName:inManagedObjectContext:
initWithStack:andStoreMetadata:
baselineHeuristics
setHeuristics:
cacheWrapperForStoreName:
setCacheWrapper:
setStack:
setStoreMetadata:
importContext
exportingPeerID
setExportingPeerID:
setStoreSaveSnapshot:
storeSaveSnapshot
transactionHistoryCache
cacheTransactionHistory:
knowledgeVector
setKnowledgeVector:
initWithStoreKnowledgeVectorDictionary:
initialStoreKnowledgeVector
operationDidFinish:
setCurrentKnowledgeVector:
updateWithKnowledgeVector:
cacheKV
minCacheKV
baselineKV
isZeroVector
purgeCacheAndWritePendingEntries:error:
createMetadataStoreKnowledgeVector:
createMinMetadataStoreKnowledgeVector:
isAncestorOfKnowledgeVector:
initWithStore:localPeerID:andUbiquityRootLocation:
recoverMetadataWithError:
stack
applyChangesFromStoreSaveSnapshot:withImportContext:withError:
peerStateForStoreName:andPeerID:inManagedObjectContext:createIfMissing:
setTransactionNumber:
setLastProcessedTransactionLogURL:
peer
updatedStoreKnowledgeVector
allPeerIDs
remoteStates
peerID
peerKey
ubiquityName
initWithStoreName:andRemotePeerID:insertIntoManagedObjectContext:
setPeer:
setStoreName:
respondToStoreTransactionStateChangeNotification:
writePendingEntries:
insertedObjectIDs
metaForStoreName:
importer
requestBaselineRollForStore:
operationWasInterruptedDuringImport:
notifyDelegateOfError:
managedObjectID
globalIDToLocalIDURICache
setManagedObjectID:
cachedTransactionHistoryForGlobalID:
conflictsWithKnowledgeVector:
filterUsingPredicate:
resolvedTypeForConflictingLogType:andLatestTransactionEntry:skipObject:
globalIDToFetchedObject
setActingPeerID:
setGlobalID:
globalID
setTransactionLogLocation:
setTransactionType:
addTransactionEntryLight:needsWrite:error:
setConflictLogDate:
setSourceObject:
setConflictingLogTransactionType:
setConflictingLogKnowledgeVector:
currentKnowledgeVector
setConflictingLogTransactionNumber:
setTransactionHistory:
setGlobalIDIndexToLocalIDURIMap:
setImportContext:
createSnapshotFromLogContent:withTransactionLog:
setConflictingLogContent:
relationshipToObjectIDsToCheck
fillManagedObject:withGlobalID:fromUbiquityDictionary:missingObjects:importContext:withError:
updatedObjectIDs
transactionType
createStoreKnowledgeVectorDictionary
setKv:
heuristics
initWithLocalPeerID:andKnowledgeVector:forPeerID:storeName:modelVersionHash:andUbiquityRootLocation:
scheduleReceiptFileWrite:
logScore
main
resolvedConflicts
lockedExistingCoord
setLockedExistingCoord:
setUpdatedStoreKnowledgeVector:
transactionDidRollBack
wroteKV
_psc
_entry
_insertedObjectIDs
_updatedObjectIDs
_logScore
_resolvedConflicts
_lockedExistingCoord
_initialStoreKnowledgeVector
_updatedStoreKnowledgeVector
_importContext
_transactionDidRollback
_wroteKV
_operationError
_relationshipsToObjectIDsToCheck
setLastTransactionDate:
lastTransactionDate
managedObjectContextDidSave:
createKnowledgeVectorFromPeerStates
newKnowledgeVectorByDecrementingPeerWithID:
initWithUnsignedInteger:
transactionEntries
actingPeer
newFileCoordinatorForUbiquityRootLocation:andLocalPeerID:
coordinateWritingItemAtURL:options:error:byAccessor:
metadataInconsistencyDetectedForStore:
cleanUpFromRolledbackPendingTransaction:withNotification:
transactionLogCache
cacheExportedLog:
createKnowledgeVectorString
shouldRespondToSaveNotification:
timeIntervalSinceDate:
initWithLocalPeerID:andUbiquityRootLocation:
setUseLocalStorage:
initWithSaveNotification:withLocalPeerID:
createDictionaryForObjectsInSaveNotification:forTransactionOfType:withExportContext:andSaveSnapshot:
createArrayForExternalDataReferencesInSaveNotification:withExportContext:andSaveSnapshot:
storeNames
storeExportContextForStoreName:
_setFilesDeletedInTransaction:
reserveTransactionNumberWithStoreExportContext:
generatePeerStates
resetFromOptimisticLockingException
scheduleTempLogMove
initWithStoreName:andSaveSnapshot:andRootLocation:
addTransactionEntryLights:error:
storeExportContextForStore:
storeSaveSnapshotForStore:
addManagedObject:withTransactionType:andStoreExportContext:withError:
filesInsertedInTransaction
createPeerRootLocationForPeerID:withUbiquityRootLocation:
pruneTemporaryLogDirectoryForPeerRootLocation:error:
moveLogsFromTempDirectory
initWithLocalPeerID:forStoreName:ubiquityRootLocation:localRootLocation:andProcessingQueue:
currentRootLocation
beginWatchingForChangesFromStore:
stopWatchingForChanges
setUbiquityRootLocation:
pendingTempLogMove
allowTempLogStorage
setAllowTempLogStorage:
localRootLocation
useLocalStorage
throwOptimisticLockingException
setThrowOptimisticLockingException:
_lastTransactionDate
_localRootLocation
_transactionLock
_pendingTransactionsToStoreNameAndTransactionNumber
_pendingTempLogMove
_allowTempLogStorage
_useLocalStorage
_throwOptimisticLockingException
recordMetadataForRecordID:
_addMirroredRelationshipMTMKey:forObjectWithID:andRelationshipName:
_metadataForRecordID:
mirroredRelationshipForRecordID:
registerMirroredRelationship:forKey:
_recordZoneIDToZoneMetadata
_recordIDToMirroredRelationshipOrRecordMetadata
_mtmKeyToMirroredRelationship
_objectIDToRelationshipNameToExistingMTMKeys
_invalidatedMTMKeys
createObjectIDCaptureStatements
dropObjectIDCaptureStatements
importQueue
setMaxConcurrentOperationCount:
cancelAllOperations
setSuspended:
pendingLogLocations
initWithLocalPeerID:andGlobalIDCache:
retainedCachedLogForLocation:loadWithRetry:error:
transactionLogAtLocation:failedToOpenWithError:
transactionLogAtLocationWasIgnored:
transactionLogType
newKnowledgeVectorBySubtractingVector:
canProcessTransactionLogWithScore:afterLogWithScore:
transactionLogAtLocationWasScheduled:
logLocationsToEncounteredErrors
start
addOperations:waitUntilFinished:
isMonitoring
setAllowBaselineRoll:
schedulingLock
createSortedOperationsArrayWithMetadata:isFirstImport:
failedLogLocations
checkSchedulingContextForMissingLocalPeerOperations:error:
scheduleTransactionLogOperations:synchronous:error:
scheduledLogLocations
createArrayOfSubLocationsAtLocation:error:
addPendingLogLocation:
batchDownloadTransactionLogsAtLocations:error:
schedulePendingLogs:error:
startDownloadForItems:onQueue:withBlock:
createSetOfCoordinatorsForPersistentStoreName:andLocalPeerID:atUbiquityRootLocation:
createNewSetOfObjectIDsForCoordinator:fromObjectIDs:
shouldThrottleNotificationsWithOperation:
postImportNotificationForStoreName:andLocalPeerID:withUserInfo:
removeLogsCachedForStoreNamed:withUbiquityRootLocation:
scheduleRecoveryTimer
discoverAndImportAllAvailableLogs:error:
logRestartTimer
setLogRestartTimer:
subpathsOfDirectoryAtPath:error:
allowBaselineRoll
isExecuting
executeBlockOnPrivateQueue:
createSetOfActiveStoreNames
createSetOfPersistentStoreCoordinatorsRegisteredForStoreName:
scheduleBaselineRecoveryOperationWithActiveBaselineOperation:
refreshPeerRangeCache:
createPrivateCoordinatorForStore:error:
addPrivateStore:toCoordinator:atURL:error:
canProcessContentsOfUbiquityRootPath:
createPrivateCoordinatorAndStoreForStore:atURL:error:
executeBlockOnRootQueue:
afterDelay:executeBlockOnRootQueue:
baselineRollOperationEncounteredAnInconsistentBaselineState:
baselineRollOperationWasUnableToLockPersistentStore:
recoveryOperation:didReplaceLocalStoreFileWithBaseline:
recoveryOperation:encounteredAnError:duringRecoveryOfBaseline:
rollResponseOperation:successfullyAdoptedBaseline:
rollResponseOperation:encounteredAnError:whileTryingToAdoptBaseline:
initWithLocalPeerID:ubiquityRootLocation:storeName:andPrivateStore:
isPeerForked:andLocalKV:
startMonitor:
compareScoreKnowledgeVector:withScoreDictionary:
scheduleBaselineRollResponseOperationForBaselineAtLocation:
throttleNotifications
setThrottleNotifications:
importOnlyActiveStores
setImportOnlyActiveStores:
schedulingContext
sideLoadCacheWrapper
setSideLoadCacheWrapper:
privatePSC
_importQueue
_privateQueue
_isMonitoring
_privatePSC
_privateStore
_schedulingContext
_sideLoadCacheWrapper
_logRestartTimer
_schedulingLock
_importOnlyActiveStores
_throttleNotifications
_numPendingNotifications
_allowBaselineRoll
_pendingImportOperationsCount
metadataStoreFileLocation
entryForLocalPeerID:storeName:andUbiquityRootLocation:
removeCachedCoordinatorsForLocalPeerID:storeName:andUbiquityRootLocation:
cacheEntryForLocalPeerID:storeName:andUbiquityRootLocation:error:
newMetadataEntryForLocalPeerID:storeName:andUbiquityRootLocation:error:
primaryKeyRanges
initWithKnowledgeVectorDictionary:
allPeersInManagedObjectContext:
peerForPeerID:inManagedObjectContext:createIfMissing:
initWithMetadataEntry:
purgeAndInitializeMetadataStoreFileWithError:
purgeMetadataForStoreMetadata:withError:
allPeers
peerForPeerID:createIfMissing:
metadataEntry
_metadataMOC
_metadataEntry
_ubiquityRootURL
_metadataStoreFileLocation
_createFetchRequestContextForObjectsToDelete
_createDeleteStatements
fetchContext
deleteStatements
setAffectedObjectIDs:
_fetchRequestForObjectsToDelete
_deleteStatements
_fetchContext
_externalDataReferenceTriggerStatements
_tempTableName
setPeerKey:
setPeerCode:
predicateWithFormat:argumentArray:
initWithStoreName:insertIntoManagedObjectContext:
peerStatesMatchingStoreName:inManagedObjectContext:
peerStateForStoreName:andPeerID:inManagedObjectContext:
peerStatesMatchingStoreName:inManagedObjectContext:omittingLocalPeerID:
setRecordName:
setCdEntityName:
setRelatedEntityName:
setRelatedRecordName:
setRelationshipName:
forConflictAnalysis
notificationSourceObject
shouldRegisterQueryGeneration
transactionID
_persistentStoreRequest
_exception
_useColoredLogging
_useConcurrentFetching
_hasHistoryTracking
_transactionID
_storeIsInMemory
setUbiquityName:
setUbiquityRootURLString:
storeMetadatasWithName:inManagedObjectContext:
setStoreURLString:
setStoreIdentifier:
setStoreType:
setStoreOptions:
setModelVersionHashString:
peerStateForPeerID:
addPeerStatesObject:
peerRanges
loadFromBaselineDictionary:
baselineRootDirectoryForUbiquityName:andUbiquityLogURL:
ubiquityRootURLString
createUbiquityLocationForRootURL:
storeOptionsBinaryPlistData
setStoreOptionsBinaryPlistData:
initWithUbiquityName:andUbiquityRootLocation:insertIntoManagedObjectContext:
updateWithStore:andRootLocation:
loadFromBaselineMetadata:withLocalPeerID:
updatePeerStatesToMatchKnowledgeVector:
storeOptions
allStoreMetadataInManagedObjectContext:
baselineStoreURLForUbiquityName:andUbiquityLogURL:
baselineModelURLForUbiquityName:andUbiquityLogURL:
baselineGCModelURLForUbiquityName:andUbiquityLogURL:
baselineMetaFileURLForUbiquityName:andUbiquityLogURL:
isBaselineRootURL:
setPeerID:
remotePeerStatesMatchingStoreName:inManagedObjectContext:
remotePeerStatesMatchingStoreName:andPeerID:inManagedObjectContext:
changeToken
_madeChanges
_changeToken
_historyToken
boolValueNum
setBoolValueNum:
dateValue
_insertMetadataEntryWithKey:forStore:intoManagedObjectContext:
setTransformedValue:
setIntegerValue:
_updateOrInsertMetadataEntryWithKey:valueSettingBlock:forStore:intoManagedObjectContext:error:
setKey:
insertMetadataEntryWithKey:transformedValue:forStore:intoManagedObjectContext:
insertMetadataEntryWithKey:integerValue:forStore:intoManagedObjectContext:
describeValue
setPeerStart:
setPeerEnd:
setEnd:
setStart:
setPeerEntityName:
transactionTypeNum
setTransactionTypeNum:
storeMetadata
modelVersionHashString
transactionLogFilename
createTransactionLogLocationForPeerID:storeName:modelVersionHash:logFilename:andUbiquityRootLocation:
initAndInsertIntoManagedObjectContext:
setTransactionLogFilename:
setActingPeer:
createGlobalIDString
setGlobalIDStr:
setLocalIDStr:
setKnowledgeVectorString:
newTransactionEntryForObjectWithCompressedGlobalID:withTransactionType:importContext:
transactionLogURL
createTransactionEntriesForCompressedObjectIDs:withTransactionType:withImportContext:
transactionEntriesMatchingGlobalObjectID:inManagedObjectContext:
transactionEntriesMatchingLocalObjectID:inManagedObjectContext:
transactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:
deleteTransactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:
transactionEntriesForPeerID:withTransactionNumber:inManagedObjectContext:
transactionEntriesForPeerID:beforeTransacationNumber:forStoreNamed:inManagedObjectContext:
transactionEntryForGlobalIDString:withActingPeerID:atTransactionNumber:inManagedObjectContext:
userDefaultsChanged:
checkUserDefaults
setDesiredLogLevel:
desiredLogLevel
setLoggingLevel:
_desiredLogLevel
initWithEventType:
initWithCustomKey:
idString
eventType
_idString
_eventType
logLevel
logEvent:ID:message:
sharedEventLogger
createEventTrackingID:
createCustomEventTrackingID:
beginEvent:
logEventData:message:
diagnostic:message:
debug:message:
info:message:
warning:message:
error:message:
fatal:message:
endEvent:
incompleteEvents
setLogLevel:
_logEvents
_logLevel
pathWithComponents:
startDownloadingUbiquitousItemAtURL:error:
logWasExported:
logWasImported:
logImportWasCancelled:
logsWereScheduled:
setupAssistantDiscoveredPathsFromMetadataQuery:
printStatus:
sharedPrivateOperationQueue
processPendingURLs
createUbiquityLocationForURL:withUbiquityRootLocation:
isiCloudExtension:
continueCheckingDownload
checkFileDownload
continueCheckingUpload
checkSafeSaveFileUpload
usesNosyncDirectory
retainedStatusForLocation:
permanentLocation
safeSaveLocation
cloudDocsRootFolder
registerInitialSyncHandlerForURL:andContainerID:onQueue:withBlock:
initWithUbiquityRootLocation:localPeerID:storeName:processingQueue:
presentedSubitemUbiquityDidChangeAtURL:
exporterDidMoveLog:
registerSafeSaveFile:
unregisterSafeSaveFile:
locationToStatus
locationToSafeSaveFile
_presentedItemURL
_scheduledProcessingBlock
_pendingURLs
_pendingURLsLock
_locationToSafeSaveFile
_locationToStatus
setConflictingObjectGlobalIDStr:
addObjectIDsForDiff:forRelationship:
addObjectID:forRelationship:
_newNormalizedSnapshot:forObject:
setAncestorSnapshot:
transactionHistory
createSnapshotDictionaryFromLogEntry:withError:
initWithTranasctionEntry:andLogSnapshot:
addSnapshot:
calculateSnapshotDiffsWithError:
conflictingLogKnowledgeVector
electAncestorKnowledgeVectorForKnowledgeVector:withExportingPeerID:fromPeerSnapshotCollection:
snapshotForKnowledgeVector:
newKnowledgeVectorByAddingKnowledgeVector:
snapshotForPeerID:andTransactionNumber:
timeIntervalSince1970
logSnapshot
resolveMergeConflictForLogContent:previousSnapshot:andAncestorSnapshot:withOldVersion:andNewVersion:error:
diffFromPrevious
createSnapshotFromManagedObject:withSourceObject:
knowledgeVectorsForTransactionNumber:exportedByPeerWithID:
createAncestorVectorForConflictingVector:
createSnapshotFromBaselineForEntry:error:
createTransactionLogForTransactionEntry:withImportContext:error:
createSnapshotDictionaryForObjectWithEntry:inTransactionLog:withError:
initWithBaselineLocation:andLocalPeerID:
createPersistentStoreCoordinatorForCurrentBaseline:
globalIDIndexToLocalIDURIMap
createSetOfManagedObjectIDsForGlobalIDsInRelationship:withValue:withGlobalIDToLocalIDURIMap:andTransactionLog:
createStagingTransactionLogLocationFromTransactionLogLocation:
conflictingObjectGlobalIDStr
conflictingLogContent
conflictingLogTransactionType
conflictLogDate
conflictingLogTransactionNumber
_conflictingObjectGlobalIDStr
_sourceObject
_conflictingLogContent
_conflictingLogKnowledgeVector
_currentKnowledgeVector
_conflictingLogTransactionType
_conflictLogDate
_conflictingLogTransactionNumber
_transactionHistory
_globalIDIndexToLocalIDURIMap
_ancestorSnapshot
checkForCloudKitTablesInStoreAtURL:withPersistentStoreCoordinator:withConfiguration:
makeACopyOfTheStoreAtURL:withCoordinator:error:
databaseName
recordZones
ensureContentsOfStore:matchContentsOfStore:error:
printMetadataForStoreAtURL:withConfiguration:operateOnACopy:
printRepresentativeSchemaForModelAtURL:orStoreAtURL:withConfiguration:
checkIfContentsOfStore:matchContentsOfStore:error:
createFetchRequestContext
setForConflictAnalysis:
_forConflictAnalysis
nonretainedObjectValue
localFilePresenter
filePresenterForUbiquityRootLocation:andLocalPeerID:
addFilePresenter:
_removeFilePresenter:
removeFilePresenter:
initWithLocalPeerID:storeName:withURL:ubiquityRootLocation:andLocalRootLocation:
registerPersistentStore:withStoreName:
unregisterPersistentStoreCoordinator:
activeStoreCount
entryWillBeRemovedFromSwitchboard
addEntryToPreviousEntries:
valueWithNonretainedObject:
entryForStore:
createUbiquityExternalDataReferenceFileLocationForUUID:andStore:withUbiquityRootLocation:
cacheFilePresenterForUbiquityRootLocation:andLocalPeerID:
removeFilePresenterCachedForUbiquityRootLocation:andLocalPeerID:
_addFilePresenter:
registerUbiquitizedPersistentStore:withURL:forLocalPeerID:withLocalRootLocation:andUbiquityRootLocation:error:
_quietlyMoveEntryToPreviousEntries:
removeEntryFromPreviousEntries:
releaseAllEntriesForStoreName:andPeerID:
_storeNameToLocalPeerIDToEntry
_rootLocationToLocalPeerIDToFilePresenters
_rootLocationToLocalPeerIDToPreviousEntries
_registrationLock
stopMonitor
filePresenterWasNotifiedTransactionLogs:
filePresenterNoticedBaselineFileChange:
initWithProcessingQueue:localPeerID:storeName:andUbiquityRootLocation:
containerIdentifierChanged:
initWithLocalPeerID:ubiquityRootLocation:localRootLocation:storeName:andPrivateQueue:
addPersistentStore:
removePersistentStore:
setAbortSetup:
setupFinished
containerState
monitorState
currentIdentityToken
uuidString
setContainerIdentifierUUID:forIdentityToken:forStoreName:
storeKV
exporter
synchronouslyExecuteBlockOnPrivateQueue:
containerStateChanged:
monitorStateChanged:
finishSetupForStore:withSetupAssistant:synchronously:error:finishBlock:
afterDelay:executeBlockOnPrivateQueue:
afterDelay:executeBlockOnGlobalConcurrentQueue:
setActiveStoreCount:
finishingSetupAssistant
_localFP
_activeStoreCount
_registeredCoordinators
_finishedSetupForStore
_hasScheduledFinishBlock
_finishedInitializingForStore
_finishLock
_finishingSetupAssistant
cacheWrapperWillBeRemovedFromEntry
initWithStoreName:privateStore:forLocalPeerID:andUbiquityRootLocation:
ubiquityIdentityToken
setUseLocalAccount:
activeModelVersionHash
useLocalAccount
_activeModelVersionHash
_stores
_importer
_exporter
_cacheWrapper
_useLocaAccount
_baselineHeuristics
finishProcessing
changes
processChange:
shouldPruneAnalyzerState:
processFinalState:
processTransaction:
resetStateForObjectID:
entityNameToObjectIDs
objectIDToState
isFinished
_objectIDToState
_processedTransactionIDs
_sortedStates
_entityNameToObjectIDs
_isFinished
_organizeValues:
_inserts
_deletes
_masterUpdates
_otherUpdates
fetchRecordsRequest
setRecordIDs:
setPerRecordProgressBlock:
fetchFinishedForRecord:withID:error:
setPerRecordCompletionBlock:
setFetchRecordsCompletionBlock:
updatedRecordIDs
_updatedRecordIDs
coordinateReadingItemAtURL:options:error:byAccessor:
shouldRetryForError:ignoreFile:
newFileCoordinatorForUbiquityRootLocation:
initWithDate:
initWithToken:
initWithTransactionToken:
initWithDate:delete:
initWithToken:delete:
propertiesToFetchForEntity:includeTransactionStrings:
fetchHistoryAfterDate:
fetchHistoryAfterTransaction:
fetchHistoryTransactionForToken:
fetchHistoryWithFetchRequest:
deleteHistoryBeforeDate:
deleteHistoryBeforeToken:
deleteHistoryBeforeTransaction:
propertiesToFetchForEntity:
entityNameToFetch
useQueryGenerationToken
setUseQueryGenerationToken:
predicateForStoreIdentifier:
_transactionIDs
_transactionNumber
_persistentHistoryChangeRequestDescriptionFlags
createPeerBaselineFileSafeSaveLocationForLocalPeerID:andBaselineFileLocation:
initWithPermanentLocation:safeSaveLocation:andLocalPeerID:
createBaselineStagingLocation:forStoreName:modelVersionHash:andFilename:withUbiquityRootLocation:
baselineArchiveLocation
baselineStagingLocation
clearOutStagingLocationWithError:
gatherMetadataWithStore:andError:
storeFilenameToData
storeFilename
initWithContentsOfURL:options:error:
constructBaselineArchive:
createArchiveWithModel:metadata:storeFilenameToData:storeFilename:error:
currentLocation
initWithPath:options:error:
baselinePeerArchiveLocation
setCurrentLocation:
metadataFromBaselineArchive:
contentsForEntryName:
initWithData:encoding:
unpackStoreFilesToStagingLocation:
authorPeerID
haveTransactionLogsForPeer:between:and:
createPeerStoreVersionLocationForPeerID:storeName:andModelVersionHash:withUbiquityRootLocation:
initWithLocalPeerID:andReceiptFileLocation:
metadataFromCurrentBaselineForStoreWithName:peerID:modelVersionHash:andUbiquityRootLocation:withError:
downloadLatestVersion:error:
isPeerReceiptTooOld:
writeDate
timeIntervalSinceNow
replaceLocalPersistentStoreAtURL:ofType:withOptions:usingPersistentStoreCoordinator:error:
_createPersistentStoreCoordinatorForCurrentBaseline:error:
createCurrentBaselineLocation:forStoreName:peerID:andModelVersionHash:forFileNamed:withUbiquityRootLocation:
optimizedModelData
gcModelData
moveToPermanentLocation:
createManagedObjectModelFromCurrentBaseline
baselineArchive
createBaselineOptimizedModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:
createBaselineGCModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:
initWithEntryNames:contents:properties:options:
createSetOfInUseExternalDataRefUUIDs:
createUbiquityExternalDataReferenceStoreLocationForStoreName:withUbiquityRootLocation:
removeFileAtLocation:error:
locationSentinel
deleteCharactersInRange:
setLocationSentinel:
createUbiquityLocationForRootPath:
createUbiquityLocationForPath:withUbiquityRootLocation:
usesCurrentBaselineDirectory
removePeerSpecificIdentifiersFromStore:withLocalPeerID:
createStringOfContentsOfBaselineFile:
prepareForBaselineRollOfPersistentStore:andLocalPeerID:error:
gatherContentsAndConstructArchiveWithError:
loadFileFromLocation:error:
canReplaceStoreAtKnowledgeVector:
isUploaded:
metadataMatchesCurrentMetadata:
importBaselineForStoreAtURL:ofType:options:withLocalPeerID:stack:andPersistentStoreCoordinator:error:
updateCurrentStoreIdentifier:error:
writeFileToLocation:error:
baselineMetadataData
createManagedObjectModel
removeUnusedExternalDataReferences:
_baselineStagingLocation
_storeFilenameToData
_storeFilename
_baselineArchive
hasRecordZoneNum
setHasRecordZoneNum:
hasSubscriptionNum
setHasSubscriptionNum:
setCkRecordZoneName:
setCkOwnerName:
previousKnowledgeVector
createNewLocalRangeWithRangeStart:andRangeEnd:forEntityNamed:
addDictionaryForPeerRange:
createPeerRangeDictionary:
setPreviousKnowledgeVectorFromCurrentMetadata:
_authorPeerID
_pKV
_peerRanges
_initWithValue:singleton:
_isUnmoored
_expectedStores
_makeConcrete:
_moor:error:
isUnmoored
_setIsUnmoored:
_setFreeValue:
_setPersistentStoreReference:
_generationIdentifier
_isCompound
_isSingleton
_freeValueOnDealloc
_updateRollbackCacheForObjectWithID:relationship:withValuesFrom:
_cacheNodePropertiesFromObject:
_addRowForInsertOrUpdate:
_encodeObjectValues:options:
_encodeObjectsForSave:forDelete:
rowForID:
forceUpdates
_interrupts
_forceUpdates
ensureStoresAgreeOnCloudKitTables:error:
compareContentOfStore:toStore:error:
compareCloudKitMetadataOfStore:toStore:error:
deriveIdentifierForNonCloudObjectID:
populateCacheForStore:inContext:error:
getObjectMatchingRecordID:fromStore:withManagedObjectContext:
compareAttributesOnObject:toObject:error:
compareRelationshipsOfRecordID:withStoreObject:andOtherObject:error:
validateValue:againstOtherValue:forIgnoredAttribute:
trimExcessiveValuesForLog:
isValue:equalToValue:forAttribute:
isEqualToDate:
getRecordIDsForRelationship:onObject:
isPending
checkCloudKitMetadata
_checkCloudKitMetadata
updateStatement
createDeleteTransactionsRequestContext
createCountRequestContextForChanges
fetchRequestContextForChanges
createRequestContextForChangesWithTransactionIDs:
_copyToInterimLocation
_moveToPermanentLocation
initWithUnsignedLong:
stringWithCapacity:
entitiesAndCounts
initWithStoreName:andUbiquityRootLocation:forLocalPeerID:
_storeNameToStoreExportContext
_ubiquityRootPathToStack
addTransactionEntryForGlobalID:andTransactionType:
_transactionEntries
_requestIdentifier
storeID
bundleID
notificationWithName:object:
initialQueryGenerationToken
postQueryGenerationToken
objectIDNotification
_userInfoFromChanges
_setCoordinator:
_rowIdentifier
_timestamp
_changes
_bundleID
_processID
_author
_queryGeneration
updateHash
stringValueFromArray:atIndexDescribedByStringNumber:
initFromCopyWithStoreName:entityName:primaryKey:peerID:andHash:managedObjectID:primaryKeyInteger:
integerFromPrimaryKeyString:
primaryKeyInteger
initWithStoreName:entityName:primaryKeyInteger:andPeerID:
initWithCompressedString:forStoreWithName:andEntityNames:primaryKeys:peerIDs:
createCompressedStringWithEntityNameToIndex:primaryKeyToIndex:peerIDToIndex:
_owningPeerID
_managedObjectID
_primaryKeyInteger
setCatastrophicLoggingLevel
testPointForLoggingMessage:atLevel:
testGetLoggingOverride
testSetLoggingOverride:
initWithExportingPeerID:
setLocalPeerID:
initForExport:
initWithTransactionLog:
_transactionDate
_exportingPeerID
_storeNameToStoreSaveSnapshots
_deleteTarget
entityNames
globalObjectIDs
managedObjectIDToGlobalObjectID
entityNameToIndex
peerIDToIndex
primaryKeyToIndex
createGlobalObjectIDForManagedObjectID:
checkIndecies:
noSyncCheckIndex:forValue:fromArrayOfValues:
globalObjectIDForManagedObject:withStoreExportContext:
createUbiquityDictionary:withStoreExportContext:error:
newKnowledgeVectorByIncrementingPeerWithID:
checkIndex:forValue:fromArrayOfValues:
transactionNumberFromPeerStates:
initWithLocalPeerID:forStoreName:
createGlobalIDForCompressedString:withEntityNames:primaryKeys:peerIDs:
filesDeletedInTransaction
setEntityNames:globalObjectIDs:primaryKeys:forStoreName:withRootLocation:
prepareForGlobalIDReplacement
replaceGlobalObjectID:withGlobalObjectID:
finishGlobalIDReplacement
globalObjectIDToIndex
globalObjectIDToPermanentManagedObjectID
setStoreKV:
globalObjectIDCache
setGlobalObjectIDCache:
_entityNames
_peerIDs
_globalObjectIDs
_managedObjectIDToGlobalObjectID
_globalObjectIDToPermanentManagedObjectID
_entityNameToIndex
_peerIDToIndex
_primaryKeyToIndex
_globalObjectIDToIndex
_peerStates
_filesInsertedInTransaction
_filesDeletedInTransaction
_storeKV
_gidCache
temporaryTransactionLogLocation
createTransactionLogLocationFromTemporaryOrStagingLogLocation:
stagingTransactionLogLocation
transactionLogTypeFromLocation:
createTransactionLogFilenameForLogType:
inPermanentLocation
inTemporaryLocation
inStagingLocation
releaseInsertedObjects
releaseUpdatedObjects
releaseDeletedObjects
loadPlistAtLocation:withError:
loadContents:
initWithTimeIntervalSince1970:
createDataFromExtendedAttrsForLog:error:
initWithData:options:error:
createUbiquityExternalDataReferenceFileLocationForUUID:andLog:
useTemporaryLogLocation
updateModificationTimesForLocation:
populateContents
writeContentsOfZipArchive:intoExtendedAttributesForFile:error:
peerCode
truncateLogFilesForPeerID:storeName:modelVersionHash:beforeKnowledgeVector:withLocalPeerID:andUbiquityRootLocation:
cleanupExternalDataReferences
deleteLogFileWithError:
transactionLogFilenameUUID
truncateLogFilesBeforeBaselineMetadata:withLocalPeerID:andUbiquityRootLocation:
generateTransactionLogFilename
initWithTransactionLogURL:ubiquityRootLocation:andLocalPeerID:
rewriteToDiskWithError:
generatePeerCodeKnowledgeVectorWithManagedObjectContext:
fileProtectionOption
loadUsingRetry
setLoadUsingRetry:
loadedComparisonMetadata
loadedImportMetadata
loadedInsertedObjectData
loadedUpdatedObjectData
loadedDeletedObjectData
_contents
_transactionLogType
_useTemporaryLogLocation
_transactionLogLocation
_temporaryTransactionLogLocation
_stagingTransactionLogLocation
_fileProtectionOption
_inTemporaryLocation
_inStagingLocation
_inPermanentLocation
_knowledgeVector
_saveSnapshot
_loadUsingRetry
_loadedComparisonMetadata
_loadedImportMetadata
_loadedInsertedObjectData
_loadedUpdatedObjectData
_loadedDeletedObjectData
_loadedContents
_contentsLock
initWithStoreName:andUbiquityRootLocation:withLocalPeerID:
_stack
_actingPeer
_storeSaveSnapshot
_globalIDToLocalIDURICache
_globalIDToFetchedObject
_heuristics
domainIdentifier
indexName
protectionClass
defaultSearchableIndex
initWithName:protectionClass:bundleIdentifier:
_processedOidsForDictionary:
initWithItemContentType:
setDisplayName:
initWithKeyName:searchable:searchableByDefault:unique:multiValued:
setValue:forCustomKey:
attributeSetForObject:
initWithUniqueIdentifier:domainIdentifier:attributeSet:
_searchableItemForObject:
_retainedCurrentSearchableIndex
indexSearchableItems:completionHandler:
deleteSearchableItemsWithIdentifiers:completionHandler:
_catchUpToCurrentTransaction
_asyncContextBlock:
_processedOidsForSaveRequest:
_updateSpotlightIndexForObjectsWithIDs:
fetchLastClientStateWithCompletionHandler:
beginIndexBatch
endIndexBatchWithClientState:completionHandler:
_processTransactionsStartingAt:
_updateSpotlightClientStateForHistoryTracking:
_reindexInstancesOf:in:
_importObjectsUpdatedSinceTransaction:
_spotlightClientStateForHistoryTracking
_doFullReimport
_initialImportCompleted
initForStoreWithDescription:model:
searchableIndex:reindexAllSearchableItemsWithAcknowledgementHandler:
searchableIndex:reindexSearchableItemsWithIdentifiers:acknowledgementHandler:
_lastImportedTransaction
_description
_context__
_domainIdentifier
_protectionClass
_enabled
_supportsPersistentHistory
_usesSharedCoordinatorStack
initForStoreWithDescription:coordinator:
startSpotlightIndexing
stopSpotlightIndexing
initWithUbiquityRootPath:
setUbiquityRootLocationPath:
setModelVersionHash:
setFilename:
otherPathComponents
setOtherPathComponents:
setUbiquityLocationType:
setHash:
setIsRootUbiquitous:
usesBaselineStagingDirectory
fileExistsAtLocationWithLocalPeerID:error:
createStringByAppendingSubpath:toPath:
isDirectory
initFileURLWithPath:isDirectory:
__isDirectory
createUbiquityLocationForRootPath:checkIsUbiquitous:
createUbiquityLocationForPath:withUbiquityRootPath:
isUbiquityLocationPath:equalToPath:
createUbiquityExternalDataReferenceFileLocationForUUID:storeName:andUbiquityRootLocation:
localLocationSentinel
createLocalBasePathWithLocalPeerID:containerID:storeName:andStoreURL:
createUbiquityLocationForURL:withUbiquityRootURL:
createUbiquityLocationForSubpath:ofUbiquityRootPath:
createMetadataRootLocationForUbiquityRootLocation:
createMetadataStoreFileLocationForLocalPeerID:storeName:andUbiquityRootLocation:
createMetadataPeerLocationForLocalPeerID:andUbiquityRootLocation:
createMetadataPeerStoreLocationForLocalPeerID:storeName:andUbiquityRootLocation:
createMetadataUUIDLocationForLocalPeerID:storeName:UUID:andUbiquityRootLocation:
createPeerBaselineFileLocationForLocalPeerID:andBaselineFileLocation:
createStagingPeerStoreVersionLocationForExportingPeerID:storeName:andModelVersionHash:withUbiquityRootLocation:
createUbiquityPeerReceiptFileLocationForPeerWithID:storeName:andModelVersionHash:withUbiquityRootLocation:
createUbiquityPeerReceiptSafeSaveLocationFromReceiptFileLocation:
createLocalStoresPathWithLocalPeerID:containerID:storeName:andStoreURL:
createLocalContainerRootLocationWithLocalPeerID:containerID:storeName:andStoreURL:
initWithUbiquityRootURL:
usesStagingLogDirectory
usesTemporaryLogDirectory
usesBaselineDirectory
isTransactionLogLocation
fileAtLocationIsUploaded:
fileAtLocationIsDownloaded:
isEqualToURL:
_ubiquityRootLocationPath
_ubiquityLocationType
_filename
_otherPathComponents
_isDirectory
_isRootUbiquitous
wipeCloudMetadataFromMirroredObjects:
deletedRecordZoneID
_deletedRecordZoneID
setCkRecordID:
fetchMirroredRelationshipsForObject:withRecordID:relatedToObjectsByRelationship:inManagedObjectContext:error:
mirroredRelationshipForObject:relatedToObject:relatedByRelationship:error:
coordinate
_bounds
_entitiesAndCounts
haveConsistentStateForBaselineRoll
rollBaselineWithError:
_governingEntity
_governingAlias
_correlationToken
_limitClause
_orderIntermediate
allDeletedObjectIDs
_mAllDeletedObjectIDs
_mAllObjectIDs
_allDeletedObjectIDs
_allObjectIDs
dataWithContentsOfFile:options:error:
archive:contentsForEntryName:
archive:streamForEntryName:
archive:propertiesForEntryName:
inputStreamWithData:
initWithCalendarIdentifier:
components:fromDate:
year
month
hour
minute
second
dataWithLength:
archiveData
openArchiveFile:
readInt32FromBytes:offset:
addLocalFileHeaderWithBytes:offset:
addCentralDirectoryEndRecordWithBytes:offset:
addCentralDirectoryHeaderWithBytes:offset:
loadFromBytes:offset:
crc32
uncompressedSize
compressedSize
localFileHeaderRelativeOffset
totalHeaderLength
compressionMethod
compareBytes:length:withLocalFileHeader:
writeInt64:toData:
writeInt32:toData:
writeInt16:toData:
readInt16FromBytes:offset:
createStringFromBytes:offset:length:
initWithEntryNames:dataProvider:options:
entryNames
streamForEntryName:
writeContentsForEntryName:toFile:options:error:
propertiesForEntryName:
archiveStream
isValid
readDataForLocalFileHeader:fromBytes:error:
createDataForEntryName:cache:error:
_data
_provider
_desc
_path
_cachedContents
_zFlags
_entryNameToData
_entryNameToLocalFileHeader
_entryNameToCentralDirectoryFileHeader
_localFileHeaders
_centralDirectoryEntries
_endRecord
setExtraFieldData:
setFileComment:
loadFromData:offset:
appendToData:
versionMadeBy
setVersionMadeBy:
versionNeededToExtract
setVersionNeededToExtract:
generalPurposeBit
setGeneralPurposeBit:
setCompressionMethod:
lastModTime
setLastModTime:
lastModDate
setLastModDate:
setCrc32:
setCompressedSize:
setUncompressedSize:
filenameLength
extraFieldLength
fileCommentLength
fileStartDiskNumber
setFileStartDiskNumber:
internalFileAttrs
setInternalFileAttrs:
externalFileAttrs
setExternalFileAttrs:
setLocalFileHeaderRelativeOffset:
extraFieldData
fileComment
_versionMadeBy
_versionNeededToExtract
_generalPurposeBit
_compressionMethod
_lastModTime
_lastModDate
_crc32
_compressedSize
_uncompressedSize
_filenameLength
_extraFieldLength
_fileCommentLength
_fileStartDiskNumber
_internalFileAttrs
_externalFileAttrs
_localFileHeaderRelativeOffset
_extraFieldData
_fileComment
setComment:
numberOfDisk
setNumberOfDisk:
diskWhereCentralDirectoryStarts
setDiskWhereCentralDirectoryStarts:
numberOfCentralDirectoryRecordsOnThisDisk
setNumberOfCentralDirectoryRecordsOnThisDisk:
totalNumberOfCentralDirectoryRecords
setTotalNumberOfCentralDirectoryRecords:
byteSizeOfCentralDirectory
setByteSizeOfCentralDirectory:
centralDirectoryOffset
setCentralDirectoryOffset:
commentLength
comment
_numberOfDisk
_diskWhereCentralDirectoryStarts
_numberOfCentralDirectoryRecordsOnThisDisk
_totalNumberOfCentralDirectoryRecords
_byteSizeOfCentralDirectory
_centralDirectoryOffset
_commentLength
_comment
setLength:
actingPeerID
initWithExportingPeerID:logSnapshot:transactionNumber:transactionDate:andKnowledgeVector:
initForRelationshipAtKey:
diffWithLogSnapshot:andPreviousSnapshot:
computeDiffToPreviousSnapshot:
removeValuesChangedByPeerSnapshot:
_logSnapshot
_diffFromPrevious
initWithURLForSaving:
createFutureForFileAtURL:
_interimLocationURL
setAttributes:ofItemAtPath:error:
_underlyingData
fileURLNoReally
_setStoreMetadata:
setOriginalFileURL:
_originalFileURL
_fileSize
_uuid
_realData
_bytes
_peerIDToTransactionNumberToSnapshot
_peerIDToTranasctionNumberToKnowledgeVector
_kvToSnapshot
_peerSnapshots
_needSort
relationshipKey
_relationshipKey
annotation
initWithError:annotation:
logEncounteredError:withAnnotation:
entries
_entries
_annotation
unresolvedConflictVersionsOfItemAtURL:
replaceItemAtURL:options:error:
electBaselineURLFromVersions:withBaseline:error:
setResolved:
removeAndReturnError:
hasCurrentBaseline
conflictsExistForBaseline:
resolveConflictsForBaseline:withError:
shouldReplaceLocalStoreWithBaseline:
replaceLocalStoreWithBaseline:error:
existsAtSafeSaveLocation
electAncestorBaselineForConflictedBaselines:dissentingBaselines:
databaseScopeNum
setDatabaseScopeNum:
setDatabaseScope:
stringForScope:
setDatabaseName:
_initPrivate
allowsKeyedCoding
_constantValueClassesForSecureCoding
classesForFetchArchive
_newDenormalizedFetchProperties:
_newNormalizedFetchProperties:
initForRequest:
inputStream
secure
_inputStream
_secure
columnsToUpdate
includeSubEntities
_includeSubEntities
fetchData
_fetchData
delete
transactionFromToken
_date
_delete
_transactionFromToken
_fetchBatchSize
_compoundPredicateClassesForSecureCoding
_extendedExpressionClassesForSecureCoding
_operatorClassesForSecureCoding
identifierForStore:
encodableTokenForStore:queryGenerationToken:
createSetOfAllPeerIDsWithOtherVector:
createKnowledgeVectorDictionaryFromString:
_updateHash
initFromCopy:storeKVDict:hash:
initWithKnowledgeVectorDictionary:andStoreKnowledgeVectorDictionary:
initWithKnowledgeVectorString:
hasPeerIDInCommonWith:
isDescendantOfKnowledgeVector:
decrementToMinimumWithKnowledgeVector:
canMergeWithKnowledgeVector:
_storeKVDict
resetOperationConfiguration
setOperationConfiguration:
setQualityOfService:
setAllowsCellularAccess:
allowsCellularAccess
qualityOfService
operationConfiguration
_operationConfiguration
initWithLocalPeerID:receiptPeerID:storeName:modelVersionHash:andUbiquityRootLocation:
receiptFileLocation
setWriteDate:
_writeDate
storeWillBeRemoved:
lockDelegateLock
unlockDelegateLock
initWithStoreName:localPeerID:andUbiquityRootLocation:
_delegateLock
_lockedDelegateLock
recoverBaselineMetadataWithImportContext:error:
recoverTransactionLogMetadataWithImportContext:error:
addTransactionHistoryEntriesForObjectIDs:withImportContext:error:
cacheMetadataForTransactionLog:withImportContext:error:
canAdoptBaseline:byReplacingLocalStoreFile:withStack:withError:
fetchRequestDescribingObjectsToUpdate
_createUpdateStatement
createFetchRequestContextForObjectsToUpdate
_updateStatement
initWithRequest:success:error:container:database:
fetchRequestDescribingChanges
_transactionFromResult:withChanges:
_changeFromResult:withTransaction:
_processResult:
setFailSetupError:
initWithUbiquityRootLocation:peerID:ubiquityName:modelVersionHash:
alphanumericCharacterSet
characterIsMember:
doBasicSanityCheckForUbiquityRootURL:withError:
doPostValidationInit:
longDescription
getCurrentUbiquityIdentityToken
ubiquityIdentityTokenChanged:
initializeStoreKnowledgeVectorFromStore:error:
finishSetupWithRetry:
initWithLocalPeerID:storeName:andUbiquityRootLocation:
identifyContainer:
usedExistingUUIDFile
replaceIdentifierWithUUID:error:
finishSetupForStore:error:
cleanUpFromFailedSetup:
synchronize
detectAndFixForkedContainer:store:error:
initializeReceiptFile:
initializeContainerIdentifierWithStore:error:
initializeStack:
initializeBaselineForStore:error:
checkKnowledgeVectorsAndBaselineWithStore:error:
sideLoadStore:error:
respondToBaselineRoll:
attemptMetadataRecoveryForStore:error:
waitForFileToUpload:
moveLocalLogFilesToUbiquityLocation:
pruneStagingDirectoryForStore:error:
seedStore:error:
isFileUploaded:
existsAtPermanentLocation
removeFileFromLocation:error:
removeOtherVersionsOfItemAtURL:error:
removeFile:
URLForUbiquityContainerIdentifier:
initialSyncComplete
createBaselineFromMostRecentLocation:localPeerID:error:
migrationAssistant
transactionLogLocationsForModelVersionHash:
transactionLogLocationsByModelVersionHash
baselineLocationsByModelVersionHash
latestBaselineLocationSkipModelVersionHash:
updateDictionary:withShortcutSnapshot:
updateDictionary:withPhraseLearningJPSnapshot:
updateDictionary:withPhraseLearningSnapshot:
updateDictionary:withBigramSnapshot:
removeEntriesFromDictionary:withPhraseLearningJPSnapshot:
removeEntriesFromDictionary:withPhraseLearningSnapshot:
removeEntriesFromDictionary:withBigramSnapshot:
fixdictionary:withDeletes:
insertEntriesInDicitonary:inUserDictionaryManagedObjectContext:
insertEntriesInDicitonary:inLearningDictionaryManagedObjectContext:
generateMachineUUIDString
filePosixPermissions
fileIsImmutable
fileType
attributesOfFileSystemForPath:error:
migrateMetadataRoot:
setBaselineKV:
exportedLog:
tryToReplaceLocalStore:withStoreSideLoadedByImporter:
globalIDCache
purgeCache
moveItemAtPath:toPath:error:
createSetOfLocalLogLocations:
rewriteTransactionLogs:toMatchStore:error:
addPendingLogLocations:
writeFile:
ubiquityMetadataTablesPresentInStore:
cleanUserDefaultsForStore:
checkAndPerformMigrationForStore:error:
removeEntriesFromDictionary:withShortcutSnapshot:
insertEntriesInDicitonary:inLearningDictionaryJPManagedObjectContext:
insertEntriesInDicitonary:inBigramManagedObjectContext:
isInitialSyncComplete
_setUbiquityRootLocation:storeName:localPeerID:andModelVersionHash:
needsMetadataRecovery
storeWasMigrated
abortSetup
retryDelaySec
setRetryDelaySec:
failSetup
setFailSetup:
failSetupError
cacheFilePresenterForUbiquityRoot
_actualStoreFileURL
_storeMetadataDict
_needsMetadataWrite
_ubiquityEnabled
_ubiquityIdentityToken
_ubiquityRootSubpath
_ubiquityName
_ubiquityContainerIdentifier
_previousModelVersionHash
_localPeerState
_metaKV
_baseline
_baselineFileExistsInCloud
_hasUploadingBaseline
_monitorUploadingBaselineAsync
_didBaselineCopy
_baselineKV
_votedOffIsland
_reapUbiquitousLogs
_respondToBaselineRoll
_storeFileExists
_storeFileIsReadOnly
_hasStoreMetadataFile
_hasStoreMetadataEntry
_hasContainerUUID
_hasContainerUUIDInStore
_needsMetadataRecovery
_localPeerReceipt
_receiptKV
_preStoreContainerUUID
_usedExistingUUIDMapping
_hasLocalTransactionLogs
_hasMigrationOptions
_didMigrateBaseline
_storeWasMigrated
_migrationAssistant
_replayLogsSynchronously
_useLocalAccount
_seedStore
_seedStoreURL
_haveExistingUUIDMappings
_abortSetup
_gotExportNotification
_sideLoadLock
_logLocationsExportedDuringSideLoad
_gidToRid
_entityNameToGidSet
_initialSyncSemaphore
_initialSyncComplete
_queryLocations
_notifyAboutSetupProgress
_numSetupTries
_retryDelaySec
_failSetup
_failSetupError
_gotAccountChange
_cacheFilePresenterForUbiquityRoot
writeToURL:atomically:encoding:error:
setUUIDStringFromLocation:
writeToDisk:
uuidFileLocation
_uuidString
_uuidFileLocation
_usedExistingUUIDFile
initWithZoneName:
initWithSubscriptionID:
setShouldSendContentAvailable:
setNotificationInfo:
removeNotificationRegistrations
observeChangesForStore:inPersistentStoreCoordinator:
_setUpCloudKitIntegration
requestManager
checkAndExecuteNextRequest
resetAfterError:andKeepContainer:
storesDidChange:
ckAccountOrIdentityChangedHandler:
managedObjectContextSaved:
remoteStoreDidChange:
newActivityWithIdentifier:
registerForSubscription:inDatabase:handler:
checkAndScheduleImportIfNecessary
_openTransactionWithLabel:andExecuteWorkBlock:
subscriptionID
unregisterForSubscriptionWithID:inDatabase:
_enqueueRequest:
_performFetchRecordsRequest:
_performImportWithRequest:
_performExportWithRequest:
_performResetZoneRequest:
_performMetadataResetRequest:
_performSetupRequest:
_performDelegateResetRequest:
resetAfterError:
_finishedRequest:withResult:
_beginWatchingForChanges
recoverFromError:
_requestAbortedNotInitialized:
purgeMetadataFromStore:inMonitor:withOptions:forRecordZones:error:
setMarkZonesAsUserPurged:
_requestEncounteredRecoverableError:withResult:
_requestEncounteredUnrecoverableError:withResult:
_recoverFromPartialError:withMonitor:
_recoverFromError:withMonitor:
postWillResetNotificationForError:
postDidResetNotificationForError:
resetNotificationUserInfoForError:
scheduleExportWithMonitor:
successfullyInitialized
observedStore
lastFetchDate
_dateExceedsSchedulingThreshold:
_executeRequest:
handleErrorInResult:
_setObservedStore:observedCoordinator:
_setZone:
_setAccountNotificationBackoffInterval:
_setRequestManager:
checkForNewChanges
fetchChangesAndUpdateObservedStore
ckDatabaseName
cloudKitQueueSemaphore
cloudKitQueue
observedCoordinator
exporterOptions
hadObservedStore
_ckDatabaseName
_cloudKitQueueSemaphore
_cloudKitQueue
_hadObservedStore
_successfullyInitialized
_exporterOptions
_coredatadClient
_observedStore
_observedCoordinator
_accountChangeNotificationIteration
_requestManager
statusNum
setStatusNum:
status
cacheSQLCorePeerRange:error:
peerRangeStartForPrimaryKey:
cachedRangeForOwningPeerID:andEntityName:withPrimaryKey:
cachedRangeForLocalPrimaryKey:ofEntityNamed:
createMapOfManagedObjectIDsForGlobalIDs:count:error:
initWithPersistentStore:andGlobalObjectIDs:
localPrimaryKeyForOwningPeerID:andEntityName:withPrimaryKey:
prepareForRangeReservationWithRangeStart:andGlobalID:andEntityName:
createLocalIDStringForStoreUUID:entityName:andPrimaryKeyString:
numRangesToReserve
createNewPeerRangesWithCache:Error:
initWithPrivateStore:storeName:andLocalPeerID:
describeCaches
describeCachesVerbose
translatedGlobalIDs
_cachedRanges
_allEntityRanges
_translatedGlobalIDs
_cachedStorePeerRanges
_rangeStart
_rangeEnd
_peerStart
_peerEnd
initWithMetadataStoreFileLocation:
initializePersistentStoreCoordinator:
createMetadataModel
newEntityForName:
newAttributeNamed:attributeType:isOptional:isTransient:withDefaultValue:andMinValue:andMaxValue:
newRelationshipNamed:withDestinationEntity:andInverseRelationship:isOptional:isToMany:andDeleteRule:
addModelingToolUserInfoToEntity:
addModelingToolUserInfoToProperty:
removeAllCoordinatorsForRootLocation:
_rootLocationToPeerIDToEntry
_rootLocationToPeerIDToEntryLock
_cachedModel
_filePresenter
peerEntityNameRangeStartSet
_peerEntityNameRangeStartSet
_globalIDToLocalURI
_unresolvedGlobalObjectIDs
_storeNameToFetchedMetadata
_numRangesToReserve
ancillaryModelFactoryClasses
slotForEntity:
entityForSlot:
clientModel
allEntities
entitiesByPath
clientEntityCount
_clientModel
_allEntities
_models
_indexedEntities
_clientEntityCount
_entityCount
_entitiesByPath
_modelEntityCounts
presentedItemLocation
_presentedItemLocation
_transactionLogCache
_transactionLogCacheLock
_generateIdentifier
_sanityCheckVariables:
_substitutionVariables
_cachedInfo
addTransactionEntry:error:
initWithTransactionEntry:ubiquityRootLocation:andGlobalIDCache:
initWithLocalPeerID:storeName:privateStore:andUbiquityRootLocation:
cachedGlobalIDs
setGlobalIDCache:
_peerIDToHistoryArray
_globalIDToHistoryArray
_peerIDToHistoryArrayLock
_entriesToWrite
_cacheKV
_minCacheKV
_globalIDCache
_hasScheduledWriteBlock
knowledgeVectorString
globalIDStr
createGlobalIDForGlobalIDString:
_globalID
_transactionType
_actingPeerID
createGlobalIDForPrimaryKeyString:entityName:andOwningPeerID:
createGlobalIDForPrimarKey:entityName:andOwningPeerID:
_peerIDToEntityNameToPrimaryKey
_peerIDToEntityNameToPrimaryKeyLock
_appWillResignActive:
writeReceiptFile:error:
peerReceipt
_peerRangeCache
_transactionHistoryCache
_peerReceipt
_pendingReceiptWrite
_receiptFileLock
_allowSchedulingOfReceiptFileWrites
isFileDownloaded:
waitForFileToDownload:
checkSafeSaveFileUploadAsync
setSafeSaveSuccess:
safeSaveFinishedUpload
replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:
setSafeSaveError:
setDownloadSuccess:
downloadFinished
setDownloadError:
safeSaveError
safeSaveSuccess
moveAfterSave
downloadSuccess
downloadError
isRegistered
_permanentLocation
_safeSaveLocation
_currentLocation
_continueCheckingDownload
_downloadSuccess
_downloadError
_continueCheckingUpload
_safeSaveSuccess
_moveAfterSave
_safeSaveError
_safeSaveSemaphore
_isRegistered
ignoredLogLocations
initWithPendingLogLocations:
failedTransactionLogAtLocationRecovered:
unionWithSchedulingContext:
_scheduledLogLocations
_pendingLogLocations
_failedLogLocations
_ignoredLogLocations
_logLocationsToEncounteredErrors
_populateBaselineAndTransactionLogLocations
receiptLocations
canUseReceipts
orderedReceipts
latestTransactionLogForModelVersionHash:
electPreviousModelVersionHashFromTransactionLogsError:
previousModelVersionHash
currentModelVersionHash
_baselineLocationsByVersionHash
_logLocationsByVersionHash
_receiptLocations
_orderedReceipts
_currentModelVersionHash
willChangeContainerState
didChangeContainerState
willChangeMonitorState
didChangeMonitorState
willChangeContainerIdentifier:
containerDeleteDetected:
didChangeContainerIdentifier:
_applicationResumed:
ubiquityIdentityChanged:
setMonitorState:
setContainerIdentifier:transitionType:
scheduleCheckBlock:
checkStoresAndContainer:
setContainerState:
_containerState
_monitorState
_hasScheduledCheckBlock
_scheduleSpinLock
_currentIdentityToken
@48@0:8@16@24@32@40
v16@0:8
B48@0:8@16@24@32^@40
B40@0:8@16@24^@32
@24@0:8@16
@40@0:8@16@24@32
@32@0:8@16@24
B16@0:8
@"NSManagedObjectModel"
@"NSMappingModel"
@"NSString"
@"NSDictionary"
@"NSSet"
@16@0:8
v24@0:8@16
@"PFUbiquityTransactionLog"
@"PFUbiquityStoreSaveSnapshot"
v20@0:8B16
@"NSNumber"
@"CKContainerOptions"
@"CKScheduler"
@"CKNotificationListener"
@"PFCloudKitContainerProvider"
@56@0:8@16@24@32@40@48
B44@0:8B16@20@28^@36
@"PFUbiquityLocation"
B24@0:8^@16
v32@0:8@16@24
@"NSSQLSavePlan"
@"NSFaultHandler"
@"NSMutableDictionary"
B24@0:8@16
Q32@0:8@16@24
Q24@0:8@16
B24@0:8Q16
@36@0:8@16@24B32
@28@0:8@16B24
@36@0:8@16B24^@28
B56@0:8@16@24@32@40^@48
B72@0:8@16@24@32@40@48@56^@64
v64@0:8@16@24@32@40@48@56
v44@0:8@16@24B32@36
@40@0:8@16@24^@32
@"CKRecordZone"
@"NSCloudKitMirroringDelegateOptions"
@"NSObject<PFCloudKitSerializerDelegate>"
@"NSMutableArray"
@"PFCloudKitMetadataCache"
@32@0:8@16@?24
v24@0:8:16
B32@0:8@16^@24
@"NSArray"
@48@0:8@16q24@32@40
q16@0:8
@24@0:8^@16
B32@0:8@16@24
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
Q16@0:8
v24@0:8Q16
@"NSData"
@"NSMutableSet"
@"CKServerChangeToken"
@24@0:8^{_NSZone=}16
Vv16@0:8
@32@0:8@16Q24
@24@0:8Q16
Q40@0:8^{?=Q^@^Q[5Q]}16^@24Q32
v32@0:8Q16@?24
v40@0:8@16Q24@?32
Q32@0:8Q16@?24
Q40@0:8@16Q24@?32
@32@0:8Q16@?24
@40@0:8@16Q24@?32
v32@0:8@16Q24
v32@0:8Q16@24
v24@0:8^@16
@"NSManagedObject"
@"NSPropertyDescription"
{_NSFaultingMutableArrayFlags="_isFault"b1"_reserved"b31}
I16@0:8
v20@0:8I16
v32@0:8:16@24
#16@0:8
{_NSFaultingMutableSetFlags="_isFault"b1"_mustPropagateDelete"b1"_reserved"b14"_relationship"b16}
@32@0:8#16@24
^{objc_method=}
v32@0:8@16@?24
i16@0:8
v20@0:8i16
B32@0:8Q16Q24
@"NSEntityMapping"
@"NSError"
@"NSManagedObjectContext"
q24@0:8@16
B40@0:8@16@24@32
@"NSString"16@0:8
@"NSArray"16@0:8
@48@0:8@16@24@32Q40
@"NSFetchedResultsController"
@"NSSQLEntity"
@"NSExpression"
@"_NSFaultingMutableSetMutationMethods"
v28@0:8@16B24
v32@0:8@16q24
v40@0:8@16@24^{__CFBitVector=}32
@"NSSQLiteStatement"
@"NSSQLiteAdapter"
@"NSMutableString"
@32@0:8r^@16Q24
@32@0:8^@16I24I28
@40@0:8^@16I24I28@32
^@16@0:8
Q40@0:8@16{_NSRange=QQ}24
@32@0:8{_NSRange=QQ}16
v40@0:8^@16{_NSRange=QQ}24
@"_PFWeakReference"
{_PFArrayFlags="shouldRetain"b1"shouldRelease"b1"useExtendedRelease"b1"freeBackingArray"b1"copyBackingArray"b1"managedObjects"b1"_RESERVED"b27}
@36@0:8{_NSRange=QQ}16B32
@32@0:8^?16^v24
@40@0:8^?16^v24@32
@24@0:8:16
@24@0:8@?16
@"_PFArray"
@"NSCachingFetchRequest"
{_PFBatchFaultingArrayFlags="_LRUIndex"b8"_uniformEntity"b1"_RESERVED"b23}
@"NSPersistentHistoryTransaction"
@40@0:8@16{_NSRange=QQ}24
^{__CFArray=}
r^@16@0:8
@32@0:8r^v16r*24
v24@0:8^v16
r*16@0:8
c16@0:8
C16@0:8
s16@0:8
S16@0:8
f16@0:8
d16@0:8
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@40@0:8@16@"NSString"24@"NSSQLEntity"32
B24@0:8@"NSObject<NSSQLAttributeExtension>"16
@"NSPredicate"
@"NSSQLAttribute"
@"NSSQLRelationship"
v24@0:8@?16
B28@0:8B16^@20
@"CKRecordZoneID"
@20@0:8B16
Q24@0:8^@16
v28@0:8Q16I24
^{__CFDictionary=}
^^{__CFDictionary}
{_contextMapTableFlags="_usesWeakReferences"b1"_garbageCollectionEnabled"b1"_reservedFlags"b30}
@"_PFModelMap"
@36@0:8^?16^v24i32
{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}
{_opaque_pthread_cond_t="__sig"q"__opaque"[40c]}
B40@0:8@16^@24^@32
B36@0:8r*16^Q24i32
^v24@0:8@16
v48@0:8@16^v24{_NSRange=QQ}32
q24@0:8r*16
B36@0:8r*16r*24i32
v24@0:8r*16
v28@0:8r*16i24
v40@0:8@16@24@32
v40@0:8^I16@24@32
@40@0:8@16@24Q32
@40@0:8#16@24@32
@40@0:8@16@24#32
^{__CFDictionary=}28@0:8@16B24
^{__CFDictionary=}24@0:8@16
^{_opaque_pthread_t=q^{__darwin_pthread_handler_rec}[8176c]}
S24@0:8Q16
v24@0:8^S16
v40@0:8^S16{_NSRange=QQ}24
r*20@0:8B16
r^S16@0:8
v24@0:8*16
r*24@0:8Q16
v72@0:8@16@24@32@40@48@56Q64
@"NSRelationshipDescription"
@"CKRecordID"
@64@0:8@16@24@32@40@48Q56
@"NSManagedObjectID"
@32@0:8@16^@24
@48@0:8@16@24@32^@40
v24@0:8d16
@"NSURL"
@40@0:8@16Q24@32
B36@0:8@16@24i32
q32@0:8@16@24
B48@0:8^@16@24@32^@40
v32@0:8*16Q24
v72@0:8@16@24@32@40@48@56@64
*16@0:8
#32@0:8@16@24
I28@0:8^@16I24
@32@0:8r*16Q24
q32@0:8*16q24
@24@0:8q16
@20@0:8I16
@"NSProgress"
@48@0:8@16@24@32@?40
@?16@0:8
@"NSAsynchronousFetchRequest"
B36@0:8@16B24^@28
@32@0:8^@16@24
^{_ExtraEntityIVars=@@@@@@ii^v}16@0:8
@"NSEntityDescription"
^{_NSRange=QQ}
{__entityDescriptionFlags="_isAbstract"b1"_shouldValidateOnSave"b1"_isImmutable"b1"_isFlattened"b1"_skipValidation"b1"_hasPropertiesIndexedBySpotlight"b1"_hasPropertiesStoredInTruthFile"b1"_rangesAreInDataBlob"b1"_hasAttributesWithExternalDataReferences"b1"_hasNonstandardPrimitiveProperties"b2"_hasUniqueProperties"b1"_hasChildrenWithUniqueProperties"b1"_validationUniqueProperties"b1"_isPersistentHistoryEntity"b1"_hasAttributesWithFileBackedFutures"b1"_reservedEntityDescription"b16}
^{_ExtraEntityIVars=@@@@@@ii^v}
@40@0:8@16q24@32
B32@0:8@16@?24
^{_NSRange=QQ}16@0:8
Q36@0:8Q16@24B32
^v24@0:8Q16
^v16@0:8
v24@0:8q16
{__entityMappingFlags="_isInUse"b1"_changeIsSchemaCompatible"b1"_reservedEntityMapping"b30}
@"NSSQLCore"
@28@0:8I16d20
d24@0:8@16
v44@0:8@16@24I32d36
{_externalRefFlags_st="_invalidToOnes"b1"_hasTemporaryID"b1"_backgroundDealloc"b1"_reservedFlags"b1"_virtualfk_count"b14"_ordkey_count"b14}
@"NSXPCStore"
@"NSCoreDataXPCMessage"
@"NSPersistentStoreCoordinator"
@"NSFetchRequest"
{_fetchRequestFlags="distinctValuesOnly"b1"includesSubentities"b1"includesPropertyValues"b1"resultType"b3"returnsObjectsAsFaults"b1"excludePendingChanges"b1"isInUse"b1"entityIsName"b1"refreshesRefetched"b1"propertiesValidated"b1"disableCaching"b1"allocationType"b3"_RESERVED"b16}
{_fetchExpressionFlags="isCountOnly"b1"_RESERVED"b31}
^{__CFArray=}32@0:8r^*16Q24
v32@0:8r^@16Q24
@32@0:8^@16Q24
@48@0:8^@16Q24^v32@40
@40@0:8^@16^@24Q32
v28@0:8^@16B24
Q44@0:8^{?=Q^@^Q[5Q]}16^@24Q32B40
v32@0:8^@16^@24
@"NSKnownKeysMappingStrategy"
[0@]
@60@0:8r^@16@24r^@32{_NSRange=QQ}40B56
{_NSRange="location"Q"length"Q}
@32@0:8Q16@24
v40@0:8Q16@24@32
v40@0:8@16Q24@32
B40@0:8^@16@24^@32
@36@0:8^I16^I24B32
v32@0:8{_NSRange=QQ}16
v40@0:8@16@24Q32
@40@0:8@16q24q32
v48@0:8@16@24@32@40
v48@0:8@16@24Q32@40
@52@0:8i16@20@28@36@44
B56@0:8^@16@24@32Q40^@48
v72@0:8@16@24^@32^@40^@48^@56^@64
@"NSObject<OS_dispatch_queue>"
B32@0:8^@16^@24
^?24@0:8:16
v48@0:8@16@24q32q40
^{?=i^v@QCQ^v[32C]*{_moFactoryClassFlags=b1b1b1b1b1b1b26}}16@0:8
#24@0:8@16
I36@0:8^@16@24I32
@36@0:8@16@24I32
v48@0:8@16@24@32^v40
Q32@0:8@16^@24
B36@0:8@16B24@28
v56@0:8@16@24:32B40^v44B52
v40@0:8@16:24^v32
v36@0:8@16B24^{?=@:^v}28
{_managedObjectContextFlags="_registeredForCallback"b1"_propagatesDeletesAtEndOfEvent"b1"_exhaustiveValidation"b1"_processingChanges"b1"_useCommittedSnapshot"b1"_registeredUndoTransactionID"b1"_retainsAllRegisteredObjects"b1"_savingInProgress"b1"_wasDisposed"b1"_unprocessedChangesPending"b1"_isDirty"b1"_ignoreUndoCheckpoints"b1"_propagatingDeletes"b1"_isNSEditorEditing"b1"_isMainThreadBlessed"b1"_isImportContext"b1"_preflightSaveInProgress"b1"_disableDiscardEditing"b1"_isParentStoreContext"b1"_postSaveNotifications"b1"_isMerging"b1"_concurrencyType"b1"_deleteInaccessible"b1"_priority"b2"_autoMerge"b1"_isXPCServerContext"b1"_pushSecureDelete"b1"_refreshAfterSave"b1"_allowAncillary"b1"_generatedMutatedIDsNotification"b1"_reservedFlags"b1}
Q48@0:8@16@24@32^@40
v32@0:8@16B24B28
v36@0:8^@16Q24B32
I48@0:8^@16I24^@28@36B44
v36@0:8@16@24B32
B44@0:8@16I24^@28B36B40
v28@0:8I16Q20
v40@0:8:16@24@32
v60@0:8@16@24@32@40@48B56
@32@0:8@16^#24
v32@0:8@16:24
B24@0:8^{__CFArray=}16
^{__CFRunLoopObserver=}
@"NSKnownKeysDictionary"
{__managedObjectModelFlags="_isInUse"b1"_isImmutable"b1"_isOptimizedForEncoding"b1"_hasEntityWithConstraints"b1"_skipUserInfoTombstones"b1"_reservedEntityDescription"b27}
B40@0:8@16Q24@32
v28@0:8B16Q20
{?=[8I]}16@0:8
@"NSXPCStoreServerPerConnectionCache"
{?="val"[8I]}
@64@0:8{?=[8I]}16@48@56
@"NSXPCStoreConnectionInfo"
@"NSSQLitePrefetchRequestCache"
@"NSObject<OS_os_transaction>"
@"NSBundle"
@"NSPersistentStoreMap"
{__modelMappingFlags="_isInUse"b1"_reservedModelMapping"b31}
@36@0:8@16B24@28
Vv32@0:8@16@?24
Vv32@0:8@"NSCoreDataXPCMessage"16@?<v@?@"NSCoreDataXPCMessage"@"NSData">24
@"NSXPCConnection"
@56@0:8@16@24@32@40^@48
@32@0:8@16q24
@40@0:8@16@24q32
@"NSPersistentStore"
@"NSPersistentHistoryToken"
@"PFCloudKitImporterOptions"
@"NSCloudKitMirroringImportRequest"
@56@0:8@16Q24Q32@40@48
@64@0:8@16Q24Q32@40@48@56
B36@0:8@16@24B32
v52@0:8@16@24@32@40B48
D16@0:8
v32@0:8D16
@"PFUbiquityKnowledgeVector"
@"NSMigrationManager"
@"NSPropertyMapping"
B80@0:8@16@24@32@40@48@56@64^@72
@"NSMigrationContext"
{_migrationManagerFlags="_migrationWasCancelled"b1"_usesStoreSpecificMigrationManager"b1"_migrationWasInPlace"b1"_reservedMigrationManager"b29}
{_objectStoreFlags="isReadOnly"b1"cleanOnRemove"b1"isMDDirty"b1"_RESERVED"b29}
B56@0:8@16^B24^B32^@40@48
@28@0:8^v16B24
i24@0:8@16
v36@0:8@16@24I32
@32@0:8@16d24
v60@0:8@16@24@32@40I48d52
v56@0:8@16@24@32@40d48
@40@0:8@16@24d32
^{?=q^?^?^?^?}
{persistentStoreCacheFlags="_preserveToManyRelationships"b1"_reserved"b31}
v32@0:8#16@24
v32@0:8@?16@24
v44@0:8@16@24B32@?36
B64@0:8@16@24@32@40@48^@56
@32@0:8@16^i24
{_persistentStoreCoordinatorFlags="_isRegistered"b1"_canUseDirectDispatch"b1"_reservedFlags"b30}
@40@0:8r*16Q24^@32
B48@0:8@16@24^{__CFSet=}32^{__CFSet=}40
#40@0:8@16@24@32
@32@0:8@16^Q24
@"NSIndexPath"
@"_NSDefaultSectionInfo"
@"NSMappedObjectStore"
^{_NSExtraPropertyIVars=@qq}
{__propertyDescriptionFlags="_isReadOnly"b1"_isTransient"b1"_isOptional"b1"_isIndexed"b1"_skipValidation"b1"_isIndexedBySpotlight"b1"_isStoredInExternalRecord"b1"_extraIvarsAreInDataBlob"b1"_isOrdered"b1"_hasMaxValueInExtraIvars"b1"_hasMinValueInExtraIvars"b1"_storeBinaryDataExternally"b1"_preserveValueOnDelete"b1"_isTriggerBacked"b1"_isFileBackedFuture"b1"_reservedPropertyDescription"b1}
^{_NSExtraPropertyIVars=@qq}16@0:8
@"NSEntityDescription"16@0:8
@"NSPredicate"16@0:8
{_requestFlags="includesSubentities"b1"resultType"b2"entityIsName"b1"secureOperation"b1"_RESERVED"b27}
{__propertyMappingFlags="_isInUse"b1"_reservedPropertyMapping"b31}
@"NSObject"
@"NSAttributeDescription"
@"NSPropertyTransform"
v40@0:8*16Q24@32
@"NSNotification"
v20@0:8c16
C32@0:8Q16Q24
@36@0:8@16C24@28
@40@0:8@16C24@28B36
@28@0:8q16C24
@24@0:8I16C20
v20@0:8C16
{_insertRequestFlags="resultType"b2"entityIsName"b1"secureOperation"b1"_RESERVED"b28}
Vv32@0:8@"CDDCloudKitMessage"16@?<v@?@"CDDCloudKitResponse">24
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
@"NSXPCListener"
@"CDDCloudKitServerConfiguration"
@"NSPersistentContainer"
@"NSObject<OS_dispatch_group>"
@28@0:8@16C24
@44@0:8@16C24@28@36
B36@0:8@16C24@28
C24@0:8@16
@"NSURL"16@0:8
@"NSOperationQueue"16@0:8
v24@0:8@?<v@?@?<v@?>>16
v24@0:8@?<v@?@"NSError">16
v24@0:8@"NSURL"16
v24@0:8@"NSSet"16
v24@0:8@"NSFileVersion"16
v32@0:8@"NSURL"16@?<v@?@"NSError">24
v32@0:8@"NSURL"16@"NSURL"24
v32@0:8@"NSURL"16@"NSFileVersion"24
@"NSSet"16@0:8
@"NSSQLModel"16@0:8
@"NSDictionary"16@0:8
^{_NSScalarObjectID=#}32@0:8@16q24
^{_NSScalarObjectID=#}32@0:8q16@24
v52@0:8@16@24@32B40@44
v36@0:8B16@20@28
@40@0:8@16^@24^@32
@"NSSQLModel"
@"NSSQLiteConnection"
@"NSSQLCoreDispatchManager"
@"NSGenerationalRowCache"
{_sqlCoreFlags="useSyntaxColoredLogging"b1"hasExternalDataReferences"b1"fileProtectionType"b3"notifyFOKChanges"b1"initializationComplete"b1"connectionsAreLocal"b1"isXPCDelegate"b1"queryGenerationInitializationFailed"b1"persistentHistoryTracking"b1"hasAncillaryModels"b1"postRemoteNotify"b1"hasFileBackedFutures"b1"isInMemory"b1"_RESERVED"b17}
@44@0:8@16@24Q32B40
@"NSFetchIndexDescription"
{__indexElementDescriptionFlags="_ascending"b1"_propertyIsRetained"b1"_unique"b1"_reservedEntityDescription"b29}
I24@0:8@16
I28@0:8@16I24
{_NSRange=QQ}16@0:8
@"NSSQLPrimaryKey"
@"NSSQLEntityKey"
@"NSSQLOptLockKey"
@"NSSQLStoreMappingGenerator"
@"NSSQLEntity_DerivedAttributesExtension"
{__sqlentityFlags="_hasAttributesWithExternalDataReferences"b1"_hasAttributesWithFileBackedFutures"b1"_reserved"b30}
@"NSSQLSelectIntermediate"
@"NSSQLGroupByIntermediate"
@"NSSQLHavingIntermediate"
@"NSSQLOffsetIntermediate"
@"CKDatabase"
@"NSSQLForeignKey"
@"NSSQLToOne"
@"NSUUID"
v56@0:8@16@24@32^^Q40^*48
I48@0:8@16@24@32@40
I40@0:8@16@24@32
@112@0:8@16@24@32@40@48@56@64q72@80@88^^Q96^*104
v44@0:8@16@24d32B40
@"NSSQLSaveChangesRequestContext"
{_sqlSaveFlags="notifyFOKChanges"b1"hasChanges"b1"reserved"b30}
@"NSCKRecordMetadata"
@32@0:8@16B24I28
@44@0:8@16B24I28B32@36
@48@0:8@16B24B28I32B36@40
@48@0:8@16@24^Q32^@40
@"NSXPCStoreConnectionManager"
@"NSXPCStoreNotificationObserver"
v56@0:8@16@24@32d40@48
@"NSSQLIntermediate"
@20@0:8C16
@40@0:8@16@24^{__CFBitVector=}32
@36@0:8@16B24B28I32
B48@0:8@16^{__CFDictionary=}24^{__CFDictionary=}32^@40
@44@0:8@16@24@32B40
@56@0:8@16^{__CFDictionary=}24^{__CFDictionary=}32^{__CFDictionary=}40^@48
B48@0:8@16@24^{__CFDictionary=}32^@40
B64@0:8@16^{__CFDictionary=}24^{__CFDictionary=}32^{__CFDictionary=}40@48^@56
@24@0:8^{sqlite3_snapshot=[48C]}16
r^v16@0:8
^{sqlite3_snapshot=[48C]}
i56@0:8r*16@24^^{sqlite3}32i40r*44B52
i32@0:8r*16@24
r*24@0:8@16
^{__CFArray=}24@0:8@16
v24@0:8i16B20
v32@0:8@16^{__CFBitVector=}24
@32@0:8@16^{__CFBitVector=}24
v48@0:8Q16Q24Q32Q40
@36@0:8@16I24^{sqlite3_stmt=}28
i32@0:8^v16@24
^{sqlite3_stmt=}16@0:8
B28@0:8@16B24
q28@0:8@16I24
^^v16@0:8
v24@0:8B16B20
B32@0:8{_NSRange=QQ}16
v52@0:8i16@20@28@36@44
Q32@0:8@?16@24
v48@0:8@16q24q32@40
v40@0:8@16q24@32
i32@0:8@16Q24
v56@0:8r*16q24q32r*40q48
^{sqlite3=}
^{sqlite3_stmt=}
[5^v]
{__sqliteConnectionFlags="_readyToBind"b1"_fetchInProgress"b1"_fileSystemType"b2"_proxyLocking"b1"_vacuumSetupNeeded"b1"_usingWAL"b1"_disallowReconnect"b1"_isWriter"b1"_didSnapshotRecovery"b1"_hasTransactionStringTable"b1"_reserved"b21}
@"CDDCloudKitMessage"
@"PFCloudKitExporterOptions"
@"PFCloudKitSerializer"
@40@0:8@?16@24@32
@52@0:8@16B24@28@36@44
@64@0:8@16@24@32@40@48@56
@60@0:8@16@24@32@40B48@52
@52@0:8@16@24B32^@36@44
v40@0:8@"PFCloudKitSerializer"16@"PFMirroredRelationship"24@"NSError"32
v32@0:8@"PFCloudKitSerializer"16@"NSCKImportPendingRelationship"24
@"NSURL"32@0:8@"PFCloudKitSerializer"16@"CKAsset"24
@"NSFileHandle"
@44@0:8@16@24B32Q36
v32@0:8Q16Q24
@"NSSQLRowCache"
{?="principal_entity_has_subentities"b1"fetch_only_primary_keys"b1"fetch_results_style"b3"use_clean_memory"b1"_reserved"b26}
q48@0:8@16@24@32@40
@"NSXPCStoreServerRequestHandlingPolicy"
@"NSMapTable"
v24@0:8@"NSPredicate"16
v24@0:8@"NSExpression"16
v24@0:8@"NSPredicateOperator"16
@"NSCloudKitMirroringExportRequest"
@"NSCloudKitMirroringDelegateSetupRequest"
@"NSCloudKitMirroringDelegateResetRequest"
@"NSCloudKitMirroringResetZoneRequest"
@"NSCloudKitMirroringFetchRecordsRequest"
@"NSCloudKitMirroringResetMetadataRequest"
@"NSCloudKitMirroringRequest"
v28@0:8i16@20
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
^{__CFDictionary=}16@0:8
v40@0:8@16@24^{__CFDictionary=}32
q32@0:8@16^@24
^{?=i^v@QCQ^v@*{_moFactoryClassFlags=b1b1b1b1b1b1b26}}16@0:8
{_sqlColumnFlags="_allowAliasing"b1"_unique"b1"_constrained"b1"_backedByTrigger"b1"_isDerivedAttribute"b1"_reservedFlags"b11}
I52@0:8^@16I24@28^^{_NSScalarObjectID}36d44
@32@0:8@16^{_NSScalarObjectID=#}24
@40@0:8@16^{_NSScalarObjectID=#}24d32
^{_NSScalarObjectID=#}24@0:8@16
^{_NSScalarObjectID=#}16@0:8
v24@0:8^{_NSScalarObjectID=#}16
v28@0:8I16q20
v24@0:8I16I20
q20@0:8I16
I20@0:8I16
^{__CFBitVector=}32@0:8@16Q24
^{__CFBitVector=}24@0:8@16
^{__CFBitVector=}16@0:8
@"_CDSnapshot"
@"NSObject<OS_dispatch_semaphore>"
q24@0:8Q16
@32@0:8@16B24B28
@52@0:8@16@24B32B36B40@44
@32@0:8B16B20@24
v56@0:8@16@24@32@40@?48
@"PFCloudKitStoreMonitor"
@"NSObject<PFCloudKitExporterDelegate>"
@"PFCloudKitExportContext"
v32@0:8^{sqlite3_stmt=}16@24
@"NSCachedFetchRequestInfo"
@32@0:8^S16Q24
@"NSSQLFetchIntermediate"
@"NSSQLColumn"
v40@0:8@16@24@?32
@"_PFFetchPlanHeader"
@"NSSQLFetchRequestContext"
@"NSSQLForeignEntityKey"
@"NSSQLForeignOrderKey"
@28@0:8@16i24
@44@0:8^{?=IdQIIII{?=b1b1b1b1b28}i^^v^I^v^v}16I24@28@36
^{?=IdQIIII{?=b1b1b1b1b28}i^^v^I^v^v}16@0:8
^{?=IdQIIII{?=b1b1b1b1b28}i^^v^I^v^v}
^Q16@0:8
@24@0:8^v16
@32@0:8^Q16Q24
@"_PFResultArray"
@56@0:8r^@16@24^Q32{_NSRange=QQ}40
v56@0:8@16@24@32@40@48
@64@0:8@16@24@32@40@48^@56
@24@0:8*16
{_double_quad_uint="high64"Q"low64"Q}
@"_NS128bitWrapper"
@32@0:8@16^v24
q32@0:8@16q24
{_fetchResultsControllerFlags="_changedResultsSinceLastSave"b1"_hasBatchedArrayResults"b1"_hasMutableFetchedResults"b1"_hasSections"b1"_includesSubentities"b1"_sendDidChangeContentDiffNotifications"b1"_sendDidChangeContentNotifications"b1"_sendDidChangeContentSnapshotNotifications"b1"_sendObjectChangeNotifications"b1"_sendSectionChangeNotifications"b1"_sendSectionIndexTitleForSectionName"b1"_sendWillChangeContentNotifications"b1"_usesNonpersistedProperties"b1"_reservedFlags"b19}
Q24@0:8Q16
v32@0:8@16^q24
Q56@0:8@16@24q32q40@48
@32@0:8@16^B24
B40@0:8@16@24^B32
v24@0:8{_NSSQLMigrationContext=@}16
@32@0:8@16{_NSSQLMigrationContext=@}24
v32@0:8@16{_NSSQLMigrationContext=@}24
^{sqlite3_intarray=}16@0:8
v24@0:8^{sqlite3_intarray=}16
^{sqlite3_intarray=}
@"NSSQLUpdateColumnsIntermediate"
q40@0:8@16@24@32
@?32@0:8@16@24
v36@0:8@16@24i32
@"NSSQLBinaryIndex"
B32@0:8@16{_NSSQLMigrationContext=@}24
B24@0:8{_NSSQLMigrationContext=@}16
@52@0:8@16@24@32B40{_NSSQLMigrationContext=@}44
@"NSSQLWhereIntermediate"
B48@0:8@16@24Q32^@40
v32@0:8^v16Q24
v40@0:8^v16{_NSRange=QQ}24
{_NSRange=QQ}48@0:8@16Q24{_NSRange=QQ}32
B40@0:8@16Q24^@32
B20@0:8B16
@44@0:8@16@24@32i40
@52@0:8r^v16Q24@32@40i48
@60@0:8r^v16Q24@32@40i48@52
v24@0:8r^v16
{__externalDataFlags="_isStoredExternally"b1"_hasMappedData"b1"_cleanupOnDealloc"b1"_dataProtectionLevel"b3"_isStoredUbiquitously"b1"_createdByUbiquityImport"b1"_reserved"b24}
v48@0:8@16@24^^Q32^*40
v40@0:8r^@16Q24Q32
v48@0:8{_NSRange=QQ}16Q32@?40
{_NSFaultingMutableOrderedSetFlags="_isFault"b1"_mustPropagateDelete"b1"_ignoringIdempotentKVO"b1"_mustCopyOnWrite"b1"_isImmutableCopy"b1"_reserved"b11"_relationship"b16}
I36@0:8^@16I24^@28
{_snapshotFlags_st="_readOnly"b1"_reservedFlags"b7}
Q24@0:8@?16
Q56@0:8@16{_NSRange=QQ}24Q40@?48
v40@0:8^@16Q24Q32
v48@0:8{_NSRange=QQ}16r^@32Q40
@"NSMutableOrderedSet"
@"_NSFaultingMutableOrderedSetMutationMethods"
B40@0:8@16^B24@32
@"CKContainer"
@"CKDatabaseSubscription"
@"NSPersistentStoreCache"
q48@0:8@"NSManagedObjectContext"16@"NSManagedObject"24@"NSManagedObjectID"32@"NSPropertyDescription"40
B44@0:8@16i24@28^@36
@"PFUbiquitySwitchboardEntry"
@"PFUbiquityImportContext"
@44@0:8@16i24@28@36
@"NSDate"
@"NSLock"
v32@0:8d16@?24
v24@0:8@"_PFUbiquityRecordImportOperation"16
v32@0:8@"_PFUbiquityRecordImportOperation"16@"NSError"24
v24@0:8@"PFUbiquityBaselineRollOperation"16
v32@0:8@"PFUbiquityBaselineRecoveryOperation"16@"PFUbiquityBaseline"24
v40@0:8@"PFUbiquityBaselineRecoveryOperation"16@"NSError"24@"PFUbiquityBaseline"32
v32@0:8@"PFUbiquityBaselineRollResponseOperation"16@"PFUbiquityBaseline"24
v40@0:8@"PFUbiquityBaselineRollResponseOperation"16@"NSError"24@"PFUbiquityBaseline"32
@"NSOperationQueue"
@"PFUbiquityRecordsImporterSchedulingContext"
@"PFUbiquitySwitchboardCacheWrapper"
@"NSObject<OS_dispatch_source>"
@"NSRecursiveLock"
@"PFUbiquityMetadataFactoryEntry"
@"NSPersistentStoreRequest"
@"NSException"
@56@0:8@16B24B28@32@40@48
@44@0:8@16B24@28@36
@52@0:8@16B24@28@36^@44
@56@0:8@16@?24@32@40^@48
@36@0:8@16i24@28
B20@0:8i16
@20@0:8i16
v48@0:8@16@24@32@?40
i36@0:8i16@20^B28
B56@0:8@16@24@32I40I44^@48
B52@0:8@16@24B32^@36@?44
@"PFUbiquityFilePresenter"
@"PFUbiquityContainerMonitor"
@"PFUbiquitySwitchboardEntryMetadata"
@"PFUbiquitySetupAssistant"
@"_PFUbiquityRecordsImporter"
@"_PFUbiquityRecordsExporter"
@"PFUbiquityBaselineHeuristics"
@"PFHistoryAnalyzerOptions"
@"NSSQLManyToMany"
B52@0:8@16Q24B32^@36@?44
B32@0:8@16^B24
{__persistentHistoryChangeRequestDescriptionFlags="_useQueryGenerationToken"b1"_deleteHistoryRequest"b1"_fetchTransactionForToken"b1"_reservedPersistentHistoryChangeRequestDescription"b29}
@32@0:8q16@24
B40@0:8@16q24q32
@28@0:8B16^@20
@"PFUbiquityBaselineMetadata"
@"_PFZipFileArchive"
@56@0:8@16q24@32@40^@48
@40@0:8Q16Q24@32
@52@0:8@16@24@32B40@44
@"NSSaveChangesRequest"
@"PFCloudKitStoreComparisonCache"
@"NSCloudKitMirroringRequestOptions"
@48@0:8@16@24Q32@40
@72@0:8@16@24@32@40Q48@56Q64
@44@0:8@16i24@28^@36
@"PFUbiquityGlobalObjectIDCache"
B32@0:8^@16@24
@"PFUbiquitySaveSnapshot"
@"_PFUbiquityStack"
@"PFUbiquityStoreMetadata"
@"PFUbiquityPeer"
@"NSPersistentStoreDescription"
@44@0:8i16@20@28@36
@60@0:8i16@20@28@36@44@52
B56@0:8@16@24@32@?40^@48
B44@0:8@16@24B32^@36
@"NSSQLLimitIntermediate"
@"NSSQLOrderIntermediate"
v28@0:8I16@20
v28@0:8S16@20
I32@0:8r*16^Q24
S32@0:8r*16^Q24
@40@0:8r*16^Q24Q32
@40@0:8@16Q24^@32
B32@0:8r*16Q24
B40@0:8@16r^v24^@32
B36@0:8r*16I24@28
i24@0:8^@16
{__zFlags="providerSuppliesContents"b1"providerSuppliesStreams"b1"providerSuppliesProperties"b1"noContentsCaching"b1"fileOpen"b1"reserved"b27}
@"PFZipEndOfCentralDirectoryRecord"
Q32@0:8@16Q24
Q32@0:8r*16Q24
v20@0:8S16
@"NSUUID"16@0:8
@48@0:8q16@24@32^@40
@"NSInputStream"
@72@0:8@16@24Q32@40@48^@56^@64
@"CKOperationConfiguration"
B48@0:8@16^B24@32^@40
@40@0:8@16@24^B32
B36@0:8B16@20^@28
@"<NSObject><NSCopying><NSCoding>"
@"PFUbiquityPeerState"
@"PFUbiquityBaseline"
@"PFUbiquityPeerReceipt"
@"PFUbiquityContainerIdentifier"
@"PFUbiquityMigrationAssistant"
@"PFUbiquityMigrationManager"
v32@0:8@"PFCloudKitExporter"16@"NSArray"24
B40@0:8@"NSManagedObjectModel"16@"NSPersistentStoreDescription"24^@32
v40@0:8@"NSPersistentStoreCoordinator"16@"NSPersistentStore"24@"NSPersistentStoreDescription"32
B56@0:8@16@24Q32@40^@48
@"CDDCloudKitClient"
@"NSCloudKitMirroringRequestManager"
Q40@0:8@16@24Q32
@40@0:8@16q24^@32
@64@0:8@16Q24B32B36@40@48@56
@56@0:8@16@24@32B40B44Q48
@"PFUbiquityMetadataFactoryFilePresenter"
@"PFUbiquityGlobalObjectID"
@40@0:8Q16@24@32
@"PFUbiquityPeerRangeCache"
@"PFUbiquityTransactionLogCache"
@"PFUbiquityTransactionHistoryCache"
B32@0:8B16B20^@24
