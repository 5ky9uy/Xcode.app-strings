@(#)PROGRAM:StatusKit  PROJECT:StatusKit-1
statusPayload
statusUniqueIdentifier
datePublished
dateReceived
dateCreated
invitationPayload
<%@: %p; identifier = "%@"; payload = "%@"; datePublished = "%@"; dateReceived = "%@"; dateCreated = "%@">
payload
v8@?0
com.apple.StatusKit
SKPresencePayload
<%@: %p; payloadDictionary = "%@">;
<%@: %p; payloadData = "%@">;
subscriptionToken
encryptionToken
<%@: %p; subscriptionValidationToken = "%@", encryptionValidationToken = "%@">
payloadData
SKInvitationPayload
<%@: %p; payloadDictionary = "%@"; dateCreated = "%@">;
<%@: %p; payloadData = "%@"; dateCreated = "%@">;
subscriptionIdentifier
statusTypeIdentifier
isPersonalStatusSubscription
currentStatus
ownerHandles
<%@: %p; subscriptionID = "%@"; personal = YES; status = "%@">
<%@: %p; subscriptionID = "%@"; owners = "%@"; status = "%@">
v16@?0@"NSError"8
PresenceDaemonConnection
com.apple.StatusKit.presence
SKStatusPublishingErrorDomain
com.apple.StatusKit.PublishingService
v24@?0@"NSString"8@"NSError"16
v24@?0@"NSArray"8@"NSError"16
v20@?0B8@"NSError"12
v24@?0@"SKHandleInvitability"8@"NSError"16
com.apple.StatusKit.publish.types
v16@?0@"<SKStatusPublishingServiceDelegate>"8
PublishingService
PublishingDaemonConnection
com.apple.StatusKit.publish
SKStatusPayload
deviceTokenURI
selfDevice
selfHandle
-[SKPresentDevice initWithHandle:deviceIdentifier:deviceTokenURI:payload:assertionTime:selfHandle:selfDevice:]
SKPresentDevice.m
handle
deviceIdentifier
assertionTime
<%@: %p; handle = "%@"; deviceIdentifier = "%@"; deviceTokenURI = "%@"; payload = "%@"; assertionTime = "%@"; selfDevice = "%d"; selfHandle = "%d">
SKPresentDevice
<nil>
SKStatusSubscription
IsInvitable
WasRemoved
SKHandleInvitability
<%@: %p; isInvitable = "%d"; wasRemoved = "%d">;
SKPresenceErrorDomain
-[SKPresence initWithPresenceIdentifier:isPersonal:]
SKPresence.m
presenceIdentifier
com.apple.StatusKit.Presence
-[SKPresence _fetchHandleInvitability:fromSenderHandle:completion:]
completionHandler
-[SKPresence _inviteHandles:fromSenderHandle:completion:]
-[SKPresence fetchPresenceCapability:]
v12@?0B8
v16@?0@"<SKPresenceDelegate>"8
SKPresence
StatusKit-oversized
scheduledRequest
secondaryDeviceRepublish
<%@: %p; identifier = "%@"; payload = "%@"; dateCreated = "%@"; scheduled=%ld, republish=%ld>
SKStatusSubscriptionErrorDomain
com.apple.StatusKit.SubscriptionService
v24@?0@"SKStatusSubscriptionMetadata"8@"NSError"16
v24@?0@"SKSubscriptionValidationTokens"8@"NSError"16
v24@?0q8@"NSError"16
v16@?0@"<SKStatusSubscriptionServiceDelegate>"8
com.apple.StatusKit.subscribe.types
SubscriptionService
handleString
<%@: %p; handleString = "%@">
StatusSubscriptionDaemonConnection
com.apple.StatusKit.subscribe
Error serializing presence payload dictionary: %@
Error deserializing presence payload data as dictionary: %@
Error serializing status payload dictionary: %@
Error deserializing status payload data as dictionary: %@
XPC Error (async): %{public}@
XPC Error (synchronous): %{public}@
XPC connection to PID %ld invalidated
XPC connection to PID %ld interrupted
Publishing status request. StatusType: %{public}@ Request: %@
XPC Error publishing status request. StatusType: %{public}@ statusRequest:%@ Error: %{public}@
Publish status request failed with error: %@
Publish status request completed with statusUniqueIdentifier: %@
Retrieving invited handles. StatusType: %{public}@
XPC Error retrieving invited handles. StatusType: %{public}@ Error: %{public}@
Retreived invited handles. StatusType: %{public}@ Handles: %@ Error: %@
Retreived invited handles. StatusType: %{public}@ Handles: %@
Checking if handle %@ has already been invited (sync) from handle: %@. StatusType: %{public}@
XPC Error checking if handle is invited (sync). StatusType: %{public}@ Error: %{public}@
Checked if handle is invited (sync). StatusType: %{public}@ Handle: %@ isInvited:%d Error: %@
Determined if handle is invited (sync). StatusType: %{public}@ Handle: %@ isInvited: %d
Checking if handle %@ has already been invited (async) from handle: %@. StatusType: %{public}@
XPC Error checking if handle is invited (async). StatusType: %{public}@ handle:%@ Error: %{public}@
Error while checking if handle has already been invited (async). StatusType: %{public}@ Handle: %@ isInvited:%d Error: %@
Checked if handle is invited (async). StatusType: %{public}@ Handle: %@ isInvited: %d
Fetching handle %@ invitability. StatusType: %{public}@
XPC Error checking invitability. StatusType: %{public}@ handle:%@ Error: %{public}@
Error fetching handle invitability. StatusType: %{public}@ Handle: %@ invitability:%@ Error: %@
Checked if handle is invitable. StatusType: %{public}@ Handle: %@ invitability: %@
Checking if handle %@ is inviteable. StatusType: %{public}@
XPC Error checking inviteability. StatusType: %{public}@ handle:%@ Error: %{public}@
Error while checking if handle is inviteable. StatusType: %{public}@ Handle: %@ isInviteable:%d Error: %@
Checked if handle is inviteable. StatusType: %{public}@ Handle: %@ isInviteable: %d
Received request to invite handles: %@ to personal channel with statusTypeIdentifier: %{public}@ from sender handle: %@
XPC Error inviting handles. StatusType: %{public}@ handles:%@ Error: %{public}@
Inviting handles completed with error: %@
Inviting handles completed.
Removing invited handles. StatusType: %{public}@ Handles: %@
XPC Error removing invited handles. StatusType: %{public}@ handles:%@ Error: %{public}@
Remove invited handles completed with error: %@
Remove invited handles completed.
Removing all invited handles. StatusType: %{public}@
XPC Error removing all invited handles. StatusType: %{public}@ Error: %{public}@
Remove all invited handles completed with error: %@
Remove all invited handles completed.
Registering for delegate callbacks for statusTypeIdentifier: %{public}@
XPC Error registering for delegate callbacks. Error: %{public}@
Error registering for delegate callbacks. Error: %@
Completed registration for delegate callbacks for statusTypeIdentifier: %@
Client is attempting to publish status of type %{public}@ but is not entitled. Client needs %@ entitlement with this status type identifier.
No delegates available to perform publishing service delegate callback
Notifying publishing service delegate that the XPC connection has disconnected
Subscription publishing delegate does not implement the delegate method to be notified the XPC connection has disconnected
XPC Connection Invalidation Handled
XPC Connection Interruption Handled
Deallocing SKPresentDevice for handle "%@"
Retaining transient subscription assertion for subscriptionIdentifier %@
XPC Error retaining transient subscription assertion. Error: %{public}@
Error retaining transient subscription assertion. Error: %{public}@
Successfully retained transient subscription assertion for subscription identifier %@
Releasing transient subscription assertion for subscriptionIdentifier %@
XPC Error releasing transient subscription assertion. Error: %{public}@
Error releasing transient subscription assertion. Error: %{public}@
Successfully released transient subscription assertion for subscription identifier %@
Retaining persistent subscription assertion for subscriptionIdentifier %@ applicationIdentifier %@
XPC Error retaining persistent subscription assertion. Error: %{public}@
Error retaining persistent subscription assertion. Error: %{public}@
Successfully retained persistent subscription assertion for subscription identifier %@ applicationIdentifier %@
Releasing persistent subscription assertion for subscriptionIdentifier %@ applicationIdentifier %@
XPC Error releasing persistent subscription assertion. Error: %{public}@
Error releasing persistent subscription assertion. Error: %{public}@
Successfully released persistent subscription assertion for subscription identifier %@ applicationIdentifier %@
Deleting subscription with subscriptionIdentifier %@
Error deleting subscription with identifier %@. Error: %{public}@
Successfully deleting subscription with identifier %@
Asserting presence for %@ with payload %@
XPC Error retaining presence assertion. Error: %{public}@
Error asserting presence. Error: %{public}@
Successfully asserted presence for presence identifier %@
Releasing presence for  %@
XPC Error releasing presence assertion. Error: %{public}@
Error releasing presence. Error: %{public}@
Successfully released presence for presence identifier %@
Retaining transient subscription assertion for presenceIdentifier %@
Successfully retained transient subscription assertion for presence identifier %@
Releasing transient subscription assertion for presenceIdentifier %@
Successfully released transient subscription assertion for presence identifier %@
Retrieving present decives. Presence: %{public}@
XPC Error retrieving invited handles. Presence: %{public}@ Error: %{public}@
Retrieved present devices. Presence: %{public}@ Handles: %@ Error: %@
Retrieved present devices. Presence: %{public}@ Handles: %@
Retrieving invited handles. Presence: %{public}@
Retrieved invited handles. Presence: %{public}@ Handles: %@ Error: %@
Retrieved invited handles. Presence: %{public}@ Handles: %@
Checking if handle %@ has already been invited (sync) from handle: %@. Presence: %{public}@
XPC Error checking if handle is invited (sync). Presence: %{public}@ Error: %{public}@
Checked if handle is invited (sync). Presence: %{public}@ Handle: %@ isInvited:%d Error: %@
Determined if handle is invited (sync). Presence: %{public}@ Handle: %@ isInvited: %d
Checking if handle %@ has already been invited (async) from handle: %@. Presence: %{public}@
XPC Error checking if handle is invited (async). Presence: %{public}@ handle:%@ Error: %{public}@
Error while checking if handle has already been invited (async). Presence: %{public}@ Handle: %@ isInvited:%d Error: %@
Checked if handle is invited (async). Presence: %{public}@ Handle: %@ isInvited: %d
Fetching handle %@ invitability. Presence: %{public}@
XPC Error checking invitability. Presence: %{public}@ handle:%@ Error: %{public}@
Error fetching handle invitability. Presence: %{public}@ Handle: %@ invitability:%@ Error: %@
Checked if handle is invitable. Presence: %{public}@ Handle: %@ invitability: %@
Received request to invite handles: %@ to presenceIdentifier: %{public}@ from sender handle: %@
XPC Error inviting handles. Presence: %{public}@ handles:%@ Error: %{public}@
Removing invited handles. Presence: %{public}@ Handles: %@
XPC Error removing invited handles. Presence: %{public}@ handles:%@ Error: %{public}@
Fetching presence capability.
XPC Error checking presence capability.  Error: %{public}@
Checked if account is presence capable: %d
Registering for delegate callbacks for presenceIdentifier: %{public}@
Completed registration for delegate callbacks for presence identifier: %@
No delegates available to perform presence delegate callback
Present devices changed on presence: %@
Delegate received message for other identifier: %@
Informing delegate of present devices update. Delegate: %@
Delegate does not implement presentHandlesChangedForPresence:, not informing delegate: %@
Invited handles changed for presence identifier: %@
Informing delegate of invited handle update. Delegate: %@
Notifying presence delegate that the XPC connection has disconnected
Presence delegate does not implement the delegate method to be notified the XPC connection has disconnected
Fetching subscription (sync) for handle %@ statusType: %{public}@
XPC Error retrieving subscription. Error: %{public}@
Error retrieving subscription for handle. Error: %@ handle: %@
Retreived subscription metadata for handle. subscriptionMetadata: %@ handle: %@
Did not find subscription metadata for handle. handle: %@
Fetching subscription (async) for handle %@ statusType: %{public}@
Fetching personal subscription (sync) for statusType: %{public}@
XPC Error retrieving personal subscription. Error: %{public}@
Error retrieving personal subscription. Error: %@
Retreived personal subscription metadata. subscriptionMetadata: %@
Did not find personal subscription metadata for status type: %@
Fetching all subscription assertions (sync) for statusType: %{public}@
XPC Error retrieving all subscription assertions. Error: %{public}@
Error retrieving all subscription assertions for status type: %@. Error: %@
Retreived subscription assertions metadatas for status type. subscriptionMetadata: %@ statusType: %@
Did not find subscription assertions for status type: %@
Fetching all active subscription (sync) for statusType: %{public}@
XPC Error retrieving all active subscriptions. Error: %{public}@
Error retrieving all active subscription for status type: %@. Error: %@
Retreived active subscription metadatas for status type. subscriptionMetadata: %@ statusType: %@
Did not find active subscriptions for status type: %@
Fetching all subscription (sync) for statusType: %{public}@
XPC Error retrieving all subscriptions. Error: %{public}@
Error retrieving all subscription for status type: %@. Error: %@
Retreived subscription metadatas for status type. subscriptionMetadata: %@ statusType: %@
Did not find subscriptions for status type: %@
Fetching all subscription with persistent assertion for statusType: %{public}@ application identifer: %@
XPC Error retrieving all subscriptions with persistent assertion. Error: %{public}@
Retreived %ld subscription metadatas for status type. subscriptionMetadata: %@ statusType: %@
Fetching channel validation token (sync) for statusType: %{public}@ handle: %@
XPC Error fetching channel validation token (sync). Error: %{public}@
Error fetching channel validation token (sync). Error: %@
Daemon returned neither a subscription validation token nor an error (sync), this should not happen, daemon should return empty string to indicate a value is not found.
Subscription validation (sync) token for handle: %@ is "%@"
Fetching channel validation token (async) for statusType: %{public}@ handle: %@
XPC Error fetching channel validation token (async). Error: %{public}@
Error fetching channel validation token (async). Error: %@
Daemon returned neither a subscription validation token nor an error (async), this should not happen, daemon should return empty string to indicate a value is not found.
Subscription validation token (async) for handle: %@ is "%@"
Validating subscription validation token "%@" for statusType: %{public}@ fromHandle: %@
XPC Error validating validation token (async). Error: %{public}@
Error validating subscription validation token (async). Error: %@
Subscription validation token "%@" from %@ has an UNKNOWN VALIDITY (!?), with no error. This is likely a bug in StatusKit.
Subscription validation token "%@" from %@ is NOT VALID. Client should re-invite this handle if appropriate.
Subscription validation token "%@" from %@ is valid
Notifying subscription service delegate that the XPC connection has disconnected
Subscription service delegate does not implement the delegate method to be notified the XPC connection has disconnected
Subscription state changed: %@
Informing delegate of state change. Delegate: %@
Delegate does not implement subscriptionStateChanged:, not informing delegate: %@
Subscription received a status update: %@
Informing delegate of status update. Delegate: %@
Delegate does not implement subscriptionReceivedStatusUpdate:, not informing delegate: %@
Invitation received for subscription: %@
Informing delegate of invitation received. Delegate: %@
Delegate does not implement subscriptionInvitationReceived:, not informing delegate: %@
No delegates available to perform subscription service delegate callback
Client is attempting to access StatusKit subscription information of type %{public}@ but is not entitled. Client needs %{public}@ entitlement with this status type identifier.
SKPublishedStatus
NSSecureCoding
NSCoding
SKPresencePayload
DictionaryPayloads
SKSubscriptionValidationTokens
SKInvitationPayload
SKStatusSubscriptionMetadata
SKPresenceDaemonProtocol
NSObject
SKPresenceDaemonDelegateProtocol
SKPresenceDaemonConnection
SKStatusPublishingService
SKStatusPublishingDaemonDelegateProtocol
SKStatusPublishingConnectionDelegateProtocol
Deprecated
SKStatusPublishingDaemonProtocol
SKStatusPublishingDaemonConnection
SKStatusPayload
SKPresentDevice
SKStatusSubscription
SKHandleInvitability
SKPresence
SKPresenceConnectionDelegateProtocol
SKStatusPublishRequest
SKStatusSubscriptionService
SKStatusSubscriptionDaemonDelegateProtocol
SKStatusSubscriptionConnectionDelegateProtocol
SKHandle
NSCopying
SKStatusSubscriptionDaemonProtocol
SKStatusSubscriptionDaemonConnection
SKDelegateResponseQueue
T@"NSArray",R,N
T#,R
T@"SKStatusSubscriptionDaemonConnection",&,N,V_daemonConnection
T@"<SKPresenceDaemonDelegateProtocol>",W,N,V_presenceDaemonDelegate
_deviceTokenURI
T@"<SKStatusPublishingDaemonDelegateProtocol>",W,N,V_publishingDaemonDelegate
_logger
T@"<SKStatusSubscriptionDaemonDelegateProtocol>",W,N,V_subscriptionDaemonDelegate
_registeredForDelegateCallbacks
T@"NSData",R,N,V_payloadData
initWithDictionary:dateCreated:
T@"NSDate",R,N,V_assertionTime
initWithString:
T@"NSDate",R,N,V_datePublished
isProxy
T@"NSDictionary",&,N,V_cachedPayloadDictionary
release
T@"NSMapTable",&,N,V_delegates
removeInvitedHandle:completion:
T@"NSObject<OS_dispatch_queue>",R,N,V_dispatchQueue
setWithObjects:
T@"NSString",R,C
.cxx_destruct
T@"NSString",R,N,V_handleString
T@"<SKPresenceConnectionDelegateProtocol>",W,N,V_connectionDelegate
T@"SKStatusSubscriptionDaemonConnection",R,N,V_daemonConnection
T@"<SKStatusPublishingConnectionDelegateProtocol>",W,N,V_connectionDelegate
_handle
T@"<SKStatusSubscriptionConnectionDelegateProtocol>",W,N,V_connectionDelegate
_oversizeLogger
T@"NSArray",R,N,V_ownerHandles
dealloc
T@"NSDate",&,N,V_dateCreated
initWithIsInvitable:wasRemoved:
T@"NSDate",R,N,V_dateCreated
inviteHandle:fromSenderHandle:withInvitationPayload:completion:
T@"NSDate",R,N,V_dateReceived
presencePayload
T@"NSDictionary",R,N
removeDelegate:
T@"NSObject<OS_dispatch_queue>",&,N,V_privateWorkQueue
setDateCreated:
T@"NSString",&,N,V_statusUniqueIdentifier
subscriptionInvitationReceived:
T@"NSString",R,N
T@"NSString",R,N,V_deviceIdentifier
T@"NSString",R,N,V_deviceTokenURI
T@"NSString",R,N,V_encryptionValidationToken
T@"NSString",R,N,V_presenceIdentifier
T@"NSString",R,N,V_statusTypeIdentifier
T@"NSString",R,N,V_statusUniqueIdentifier
T@"NSString",R,N,V_subscriptionIdentifier
T@"NSString",R,N,V_subscriptionValidationToken
T@"NSXPCConnection",&,N,V_xpcConnection
T@"NSXPCInterface",R,N
T@"SKHandle",R,N
T@"SKHandle",R,N,V_handle
T@"SKInvitationPayload",R,N,V_invitationPayload
T@"SKPresenceDaemonConnection",&,N,V_daemonConnection
T@"SKPresencePayload",R,N,V_presencePayload
T@"SKPublishedStatus",R,N
T@"SKPublishedStatus",R,N,V_currentStatus
T@"SKStatusPayload",R,C,N,V_statusPayload
T@"SKStatusPayload",R,N,V_statusPayload
T@"SKStatusPublishingDaemonConnection",&,N,V_daemonConnection
T@"SKStatusSubscription",R,N
T@"SKStatusSubscriptionMetadata",R,N,V_subscriptionMetadata
TB,N,V_isScheduledRequest
TB,N,V_isSecondaryDeviceRepublish
TB,N,V_registeredForDelegateCallbacks
TB,R
TB,R,N,GisPersonalStatusSubscription
TB,R,N,GisPersonalStatusSubscription,V_personalStatusSubscription
TB,R,N,V_isInvitable
TB,R,N,V_isPersonal
TB,R,N,V_isSelfDevice
TB,R,N,V_isSelfHandle
TB,R,N,V_wasRemoved
TQ,R
T{os_unfair_lock_s=I},N,V_delegateLock
T{os_unfair_lock_s=I},N,V_lock
UUID
UUIDString
_allStatusSubscriptionsIncludingPersonalSubscription:
_assertionTime
_cachedPayloadDictionary
_connectionDelegate
_currentStatus
_daemonConnection
_dateCreated
_datePublished
_dateReceived
_delegateLock
_delegates
_delegatesPerformOnResponseQueueForGroup:block:
_deviceIdentifier
_dispatchQueue
_encryptionValidationToken
_fetchHandleInvitability:fromSenderHandle:completion:
_handleString
_invitationPayload
_inviteHandle:fromSenderHandle:completion:
_inviteHandle:fromSenderHandle:withInvitationPayload:completion:
_inviteHandles:fromSenderHandle:completion:
_inviteHandles:fromSenderHandle:withInvitationPayload:completion:
_isHandleInvitable:fromSenderHandle:completion:
_isHandleInvited:fromSenderHandle:
_isHandleInvited:fromSenderHandle:completion:
_isInvitable
_isPersonal
_isScheduledRequest
_isSecondaryDeviceRepublish
_isSelfDevice
_isSelfHandle
_lock
_ownerHandles
_ownerHandlesDescription
_payloadData
_personalStatusSubscription
_presenceDaemonDelegate
_presenceIdentifier
_presencePayload
_privateWorkQueue
_publishingDaemonDelegate
_registerForDelegateCallbacksIfNecessary
_resetConnectionHandlers
_simulateCrashIfNecessaryForError:
_statusPayload
_statusTypeIdentifier
_statusUniqueIdentifier
_subscriptionDaemonDelegate
_subscriptionIdentifier
_subscriptionMetadata
_subscriptionValidationToken
_wasRemoved
_xpcConnection
_xpcConnectionOptions
addDelegate:queue:
addObject:
allStatusSubscriptions
allStatusSubscriptionsExceptPersonalSubscription
allStatusSubscriptionsWithActiveAssertions
allStatusSubscriptionsWithActiveSubscriptions
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:completion:
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:
allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:
allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:
allocWithZone:
arrayWithObjects:count:
assertPresenceForIdentifier:withPresencePayload:completion:
assertPresenceWithCompletion:
assertPresenceWithPresencePayload:completion:
assertionTime
asynchronousRemoteDaemonWithErrorHandler:
autorelease
bytes
cachedPayloadDictionary
class
code
conformsToProtocol:
connectionDelegate
copy
copyWithZone:
count
countByEnumeratingWithState:objects:count:
currentStatus
daemonConnection
daemonDelegateXPCInterface
daemonXPCInterface
dataWithBytes:length:
dataWithPropertyList:format:options:error:
dateCreated
datePublished
dateReceived
debugDescription
decodeBoolForKey:
decodeObjectOfClass:forKey:
decodeObjectOfClasses:forKey:
delegateLock
delegates
deleteSubscriptionWithCompletion:
deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:
description
deviceIdentifier
deviceTokenURI
dispatchQueue
domain
encodeBool:forKey:
encodeObject:forKey:
encodeWithCoder:
encryptionValidationToken
fetchHandleInvitability:fromHandle:forPresenceIdentifier:completion:
fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:
fetchHandleInvitability:fromSenderHandle:completion:
fetchHandleInvitabilityFromPrimaryAccountHandle:completion:
fetchPresenceCapability:
firstObject
handle
handleString
hash
init
initWithCoder:
initWithData:
initWithData:dateCreated:
initWithDictionary:
initWithHandle:deviceIdentifier:deviceTokenURI:payload:assertionTime:selfHandle:selfDevice:
initWithMachServiceName:options:
initWithPresenceDaemonDelegate:connectionDelegate:
initWithPresenceIdentifier:
initWithPresenceIdentifier:isPersonal:
initWithPublishingDaemonDelegate:connectionDelegate:
initWithQueue:
initWithStatusPayload:
initWithStatusPayload:isScheduledRequest:
initWithStatusPayload:statusUniqueIdentifier:datePublished:dateCreated:dateReceived:invitationPayload:
initWithStatusTypeIdentifier:
initWithString:mergeID:
initWithSubscriptionDaemonDelegate:connectionDelegate:
initWithSubscriptionIdentifier:statusTypeIdentifier:isPersonalStatusSubscription:currentStatus:ownerHandles:
initWithSubscriptionMetadata:daemonConnection:
initWithSubscriptionValidationToken:encryptionValidationToken:
interfaceWithProtocol:
invalidate
invitationPayload
inviteHandle:fromSenderHandle:completion:
inviteHandle:withInvitationPayload:completion:
inviteHandleFromPrimaryAccountHandle:completion:
inviteHandleFromPrimaryAccountHandle:withInvitationPayload:completion:
inviteHandles:fromSenderHandle:completion:
inviteHandles:fromSenderHandle:presenceIdentifier:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:
inviteHandles:withInvitationPayload:completion:
inviteHandlesFromPrimaryAccountHandle:completion:
inviteHandlesFromPrimaryAccountHandle:withInvitationPayload:completion:
invitedHandles
invitedHandlesChangedForPresence:
invitedHandlesChangedForPresenceIdentifier:completion:
invitedHandlesForPresenceIdentifier:completion:
invitedHandlesForStatusTypeIdentifier:completion:
isEqual:
isEqualToData:
isEqualToString:
isEqualToSubscriptionValidationTokens:
isExactlyEqualToHandle:
isHandleInvitable:completion:
isHandleInvitable:fromSenderHandle:completion:
isHandleInvitableFromPrimaryAccountHandle:completion:
isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:
isHandleInvited:
isHandleInvited:completion:
isHandleInvited:fromSenderHandle:
isHandleInvited:fromSenderHandle:completion:
isHandleInvited:fromSenderHandle:forPresenceIdentifier:completion:
isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:
isHandleInvitedFromPrimaryAccountHandle:
isHandleInvitedFromPrimaryAccountHandle:completion:
isInvitable
isKindOfClass:
isMemberOfClass:
isPersonal
isPersonalStatusSubscription
isScheduledRequest
isSecondaryDeviceRepublish
isSelfDevice
isSelfHandle
keyEnumerator
length
lock
logger
objectForKey:
ownerHandle
ownerHandles
payloadData
payloadDictionary
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
personalStatusSubscription
presenceDaemonConnectionDidDisconnect:
presenceDaemonDelegate
presenceDaemonDisconnected:
presenceIdentifier
presentDevices
presentDevicesChangedForPresence:
presentDevicesForPresenceIdentifier:completion:
presentHandlesChangedForPresenceIdentifier:completion:
privateWorkQueue
processIdentifier
propertyListWithData:options:format:error:
publishStatusRequest:completion:
publishStatusRequest:statusTypeIdentifier:completion:
publishingDaemonConnectionDidDisconnect:
publishingDaemonDelegate
publishingServiceDaemonDisconnected:
registerForDelegateCallbacksWithPresenceIdentifier:isPersonal:completion:
registerForDelegateCallbacksWithStatusTypeIdentifier:completion:
registeredForDelegateCallbacks
releaseDaemonConnection
releasePersistentSubscriptionAssertionForApplicationIdentifier:completion:
releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
releasePresenceForIdentifier:completion:
releasePresenceWithCompletion:
releaseTransientSubscriptionAssertionForPresenceIdentifier:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
releaseTransientSubscriptionAssertionWithCompletion:
remoteObjectProxyWithErrorHandler:
removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:
removeAllInvitedHandlesWithCompletion:
removeInvitedHandles:completion:
removeInvitedHandles:presenceIdentifier:completion:
removeInvitedHandles:statusTypeIdentifier:completion:
removeObjectForKey:
respondsToSelector:
resume
retain
retainCount
retainPersistentSubscriptionAssertionForApplicationIdentifier:completion:
retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
retainTransientSubscriptionAssertionForPresenceIdentifier:completion:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
retainTransientSubscriptionAssertionWithCompletion:
self
setCachedPayloadDictionary:
setClasses:forSelector:argumentIndex:ofReply:
setConnectionDelegate:
setDaemonConnection:
setDelegateLock:
setDelegates:
setExportedInterface:
setExportedObject:
setInterruptionHandler:
setInvalidationHandler:
setIsScheduledRequest:
setIsSecondaryDeviceRepublish:
setLock:
setObject:forKey:
setPresenceDaemonDelegate:
setPrivateWorkQueue:
setPublishingDaemonDelegate:
setRegisteredForDelegateCallbacks:
setRemoteObjectInterface:
setStatusUniqueIdentifier:
setSubscriptionDaemonDelegate:
setXPCConnection:
setXpcConnection:
statusPayload
statusSubscriptionForHandle:
statusSubscriptionForHandle:completion:
statusTypeIdentifier
statusUniqueIdentifier
stringWithFormat:
subscriptionDaemonConnectionDidDisconnect:
subscriptionDaemonDelegate
subscriptionIdentifier
subscriptionInvitationReceived:completion:
subscriptionMetadata
subscriptionMetadataForHandle:statusTypeIdentifier:completion:
subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:
subscriptionReceivedStatusUpdate:
subscriptionReceivedStatusUpdate:completion:
subscriptionServiceDaemonDisconnected:
subscriptionStateChanged:
subscriptionStateChangedForSubscriptions:completion:
subscriptionValidationToken
subscriptionValidationTokenForHandle:completion:
subscriptionValidationTokenForHandle:error:
subscriptionValidationTokensForHandle:completion:
subscriptionValidationTokensForHandle:error:
subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:
superclass
supportsSecureCoding
synchronousRemoteDaemonWithErrorHandler:
synchronousRemoteObjectProxyWithErrorHandler:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationToken:fromSender:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:
wasRemoved
weakToStrongObjectsMapTable
xpcConnection
zone
B16@0:8
v24@0:8@16
@24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@64@0:8@16@24@32@40@48@56
@16@0:8
v16@0:8
@"SKStatusPayload"
@"NSString"
@"NSDate"
@"SKInvitationPayload"
B24@0:8@16
Q16@0:8
@24@0:8^{_NSZone=}16
@"NSData"
@"NSDictionary"
@32@0:8@16@24
@52@0:8@16@24B32@36@44
@"SKPublishedStatus"
@"NSArray"
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
v32@0:8@16@?24
v48@0:8@16@24@32@?40
v40@0:8@16@24@?32
v24@0:8@?16
v36@0:8@16B24@?28
v32@0:8@"NSString"16@?<v@?@"NSArray"@"NSError">24
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?B@"NSError">40
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?@"SKHandleInvitability"@"NSError">40
v48@0:8@"NSArray"16@"SKHandle"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"NSArray"16@"NSString"24@?<v@?@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSError">24
v40@0:8@"NSString"16@"SKPresencePayload"24@?<v@?@"NSError">32
v24@0:8@?<v@?B>16
v36@0:8@"NSString"16B24@?<v@?@"NSError">28
v32@0:8@"NSString"16@?<v@?>24
@24@0:8@?16
{os_unfair_lock_s=I}16@0:8
v20@0:8{os_unfair_lock_s=I}16
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"NSXPCConnection"
@"<SKPresenceDaemonDelegateProtocol>"
@"<SKPresenceConnectionDelegateProtocol>"
v24@0:8@"SKStatusPublishingDaemonConnection"16
B32@0:8@16@24
v32@0:8@16@24
v20@0:8B16
@"SKStatusPublishingDaemonConnection"
@"NSMapTable"
@"NSObject<OS_dispatch_queue>"
v56@0:8@16@24@32@40@?48
v40@0:8@"SKStatusPublishRequest"16@"NSString"24@?<v@?@"NSString"@"NSError">32
v56@0:8@"NSArray"16@"SKHandle"24@"SKInvitationPayload"32@"NSString"40@?<v@?@"NSError">48
@"<SKStatusPublishingDaemonDelegateProtocol>"
@"<SKStatusPublishingConnectionDelegateProtocol>"
@64@0:8@16@24@32@40@48B56B60
@"SKHandle"
@"SKPresencePayload"
@"SKStatusSubscriptionMetadata"
@"SKStatusSubscriptionDaemonConnection"
@24@0:8B16B20
v24@0:8@"SKPresenceDaemonConnection"16
@28@0:8@16B24
@"SKPresenceDaemonConnection"
v32@0:8@"NSArray"16@?<v@?>24
v32@0:8@"SKStatusSubscriptionMetadata"16@?<v@?>24
v24@0:8@"SKStatusSubscriptionDaemonConnection"16
@20@0:8B16
@32@0:8@16^@24
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSArray"@"NSError">28
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSArray"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">24
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError">32
v48@0:8@"NSString"16@"NSString"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKSubscriptionValidationTokens"@"NSError">32
v48@0:8@"SKSubscriptionValidationTokens"16@"SKHandle"24@"NSString"32@?<v@?q@"NSError">40
@"<SKStatusSubscriptionDaemonDelegateProtocol>"
@"<SKStatusSubscriptionConnectionDelegateProtocol>"
@(#)PROGRAM:StatusKit  PROJECT:StatusKit-1
statusPayload
statusUniqueIdentifier
datePublished
dateReceived
dateCreated
invitationPayload
<%@: %p; identifier = "%@"; payload = "%@"; datePublished = "%@"; dateReceived = "%@"; dateCreated = "%@">
payload
v8@?0
com.apple.StatusKit
SKPresencePayload
<%@: %p; payloadDictionary = "%@">;
<%@: %p; payloadData = "%@">;
subscriptionToken
encryptionToken
<%@: %p; subscriptionValidationToken = "%@", encryptionValidationToken = "%@">
payloadData
SKInvitationPayload
<%@: %p; payloadDictionary = "%@"; dateCreated = "%@">;
<%@: %p; payloadData = "%@"; dateCreated = "%@">;
subscriptionIdentifier
statusTypeIdentifier
isPersonalStatusSubscription
currentStatus
ownerHandles
<%@: %p; subscriptionID = "%@"; personal = YES; status = "%@">
<%@: %p; subscriptionID = "%@"; owners = "%@"; status = "%@">
v16@?0@"NSError"8
PresenceDaemonConnection
com.apple.StatusKit.presence
SKStatusPublishingErrorDomain
com.apple.StatusKit.PublishingService
v24@?0@"NSString"8@"NSError"16
v24@?0@"NSArray"8@"NSError"16
v20@?0B8@"NSError"12
v24@?0@"SKHandleInvitability"8@"NSError"16
com.apple.StatusKit.publish.types
v16@?0@"<SKStatusPublishingServiceDelegate>"8
PublishingService
PublishingDaemonConnection
com.apple.StatusKit.publish
SKStatusPayload
deviceTokenURI
selfDevice
selfHandle
-[SKPresentDevice initWithHandle:deviceIdentifier:deviceTokenURI:payload:assertionTime:selfHandle:selfDevice:]
SKPresentDevice.m
handle
deviceIdentifier
assertionTime
<%@: %p; handle = "%@"; deviceIdentifier = "%@"; deviceTokenURI = "%@"; payload = "%@"; assertionTime = "%@"; selfDevice = "%d"; selfHandle = "%d">
SKPresentDevice
<nil>
SKStatusSubscription
IsInvitable
WasRemoved
SKHandleInvitability
<%@: %p; isInvitable = "%d"; wasRemoved = "%d">;
SKPresenceErrorDomain
-[SKPresence initWithPresenceIdentifier:isPersonal:]
SKPresence.m
presenceIdentifier
com.apple.StatusKit.Presence
-[SKPresence _fetchHandleInvitability:fromSenderHandle:completion:]
completionHandler
-[SKPresence _inviteHandles:fromSenderHandle:completion:]
-[SKPresence fetchPresenceCapability:]
v12@?0B8
v16@?0@"<SKPresenceDelegate>"8
SKPresence
StatusKit-oversized
scheduledRequest
secondaryDeviceRepublish
<%@: %p; identifier = "%@"; payload = "%@"; dateCreated = "%@"; scheduled=%ld, republish=%ld>
SKStatusSubscriptionErrorDomain
com.apple.StatusKit.SubscriptionService
v24@?0@"SKStatusSubscriptionMetadata"8@"NSError"16
v24@?0@"SKSubscriptionValidationTokens"8@"NSError"16
v24@?0q8@"NSError"16
v16@?0@"<SKStatusSubscriptionServiceDelegate>"8
com.apple.StatusKit.subscribe.types
SubscriptionService
handleString
<%@: %p; handleString = "%@">
StatusSubscriptionDaemonConnection
com.apple.StatusKit.subscribe
Error serializing presence payload dictionary: %@
Error deserializing presence payload data as dictionary: %@
Error serializing status payload dictionary: %@
Error deserializing status payload data as dictionary: %@
XPC Error (async): %{public}@
XPC Error (synchronous): %{public}@
XPC connection to PID %ld invalidated
XPC connection to PID %ld interrupted
Publishing status request. StatusType: %{public}@ Request: %@
XPC Error publishing status request. StatusType: %{public}@ statusRequest:%@ Error: %{public}@
Publish status request failed with error: %@
Publish status request completed with statusUniqueIdentifier: %@
Retrieving invited handles. StatusType: %{public}@
XPC Error retrieving invited handles. StatusType: %{public}@ Error: %{public}@
Retreived invited handles. StatusType: %{public}@ Handles: %@ Error: %@
Retreived invited handles. StatusType: %{public}@ Handles: %@
Checking if handle %@ has already been invited (sync) from handle: %@. StatusType: %{public}@
XPC Error checking if handle is invited (sync). StatusType: %{public}@ Error: %{public}@
Checked if handle is invited (sync). StatusType: %{public}@ Handle: %@ isInvited:%d Error: %@
Determined if handle is invited (sync). StatusType: %{public}@ Handle: %@ isInvited: %d
Checking if handle %@ has already been invited (async) from handle: %@. StatusType: %{public}@
XPC Error checking if handle is invited (async). StatusType: %{public}@ handle:%@ Error: %{public}@
Error while checking if handle has already been invited (async). StatusType: %{public}@ Handle: %@ isInvited:%d Error: %@
Checked if handle is invited (async). StatusType: %{public}@ Handle: %@ isInvited: %d
Fetching handle %@ invitability. StatusType: %{public}@
XPC Error checking invitability. StatusType: %{public}@ handle:%@ Error: %{public}@
Error fetching handle invitability. StatusType: %{public}@ Handle: %@ invitability:%@ Error: %@
Checked if handle is invitable. StatusType: %{public}@ Handle: %@ invitability: %@
Checking if handle %@ is inviteable. StatusType: %{public}@
XPC Error checking inviteability. StatusType: %{public}@ handle:%@ Error: %{public}@
Error while checking if handle is inviteable. StatusType: %{public}@ Handle: %@ isInviteable:%d Error: %@
Checked if handle is inviteable. StatusType: %{public}@ Handle: %@ isInviteable: %d
Received request to invite handles: %@ to personal channel with statusTypeIdentifier: %{public}@ from sender handle: %@
XPC Error inviting handles. StatusType: %{public}@ handles:%@ Error: %{public}@
Inviting handles completed with error: %@
Inviting handles completed.
Removing invited handles. StatusType: %{public}@ Handles: %@
XPC Error removing invited handles. StatusType: %{public}@ handles:%@ Error: %{public}@
Remove invited handles completed with error: %@
Remove invited handles completed.
Removing all invited handles. StatusType: %{public}@
XPC Error removing all invited handles. StatusType: %{public}@ Error: %{public}@
Remove all invited handles completed with error: %@
Remove all invited handles completed.
Registering for delegate callbacks for statusTypeIdentifier: %{public}@
XPC Error registering for delegate callbacks. Error: %{public}@
Error registering for delegate callbacks. Error: %@
Completed registration for delegate callbacks for statusTypeIdentifier: %@
Client is attempting to publish status of type %{public}@ but is not entitled. Client needs %@ entitlement with this status type identifier.
No delegates available to perform publishing service delegate callback
Notifying publishing service delegate that the XPC connection has disconnected
Subscription publishing delegate does not implement the delegate method to be notified the XPC connection has disconnected
XPC Connection Invalidation Handled
XPC Connection Interruption Handled
Deallocing SKPresentDevice for handle "%@"
Retaining transient subscription assertion for subscriptionIdentifier %@
XPC Error retaining transient subscription assertion. Error: %{public}@
Error retaining transient subscription assertion. Error: %{public}@
Successfully retained transient subscription assertion for subscription identifier %@
Releasing transient subscription assertion for subscriptionIdentifier %@
XPC Error releasing transient subscription assertion. Error: %{public}@
Error releasing transient subscription assertion. Error: %{public}@
Successfully released transient subscription assertion for subscription identifier %@
Retaining persistent subscription assertion for subscriptionIdentifier %@ applicationIdentifier %@
XPC Error retaining persistent subscription assertion. Error: %{public}@
Error retaining persistent subscription assertion. Error: %{public}@
Successfully retained persistent subscription assertion for subscription identifier %@ applicationIdentifier %@
Releasing persistent subscription assertion for subscriptionIdentifier %@ applicationIdentifier %@
XPC Error releasing persistent subscription assertion. Error: %{public}@
Error releasing persistent subscription assertion. Error: %{public}@
Successfully released persistent subscription assertion for subscription identifier %@ applicationIdentifier %@
Deleting subscription with subscriptionIdentifier %@
Error deleting subscription with identifier %@. Error: %{public}@
Successfully deleting subscription with identifier %@
Asserting presence for %@ with payload %@
XPC Error retaining presence assertion. Error: %{public}@
Error asserting presence. Error: %{public}@
Successfully asserted presence for presence identifier %@
Releasing presence for  %@
XPC Error releasing presence assertion. Error: %{public}@
Error releasing presence. Error: %{public}@
Successfully released presence for presence identifier %@
Retaining transient subscription assertion for presenceIdentifier %@
Successfully retained transient subscription assertion for presence identifier %@
Releasing transient subscription assertion for presenceIdentifier %@
Successfully released transient subscription assertion for presence identifier %@
Retrieving present decives. Presence: %{public}@
XPC Error retrieving invited handles. Presence: %{public}@ Error: %{public}@
Retrieved present devices. Presence: %{public}@ Handles: %@ Error: %@
Retrieved present devices. Presence: %{public}@ Handles: %@
Retrieving invited handles. Presence: %{public}@
Retrieved invited handles. Presence: %{public}@ Handles: %@ Error: %@
Retrieved invited handles. Presence: %{public}@ Handles: %@
Checking if handle %@ has already been invited (sync) from handle: %@. Presence: %{public}@
XPC Error checking if handle is invited (sync). Presence: %{public}@ Error: %{public}@
Checked if handle is invited (sync). Presence: %{public}@ Handle: %@ isInvited:%d Error: %@
Determined if handle is invited (sync). Presence: %{public}@ Handle: %@ isInvited: %d
Checking if handle %@ has already been invited (async) from handle: %@. Presence: %{public}@
XPC Error checking if handle is invited (async). Presence: %{public}@ handle:%@ Error: %{public}@
Error while checking if handle has already been invited (async). Presence: %{public}@ Handle: %@ isInvited:%d Error: %@
Checked if handle is invited (async). Presence: %{public}@ Handle: %@ isInvited: %d
Fetching handle %@ invitability. Presence: %{public}@
XPC Error checking invitability. Presence: %{public}@ handle:%@ Error: %{public}@
Error fetching handle invitability. Presence: %{public}@ Handle: %@ invitability:%@ Error: %@
Checked if handle is invitable. Presence: %{public}@ Handle: %@ invitability: %@
Received request to invite handles: %@ to presenceIdentifier: %{public}@ from sender handle: %@
XPC Error inviting handles. Presence: %{public}@ handles:%@ Error: %{public}@
Removing invited handles. Presence: %{public}@ Handles: %@
XPC Error removing invited handles. Presence: %{public}@ handles:%@ Error: %{public}@
Fetching presence capability.
XPC Error checking presence capability.  Error: %{public}@
Checked if account is presence capable: %d
Registering for delegate callbacks for presenceIdentifier: %{public}@
Completed registration for delegate callbacks for presence identifier: %@
No delegates available to perform presence delegate callback
Present devices changed on presence: %@
Delegate received message for other identifier: %@
Informing delegate of present devices update. Delegate: %@
Delegate does not implement presentHandlesChangedForPresence:, not informing delegate: %@
Invited handles changed for presence identifier: %@
Informing delegate of invited handle update. Delegate: %@
Notifying presence delegate that the XPC connection has disconnected
Presence delegate does not implement the delegate method to be notified the XPC connection has disconnected
Fetching subscription (sync) for handle %@ statusType: %{public}@
XPC Error retrieving subscription. Error: %{public}@
Error retrieving subscription for handle. Error: %@ handle: %@
Retreived subscription metadata for handle. subscriptionMetadata: %@ handle: %@
Did not find subscription metadata for handle. handle: %@
Fetching subscription (async) for handle %@ statusType: %{public}@
Fetching personal subscription (sync) for statusType: %{public}@
XPC Error retrieving personal subscription. Error: %{public}@
Error retrieving personal subscription. Error: %@
Retreived personal subscription metadata. subscriptionMetadata: %@
Did not find personal subscription metadata for status type: %@
Fetching all subscription assertions (sync) for statusType: %{public}@
XPC Error retrieving all subscription assertions. Error: %{public}@
Error retrieving all subscription assertions for status type: %@. Error: %@
Retreived subscription assertions metadatas for status type. subscriptionMetadata: %@ statusType: %@
Did not find subscription assertions for status type: %@
Fetching all active subscription (sync) for statusType: %{public}@
XPC Error retrieving all active subscriptions. Error: %{public}@
Error retrieving all active subscription for status type: %@. Error: %@
Retreived active subscription metadatas for status type. subscriptionMetadata: %@ statusType: %@
Did not find active subscriptions for status type: %@
Fetching all subscription (sync) for statusType: %{public}@
XPC Error retrieving all subscriptions. Error: %{public}@
Error retrieving all subscription for status type: %@. Error: %@
Retreived subscription metadatas for status type. subscriptionMetadata: %@ statusType: %@
Did not find subscriptions for status type: %@
Fetching all subscription with persistent assertion for statusType: %{public}@ application identifer: %@
XPC Error retrieving all subscriptions with persistent assertion. Error: %{public}@
Retreived %ld subscription metadatas for status type. subscriptionMetadata: %@ statusType: %@
Fetching channel validation token (sync) for statusType: %{public}@ handle: %@
XPC Error fetching channel validation token (sync). Error: %{public}@
Error fetching channel validation token (sync). Error: %@
Daemon returned neither a subscription validation token nor an error (sync), this should not happen, daemon should return empty string to indicate a value is not found.
Subscription validation (sync) token for handle: %@ is "%@"
Fetching channel validation token (async) for statusType: %{public}@ handle: %@
XPC Error fetching channel validation token (async). Error: %{public}@
Error fetching channel validation token (async). Error: %@
Daemon returned neither a subscription validation token nor an error (async), this should not happen, daemon should return empty string to indicate a value is not found.
Subscription validation token (async) for handle: %@ is "%@"
Validating subscription validation token "%@" for statusType: %{public}@ fromHandle: %@
XPC Error validating validation token (async). Error: %{public}@
Error validating subscription validation token (async). Error: %@
Subscription validation token "%@" from %@ has an UNKNOWN VALIDITY (!?), with no error. This is likely a bug in StatusKit.
Subscription validation token "%@" from %@ is NOT VALID. Client should re-invite this handle if appropriate.
Subscription validation token "%@" from %@ is valid
Notifying subscription service delegate that the XPC connection has disconnected
Subscription service delegate does not implement the delegate method to be notified the XPC connection has disconnected
Subscription state changed: %@
Informing delegate of state change. Delegate: %@
Delegate does not implement subscriptionStateChanged:, not informing delegate: %@
Subscription received a status update: %@
Informing delegate of status update. Delegate: %@
Delegate does not implement subscriptionReceivedStatusUpdate:, not informing delegate: %@
Invitation received for subscription: %@
Informing delegate of invitation received. Delegate: %@
Delegate does not implement subscriptionInvitationReceived:, not informing delegate: %@
No delegates available to perform subscription service delegate callback
Client is attempting to access StatusKit subscription information of type %{public}@ but is not entitled. Client needs %{public}@ entitlement with this status type identifier.
SKPublishedStatus
NSSecureCoding
NSCoding
SKPresencePayload
DictionaryPayloads
SKSubscriptionValidationTokens
SKInvitationPayload
SKStatusSubscriptionMetadata
SKPresenceDaemonProtocol
NSObject
SKPresenceDaemonDelegateProtocol
SKPresenceDaemonConnection
SKStatusPublishingService
SKStatusPublishingDaemonDelegateProtocol
SKStatusPublishingConnectionDelegateProtocol
Deprecated
SKStatusPublishingDaemonProtocol
SKStatusPublishingDaemonConnection
SKStatusPayload
SKPresentDevice
SKStatusSubscription
SKHandleInvitability
SKPresence
SKPresenceConnectionDelegateProtocol
SKStatusPublishRequest
SKStatusSubscriptionService
SKStatusSubscriptionDaemonDelegateProtocol
SKStatusSubscriptionConnectionDelegateProtocol
SKHandle
NSCopying
SKStatusSubscriptionDaemonProtocol
SKStatusSubscriptionDaemonConnection
SKDelegateResponseQueue
T@"NSArray",R,N
T#,R
T@"SKStatusSubscriptionDaemonConnection",&,N,V_daemonConnection
T@"<SKPresenceDaemonDelegateProtocol>",W,N,V_presenceDaemonDelegate
_deviceTokenURI
T@"<SKStatusPublishingDaemonDelegateProtocol>",W,N,V_publishingDaemonDelegate
_logger
T@"<SKStatusSubscriptionDaemonDelegateProtocol>",W,N,V_subscriptionDaemonDelegate
_registeredForDelegateCallbacks
T@"NSData",R,N,V_payloadData
initWithDictionary:dateCreated:
T@"NSDate",R,N,V_assertionTime
initWithString:
T@"NSDate",R,N,V_datePublished
isProxy
T@"NSDictionary",&,N,V_cachedPayloadDictionary
release
T@"NSMapTable",&,N,V_delegates
removeInvitedHandle:completion:
T@"NSObject<OS_dispatch_queue>",R,N,V_dispatchQueue
setWithObjects:
T@"NSString",R,C
.cxx_destruct
T@"NSString",R,N,V_handleString
T@"<SKPresenceConnectionDelegateProtocol>",W,N,V_connectionDelegate
T@"SKStatusSubscriptionDaemonConnection",R,N,V_daemonConnection
T@"<SKStatusPublishingConnectionDelegateProtocol>",W,N,V_connectionDelegate
_handle
T@"<SKStatusSubscriptionConnectionDelegateProtocol>",W,N,V_connectionDelegate
_oversizeLogger
T@"NSArray",R,N,V_ownerHandles
dealloc
T@"NSDate",&,N,V_dateCreated
initWithIsInvitable:wasRemoved:
T@"NSDate",R,N,V_dateCreated
inviteHandle:fromSenderHandle:withInvitationPayload:completion:
T@"NSDate",R,N,V_dateReceived
presencePayload
T@"NSDictionary",R,N
removeDelegate:
T@"NSObject<OS_dispatch_queue>",&,N,V_privateWorkQueue
setDateCreated:
T@"NSString",&,N,V_statusUniqueIdentifier
subscriptionInvitationReceived:
T@"NSString",R,N
T@"NSString",R,N,V_deviceIdentifier
T@"NSString",R,N,V_deviceTokenURI
T@"NSString",R,N,V_encryptionValidationToken
T@"NSString",R,N,V_presenceIdentifier
T@"NSString",R,N,V_statusTypeIdentifier
T@"NSString",R,N,V_statusUniqueIdentifier
T@"NSString",R,N,V_subscriptionIdentifier
T@"NSString",R,N,V_subscriptionValidationToken
T@"NSXPCConnection",&,N,V_xpcConnection
T@"NSXPCInterface",R,N
T@"SKHandle",R,N
T@"SKHandle",R,N,V_handle
T@"SKInvitationPayload",R,N,V_invitationPayload
T@"SKPresenceDaemonConnection",&,N,V_daemonConnection
T@"SKPresencePayload",R,N,V_presencePayload
T@"SKPublishedStatus",R,N
T@"SKPublishedStatus",R,N,V_currentStatus
T@"SKStatusPayload",R,C,N,V_statusPayload
T@"SKStatusPayload",R,N,V_statusPayload
T@"SKStatusPublishingDaemonConnection",&,N,V_daemonConnection
T@"SKStatusSubscription",R,N
T@"SKStatusSubscriptionMetadata",R,N,V_subscriptionMetadata
TB,N,V_isScheduledRequest
TB,N,V_isSecondaryDeviceRepublish
TB,N,V_registeredForDelegateCallbacks
TB,R
TB,R,N,GisPersonalStatusSubscription
TB,R,N,GisPersonalStatusSubscription,V_personalStatusSubscription
TB,R,N,V_isInvitable
TB,R,N,V_isPersonal
TB,R,N,V_isSelfDevice
TB,R,N,V_isSelfHandle
TB,R,N,V_wasRemoved
TQ,R
T{os_unfair_lock_s=I},N,V_delegateLock
T{os_unfair_lock_s=I},N,V_lock
UUID
UUIDString
_allStatusSubscriptionsIncludingPersonalSubscription:
_assertionTime
_cachedPayloadDictionary
_connectionDelegate
_currentStatus
_daemonConnection
_dateCreated
_datePublished
_dateReceived
_delegateLock
_delegates
_delegatesPerformOnResponseQueueForGroup:block:
_deviceIdentifier
_dispatchQueue
_encryptionValidationToken
_fetchHandleInvitability:fromSenderHandle:completion:
_handleString
_invitationPayload
_inviteHandle:fromSenderHandle:completion:
_inviteHandle:fromSenderHandle:withInvitationPayload:completion:
_inviteHandles:fromSenderHandle:completion:
_inviteHandles:fromSenderHandle:withInvitationPayload:completion:
_isHandleInvitable:fromSenderHandle:completion:
_isHandleInvited:fromSenderHandle:
_isHandleInvited:fromSenderHandle:completion:
_isInvitable
_isPersonal
_isScheduledRequest
_isSecondaryDeviceRepublish
_isSelfDevice
_isSelfHandle
_lock
_ownerHandles
_ownerHandlesDescription
_payloadData
_personalStatusSubscription
_presenceDaemonDelegate
_presenceIdentifier
_presencePayload
_privateWorkQueue
_publishingDaemonDelegate
_registerForDelegateCallbacksIfNecessary
_resetConnectionHandlers
_simulateCrashIfNecessaryForError:
_statusPayload
_statusTypeIdentifier
_statusUniqueIdentifier
_subscriptionDaemonDelegate
_subscriptionIdentifier
_subscriptionMetadata
_subscriptionValidationToken
_wasRemoved
_xpcConnection
_xpcConnectionOptions
addDelegate:queue:
addObject:
allStatusSubscriptions
allStatusSubscriptionsExceptPersonalSubscription
allStatusSubscriptionsWithActiveAssertions
allStatusSubscriptionsWithActiveSubscriptions
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:completion:
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:
allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:
allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:
allocWithZone:
arrayWithObjects:count:
assertPresenceForIdentifier:withPresencePayload:completion:
assertPresenceWithCompletion:
assertPresenceWithPresencePayload:completion:
assertionTime
asynchronousRemoteDaemonWithErrorHandler:
autorelease
bytes
cachedPayloadDictionary
class
code
conformsToProtocol:
connectionDelegate
copy
copyWithZone:
count
countByEnumeratingWithState:objects:count:
currentStatus
daemonConnection
daemonDelegateXPCInterface
daemonXPCInterface
dataWithBytes:length:
dataWithPropertyList:format:options:error:
dateCreated
datePublished
dateReceived
debugDescription
decodeBoolForKey:
decodeObjectOfClass:forKey:
decodeObjectOfClasses:forKey:
delegateLock
delegates
deleteSubscriptionWithCompletion:
deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:
description
deviceIdentifier
deviceTokenURI
dispatchQueue
domain
encodeBool:forKey:
encodeObject:forKey:
encodeWithCoder:
encryptionValidationToken
fetchHandleInvitability:fromHandle:forPresenceIdentifier:completion:
fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:
fetchHandleInvitability:fromSenderHandle:completion:
fetchHandleInvitabilityFromPrimaryAccountHandle:completion:
fetchPresenceCapability:
firstObject
handle
handleString
hash
init
initWithCoder:
initWithData:
initWithData:dateCreated:
initWithDictionary:
initWithHandle:deviceIdentifier:deviceTokenURI:payload:assertionTime:selfHandle:selfDevice:
initWithMachServiceName:options:
initWithPresenceDaemonDelegate:connectionDelegate:
initWithPresenceIdentifier:
initWithPresenceIdentifier:isPersonal:
initWithPublishingDaemonDelegate:connectionDelegate:
initWithQueue:
initWithStatusPayload:
initWithStatusPayload:isScheduledRequest:
initWithStatusPayload:statusUniqueIdentifier:datePublished:dateCreated:dateReceived:invitationPayload:
initWithStatusTypeIdentifier:
initWithString:mergeID:
initWithSubscriptionDaemonDelegate:connectionDelegate:
initWithSubscriptionIdentifier:statusTypeIdentifier:isPersonalStatusSubscription:currentStatus:ownerHandles:
initWithSubscriptionMetadata:daemonConnection:
initWithSubscriptionValidationToken:encryptionValidationToken:
interfaceWithProtocol:
invalidate
invitationPayload
inviteHandle:fromSenderHandle:completion:
inviteHandle:withInvitationPayload:completion:
inviteHandleFromPrimaryAccountHandle:completion:
inviteHandleFromPrimaryAccountHandle:withInvitationPayload:completion:
inviteHandles:fromSenderHandle:completion:
inviteHandles:fromSenderHandle:presenceIdentifier:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:
inviteHandles:withInvitationPayload:completion:
inviteHandlesFromPrimaryAccountHandle:completion:
inviteHandlesFromPrimaryAccountHandle:withInvitationPayload:completion:
invitedHandles
invitedHandlesChangedForPresence:
invitedHandlesChangedForPresenceIdentifier:completion:
invitedHandlesForPresenceIdentifier:completion:
invitedHandlesForStatusTypeIdentifier:completion:
isEqual:
isEqualToData:
isEqualToString:
isEqualToSubscriptionValidationTokens:
isExactlyEqualToHandle:
isHandleInvitable:completion:
isHandleInvitable:fromSenderHandle:completion:
isHandleInvitableFromPrimaryAccountHandle:completion:
isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:
isHandleInvited:
isHandleInvited:completion:
isHandleInvited:fromSenderHandle:
isHandleInvited:fromSenderHandle:completion:
isHandleInvited:fromSenderHandle:forPresenceIdentifier:completion:
isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:
isHandleInvitedFromPrimaryAccountHandle:
isHandleInvitedFromPrimaryAccountHandle:completion:
isInvitable
isKindOfClass:
isMemberOfClass:
isPersonal
isPersonalStatusSubscription
isScheduledRequest
isSecondaryDeviceRepublish
isSelfDevice
isSelfHandle
keyEnumerator
length
lock
logger
objectForKey:
ownerHandle
ownerHandles
payloadData
payloadDictionary
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
personalStatusSubscription
presenceDaemonConnectionDidDisconnect:
presenceDaemonDelegate
presenceDaemonDisconnected:
presenceIdentifier
presentDevices
presentDevicesChangedForPresence:
presentDevicesForPresenceIdentifier:completion:
presentHandlesChangedForPresenceIdentifier:completion:
privateWorkQueue
processIdentifier
propertyListWithData:options:format:error:
publishStatusRequest:completion:
publishStatusRequest:statusTypeIdentifier:completion:
publishingDaemonConnectionDidDisconnect:
publishingDaemonDelegate
publishingServiceDaemonDisconnected:
registerForDelegateCallbacksWithPresenceIdentifier:isPersonal:completion:
registerForDelegateCallbacksWithStatusTypeIdentifier:completion:
registeredForDelegateCallbacks
releaseDaemonConnection
releasePersistentSubscriptionAssertionForApplicationIdentifier:completion:
releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
releasePresenceForIdentifier:completion:
releasePresenceWithCompletion:
releaseTransientSubscriptionAssertionForPresenceIdentifier:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
releaseTransientSubscriptionAssertionWithCompletion:
remoteObjectProxyWithErrorHandler:
removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:
removeAllInvitedHandlesWithCompletion:
removeInvitedHandles:completion:
removeInvitedHandles:presenceIdentifier:completion:
removeInvitedHandles:statusTypeIdentifier:completion:
removeObjectForKey:
respondsToSelector:
resume
retain
retainCount
retainPersistentSubscriptionAssertionForApplicationIdentifier:completion:
retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
retainTransientSubscriptionAssertionForPresenceIdentifier:completion:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
retainTransientSubscriptionAssertionWithCompletion:
self
setCachedPayloadDictionary:
setClasses:forSelector:argumentIndex:ofReply:
setConnectionDelegate:
setDaemonConnection:
setDelegateLock:
setDelegates:
setExportedInterface:
setExportedObject:
setInterruptionHandler:
setInvalidationHandler:
setIsScheduledRequest:
setIsSecondaryDeviceRepublish:
setLock:
setObject:forKey:
setPresenceDaemonDelegate:
setPrivateWorkQueue:
setPublishingDaemonDelegate:
setRegisteredForDelegateCallbacks:
setRemoteObjectInterface:
setStatusUniqueIdentifier:
setSubscriptionDaemonDelegate:
setXPCConnection:
setXpcConnection:
statusPayload
statusSubscriptionForHandle:
statusSubscriptionForHandle:completion:
statusTypeIdentifier
statusUniqueIdentifier
stringWithFormat:
subscriptionDaemonConnectionDidDisconnect:
subscriptionDaemonDelegate
subscriptionIdentifier
subscriptionInvitationReceived:completion:
subscriptionMetadata
subscriptionMetadataForHandle:statusTypeIdentifier:completion:
subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:
subscriptionReceivedStatusUpdate:
subscriptionReceivedStatusUpdate:completion:
subscriptionServiceDaemonDisconnected:
subscriptionStateChanged:
subscriptionStateChangedForSubscriptions:completion:
subscriptionValidationToken
subscriptionValidationTokenForHandle:completion:
subscriptionValidationTokenForHandle:error:
subscriptionValidationTokensForHandle:completion:
subscriptionValidationTokensForHandle:error:
subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:
superclass
supportsSecureCoding
synchronousRemoteDaemonWithErrorHandler:
synchronousRemoteObjectProxyWithErrorHandler:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationToken:fromSender:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:
wasRemoved
weakToStrongObjectsMapTable
xpcConnection
zone
B16@0:8
v24@0:8@16
@24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@64@0:8@16@24@32@40@48@56
@16@0:8
v16@0:8
@"SKStatusPayload"
@"NSString"
@"NSDate"
@"SKInvitationPayload"
B24@0:8@16
Q16@0:8
@24@0:8^{_NSZone=}16
@"NSData"
@"NSDictionary"
@32@0:8@16@24
@52@0:8@16@24B32@36@44
@"SKPublishedStatus"
@"NSArray"
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
v32@0:8@16@?24
v48@0:8@16@24@32@?40
v40@0:8@16@24@?32
v24@0:8@?16
v36@0:8@16B24@?28
v32@0:8@"NSString"16@?<v@?@"NSArray"@"NSError">24
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?B@"NSError">40
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?@"SKHandleInvitability"@"NSError">40
v48@0:8@"NSArray"16@"SKHandle"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"NSArray"16@"NSString"24@?<v@?@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSError">24
v40@0:8@"NSString"16@"SKPresencePayload"24@?<v@?@"NSError">32
v24@0:8@?<v@?B>16
v36@0:8@"NSString"16B24@?<v@?@"NSError">28
v32@0:8@"NSString"16@?<v@?>24
@24@0:8@?16
{os_unfair_lock_s=I}16@0:8
v20@0:8{os_unfair_lock_s=I}16
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"NSXPCConnection"
@"<SKPresenceDaemonDelegateProtocol>"
@"<SKPresenceConnectionDelegateProtocol>"
v24@0:8@"SKStatusPublishingDaemonConnection"16
B32@0:8@16@24
v32@0:8@16@24
v20@0:8B16
@"SKStatusPublishingDaemonConnection"
@"NSMapTable"
@"NSObject<OS_dispatch_queue>"
v56@0:8@16@24@32@40@?48
v40@0:8@"SKStatusPublishRequest"16@"NSString"24@?<v@?@"NSString"@"NSError">32
v56@0:8@"NSArray"16@"SKHandle"24@"SKInvitationPayload"32@"NSString"40@?<v@?@"NSError">48
@"<SKStatusPublishingDaemonDelegateProtocol>"
@"<SKStatusPublishingConnectionDelegateProtocol>"
@64@0:8@16@24@32@40@48B56B60
@"SKHandle"
@"SKPresencePayload"
@"SKStatusSubscriptionMetadata"
@"SKStatusSubscriptionDaemonConnection"
@24@0:8B16B20
v24@0:8@"SKPresenceDaemonConnection"16
@28@0:8@16B24
@"SKPresenceDaemonConnection"
v32@0:8@"NSArray"16@?<v@?>24
v32@0:8@"SKStatusSubscriptionMetadata"16@?<v@?>24
v24@0:8@"SKStatusSubscriptionDaemonConnection"16
@20@0:8B16
@32@0:8@16^@24
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSArray"@"NSError">28
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSArray"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">24
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError">32
v48@0:8@"NSString"16@"NSString"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKSubscriptionValidationTokens"@"NSError">32
v48@0:8@"SKSubscriptionValidationTokens"16@"SKHandle"24@"NSString"32@?<v@?q@"NSError">40
@"<SKStatusSubscriptionDaemonDelegateProtocol>"
@"<SKStatusSubscriptionConnectionDelegateProtocol>"
