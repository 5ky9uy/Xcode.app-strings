@(#)PROGRAM:StatusKitAgentCore  PROJECT:StatusKit-1
v8@?0
com.apple.StatusKit
SKAStatusEncryptionManager
com.apple.StatusKit.InvitationManager.cleanup
v24@?0@"SKADatabaseChannel"8@"NSError"16
com.apple.availability
com.apple.statuskit.cleanup
v12@?0B8
v20@?0B8@"NSError"12
v32@?0@"NSString"8@"NSData"16@"NSError"24
Sender handle is invalid, or could not determine a valid default sender handle.
Invited handles are invalid
Could not find or create a channel to send invitation for status of type "%@".
Key roll failed
Could not uninvite handle(s) "%@" because we could not find an existing invitation for those handle(s)
Could not any existing invitations to delete
SKAInvitationManager
lastSubscriptionDate
channelIdentifier
%K == %@
dateRemoved
removedHandle
statusTypeIdentifier
%@ %@
channel_topic
auth_credential
channel_ownership_type
SELF_USER_OWNERSHIP
(unknown: %i)
identifier
personal
decomissioned
statusType
encryptionKeys
dateChannelCreated
%K != nil
v16@?0@"NSError"8
com.apple.StatusKit.publish.types
com.apple.StatusKit.publish.allTypes
<%@ PID=%ld>
SKAStatusPublishingServiceClientConnection
com.apple.StatusKitAgent
lastPublishTime
rapidPublishCount
com.apple.StatusKitAgent.PublishingManager
com.apple.statuskit.pendingPublish
v24@?0@"NSString"8@"NSError"16
shared-channels-stale-publish-wait-time-seconds
shared-channels-rate-limit-wait-time-seconds
shared-channels-request-retry-count
shared-channels-client-rate-limit-max-rapid-publishes
shared-channels-client-rate-limit-rapid-publish-time-seconds
SKAStatusPublishingManager
Could not find or create a channel to publish status of type "%@".
Status Publish Request %@ created at %@ is not newer than existing status %@ at %@
Status Publish Request has the same status unique identifier as existing status: %@
Status Publish Request has been rate-limtited
<%@: %p; identifier = "%@"; personal = %ld, decomissioned = %ld, statusType = "%@"; dateCreated = "%@">;
SKADatabaseChannel
%@_%p
v16@?0q8
No valid IDS destinations could be determined
status-kit-keysharing-disabled
SKAMessagingProvider
Client is not entitled to publish status of type "%@". Missing entitlement "%@"
Could not determine any users to share with from request
System iCloud account does not exist or is not statuskit capable
Could not determine sender handle to use
dateCreated of StatusPayload differs too much from server time
SKAStatusPublishingServiceClient
v24@?0@"SKHandleInvitability"8@"NSError"16
shared-channels-scheduled-publish-variance-max-slop-period-seconds
shared-channels-unscheduled-publish-variance-max-slop-period-seconds
shared-channels-secondary-device-republish-variance-min-slop-period-seconds
Client is not entitled to subscription information for status of type "%@". Missing entitlement "%@"
com.apple.StatusKit.subscribe.types
Client is not entitled to subscription information for status. Missing entitlement "%@"
Subscription not found matching subscription identifier: "%@"
SKAStatusSubscriptionServiceClient
v16@?0@"NSArray"8
com.apple.StatusKit.StatusReceivingManager.cleanup
SKAStatusReceivingManager
dateCreated
statusUniqueIdentifier
SKAChannelManagerErrorDomain
SKAChannelManagerErrorRetryIntervalKey
StatusKitDataKey
com.apple.icloud.presence.mode.status
Generic non-success response status
v24@?0@"NSData"8@"NSError"16
SKAChannelManager
Could not fetch JWT token for authenticating request
SUCCESS
AUTH_EXPIRED
AUTH_FAILED
BAD_REQUEST
CHANNEL_IDENTITY_VALIDATION_FAILED
INTERNAL_ERROR
STALE_PUBLISH_REJECTED
RATE_LIMITED
status
retry_interval_seconds
<%@: %p; identifier = "%@"; dateCreated = "%@"; invitationPayload: "%@">
SKADatabaseReceivedInvitation
com.apple.gs.sharedchannels.auth
lastReauthTime
reauthCount
v24@?0@"NSDictionary"8@"NSError"16
shared-channels-reauth-max-count
shared-channels-reauth-backoff-time-seconds
SKAAccountProvider
channel_id
channel_token
com.apple.aps.StatusKit
SKPushManagerErrorDomain
IMMobileNetworkManager
skipAuth
v40@?0@"IDSBaseMessage"8@"NSError"16q24@"NSDictionary"32
shared-channels-disabled
SKAPushManager
<%@: %p; uniqueIdentifier = "%@"; channelIdentifier = "%@"; dateCreated = "%@">;
channel_identity
lastFaultTime
com.apple.StatusKitAgent.SubscriptionManager
v32@?0@"SKATransientSubscriptionAssertion"8Q16^B24
com.apple.focus.status
shared-channels-subscription-cache-size
shared-channels-max-subscription-size
shared-channels-subscription-ttl-minutes
SKAStatusSubscriptionManager
<%@: %p; subscriptionIdentifier = %@
SKATransientSubscriptionAssertion
simple_jwt
auth_credential_oneof
PBUNSET
channel_publish_payload
publish_initiate_timestamp_millis
publish_payload
publish_payload_expiry_ttl_millis
push_priority
pending_publish_hint
scheduled_publish_hint
retry_count
NORMAL
HIGH
com.apple.private.alloy.status.keysharing
com.apple.StatusKit.publish
com.apple.StatusKit.subscribe
SKAStatusServer
BiomeDonationEnabled
Kettle
FeatureComplete
com.apple.statuskit.maintenance
v16@?0@"NSObject<OS_xpc_object>"8
com.apple.StatusKitAgent.CoreData.historyProcessing
v24@?0@"NSPersistentStoreDescription"8@"NSError"16
StatusKitAgent
SKADatabaseModel
com.apple.statuskit
StatusKit
database
statuskit-local-v1.db
statuskit-cloud.db
lastProcessedPersistentHistoryToken.data
Local
com.apple.aps.StatusKit.CloudKitMirroring
Cloud
author != %@
v24@?0@"CKAccountInfo"8@"NSError"16
skipHSA2
SKADatabaseProvider
SKAGeneratedEncryptionKey
dateInvitationCreated
senderHandle
dateGenerated
com.apple.StatusKit.subscribe.allTypes
SKAStatusSubscriptionServiceClientConnection
applicationIdentifier
<%@: %p; statusPayload = "%@"; invitation = "%@">;
v32@?0@"ReceivedInvitation"8Q16^B24
v32@?0@"Channel"8Q16^B24
SKADatabaseManager
datePublished
uniqueIdentifier
%02lx
%02x
invitedHandle
channel
SKASystemMonitor
Channel
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
Channel does not have a current outgoing ratchet, rolling encryption key to generate a new one.
Encryption key rolled successfully, fetching new key
Key roll failed, unable to encrypt status
Error encrypting status: %@
Message encrypted successfully
Unable to encrypt status due to nil outgoing encryption key
Attempting to decrypt incoming status on personal channel using keys from %ld outgoing ratchets.
Status payload successfully decrypteded from generatedKey: %@
Status payload not decrypteded from generatedKey: %@
Status payload failed to decrypt with all known generated encryption keys.
Attempting to decrypt incoming status on non personal channel using incoming ratchet state from %ld received invitations.
Status payload successfully decrypteded from invitation: %@
Status payload not decrypted from invitation: %@
Status payload failed to decrypt with all known invitations.
Decrypteded payload: %@
Status payload failed to decrypt with error: %@
Status payload decypted to nil data
Status payload successfully decrypted
Extracting status payload, but envelope dictionary is not deserializable. Returning nil payload.
Extracting status payload, but encrypted payload is missing, is this an empty status update, or a malformed status: %@
Failed to extract status payload, signature is missing: %@
Failed to extract status payload, ratchet index is missing: %@
Failed to extract status payload, ratchet index is an invalid number: %@
Successfully decrypted status payload
Failed to decrypt status payload
Finding most recent incoming ratchet for personal channel from %ld outgoing ratchets.
Finding most recent incoming ratchet for non personal channel using incoming ratchet state from %ld received invitations.
Unable to find most recent incoming ratchet for channel: %@
Error serializing status envelope dictionary: %@
Error deserializing status envelope data as dictionary: %@
Request to invite handles contains no valid handles to invite. InvitedHandles: %@
Error resolving sender handle. UnresolvedSenderHandle: %@
Error fetching or creating personal channel: %@
Could not find or create personal channel
Adding invited handles %@ to database for channel: %@
Inivtation was not sent for handles %@ due to key roll error: %@
Invitations for newly invited handles %@ was already sent during key roll, skipping individual message send.
Invitation failed with error: %@
Could not find existing personal channel to revoke all invitations for
Finished deleting all invited user database records for channel %@, initiating key roll
Unable to find any invitations to revoke, taking no action, returning error
Could not find existing personal channel to revoke invitations for
Successfully deleted database record for invited user: %@.  Adding to removed users
Unable to find database record for invited user attempted to delete: %@
Finished deleting database records for uninvited users, initiating key roll
Received request to roll encryption key for personal channel with statusTypeIdentifier: %@
Not rolling encryption key because a personal channel does not exist for statusTypeIdentifier: %@
Error encounted during key roll for statusTypeIdentifier: %@ error: %@
Received request to roll personal channel with statusTypeIdentifier: %@
Channel creation failed! Aborting channel roll.
Failed to copy invited users! Aborting channel roll.
Succesfully rolled personal channel with statusTypeIdentifier: %@
Asked to roll personal channel for %@, but no channel exists
Generating new outgoing ratchet
Storing newly generated outgoing ratchet
Messaging %ld existing invited users with the newly generated subscription keys
Outgoing IDS messages for encryption key roll failed to send: %@
Not sending any invitations following key roll as there are no invited users for channel %@
Failing to send invitation to zero invited users
Error generating incoming ratchet: %@
Error serializing incoming ratchet
Database InvitedUser does not have an invited SKHandle: %@
Sending invitation message with new encryption key ratchet index %ld to handle "%@" with invitation payload %@
Invitation sent successfully
Invitation send failed with error: %@ message: %@
Invited handle failed validation, ignoring: %@
Validated invited handle set does not match unvalidated handles. Unvalidated set may have contained duplicate or invalid handles. Validated: %@ Unvalidated: %@
Incoming invitation from handle: %@
Invitation message missing channel identifier, dropping invitation: %@
Invitation message missing status type identifier, dropping invitation: %@
Invitation message uses legacy status type identifier, dropping invitation: %@
Invitation message missing incoming ratchet state, dropping invitation: %@
Invitation message missing date invitation created, dropping invitation: %@
No existing channel matches incoming invitation, creating new channel
Could not find or create channel for incoming invitation, dropping invitation.
Storing received invitation
Cleaning up ReceivedInvitations for channel: %@
Removing old channels for handle: %@
fromHandle "%@" is NOT a valid sender handle for active iCloud account
fromHandle "%@" is a valid sender handle for active iCloud account
toHandle "%@" inviteability check completed with result: %d
Handle is invalid, and not inviteable: %@
handle "%@" is present as a removed user
Channel has no existing encryption key data, initiating key roll to generate first key
Generating first encryption key for personal channel failed: %@
Found existing encryption keys, attempting to ratchet forward from current ratchet index: %ld
Rolling encryption key for personal channel failed: %@
Ratchet forward succeeded. New ratchet index: %ld. Persisting this state.
Error fetching or update invited user for handle: %@
Removing handle %@ from removed users because of invite
Invited handle has a nil handle string: %@
Found %ld existing invited user for invitedHandle %@ (ignoring sender handle).
Existing invited user was invited from the same handle: %@. Updating payload, and not creating a new InvitedUser record.
Existing invited user was invited from %@, but we are attempting to invite from %@. Will update this users payload, but may still need to create a new InvitedUser record
Updating invitation payload on invitedUser: %@
Received a nil updated user from call to updateInvitationPayload
Invitation payload is already up to date
Could not find an existing invited user matching handle: %@ and senderHandle %@, attempting to create a new one.
Received a nil created user from createInvitedUserWithHandle
Could not find an existing personal status channel, attempting to create a new one.
Account refresh required for error: %@
Account refresh succeeded, reattempting channel creation
Account refresh failed with error: %@
Error is an auth expired error, we should attempt reauth
Error is an auth failed error, we should attempt reauth
Error is an auth missing auth token error, we should attempt reauth
Error does not appear to be auth related, we should not attempt reauth
XPC connection to PID %ld interrupted
XPC connection to PID %ld invalidated
XPC Error (async): %{public}@
XPC Error (synchronous): %{public}@
Deallocing {pointer: %p}
Client is not entitled for any status types
Client is not entitled to publish status of type %{public}@
Client is currently rate-limited.  Enqueing requests as pending publish.
Publishing status unique identifier: %@ to channel: %@
Error publishing status with the channel manager: %@
Attempting reauth to resolve error
Account refresh succeeded, publishing pending publish requests
Removing pending publish based on error
Rolling channel.
Channel was rolled succesfully.
Channel roll failed.
Not rolling channel because this is a secondary device publish.
Attempting retry with delay.
Retrying after %f sec delay
Retry interval is 0--not retrying
Successfully published status %@ to channel %@
Dropping and removing status publish request with unique identifier %@. Error: %@
Could not find or create a personal channel for statusTypeIdentifier %@ error: %@
Pending publish request has already been scheduled.  Not enqueing again
Will attempt to process %ld pending publish requests after a %.2f second delay
Skipping publish of pending request that lacks an status identifier
Deleting pending status with ID %@ as it has expired
Deleting pending status with ID %@ as it has passed the max retry count of %lu
Attempting to publish pending request with ID: %@
Publish of pending status request with ID:%@ finished with error:%@
No pending publish requests
Publish requested for reason: %lu
Dropping status publish request, a status with unique identifier %@ has already been published. PublishRequest: %@
Dropping status publish request, existing status %@ was created at %@, publish request %@ from %@ is not newer.
In window for rate limit backoff.  We'll be free again at %@
We've left the rate-limit backoff window.
Incrementing rapid publish counter.
Deleting pending publish request with ID: %@ because it is older than newly received publish request with ID %@
Creating new pending status publish request for status unique identifier: %@
Pending status publish request already exists for status unique identifier: %@
StatusTypeIdentifier %@ corresponds to personal channel %@
Could not find an existing personal status channel for statusTypeIdentifier %@, attempting to create a new one.
Channel creation request failed with error: %@
Channel creation request succeeded, new personal channel for statusTypeIdentifier %@ has channel identifier %@
Deleting pending status publish request with identifier: %@
Delete failed for pending status publish request with identifier: %@
Publish was rejected for being stale. Abandoning.
Publish was rejected for being malformed. Abandoning.
Channel identity validation failed. We should roll this channel.
Publish was rejected because we've hit a rate limit.
Server bag indicates our pending publish request delay time should be %.2f
Server bag indicates our rate limit delay time should be %.2f
Server bag indicates our max retry count should be %lu
Server bag indicates our max rapid publishes should be %lu
Server bag indicates our rapid publish timescale should be %lu
Failed to create currentOutgoingRatchet due to invalid data. Error: %@
Initializing messaging provider with service %@ and delegate %@
Keysharing has been disabled by the server! Not initializing messaging service
Keysharing has been disabled by the server! Not sending message
Failed to generate IDS destination for handle: %@
No valid IDS destinations generated from handles: %@
Sending message %@ to destinations %@ options: %@
Successfully sent invitation message, assigned message identifier: %@
Failed to send invitation message with error: %@
Sender handle "%@" is a valid sender handle for active iCloud account
Sender handle "%@" is NOT a valid sender handle for active iCloud account
Received incoming message: %@ fromID: %@
Keysharing has been disabled by the server! Dropping incoming message
Received didHintCheckingTransportLogWithReason
Resolved default caller ID: %@
Unable to determine default caller ID among URIs: %@
Keysharing has been disabled in the server bag!
Publishing service client connection was interrupted: %@
Publishing service client connection was invalidated: %@
Received request to publish status: %@
Rejecting publish request, client is not entitled
Account is not StatusKit capable
dateCreated not set on statusPublishRequest:%@. Setting to serverTime: %@
dateCreated time differs too much from server time.  delta = %f
Personal channel does not exist for status type identifier
Attempting to determine if handle %@ has already been invited from handle: %@
Error resolving sender handle for isInvited check. UnresolvedSenderHandle: %@
We found a match to an existing invited user
We found an existing invitated user matching the requested user, but that invitation was sent with handle %@ instead of handle %@. Ignoring.
We did not find a match to any existing invited user
Received request to send invitation for personal channel with statusTypeIdentifier %@ to handles: %@
Failed to send invitation to handles with error: %@
Successfully sent invitation to handles: %@
Received request to remove invitation from personal channel with statusTypeIdentifier %@ for handles: %@
Invitation revocation for handles %@ failed with error: %@
Invitation revocation for handles %@ completed succesffully
Received request to remove all invitations from personal channel with statusTypeIdentifier %@
Invitation revocation for all handles failed with error: %@
Invitation revocation for all handles completed succesffully
Client %@ has registered for delegate callbacks for statusTypeIdentifier: %@.
Server bag unexpected value type for key "%@". Value: %@
Resolved secondary device republish delay of %.1f seconds, within allowed range of (%.1f,%.1f) seconds.
XPC Error notifying of remote database changes. Error: %{public}@
Connected client completed processing of remote database changes.
Notifying client of updated subscription: %@
XPC Error notifying client of status update. Error: %{public}@
Connected client completed processing of status update.
Connected client does not match status type identifier of changed subscription. Client: %@ Status: %@
XPC Error notifying of received invitation. Error: %{public}@
Notifying connected client of received channel invitation.
Connected client completed processing of channel invitation.
Connected client does not match invited channel status type.
Current status for channel is expired
No existing status for channel
Beginning release of transient subscription assertions associated with interrupted client
Error releasing transient subscription assertions associated with interrupted client: %@
Success releasing transient subscription assertions associated with interrupted client
Beginning release of transient subscription assertions associated with invalidated client
Error releasing transient subscription assertions associated with invalidated client: %@
Success releasing transient subscription assertions associated with invalidated client
Client is not entitled to access subscription information for status type: %@
Retrieving subscription information for handle: %@
Subscription information not found for handle: %@
Found subscription metadata: %@ for handle %@
Retrieving all subscription information for statusTypeIdentifier: %@
Found %ld channels for status type %@
Retrieving all active assertions for statusTypeIdentifier: %@
Retrieving all subscription assertions for statusTypeIdentifier: %@ applicationIdentifier: %@
Found %ld subscription assertions
Subscription information not found for personal channel with statusTypeIdentifier: %@
Found subscription metadata for personal channel: %@
Received request to retain transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain transient subscription assertion for status type: %@
No subscription was found matching subscriptionIdentifier: %@ statusTypeIdentifier: %@
Error retaining transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release transient subscription assertion for status type: %@
Error releasing transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to retain persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain persistent subscription assertion for status type: %@
Error retaining persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release persistent subscription assertion for status type: %@
Error releasing persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request for subscription and encryption validation token for handle "%@" statusTypeIdentifier: %@
Found channel %@ matching handle: %@
Did not find a channel matching handle: "%@". Returning empty string to indicate no match.
Received request for validate token "%@" from handle "%@" for statusTypeIdentifier: %@
Validating tokens against personal channel: %@
Received invalid validity for subscription channel validation. Not validating encryption token.
Sender "%@" asked us to verify that we do not have a personal channel, and they are correct
Sender "%@" asked us to verify a channel validation token, but we don't have a personal channel, this device may be out of sync, returning unknown
Attempting to validate subscription channel token "%@" against personal channel with identifier "%@"
Sender "%@" asked us to verify that we do not have a personal channel, but we do have channel %@. Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid subscription channel validation token
Sender "%@" has supplied a subscription channel validation token "%@", that does not match our current personal channel identifier "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Attempting to validate encryption token "%@" against personal channel %@
Sender "%@" provided encryption validation token "%@", but we do not have a local value to validate against. Returning valid.
Sender "%@" provided an nil encryption validation token, but we expected "%@". For backward compatibility, we assume nil means they are on an older OS and we should not fail validation. Returning valid.
Sender "%@" provided an empty encryption validation token, but we expected "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid encryption validation token. Provided: "%@" Expected: "%@"
Sender "%@" has supplied an encryptoin validation token "%@", that does not match our expected value "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Validated subscriptionIdentifier: %@ statusTypeIdentifier: %@
Failed to validate. subscriptionIdentifier: %@ does not match statusTypeIdentifier: %@
Failed to validate subscriptionIdentifier: %@ statusTypeIdentifier: %@
Could not find channel matching incoming status update, ignoring.
Found channel matching channel identifier: %@.
Could not extract unencrypted envelope from incoming status update, ignoring.
Could not determine status unique identifier for incoming status update, ignoring.
Could not determine date published for incoming status update, ignoring.
Date created is too far in the future, ignoring.
We've already received a status with this unique identifier (%@), ignoring.
Received new status %@ for channel %@
Saved incoming status update to database with unique identifier: %@
Not informing delegate of status because it has expired
Received request to create a personal channel
Unable to fetch JWT token for icloud account.  Failing request.
Asking push manager to execute create channel request
Channel create request failed with error: %@
Channel create response received
Create channle response contains non success status: %ld - %@
Retry interval specified: %ld
Channel create success response received: %@
Received request to publish data on channel %@
Unable to fetch JWT auth token.  Failing request.
Sending publish request to push manager
Publish status request contains error: %@
Publish status request contains neither error nor proto response
Handling protobuf response data for completed status publish request
Publish status request completed with nonsuccess response status: %ld
Publish status request completed with success
Fetching subscribed channels
Received %ld subscribed channels: %@
Subscribing to channels: %@
Unsubscribing from channels: %@
Retrieving JWT token from account provider
Could not fetch JWT token!: Error: %@
Received data on channel: %@
Failed to subscribe to channel: %@ Error: %@
Failed to create incomingRatchet due to invalid data. Error: %@
Unable to fetch system account! Likely no iCloud account signed in.
Unable to fetch JWT token!
Fetched token hash:%@
Reauth has hit rate limit.  Not attempting.
Unable to fetch account store!
Unable to fetch system account! Likely no iCloud account signed in. Error: %@
altDSID not available for account
Auth refresh suceeded.
Auth refresh failed with error: %@
Fetching primary iCloud account
Primary iCloud account determined: %@
Failed to find primary iCloud account
Server bag indicates our max reauth count should be %lu
Server bag indicates our reauth backoff time should be %lu
Received did leave first unlock notification.
Initializing APS connection.
Deferring connection initialization as device is before first unlock.
Using sandbox push environment
Using production push environment
Shared channels disabled by server! Aborting
No active APS connection. Cannot change topic filter.
Not under first data protection lock but no APS connection!
Trying to create a channel resulted in error %@
Create channel reverse push completed, calling completion with proto response
Sending create channel message.
Switching topic to non-waking
Switching topic to enabled
Publishing status
Publishing status failed with resultCode %ld error: %@
Publishing status, reverse push completed, calling completion with protobuf response data
Fetching subscribed channels completed with channels: %@
APSConnection server is disconnected. Using current system time
APSConnection server time is invalid. Using current system time
Receieved aps incoming message: %@ -- expiration: %@
Status kit message data undecodable
Channel subscription failed. Failures: %@
Shared channels has been disabled in the server bag!
Transient subscription assertion already existed, but still refreshing registered subscription assertions, to ensure apsd is in sync.
Failed to update registered subscriptions following transient assertion retain with error: %@
Successfully updated registered subscriptions following transient assertion retain
Successfully removed transient subscription assertion from in memory model for subscription identifier: %@
Could not find transient subscription assertion to remove from in memory model for subscription identifier: %@
Failed to update registered subscriptions following transient assertion release with error: %@
Successfully updated registered subscriptions following transient assertion release
Disconnecting client had no active transient subscription assertions, not updating registered subscriptions
Disconnecting client had %ld transient subscription assertion, removing transient assertions and updating registrations for channels: %@
Failed to update registered subscriptions following client disconnect with error: %@
Successfully updated registered subscriptions following client disconnect
A subscription assertion already exists, no need to create a new one. Existing: %@
Created subscription assertion: %@
Failed to update registered subscriptions following persistent assertion retain with error: %@
Successfully updated registered subscriptions following persistent assertion retain
Did not delete persistent subscription assertion because one was not found for subscription identifier: %@
Successfully removed persistent subscription assertion from database for subscription identifier: %@
Failed to update registered subscriptions following persistent assertion release with error: %@
Successfully updated registered subscriptions following persistent assertion release
Returning %lu active assertions.
Returning %lu active subscriptions.
Found an existing transient subscription assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added transient subscription assertion to in memory model for subscription identifier: %@
Not creating a new transient subscription assertion, one already exists.
Marking subscription change time for channel %@
Succesfully removed transient subscription assertion for identifier: %@. Client had %ld transient subscription assertions, now has %ld. Client: %@
Could not find transient subscription assertion for subscription identifier: "%@". Active transient subscription assertions: %@ for client: %@
StatusKitAgent wants to be subscribed to: %@
StatusKitAgent was previously subscriped to: %@
No changes for active subscriptions based on current assertions. Subscribed to: %@
Subscriptions updated. Subscribed to: %@
Active subscription count %ld does not exceed cap of %ld
Active subscription count %ld exceeds cap of %ld
Transient subscription assertions: %@
Persistent subscription assertions: %@
Personal channels requiring self subscription: %@
Cached channels for subscription: %@
Finding at most %ld cached channels to subscribe to
Personal channel has no identifier: %@
No personal channel for statusTypeIdentifier: %@
Server bag indicates our max subscription count should be %lu
Server bag indicates our hard max subscription count should be %lu
Server bag indicates our subscription TTL should be %f seconds
Creating TransientSubscriptionAssertion for channel "%@"
TransientSubscriptionAssertion
Deallocing TransientSubscriptionAssertion for channel "%@", releasing os_activity
Initializing
Shutting down
Logging state
Receiving XPC connection from PID %ld for publishing service
Receiving XPC connection from PID %ld for subscription service
Receiving XPC connection from PID %ld for unknown service name: %{public}@
Rejected XPC connection from PID %ld for publishing service. Client is not entitled for any publishing service.
Accepted XPC connection from PID %ld for publishing service
Rejected XPC connection from PID %ld for subscription service. Client is not entitled for any subscription service.
Accepted XPC connection from PID %ld for subscription service
Subscription service client was invalidated. Removing client: %@
Publishing service client was invalidated. Removing client: %@
Received remote database changes for channels: %@
Error updating subscriptions following remote database changes: %@
Success updating subscriptions following remote database changes
Could not find channel matching changed channelIdentifier: %@
Could not find any database channel matching changed channelIdentifiers
Incoming message received. Service: %@ senderID: %@ guid: %@
Handling message as key invite
Received network reachable notification
Kettle feature flag not enabled.  Exiting.
Failed to subscribe to channel %@ with error: %@
Server received status update: %@
Writing to Biome event with IDSHandle: %@, statusTypeIdentifier %@
Channel created with identifier: %@ type: %@
Updating registered subscription to allow self subscription to personal channel, if necessary
Updating registered subscription failed with error: %@
Updating registered subscription to allow self subscriptions completed
Received channel invitation on channel: %@
Revoked invitation(s) on channel: %@. Republishing current status
Finished republishing status.  ID:%@ error:%@
Couldn't decrypt current status on channel
No current status to republish
Scheduling maintenance XPC activity %@
Finished maintenance subscription update with error %@
Removing decomissioned channels
Creating persistent container
Failed to load persistent store. Error: %@ Store: %@
Completed loading of persistent store: %@
Completed creation of persistent container
Failed creation of persistent container
Persistent store remote change notification received.
Error executing history change request: %@
History change request found no results.
Have channel matching persistent history change. Channel: %@ Change: %@
Could not find channel matching persisent history change: %@
Ignoring delete channel change: %@
Have received invitation matching persistent history change. ReceivedInvitation: %@ Change: %@
ReceivedInvitation matching persistent history change has channel. Channel: %@ Change: %@
ReceivedInvitation matching persistent history change has not channel. ReceivedInvitation: %@ Change: %@
Could not find encryption key matching persisent history change: %@
Ignoring delete received invitation change: %@
Did not find object matching change history event. Object has already been deleted. Error: %@
Error fetching object matching change transaction. Error: %@
Last processed persistent history token is nil at URL %@
Error unarchiving last processed persistent history token. Error: %@
Error archiving last processed persistent history token. Error: %@
Archived last processed persistent history token is zero length
Overriding device-to-device encryption check because default has been set.
Account supports device-to-device encryption
Account does not support device-to-device encryption and is not statuskit capable
Failed to create outgoing ratchet due to invalid data. Error: %@
Failed to create outgoing ratchet due to nil outgoing ratchet state
Failed to create incoming ratchet due to failure to access subscription keys
Failed to create incoming ratchet due to lack of outgoing ratchet
Client is not entitled to subscription information for status of type %{public}@
Error fetching personal status channel. Error: %@
Fetch request for personal status channel type "%@" completed with result: %@
Error fetching decomissioned channel. Error: %@
Fetch request for decomissioned personal channels completed with %lu results
Deleted existing channel.
Could not find existing channel
More than one personal channel exists for channel identifier: %@
Beginning fetch request for channels with channel identifier: %@
Error executing fetch for subscription validation. Error: %@
Fetch request for channels by identifier returned a nil result
Fetch request for channel by identifier found no match.
Fetch request for channel by identifier completed with %ld result(s)
Preferring invitation %@ from %@ among %ld result(s)
Invitation %@ corresponds to channelIdentifier: %@
Could not find any channels associated with channel identifier: %@
Invitation does not correspond to any channel. InvitationIdentifier: %@
No received invitation found matching handle %@ statusTypeIdentifier: %@
Invitation does not correspond to any channel. ReceivedInvitation: %@ handle: %@
Channel not found for channel identifier: %@
Beginning fetch request for channel by handle
Error executing fetch for channel by handle. Error: %@
Fetch request for channel by handle found no match.
Fetch request for channel by handle completed with %ld result(s)
Error saving managed object context for storing new personal channel. Error: %@
Error saving managed object context for storing channel invitation. Error: %@
Error saving managed object context for updated outgoing ratchet state. Error: %@
Error saving managed object context for decomissioning. Error: %@
Could not find generated ratchet keys matching database channel. Channel: %@
Beginning fetch request for active subscription assertions
Error fetching subscription assertions. Error: %@
Fetch request for active subscription assertions completed
Error saving managed object context for storing persistent subscription assertion. Error: %@
Deleted existing assertion.
Could not find existing assertion
Error fetching transientSubscriptionHistory. Error: %@
Error fetching transientSubscriptionHistories. Error: %@
Found existing transient subscription history. Updating lastSubscrionDate.
Could not find existing transient subscription history. Creating a new one.
Error saving managed object context for storing transient subscription history. Error: %@
Error saving managed object context for storing invited user. Error: %@
Error saving managed object context for copyinh invited users. Error: %@
Multiple (%ld) entries in the database match a single invited user, updating all of them. InvitedUser: %@
Error saving managed object context for updating invitation payload on invited user. Error: %@
Error finding core data invited user to update invitation. No match for SKADatabaseInvitedUser: %@
Error finding core data channel matching SKADatabaseChannel: %@
Error fetching invited user. Error: %@
Fetch request for invited user executed with results: %@
Failed to normalize handle: "%@", returning nil existing invited user
Deleting existing invited user with handle: %@
Error saving managed object context for deleting invited users by handle. Error: %@
Could not find existing invited user matching handle: %@
Could not find existing database channel matching channel %@
Deleting all %ld existing invited users for channel %@
Error saving managed object context for deleting all invited users. Error: %@
Could not find any existing invited users to delete
Error saving managed object context for storing status. Error: %@
Beginning lookup of most recent status for channel
Error executing fetch for status by channel. Error: %@
Fetch request for status by channel found no match.
Fetch request for status by channel completed with %ld result(s)
Beginning lookup of most recent status for unique id
Error executing fetch for status by unique id. Error: %@
Fetch request for status by unique id found no match.
Fetch request for status by unique id completed with %ld result(s)
Beginning database cleanup of statuses on channel identifier: %@
Error executing fetch for status cleanup. Error: %@
Fetch request for cleanup of statuses found no matches.
Fetch request for status cleanup completed with %ld result(s)
Keeping status %@ because it is our most recent status
Keeping status %@ because it is excluded from this cleanup request
Deleting status %@ as it is no longer the most recent
Error saving managed object context for status cleanup. Error: %@
Error fetching pending requests. Error: %@
Error saving managed object context for storing pending publish request. Error: %@
Error saving managed object context for deleting pending publish request. Error: %@
Deleted existing pending publish request with identifier: %@
Could not find existing pending publish request with identifier: %@
Error saving managed object context for incrementing pending publish request. Error: %@
Incremented pending publish request rc with identifier: %@
Error saving managed object context for storing removed user. Error: %@
Error saving managed object context for deleting removed user. Error: %@
Deleted existing removed user with handle: %@
Could not find existing removed user with handle: %@
Error fetching removed users. Error: %@
Beginning fetch request for ReceivedInvitation from handle %@ statusTypeIdentifier: %@
Error executing fetch for ReceivedInvitation by handle. Error: %@
Fetch request for ReceivedInvitation by handle found no match.
Fetch request for ReceivedInvitation by handle completed with %ld result(s)
Could not find core data channel to match channel identifier: %@
Error saving managed object context for storing received invitation. Error: %@
Could not find any existing channels matching channel identifier. Returning no received invitations. Channel identifier: %@
Keeping invitation %@ because it is at index %ld when ordered by recency and we are keeping the %ld most recent
Keeping invitation %@ because it was excluded by the caller
Keeping invitation %@ because it is the most recent invitation from senderHandle: %@
Deleting invitation %@ as it is no longer the most recent
Error saving managed object context for invitation cleanup. Error: %@
Deleting channel %@ as it is decomissioned and not recent or old
Not deleting channel %@ as it is in our most recent and old decomissioned channels
Error saving managed object context for decomissioned channel cleanup. Error: %@
No decomissioned channel to clean up
Channel cleanup is disabled.
Delivering %@ to %@
SKAStatusEncryptionManager
SKAStatusEncryptionManaging
NSObject
SKAStatusUnencryptedEnvelope
SKAInvitationManager
SKAInvitationManaging
KeyPathConstants
Predicates
SortDescriptors
SharedChannelCreateRequest
NSCopying
SKAStatusPublishingServiceClientConnection
SKAStatusPublishingManager
SKAStatusPublishingManaging
SKADatabaseChannel
CurrentOutgoingRatchet
SKAMessagingProvider
IDSServiceDelegate
SKAMessagingProviding
SKAStatusPublishingServiceClient
SKStatusPublishingDaemonProtocol
SKAStatusPublishingServiceClientConnectionLifecycleDelegate
SKAStatusSubscriptionServiceClient
SKStatusSubscriptionDaemonProtocol
SKAClientConnectionRepresentable
SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate
SKAStatusReceivingManager
SKAStatusReceivingManaging
CoreData
SKAChannelManager
SKAPushManagingDelegate
SKAChannelManaging
SharedChannelPublishResponse
SKADatabaseReceivedInvitation
SKHandle
IncomingRatchet
SKInvitationPayload
SKADatabaseTransientSubscriptionHistory
StatusKitAgent
SKAAccountProvider
SKAAccountProviding
ChannelIdentity
SKAPushManager
APSConnectionDelegate
SKASystemMonitorListener
SKAPushManaging
SKADatabaseStatus
SharedChannelCreateResponse
SKAStatusSubscriptionManager
SKAStatusSubscriptionManaging
SKATransientSubscriptionAssertion
AuthCredential
SharedChannelPublishRequest
ChannelPublishPayload
SKAStatusServer
NSXPCListenerDelegate
SKADatabaseProvidingDelegate
SKAMessagingProvidingDelegate
SKAChannelManagingDelegate
SKAStatusReceivingManagingDelegate
SKADatabaseManagingDelegate
SKAInvitationManagingDelegate
SKAStatusPublishingServiceClientDelegate
SKAStatusSubscriptionServiceClientDelegate
SKADatabaseRemovedUser
SKADatabaseProvider
SKADatabaseProviding
SKAGeneratedEncryptionKey
Ratchets
SKAStatusSubscriptionServiceClientConnection
SKADecryptedStatusPayload
SKADatabaseInvitedUser
SKADatabaseManager
SKADatabaseManaging
SKADatabaseSubscriptionAssertion
SKADatabasePendingPublishRequest
SKASystemMonitor
Channel
CoreDataProperties
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
init
setObject:forKeyedSubscript:
timeIntervalSince1970
numberWithDouble:
payloadData
_encryptPayload:channel:
encryptedMessage
base64EncodedStringWithOptions:
index
numberWithUnsignedShort:
signature
_serializeDictionaryAsBinaryPlist:
currentOutgoingRatchet
logger
statusType
rollEncryptionKeyForPersonalChannelWithStatusTypeIdentifier:error:
newBackgroundContext
existingPersonalChannelForStatusTypeIdentifier:databaseContext:
sealStatus:authenticating:error:
isPersonal
generatedEncryptionKeysForPersonalChannel:databaseContext:
count
countByEnumeratingWithState:objects:count:
incomingRatchet
_decryptPayloadData:withIncomingRatchet:withRatchetIndex:signatureData:
initWithData:
initWithStatusPayload:invitation:
receivedInvitationsForChannel:databaseContext:
firstObject
unsealStatusWithIndex:encryptedMessage:authenticating:signature:error:
_deserializeBinaryPlistDictionaryData:
initWithEnvelopeDictionary:
ska_dataFrombase64EncodedStringForKey:
ska_numberForKey:
integerValue
_decryptPayload:withRatchetIndex:signatureData:channel:
_mostRecentIncomingRatchetForChannel:
signingKeyIdentifier
ska_hexString
length
substringToIndex:
dataWithPropertyList:format:options:error:
propertyListWithData:options:format:error:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
encodeStatusPayload:statusUniqueIdentifier:dateCreated:currentServerTime:channel:
extractEnvelopeFromStatusEnvelopeData:
decryptStatusPayloadFromStatusEnvelopeData:channel:
encryptionValidationTokenForChannel:
initWithDatabaseManager:invitationManager:
databaseManager
invitationManager
.cxx_destruct
_databaseManager
_invitationManager
T@"<SKADatabaseManaging>",R,N,V_databaseManager
T@"<SKAInvitationManaging>",R,N,V_invitationManager
ska_stringForKey:
ska_dateFromUnixTimestampForKey:
statusUniqueIdentifier
datePublished
dateCreated
envelopeDictionary
setEnvelopeDictionary:
_envelopeDictionary
T@"NSDictionary",&,N,V_envelopeDictionary
T@"NSString",R,N
T@"NSDate",R,N
_validateInvitedHandles:
_invalidInvitedHandlesError
resolveSenderHandleWithPreferredSenderHandle:
_invalidSenderHandleError
_noPersonalChannelErrorForStatusTypeIdentifier:
_addInvitedHandles:senderHandle:toDatabaseForPersonalChannel:withInvitationPayload:databaseContext:
_ratchetEncryptionKeyForwardOrKeyRollForPersonalChannel:databaseContext:invitationWasSentViaKeyRoll:error:
currentSubscriptionKeys
_sendInvitationMessageForChannel:toInvitedUsers:subscriptionKeys:error:
_findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
deleteAllInvitedUsersForPersonalChannel:databaseContext:
_rollEncryptionKeyForChannel:databaseContext:error:
_keyRollFailedErrorWithUnderlyingError:
_unableToFindAnyExistingInvitationToDeleteError
deleteInvitedUserForHandle:personalChannel:databaseContext:
createRemovedUserWithHandle:dateRemoved:statusTypeIdentifier:databaseContext:
invitationManager:didRevokeInvitationOnChannel:
_unableToFindExistingInvitationForHandlesError:
copyInvitedUsersFromChannel:toChannel:databaseContext:
decomissionAllPersonalChannelsWithStatusTypeIdentifier:databaseContext:
_createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
serializedData
createGeneratedEncryptionKeyWithOriginalOutgoingRatchetState:personalChannel:databaseContext:
existingInvitedUsersForPersonalChannel:databaseContext:
chainKey
signingKey
initWithIndex:chainKey:signingKey:error:
invitedSKHandle
senderSKHandle
invitationPayload
handleString
identifier
date
copy
sendMessage:toHandle:fromHandle:error:
_validateInvitedHandle:
addObject:
array
isEqualToString:
existingChannelForSubscriptionIdentifier:databaseContext:
createChannelForStatusTypeIdentifier:channelIdentifier:databaseContext:
createReceivedInvitationForChannel:senderHandle:invitedHandle:invitationIdentifier:dateInvitationCreated:incomingRatchetState:invitationPayload:databaseContext:
invitationManager:didReceiveInvitation:forChannel:
allExistingChannelsForHandle:statusTypeIdentifier:databaseContext:
cleanupOldReceivedInvitationsForChannelIdentifier:excludingInvitation:databaseContext:
cleanupOldChannelsForHandle:statusTypeIdentifier:databaseContext:
messagingProvider
isHandleAvailableToMessageFrom:
_isHandleInviteable:completion:
isHandleMessageable:completion:
existingRemovedUserWithHandle:statusTypeIdentifier:withDatabaseContext:
initWithIsInvitable:wasRemoved:
isHandleInviteable:fromHandle:completion:
ratchetForward
updatePersonalChannel:withCurrentOutgoingRatchetState:databaseContext:
_updateOrCreateInvitedUserWithHandle:senderHandle:onChannel:withInvitationPayload:databaseContext:
addObjectsFromArray:
deleteRemovedUserWithHandle:statusTypeIdentifier:databaseContext:
existingInvitedUsersForInvitedHandle:onChannel:databaseContext:
isNormalizedEqualToHandle:
updateInvitationPayload:onExistingInvitedUser:channel:databaseContext:
createInvitedUserWithHandle:senderHandle:invitationPayload:channel:databaseContext:
_shouldReauthForError:
accountProvider
channelManager
createPersonalChannelForStatusTypeIdentifier:channelIdentifier:channelToken:databaseContext:
createChannelWithCompletion:
refreshCredentialForPrimaryAccountWithCompletion:
domain
code
stringWithFormat:
dictionaryWithObjects:forKeys:count:
errorWithDomain:code:userInfo:
componentsJoinedByString:
sendInvitationForPersonalChannelWithStatusTypeIdentifier:toHandles:fromSenderHandle:withInvitationPayload:completion:
revokeInvitationFromPersonalChannelWithStatusTypeIdentifier:forHandles:completion:
revokeAllInvitationsFromPersonalChannelWithStatusTypeIdentifier:completion:
handleIncomingInvitationMessage:fromHandle:toHandle:messageGuid:
rollPersonalChannelWithStatusTypeIdentifier:completion:
fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:
delegate
setDelegate:
T@"<SKAInvitationManagingDelegate>",W,N
initWithMessagingProvider:databaseManager:accountProvider:channelManager:
setDatabaseManager:
setMessagingProvider:
setChannelManager:
setAccountProvider:
backgroundCleanupQueue
setBackgroundCleanupQueue:
_delegate
_messagingProvider
_channelManager
_accountProvider
_backgroundCleanupQueue
T@"<SKADatabaseManaging>",&,N,V_databaseManager
T@"<SKAMessagingProviding>",&,N,V_messagingProvider
T@"<SKAChannelManaging>",&,N,V_channelManager
T@"<SKAAccountProviding>",&,N,V_accountProvider
T@"NSObject<OS_dispatch_queue>",&,N,V_backgroundCleanupQueue
T@"<SKAInvitationManagingDelegate>",W,N,V_delegate
lastSubscriptionDateKeyPath
channelIdentifierKeyPath
predicateWithFormat:
predicateForLastSubscriptionDate:
predicateForChannelIdentifier:
sortDescriptorWithKey:ascending:
sortDescriptorForLastSubscriptionDateAscending:
dateRemovedKeyPath
handleKeyPath
statusTypeIdentifierKeyPath
normalizedHandleString
predicateForHandleString:
predicateForHandle:
predicateForStatusTypeIdentifier:
dictionaryRepresentation
dictionary
setObject:forKey:
setChannelTopic:
setAuthCredential:
allocWithZone:
copyWithZone:
mergeFrom:
hasChannelTopic
hasAuthCredential
channelOwnershipType
setChannelOwnershipType:
setHasChannelOwnershipType:
hasChannelOwnershipType
channelOwnershipTypeAsString:
StringAsChannelOwnershipType:
readFrom:
writeTo:
copyTo:
channelTopic
authCredential
_authCredential
_channelOwnershipType
_channelTopic
_has
TB,R,N
T@"NSString",&,N,V_channelTopic
T@"AuthCredential",&,N,V_authCredential
TB,N
Ti,N,V_channelOwnershipType
identifierKeyPath
personalKeyPath
decomissionedKeyPath
statusTypeKeyPath
encryptionKeysKeyPath
dateChannelCreatedKeyPath
numberWithBool:
predicateForPersonal:
predicateForDecomissioned:
predicateForCreationDateNotNil
sortDescriptorForStatusTypeIdentifierOrderedAscending:
sortDescriptorForPersonalOrderedAscending:
sortDescriptorForChannelIdentifierOrderedAscending:
sortDescriptorForCreationDateAscending:
daemonXPCInterface
setExportedInterface:
setExportedObject:
daemonDelegateXPCInterface
setRemoteObjectInterface:
_setQueue:
processIdentifier
connectionLifecycleDelegate
publishingServiceClientConnectionWasInterrupted:
setInterruptionHandler:
publishingServiceClientConnectionWasInvalidated:
setInvalidationHandler:
resume
xpcConnection
remoteObjectProxyWithErrorHandler:
synchronousRemoteObjectProxyWithErrorHandler:
invalidate
dealloc
sk_stringArrayValueForEntitlement:
sk_booleanValueForEntitlement:
_connection:isEntitledForPublishingWithStatusTypeIdentifier:
containsObject:
clientIsEntitledForAtLeastOnePublishingServiceType:
initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:
asynchronousRemoteDaemonDelegateWithErrorHandler:
synchronousRemoteDaemonDelegateWithErrorHandler:
clientIsEntitledForPublishingWithStatusTypeIdentifier:
setXpcConnection:
setConnectionLifecycleDelegate:
_xpcConnection
_connectionLifecycleDelegate
T@"NSXPCConnection",&,N,V_xpcConnection
T@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
Ti,R
clientIsRateLimited
ensurePendingPublishRequestExistsWithPublishRequest:forStatusTypeIdentifier:databaseContext:
_rateLimitDelayTime
publishPendingRequestsWithDelay:
_errorForRateLimit
_publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:retryCount:completion:
_removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:databaseContext:
internalWorkQueue
_shouldClientRateLimit
setClientIsRateLimited:
_shouldAllowPublishForPublishRequest:onChannel:error:
_markPublishAttempt
statusPayload
serverTime
encryptionManager
channelToken
isScheduledRequest
isSecondaryDeviceRepublish
userInfo
objectForKey:
doubleValue
_shouldAbandonRequestForError:
_removePendingPublishRequestWithUniqueIdentifier:databaseContext:
_shouldRollChannelForError:
_shouldRetryWithDelayForError:
publishData:onChannel:withChannelToken:publishInitiateTime:isPendingPublish:isScheduledPublish:retryCount:completion:
findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
pendingRequestScheduled
existingPendingPublishRequestsWithDatabaseContext:
setPendingRequestScheduled:
timeIntervalSinceDate:
retryCount
_maxRetryCount
initWithStatusPayload:
setDateCreated:
setStatusUniqueIdentifier:
statusTypeIdentifier
incrementPendingPublishRequestRetryCountWithUniqueIdentifier:databaseContext:
_pendingDelayTime
existingStatusForChannel:databaseContext:
uniqueIdentifier
_errorForDuplicateStatusPublishRequestWithIdentifier:
compare:
_errorForStatusPublishRequestWithIdentifier:requestedStatusCreationDate:isOlderThanExistingStatus:existingStatusCreationDate:
_maxRapidPublishes
intValue
dateByAddingTimeInterval:
_rapidPublishesTimescale
numberWithInt:
existingPendingPublishRequestsForStatusTypeIdentifier:withDatabaseContext:
existingPendingPublishRequestForUniqueIdentifier:withDatabaseContext:
createPendingPublishRequestWithUniqueIdentifier:dateCreated:payloadData:statusTypeIdentifier:databaseContext:
createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
deletePendingPublishRequestWithWithUniqueIdentifier:databaseContext:
sharedInstanceForBagType:
publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:completion:
removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:
publishPendingRequestForReason:
initWithDatabaseManager:channelManager:accountProvider:encryptionManager:invitationManager:
setEncryptionManager:
setInvitationManager:
setInternalWorkQueue:
_pendingRequestScheduled
_clientIsRateLimited
_encryptionManager
_internalWorkQueue
T@"<SKAStatusEncryptionManaging>",&,N,V_encryptionManager
T@"<SKAInvitationManaging>",&,N,V_invitationManager
T@"NSObject<OS_dispatch_queue>",&,N,V_internalWorkQueue
TB,V_pendingRequestScheduled
TB,V_clientIsRateLimited
initWithChannelToken:identifier:personal:decomissioned:currentOutgoingRatchetState:dateCreated:statusType:invitedUsers:
isDecomissioned
currentOutgoingRatchetState
dateChannelCreated
setDateChannelCreated:
invitedUsers
_personal
_decomissioned
_channelToken
_identifier
_currentOutgoingRatchetState
_dateChannelCreated
_statusType
_invitedUsers
T@"NSData",R,N,V_channelToken
T@"NSString",R,C,N,V_identifier
personal
TB,R,N,GisPersonal,V_personal
decomissioned
TB,R,N,GisDecomissioned,V_decomissioned
T@"NSData",R,N,V_currentOutgoingRatchetState
T@"NSData",&,N,V_dateChannelCreated
T@"NSString",R,C,N,V_statusType
T@"NSArray",R,C,N,V_invitedUsers
initWithData:error:
T@"MPStatusKitOutgoingRatchet",R,N
_keysharingIsDisabledByServer
initWithService:
addDelegate:queue:
arrayWithObjects:count:
sendMessage:toHandles:fromHandle:error:
idsDestination
_noValidIDSDetintationError
sendMessage:toDestinations:priority:options:identifier:error:
serviceIdentifier
sharedInstance
refreshIDStatusForDestination:service:listenerID:queue:completionBlock:
initWithUnprefixedURI:
service
URIs
isEqualToURI:
originalGUID
toID
service:didReceiveIncomingMessage:fromID:toID:messageGuid:
networkBecameReachable
unprefixedURI
initWithString:
boolValue
service:account:incomingOpportunisticData:withIdentifier:fromID:context:
service:didSendOpportunisticDataWithIdentifier:toIDs:
service:account:incomingMessage:fromID:context:
service:account:incomingData:fromID:context:
service:account:incomingUnhandledProtobuf:fromID:context:
service:account:incomingResourceAtURL:fromID:context:
service:account:incomingResourceAtURL:metadata:fromID:context:
service:account:incomingPendingMessageOfType:fromID:context:
service:activeAccountsChanged:
service:devicesChanged:
service:nearbyDevicesChanged:
service:connectedDevicesChanged:
service:linkedDevicesChanged:
service:account:identifier:didSendWithSuccess:error:
service:account:identifier:didSendWithSuccess:error:context:
service:account:identifier:sentBytes:totalBytes:
service:account:identifier:hasBeenDeliveredWithContext:
service:account:identifier:fromID:hasBeenDeliveredWithContext:
service:account:inviteReceivedForSession:fromID:
service:account:inviteReceivedForSession:fromID:withOptions:
service:account:inviteReceivedForSession:fromID:withContext:
service:account:receivedGroupSessionParticipantUpdate:
service:account:receivedGroupSessionParticipantDataUpdate:
serviceSpaceDidBecomeAvailable:
serviceAllowedTrafficClassifiersDidReset:
service:didSwitchActivePairedDevice:acknowledgementBlock:
T@"<SKAMessagingProvidingDelegate>",W,N
initWithDelegate:serviceIdentifier:queue:
service:didHintCheckingTransportLogWithReason:
setService:
setServiceIdentifier:
_service
_serviceIdentifier
T@"IDSService",&,N,V_service
T@"NSString",&,N,V_serviceIdentifier
T@"<SKAMessagingProvidingDelegate>",W,N,V_delegate
publishingServiceClientWasInvalidated:
clientConnection
_missingEntitlmentErrorForStatusTypeIdentifier:
_accountNotCapableError
UUID
UUIDString
_dateCreatedDriftError
_delayForStatusPublishRequest:
publishingManager
accountIsStatusKitCapableWithCompletion:
_unableToResolveSenderHandleError
setAccountIsStatusKitCapable:
setAccountCheckCompleted:
queue
accountIsStatusKitCapable
deviceToDeviceEncryptedDatabaseCapableWithCompletion:
_serverBagNumberForKey:
_serverBagTimeIntervalForKey:withDefaultValue:
_scheduledPublishMaxDelayTime
_unscheduledPublishMaxDelayTime
_secondaryDeviceRepublishMaxDelayTime
_secondaryDeviceRepublishMinDelayTime
_randomSecondaryDeviceRepublishDelay
_randomScheduledPublishDelay
_randomUnscheduledPublishDelay
_noUsersToShareWithError
publishStatusRequest:statusTypeIdentifier:completion:
invitedHandlesForStatusTypeIdentifier:completion:
isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:
isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:
removeInvitedHandles:statusTypeIdentifier:completion:
removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:
registerForDelegateCallbacksWithStatusTypeIdentifier:completion:
initWithXPCConnection:queue:delegate:databaseManager:invitationManager:publishingManager:channelManager:
statusTypeIdenfifier
setClientConnection:
databaseProvider
setDatabaseProvider:
setPublishingManager:
accountCheckCompleted
setQueue:
_accountIsStatusKitCapable
_accountCheckCompleted
_statusTypeIdenfifier
_clientConnection
_databaseProvider
_publishingManager
_queue
T@"SKAStatusPublishingServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusPublishingServiceClientDelegate>",W,N,V_delegate
T@"<SKADatabaseProviding>",&,N,V_databaseProvider
T@"SKAInvitationManager",&,N,V_invitationManager
T@"<SKAStatusPublishingManaging>",&,N,V_publishingManager
TB,N,V_accountIsStatusKitCapable
TB,N,V_accountCheckCompleted
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
T@"NSString",R,C,N,V_statusTypeIdenfifier
channelMatchesClientStatusTypeIdentifier:
_subscriptionMetadataForChannel:
subscriptionStateChangedForSubscriptions:completion:
subscriptionReceivedStatusUpdate:completion:
subscriptionInvitationReceived:completion:
_currentStatusForChannel:
_handlesAssociatedWithChannel:
initWithSubscriptionIdentifier:statusTypeIdentifier:isPersonalStatusSubscription:currentStatus:ownerHandles:
isExpired
dateReceived
rawData
invitation
skInvitationPayload
initWithStatusPayload:statusUniqueIdentifier:datePublished:dateCreated:dateReceived:invitationPayload:
releaseAllTransientSubscriptionAssertionsAssociatedWithClient:completion:
subscriptionServiceClientWasInvalidated:
clientIsEntitledForSubscriptionWithStatusTypeIdentifier:
existingChannelForHandle:statusTypeIdentifier:databaseContext:
allExistingChannelsForStatusTypeIdentifier:includingPersonalChannel:databaseContext:
subscriptionManager
allSubscriptionIdentifiersWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionIdentifiersWithActiveSubscriptionsForStatusTypeIdentifier:completion:
existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
channelIdentifier
_validateChannelIsKnownForSubscriptionIdentifier:statusTypeIdentifier:databaseContext:
_subscriptionIdentifierNotFoundError:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
initWithSubscriptionValidationToken:encryptionValidationToken:
subscriptionValidationToken
validatePersonalChannel:matchesSubscriptionValidationToken:fromSender:
encryptionValidationToken
validatePersonalChannel:matchesEncryptionValidationToken:fromSender:
hasPrefix:
_genericMissingSubscriptionEntitlmentError
subscriptionMetadataForHandle:statusTypeIdentifier:completion:
allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:
allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:
subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:
subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:
subscriptionServiceClientConnectionWasInvalidated:
subscriptionServiceClientConnectionWasInterrupted:
initWithXPCConnection:queue:delegate:databaseManager:subscriptionManager:encryptionManager:
handleRemoteDatabaseChangeForChannels:
handleReceivedStatusUpdate:onChannel:
handleReceivedInvitationForChannel:
setSubscriptionManager:
_subscriptionManager
T@"SKAStatusSubscriptionServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusSubscriptionServiceClientDelegate>",W,N,V_delegate
T@"<SKAStatusSubscriptionManaging>",&,N,V_subscriptionManager
existingStatusForUniqueIdentifier:databaseContext:
createStatusWithUniqueIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:channelIdentifier:databaseContext:
statusReceivingManager:didReceiveStatusUpdate:onChannel:
cleanupOldStatusUpdatesForChannelIdentifier:excludingStatusUniqueIdentifier:databaseContext:
handleIncomingStatusData:onChannelIdentifier:dateReceived:dateExpired:serverTime:
initWithDatabaseManager:encryptionManager:delegate:
T@"<SKAStatusReceivingManagingDelegate>",W,N,V_delegate
dateCreatedKeyPath
statusUniqueIdentifierKeyPath
predicateForStatusUniqueIdentifier:
sortDescriptorForDateCreatedAscending:
initWithCoreDataInvitedUser:
initWithCoreDataChannels:
dateExpired
initWithChannelIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:uniqueIdentifier:
initWithCoreDataStatus:
invitedHandle
senderHandle
dateInvitationPayloadCreated
initWithInvitedHandle:senderHande:invitationPayloadData:dateInvitationPayloadCreated:
invitationIdentifier
dateInvitationCreated
incomingRatchetState
initWithInvitationIdentifier:senderHandle:invitedHandle:statusTypeIdentifier:dateInvitationCreated:incomingRatchetState:invitationPayload:
initWithCoreDataReceivedInvitation:
initWithStatusTypeIdentifier:dateCreated:payloadData:statusUniqueIdentifier:retryCount:
initWithCoreDataPendingPublishRequest:
originalOutgoingRatchetState
dateGenerated
initWithOriginalOutgoingRatchetState:dateGenerated:
initWithCoreDataGeneratedEncryptionKey:
applicationIdentifier
initWithChannelIdentifier:statusTypeIdentifier:applicationIdentifier:
initWithCoreDataSubscriptionAssertion:
lastSubscriptionDate
initWithChannelIdentifier:lastSubscriptionDate:
initWithCoreDataTransientSubscriptionHistory:
removedHandle
dateRemoved
initWithHandle:statusTypeIdentifier:dateRemoved:
initWithCoreDataRemovedUser:
_getJWTToken
_jwtTokenNotFoundError
setSimpleJwt:
data
pushManager
status
hasRetryIntervalSeconds
retryIntervalSeconds
numberWithUnsignedInt:
channelIdentity
channelId
createChannelWithProtoData:completion:
setChannelToken:
initWithBase64EncodedString:options:
setChannelId:
setPublishInitiateTimestampMillis:
setPendingPublishHint:
setScheduledPublishHint:
setRetryCount:
setChannelIdentity:
setPublishPayloadExpiryTtlMillis:
_createPayloadDataFromData:
setPublishPayload:
setPushPriority:
setChannelPublishPayload:
publishStatus:completion:
subscribedChannelsWithCompletion:
subscribeToChannels:
unsubscribeFromChannels:
dataWithJSONObject:options:error:
jwtTokenForPrimaryAccountWithError:
channelManager:didReceiveData:onChannel:dateReceived:dateExpired:
channelManager:failedToSubscribeToChannel:withError:
pushManager:didReceiveData:onChannel:dateReceived:dateExpired:
pushManager:failedToSubscribeToChannel:withError:
activeChannelSubscriptionsWithCompletion:
initWithPushManager:accountProvider:delegate:
setPushManager:
_pushManager
T@"<SKAPushManaging>",&,N,V_pushManager
T@"<SKAChannelManagingDelegate>",W,N,V_delegate
setStatus:
setHasStatus:
hasStatus
statusAsString:
StringAsStatus:
setRetryIntervalSeconds:
setHasRetryIntervalSeconds:
_retryIntervalSeconds
_status
Ti,N,V_status
TI,N,V_retryIntervalSeconds
_senderHandle
_invitedHandle
_statusTypeIdentifier
_invitationIdentifier
_dateInvitationCreated
_incomingRatchetState
_invitationPayload
T@"NSString",R,N,V_senderHandle
T@"NSString",R,N,V_invitedHandle
T@"NSString",R,N,V_statusTypeIdentifier
T@"NSString",R,N,V_invitationIdentifier
T@"NSDate",R,N,V_dateInvitationCreated
T@"NSData",R,N,V_incomingRatchetState
T@"NSData",R,N,V_invitationPayload
T@"SKHandle",R,N
T@"MPStatusKitIncomingRatchet",R,N
initWithData:dateCreated:
T@"SKInvitationPayload",R,N
_channelIdentifier
_lastSubscriptionDate
T@"NSString",R,N,V_channelIdentifier
T@"NSDate",R,N,V_lastSubscriptionDate
objectForKeyedSubscript:
dateWithTimeIntervalSince1970:
ska_dictionaryForKey:
_primarySystemiCloudAccountWithError:
aida_tokenWithExpiryCheckForService:
ska_sha256Hash
_shouldAttemptReauth
_markReauthAttempt
setAuthenticationType:
setIsUsernameEditable:
setServiceType:
aida_alternateDSID
setAltDSID:
authenticateWithContext:completion:
aida_accountForPrimaryiCloudAccount
_maxReauthCount
_authResetTime
tokenFetchQueue
setTokenFetchQueue:
_tokenFetchQueue
T@"NSObject<OS_dispatch_queue>",&,N,V_tokenFetchQueue
hasChannelId
hasChannelToken
_channelId
T@"NSData",&,N,V_channelId
T@"NSData",&,N,V_channelToken
addListener:
_initializeAPSConnection
_pushEnvironment
initWithEnvironmentName:namedDelegatePort:queue:
initWithAPSConnection:mobileNetworkManager:
isUnderFirstDataProtectionLock
_setNonWakingTopics:
_sharedChannelsIsDisabledByServer
initWithProtoData:messageType:
protoResponse
setCompletionBlock:
setTimeout:
messageDelivery
sendMessage:
nonWakingTopics
enabledTopics
setEnabledTopics:ignoredTopics:opportunisticTopics:nonWakingTopics:
initWithChannelID:
connection
subscribeToChannels:forTopic:
unsubscribeFromChannels:forTopic:
channelID
getRegisteredChannelsForTopic:completion:
isConnected
dateWithTimeIntervalSinceReferenceDate:
expirationDate
timestamp
failureReason
connection:didReceivePublicToken:
connection:didReceiveToken:forTopic:identifier:
connection:didReceiveIncomingMessage:
connection:didReceiveMessageForTopic:userInfo:
connection:didSendOutgoingMessage:
connection:didFailToSendOutgoingMessage:error:
connection:didChangeConnectedStatus:
connectionDidReconnect:
connection:channelSubscriptionsFailedWithFailures:
systemDidLeaveFirstDataProtectionLock
switchFilterToNonwaking
switchFilterToEnabled
T@"<SKAPushManagingDelegate>",W,N
initWithQueue:systemMonitor:
systemMonitor
setSystemMonitor:
setConnection:
setMessageDelivery:
_systemMonitor
_connection
_messageDelivery
T@"SKASystemMonitor",&,N,V_systemMonitor
T@"APSConnection",&,N,V_connection
T@"FTMessageDelivery",&,N,V_messageDelivery
T@"<SKAPushManagingDelegate>",W,N,V_delegate
_dateCreated
_datePublished
_dateReceived
_dateExpired
_rawData
_uniqueIdentifier
T@"NSString",R,C,N,V_channelIdentifier
T@"NSDate",R,C,N,V_dateCreated
T@"NSDate",R,C,N,V_datePublished
T@"NSDate",R,C,N,V_dateReceived
T@"NSDate",R,C,N,V_dateExpired
T@"NSData",R,N,V_rawData
T@"NSString",R,C,N,V_uniqueIdentifier
hasChannelIdentity
_channelIdentity
T@"ChannelIdentity",&,N,V_channelIdentity
weakToStrongObjectsMapTable
_addTransientSubscriptionAssertionForClient:subscriptionIdentifier:
_markCacheSubscriptionDateForChannelIdentifier:
updateRegisteredSubscriptionsForActiveAssertionsWithCompletion:
_removeTransientSubscriptionAssertionForClient:subscriptionIdentifier:
activeTransientSubscriptionsByClient
removeObjectForKey:
existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
createSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:statusTypeIdentifier:databaseContext:
deleteSubscriptionAssertionWithSubscriptionIdentifier:applicationIdentifier:databaseContext:
_fetchAllClientActiveSubscriptionAssertions
_activeTransientSubscriptionsForClient:
subscriptionIdentifier
initWithSubscriptionIdentifier:
createOrUpdateTransientSubscriptionHistoryForChannelIdentifier:lastSubscriptionDate:databaseContext:
addIndex:
enumerateObjectsUsingBlock:
removeObjectsAtIndexes:
_fetchAllActiveSubscriptionAssertionsWithCache
_sortAndDedupeSubscriptionIdentifiers:
_enforceSubscriptionsHardCapOnSubscriptionIdentifiers:
differenceFromArray:
removals
object
insertions
_activeTransientAssertionsExist
initWithArray:
sortDescriptorWithKey:ascending:selector:
sortedArrayUsingDescriptors:
_hardMaxSubscriptionCount
subarrayWithRange:
objectEnumerator
allPersistentSubscriptionAssertionChannelIdentifiersWithDatabaseContext:
_allPersonalChannelIdentifiersRequiringSelfSubscriptionWithDatabaseContext:
_maxSubscriptionCacheCount
_recentlyReleasedTransientSubscriptionAssertionIdentifiersExcludingSubscriptionIdentifiers:count:databaseContext:
_subscriptionTTL
existingRecentTransientSubscriptionHistoriesWithLimit:databaseContext:
allObjects
_statusTypeIdentifiersRequiringSelfSubscription
initWithDatabaseManager:channelManager:pushManager:
setActiveTransientSubscriptionsByClient:
_activeTransientSubscriptionsByClient
T@"NSMapTable",&,N,V_activeTransientSubscriptionsByClient
isEqualToTransientSubscription:
osActivity
_subscriptionIdentifier
_osActivity
T@"NSObject<OS_os_activity>",R,N,V_osActivity
T@"NSString",R,C,N,V_subscriptionIdentifier
clearOneofValuesForAuthCredentialOneof
hasSimpleJwt
authCredentialOneof
setAuthCredentialOneof:
setHasAuthCredentialOneof:
hasAuthCredentialOneof
authCredentialOneofAsString:
StringAsAuthCredentialOneof:
simpleJwt
_authCredentialOneof
_simpleJwt
T@"NSString",&,N,V_simpleJwt
Ti,N,V_authCredentialOneof
hasChannelPublishPayload
channelPublishPayload
_channelPublishPayload
T@"ChannelPublishPayload",&,N,V_channelPublishPayload
numberWithUnsignedLongLong:
setHasPublishInitiateTimestampMillis:
hasPublishInitiateTimestampMillis
hasPublishPayload
setHasPublishPayloadExpiryTtlMillis:
hasPublishPayloadExpiryTtlMillis
pushPriority
setHasPushPriority:
hasPushPriority
pushPriorityAsString:
StringAsPushPriority:
setHasPendingPublishHint:
hasPendingPublishHint
setHasScheduledPublishHint:
hasScheduledPublishHint
setHasRetryCount:
hasRetryCount
publishInitiateTimestampMillis
publishPayload
publishPayloadExpiryTtlMillis
pendingPublishHint
scheduledPublishHint
_publishInitiateTimestampMillis
_publishPayloadExpiryTtlMillis
_publishPayload
_pushPriority
_retryCount
_pendingPublishHint
_scheduledPublishHint
TQ,N,V_publishInitiateTimestampMillis
T@"NSData",&,N,V_publishPayload
TQ,N,V_publishPayloadExpiryTtlMillis
Ti,N,V_pushPriority
TB,N,V_pendingPublishHint
TB,N,V_scheduledPublishHint
TI,N,V_retryCount
initWithDelegate:
initWithDatabaseProvider:delegate:
initWithMachServiceName:
_setupMaintenanceActivity
serviceName
_publishingServiceListener:shouldAcceptNewConnection:
_subscriptionServiceListener:shouldAcceptNewConnection:
clientIsEntitledForAtLeastOneSubscriptionServiceType:
subscriptionServiceConnectedClients
removeObject:
publishingServiceConnectedClients
_kettleFeatureEnabled
donateReceivedStatusToBiomeOnChannel:
_shouldDonateToBiomeForStatusTypeIdentifier:
_senderHandlesForChannel:
userStatusChangeStream
initWithIDSHandles:statusChangeType:
source
sendEvent:
standardUserDefaults
initWithStatusPayload:isScheduledRequest:
cleanupDecommisionedChannelsWithDatabaseContext:
listener:shouldAcceptNewConnection:
databaseDidReceiveRemoteChangesForChannels:
databaseManager:didCreateChannel:
shutdown
logState
publishingServiceListener
setPublishingServiceListener:
publishingServiceConnectionQueue
setPublishingServiceConnectionQueue:
setPublishingServiceConnectedClients:
subscriptionServiceListener
setSubscriptionServiceListener:
subscriptionServiceConnectionQueue
setSubscriptionServiceConnectionQueue:
setSubscriptionServiceConnectedClients:
invitationManagerMessagingQueue
setInvitationManagerMessagingQueue:
invitationMessagingProvider
setInvitationMessagingProvider:
statusReceivingManager
setStatusReceivingManager:
_publishingServiceListener
_publishingServiceConnectionQueue
_publishingServiceConnectedClients
_subscriptionServiceListener
_subscriptionServiceConnectionQueue
_subscriptionServiceConnectedClients
_invitationManagerMessagingQueue
_invitationMessagingProvider
_statusReceivingManager
T@"NSXPCListener",&,N,V_publishingServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_publishingServiceConnectionQueue
T@"NSMutableArray",&,N,V_publishingServiceConnectedClients
T@"NSXPCListener",&,N,V_subscriptionServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_subscriptionServiceConnectionQueue
T@"NSMutableArray",&,N,V_subscriptionServiceConnectedClients
T@"NSObject<OS_dispatch_queue>",&,N,V_invitationManagerMessagingQueue
T@"<SKAMessagingProviding>",&,N,V_invitationMessagingProvider
T@"<SKAStatusReceivingManaging>",&,N,V_statusReceivingManager
handle
_handle
_dateRemoved
T@"NSString",R,N,V_handle
T@"NSDate",R,N,V_dateRemoved
createPersistentContainer
containerName
bundleForClass:
mergedModelFromBundles:
initWithName:managedObjectModel:
localPersistentStoreDescription
cloudPersistentStoreDescription
setPersistentStoreDescriptions:
loadPersistentStoresWithCompletionHandler:
defaultCenter
handlePersistentStoreRemoteChangeNotification:
addObserver:selector:name:object:
createCkContainer
ckContainerIdentifier
initWithContainerIdentifier:environment:
initWithContainerID:
defaultManager
URLForDirectory:inDomain:appropriateForURL:create:error:
URLByAppendingPathComponent:isDirectory:
fileManager
path
fileExistsAtPath:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
databaseDirectoryURL
localDatabaseFileURL
persistentStoreDescriptionWithURL:
setType:
setConfiguration:
setShouldAddStoreAsynchronously:
setOption:forKey:
cloudDatabaseFileURL
initWithContainerIdentifier:
setUseDeviceToDeviceEncryption:
setApsConnectionMachServiceName:
setCloudKitContainerOptions:
processPersistentStoreRemoteChanges
persistentContainer
fetchRequest
appTransactionAuthorName
predicateWithFormat:argumentArray:
setPredicate:
lastProcessedPersistentHistoryToken
fetchHistoryAfterToken:
setFetchRequest:
executeRequest:error:
result
changes
changedObjectID
entity
name
extractModifiedChannelFromPersistentStoreRemoteChangeForChannel:managedObjectContext:
extractModifiedChannelFromPersistentStoreRemoteChangeForReceivedInvitation:managedObjectContext:
lastObject
token
setLastProcessedPersistentHistoryToken:
performBlockAndWait:
changeType
existingManagedObjectWithID:managedObjectContext:
channel
existingObjectWithID:error:
lastProcessedPersistentHistoryTokenFileURL
dataWithContentsOfURL:
unarchivedObjectOfClass:fromData:error:
archivedDataWithRootObject:requiringSecureCoding:error:
writeToURL:atomically:
overrideDeviceEncryptionCheck
ckContainer
supportsDeviceToDeviceEncryption
accountInfoWithCompletionHandler:
databaseHasBeenCreated
historyProcessingQueue
setHistoryProcessingQueue:
setPersistentContainer:
setCkContainer:
_historyProcessingQueue
_persistentContainer
_ckContainer
T@"NSObject<OS_dispatch_queue>",&,N,V_historyProcessingQueue
T@"NSPersistentContainer",&,N,V_persistentContainer
T@"CKContainer",&,N,V_ckContainer
T@"<SKADatabaseProvidingDelegate>",W,N,V_delegate
_originalOutgoingRatchetState
_dateGenerated
T@"NSData",R,N,V_originalOutgoingRatchetState
T@"NSDate",R,N,V_dateGenerated
outgoingRatchet
dateInvitationCreatedKeyPath
senderHandleKeyPath
predicateForSenderHandleString:
predicateForSenderHandle:
sortDescriptorForDateInvitationCreatedOrderedAscending:
sortDescriptorForSenderHandleOrderedAscending:
dateGeneratedKeyPath
ska_appearsToBeEmail
_connection:isEntitledForSubscriptionWithStatusTypeIdentifier:
clientIsEntitledForAtLeastOneSubscriptionServiceType
T@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
applicationIdentifierKeyPath
predicateForApplicationIdentifier:
_statusPayload
_invitation
T@"SKStatusPayload",R,N,V_statusPayload
T@"SKADatabaseReceivedInvitation",R,N,V_invitation
invitationPayloadData
_invitationPayloadData
_dateInvitationPayloadCreated
T@"NSData",R,N,V_invitationPayloadData
T@"NSDate",R,N,V_dateInvitationPayloadCreated
_existingPersonalChannelForStatusTypeIdentifier:databaseContext:
andPredicateWithSubpredicates:
setSortDescriptors:
setFetchLimit:
executeFetchRequest:error:
deleteObject:
_existingChannelsForChannelIdentifier:databaseContext:
_existingChannelsForDatabaseChannel:databaseContext:
_existingReceivedInvitationsForHandle:statusTypeIdentifier:databaseContext:
refreshObject:mergeChanges:
allValues
initWithContext:
setStatusType:
setDecomissioned:
setPersonal:
setIdentifier:
save:
_existingPersonalChannelForDatabaseChannel:databaseContext:
setCurrentOutgoingRatchetState:
_existingPersonalChannelsForStatusTypeIdentifier:databaseContext:
setOriginalOutgoingRatchetState:
setDateGenerated:
addGeneratedEncryptionKeysObject:
generatedEncryptionKeys
_existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
_existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
setChannelIdentifier:
setApplicationIdentifier:
setStatusTypeIdentifier:
_existingTransientSubscriptionHistoryForChannelIdentifier:databaseContext:
setLastSubscriptionDate:
_existingTransientSubscriptionHistoryWithLimit:orderedByLastSubscriptionDateAscending:databaseContext:
setInvitedHandle:
setInvitationPayload:
setDateInvitationPayloadCreated:
setSenderHandle:
addInvitedUsersObject:
_existingInvitedUsersForDatabaseInvitedUser:databaseChannel:databaseContext:
_existingInvitedUsersForInvitedHandle:channel:databaseContext:
predicateForInvitedHandle:
predicateForChannel:
setUniqueIdentifier:
setDatePublished:
setDateReceived:
setRawData:
setDateExpired:
setPayloadData:
_existingPendingPublishRequestForUniqueIdentifier:databaseContext:
_existingPendingPublishRequestsForStatusTypeIdentifier:databaseContext:
_existingPendingPublishRequestsWithDatabaseContext:
setDateRemoved:
setRemovedHandle:
_existingRemovedUsersForHandle:statusTypeIdentifier:databaseContext:
setInvitationIdentifier:
setDateInvitationCreated:
setIncomingRatchetState:
addReceivedInvitationsObject:
receivedInvitations
_existingReceivedInvitationsForChannelIdentifier:sortedByDateReceived:databaseContect:
_existingDecomissionedPersonalChannelsWithDatabaseContext:
deletePersonalChannelForStatusTypeIdentifier:databaseContext:
T@"<SKADatabaseProviding>",R,N,V_databaseProvider
T@"<SKADatabaseManagingDelegate>",R,W,N,V_delegate
datePublishedKeyPath
uniqueIdentifierKeyPath
sortDescriptorForDatePublishedAscending:
valueForEntitlement:
_applicationIdentifier
T@"NSString",R,N,V_applicationIdentifier
bytes
initWithCapacity:
appendFormat:
_payloadData
_statusUniqueIdentifier
T@"NSString",R,C,N,V_statusTypeIdentifier
T@"NSData",R,N,V_payloadData
T@"NSString",R,C,N,V_statusUniqueIdentifier
Tq,R,N,V_retryCount
containsString:
UTF8String
stringWithCapacity:
invitedHandleKeyPath
channelKeyPath
initWithOptions:capacity:
_updateLockState
_listenForKeyBagChangeNotifications
_deviceStillUnderFirstLock
_deliverNotificationSelectorToListeners:
performSelectorOnMainThread:withObject:waitUntilDone:
removeListener:
ivarLock
setIvarLock:
underFirstLock
setUnderFirstLock:
listeners
setListeners:
_underFirstLock
_ivarLock
_listeners
T{os_unfair_lock_s=I},N,V_ivarLock
TB,N,V_underFirstLock
T@"NSHashTable",&,N,V_listeners
fetchRequestWithEntityName:
T@"NSData",&,D,N
T@"NSDate",C,D,N
TB,D,N
T@"NSString",C,D,N
T@"NSSet",&,D,N
T@"Channel",&,D,N
Ti,D,N
@16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@56@0:8@16@24@32@40@48
@24@0:8@16
@32@0:8@16@24
@"NSData"56@0:8@"SKStatusPayload"16@"NSString"24@"NSDate"32@"NSDate"40@"SKADatabaseChannel"48
@"SKAStatusUnencryptedEnvelope"24@0:8@"NSData"16
@"SKADecryptedStatusPayload"32@0:8@"NSData"16@"SKADatabaseChannel"24
@"NSString"24@0:8@"SKADatabaseChannel"16
@44@0:8@16S24@28@36
@44@0:8@16@24S32@36
v16@0:8
@"<SKADatabaseManaging>"
@"<SKAInvitationManaging>"
v24@0:8@16
@"NSDictionary"
v56@0:8@16@24@32@40@?48
v40@0:8@16@24@?32
v32@0:8@16@?24
v48@0:8@16@24@32@40
B32@0:8@16^@24
v48@0:8@16@24@32@?40
v56@0:8@"NSString"16@"NSArray"24@"SKHandle"32@"SKInvitationPayload"40@?<v@?B@"NSError">48
v40@0:8@"NSString"16@"NSArray"24@?<v@?@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSError">24
v48@0:8@"NSDictionary"16@"SKHandle"24@"SKHandle"32@"NSString"40
B32@0:8@"NSString"16^@24
v32@0:8@"NSString"16@?<v@?B>24
v40@0:8@"SKHandle"16@"SKHandle"24@?<v@?B@"NSError">32
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?@"SKHandleInvitability"@"NSError">40
@"SKHandle"24@0:8@"SKHandle"16
@"<SKAInvitationManagingDelegate>"16@0:8
v24@0:8@"<SKAInvitationManagingDelegate>"16
@48@0:8@16@24@32@40
B40@0:8@16@24^@32
B48@0:8@16@24@32^@40
@48@0:8@16@24^B32^@40
@"<SKAInvitationManagingDelegate>"
@"<SKAMessagingProviding>"
@"<SKAChannelManaging>"
@"<SKAAccountProviding>"
@"NSObject<OS_dispatch_queue>"
@20@0:8B16
@24@0:8^{_NSZone=}16
i16@0:8
v20@0:8i16
v20@0:8B16
@20@0:8i16
i24@0:8@16
@"AuthCredential"
@"NSString"
{?="channelOwnershipType"b1}
B32@0:8@16@24
@24@0:8@?16
@"NSXPCConnection"
@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>"
v52@0:8@16@24d32B40@?44
v32@0:8@16@24
v24@0:8q16
v52@0:8@"SKStatusPublishRequest"16@"NSString"24d32B40@?<v@?@"NSString"@"NSError">44
v32@0:8@"NSString"16@"SKStatusPublishRequest"24
v60@0:8@16@24d32B40Q44@?52
v24@0:8d16
v40@0:8@16@24@32
d16@0:8
q16@0:8
@"<SKAStatusEncryptionManaging>"
@72@0:8@16@24B32B36@40@48@56@64
@"NSData"
@"NSArray"
v64@0:8@16@24@32@40@48@56
v56@0:8@16@24@32@40@48
v56@0:8@16@24q32@40@48
v52@0:8@16@24@32B40@44
v60@0:8@16@24@32B40@44@52
v56@0:8@16@24@32q40q48
v64@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"NSString"48@"IDSMessageContext"56
v40@0:8@"IDSService"16@"NSString"24@"NSArray"32
v56@0:8@"IDSService"16@"IDSAccount"24@"NSDictionary"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSProtobuf"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSString"40@"IDSMessageContext"48
v64@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSDictionary"40@"NSString"48@"IDSMessageContext"56
v56@0:8@"IDSService"16@"IDSAccount"24q32@"NSString"40@"IDSMessageContext"48
v32@0:8@"IDSService"16@"NSSet"24
v32@0:8@"IDSService"16@"NSArray"24
v52@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44
v60@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44@"IDSMessageContext"52
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32q40q48
v48@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@40
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@"NSString"40@48
v48@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSDictionary"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSData"48
v40@0:8@"IDSService"16@"IDSAccount"24@"IDSGroupSessionParticipantUpdate"32
v24@0:8@"IDSService"16
v40@0:8@"IDSService"16@"IDSDevice"24@?<v@?>32
B48@0:8@"NSDictionary"16@"SKHandle"24@"SKHandle"32^@40
B48@0:8@"NSDictionary"16@"NSArray"24@"SKHandle"32^@40
v32@0:8@"SKHandle"16@?<v@?B>24
B24@0:8@"SKHandle"16
@"<SKAMessagingProvidingDelegate>"16@0:8
v24@0:8@"<SKAMessagingProvidingDelegate>"16
@40@0:8@16@24@32
v32@0:8@16q24
@"<SKAMessagingProvidingDelegate>"
@"IDSService"
v40@0:8@"SKStatusPublishRequest"16@"NSString"24@?<v@?@"NSString"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSArray"@"NSError">24
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?B@"NSError">40
v56@0:8@"NSArray"16@"SKHandle"24@"SKInvitationPayload"32@"NSString"40@?<v@?@"NSError">48
v40@0:8@"NSArray"16@"NSString"24@?<v@?@"NSError">32
v24@0:8@"SKAStatusPublishingServiceClientConnection"16
@72@0:8@16@24@32@40@48@56@64
v24@0:8@?16
d32@0:8@16d24
d24@0:8@16
@"SKAStatusPublishingServiceClientConnection"
@"<SKAStatusPublishingServiceClientDelegate>"
@"<SKADatabaseProviding>"
@"SKAInvitationManager"
@"<SKAStatusPublishingManaging>"
v36@0:8@16B24@?28
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSArray"@"NSError">28
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSArray"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">24
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError">32
v48@0:8@"NSString"16@"NSString"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKSubscriptionValidationTokens"@"NSError">32
v48@0:8@"SKSubscriptionValidationTokens"16@"SKHandle"24@"NSString"32@?<v@?q@"NSError">40
v24@0:8@"SKAStatusSubscriptionServiceClientConnection"16
@64@0:8@16@24@32@40@48@56
q40@0:8@16@24@32
B40@0:8@16@24@32
@"SKAStatusSubscriptionServiceClientConnection"
@"<SKAStatusSubscriptionServiceClientDelegate>"
@"<SKAStatusSubscriptionManaging>"
v56@0:8@"NSData"16@"NSString"24@"NSDate"32@"NSDate"40@"NSDate"48
@"<SKAStatusReceivingManagingDelegate>"
v56@0:8@"<SKAPushManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAPushManaging>"16@"NSString"24@"NSError"32
v72@0:8@16@24@32@40B48B52Q56@?64
v24@0:8@?<v@?@"NSString"@"NSData"@"NSError">16
v72@0:8@"NSData"16@"NSString"24@"NSData"32@"NSDate"40B48B52Q56@?<v@?@"NSError">64
v24@0:8@?<v@?@"NSArray">16
v24@0:8@"NSArray"16
@"NSDate"16@0:8
@"<SKAPushManaging>"
@"<SKAChannelManagingDelegate>"
v20@0:8I16
I16@0:8
{?="retryIntervalSeconds"b1"status"b1}
@"NSDate"
@24@0:8^@16
@"NSString"24@0:8^@16
v24@0:8@?<v@?B@"NSError">16
v28@0:8@16B24
v32@0:8@"APSConnection"16@"NSData"24
v48@0:8@"APSConnection"16@"NSData"24@"NSString"32@"NSString"40
v32@0:8@"APSConnection"16@"APSIncomingMessage"24
v40@0:8@"APSConnection"16@"NSString"24@"NSDictionary"32
v32@0:8@"APSConnection"16@"APSOutgoingMessage"24
v40@0:8@"APSConnection"16@"APSOutgoingMessage"24@"NSError"32
v28@0:8@"APSConnection"16B24
v24@0:8@"APSConnection"16
v32@0:8@"APSConnection"16@"NSArray"24
v32@0:8@"NSData"16@?<v@?@"NSData"@"NSError">24
@"<SKAPushManagingDelegate>"16@0:8
v24@0:8@"<SKAPushManagingDelegate>"16
@"<SKAPushManagingDelegate>"
@"SKASystemMonitor"
@"APSConnection"
@"FTMessageDelivery"
@"ChannelIdentity"
v48@0:8@"NSString"16@"NSString"24@"<SKAClientConnectionRepresentable>"32@?<v@?@"NSError">40
v32@0:8@"<SKAClientConnectionRepresentable>"16@?<v@?@"NSError">24
v24@0:8@?<v@?@"NSError">16
v32@0:8@"NSString"16@?<v@?@"NSArray">24
@40@0:8@16q24@32
@"NSMapTable"
@"NSObject<OS_os_activity>"
{?="authCredentialOneof"b1}
@"ChannelPublishPayload"
v24@0:8Q16
{?="publishInitiateTimestampMillis"b1"publishPayloadExpiryTtlMillis"b1"pushPriority"b1"retryCount"b1"pendingPublishHint"b1"scheduledPublishHint"b1}
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
v56@0:8@"NSString"16@"NSDictionary"24@"NSString"32@"NSString"40@"NSString"48
v56@0:8@"<SKAChannelManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAChannelManaging>"16@"NSString"24@"NSError"32
v40@0:8@"<SKAStatusReceivingManaging>"16@"SKADatabaseStatus"24@"SKADatabaseChannel"32
v32@0:8@"<SKADatabaseManaging>"16@"SKADatabaseChannel"24
v40@0:8@"<SKAInvitationManaging>"16@"SKADatabaseReceivedInvitation"24@"SKADatabaseChannel"32
v32@0:8@"<SKAInvitationManaging>"16@"SKADatabaseChannel"24
v24@0:8@"SKAStatusPublishingServiceClient"16
v24@0:8@"SKAStatusSubscriptionServiceClient"16
@"NSXPCListener"
@"NSMutableArray"
@"<SKAStatusReceivingManaging>"
@"NSManagedObjectContext"16@0:8
v24@0:8@?<v@?B>16
@"<SKADatabaseProvidingDelegate>"
@"NSPersistentContainer"
@"CKContainer"
@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>"
@"SKStatusPayload"
@"SKADatabaseReceivedInvitation"
@36@0:8@16B24@28
@32@0:8q16@24
@80@0:8@16@24@32@40@48@56@64@72
@"SKADatabaseChannel"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"36@0:8@"NSString"16B24@"NSManagedObjectContext"28
@"SKADatabaseChannel"48@0:8@"NSString"16@"NSString"24@"NSData"32@"NSManagedObjectContext"40
B32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseChannel"40@0:8@"SKADatabaseChannel"16@"NSData"24@"NSManagedObjectContext"32
@"SKAGeneratedEncryptionKey"40@0:8@"NSData"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"NSArray"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"NSArray"24@0:8@"NSManagedObjectContext"16
@"NSArray"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"48@0:8@"NSString"16@"NSString"24@"NSString"32@"NSManagedObjectContext"40
B40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSDate"24@"NSManagedObjectContext"32
@"NSArray"32@0:8q16@"NSManagedObjectContext"24
@"NSArray"40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"SKADatabaseInvitedUser"48@0:8@"SKInvitationPayload"16@"SKADatabaseInvitedUser"24@"SKADatabaseChannel"32@"NSManagedObjectContext"40
@"SKADatabaseInvitedUser"56@0:8@"SKHandle"16@"SKHandle"24@"SKInvitationPayload"32@"SKADatabaseChannel"40@"NSManagedObjectContext"48
B40@0:8@"SKADatabaseChannel"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"80@0:8@"NSString"16@"NSDate"24@"NSDate"32@"NSDate"40@"NSDate"48@"NSData"56@"NSString"64@"NSManagedObjectContext"72
@"SKADatabaseStatus"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"32@0:8@"NSString"16@"NSManagedObjectContext"24
v40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabasePendingPublishRequest"56@0:8@"NSString"16@"NSDate"24@"NSData"32@"NSString"40@"NSManagedObjectContext"48
@"SKADatabasePendingPublishRequest"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"NSArray"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseRemovedUser"48@0:8@"SKHandle"16@"NSDate"24@"NSString"32@"NSManagedObjectContext"40
@"SKADatabaseRemovedUser"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseReceivedInvitation"80@0:8@"SKADatabaseChannel"16@"SKHandle"24@"SKHandle"32@"NSString"40@"NSDate"48@"NSData"56@"NSData"64@"NSManagedObjectContext"72
v40@0:8@"NSString"16@"SKADatabaseReceivedInvitation"24@"NSManagedObjectContext"32
v24@0:8@"NSManagedObjectContext"16
v40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@36@0:8q16B24@28
@"<SKADatabaseManagingDelegate>"
@56@0:8@16@24@32@40q48
v24@0:8:16
{os_unfair_lock_s=I}16@0:8
v20@0:8{os_unfair_lock_s=I}16
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"NSHashTable"
@(#)PROGRAM:StatusKitAgentCore  PROJECT:StatusKit-1
O>ADGJM8
'*-036
)JVy
v8@?0
com.apple.StatusKit
SKAStatusEncryptionManager
com.apple.StatusKit.InvitationManager.cleanup
v24@?0@"SKADatabaseChannel"8@"NSError"16
com.apple.availability
com.apple.statuskit.cleanup
v12@?0B8
v20@?0B8@"NSError"12
v32@?0@"NSString"8@"NSData"16@"NSError"24
Sender handle is invalid, or could not determine a valid default sender handle.
Invited handles are invalid
Could not find or create a channel to send invitation for status of type "%@".
Key roll failed
Could not uninvite handle(s) "%@" because we could not find an existing invitation for those handle(s)
Could not any existing invitations to delete
SKAInvitationManager
lastSubscriptionDate
channelIdentifier
%K == %@
dateRemoved
removedHandle
statusTypeIdentifier
%@ %@
channel_topic
auth_credential
channel_ownership_type
SELF_USER_OWNERSHIP
(unknown: %i)
identifier
personal
decomissioned
statusType
encryptionKeys
dateChannelCreated
%K != nil
v16@?0@"NSError"8
com.apple.StatusKit.publish.types
com.apple.StatusKit.publish.allTypes
<%@ PID=%ld>
SKAStatusPublishingServiceClientConnection
com.apple.StatusKitAgent
lastPublishTime
rapidPublishCount
com.apple.StatusKitAgent.PublishingManager
com.apple.statuskit.pendingPublish
v24@?0@"NSString"8@"NSError"16
shared-channels-stale-publish-wait-time-seconds
shared-channels-rate-limit-wait-time-seconds
shared-channels-request-retry-count
shared-channels-client-rate-limit-max-rapid-publishes
shared-channels-client-rate-limit-rapid-publish-time-seconds
SKAStatusPublishingManager
Could not find or create a channel to publish status of type "%@".
Status Publish Request %@ created at %@ is not newer than existing status %@ at %@
Status Publish Request has the same status unique identifier as existing status: %@
Status Publish Request has been rate-limtited
<%@: %p; identifier = "%@"; personal = %ld, decomissioned = %ld, statusType = "%@"; dateCreated = "%@">;
SKADatabaseChannel
%@_%p
v16@?0q8
No valid IDS destinations could be determined
status-kit-keysharing-disabled
SKAMessagingProvider
Client is not entitled to publish status of type "%@". Missing entitlement "%@"
Could not determine any users to share with from request
System iCloud account does not exist or is not statuskit capable
Could not determine sender handle to use
dateCreated of StatusPayload differs too much from server time
SKAStatusPublishingServiceClient
v24@?0@"SKHandleInvitability"8@"NSError"16
shared-channels-scheduled-publish-variance-max-slop-period-seconds
shared-channels-unscheduled-publish-variance-max-slop-period-seconds
shared-channels-secondary-device-republish-variance-min-slop-period-seconds
Client is not entitled to subscription information for status of type "%@". Missing entitlement "%@"
com.apple.StatusKit.subscribe.types
Client is not entitled to subscription information for status. Missing entitlement "%@"
Subscription not found matching subscription identifier: "%@"
SKAStatusSubscriptionServiceClient
v16@?0@"NSArray"8
com.apple.StatusKit.StatusReceivingManager.cleanup
SKAStatusReceivingManager
dateCreated
statusUniqueIdentifier
SKAChannelManagerErrorDomain
SKAChannelManagerErrorRetryIntervalKey
StatusKitDataKey
com.apple.icloud.presence.mode.status
Generic non-success response status
v24@?0@"NSData"8@"NSError"16
SKAChannelManager
Could not fetch JWT token for authenticating request
SUCCESS
AUTH_EXPIRED
AUTH_FAILED
BAD_REQUEST
CHANNEL_IDENTITY_VALIDATION_FAILED
INTERNAL_ERROR
STALE_PUBLISH_REJECTED
RATE_LIMITED
status
retry_interval_seconds
<%@: %p; identifier = "%@"; dateCreated = "%@"; invitationPayload: "%@">
SKADatabaseReceivedInvitation
com.apple.gs.sharedchannels.auth
lastReauthTime
reauthCount
v24@?0@"NSDictionary"8@"NSError"16
shared-channels-reauth-max-count
shared-channels-reauth-backoff-time-seconds
SKAAccountProvider
channel_id
channel_token
com.apple.aps.StatusKit
SKPushManagerErrorDomain
IMMobileNetworkManager
skipAuth
v40@?0@"IDSBaseMessage"8@"NSError"16q24@"NSDictionary"32
shared-channels-disabled
SKAPushManager
<%@: %p; uniqueIdentifier = "%@"; channelIdentifier = "%@"; dateCreated = "%@">;
channel_identity
lastFaultTime
com.apple.StatusKitAgent.SubscriptionManager
v32@?0@"SKATransientSubscriptionAssertion"8Q16^B24
com.apple.focus.status
shared-channels-subscription-cache-size
shared-channels-max-subscription-size
shared-channels-subscription-ttl-minutes
SKAStatusSubscriptionManager
<%@: %p; subscriptionIdentifier = %@
SKATransientSubscriptionAssertion
simple_jwt
auth_credential_oneof
PBUNSET
channel_publish_payload
publish_initiate_timestamp_millis
publish_payload
publish_payload_expiry_ttl_millis
push_priority
pending_publish_hint
scheduled_publish_hint
retry_count
NORMAL
HIGH
com.apple.private.alloy.status.keysharing
com.apple.StatusKit.publish
com.apple.StatusKit.subscribe
SKAStatusServer
BiomeDonationEnabled
Kettle
FeatureComplete
com.apple.statuskit.maintenance
v16@?0@"NSObject<OS_xpc_object>"8
com.apple.StatusKitAgent.CoreData.historyProcessing
v24@?0@"NSPersistentStoreDescription"8@"NSError"16
StatusKitAgent
SKADatabaseModel
com.apple.statuskit
StatusKit
database
statuskit-local-v1.db
statuskit-cloud.db
lastProcessedPersistentHistoryToken.data
Local
com.apple.aps.StatusKit.CloudKitMirroring
Cloud
author != %@
v24@?0@"CKAccountInfo"8@"NSError"16
skipHSA2
SKADatabaseProvider
SKAGeneratedEncryptionKey
dateInvitationCreated
senderHandle
dateGenerated
com.apple.StatusKit.subscribe.allTypes
SKAStatusSubscriptionServiceClientConnection
applicationIdentifier
<%@: %p; statusPayload = "%@"; invitation = "%@">;
v32@?0@"ReceivedInvitation"8Q16^B24
v32@?0@"Channel"8Q16^B24
SKADatabaseManager
datePublished
uniqueIdentifier
%02lx
%02x
invitedHandle
channel
SKASystemMonitor
Channel
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
Channel does not have a current outgoing ratchet, rolling encryption key to generate a new one.
Encryption key rolled successfully, fetching new key
Key roll failed, unable to encrypt status
Error encrypting status: %@
Message encrypted successfully
Unable to encrypt status due to nil outgoing encryption key
Attempting to decrypt incoming status on personal channel using keys from %ld outgoing ratchets.
Status payload successfully decrypteded from generatedKey: %@
Status payload not decrypteded from generatedKey: %@
Status payload failed to decrypt with all known generated encryption keys.
Attempting to decrypt incoming status on non personal channel using incoming ratchet state from %ld received invitations.
Status payload successfully decrypteded from invitation: %@
Status payload not decrypted from invitation: %@
Status payload failed to decrypt with all known invitations.
Decrypteded payload: %@
Status payload failed to decrypt with error: %@
Status payload decypted to nil data
Status payload successfully decrypted
Extracting status payload, but envelope dictionary is not deserializable. Returning nil payload.
Extracting status payload, but encrypted payload is missing, is this an empty status update, or a malformed status: %@
Failed to extract status payload, signature is missing: %@
Failed to extract status payload, ratchet index is missing: %@
Failed to extract status payload, ratchet index is an invalid number: %@
Successfully decrypted status payload
Failed to decrypt status payload
Finding most recent incoming ratchet for personal channel from %ld outgoing ratchets.
Finding most recent incoming ratchet for non personal channel using incoming ratchet state from %ld received invitations.
Unable to find most recent incoming ratchet for channel: %@
Error serializing status envelope dictionary: %@
Error deserializing status envelope data as dictionary: %@
Request to invite handles contains no valid handles to invite. InvitedHandles: %@
Error resolving sender handle. UnresolvedSenderHandle: %@
Error fetching or creating personal channel: %@
Could not find or create personal channel
Adding invited handles %@ to database for channel: %@
Inivtation was not sent for handles %@ due to key roll error: %@
Invitations for newly invited handles %@ was already sent during key roll, skipping individual message send.
Invitation failed with error: %@
Could not find existing personal channel to revoke all invitations for
Finished deleting all invited user database records for channel %@, initiating key roll
Unable to find any invitations to revoke, taking no action, returning error
Could not find existing personal channel to revoke invitations for
Successfully deleted database record for invited user: %@.  Adding to removed users
Unable to find database record for invited user attempted to delete: %@
Finished deleting database records for uninvited users, initiating key roll
Received request to roll encryption key for personal channel with statusTypeIdentifier: %@
Not rolling encryption key because a personal channel does not exist for statusTypeIdentifier: %@
Error encounted during key roll for statusTypeIdentifier: %@ error: %@
Received request to roll personal channel with statusTypeIdentifier: %@
Channel creation failed! Aborting channel roll.
Failed to copy invited users! Aborting channel roll.
Succesfully rolled personal channel with statusTypeIdentifier: %@
Asked to roll personal channel for %@, but no channel exists
Generating new outgoing ratchet
Storing newly generated outgoing ratchet
Messaging %ld existing invited users with the newly generated subscription keys
Outgoing IDS messages for encryption key roll failed to send: %@
Not sending any invitations following key roll as there are no invited users for channel %@
Failing to send invitation to zero invited users
Error generating incoming ratchet: %@
Error serializing incoming ratchet
Database InvitedUser does not have an invited SKHandle: %@
Sending invitation message with new encryption key ratchet index %ld to handle "%@" with invitation payload %@
Invitation sent successfully
Invitation send failed with error: %@ message: %@
Invited handle failed validation, ignoring: %@
Validated invited handle set does not match unvalidated handles. Unvalidated set may have contained duplicate or invalid handles. Validated: %@ Unvalidated: %@
Incoming invitation from handle: %@
Invitation message missing channel identifier, dropping invitation: %@
Invitation message missing status type identifier, dropping invitation: %@
Invitation message uses legacy status type identifier, dropping invitation: %@
Invitation message missing incoming ratchet state, dropping invitation: %@
Invitation message missing date invitation created, dropping invitation: %@
No existing channel matches incoming invitation, creating new channel
Could not find or create channel for incoming invitation, dropping invitation.
Storing received invitation
Cleaning up ReceivedInvitations for channel: %@
Removing old channels for handle: %@
fromHandle "%@" is NOT a valid sender handle for active iCloud account
fromHandle "%@" is a valid sender handle for active iCloud account
toHandle "%@" inviteability check completed with result: %d
Handle is invalid, and not inviteable: %@
handle "%@" is present as a removed user
Channel has no existing encryption key data, initiating key roll to generate first key
Generating first encryption key for personal channel failed: %@
Found existing encryption keys, attempting to ratchet forward from current ratchet index: %ld
Rolling encryption key for personal channel failed: %@
Ratchet forward succeeded. New ratchet index: %ld. Persisting this state.
Error fetching or update invited user for handle: %@
Removing handle %@ from removed users because of invite
Invited handle has a nil handle string: %@
Found %ld existing invited user for invitedHandle %@ (ignoring sender handle).
Existing invited user was invited from the same handle: %@. Updating payload, and not creating a new InvitedUser record.
Existing invited user was invited from %@, but we are attempting to invite from %@. Will update this users payload, but may still need to create a new InvitedUser record
Updating invitation payload on invitedUser: %@
Received a nil updated user from call to updateInvitationPayload
Invitation payload is already up to date
Could not find an existing invited user matching handle: %@ and senderHandle %@, attempting to create a new one.
Received a nil created user from createInvitedUserWithHandle
Could not find an existing personal status channel, attempting to create a new one.
Account refresh required for error: %@
Account refresh succeeded, reattempting channel creation
Account refresh failed with error: %@
Error is an auth expired error, we should attempt reauth
Error is an auth failed error, we should attempt reauth
Error is an auth missing auth token error, we should attempt reauth
Error does not appear to be auth related, we should not attempt reauth
XPC connection to PID %ld interrupted
XPC connection to PID %ld invalidated
XPC Error (async): %{public}@
XPC Error (synchronous): %{public}@
Deallocing {pointer: %p}
Client is not entitled for any status types
Client is not entitled to publish status of type %{public}@
Client is currently rate-limited.  Enqueing requests as pending publish.
Publishing status unique identifier: %@ to channel: %@
Error publishing status with the channel manager: %@
Attempting reauth to resolve error
Account refresh succeeded, publishing pending publish requests
Removing pending publish based on error
Rolling channel.
Channel was rolled succesfully.
Channel roll failed.
Not rolling channel because this is a secondary device publish.
Attempting retry with delay.
Retrying after %f sec delay
Retry interval is 0--not retrying
Successfully published status %@ to channel %@
Dropping and removing status publish request with unique identifier %@. Error: %@
Could not find or create a personal channel for statusTypeIdentifier %@ error: %@
Pending publish request has already been scheduled.  Not enqueing again
Will attempt to process %ld pending publish requests after a %.2f second delay
Skipping publish of pending request that lacks an status identifier
Deleting pending status with ID %@ as it has expired
Deleting pending status with ID %@ as it has passed the max retry count of %lu
Attempting to publish pending request with ID: %@
Publish of pending status request with ID:%@ finished with error:%@
No pending publish requests
Publish requested for reason: %lu
Dropping status publish request, a status with unique identifier %@ has already been published. PublishRequest: %@
Dropping status publish request, existing status %@ was created at %@, publish request %@ from %@ is not newer.
In window for rate limit backoff.  We'll be free again at %@
We've left the rate-limit backoff window.
Incrementing rapid publish counter.
Deleting pending publish request with ID: %@ because it is older than newly received publish request with ID %@
Creating new pending status publish request for status unique identifier: %@
Pending status publish request already exists for status unique identifier: %@
StatusTypeIdentifier %@ corresponds to personal channel %@
Could not find an existing personal status channel for statusTypeIdentifier %@, attempting to create a new one.
Channel creation request failed with error: %@
Channel creation request succeeded, new personal channel for statusTypeIdentifier %@ has channel identifier %@
Deleting pending status publish request with identifier: %@
Delete failed for pending status publish request with identifier: %@
Publish was rejected for being stale. Abandoning.
Publish was rejected for being malformed. Abandoning.
Channel identity validation failed. We should roll this channel.
Publish was rejected because we've hit a rate limit.
Server bag indicates our pending publish request delay time should be %.2f
Server bag indicates our rate limit delay time should be %.2f
Server bag indicates our max retry count should be %lu
Server bag indicates our max rapid publishes should be %lu
Server bag indicates our rapid publish timescale should be %lu
Failed to create currentOutgoingRatchet due to invalid data. Error: %@
Initializing messaging provider with service %@ and delegate %@
Keysharing has been disabled by the server! Not initializing messaging service
Keysharing has been disabled by the server! Not sending message
Failed to generate IDS destination for handle: %@
No valid IDS destinations generated from handles: %@
Sending message %@ to destinations %@ options: %@
Successfully sent invitation message, assigned message identifier: %@
Failed to send invitation message with error: %@
Sender handle "%@" is a valid sender handle for active iCloud account
Sender handle "%@" is NOT a valid sender handle for active iCloud account
Received incoming message: %@ fromID: %@
Keysharing has been disabled by the server! Dropping incoming message
Received didHintCheckingTransportLogWithReason
Resolved default caller ID: %@
Unable to determine default caller ID among URIs: %@
Keysharing has been disabled in the server bag!
Publishing service client connection was interrupted: %@
Publishing service client connection was invalidated: %@
Received request to publish status: %@
Rejecting publish request, client is not entitled
Account is not StatusKit capable
dateCreated not set on statusPublishRequest:%@. Setting to serverTime: %@
dateCreated time differs too much from server time.  delta = %f
Personal channel does not exist for status type identifier
Attempting to determine if handle %@ has already been invited from handle: %@
Error resolving sender handle for isInvited check. UnresolvedSenderHandle: %@
We found a match to an existing invited user
We found an existing invitated user matching the requested user, but that invitation was sent with handle %@ instead of handle %@. Ignoring.
We did not find a match to any existing invited user
Received request to send invitation for personal channel with statusTypeIdentifier %@ to handles: %@
Failed to send invitation to handles with error: %@
Successfully sent invitation to handles: %@
Received request to remove invitation from personal channel with statusTypeIdentifier %@ for handles: %@
Invitation revocation for handles %@ failed with error: %@
Invitation revocation for handles %@ completed succesffully
Received request to remove all invitations from personal channel with statusTypeIdentifier %@
Invitation revocation for all handles failed with error: %@
Invitation revocation for all handles completed succesffully
Client %@ has registered for delegate callbacks for statusTypeIdentifier: %@.
Server bag unexpected value type for key "%@". Value: %@
Resolved secondary device republish delay of %.1f seconds, within allowed range of (%.1f,%.1f) seconds.
XPC Error notifying of remote database changes. Error: %{public}@
Connected client completed processing of remote database changes.
Notifying client of updated subscription: %@
XPC Error notifying client of status update. Error: %{public}@
Connected client completed processing of status update.
Connected client does not match status type identifier of changed subscription. Client: %@ Status: %@
XPC Error notifying of received invitation. Error: %{public}@
Notifying connected client of received channel invitation.
Connected client completed processing of channel invitation.
Connected client does not match invited channel status type.
Current status for channel is expired
No existing status for channel
Beginning release of transient subscription assertions associated with interrupted client
Error releasing transient subscription assertions associated with interrupted client: %@
Success releasing transient subscription assertions associated with interrupted client
Beginning release of transient subscription assertions associated with invalidated client
Error releasing transient subscription assertions associated with invalidated client: %@
Success releasing transient subscription assertions associated with invalidated client
Client is not entitled to access subscription information for status type: %@
Retrieving subscription information for handle: %@
Subscription information not found for handle: %@
Found subscription metadata: %@ for handle %@
Retrieving all subscription information for statusTypeIdentifier: %@
Found %ld channels for status type %@
Retrieving all active assertions for statusTypeIdentifier: %@
Retrieving all subscription assertions for statusTypeIdentifier: %@ applicationIdentifier: %@
Found %ld subscription assertions
Subscription information not found for personal channel with statusTypeIdentifier: %@
Found subscription metadata for personal channel: %@
Received request to retain transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain transient subscription assertion for status type: %@
No subscription was found matching subscriptionIdentifier: %@ statusTypeIdentifier: %@
Error retaining transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release transient subscription assertion for status type: %@
Error releasing transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to retain persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain persistent subscription assertion for status type: %@
Error retaining persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release persistent subscription assertion for status type: %@
Error releasing persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request for subscription and encryption validation token for handle "%@" statusTypeIdentifier: %@
Found channel %@ matching handle: %@
Did not find a channel matching handle: "%@". Returning empty string to indicate no match.
Received request for validate token "%@" from handle "%@" for statusTypeIdentifier: %@
Validating tokens against personal channel: %@
Received invalid validity for subscription channel validation. Not validating encryption token.
Sender "%@" asked us to verify that we do not have a personal channel, and they are correct
Sender "%@" asked us to verify a channel validation token, but we don't have a personal channel, this device may be out of sync, returning unknown
Attempting to validate subscription channel token "%@" against personal channel with identifier "%@"
Sender "%@" asked us to verify that we do not have a personal channel, but we do have channel %@. Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid subscription channel validation token
Sender "%@" has supplied a subscription channel validation token "%@", that does not match our current personal channel identifier "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Attempting to validate encryption token "%@" against personal channel %@
Sender "%@" provided encryption validation token "%@", but we do not have a local value to validate against. Returning valid.
Sender "%@" provided an nil encryption validation token, but we expected "%@". For backward compatibility, we assume nil means they are on an older OS and we should not fail validation. Returning valid.
Sender "%@" provided an empty encryption validation token, but we expected "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid encryption validation token. Provided: "%@" Expected: "%@"
Sender "%@" has supplied an encryptoin validation token "%@", that does not match our expected value "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Validated subscriptionIdentifier: %@ statusTypeIdentifier: %@
Failed to validate. subscriptionIdentifier: %@ does not match statusTypeIdentifier: %@
Failed to validate subscriptionIdentifier: %@ statusTypeIdentifier: %@
Could not find channel matching incoming status update, ignoring.
Found channel matching channel identifier: %@.
Could not extract unencrypted envelope from incoming status update, ignoring.
Could not determine status unique identifier for incoming status update, ignoring.
Could not determine date published for incoming status update, ignoring.
Date created is too far in the future, ignoring.
We've already received a status with this unique identifier (%@), ignoring.
Received new status %@ for channel %@
Saved incoming status update to database with unique identifier: %@
Not informing delegate of status because it has expired
Received request to create a personal channel
Unable to fetch JWT token for icloud account.  Failing request.
Asking push manager to execute create channel request
Channel create request failed with error: %@
Channel create response received
Create channle response contains non success status: %ld - %@
Retry interval specified: %ld
Channel create success response received: %@
Received request to publish data on channel %@
Unable to fetch JWT auth token.  Failing request.
Sending publish request to push manager
Publish status request contains error: %@
Publish status request contains neither error nor proto response
Handling protobuf response data for completed status publish request
Publish status request completed with nonsuccess response status: %ld
Publish status request completed with success
Fetching subscribed channels
Received %ld subscribed channels: %@
Subscribing to channels: %@
Unsubscribing from channels: %@
Retrieving JWT token from account provider
Could not fetch JWT token!: Error: %@
Received data on channel: %@
Failed to subscribe to channel: %@ Error: %@
Failed to create incomingRatchet due to invalid data. Error: %@
Unable to fetch system account! Likely no iCloud account signed in.
Unable to fetch JWT token!
Fetched token hash:%@
Reauth has hit rate limit.  Not attempting.
Unable to fetch account store!
Unable to fetch system account! Likely no iCloud account signed in. Error: %@
altDSID not available for account
Auth refresh suceeded.
Auth refresh failed with error: %@
Fetching primary iCloud account
Primary iCloud account determined: %@
Failed to find primary iCloud account
Server bag indicates our max reauth count should be %lu
Server bag indicates our reauth backoff time should be %lu
Received did leave first unlock notification.
Initializing APS connection.
Deferring connection initialization as device is before first unlock.
Using sandbox push environment
Using production push environment
Shared channels disabled by server! Aborting
No active APS connection. Cannot change topic filter.
Not under first data protection lock but no APS connection!
Trying to create a channel resulted in error %@
Create channel reverse push completed, calling completion with proto response
Sending create channel message.
Switching topic to non-waking
Switching topic to enabled
Publishing status
Publishing status failed with resultCode %ld error: %@
Publishing status, reverse push completed, calling completion with protobuf response data
Fetching subscribed channels completed with channels: %@
APSConnection server is disconnected. Using current system time
APSConnection server time is invalid. Using current system time
Receieved aps incoming message: %@ -- expiration: %@
Status kit message data undecodable
Channel subscription failed. Failures: %@
Shared channels has been disabled in the server bag!
Transient subscription assertion already existed, but still refreshing registered subscription assertions, to ensure apsd is in sync.
Failed to update registered subscriptions following transient assertion retain with error: %@
Successfully updated registered subscriptions following transient assertion retain
Successfully removed transient subscription assertion from in memory model for subscription identifier: %@
Could not find transient subscription assertion to remove from in memory model for subscription identifier: %@
Failed to update registered subscriptions following transient assertion release with error: %@
Successfully updated registered subscriptions following transient assertion release
Disconnecting client had no active transient subscription assertions, not updating registered subscriptions
Disconnecting client had %ld transient subscription assertion, removing transient assertions and updating registrations for channels: %@
Failed to update registered subscriptions following client disconnect with error: %@
Successfully updated registered subscriptions following client disconnect
A subscription assertion already exists, no need to create a new one. Existing: %@
Created subscription assertion: %@
Failed to update registered subscriptions following persistent assertion retain with error: %@
Successfully updated registered subscriptions following persistent assertion retain
Did not delete persistent subscription assertion because one was not found for subscription identifier: %@
Successfully removed persistent subscription assertion from database for subscription identifier: %@
Failed to update registered subscriptions following persistent assertion release with error: %@
Successfully updated registered subscriptions following persistent assertion release
Returning %lu active assertions.
Returning %lu active subscriptions.
Found an existing transient subscription assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added transient subscription assertion to in memory model for subscription identifier: %@
Not creating a new transient subscription assertion, one already exists.
Marking subscription change time for channel %@
Succesfully removed transient subscription assertion for identifier: %@. Client had %ld transient subscription assertions, now has %ld. Client: %@
Could not find transient subscription assertion for subscription identifier: "%@". Active transient subscription assertions: %@ for client: %@
StatusKitAgent wants to be subscribed to: %@
StatusKitAgent was previously subscriped to: %@
No changes for active subscriptions based on current assertions. Subscribed to: %@
Subscriptions updated. Subscribed to: %@
Active subscription count %ld does not exceed cap of %ld
Active subscription count %ld exceeds cap of %ld
Transient subscription assertions: %@
Persistent subscription assertions: %@
Personal channels requiring self subscription: %@
Cached channels for subscription: %@
Finding at most %ld cached channels to subscribe to
Personal channel has no identifier: %@
No personal channel for statusTypeIdentifier: %@
Server bag indicates our max subscription count should be %lu
Server bag indicates our hard max subscription count should be %lu
Server bag indicates our subscription TTL should be %f seconds
Creating TransientSubscriptionAssertion for channel "%@"
TransientSubscriptionAssertion
Deallocing TransientSubscriptionAssertion for channel "%@", releasing os_activity
Initializing
Shutting down
Logging state
Receiving XPC connection from PID %ld for publishing service
Receiving XPC connection from PID %ld for subscription service
Receiving XPC connection from PID %ld for unknown service name: %{public}@
Rejected XPC connection from PID %ld for publishing service. Client is not entitled for any publishing service.
Accepted XPC connection from PID %ld for publishing service
Rejected XPC connection from PID %ld for subscription service. Client is not entitled for any subscription service.
Accepted XPC connection from PID %ld for subscription service
Subscription service client was invalidated. Removing client: %@
Publishing service client was invalidated. Removing client: %@
Received remote database changes for channels: %@
Error updating subscriptions following remote database changes: %@
Success updating subscriptions following remote database changes
Could not find channel matching changed channelIdentifier: %@
Could not find any database channel matching changed channelIdentifiers
Incoming message received. Service: %@ senderID: %@ guid: %@
Handling message as key invite
Received network reachable notification
Kettle feature flag not enabled.  Exiting.
Failed to subscribe to channel %@ with error: %@
Server received status update: %@
Writing to Biome event with IDSHandle: %@, statusTypeIdentifier %@
Channel created with identifier: %@ type: %@
Updating registered subscription to allow self subscription to personal channel, if necessary
Updating registered subscription failed with error: %@
Updating registered subscription to allow self subscriptions completed
Received channel invitation on channel: %@
Revoked invitation(s) on channel: %@. Republishing current status
Finished republishing status.  ID:%@ error:%@
Couldn't decrypt current status on channel
No current status to republish
Scheduling maintenance XPC activity %@
Finished maintenance subscription update with error %@
Removing decomissioned channels
Creating persistent container
Failed to load persistent store. Error: %@ Store: %@
Completed loading of persistent store: %@
Completed creation of persistent container
Failed creation of persistent container
Persistent store remote change notification received.
Error executing history change request: %@
History change request found no results.
Have channel matching persistent history change. Channel: %@ Change: %@
Could not find channel matching persisent history change: %@
Ignoring delete channel change: %@
Have received invitation matching persistent history change. ReceivedInvitation: %@ Change: %@
ReceivedInvitation matching persistent history change has channel. Channel: %@ Change: %@
ReceivedInvitation matching persistent history change has not channel. ReceivedInvitation: %@ Change: %@
Could not find encryption key matching persisent history change: %@
Ignoring delete received invitation change: %@
Did not find object matching change history event. Object has already been deleted. Error: %@
Error fetching object matching change transaction. Error: %@
Last processed persistent history token is nil at URL %@
Error unarchiving last processed persistent history token. Error: %@
Error archiving last processed persistent history token. Error: %@
Archived last processed persistent history token is zero length
Overriding device-to-device encryption check because default has been set.
Account supports device-to-device encryption
Account does not support device-to-device encryption and is not statuskit capable
Failed to create outgoing ratchet due to invalid data. Error: %@
Failed to create outgoing ratchet due to nil outgoing ratchet state
Failed to create incoming ratchet due to failure to access subscription keys
Failed to create incoming ratchet due to lack of outgoing ratchet
Client is not entitled to subscription information for status of type %{public}@
Error fetching personal status channel. Error: %@
Fetch request for personal status channel type "%@" completed with result: %@
Error fetching decomissioned channel. Error: %@
Fetch request for decomissioned personal channels completed with %lu results
Deleted existing channel.
Could not find existing channel
More than one personal channel exists for channel identifier: %@
Beginning fetch request for channels with channel identifier: %@
Error executing fetch for subscription validation. Error: %@
Fetch request for channels by identifier returned a nil result
Fetch request for channel by identifier found no match.
Fetch request for channel by identifier completed with %ld result(s)
Preferring invitation %@ from %@ among %ld result(s)
Invitation %@ corresponds to channelIdentifier: %@
Could not find any channels associated with channel identifier: %@
Invitation does not correspond to any channel. InvitationIdentifier: %@
No received invitation found matching handle %@ statusTypeIdentifier: %@
Invitation does not correspond to any channel. ReceivedInvitation: %@ handle: %@
Channel not found for channel identifier: %@
Beginning fetch request for channel by handle
Error executing fetch for channel by handle. Error: %@
Fetch request for channel by handle found no match.
Fetch request for channel by handle completed with %ld result(s)
Error saving managed object context for storing new personal channel. Error: %@
Error saving managed object context for storing channel invitation. Error: %@
Error saving managed object context for updated outgoing ratchet state. Error: %@
Error saving managed object context for decomissioning. Error: %@
Could not find generated ratchet keys matching database channel. Channel: %@
Beginning fetch request for active subscription assertions
Error fetching subscription assertions. Error: %@
Fetch request for active subscription assertions completed
Error saving managed object context for storing persistent subscription assertion. Error: %@
Deleted existing assertion.
Could not find existing assertion
Error fetching transientSubscriptionHistory. Error: %@
Error fetching transientSubscriptionHistories. Error: %@
Found existing transient subscription history. Updating lastSubscrionDate.
Could not find existing transient subscription history. Creating a new one.
Error saving managed object context for storing transient subscription history. Error: %@
Error saving managed object context for storing invited user. Error: %@
Error saving managed object context for copyinh invited users. Error: %@
Multiple (%ld) entries in the database match a single invited user, updating all of them. InvitedUser: %@
Error saving managed object context for updating invitation payload on invited user. Error: %@
Error finding core data invited user to update invitation. No match for SKADatabaseInvitedUser: %@
Error finding core data channel matching SKADatabaseChannel: %@
Error fetching invited user. Error: %@
Fetch request for invited user executed with results: %@
Failed to normalize handle: "%@", returning nil existing invited user
Deleting existing invited user with handle: %@
Error saving managed object context for deleting invited users by handle. Error: %@
Could not find existing invited user matching handle: %@
Could not find existing database channel matching channel %@
Deleting all %ld existing invited users for channel %@
Error saving managed object context for deleting all invited users. Error: %@
Could not find any existing invited users to delete
Error saving managed object context for storing status. Error: %@
Beginning lookup of most recent status for channel
Error executing fetch for status by channel. Error: %@
Fetch request for status by channel found no match.
Fetch request for status by channel completed with %ld result(s)
Beginning lookup of most recent status for unique id
Error executing fetch for status by unique id. Error: %@
Fetch request for status by unique id found no match.
Fetch request for status by unique id completed with %ld result(s)
Beginning database cleanup of statuses on channel identifier: %@
Error executing fetch for status cleanup. Error: %@
Fetch request for cleanup of statuses found no matches.
Fetch request for status cleanup completed with %ld result(s)
Keeping status %@ because it is our most recent status
Keeping status %@ because it is excluded from this cleanup request
Deleting status %@ as it is no longer the most recent
Error saving managed object context for status cleanup. Error: %@
Error fetching pending requests. Error: %@
Error saving managed object context for storing pending publish request. Error: %@
Error saving managed object context for deleting pending publish request. Error: %@
Deleted existing pending publish request with identifier: %@
Could not find existing pending publish request with identifier: %@
Error saving managed object context for incrementing pending publish request. Error: %@
Incremented pending publish request rc with identifier: %@
Error saving managed object context for storing removed user. Error: %@
Error saving managed object context for deleting removed user. Error: %@
Deleted existing removed user with handle: %@
Could not find existing removed user with handle: %@
Error fetching removed users. Error: %@
Beginning fetch request for ReceivedInvitation from handle %@ statusTypeIdentifier: %@
Error executing fetch for ReceivedInvitation by handle. Error: %@
Fetch request for ReceivedInvitation by handle found no match.
Fetch request for ReceivedInvitation by handle completed with %ld result(s)
Could not find core data channel to match channel identifier: %@
Error saving managed object context for storing received invitation. Error: %@
Could not find any existing channels matching channel identifier. Returning no received invitations. Channel identifier: %@
Keeping invitation %@ because it is at index %ld when ordered by recency and we are keeping the %ld most recent
Keeping invitation %@ because it was excluded by the caller
Keeping invitation %@ because it is the most recent invitation from senderHandle: %@
Deleting invitation %@ as it is no longer the most recent
Error saving managed object context for invitation cleanup. Error: %@
Deleting channel %@ as it is decomissioned and not recent or old
Not deleting channel %@ as it is in our most recent and old decomissioned channels
Error saving managed object context for decomissioned channel cleanup. Error: %@
No decomissioned channel to clean up
Channel cleanup is disabled.
Delivering %@ to %@
SKAStatusEncryptionManager
SKAStatusEncryptionManaging
NSObject
SKAStatusUnencryptedEnvelope
SKAInvitationManager
SKAInvitationManaging
KeyPathConstants
Predicates
SortDescriptors
SharedChannelCreateRequest
NSCopying
SKAStatusPublishingServiceClientConnection
SKAStatusPublishingManager
SKAStatusPublishingManaging
SKADatabaseChannel
CurrentOutgoingRatchet
SKAMessagingProvider
IDSServiceDelegate
SKAMessagingProviding
SKAStatusPublishingServiceClient
SKStatusPublishingDaemonProtocol
SKAStatusPublishingServiceClientConnectionLifecycleDelegate
SKAStatusSubscriptionServiceClient
SKStatusSubscriptionDaemonProtocol
SKAClientConnectionRepresentable
SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate
SKAStatusReceivingManager
SKAStatusReceivingManaging
CoreData
SKAChannelManager
SKAPushManagingDelegate
SKAChannelManaging
SharedChannelPublishResponse
SKADatabaseReceivedInvitation
SKHandle
IncomingRatchet
SKInvitationPayload
SKADatabaseTransientSubscriptionHistory
StatusKitAgent
SKAAccountProvider
SKAAccountProviding
ChannelIdentity
SKAPushManager
APSConnectionDelegate
SKASystemMonitorListener
SKAPushManaging
SKADatabaseStatus
SharedChannelCreateResponse
SKAStatusSubscriptionManager
SKAStatusSubscriptionManaging
SKATransientSubscriptionAssertion
AuthCredential
SharedChannelPublishRequest
ChannelPublishPayload
SKAStatusServer
NSXPCListenerDelegate
SKADatabaseProvidingDelegate
SKAMessagingProvidingDelegate
SKAChannelManagingDelegate
SKAStatusReceivingManagingDelegate
SKADatabaseManagingDelegate
SKAInvitationManagingDelegate
SKAStatusPublishingServiceClientDelegate
SKAStatusSubscriptionServiceClientDelegate
SKADatabaseRemovedUser
SKADatabaseProvider
SKADatabaseProviding
SKAGeneratedEncryptionKey
Ratchets
SKAStatusSubscriptionServiceClientConnection
SKADecryptedStatusPayload
SKADatabaseInvitedUser
SKADatabaseManager
SKADatabaseManaging
SKADatabaseSubscriptionAssertion
SKADatabasePendingPublishRequest
SKASystemMonitor
Channel
CoreDataProperties
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
init
setObject:forKeyedSubscript:
timeIntervalSince1970
numberWithDouble:
payloadData
_encryptPayload:channel:
encryptedMessage
base64EncodedStringWithOptions:
index
numberWithUnsignedShort:
signature
_serializeDictionaryAsBinaryPlist:
currentOutgoingRatchet
logger
statusType
rollEncryptionKeyForPersonalChannelWithStatusTypeIdentifier:error:
newBackgroundContext
existingPersonalChannelForStatusTypeIdentifier:databaseContext:
sealStatus:authenticating:error:
isPersonal
generatedEncryptionKeysForPersonalChannel:databaseContext:
count
countByEnumeratingWithState:objects:count:
incomingRatchet
_decryptPayloadData:withIncomingRatchet:withRatchetIndex:signatureData:
initWithData:
initWithStatusPayload:invitation:
receivedInvitationsForChannel:databaseContext:
firstObject
unsealStatusWithIndex:encryptedMessage:authenticating:signature:error:
_deserializeBinaryPlistDictionaryData:
initWithEnvelopeDictionary:
ska_dataFrombase64EncodedStringForKey:
ska_numberForKey:
integerValue
_decryptPayload:withRatchetIndex:signatureData:channel:
_mostRecentIncomingRatchetForChannel:
signingKeyIdentifier
ska_hexString
length
substringToIndex:
dataWithPropertyList:format:options:error:
propertyListWithData:options:format:error:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
encodeStatusPayload:statusUniqueIdentifier:dateCreated:currentServerTime:channel:
extractEnvelopeFromStatusEnvelopeData:
decryptStatusPayloadFromStatusEnvelopeData:channel:
encryptionValidationTokenForChannel:
initWithDatabaseManager:invitationManager:
databaseManager
invitationManager
.cxx_destruct
_databaseManager
_invitationManager
T@"<SKADatabaseManaging>",R,N,V_databaseManager
T@"<SKAInvitationManaging>",R,N,V_invitationManager
ska_stringForKey:
ska_dateFromUnixTimestampForKey:
statusUniqueIdentifier
datePublished
dateCreated
envelopeDictionary
setEnvelopeDictionary:
_envelopeDictionary
T@"NSDictionary",&,N,V_envelopeDictionary
T@"NSString",R,N
T@"NSDate",R,N
_validateInvitedHandles:
_invalidInvitedHandlesError
resolveSenderHandleWithPreferredSenderHandle:
_invalidSenderHandleError
_noPersonalChannelErrorForStatusTypeIdentifier:
_addInvitedHandles:senderHandle:toDatabaseForPersonalChannel:withInvitationPayload:databaseContext:
_ratchetEncryptionKeyForwardOrKeyRollForPersonalChannel:databaseContext:invitationWasSentViaKeyRoll:error:
currentSubscriptionKeys
_sendInvitationMessageForChannel:toInvitedUsers:subscriptionKeys:error:
_findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
deleteAllInvitedUsersForPersonalChannel:databaseContext:
_rollEncryptionKeyForChannel:databaseContext:error:
_keyRollFailedErrorWithUnderlyingError:
_unableToFindAnyExistingInvitationToDeleteError
deleteInvitedUserForHandle:personalChannel:databaseContext:
createRemovedUserWithHandle:dateRemoved:statusTypeIdentifier:databaseContext:
invitationManager:didRevokeInvitationOnChannel:
_unableToFindExistingInvitationForHandlesError:
copyInvitedUsersFromChannel:toChannel:databaseContext:
decomissionAllPersonalChannelsWithStatusTypeIdentifier:databaseContext:
_createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
serializedData
createGeneratedEncryptionKeyWithOriginalOutgoingRatchetState:personalChannel:databaseContext:
existingInvitedUsersForPersonalChannel:databaseContext:
chainKey
signingKey
initWithIndex:chainKey:signingKey:error:
invitedSKHandle
senderSKHandle
invitationPayload
handleString
identifier
date
copy
sendMessage:toHandle:fromHandle:error:
_validateInvitedHandle:
addObject:
array
isEqualToString:
existingChannelForSubscriptionIdentifier:databaseContext:
createChannelForStatusTypeIdentifier:channelIdentifier:databaseContext:
createReceivedInvitationForChannel:senderHandle:invitedHandle:invitationIdentifier:dateInvitationCreated:incomingRatchetState:invitationPayload:databaseContext:
invitationManager:didReceiveInvitation:forChannel:
allExistingChannelsForHandle:statusTypeIdentifier:databaseContext:
cleanupOldReceivedInvitationsForChannelIdentifier:excludingInvitation:databaseContext:
cleanupOldChannelsForHandle:statusTypeIdentifier:databaseContext:
messagingProvider
isHandleAvailableToMessageFrom:
_isHandleInviteable:completion:
isHandleMessageable:completion:
existingRemovedUserWithHandle:statusTypeIdentifier:withDatabaseContext:
initWithIsInvitable:wasRemoved:
isHandleInviteable:fromHandle:completion:
ratchetForward
updatePersonalChannel:withCurrentOutgoingRatchetState:databaseContext:
_updateOrCreateInvitedUserWithHandle:senderHandle:onChannel:withInvitationPayload:databaseContext:
addObjectsFromArray:
deleteRemovedUserWithHandle:statusTypeIdentifier:databaseContext:
existingInvitedUsersForInvitedHandle:onChannel:databaseContext:
isNormalizedEqualToHandle:
updateInvitationPayload:onExistingInvitedUser:channel:databaseContext:
createInvitedUserWithHandle:senderHandle:invitationPayload:channel:databaseContext:
_shouldReauthForError:
accountProvider
channelManager
createPersonalChannelForStatusTypeIdentifier:channelIdentifier:channelToken:databaseContext:
createChannelWithCompletion:
refreshCredentialForPrimaryAccountWithCompletion:
domain
code
stringWithFormat:
dictionaryWithObjects:forKeys:count:
errorWithDomain:code:userInfo:
componentsJoinedByString:
sendInvitationForPersonalChannelWithStatusTypeIdentifier:toHandles:fromSenderHandle:withInvitationPayload:completion:
revokeInvitationFromPersonalChannelWithStatusTypeIdentifier:forHandles:completion:
revokeAllInvitationsFromPersonalChannelWithStatusTypeIdentifier:completion:
handleIncomingInvitationMessage:fromHandle:toHandle:messageGuid:
rollPersonalChannelWithStatusTypeIdentifier:completion:
fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:
delegate
setDelegate:
T@"<SKAInvitationManagingDelegate>",W,N
initWithMessagingProvider:databaseManager:accountProvider:channelManager:
setDatabaseManager:
setMessagingProvider:
setChannelManager:
setAccountProvider:
backgroundCleanupQueue
setBackgroundCleanupQueue:
_delegate
_messagingProvider
_channelManager
_accountProvider
_backgroundCleanupQueue
T@"<SKADatabaseManaging>",&,N,V_databaseManager
T@"<SKAMessagingProviding>",&,N,V_messagingProvider
T@"<SKAChannelManaging>",&,N,V_channelManager
T@"<SKAAccountProviding>",&,N,V_accountProvider
T@"NSObject<OS_dispatch_queue>",&,N,V_backgroundCleanupQueue
T@"<SKAInvitationManagingDelegate>",W,N,V_delegate
lastSubscriptionDateKeyPath
channelIdentifierKeyPath
predicateWithFormat:
predicateForLastSubscriptionDate:
predicateForChannelIdentifier:
sortDescriptorWithKey:ascending:
sortDescriptorForLastSubscriptionDateAscending:
dateRemovedKeyPath
handleKeyPath
statusTypeIdentifierKeyPath
normalizedHandleString
predicateForHandleString:
predicateForHandle:
predicateForStatusTypeIdentifier:
dictionaryRepresentation
dictionary
setObject:forKey:
setChannelTopic:
setAuthCredential:
allocWithZone:
copyWithZone:
mergeFrom:
hasChannelTopic
hasAuthCredential
channelOwnershipType
setChannelOwnershipType:
setHasChannelOwnershipType:
hasChannelOwnershipType
channelOwnershipTypeAsString:
StringAsChannelOwnershipType:
readFrom:
writeTo:
copyTo:
channelTopic
authCredential
_authCredential
_channelOwnershipType
_channelTopic
_has
TB,R,N
T@"NSString",&,N,V_channelTopic
T@"AuthCredential",&,N,V_authCredential
TB,N
Ti,N,V_channelOwnershipType
identifierKeyPath
personalKeyPath
decomissionedKeyPath
statusTypeKeyPath
encryptionKeysKeyPath
dateChannelCreatedKeyPath
numberWithBool:
predicateForPersonal:
predicateForDecomissioned:
predicateForCreationDateNotNil
sortDescriptorForStatusTypeIdentifierOrderedAscending:
sortDescriptorForPersonalOrderedAscending:
sortDescriptorForChannelIdentifierOrderedAscending:
sortDescriptorForCreationDateAscending:
daemonXPCInterface
setExportedInterface:
setExportedObject:
daemonDelegateXPCInterface
setRemoteObjectInterface:
_setQueue:
processIdentifier
connectionLifecycleDelegate
publishingServiceClientConnectionWasInterrupted:
setInterruptionHandler:
publishingServiceClientConnectionWasInvalidated:
setInvalidationHandler:
resume
xpcConnection
remoteObjectProxyWithErrorHandler:
synchronousRemoteObjectProxyWithErrorHandler:
invalidate
dealloc
sk_stringArrayValueForEntitlement:
sk_booleanValueForEntitlement:
_connection:isEntitledForPublishingWithStatusTypeIdentifier:
containsObject:
clientIsEntitledForAtLeastOnePublishingServiceType:
initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:
asynchronousRemoteDaemonDelegateWithErrorHandler:
synchronousRemoteDaemonDelegateWithErrorHandler:
clientIsEntitledForPublishingWithStatusTypeIdentifier:
setXpcConnection:
setConnectionLifecycleDelegate:
_xpcConnection
_connectionLifecycleDelegate
T@"NSXPCConnection",&,N,V_xpcConnection
T@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
Ti,R
clientIsRateLimited
ensurePendingPublishRequestExistsWithPublishRequest:forStatusTypeIdentifier:databaseContext:
_rateLimitDelayTime
publishPendingRequestsWithDelay:
_errorForRateLimit
_publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:retryCount:completion:
_removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:databaseContext:
internalWorkQueue
_shouldClientRateLimit
setClientIsRateLimited:
_shouldAllowPublishForPublishRequest:onChannel:error:
_markPublishAttempt
statusPayload
serverTime
encryptionManager
channelToken
isScheduledRequest
isSecondaryDeviceRepublish
userInfo
objectForKey:
doubleValue
_shouldAbandonRequestForError:
_removePendingPublishRequestWithUniqueIdentifier:databaseContext:
_shouldRollChannelForError:
_shouldRetryWithDelayForError:
publishData:onChannel:withChannelToken:publishInitiateTime:isPendingPublish:isScheduledPublish:retryCount:completion:
findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
pendingRequestScheduled
existingPendingPublishRequestsWithDatabaseContext:
setPendingRequestScheduled:
timeIntervalSinceDate:
retryCount
_maxRetryCount
initWithStatusPayload:
setDateCreated:
setStatusUniqueIdentifier:
statusTypeIdentifier
incrementPendingPublishRequestRetryCountWithUniqueIdentifier:databaseContext:
_pendingDelayTime
existingStatusForChannel:databaseContext:
uniqueIdentifier
_errorForDuplicateStatusPublishRequestWithIdentifier:
compare:
_errorForStatusPublishRequestWithIdentifier:requestedStatusCreationDate:isOlderThanExistingStatus:existingStatusCreationDate:
_maxRapidPublishes
intValue
dateByAddingTimeInterval:
_rapidPublishesTimescale
numberWithInt:
existingPendingPublishRequestsForStatusTypeIdentifier:withDatabaseContext:
existingPendingPublishRequestForUniqueIdentifier:withDatabaseContext:
createPendingPublishRequestWithUniqueIdentifier:dateCreated:payloadData:statusTypeIdentifier:databaseContext:
createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
deletePendingPublishRequestWithWithUniqueIdentifier:databaseContext:
sharedInstanceForBagType:
publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:completion:
removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:
publishPendingRequestForReason:
initWithDatabaseManager:channelManager:accountProvider:encryptionManager:invitationManager:
setEncryptionManager:
setInvitationManager:
setInternalWorkQueue:
_pendingRequestScheduled
_clientIsRateLimited
_encryptionManager
_internalWorkQueue
T@"<SKAStatusEncryptionManaging>",&,N,V_encryptionManager
T@"<SKAInvitationManaging>",&,N,V_invitationManager
T@"NSObject<OS_dispatch_queue>",&,N,V_internalWorkQueue
TB,V_pendingRequestScheduled
TB,V_clientIsRateLimited
initWithChannelToken:identifier:personal:decomissioned:currentOutgoingRatchetState:dateCreated:statusType:invitedUsers:
isDecomissioned
currentOutgoingRatchetState
dateChannelCreated
setDateChannelCreated:
invitedUsers
_personal
_decomissioned
_channelToken
_identifier
_currentOutgoingRatchetState
_dateChannelCreated
_statusType
_invitedUsers
T@"NSData",R,N,V_channelToken
T@"NSString",R,C,N,V_identifier
personal
TB,R,N,GisPersonal,V_personal
decomissioned
TB,R,N,GisDecomissioned,V_decomissioned
T@"NSData",R,N,V_currentOutgoingRatchetState
T@"NSData",&,N,V_dateChannelCreated
T@"NSString",R,C,N,V_statusType
T@"NSArray",R,C,N,V_invitedUsers
initWithData:error:
T@"MPStatusKitOutgoingRatchet",R,N
_keysharingIsDisabledByServer
initWithService:
addDelegate:queue:
arrayWithObjects:count:
sendMessage:toHandles:fromHandle:error:
idsDestination
_noValidIDSDetintationError
sendMessage:toDestinations:priority:options:identifier:error:
serviceIdentifier
sharedInstance
refreshIDStatusForDestination:service:listenerID:queue:completionBlock:
initWithUnprefixedURI:
service
URIs
isEqualToURI:
originalGUID
toID
service:didReceiveIncomingMessage:fromID:toID:messageGuid:
networkBecameReachable
unprefixedURI
initWithString:
boolValue
service:account:incomingOpportunisticData:withIdentifier:fromID:context:
service:didSendOpportunisticDataWithIdentifier:toIDs:
service:account:incomingMessage:fromID:context:
service:account:incomingData:fromID:context:
service:account:incomingUnhandledProtobuf:fromID:context:
service:account:incomingResourceAtURL:fromID:context:
service:account:incomingResourceAtURL:metadata:fromID:context:
service:account:incomingPendingMessageOfType:fromID:context:
service:activeAccountsChanged:
service:devicesChanged:
service:nearbyDevicesChanged:
service:connectedDevicesChanged:
service:linkedDevicesChanged:
service:account:identifier:didSendWithSuccess:error:
service:account:identifier:didSendWithSuccess:error:context:
service:account:identifier:sentBytes:totalBytes:
service:account:identifier:hasBeenDeliveredWithContext:
service:account:identifier:fromID:hasBeenDeliveredWithContext:
service:account:inviteReceivedForSession:fromID:
service:account:inviteReceivedForSession:fromID:withOptions:
service:account:inviteReceivedForSession:fromID:withContext:
service:account:receivedGroupSessionParticipantUpdate:
service:account:receivedGroupSessionParticipantDataUpdate:
serviceSpaceDidBecomeAvailable:
serviceAllowedTrafficClassifiersDidReset:
service:didSwitchActivePairedDevice:acknowledgementBlock:
T@"<SKAMessagingProvidingDelegate>",W,N
initWithDelegate:serviceIdentifier:queue:
service:didHintCheckingTransportLogWithReason:
setService:
setServiceIdentifier:
_service
_serviceIdentifier
T@"IDSService",&,N,V_service
T@"NSString",&,N,V_serviceIdentifier
T@"<SKAMessagingProvidingDelegate>",W,N,V_delegate
publishingServiceClientWasInvalidated:
clientConnection
_missingEntitlmentErrorForStatusTypeIdentifier:
_accountNotCapableError
UUID
UUIDString
_dateCreatedDriftError
_delayForStatusPublishRequest:
publishingManager
accountIsStatusKitCapableWithCompletion:
_unableToResolveSenderHandleError
setAccountIsStatusKitCapable:
setAccountCheckCompleted:
queue
accountIsStatusKitCapable
deviceToDeviceEncryptedDatabaseCapableWithCompletion:
_serverBagNumberForKey:
_serverBagTimeIntervalForKey:withDefaultValue:
_scheduledPublishMaxDelayTime
_unscheduledPublishMaxDelayTime
_secondaryDeviceRepublishMaxDelayTime
_secondaryDeviceRepublishMinDelayTime
_randomSecondaryDeviceRepublishDelay
_randomScheduledPublishDelay
_randomUnscheduledPublishDelay
_noUsersToShareWithError
publishStatusRequest:statusTypeIdentifier:completion:
invitedHandlesForStatusTypeIdentifier:completion:
isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:
isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:
removeInvitedHandles:statusTypeIdentifier:completion:
removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:
registerForDelegateCallbacksWithStatusTypeIdentifier:completion:
initWithXPCConnection:queue:delegate:databaseManager:invitationManager:publishingManager:channelManager:
statusTypeIdenfifier
setClientConnection:
databaseProvider
setDatabaseProvider:
setPublishingManager:
accountCheckCompleted
setQueue:
_accountIsStatusKitCapable
_accountCheckCompleted
_statusTypeIdenfifier
_clientConnection
_databaseProvider
_publishingManager
_queue
T@"SKAStatusPublishingServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusPublishingServiceClientDelegate>",W,N,V_delegate
T@"<SKADatabaseProviding>",&,N,V_databaseProvider
T@"SKAInvitationManager",&,N,V_invitationManager
T@"<SKAStatusPublishingManaging>",&,N,V_publishingManager
TB,N,V_accountIsStatusKitCapable
TB,N,V_accountCheckCompleted
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
T@"NSString",R,C,N,V_statusTypeIdenfifier
channelMatchesClientStatusTypeIdentifier:
_subscriptionMetadataForChannel:
subscriptionStateChangedForSubscriptions:completion:
subscriptionReceivedStatusUpdate:completion:
subscriptionInvitationReceived:completion:
_currentStatusForChannel:
_handlesAssociatedWithChannel:
initWithSubscriptionIdentifier:statusTypeIdentifier:isPersonalStatusSubscription:currentStatus:ownerHandles:
isExpired
dateReceived
rawData
invitation
skInvitationPayload
initWithStatusPayload:statusUniqueIdentifier:datePublished:dateCreated:dateReceived:invitationPayload:
releaseAllTransientSubscriptionAssertionsAssociatedWithClient:completion:
subscriptionServiceClientWasInvalidated:
clientIsEntitledForSubscriptionWithStatusTypeIdentifier:
existingChannelForHandle:statusTypeIdentifier:databaseContext:
allExistingChannelsForStatusTypeIdentifier:includingPersonalChannel:databaseContext:
subscriptionManager
allSubscriptionIdentifiersWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionIdentifiersWithActiveSubscriptionsForStatusTypeIdentifier:completion:
existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
channelIdentifier
_validateChannelIsKnownForSubscriptionIdentifier:statusTypeIdentifier:databaseContext:
_subscriptionIdentifierNotFoundError:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
initWithSubscriptionValidationToken:encryptionValidationToken:
subscriptionValidationToken
validatePersonalChannel:matchesSubscriptionValidationToken:fromSender:
encryptionValidationToken
validatePersonalChannel:matchesEncryptionValidationToken:fromSender:
hasPrefix:
_genericMissingSubscriptionEntitlmentError
subscriptionMetadataForHandle:statusTypeIdentifier:completion:
allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:
allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:
subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:
subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:
subscriptionServiceClientConnectionWasInvalidated:
subscriptionServiceClientConnectionWasInterrupted:
initWithXPCConnection:queue:delegate:databaseManager:subscriptionManager:encryptionManager:
handleRemoteDatabaseChangeForChannels:
handleReceivedStatusUpdate:onChannel:
handleReceivedInvitationForChannel:
setSubscriptionManager:
_subscriptionManager
T@"SKAStatusSubscriptionServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusSubscriptionServiceClientDelegate>",W,N,V_delegate
T@"<SKAStatusSubscriptionManaging>",&,N,V_subscriptionManager
existingStatusForUniqueIdentifier:databaseContext:
createStatusWithUniqueIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:channelIdentifier:databaseContext:
statusReceivingManager:didReceiveStatusUpdate:onChannel:
cleanupOldStatusUpdatesForChannelIdentifier:excludingStatusUniqueIdentifier:databaseContext:
handleIncomingStatusData:onChannelIdentifier:dateReceived:dateExpired:serverTime:
initWithDatabaseManager:encryptionManager:delegate:
T@"<SKAStatusReceivingManagingDelegate>",W,N,V_delegate
dateCreatedKeyPath
statusUniqueIdentifierKeyPath
predicateForStatusUniqueIdentifier:
sortDescriptorForDateCreatedAscending:
initWithCoreDataInvitedUser:
initWithCoreDataChannels:
dateExpired
initWithChannelIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:uniqueIdentifier:
initWithCoreDataStatus:
invitedHandle
senderHandle
dateInvitationPayloadCreated
initWithInvitedHandle:senderHande:invitationPayloadData:dateInvitationPayloadCreated:
invitationIdentifier
dateInvitationCreated
incomingRatchetState
initWithInvitationIdentifier:senderHandle:invitedHandle:statusTypeIdentifier:dateInvitationCreated:incomingRatchetState:invitationPayload:
initWithCoreDataReceivedInvitation:
initWithStatusTypeIdentifier:dateCreated:payloadData:statusUniqueIdentifier:retryCount:
initWithCoreDataPendingPublishRequest:
originalOutgoingRatchetState
dateGenerated
initWithOriginalOutgoingRatchetState:dateGenerated:
initWithCoreDataGeneratedEncryptionKey:
applicationIdentifier
initWithChannelIdentifier:statusTypeIdentifier:applicationIdentifier:
initWithCoreDataSubscriptionAssertion:
lastSubscriptionDate
initWithChannelIdentifier:lastSubscriptionDate:
initWithCoreDataTransientSubscriptionHistory:
removedHandle
dateRemoved
initWithHandle:statusTypeIdentifier:dateRemoved:
initWithCoreDataRemovedUser:
_getJWTToken
_jwtTokenNotFoundError
setSimpleJwt:
data
pushManager
status
hasRetryIntervalSeconds
retryIntervalSeconds
numberWithUnsignedInt:
channelIdentity
channelId
createChannelWithProtoData:completion:
setChannelToken:
initWithBase64EncodedString:options:
setChannelId:
setPublishInitiateTimestampMillis:
setPendingPublishHint:
setScheduledPublishHint:
setRetryCount:
setChannelIdentity:
setPublishPayloadExpiryTtlMillis:
_createPayloadDataFromData:
setPublishPayload:
setPushPriority:
setChannelPublishPayload:
publishStatus:completion:
subscribedChannelsWithCompletion:
subscribeToChannels:
unsubscribeFromChannels:
dataWithJSONObject:options:error:
jwtTokenForPrimaryAccountWithError:
channelManager:didReceiveData:onChannel:dateReceived:dateExpired:
channelManager:failedToSubscribeToChannel:withError:
pushManager:didReceiveData:onChannel:dateReceived:dateExpired:
pushManager:failedToSubscribeToChannel:withError:
activeChannelSubscriptionsWithCompletion:
initWithPushManager:accountProvider:delegate:
setPushManager:
_pushManager
T@"<SKAPushManaging>",&,N,V_pushManager
T@"<SKAChannelManagingDelegate>",W,N,V_delegate
setStatus:
setHasStatus:
hasStatus
statusAsString:
StringAsStatus:
setRetryIntervalSeconds:
setHasRetryIntervalSeconds:
_retryIntervalSeconds
_status
Ti,N,V_status
TI,N,V_retryIntervalSeconds
_senderHandle
_invitedHandle
_statusTypeIdentifier
_invitationIdentifier
_dateInvitationCreated
_incomingRatchetState
_invitationPayload
T@"NSString",R,N,V_senderHandle
T@"NSString",R,N,V_invitedHandle
T@"NSString",R,N,V_statusTypeIdentifier
T@"NSString",R,N,V_invitationIdentifier
T@"NSDate",R,N,V_dateInvitationCreated
T@"NSData",R,N,V_incomingRatchetState
T@"NSData",R,N,V_invitationPayload
T@"SKHandle",R,N
T@"MPStatusKitIncomingRatchet",R,N
initWithData:dateCreated:
T@"SKInvitationPayload",R,N
_channelIdentifier
_lastSubscriptionDate
T@"NSString",R,N,V_channelIdentifier
T@"NSDate",R,N,V_lastSubscriptionDate
objectForKeyedSubscript:
dateWithTimeIntervalSince1970:
ska_dictionaryForKey:
_primarySystemiCloudAccountWithError:
aida_tokenWithExpiryCheckForService:
ska_sha256Hash
_shouldAttemptReauth
_markReauthAttempt
setAuthenticationType:
setIsUsernameEditable:
setServiceType:
aida_alternateDSID
setAltDSID:
authenticateWithContext:completion:
aida_accountForPrimaryiCloudAccount
_maxReauthCount
_authResetTime
tokenFetchQueue
setTokenFetchQueue:
_tokenFetchQueue
T@"NSObject<OS_dispatch_queue>",&,N,V_tokenFetchQueue
hasChannelId
hasChannelToken
_channelId
T@"NSData",&,N,V_channelId
T@"NSData",&,N,V_channelToken
addListener:
_initializeAPSConnection
_pushEnvironment
initWithEnvironmentName:namedDelegatePort:queue:
initWithAPSConnection:mobileNetworkManager:
isUnderFirstDataProtectionLock
_setNonWakingTopics:
_sharedChannelsIsDisabledByServer
initWithProtoData:messageType:
protoResponse
setCompletionBlock:
setTimeout:
messageDelivery
sendMessage:
nonWakingTopics
enabledTopics
setEnabledTopics:ignoredTopics:opportunisticTopics:nonWakingTopics:
initWithChannelID:
connection
subscribeToChannels:forTopic:
unsubscribeFromChannels:forTopic:
channelID
getRegisteredChannelsForTopic:completion:
isConnected
dateWithTimeIntervalSinceReferenceDate:
expirationDate
timestamp
failureReason
connection:didReceivePublicToken:
connection:didReceiveToken:forTopic:identifier:
connection:didReceiveIncomingMessage:
connection:didReceiveMessageForTopic:userInfo:
connection:didSendOutgoingMessage:
connection:didFailToSendOutgoingMessage:error:
connection:didChangeConnectedStatus:
connectionDidReconnect:
connection:channelSubscriptionsFailedWithFailures:
systemDidLeaveFirstDataProtectionLock
switchFilterToNonwaking
switchFilterToEnabled
T@"<SKAPushManagingDelegate>",W,N
initWithQueue:systemMonitor:
systemMonitor
setSystemMonitor:
setConnection:
setMessageDelivery:
_systemMonitor
_connection
_messageDelivery
T@"SKASystemMonitor",&,N,V_systemMonitor
T@"APSConnection",&,N,V_connection
T@"FTMessageDelivery",&,N,V_messageDelivery
T@"<SKAPushManagingDelegate>",W,N,V_delegate
_dateCreated
_datePublished
_dateReceived
_dateExpired
_rawData
_uniqueIdentifier
T@"NSString",R,C,N,V_channelIdentifier
T@"NSDate",R,C,N,V_dateCreated
T@"NSDate",R,C,N,V_datePublished
T@"NSDate",R,C,N,V_dateReceived
T@"NSDate",R,C,N,V_dateExpired
T@"NSData",R,N,V_rawData
T@"NSString",R,C,N,V_uniqueIdentifier
hasChannelIdentity
_channelIdentity
T@"ChannelIdentity",&,N,V_channelIdentity
weakToStrongObjectsMapTable
_addTransientSubscriptionAssertionForClient:subscriptionIdentifier:
_markCacheSubscriptionDateForChannelIdentifier:
updateRegisteredSubscriptionsForActiveAssertionsWithCompletion:
_removeTransientSubscriptionAssertionForClient:subscriptionIdentifier:
activeTransientSubscriptionsByClient
removeObjectForKey:
existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
createSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:statusTypeIdentifier:databaseContext:
deleteSubscriptionAssertionWithSubscriptionIdentifier:applicationIdentifier:databaseContext:
_fetchAllClientActiveSubscriptionAssertions
_activeTransientSubscriptionsForClient:
subscriptionIdentifier
initWithSubscriptionIdentifier:
createOrUpdateTransientSubscriptionHistoryForChannelIdentifier:lastSubscriptionDate:databaseContext:
addIndex:
enumerateObjectsUsingBlock:
removeObjectsAtIndexes:
_fetchAllActiveSubscriptionAssertionsWithCache
_sortAndDedupeSubscriptionIdentifiers:
_enforceSubscriptionsHardCapOnSubscriptionIdentifiers:
differenceFromArray:
removals
object
insertions
_activeTransientAssertionsExist
initWithArray:
sortDescriptorWithKey:ascending:selector:
sortedArrayUsingDescriptors:
_hardMaxSubscriptionCount
subarrayWithRange:
objectEnumerator
allPersistentSubscriptionAssertionChannelIdentifiersWithDatabaseContext:
_allPersonalChannelIdentifiersRequiringSelfSubscriptionWithDatabaseContext:
_maxSubscriptionCacheCount
_recentlyReleasedTransientSubscriptionAssertionIdentifiersExcludingSubscriptionIdentifiers:count:databaseContext:
_subscriptionTTL
existingRecentTransientSubscriptionHistoriesWithLimit:databaseContext:
allObjects
_statusTypeIdentifiersRequiringSelfSubscription
initWithDatabaseManager:channelManager:pushManager:
setActiveTransientSubscriptionsByClient:
_activeTransientSubscriptionsByClient
T@"NSMapTable",&,N,V_activeTransientSubscriptionsByClient
isEqualToTransientSubscription:
osActivity
_subscriptionIdentifier
_osActivity
T@"NSObject<OS_os_activity>",R,N,V_osActivity
T@"NSString",R,C,N,V_subscriptionIdentifier
clearOneofValuesForAuthCredentialOneof
hasSimpleJwt
authCredentialOneof
setAuthCredentialOneof:
setHasAuthCredentialOneof:
hasAuthCredentialOneof
authCredentialOneofAsString:
StringAsAuthCredentialOneof:
simpleJwt
_authCredentialOneof
_simpleJwt
T@"NSString",&,N,V_simpleJwt
Ti,N,V_authCredentialOneof
hasChannelPublishPayload
channelPublishPayload
_channelPublishPayload
T@"ChannelPublishPayload",&,N,V_channelPublishPayload
numberWithUnsignedLongLong:
setHasPublishInitiateTimestampMillis:
hasPublishInitiateTimestampMillis
hasPublishPayload
setHasPublishPayloadExpiryTtlMillis:
hasPublishPayloadExpiryTtlMillis
pushPriority
setHasPushPriority:
hasPushPriority
pushPriorityAsString:
StringAsPushPriority:
setHasPendingPublishHint:
hasPendingPublishHint
setHasScheduledPublishHint:
hasScheduledPublishHint
setHasRetryCount:
hasRetryCount
publishInitiateTimestampMillis
publishPayload
publishPayloadExpiryTtlMillis
pendingPublishHint
scheduledPublishHint
_publishInitiateTimestampMillis
_publishPayloadExpiryTtlMillis
_publishPayload
_pushPriority
_retryCount
_pendingPublishHint
_scheduledPublishHint
TQ,N,V_publishInitiateTimestampMillis
T@"NSData",&,N,V_publishPayload
TQ,N,V_publishPayloadExpiryTtlMillis
Ti,N,V_pushPriority
TB,N,V_pendingPublishHint
TB,N,V_scheduledPublishHint
TI,N,V_retryCount
initWithDelegate:
initWithDatabaseProvider:delegate:
initWithMachServiceName:
_setupMaintenanceActivity
serviceName
_publishingServiceListener:shouldAcceptNewConnection:
_subscriptionServiceListener:shouldAcceptNewConnection:
clientIsEntitledForAtLeastOneSubscriptionServiceType:
subscriptionServiceConnectedClients
removeObject:
publishingServiceConnectedClients
_kettleFeatureEnabled
donateReceivedStatusToBiomeOnChannel:
_shouldDonateToBiomeForStatusTypeIdentifier:
_senderHandlesForChannel:
userStatusChangeStream
initWithIDSHandles:statusChangeType:
source
sendEvent:
standardUserDefaults
initWithStatusPayload:isScheduledRequest:
cleanupDecommisionedChannelsWithDatabaseContext:
listener:shouldAcceptNewConnection:
databaseDidReceiveRemoteChangesForChannels:
databaseManager:didCreateChannel:
shutdown
logState
publishingServiceListener
setPublishingServiceListener:
publishingServiceConnectionQueue
setPublishingServiceConnectionQueue:
setPublishingServiceConnectedClients:
subscriptionServiceListener
setSubscriptionServiceListener:
subscriptionServiceConnectionQueue
setSubscriptionServiceConnectionQueue:
setSubscriptionServiceConnectedClients:
invitationManagerMessagingQueue
setInvitationManagerMessagingQueue:
invitationMessagingProvider
setInvitationMessagingProvider:
statusReceivingManager
setStatusReceivingManager:
_publishingServiceListener
_publishingServiceConnectionQueue
_publishingServiceConnectedClients
_subscriptionServiceListener
_subscriptionServiceConnectionQueue
_subscriptionServiceConnectedClients
_invitationManagerMessagingQueue
_invitationMessagingProvider
_statusReceivingManager
T@"NSXPCListener",&,N,V_publishingServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_publishingServiceConnectionQueue
T@"NSMutableArray",&,N,V_publishingServiceConnectedClients
T@"NSXPCListener",&,N,V_subscriptionServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_subscriptionServiceConnectionQueue
T@"NSMutableArray",&,N,V_subscriptionServiceConnectedClients
T@"NSObject<OS_dispatch_queue>",&,N,V_invitationManagerMessagingQueue
T@"<SKAMessagingProviding>",&,N,V_invitationMessagingProvider
T@"<SKAStatusReceivingManaging>",&,N,V_statusReceivingManager
handle
_handle
_dateRemoved
T@"NSString",R,N,V_handle
T@"NSDate",R,N,V_dateRemoved
createPersistentContainer
containerName
bundleForClass:
mergedModelFromBundles:
initWithName:managedObjectModel:
localPersistentStoreDescription
cloudPersistentStoreDescription
setPersistentStoreDescriptions:
loadPersistentStoresWithCompletionHandler:
defaultCenter
handlePersistentStoreRemoteChangeNotification:
addObserver:selector:name:object:
createCkContainer
ckContainerIdentifier
initWithContainerIdentifier:environment:
initWithContainerID:
defaultManager
URLForDirectory:inDomain:appropriateForURL:create:error:
URLByAppendingPathComponent:isDirectory:
fileManager
path
fileExistsAtPath:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
databaseDirectoryURL
localDatabaseFileURL
persistentStoreDescriptionWithURL:
setType:
setConfiguration:
setShouldAddStoreAsynchronously:
setOption:forKey:
cloudDatabaseFileURL
initWithContainerIdentifier:
setUseDeviceToDeviceEncryption:
setApsConnectionMachServiceName:
setCloudKitContainerOptions:
processPersistentStoreRemoteChanges
persistentContainer
fetchRequest
appTransactionAuthorName
predicateWithFormat:argumentArray:
setPredicate:
lastProcessedPersistentHistoryToken
fetchHistoryAfterToken:
setFetchRequest:
executeRequest:error:
result
changes
changedObjectID
entity
name
extractModifiedChannelFromPersistentStoreRemoteChangeForChannel:managedObjectContext:
extractModifiedChannelFromPersistentStoreRemoteChangeForReceivedInvitation:managedObjectContext:
lastObject
token
setLastProcessedPersistentHistoryToken:
performBlockAndWait:
changeType
existingManagedObjectWithID:managedObjectContext:
channel
existingObjectWithID:error:
lastProcessedPersistentHistoryTokenFileURL
dataWithContentsOfURL:
unarchivedObjectOfClass:fromData:error:
archivedDataWithRootObject:requiringSecureCoding:error:
writeToURL:atomically:
overrideDeviceEncryptionCheck
ckContainer
supportsDeviceToDeviceEncryption
accountInfoWithCompletionHandler:
databaseHasBeenCreated
historyProcessingQueue
setHistoryProcessingQueue:
setPersistentContainer:
setCkContainer:
_historyProcessingQueue
_persistentContainer
_ckContainer
T@"NSObject<OS_dispatch_queue>",&,N,V_historyProcessingQueue
T@"NSPersistentContainer",&,N,V_persistentContainer
T@"CKContainer",&,N,V_ckContainer
T@"<SKADatabaseProvidingDelegate>",W,N,V_delegate
_originalOutgoingRatchetState
_dateGenerated
T@"NSData",R,N,V_originalOutgoingRatchetState
T@"NSDate",R,N,V_dateGenerated
outgoingRatchet
dateInvitationCreatedKeyPath
senderHandleKeyPath
predicateForSenderHandleString:
predicateForSenderHandle:
sortDescriptorForDateInvitationCreatedOrderedAscending:
sortDescriptorForSenderHandleOrderedAscending:
dateGeneratedKeyPath
ska_appearsToBeEmail
_connection:isEntitledForSubscriptionWithStatusTypeIdentifier:
clientIsEntitledForAtLeastOneSubscriptionServiceType
T@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
applicationIdentifierKeyPath
predicateForApplicationIdentifier:
_statusPayload
_invitation
T@"SKStatusPayload",R,N,V_statusPayload
T@"SKADatabaseReceivedInvitation",R,N,V_invitation
invitationPayloadData
_invitationPayloadData
_dateInvitationPayloadCreated
T@"NSData",R,N,V_invitationPayloadData
T@"NSDate",R,N,V_dateInvitationPayloadCreated
_existingPersonalChannelForStatusTypeIdentifier:databaseContext:
andPredicateWithSubpredicates:
setSortDescriptors:
setFetchLimit:
executeFetchRequest:error:
deleteObject:
_existingChannelsForChannelIdentifier:databaseContext:
_existingChannelsForDatabaseChannel:databaseContext:
_existingReceivedInvitationsForHandle:statusTypeIdentifier:databaseContext:
refreshObject:mergeChanges:
allValues
initWithContext:
setStatusType:
setDecomissioned:
setPersonal:
setIdentifier:
save:
_existingPersonalChannelForDatabaseChannel:databaseContext:
setCurrentOutgoingRatchetState:
_existingPersonalChannelsForStatusTypeIdentifier:databaseContext:
setOriginalOutgoingRatchetState:
setDateGenerated:
addGeneratedEncryptionKeysObject:
generatedEncryptionKeys
_existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
_existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
setChannelIdentifier:
setApplicationIdentifier:
setStatusTypeIdentifier:
_existingTransientSubscriptionHistoryForChannelIdentifier:databaseContext:
setLastSubscriptionDate:
_existingTransientSubscriptionHistoryWithLimit:orderedByLastSubscriptionDateAscending:databaseContext:
setInvitedHandle:
setInvitationPayload:
setDateInvitationPayloadCreated:
setSenderHandle:
addInvitedUsersObject:
_existingInvitedUsersForDatabaseInvitedUser:databaseChannel:databaseContext:
_existingInvitedUsersForInvitedHandle:channel:databaseContext:
predicateForInvitedHandle:
predicateForChannel:
setUniqueIdentifier:
setDatePublished:
setDateReceived:
setRawData:
setDateExpired:
setPayloadData:
_existingPendingPublishRequestForUniqueIdentifier:databaseContext:
_existingPendingPublishRequestsForStatusTypeIdentifier:databaseContext:
_existingPendingPublishRequestsWithDatabaseContext:
setDateRemoved:
setRemovedHandle:
_existingRemovedUsersForHandle:statusTypeIdentifier:databaseContext:
setInvitationIdentifier:
setDateInvitationCreated:
setIncomingRatchetState:
addReceivedInvitationsObject:
receivedInvitations
_existingReceivedInvitationsForChannelIdentifier:sortedByDateReceived:databaseContect:
_existingDecomissionedPersonalChannelsWithDatabaseContext:
deletePersonalChannelForStatusTypeIdentifier:databaseContext:
T@"<SKADatabaseProviding>",R,N,V_databaseProvider
T@"<SKADatabaseManagingDelegate>",R,W,N,V_delegate
datePublishedKeyPath
uniqueIdentifierKeyPath
sortDescriptorForDatePublishedAscending:
valueForEntitlement:
_applicationIdentifier
T@"NSString",R,N,V_applicationIdentifier
bytes
initWithCapacity:
appendFormat:
_payloadData
_statusUniqueIdentifier
T@"NSString",R,C,N,V_statusTypeIdentifier
T@"NSData",R,N,V_payloadData
T@"NSString",R,C,N,V_statusUniqueIdentifier
Tq,R,N,V_retryCount
containsString:
UTF8String
stringWithCapacity:
invitedHandleKeyPath
channelKeyPath
initWithOptions:capacity:
_updateLockState
_listenForKeyBagChangeNotifications
_deviceStillUnderFirstLock
_deliverNotificationSelectorToListeners:
performSelectorOnMainThread:withObject:waitUntilDone:
removeListener:
ivarLock
setIvarLock:
underFirstLock
setUnderFirstLock:
listeners
setListeners:
_underFirstLock
_ivarLock
_listeners
T{os_unfair_lock_s=I},N,V_ivarLock
TB,N,V_underFirstLock
T@"NSHashTable",&,N,V_listeners
fetchRequestWithEntityName:
T@"NSData",&,D,N
T@"NSDate",C,D,N
TB,D,N
T@"NSString",C,D,N
T@"NSSet",&,D,N
T@"Channel",&,D,N
Ti,D,N
@16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@56@0:8@16@24@32@40@48
@24@0:8@16
@32@0:8@16@24
@"NSData"56@0:8@"SKStatusPayload"16@"NSString"24@"NSDate"32@"NSDate"40@"SKADatabaseChannel"48
@"SKAStatusUnencryptedEnvelope"24@0:8@"NSData"16
@"SKADecryptedStatusPayload"32@0:8@"NSData"16@"SKADatabaseChannel"24
@"NSString"24@0:8@"SKADatabaseChannel"16
@44@0:8@16S24@28@36
@44@0:8@16@24S32@36
v16@0:8
@"<SKADatabaseManaging>"
@"<SKAInvitationManaging>"
v24@0:8@16
@"NSDictionary"
v56@0:8@16@24@32@40@?48
v40@0:8@16@24@?32
v32@0:8@16@?24
v48@0:8@16@24@32@40
B32@0:8@16^@24
v48@0:8@16@24@32@?40
v56@0:8@"NSString"16@"NSArray"24@"SKHandle"32@"SKInvitationPayload"40@?<v@?B@"NSError">48
v40@0:8@"NSString"16@"NSArray"24@?<v@?@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSError">24
v48@0:8@"NSDictionary"16@"SKHandle"24@"SKHandle"32@"NSString"40
B32@0:8@"NSString"16^@24
v32@0:8@"NSString"16@?<v@?B>24
v40@0:8@"SKHandle"16@"SKHandle"24@?<v@?B@"NSError">32
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?@"SKHandleInvitability"@"NSError">40
@"SKHandle"24@0:8@"SKHandle"16
@"<SKAInvitationManagingDelegate>"16@0:8
v24@0:8@"<SKAInvitationManagingDelegate>"16
@48@0:8@16@24@32@40
B40@0:8@16@24^@32
B48@0:8@16@24@32^@40
@48@0:8@16@24^B32^@40
@"<SKAInvitationManagingDelegate>"
@"<SKAMessagingProviding>"
@"<SKAChannelManaging>"
@"<SKAAccountProviding>"
@"NSObject<OS_dispatch_queue>"
@20@0:8B16
@24@0:8^{_NSZone=}16
i16@0:8
v20@0:8i16
v20@0:8B16
@20@0:8i16
i24@0:8@16
@"AuthCredential"
@"NSString"
{?="channelOwnershipType"b1}
B32@0:8@16@24
@24@0:8@?16
@"NSXPCConnection"
@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>"
v52@0:8@16@24d32B40@?44
v32@0:8@16@24
v24@0:8q16
v52@0:8@"SKStatusPublishRequest"16@"NSString"24d32B40@?<v@?@"NSString"@"NSError">44
v32@0:8@"NSString"16@"SKStatusPublishRequest"24
v60@0:8@16@24d32B40Q44@?52
v24@0:8d16
v40@0:8@16@24@32
d16@0:8
q16@0:8
@"<SKAStatusEncryptionManaging>"
@72@0:8@16@24B32B36@40@48@56@64
@"NSData"
@"NSArray"
v64@0:8@16@24@32@40@48@56
v56@0:8@16@24@32@40@48
v56@0:8@16@24q32@40@48
v52@0:8@16@24@32B40@44
v60@0:8@16@24@32B40@44@52
v56@0:8@16@24@32q40q48
v64@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"NSString"48@"IDSMessageContext"56
v40@0:8@"IDSService"16@"NSString"24@"NSArray"32
v56@0:8@"IDSService"16@"IDSAccount"24@"NSDictionary"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSProtobuf"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSString"40@"IDSMessageContext"48
v64@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSDictionary"40@"NSString"48@"IDSMessageContext"56
v56@0:8@"IDSService"16@"IDSAccount"24q32@"NSString"40@"IDSMessageContext"48
v32@0:8@"IDSService"16@"NSSet"24
v32@0:8@"IDSService"16@"NSArray"24
v52@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44
v60@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44@"IDSMessageContext"52
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32q40q48
v48@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@40
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@"NSString"40@48
v48@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSDictionary"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSData"48
v40@0:8@"IDSService"16@"IDSAccount"24@"IDSGroupSessionParticipantUpdate"32
v24@0:8@"IDSService"16
v40@0:8@"IDSService"16@"IDSDevice"24@?<v@?>32
B48@0:8@"NSDictionary"16@"SKHandle"24@"SKHandle"32^@40
B48@0:8@"NSDictionary"16@"NSArray"24@"SKHandle"32^@40
v32@0:8@"SKHandle"16@?<v@?B>24
B24@0:8@"SKHandle"16
@"<SKAMessagingProvidingDelegate>"16@0:8
v24@0:8@"<SKAMessagingProvidingDelegate>"16
@40@0:8@16@24@32
v32@0:8@16q24
@"<SKAMessagingProvidingDelegate>"
@"IDSService"
v40@0:8@"SKStatusPublishRequest"16@"NSString"24@?<v@?@"NSString"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSArray"@"NSError">24
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?B@"NSError">40
v56@0:8@"NSArray"16@"SKHandle"24@"SKInvitationPayload"32@"NSString"40@?<v@?@"NSError">48
v40@0:8@"NSArray"16@"NSString"24@?<v@?@"NSError">32
v24@0:8@"SKAStatusPublishingServiceClientConnection"16
@72@0:8@16@24@32@40@48@56@64
v24@0:8@?16
d32@0:8@16d24
d24@0:8@16
@"SKAStatusPublishingServiceClientConnection"
@"<SKAStatusPublishingServiceClientDelegate>"
@"<SKADatabaseProviding>"
@"SKAInvitationManager"
@"<SKAStatusPublishingManaging>"
v36@0:8@16B24@?28
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSArray"@"NSError">28
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSArray"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">24
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError">32
v48@0:8@"NSString"16@"NSString"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKSubscriptionValidationTokens"@"NSError">32
v48@0:8@"SKSubscriptionValidationTokens"16@"SKHandle"24@"NSString"32@?<v@?q@"NSError">40
v24@0:8@"SKAStatusSubscriptionServiceClientConnection"16
@64@0:8@16@24@32@40@48@56
q40@0:8@16@24@32
B40@0:8@16@24@32
@"SKAStatusSubscriptionServiceClientConnection"
@"<SKAStatusSubscriptionServiceClientDelegate>"
@"<SKAStatusSubscriptionManaging>"
v56@0:8@"NSData"16@"NSString"24@"NSDate"32@"NSDate"40@"NSDate"48
@"<SKAStatusReceivingManagingDelegate>"
v56@0:8@"<SKAPushManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAPushManaging>"16@"NSString"24@"NSError"32
v72@0:8@16@24@32@40B48B52Q56@?64
v24@0:8@?<v@?@"NSString"@"NSData"@"NSError">16
v72@0:8@"NSData"16@"NSString"24@"NSData"32@"NSDate"40B48B52Q56@?<v@?@"NSError">64
v24@0:8@?<v@?@"NSArray">16
v24@0:8@"NSArray"16
@"NSDate"16@0:8
@"<SKAPushManaging>"
@"<SKAChannelManagingDelegate>"
v20@0:8I16
I16@0:8
{?="retryIntervalSeconds"b1"status"b1}
@"NSDate"
@24@0:8^@16
@"NSString"24@0:8^@16
v24@0:8@?<v@?B@"NSError">16
v28@0:8@16B24
v32@0:8@"APSConnection"16@"NSData"24
v48@0:8@"APSConnection"16@"NSData"24@"NSString"32@"NSString"40
v32@0:8@"APSConnection"16@"APSIncomingMessage"24
v40@0:8@"APSConnection"16@"NSString"24@"NSDictionary"32
v32@0:8@"APSConnection"16@"APSOutgoingMessage"24
v40@0:8@"APSConnection"16@"APSOutgoingMessage"24@"NSError"32
v28@0:8@"APSConnection"16B24
v24@0:8@"APSConnection"16
v32@0:8@"APSConnection"16@"NSArray"24
v32@0:8@"NSData"16@?<v@?@"NSData"@"NSError">24
@"<SKAPushManagingDelegate>"16@0:8
v24@0:8@"<SKAPushManagingDelegate>"16
@"<SKAPushManagingDelegate>"
@"SKASystemMonitor"
@"APSConnection"
@"FTMessageDelivery"
@"ChannelIdentity"
v48@0:8@"NSString"16@"NSString"24@"<SKAClientConnectionRepresentable>"32@?<v@?@"NSError">40
v32@0:8@"<SKAClientConnectionRepresentable>"16@?<v@?@"NSError">24
v24@0:8@?<v@?@"NSError">16
v32@0:8@"NSString"16@?<v@?@"NSArray">24
@40@0:8@16q24@32
@"NSMapTable"
@"NSObject<OS_os_activity>"
{?="authCredentialOneof"b1}
@"ChannelPublishPayload"
v24@0:8Q16
{?="publishInitiateTimestampMillis"b1"publishPayloadExpiryTtlMillis"b1"pushPriority"b1"retryCount"b1"pendingPublishHint"b1"scheduledPublishHint"b1}
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
v56@0:8@"NSString"16@"NSDictionary"24@"NSString"32@"NSString"40@"NSString"48
v56@0:8@"<SKAChannelManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAChannelManaging>"16@"NSString"24@"NSError"32
v40@0:8@"<SKAStatusReceivingManaging>"16@"SKADatabaseStatus"24@"SKADatabaseChannel"32
v32@0:8@"<SKADatabaseManaging>"16@"SKADatabaseChannel"24
v40@0:8@"<SKAInvitationManaging>"16@"SKADatabaseReceivedInvitation"24@"SKADatabaseChannel"32
v32@0:8@"<SKAInvitationManaging>"16@"SKADatabaseChannel"24
v24@0:8@"SKAStatusPublishingServiceClient"16
v24@0:8@"SKAStatusSubscriptionServiceClient"16
@"NSXPCListener"
@"NSMutableArray"
@"<SKAStatusReceivingManaging>"
@"NSManagedObjectContext"16@0:8
v24@0:8@?<v@?B>16
@"<SKADatabaseProvidingDelegate>"
@"NSPersistentContainer"
@"CKContainer"
@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>"
@"SKStatusPayload"
@"SKADatabaseReceivedInvitation"
@36@0:8@16B24@28
@32@0:8q16@24
@80@0:8@16@24@32@40@48@56@64@72
@"SKADatabaseChannel"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"36@0:8@"NSString"16B24@"NSManagedObjectContext"28
@"SKADatabaseChannel"48@0:8@"NSString"16@"NSString"24@"NSData"32@"NSManagedObjectContext"40
B32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseChannel"40@0:8@"SKADatabaseChannel"16@"NSData"24@"NSManagedObjectContext"32
@"SKAGeneratedEncryptionKey"40@0:8@"NSData"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"NSArray"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"NSArray"24@0:8@"NSManagedObjectContext"16
@"NSArray"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"48@0:8@"NSString"16@"NSString"24@"NSString"32@"NSManagedObjectContext"40
B40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSDate"24@"NSManagedObjectContext"32
@"NSArray"32@0:8q16@"NSManagedObjectContext"24
@"NSArray"40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"SKADatabaseInvitedUser"48@0:8@"SKInvitationPayload"16@"SKADatabaseInvitedUser"24@"SKADatabaseChannel"32@"NSManagedObjectContext"40
@"SKADatabaseInvitedUser"56@0:8@"SKHandle"16@"SKHandle"24@"SKInvitationPayload"32@"SKADatabaseChannel"40@"NSManagedObjectContext"48
B40@0:8@"SKADatabaseChannel"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"80@0:8@"NSString"16@"NSDate"24@"NSDate"32@"NSDate"40@"NSDate"48@"NSData"56@"NSString"64@"NSManagedObjectContext"72
@"SKADatabaseStatus"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"32@0:8@"NSString"16@"NSManagedObjectContext"24
v40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabasePendingPublishRequest"56@0:8@"NSString"16@"NSDate"24@"NSData"32@"NSString"40@"NSManagedObjectContext"48
@"SKADatabasePendingPublishRequest"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"NSArray"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseRemovedUser"48@0:8@"SKHandle"16@"NSDate"24@"NSString"32@"NSManagedObjectContext"40
@"SKADatabaseRemovedUser"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseReceivedInvitation"80@0:8@"SKADatabaseChannel"16@"SKHandle"24@"SKHandle"32@"NSString"40@"NSDate"48@"NSData"56@"NSData"64@"NSManagedObjectContext"72
v40@0:8@"NSString"16@"SKADatabaseReceivedInvitation"24@"NSManagedObjectContext"32
v24@0:8@"NSManagedObjectContext"16
v40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@36@0:8q16B24@28
@"<SKADatabaseManagingDelegate>"
@56@0:8@16@24@32@40q48
v24@0:8:16
{os_unfair_lock_s=I}16@0:8
v20@0:8{os_unfair_lock_s=I}16
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"NSHashTable"
