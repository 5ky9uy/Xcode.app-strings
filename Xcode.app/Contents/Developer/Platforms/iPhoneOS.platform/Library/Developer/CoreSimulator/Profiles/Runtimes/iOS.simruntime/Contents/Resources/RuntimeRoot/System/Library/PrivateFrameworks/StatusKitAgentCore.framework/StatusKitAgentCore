@(#)PROGRAM:StatusKitAgentCore  PROJECT:StatusKit-1
v8@?0
com.apple.StatusKit
SKAStatusEncryptionManager
channelID
%K == %@
com.apple.StatusKit.InvitationManager.cleanup
v24@?0@"SKADatabaseChannel"8@"NSError"16
v12@?0B8
com.apple.availability
com.apple.statuskit.cleanup
v20@?0B8@"NSError"12
v32@?0@"NSString"8@"NSData"16@"NSError"24
Sender handle is invalid, or could not determine a valid default sender handle.
Invited handles are invalid
Could not find or create a channel to send invitation for status of type "%@".
Could not find or create a channel to send invitation for presence "%@".
Key roll failed
Could not uninvite handle(s) "%@" because we could not find an existing invitation for those handle(s)
Could not any existing invitations to delete
Presence has been disabled by the server
SKAInvitationManager
activity-presence-enabled
lastSubscriptionDate
channelIdentifier
<%@: %p; presenceIdentifier = %@
SKAPresenceAssertion
dateRemoved
removedHandle
statusTypeIdentifier
presenceIdentifier
%@ %@
channel_topic
auth_credential
channel_ownership_type
SELF_USER_OWNERSHIP
SHARED_OWNERSHIP
(unknown: %i)
<%@: %p; subscriptionIdentifier = %@
SKAPresenceSubscriptionAssertion
identifier
personal
decomissioned
statusType
encryptionKeys
dateChannelCreated
channelType
%K != nil
token_uri
presence_identifier
channel_identifier
timestamp
client_payload
v16@?0@"NSError"8
com.apple.StatusKit.publish.types
com.apple.StatusKit.publish.allTypes
<%@ PID=%ld>
SKAStatusPublishingServiceClientConnection
status
uuid
server_timestamp_seconds
version
participant_payload
response_message_index
total_response_messages
SUCCESS
AUTH_EXPIRED
AUTH_FAILED
BAD_REQUEST
CHANNEL_IDENTITY_VALIDATION_FAILED
INTERNAL_ERROR
STALE_PUBLISH_REJECTED
RATE_LIMITED
com.apple.StatusKitAgent
lastPublishTime
rapidPublishCount
com.apple.StatusKitAgent.PublishingManager
com.apple.statuskit.pendingPublish
v24@?0@"NSString"8@"NSError"16
shared-channels-stale-publish-wait-time-seconds
shared-channels-rate-limit-wait-time-seconds
shared-channels-request-retry-count
shared-channels-client-rate-limit-max-rapid-publishes
shared-channels-client-rate-limit-rapid-publish-time-seconds
SKAStatusPublishingManager
Could not find or create a channel to publish status of type "%@".
Status Publish Request %@ created at %@ is not newer than existing status %@ at %@
Status Publish Request has the same status unique identifier as existing status: %@
Status Publish Request has been rate-limtited
<%@: %p; identifier = "%@"; personal = %ld, decomissioned = %ld, statusType = "%@"; dateCreated = "%@">;
SKADatabaseChannel
IDSRegistrationPropertySupportsSharedExperiencePresence
%@_%p
v16@?0q8
v24@?0@"NSData"8@"NSError"16
No valid IDS destinations could be determined
status-kit-keysharing-disabled
status-kit-selfsharing-disabled
SKAMessagingProvider
SKAPresenceMembershipKey
Client is not entitled to publish status of type "%@". Missing entitlement "%@"
Could not determine any users to share with from request
System iCloud account does not exist or is not statuskit capable
Could not determine sender handle to use
dateCreated of StatusPayload differs too much from server time
SKAStatusPublishingServiceClient
v24@?0@"SKHandleInvitability"8@"NSError"16
shared-channels-scheduled-publish-variance-max-slop-period-seconds
shared-channels-unscheduled-publish-variance-max-slop-period-seconds
shared-channels-secondary-device-republish-variance-min-slop-period-seconds
Client is not entitled to subscription information for status of type "%@". Missing entitlement "%@"
com.apple.StatusKit.subscribe.types
Client is not entitled to subscription information for status. Missing entitlement "%@"
Traffic mode is enable and status access is unavailable
Subscription not found matching subscription identifier: "%@"
SKAStatusSubscriptionServiceClient
v16@?0@"NSArray"8
lastReassertTime
lastCryptoRollTime
com.apple.StatusKitAgent.PresenceManager
com.apple.StatusKitAgent.ChannelFetchQueue
v32@?0@"NSError"8d16@"NSArray"24
v40@?0@"NSError"8d16Q24@"NSArray"32
v16@?0@"NSData"8
v32@?0@"NSError"8Q16@"NSArray"24
v24@?0@"NSError"8@"NSArray"16
v32@?0@"SKAPresenceAssertion"8Q16^B24
v32@?0@"SKPresentDevice"8Q16^B24
v24@?0@"NSError"8@"NSData"16
v20@?0@"NSError"8B16
No existing assertion exists
No channel exists for presence identifier
Failed to generate cryptographic keys for channel
Failed to generate payload for presence message
Payload is too large
shared-channels-reassert-reset-time-seconds
shared-channels-crypto-roll-reset-time-seconds
shared-channels-max-presence-payload-size-bytes
SKAPresenceManager
com.apple.StatusKit.StatusReceivingManager.cleanup
SKAStatusReceivingManager
dateCreated
statusUniqueIdentifier
SKAChannelManagerErrorDomain
SKAChannelManagerErrorRetryIntervalKey
StatusKitDataKey
com.apple.icloud.presence.shared.experience
com.apple.icloud.presence.mode.status
Generic non-success response status
SKAChannelManager
Could not fetch JWT token for authenticating request
Error in server response
retry_interval_seconds
<%@: %p; identifier = "%@"; dateCreated = "%@"; invitationPayload: "%@">
SKADatabaseReceivedInvitation
SKAPresenceEncryptionKey
com.apple.gs.sharedchannels.auth
com.apple.gs.sharedexperiences.auth
lastReauthTime
reauthCount
SKAAccountProviderErrorDomain
Reauth has hit rate limit
v24@?0@"NSDictionary"8@"NSError"16
shared-channels-reauth-max-count
shared-channels-reauth-backoff-time-seconds
SKAAccountProvider
encrypted_participant_payload
server_update_timestamp_seconds
channel_id
channel_token
com.apple.icloud.presence.channel.management
com.apple.aps.StatusKit
SKPushManagerErrorDomain
IMMobileNetworkManager
useSandbox
v40@?0@"IDSBaseMessage"8@"NSError"16q24@"NSDictionary"32
v24@?0@"NSArray"8@"NSError"16
shared-channels-disabled
SKAPushManager
<%@: %p; uniqueIdentifier = "%@"; channelIdentifier = "%@"; dateCreated = "%@"; dateExpired = "%@">;
SKADatabaseStatus
channel_identity
client_timestamp_seconds
lastFaultTime
com.apple.StatusKitAgent.SubscriptionManager
v32@?0@"SKATransientSubscriptionAssertion"8Q16^B24
v32@?0@"SKAPresenceSubscriptionAssertion"8Q16^B24
com.apple.focus.status
There are too many presence subscriptions
shared-channels-subscription-cache-size
activity-presence-max-subscription-size
shared-channels-max-subscription-size
shared-channels-subscription-ttl-minutes
SKAStatusSubscriptionManager
SKATransientSubscriptionAssertion
simple_jwt
shared_ownership_auth
auth_credential_oneof
PBUNSET
channel_publish_payload
publish_initiate_timestamp_millis
publish_payload
publish_payload_expiry_ttl_millis
push_priority
pending_publish_hint
scheduled_publish_hint
retry_count
NORMAL
HIGH
LDMGlobalEnabled
com.apple.private.alloy.status.keysharing
com.apple.StatusKit.publish
com.apple.StatusKit.subscribe
com.apple.StatusKit.presence
SKAStatusServer
com.apple.StatusKit.presence.clientID
BiomeDonationEnabled
Kettle
FeatureComplete
com.apple.statuskit.maintenance
v16@?0@"NSObject<OS_xpc_object>"8
com.apple.StatusKitAgent.CoreData.historyProcessing
v24@?0@"NSPersistentStoreDescription"8@"NSError"16
StatusKitAgent
SKADatabaseModel
com.apple.statuskit
StatusKit
database
statuskit-local-v1.db
statuskit-cloud.db
lastProcessedPersistentHistoryToken.data
Local
com.apple.aps.StatusKit.CloudKitMirroring
Cloud
author != %@
v24@?0@"CKAccountInfo"8@"NSError"16
skipHSA2
SKADatabaseProvider
SKAGeneratedEncryptionKey
dateInvitationCreated
senderHandle
dateGenerated
com.apple.StatusKit.subscribe.allTypes
SKAStatusSubscriptionServiceClientConnection
current_version
prev_version
encrypted_update_payload
payload
signature
update_type
padding
PARTICIPANT_ADDED
PARTICIPANT_REMOVED
applicationIdentifier
request_flag
NEW_REQUEST
REFRESH_REQUEST
UPDATE_MISSED
<%@: %p; statusPayload = "%@"; invitation = "%@">;
v32@?0@"ReceivedInvitation"8Q16^B24
v32@?0@"Channel"8Q16^B24
SKADatabaseManager
datePublished
uniqueIdentifier
%02lx
System iCloud account does not exist or is not presence capable
No channel exists or could be created for presence identifier
Missing client ID entitlement
This action isn't available when isPersonal is True
SKAPresenceClient
StatusKit-oversized
%@-%@-%@
%02x
activation_response
deactivation_response
polling_response
response
channel_public_key
nonce
sign_nonce
server_encryption_key
SKAPresenceClientConnection
activation_expiry_seconds
invitedHandle
channel
SKASystemMonitor
activation_request
deactivation_request
polling_request
request
Channel
ChannelCheckpoint
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
Channel does not have a current outgoing ratchet, rolling encryption key to generate a new one.
Encryption key rolled successfully, fetching new key
Key roll failed, unable to encrypt status
Error encrypting status: %@
Message encrypted successfully
Unable to encrypt status due to nil outgoing encryption key
Attempting to decrypt incoming status on personal channel using keys from %ld outgoing ratchets.
Status payload successfully decrypteded from generatedKey: %@
Status payload not decrypteded from generatedKey: %@
Status payload failed to decrypt with all known generated encryption keys.
Attempting to decrypt incoming status on non personal channel using incoming ratchet state from %ld received invitations.
Status payload successfully decrypteded from invitation: %@
Status payload not decrypted from invitation: %@
Status payload failed to decrypt with all known invitations.
Decrypteded payload: %@
Status payload failed to decrypt with error: %@
Status payload decypted to nil data
Status payload successfully decrypted
Extracting status payload, but envelope dictionary is not deserializable. Returning nil payload.
Extracting status payload, but encrypted payload is missing, is this an empty status update, or a malformed status: %@
Failed to extract status payload, signature is missing: %@
Failed to extract status payload, ratchet index is missing: %@
Failed to extract status payload, ratchet index is an invalid number: %@
Successfully decrypted status payload
Failed to decrypt status payload
Finding most recent incoming ratchet for personal channel from %ld outgoing ratchets.
Finding most recent incoming ratchet for non personal channel using incoming ratchet state from %ld received invitations.
Unable to find most recent incoming ratchet for channel: %@
Error serializing status envelope dictionary: %@
Error deserializing status envelope data as dictionary: %@
In Traffic Mode--will drop incoming status invitations
Request to invite handles contains no valid handles to invite. InvitedHandles: %@
Error resolving sender handle. UnresolvedSenderHandle: %@
Error fetching or creating personal channel: %@
Could not find or create personal channel
Adding invited handles %@ to database for channel: %@
Inivtation was not sent for handles %@ due to key roll error: %@
Invitations for newly invited handles %@ was already sent during key roll, skipping individual message send.
Invitation failed with error: %@
Presence has been disabled by the server.
Error fetching or creating presence channel: %@
Could not find or create presence channel
Could not find channel for presence identifier %@
Presence invitation sent successfully to self-account devices. ID:%@
Self presence invitation send failed with error: %@ message: %@, ID:%@.  Maybe no other device on account?
Could not find existing personal channel to revoke all invitations for
Finished deleting all invited user database records for channel %@, initiating key roll
Unable to find any invitations to revoke, taking no action, returning error
Could not find existing personal channel to revoke invitations for
Successfully deleted database record for invited user: %@.  Adding to removed users
Unable to find database record for invited user attempted to delete: %@
Finished deleting database records for uninvited users, initiating key roll
Finished rolling presence channel
Error rolling presence channel
Received request to roll encryption key for personal channel with statusTypeIdentifier: %@
Not rolling encryption key because a personal channel does not exist for statusTypeIdentifier: %@
Error encounted during key roll for statusTypeIdentifier: %@ error: %@
Received callback for message with identifier: %@ did send with success: %d
Invitation message failed to send! Removing record of invitation.
Could not find channel matching channel ID
Could not find channel ID matching message ID.
Received request to roll personal channel with statusTypeIdentifier: %@
Channel creation failed! Aborting channel roll.
Failed to copy invited users! Aborting channel roll.
Succesfully rolled personal channel with statusTypeIdentifier: %@
Asked to roll personal channel for %@, but no channel exists
Received request to roll presence channel with presence identifier: %@
Succesfully rolled presence channel with presenceIdentifier: %@
Asked to roll presence channel for %@, but no channel exists
Generating new outgoing ratchet
Storing newly generated outgoing ratchet
Messaging %ld existing invited users with the newly generated subscription keys
Outgoing IDS messages for encryption key roll failed to send: %@
Not sending any invitations following key roll as there are no invited users for channel %@
Failing to send invitation to zero invited users
Error generating incoming ratchet: %@
Error serializing incoming ratchet
Database InvitedUser does not have an invited SKHandle: %@
Sending invitation message with new encryption key ratchet index %ld to handle "%@" with invitation payload %@
Invitation sent successfully. ID: %@
Invitation send failed with error: %@ message: %@ ID: %@
Sending presence invitation message to handle "%@"
Presence invitation sent successfully. ID:%@
Presence invitation send failed with error: %@ message: %@, ID:%@
Invited handle failed validation, ignoring: %@
Validated invited handle set does not match unvalidated handles. Unvalidated set may have contained duplicate or invalid handles. Validated: %@ Unvalidated: %@
Incoming invitation from handle: %@
Invitation message missing channel identifier, dropping invitation: %@
Invitation message missing date invitation created, dropping invitation: %@
Invitation message has both status and presence, dropping invitation: %@
Treating invite as a status invite
We're in traffic mode--dropping incoming invitation
Invitation message uses legacy status type identifier, dropping invitation: %@
Invitation message missing incoming ratchet state, dropping invitation: %@
No existing channel matches incoming invitation, creating new channel
Treating invite as a presence invite
Invitation message missing channel token, dropping invitation: %@
Invitation message missing peer key data, dropping invitation: %@
Invitation message missing server key data, dropping invitation: %@
Invitation message is for a personal presence channel but does not come from a device on our account: %@
Invitation message missing membership key data, dropping invitation: %@
Invitation message missing date channel created. Using current server time
Could not find or create channel for incoming invitation, dropping invitation.
Invitation missing presence and status identifiers, dropping invitation: %@
Storing received invitation
Cleaning up ReceivedInvitations from handle: %@
Removing old channels for handle: %@
fromHandle "%@" is NOT a valid sender handle for active iCloud account
fromHandle "%@" is a valid sender handle for active iCloud account
toHandle "%@" inviteability check completed with result: %d
Handle is invalid, and not inviteable: %@
handle "%@" is present as a removed user
Channel has no existing encryption key data, initiating key roll to generate first key
Generating first encryption key for personal channel failed: %@
Found existing encryption keys, attempting to ratchet forward from current ratchet index: %ld
Rolling encryption key for personal channel failed: %@
Ratchet forward succeeded. New ratchet index: %ld. Persisting this state.
Error fetching or update invited user for handle: %@
Removing handle %@ from removed users because of invite
Invited handle has a nil handle string: %@
Found %ld existing invited user for invitedHandle %@ (ignoring sender handle).
Existing invited user was invited from the same handle: %@. Updating payload, and not creating a new InvitedUser record.
Existing invited user was invited from %@, but we are attempting to invite from %@. Will update this users payload, but may still need to create a new InvitedUser record
Updating invitation payload on invitedUser: %@
Received a nil updated user from call to updateInvitationPayload
Invitation payload is already up to date
Could not find an existing invited user matching handle: %@ and senderHandle %@, attempting to create a new one.
Received a nil created user from createInvitedUserWithHandle
Could not find an existing personal status channel, attempting to create a new one.
Account refresh required for error: %@
Account refresh succeeded, reattempting channel creation
Account refresh failed with error: %@
Error is an auth expired error, we should attempt reauth
Error is an auth failed error, we should attempt reauth
Error is an auth missing auth token error, we should attempt reauth
Error does not appear to be auth related, we should not attempt reauth
Server bag indicates presence enablement with status: %ld
Creating PresenceAssertion for identifier "%@"
PresenceAssertion
Deallocing PresenceAssertion for channel "%@", releasing os_activity
Creating PresenceSubscriptionAssertion for channel "%@"
PresenceSubscriptionAssertion
Deallocing PresenceSubscriptionAssertion for channel "%@", releasing os_activity
XPC connection to PID %ld interrupted
XPC connection to PID %ld invalidated
XPC Error (async): %{public}@
XPC Error (synchronous): %{public}@
Deallocing {pointer: %p}
Client is not entitled for any status types
Client is not entitled to publish status of type %{public}@
Client is currently rate-limited.  Enqueing requests as pending publish.
Publishing status unique identifier: %@ to channel: %@
Error publishing status with the channel manager: %@
Attempting reauth to resolve error
Account refresh succeeded, publishing pending publish requests
Removing pending publish based on error
Rolling channel.
Channel was rolled succesfully.
Channel roll failed.
Not rolling channel because this is a secondary device publish.
Attempting retry with delay.
Retrying after %f sec delay
Retry interval is 0--not retrying
Successfully published status %@ to channel %@
Dropping and removing status publish request with unique identifier %@. Error: %@
Could not find or create a personal channel for statusTypeIdentifier %@ error: %@
Pending publish request has already been scheduled.  Not enqueing again
Will attempt to process %ld pending publish requests after a %.2f second delay
Skipping publish of pending request that lacks an status identifier
Deleting pending status with ID %@ as it has expired
Deleting pending status with ID %@ as it has passed the max retry count of %lu
Attempting to publish pending request with ID: %@
Publish of pending status request with ID:%@ finished with error:%@
No pending publish requests
Publish requested for reason: %lu
Dropping status publish request, a status with unique identifier %@ has already been published. PublishRequest: %@
Dropping status publish request, existing status %@ was created at %@, publish request %@ from %@ is not newer.
In window for rate limit backoff.  We'll be free again at %@
We've left the rate-limit backoff window.
Incrementing rapid publish counter.
Deleting pending publish request with ID: %@ because it is older than newly received publish request with ID %@
Creating new pending status publish request for status unique identifier: %@
Pending status publish request already exists for status unique identifier: %@
StatusTypeIdentifier %@ corresponds to personal channel %@
Could not find an existing personal status channel for statusTypeIdentifier %@, attempting to create a new one.
Channel creation request failed with error: %@
Channel creation request succeeded, new personal channel for statusTypeIdentifier %@ has channel identifier %@
Deleting pending status publish request with identifier: %@
Delete failed for pending status publish request with identifier: %@
Publish was rejected for being stale. Abandoning.
Publish was rejected for being malformed. Abandoning.
Channel identity validation failed. We should roll this channel.
Publish was rejected because we've hit a rate limit.
Server bag indicates our pending publish request delay time should be %.2f
Server bag indicates our rate limit delay time should be %.2f
Server bag indicates our max retry count should be %lu
Server bag indicates our max rapid publishes should be %lu
Server bag indicates our rapid publish timescale should be %lu
Failed to create currentOutgoingRatchet due to invalid data. Error: %@
Initializing messaging provider with service %@ and delegate %@
Keysharing has been disabled by the server! Not initializing messaging service
Keysharing has been disabled by the server! Not sending message
Failed to generate IDS destination for handle: %@
No valid IDS destinations generated from handles: %@
Sending message %@ to destinations %@ options: %@
Successfully sent invitation message, assigned message identifier: %@
Failed to send invitation message with error: %@
Self sharing has been disabled by the server! Not sending message
No destinations for self devices
Sender handle "%@" is a valid sender handle for active iCloud account
Sender handle "%@" is not a valid sender handle for active iCloud account
Received incoming message: %@ fromID: %@
Keysharing has been disabled by the server! Dropping incoming message
Message: %@ did send with success: %d
Received didHintCheckingTransportLogWithReason
Resolved default caller ID: %@
Unable to determine default caller ID among URIs: %@
Signature verification returned with result: %d
Keysharing has been disabled in the server bag!
Self sharing has been disabled in the server bag!
Private key material nil or incorrect length
Signing completed with error: %@
Public key externalization completed with error: %@
Private key externalization completed with error: %@
Membership key generation completed with error: %@
Membership key generation from data completed with error: %@
Publishing service client connection was interrupted: %@
Publishing service client connection was invalidated: %@
Received request to publish status: %@
Rejecting publish request, client is not entitled
Account is not StatusKit capable
dateCreated not set on statusPublishRequest:%@. Setting to serverTime: %@
dateCreated time differs too much from server time.  delta = %f
Personal channel does not exist for status type identifier
Attempting to determine if handle %@ has already been invited from handle: %@
Error resolving sender handle for isInvited check. UnresolvedSenderHandle: %@
We found a match to an existing invited user
We found an existing invitated user matching the requested user, but that invitation was sent with handle %@ instead of handle %@. Ignoring.
We did not find a match to any existing invited user
Received request to send invitation for personal channel with statusTypeIdentifier %@ to handles: %@
Failed to send invitation to handles with error: %@
Successfully sent invitation to handles: %@
Received request to remove invitation from personal channel with statusTypeIdentifier %@ for handles: %@
Invitation revocation for handles %@ failed with error: %@
Invitation revocation for handles %@ completed succesffully
Received request to remove all invitations from personal channel with statusTypeIdentifier %@
Invitation revocation for all handles failed with error: %@
Invitation revocation for all handles completed succesffully
Client %@ has registered for delegate callbacks for statusTypeIdentifier: %@.
Server bag unexpected value type for key "%@". Value: %@
Resolved secondary device republish delay of %.1f seconds, within allowed range of (%.1f,%.1f) seconds.
XPC Error notifying of remote database changes. Error: %{public}@
Connected client completed processing of remote database changes.
Notifying client of updated subscription: %@
XPC Error notifying client of status update. Error: %{public}@
Connected client completed processing of status update.
Connected client does not match status type identifier of changed subscription. Client: %@ Status: %@
XPC Error notifying of received invitation. Error: %{public}@
Notifying connected client of received channel invitation.
Connected client completed processing of channel invitation.
Connected client does not match invited channel status type.
Current status for channel is expired
No existing status for channel
Beginning release of transient subscription assertions associated with interrupted client
Error releasing transient subscription assertions associated with interrupted client: %@
Success releasing transient subscription assertions associated with interrupted client
Beginning release of transient subscription assertions associated with invalidated client
Error releasing transient subscription assertions associated with invalidated client: %@
Success releasing transient subscription assertions associated with invalidated client
Client is not entitled to access subscription information for status type: %@
Retrieving subscription information for handle: %@
Subscription information not found for handle: %@
Found subscription metadata: %@ for handle %@
Retrieving all subscription information for statusTypeIdentifier: %@
Found %ld channels for status type %@
Retrieving all active assertions for statusTypeIdentifier: %@
Retrieving all subscription assertions for statusTypeIdentifier: %@ applicationIdentifier: %@
Found %ld subscription assertions
Subscription information not found for personal channel with statusTypeIdentifier: %@
Found subscription metadata for personal channel: %@
Received request to retain transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain transient subscription assertion for status type: %@
We're in traffic mode -- rejecting subscription request
No subscription was found matching subscriptionIdentifier: %@ statusTypeIdentifier: %@
Error retaining transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release transient subscription assertion for status type: %@
Error releasing transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to retain persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain persistent subscription assertion for status type: %@
Error retaining persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release persistent subscription assertion for status type: %@
Error releasing persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request for subscription and encryption validation token for handle "%@" statusTypeIdentifier: %@
Found channel %@ matching handle: %@
Did not find a channel matching handle: "%@". Returning empty string to indicate no match.
Received request for validate token "%@" from handle "%@" for statusTypeIdentifier: %@
Validating tokens against personal channel: %@
Received invalid validity for subscription channel validation. Not validating encryption token.
Sender "%@" asked us to verify that we do not have a personal channel, and they are correct
Sender "%@" asked us to verify a channel validation token, but we don't have a personal channel, this device may be out of sync, returning unknown
Attempting to validate subscription channel token "%@" against personal channel with identifier "%@"
Sender "%@" asked us to verify that we do not have a personal channel, but we do have channel %@. Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid subscription channel validation token
Sender "%@" has supplied a subscription channel validation token "%@", that does not match our current personal channel identifier "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Attempting to validate encryption token "%@" against personal channel %@
Sender "%@" provided encryption validation token "%@", but we do not have a local value to validate against. Returning valid.
Sender "%@" provided an nil encryption validation token, but we expected "%@". For backward compatibility, we assume nil means they are on an older OS and we should not fail validation. Returning valid.
Sender "%@" provided an empty encryption validation token, but we expected "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid encryption validation token. Provided: "%@" Expected: "%@"
Sender "%@" has supplied an encryptoin validation token "%@", that does not match our expected value "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Validated subscriptionIdentifier: %@ statusTypeIdentifier: %@
Failed to validate. subscriptionIdentifier: %@ does not match statusTypeIdentifier: %@
Failed to validate subscriptionIdentifier: %@ statusTypeIdentifier: %@
Payload is invalid! Aborting presence assertion. Error: %@
Presence assertion already existed, but still sending presence assertion to ensure apsd is in sync.
Updating active particpants for channel %@
Payload is oversized! Payload size:%lu Max size:%lu
_sendPresenceAssertionMessageForChannel - Failed to retrieve one or more required crypto keys. membershipKey %@ serverKey %@
Presence payload is nil
Sending presence assertion message for presence identifier %@ on channel %@
Account refresh succeeded, reattempting presence assertion
Account refresh did not fix secondary attempt %@
Should not reauth for error: %@
Presence assertion completed with success.
Sending polling request for channel: 
_sendPollingMessageForChannel - Failed to retrieve one or more required crypto keys. membershipKey %@ serverKey %@
Polling completed with success.
Updating present devices for channel: %@
Participant payload failed to be processed
Successfully removed presence assertion from in memory model for subscription identifier: %@
Deactivation message failed for %@ with error: %@
Deactivation message suceeded for %@
Could not find presence assertion to remove from in memory model for subscription identifier: %@
_sendPresenceDeactivationMessageForChannel - Failed to retrieve one or more required crypto keys. membershipKey %@ serverKey %@
Release completed with success.
Should not reauth for error releasing presence: %@
Presence release completed with success.
Disconnecting client had no active presence assertions, not updating registered subscriptions
Disconnecting client had %ld presence assertion, removing presence assertions and updating registrations for channels: %@
Completed sending deactivation message for presence identifier: %@ because of a disconnected client
Could not find presence assertion to remove from in memory model for presence identifier: %@
presentDevicesForPresenceIdentifier returning %lu devices
No channel currently exists, so returning empty set of present devices
Received incoming payload on channel %@
Failed to deserialize data on channel %@
We recently sent an assertion message. Delaying processing of incoming push
Last checkpoint matches current checkpoint -- not polling
Payload last checkpoint is 0 -- not polling
Last checkpoint does not match current checkpoint -- polling because we missed something. Payload last checkpoint: %lld ; Current saved checkpoint: %lld 
We want to poll but we currently have no connected clients with an active subscription.  Resetting state and dropping payload
Error updating active particpants for channel %@  based on polling response
Updating active particpants for channel %@  based on polling response
Encrypted update data missing on channel %@
Failed to instantiate server key for channel %@
Failed to decrypt payload for channel %@
Failed to deserialize update on channel %@
Missing participant payloads for update on channel %@
Failed to validate device on channel %@
The last checkpoint was 0, so we're clearing any previously present devices before adding the new one
Adding device %@ to channel %@
Removing device %@ from channel %@
Unkown update type on channel %@
Looking for self device in channel: %@
Present device: %@
Active assertion exists but we're missing or have expired from this channel: %@
Attempting to reassert to fix state
Error reasserting presence for channel %@
Updating active particpants for channel %@ following reassert
Not reasserting because of rate limit
Updated checkpoint to %lld on channel %@ with result %d
Found an existing presence assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added presence assertion to in memory model for presennce identifier: %@
Not creating a new presence assertion, one already exists.
Succesfully removed presence assertion for identifier: %@. Client had %ld presence assertions, now has %ld. Client: %@
Could not find presence assertion for subscription identifier: "%@". Active presence assertions: %@ for client: %@
Found an existing present device for channel: %@ and device:%@
Successfully added present device to in memory model for channel identifier: %@
Not creating a new present device, one already exists.
Succesfully removed present devices for identifier: %@. Channel had %ld presence assertions, now has %ld
Could not find present device for subscription identifier: "%@". Present devices: %@
Clearing present devices for channel: %@
Could not find an existing presence channel, attempting to create a new one.
_sendPresenceDeactivationMessageForChannel - Failed to create one or more required crypto keys. membershipKey %@ serverKey %@ peerKey %@
Failed to obtain material for one or more required crypto keys
Failed to get signature: %@
Failed to get peer key
Payload size: %ld
Payload data empty
Failed to instantiate peer key for decryption
Payload data failed to decrypt
Payload data missing signature
Payload channel ID does not match the channel it was published on
Payload presence ID does not match the identifier of the channel it was published on
Missing token URI
Signature verification for %@ failed with error %@
Payload data signature failed to verify
Assertion time is older than existing presence, dropping
Assertion time deviated too much from server received time! Asserting device clock out of sync or replay attack
Assertion time is more than a day in the future, dropping. Our clock might be out of sync
Incoming payload failed validation. Error: %@
Incoming present device has no client-specified payload
Self device identifier: %@
Other device identifier: %@
Constructed SKPresentDevice from payload: %@
Rolling channel to attempt to solve crypto error.
It's been too recent since our last crypto roll. Not rolling
Server bag indicates our reset time for reasserting presence should be %lu
Server bag indicates our reset time for resetting crypto roll rate limits presence should be %lu
Server bag indicates our maxPayload size should be %lu
Could not find channel matching incoming status update, ignoring.
Found channel matching channel identifier: %@.
Could not extract unencrypted envelope from incoming status update, ignoring.
Could not determine status unique identifier for incoming status update, ignoring.
Could not determine date published for incoming status update, ignoring.
Date created is too far in the future, ignoring.
We've already received a status with this unique identifier (%@), ignoring.
Received new status %@ for channel %@
Saved incoming status update to database with unique identifier: %@
Not informing delegate of status because it has expired
Received request to create a personal channel
Unable to fetch JWT token for icloud account.  Failing request.
Asking push manager to execute create channel request
Channel create request failed with error: %@
Channel create response received
Create channle response contains non success status: %ld - %@
Retry interval specified: %ld
Channel create success response received: %@
Received request to create a presence channel
Asking push manager to execute create presence channel request
Presence channel create request failed with error: %@
Presence channel create response received
Create presence channel response contains non success status: %ld - %@
Presence channel create success response received: %@
Received request to publish data on channel %@
Unable to fetch JWT auth token.  Failing request.
Sending publish request to push manager
Publish status request contains error: %@
Publish status request contains neither error nor proto response
Handling protobuf response data for completed status publish request
Publish status request completed with nonsuccess response status: %ld
Publish status request completed with success
Received request to assert presence on channel %@
Sending presence activation request to push manager
Presence assertion response contains error: %@
Presence assertion response contains neither error nor proto response
Handling protobuf response data for completed presence assertion request
Presence assertion request completed with nonsuccess response status: %ld
Presence assertion request completed with success
Received request to release presence on channel %@
Sending presence deactivation request to push manager
Presence assertion release response contains error: %@
Presence assertion release response contains neither error nor proto response
Handling protobuf response data for completed presence assertion release request
Presence assertion release request completed with nonsuccess response status: %ld
Presence assertion release request completed with success
Received request to poll presence on channel %@
Sending polling request to push manager
Polling response contains error: %@
Polling response contains neither error nor proto response
Handling protobuf response data for completed polling request
Polling request completed with nonsuccess response status: %ld
Polling request completed with success
Fetching subscribed channels
Received %ld subscribed channels: %@
Subscribing to channels: %@
Unsubscribing from channels: %@
Enabling activity tracking
Disabling activity tracking
Retrieving JWT token from account provider
Could not fetch JWT token!: Error: %@
Received data on channel: %@
Failed to subscribe to channel: %@ Error: %@
Failed to create incomingRatchet due to invalid data. Error: %@
keyMaterial nil or incorrect length
Can not encrypt empty/nil data
Could not encrypt. Status: %i
Encrypted data is too small to decrypt (invalid size)
Could not decrypt. Status: %i
Could not generate random bytes. %i
Unable to fetch system account! Likely no iCloud account signed in.
Unable to fetch JWT token!
Fetched token hash:%@ for %@
Reauth has hit rate limit.  Not attempting.
Unable to fetch account store!
Unable to fetch system account! Likely no iCloud account signed in. Error: %@
altDSID not available for account
Auth refresh suceeded.
Auth refresh failed with error: %@
Fetching primary iCloud account
Primary iCloud account determined: %@
Failed to find primary iCloud account
Server bag indicates our max reauth count should be %lu
Server bag indicates our reauth backoff time should be %lu
In Traffic Mode--will not honor status subscriptions and will drop incoming status's
Received did leave first unlock notification.
Initializing APS connection.
Deferring connection initialization as device is before first unlock.
Using sandbox push environment
Using production push environment
Shared channels disabled by server! Aborting
No active APS connection. Cannot change topic filter.
Not under first data protection lock but no APS connection!
Trying to create a channel resulted in error %@
Create channel reverse push completed, calling completion with proto response
Sending create channel message.
Switching %@ to non-waking
Switching %@ to enabled
Traffic mode is enabled. Aborting publish
Publishing status
Publishing status failed with resultCode %ld error: %@
Publishing status, reverse push completed, calling completion with protobuf response data
Asked to enable activity tracking but we're missing a connection.  Likely before first unlock
No APSConnection. Cannot fetch push token
Sending presence protobuff message to server
Presence protobuff send failed with resultCode %ld error: %@
Presence protobuff sent, reverse push completed, calling completion with protobuf response data
Not subscribing to status channels because traffic mode is enabled
Subscribing to channels: %@ for topic %@
Error fetching subscribed channels! Error: %@
Fetching subscribed channels completed with channels: %@
APSConnection server is disconnected. Using current system time
APSConnection server time is invalid. Using current system time
Receieved aps incoming message: %@ -- expiration: %@
Status kit message data undecodable
Channel subscription failed. Failures: %@
Shared channels has been disabled in the server bag!
Date expired: %@, isExpired: %d
Transient subscription assertion already existed, but still refreshing registered subscription assertions, to ensure apsd is in sync.
Failed to update registered subscriptions following transient assertion retain with error: %@
Successfully updated registered subscriptions following transient assertion retain
Successfully removed transient subscription assertion from in memory model for subscription identifier: %@
Could not find transient subscription assertion to remove from in memory model for subscription identifier: %@
Failed to update registered subscriptions following transient assertion release with error: %@
Successfully updated registered subscriptions following transient assertion release
Disconnecting client had no active transient subscription assertions, not updating registered subscriptions
Disconnecting client had %ld transient subscription assertion, removing transient assertions and updating registrations for channels: %@
Failed to update registered subscriptions following client disconnect with error: %@
Successfully updated registered subscriptions following client disconnect
A subscription assertion already exists, no need to create a new one. Existing: %@
Created subscription assertion: %@
Failed to update registered subscriptions following persistent assertion retain with error: %@
Successfully updated registered subscriptions following persistent assertion retain
Did not delete persistent subscription assertion because one was not found for subscription identifier: %@
Successfully removed persistent subscription assertion from database for subscription identifier: %@
Failed to update registered subscriptions following persistent assertion release with error: %@
Successfully updated registered subscriptions following persistent assertion release
Returning %lu active assertions.
Returning %lu active subscriptions.
Disconnecting presence client had no active transient subscription assertions, not updating registered subscriptions
Disconnecting presence client had %ld transient subscription assertion, removing transient assertions and updating registrations for channels: %@
Successfully removed presence subscription assertion from in memory model for subscription identifier: %@
Could not find presence subscription assertion to remove from in memory model for subscription identifier: %@
Failed to update registered subscriptions following presence assertion release with error: %@
Successfully updated registered subscriptions following presence assertion release
Presence subscription assertion already existed, but still refreshing registered subscription assertions, to ensure apsd is in sync.
Failed to update registered subscriptions following presence assertion retain with error: %@
Successfully updated registered subscriptions following presence assertion retain
Found an existing transient subscription assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added transient subscription assertion to in memory model for subscription identifier: %@
Not creating a new transient subscription assertion, one already exists.
Found an existing presence subscription assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added presence subscription assertion to in memory model for subscription identifier: %@
Not creating a new presence subscription assertion, one already exists.
Marking subscription change time for channel %@
Succesfully removed transient subscription assertion for identifier: %@. Client had %ld transient subscription assertions, now has %ld. Client: %@
Could not find transient subscription assertion for subscription identifier: "%@". Active transient subscription assertions: %@ for client: %@
Succesfully removed presence subscription assertion for identifier: %@. Client had %ld transient subscription assertions, now has %ld. Client: %@
Could not find presence subscription assertion for subscription identifier: "%@". Active transient subscription assertions: %@ for client: %@
StatusKitAgent wants to be subscribed to: %@
StatusKitAgent was previously subscriped to: %@
No changes for active subscriptions based on current assertions. Subscribed to: %@
Subscriptions updated. Subscribed to: %@
Active subscription count %ld does not exceed cap of %ld
Active subscription count %ld exceeds cap of %ld
Transient subscription assertions: %@
Persistent subscription assertions: %@
Personal channels requiring self subscription: %@
Cached channels for subscription: %@
Finding at most %ld cached channels to subscribe to
Channel from history is gone from database: %@
Personal channel has no identifier: %@
No personal channel for statusTypeIdentifier: %@
Server bag indicates our max subscription count should be %lu
Server bag indicates our max presence subscription count should be %lu
Server bag indicates our hard max subscription count should be %lu
Server bag indicates our subscription TTL should be %f seconds
Creating TransientSubscriptionAssertion for channel "%@"
TransientSubscriptionAssertion
Deallocing TransientSubscriptionAssertion for channel "%@", releasing os_activity
Initializing
Shutting down
Logging state
Receiving XPC connection from PID %ld for publishing service
Receiving XPC connection from PID %ld for subscription service
Receiving XPC connection from PID %ld for presence
Receiving XPC connection from PID %ld for unknown service name: %{public}@
Rejected XPC connection from PID %ld for publishing service. Client is not entitled for any publishing service.
Accepted XPC connection from PID %ld for publishing service
Incoming XPC connection from PID %ld for presence service
Accepting XPC connection from PID %ld for presence service with clientid:%@
Rejecting incoming XPC connection from PID %ld because of missing or blank entitlement: %@
Rejected XPC connection from PID %ld for subscription service. Client is not entitled for any subscription service.
Accepted XPC connection from PID %ld for subscription service
Subscription service client was invalidated. Removing client: %@
Publishing service client was invalidated. Removing client: %@
Presence client was invalidated. Removing client: %@
Received remote database changes for channels: %@
Error updating subscriptions following remote database changes: %@
Success updating subscriptions following remote database changes
Could not find channel matching changed channelIdentifier: %@
Could not find any database channel matching changed channelIdentifiers
Incoming message received. Service: %@ senderID: %@ guid: %@
Handling message as key invite
Received network reachable notification
Kettle feature flag not enabled.  Exiting.
Handling as status update
We're in traffic mode--dropping incoming status
Handling as presence update
Unrecognized channel type for incoming message
Unable to find database channel for channel id for incoming message
Failed to subscribe to channel %@ with error: %@
Server received status update: %@
Writing to Biome event with IDSHandle: %@, statusTypeIdentifier %@
Channel created with identifier: %@ type: %@
Updating registered subscription to allow self subscription to personal channel, if necessary
Updating registered subscription failed with error: %@
Updating registered subscription to allow self subscriptions completed
Server received present devices update on presence identifier: %@
New presence channel created. Sending self invite for channel: %@
Sent self-invite with success:%d and error:%@
Finished rolling channel with success %d
Received channel invitation on channel: %@
Handling invitation as status invite
Handling invitation as presence invite
New received invitation for presence identifier %@ updated the mapped channel.  Notifying connected clients to reassert if needed
Revoked invitation(s) on channel: %@. Republishing current status
Finished republishing status.  ID:%@ error:%@
Couldn't decrypt current status on channel
No current status to republish
Scheduling maintenance XPC activity %@
Finished maintenance subscription update with error %@
Removing decomissioned channels
Creating persistent container
Failed to load persistent store. Error: %@ Store: %@
Completed loading of persistent store: %@
Completed creation of persistent container
Failed creation of persistent container
Persistent store remote change notification received.
Error executing history change request: %@
History change request found no results.
Have channel matching persistent history change. Channel: %@ Change: %@
Could not find channel matching persisent history change: %@
Ignoring delete channel change: %@
Have received invitation matching persistent history change. ReceivedInvitation: %@ Change: %@
ReceivedInvitation matching persistent history change has channel. Channel: %@ Change: %@
ReceivedInvitation matching persistent history change has not channel. ReceivedInvitation: %@ Change: %@
Could not find encryption key matching persisent history change: %@
Ignoring delete received invitation change: %@
Did not find object matching change history event. Object has already been deleted. Error: %@
Error fetching object matching change transaction. Error: %@
Last processed persistent history token is nil at URL %@
Error unarchiving last processed persistent history token. Error: %@
Error archiving last processed persistent history token. Error: %@
Archived last processed persistent history token is zero length
Overriding device-to-device encryption check because default has been set.
Account supports device-to-device encryption
Account does not support device-to-device encryption and is not statuskit capable
Failed to create outgoing ratchet due to invalid data. Error: %@
Failed to create outgoing ratchet due to nil outgoing ratchet state
Failed to create incoming ratchet due to failure to access subscription keys
Failed to create incoming ratchet due to lack of outgoing ratchet
Client is not entitled to subscription information for status of type %{public}@
Error fetching personal status channel. Error: %@
Fetch request for personal status channel type "%@" completed with result: %@
Error fetching decomissioned channel. Error: %@
Fetch request for decomissioned personal channels completed with %lu results
Deleted existing channel.
Could not find existing channel
More than one personal channel exists for channel identifier: %@
Error executing fetch for subscription validation. Error: %@
Fetch request for channels by identifier returned a nil result
Fetch request for channel by identifier %@ found no match.
Fetch request for channels by identifier %@ returned a nil result
Beginning fetch request for channels with presence identifier: %@
Fetch request for channel by identifier found no match.
Fetch request for channel by identifier completed with %ld result(s)
Preferring invitation %@ from %@ among %ld result(s)
Invitation %@ corresponds to channelIdentifier: %@
Could not find any channels associated with channel identifier: %@
Invitation does not correspond to any channel. InvitationIdentifier: %@
No received invitation found matching handle %@ statusTypeIdentifier: %@
Invitation does not correspond to any channel. ReceivedInvitation: %@ handle: %@
Channel not found for channel identifier: %@
Beginning fetch request for channel by handle
Error executing fetch for channel by handle. Error: %@
Fetch request for channel by handle found no match.
Fetch request for channel by handle completed with %ld result(s)
Error saving managed object context for storing new personal channel. Error: %@
Error saving managed object context for storing new presence channel. Error: %@
Error saving managed object context for storing channel invitation. Error: %@
Error saving managed object context for updated outgoing ratchet state. Error: %@
Error saving managed object context for decomissioning. Error: %@
Could not find generated ratchet keys matching database channel. Channel: %@
Beginning fetch request for active subscription assertions
Error fetching subscription assertions. Error: %@
Fetch request for active subscription assertions completed
Error saving managed object context for storing persistent subscription assertion. Error: %@
Deleted existing assertion.
Could not find existing assertion
Error fetching transientSubscriptionHistory. Error: %@
Error fetching transientSubscriptionHistories. Error: %@
Found existing transient subscription history. Updating lastSubscrionDate.
Could not find existing transient subscription history. Creating a new one.
Error saving managed object context for storing transient subscription history. Error: %@
Error saving managed object context for storing invited user. Error: %@
Error saving managed object context for copyinh invited users. Error: %@
Multiple (%ld) entries in the database match a single invited user, updating all of them. InvitedUser: %@
Error saving managed object context for updating invitation payload on invited user. Error: %@
Error finding core data invited user to update invitation. No match for SKADatabaseInvitedUser: %@
Error finding core data channel matching SKADatabaseChannel: %@
Error fetching invited user. Error: %@
Fetch request for invited user executed with results: %@
Failed to normalize handle: "%@", returning nil existing invited user
Deleting existing invited user with handle: %@
Error saving managed object context for deleting invited users by handle. Error: %@
Could not find existing invited user matching handle: %@
Could not find existing database channel matching channel %@
Deleting all %ld existing invited users for channel %@
Error saving managed object context for deleting all invited users. Error: %@
Could not find any existing invited users to delete
Error saving managed object context for storing status. Error: %@
Beginning lookup of most recent status for channel
Error executing fetch for status by channel. Error: %@
Fetch request for status by channel found no match.
Fetch request for status by channel completed with %ld result(s)
Beginning lookup of most recent status for unique id
Error executing fetch for status by unique id. Error: %@
Fetch request for status by unique id found no match.
Fetch request for status by unique id completed with %ld result(s)
Found existing checkpoint %lld for channel %@
No existing checkpoint for channel: %@. Creating a new checkpoint
Error saving managed object context for channel checkpoint. Error: %@
Updated checkpoint for channel: %@
Error saving managed object context for storing checkpoint. Error: %@
Error fetching pending requests. Error: %@
Beginning database cleanup of statuses on channel identifier: %@
Error executing fetch for status cleanup. Error: %@
Fetch request for cleanup of statuses found no matches.
Fetch request for status cleanup completed with %ld result(s)
Keeping status %@ because it is our most recent status
Keeping status %@ because it is excluded from this cleanup request
Deleting status %@ as it is no longer the most recent
Error saving managed object context for status cleanup. Error: %@
Error saving managed object context for storing pending publish request. Error: %@
Error saving managed object context for deleting pending publish request. Error: %@
Deleted existing pending publish request with identifier: %@
Could not find existing pending publish request with identifier: %@
Error saving managed object context for incrementing pending publish request. Error: %@
Incremented pending publish request rc with identifier: %@
Error saving managed object context for storing removed user. Error: %@
Error saving managed object context for deleting removed user. Error: %@
Deleted existing removed user with handle: %@
Could not find existing removed user with handle: %@
Error fetching removed users. Error: %@
Beginning fetch request for ReceivedInvitation from handle %@ statusTypeIdentifier: %@
Error executing fetch for ReceivedInvitation by handle. Error: %@
Fetch request for ReceivedInvitation by handle found no match.
Fetch request for ReceivedInvitation by handle completed with %ld result(s)
Could not find core data channel to match channel identifier: %@
Error saving managed object context for storing received invitation. Error: %@
Could not find any existing channels matching channel identifier. Returning no received invitations. Channel identifier: %@
Deleting invitation %@ as it is no longer the most recent
Error saving managed object context for invitation cleanup. Error: %@
Deleting channel %@ as it is decomissioned and not recent or old
Not deleting channel %@ as it is in our most recent and old decomissioned channels
Error saving managed object context for decomissioned channel cleanup. Error: %@
No decomissioned channel to clean up
Channel cleanup is disabled.
Presence client connection was interrupted: %@
Error releasing presence assertions associated with interrupted client: %@
Success releasing presence assertions associated with interrupted client
Presence client connection was invalidated: %@
Beginning release of presence subscription assertions associated with interrupted client
Error releasing presence subscription assertions associated with invalidated client: %@
Success releasing presence subscription assertions associated with invalidated client
Beginning release of presence assertions associated with interrupted client
Error releasing presence assertions associated with invalidated client: %@
Success releasing presence assertions associated with invalidated client
Client did not specify a payload
Missing client ID entitlement or presence identifier
Retaining presence assertion for presenceIdentifier: %@
Error retaining presence assertion for presenceIdentifier: %@ error: %@
Successfully retained presence assertion for presenceIdentifier: %@
Error releasing presence assertion for presenceIdentifier: %@ error: %@
Successfully released presence assertion for presenceIdentifier: %@
Presence account check completed with result: %d
Inviting handles isn't available when isPersonal is true
Received request to send invitation for presence channel with presence identifier %@ to handles: %@
Account is not Presence capable
Personal channel does not exist for presence identifier
Client %@ has registered for delegate callbacks for presence identifier: %@.
Inviting (or removing) handles isn't available when isPersonal is true
Unable to find or create channel for presenceIdentifier: %@
Error retaining presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@ error: %@
Successfully retained presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@
Successfully released presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@
Notifying client of updated present devices
XPC Error notifying client of present devices update. Error: %{public}@
Retrieved present devices. Presence: %{public}@ Handles: %@ Error: %@
Retrieved present devices. Presence: %{public}@ Handles: %@
Notifying delegate of present devices change
Connected client completed processing of present devices update.
No change in present devices - not notifying delegate
Connected client does not match presence identifier of changed channel. Client: %@ Presence: %@
Notifying client of updated invitations
XPC Error notifying client of invitations update. Error: %{public}@
Connected client completed processing of invited handles update.
Unable to find channel for presenceIdentifier: %@
Moving over to new channel for subscription for presence identifier %@. Old channel %@ New channel %@
Error releasing presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@ error: %@
Reasserting presence to handle change in underlying channel for presenceIdentifier %@
Client does not have a presence client ID
Delivering %@ to %@
SKAStatusEncryptionManager
SKAStatusEncryptionManaging
NSObject
SKAStatusUnencryptedEnvelope
KeyPathConstants
Predicates
SKAOutgoingInvitationState
SKAInvitationManager
SKAInvitationManaging
SortDescriptors
SKAPresenceAssertion
SharedChannelCreateRequest
NSCopying
SKAPresenceSubscriptionAssertion
DecryptedParticipantPayload
SKAStatusPublishingServiceClientConnection
ChannelActivityPollingResponse
SKAStatusPublishingManager
SKAStatusPublishingManaging
SKADatabaseChannel
CurrentOutgoingRatchet
SKAMessagingProvider
IDSServiceDelegate
SKAMessagingProviding
SKAPresenceMembershipKey
SKAStatusPublishingServiceClient
SKStatusPublishingDaemonProtocol
SKAStatusPublishingServiceClientConnectionLifecycleDelegate
SKAStatusSubscriptionServiceClient
SKStatusSubscriptionDaemonProtocol
SKAClientConnectionRepresentable
SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate
SKAPresenceManager
SKAPresenceManaging
SKAStatusReceivingManager
SKAStatusReceivingManaging
CoreData
SKAChannelManager
SKAPushManagingDelegate
SKAChannelManaging
SharedChannelPublishResponse
SKADatabaseReceivedInvitation
SKHandle
IncomingRatchet
SKInvitationPayload
SKADatabaseTransientSubscriptionHistory
StatusKitAgent
SKAPresenceEncryptionKey
SKAAccountProvider
SKAAccountProviding
ChannelActivityParticipantPayload
ChannelIdentity
SKAPushManager
APSConnectionDelegate
SKASystemMonitorListener
SKAPushManaging
SKADatabaseStatus
SharedChannelCreateResponse
ChannelActivityDeactivationRequest
SKAStatusSubscriptionManager
SKAStatusSubscriptionManaging
SKATransientSubscriptionAssertion
AuthCredential
SharedChannelPublishRequest
ChannelPublishPayload
SKAStatusServer
NSXPCListenerDelegate
SKADatabaseProvidingDelegate
SKAMessagingProvidingDelegate
SKAChannelManagingDelegate
SKAStatusReceivingManagingDelegate
SKADatabaseManagingDelegate
SKAInvitationManagingDelegate
SKAStatusPublishingServiceClientDelegate
SKAStatusSubscriptionServiceClientDelegate
SKAPresenceClientDelegate
SKAPresenceManagingDelegate
SKADatabaseRemovedUser
SKADatabaseProvider
SKADatabaseProviding
SKAGeneratedEncryptionKey
Ratchets
SKAStatusSubscriptionServiceClientConnection
ChannelActivityUpdate
SignedParticipantPayload
ChannelActivityUpdatePayload
ChannelActivityActivationRequest
SKADecryptedStatusPayload
SKADatabaseInvitedUser
SKADatabaseManager
SKADatabaseManaging
SKADatabaseSubscriptionAssertion
ChannelActivityPollingRequest
SKAPresenceClient
SKPresenceDaemonProtocol
SKAPresenceClientConnectionLifecycleDelegate
ChannelActivityDeactivationResponse
SKADatabasePendingPublishRequest
SharedChannelActivityResponse
SharedOwnershipAuth
SKAPresenceClientConnection
ChannelActivityActivationResponse
SKASystemMonitor
SharedChannelActivityRequest
Channel
CoreDataProperties
ChannelCheckpoint
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
init
setObject:forKeyedSubscript:
timeIntervalSince1970
numberWithDouble:
payloadData
_encryptPayload:channel:
encryptedMessage
base64EncodedStringWithOptions:
index
numberWithUnsignedShort:
signature
_serializeDictionaryAsBinaryPlist:
currentOutgoingRatchet
logger
statusType
rollEncryptionKeyForPersonalChannelWithStatusTypeIdentifier:error:
newBackgroundContext
existingPersonalChannelForStatusTypeIdentifier:databaseContext:
sealStatus:authenticating:error:
isPersonal
generatedEncryptionKeysForPersonalChannel:databaseContext:
count
countByEnumeratingWithState:objects:count:
incomingRatchet
_decryptPayloadData:withIncomingRatchet:withRatchetIndex:signatureData:
initWithData:
initWithStatusPayload:invitation:
receivedInvitationsForChannel:databaseContext:
firstObject
unsealStatusWithIndex:encryptedMessage:authenticating:signature:error:
_deserializeBinaryPlistDictionaryData:
initWithEnvelopeDictionary:
ska_dataFrombase64EncodedStringForKey:
ska_numberForKey:
integerValue
_decryptPayload:withRatchetIndex:signatureData:channel:
_mostRecentIncomingRatchetForChannel:
signingKeyIdentifier
ska_hexString
length
substringToIndex:
dataWithPropertyList:format:options:error:
propertyListWithData:options:format:error:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
encodeStatusPayload:statusUniqueIdentifier:dateCreated:currentServerTime:channel:
extractEnvelopeFromStatusEnvelopeData:
decryptStatusPayloadFromStatusEnvelopeData:channel:
encryptionValidationTokenForChannel:
initWithDatabaseManager:invitationManager:
databaseManager
invitationManager
.cxx_destruct
_databaseManager
_invitationManager
T@"<SKADatabaseManaging>",R,N,V_databaseManager
T@"<SKAInvitationManaging>",R,N,V_invitationManager
ska_stringForKey:
ska_dateFromUnixTimestampForKey:
statusUniqueIdentifier
datePublished
dateCreated
envelopeDictionary
setEnvelopeDictionary:
_envelopeDictionary
T@"NSDictionary",&,N,V_envelopeDictionary
T@"NSString",R,N
T@"NSDate",R,N
identifierKeyPath
predicateWithFormat:
predicateForChannelIdentifier:
initWithToHandle:fromHandle:channelIdentifier:
toHandle
setToHandle:
fromHandle
setFromHandle:
channelIdentifier
setChannelIdentifier:
_toHandle
_fromHandle
_channelIdentifier
T@"SKHandle",&,N,V_toHandle
T@"SKHandle",&,N,V_fromHandle
T@"NSString",&,N,V_channelIdentifier
_presenceEnabledByServer
_validateInvitedHandles:
_invalidInvitedHandlesError
resolveSenderHandleWithPreferredSenderHandle:
_invalidSenderHandleError
_noPersonalChannelErrorForStatusTypeIdentifier:
_addInvitedHandles:senderHandle:toDatabaseForPersonalChannel:withInvitationPayload:databaseContext:
_ratchetEncryptionKeyForwardOrKeyRollForPersonalChannel:databaseContext:invitationWasSentViaKeyRoll:error:
currentSubscriptionKeys
_sendInvitationMessageForChannel:toInvitedUsers:subscriptionKeys:error:
_findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
presenceEnabledByServer
_presenceDisabledError
presenceManager
_noPresenceChannelForIdentifier:
_addInvitedHandles:senderHandle:toDatabaseForPresenceChannel:databaseContext:
_sendInvitationMessageForPresenceChannel:toInvitedUsers:error:
findOrCreatePresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
_invitationMessageForPresenceChannel:
messagingProvider
copy
sendMessageToSelfDevices:limitToPresenceCapable:identifier:error:
findPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
deleteAllInvitedUsersForPersonalChannel:databaseContext:
_rollEncryptionKeyForChannel:databaseContext:error:
_keyRollFailedErrorWithUnderlyingError:
_unableToFindAnyExistingInvitationToDeleteError
deleteInvitedUserForHandle:personalChannel:databaseContext:
createRemovedUserWithHandle:dateRemoved:statusTypeIdentifier:databaseContext:
invitationManager:didRevokeInvitationOnChannel:
_unableToFindExistingInvitationForHandlesError:
existingChannelForPresenceIdentifier:isPersonal:databaseContext:
createRemovedUserWithHandle:dateRemoved:presenceIdentifier:databaseContext:
rollPresenceChannelWithPresenceIdentifier:isPersonal:completion:
outgoingInvitationMapping
valueForKey:
existingChannelForSubscriptionIdentifier:databaseContext:
deleteInvitedUserForHandle:presenceChannel:databaseContext:
removeObjectForKey:
copyInvitedUsersFromChannel:toChannel:databaseContext:
identifier
decomissionChannelWithIdentifier:databaseContext:
_createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
invitedUsers
createPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
serializedData
createGeneratedEncryptionKeyWithOriginalOutgoingRatchetState:personalChannel:databaseContext:
existingInvitedUsersForPersonalChannel:databaseContext:
chainKey
signingKey
initWithIndex:chainKey:signingKey:error:
invitedSKHandle
senderSKHandle
invitationPayload
handleString
date
sendMessage:toHandle:fromHandle:limitToPresenceCapable:identifier:error:
presenceServerKey
presencePeerKey
presenceMembershipKey
presenceIdentifier
channelToken
channelManager
serverTime
dateChannelCreated
numberWithBool:
_validateInvitedHandle:
addObject:
array
isEqualToString:
createChannelForStatusTypeIdentifier:channelIdentifier:databaseContext:
boolValue
isFromIDFromSelfAccount:
createPresenceChannelForPresenceIdentifier:channelIdentifier:channelToken:peerKey:serverKey:membershipKey:creationDate:isPersonal:databaseContext:
createReceivedInvitationForChannel:senderHandle:invitedHandle:invitationIdentifier:dateInvitationCreated:incomingRatchetState:presenceIdentifier:channelToken:serverKey:peerKey:invitationPayload:databaseContext:
invitationManager:didReceiveInvitation:forChannel:
allExistingChannelsForHandle:statusTypeIdentifier:databaseContext:
cleanupOldReceivedInvitationsForChannelIdentifier:excludingInvitation:databaseContext:
cleanupOldChannelsForHandle:statusTypeIdentifier:databaseContext:
isHandleAvailableToMessageFrom:
_isHandleInviteable:completion:
isHandleMessageable:completion:
_isPresenceHandleInviteable:completion:
isHandleMessageableForPresence:completion:
existingRemovedUserWithHandle:statusTypeIdentifier:withDatabaseContext:
initWithIsInvitable:wasRemoved:
isHandleInviteable:fromHandle:completion:
existingRemovedUserWithHandle:presenceIdentifier:withDatabaseContext:
isPresenceHandleInviteable:fromHandle:completion:
ratchetForward
updatePersonalChannel:withCurrentOutgoingRatchetState:databaseContext:
_updateOrCreateInvitedUserWithHandle:senderHandle:onChannel:withInvitationPayload:databaseContext:
addObjectsFromArray:
deleteRemovedUserWithHandle:statusTypeIdentifier:databaseContext:
deleteRemovedUserWithHandle:presenceIdentifier:databaseContext:
existingInvitedUsersForInvitedHandle:onChannel:databaseContext:
isNormalizedEqualToHandle:
updateInvitationPayload:onExistingInvitedUser:channel:databaseContext:
createInvitedUserWithHandle:senderHandle:invitationPayload:channel:databaseContext:
_shouldReauthForError:
accountProvider
createPersonalChannelForStatusTypeIdentifier:channelIdentifier:channelToken:databaseContext:
createChannelWithCompletion:
refreshCredentialForPrimaryAccountWithCompletion:
domain
code
stringWithFormat:
dictionaryWithObjects:forKeys:count:
errorWithDomain:code:userInfo:
componentsJoinedByString:
sharedInstanceForBagType:
objectForKey:
sendInvitationForPersonalChannelWithStatusTypeIdentifier:toHandles:fromSenderHandle:withInvitationPayload:completion:
sendInvitationForPresenceChannelWithPresenceIdentifier:toHandles:fromSenderHandle:completion:
sendSelfInvitationForPresenceChannelWithPresenceIdentifier:isPersonal:completion:
revokeInvitationFromPersonalChannelWithStatusTypeIdentifier:forHandles:completion:
revokeInvitationFromPresenceChannelWithPresenceIdentifier:forHandles:completion:
revokeAllInvitationsFromPersonalChannelWithStatusTypeIdentifier:completion:
handleIncomingInvitationMessage:fromHandle:fromID:toHandle:messageGuid:
outgoingMessageWithIdentifier:fromHandle:toHandle:didSendWithSuccess:
rollPersonalChannelWithStatusTypeIdentifier:completion:
fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:
fetchHandleInvitability:fromHandle:forPresenceIdentifier:completion:
delegate
setDelegate:
T@"<SKAInvitationManagingDelegate>",W,N
initWithMessagingProvider:databaseManager:accountProvider:channelManager:presenceManager:trafficMode:
setDatabaseManager:
setMessagingProvider:
setChannelManager:
setAccountProvider:
setPresenceManager:
backgroundCleanupQueue
setBackgroundCleanupQueue:
setOutgoingInvitationMapping:
trafficModeEnabled
setTrafficModeEnabled:
setPresenceEnabledByServer:
_trafficModeEnabled
_delegate
_messagingProvider
_channelManager
_accountProvider
_presenceManager
_backgroundCleanupQueue
_outgoingInvitationMapping
T@"<SKADatabaseManaging>",&,N,V_databaseManager
T@"<SKAMessagingProviding>",&,N,V_messagingProvider
T@"<SKAChannelManaging>",&,N,V_channelManager
T@"<SKAAccountProviding>",&,N,V_accountProvider
T@"<SKAPresenceManaging>",&,N,V_presenceManager
T@"NSObject<OS_dispatch_queue>",&,N,V_backgroundCleanupQueue
T@"NSMutableDictionary",&,N,V_outgoingInvitationMapping
TB,N,V_trafficModeEnabled
TB,N,V_presenceEnabledByServer
T@"<SKAInvitationManagingDelegate>",W,N,V_delegate
lastSubscriptionDateKeyPath
channelIdentifierKeyPath
predicateForLastSubscriptionDate:
sortDescriptorWithKey:ascending:
sortDescriptorForLastSubscriptionDateAscending:
isEqualToPresenceAssertion:
dealloc
initWithPresenceIdentifier:isPersonal:payload:
payload
setPayload:
osActivity
_isPersonal
_presenceIdentifier
_payload
_osActivity
T@"NSObject<OS_os_activity>",R,N,V_osActivity
T@"NSString",R,C,N,V_presenceIdentifier
TB,R,N,V_isPersonal
T@"SKPresencePayload",C,N,V_payload
dateRemovedKeyPath
handleKeyPath
statusTypeIdentifierKeyPath
presenceIdentifierKeyPath
normalizedHandleString
predicateForHandleString:
predicateForHandle:
predicateForStatusTypeIdentifier:
predicateForPresenceIdentifier:
dictionaryRepresentation
dictionary
setObject:forKey:
setChannelTopic:
setAuthCredential:
allocWithZone:
copyWithZone:
mergeFrom:
hasChannelTopic
hasAuthCredential
channelOwnershipType
setChannelOwnershipType:
setHasChannelOwnershipType:
hasChannelOwnershipType
channelOwnershipTypeAsString:
StringAsChannelOwnershipType:
readFrom:
writeTo:
copyTo:
channelTopic
authCredential
_authCredential
_channelOwnershipType
_channelTopic
_has
TB,R,N
T@"NSString",&,N,V_channelTopic
T@"AuthCredential",&,N,V_authCredential
TB,N
Ti,N,V_channelOwnershipType
subscriptionIdentifier
isEqualToPresenceSubscription:
initWithSubscriptionIdentifier:
_subscriptionIdentifier
T@"NSString",R,C,N,V_subscriptionIdentifier
personalKeyPath
decomissionedKeyPath
statusTypeKeyPath
encryptionKeysKeyPath
dateChannelCreatedKeyPath
channelTypeKeyPath
predicateForPersonal:
predicateForDecomissioned:
predicateForChannelTypeStatus
predicateForChannelTypePresence
predicateForCreationDateNotNil
sortDescriptorForStatusTypeIdentifierOrderedAscending:
sortDescriptorForPersonalOrderedAscending:
sortDescriptorForChannelIdentifierOrderedAscending:
sortDescriptorForCreationDateAscending:
numberWithUnsignedLongLong:
setTokenUri:
setPresenceIdentifier:
setClientPayload:
hasTokenUri
hasPresenceIdentifier
hasChannelIdentifier
setTimestamp:
setHasTimestamp:
hasTimestamp
hasClientPayload
tokenUri
timestamp
clientPayload
_timestamp
_clientPayload
_tokenUri
T@"NSString",&,N,V_tokenUri
T@"NSString",&,N,V_presenceIdentifier
TQ,N,V_timestamp
T@"NSData",&,N,V_clientPayload
daemonXPCInterface
setExportedInterface:
setExportedObject:
daemonDelegateXPCInterface
setRemoteObjectInterface:
_setQueue:
processIdentifier
connectionLifecycleDelegate
publishingServiceClientConnectionWasInterrupted:
setInterruptionHandler:
publishingServiceClientConnectionWasInvalidated:
setInvalidationHandler:
resume
xpcConnection
remoteObjectProxyWithErrorHandler:
synchronousRemoteObjectProxyWithErrorHandler:
invalidate
sk_stringArrayValueForEntitlement:
sk_booleanValueForEntitlement:
_connection:isEntitledForPublishingWithStatusTypeIdentifier:
containsObject:
clientIsEntitledForAtLeastOnePublishingServiceType:
initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:
asynchronousRemoteDaemonDelegateWithErrorHandler:
synchronousRemoteDaemonDelegateWithErrorHandler:
clientIsEntitledForPublishingWithStatusTypeIdentifier:
setXpcConnection:
setConnectionLifecycleDelegate:
_xpcConnection
_connectionLifecycleDelegate
T@"NSXPCConnection",&,N,V_xpcConnection
T@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
Ti,R
removeAllObjects
objectAtIndex:
initWithCapacity:
numberWithUnsignedInt:
addParticipantPayload:
setUuid:
participantPayloadsCount
clearParticipantPayloads
participantPayloadAtIndex:
participantPayloadType
status
setStatus:
setHasStatus:
hasStatus
statusAsString:
StringAsStatus:
hasUuid
setServerTimestampSeconds:
setHasServerTimestampSeconds:
hasServerTimestampSeconds
setVersion:
setHasVersion:
hasVersion
setResponseMessageIndex:
setHasResponseMessageIndex:
hasResponseMessageIndex
setTotalResponseMessages:
setHasTotalResponseMessages:
hasTotalResponseMessages
uuid
serverTimestampSeconds
version
participantPayloads
setParticipantPayloads:
responseMessageIndex
totalResponseMessages
_serverTimestampSeconds
_version
_participantPayloads
_responseMessageIndex
_status
_totalResponseMessages
_uuid
Ti,N,V_status
T@"NSData",&,N,V_uuid
TQ,N,V_serverTimestampSeconds
TQ,N,V_version
T@"NSMutableArray",&,N,V_participantPayloads
TI,N,V_responseMessageIndex
TI,N,V_totalResponseMessages
clientIsRateLimited
ensurePendingPublishRequestExistsWithPublishRequest:forStatusTypeIdentifier:databaseContext:
_rateLimitDelayTime
publishPendingRequestsWithDelay:
_errorForRateLimit
_publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:retryCount:completion:
_removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:databaseContext:
internalWorkQueue
_shouldClientRateLimit
setClientIsRateLimited:
_shouldAllowPublishForPublishRequest:onChannel:error:
_markPublishAttempt
statusPayload
encryptionManager
isScheduledRequest
isSecondaryDeviceRepublish
userInfo
doubleValue
_shouldAbandonRequestForError:
_removePendingPublishRequestWithUniqueIdentifier:databaseContext:
_shouldRollChannelForError:
_shouldRetryWithDelayForError:
publishData:onChannel:withChannelToken:publishInitiateTime:isPendingPublish:isScheduledPublish:retryCount:completion:
findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
pendingRequestScheduled
existingPendingPublishRequestsWithDatabaseContext:
setPendingRequestScheduled:
timeIntervalSinceDate:
retryCount
_maxRetryCount
initWithStatusPayload:
setDateCreated:
setStatusUniqueIdentifier:
statusTypeIdentifier
incrementPendingPublishRequestRetryCountWithUniqueIdentifier:databaseContext:
_pendingDelayTime
existingStatusForChannel:databaseContext:
uniqueIdentifier
_errorForDuplicateStatusPublishRequestWithIdentifier:
compare:
_errorForStatusPublishRequestWithIdentifier:requestedStatusCreationDate:isOlderThanExistingStatus:existingStatusCreationDate:
_maxRapidPublishes
intValue
dateByAddingTimeInterval:
_rapidPublishesTimescale
numberWithInt:
existingPendingPublishRequestsForStatusTypeIdentifier:withDatabaseContext:
existingPendingPublishRequestForUniqueIdentifier:withDatabaseContext:
createPendingPublishRequestWithUniqueIdentifier:dateCreated:payloadData:statusTypeIdentifier:databaseContext:
createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
deletePendingPublishRequestWithWithUniqueIdentifier:databaseContext:
publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:completion:
removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:
publishPendingRequestForReason:
initWithDatabaseManager:channelManager:accountProvider:encryptionManager:invitationManager:
setEncryptionManager:
setInvitationManager:
setInternalWorkQueue:
_pendingRequestScheduled
_clientIsRateLimited
_encryptionManager
_internalWorkQueue
T@"<SKAStatusEncryptionManaging>",&,N,V_encryptionManager
T@"<SKAInvitationManaging>",&,N,V_invitationManager
T@"NSObject<OS_dispatch_queue>",&,N,V_internalWorkQueue
TB,V_pendingRequestScheduled
TB,V_clientIsRateLimited
initWithChannelToken:channelType:identifier:personal:decomissioned:currentOutgoingRatchetState:dateCreated:statusType:presenceIdentifier:invitedUsers:presenceServerKey:presencePeerKey:presenceMembershipKey:
isDecomissioned
currentOutgoingRatchetState
setDateChannelCreated:
channelType
_personal
_decomissioned
_channelToken
_identifier
_currentOutgoingRatchetState
_dateChannelCreated
_statusType
_channelType
_invitedUsers
_presenceServerKey
_presencePeerKey
_presenceMembershipKey
T@"NSData",R,N,V_channelToken
T@"NSString",R,C,N,V_identifier
personal
TB,R,N,GisPersonal,V_personal
decomissioned
TB,R,N,GisDecomissioned,V_decomissioned
T@"NSData",R,N,V_currentOutgoingRatchetState
T@"NSDate",&,N,V_dateChannelCreated
T@"NSString",R,C,N,V_statusType
Tq,R,N,V_channelType
T@"NSArray",R,C,N,V_invitedUsers
T@"NSData",R,N,V_presenceServerKey
T@"NSData",R,N,V_presencePeerKey
T@"NSData",R,N,V_presenceMembershipKey
initWithData:error:
T@"MPStatusKitOutgoingRatchet",R,N
_keysharingIsDisabledByServer
initWithService:
addDelegate:queue:
arrayWithObjects:count:
sendMessage:toHandles:fromHandle:limitToPresenceCapable:identifier:error:
idsDestination
_noValidIDSDetintationError
mutableCopy
sendMessage:toDestinations:priority:options:identifier:error:
_selfSharingIsDisabledByServer
service
devices
serviceIdentifier
sharedInstance
refreshIDStatusForDestination:service:listenerID:queue:completionBlock:
initWithUnprefixedURI:
URIs
isEqualToURI:
deviceForFromID:
originalGUID
toID
service:didReceiveIncomingMessage:fromID:toID:messageGuid:
fromID
service:outgoingMessageWithIdentifier:fromID:toID:didSendWithSuccess:
networkBecameReachable
unprefixedURI
initWithString:
deviceToken
pushToken
signData:withAlgorithm:completion:
initWithPrefixedURI:
verifySignedData:matchesExpectedData:withTokenURI:forAlgorithm:completion:
service:account:incomingOpportunisticData:withIdentifier:fromID:context:
service:didSendOpportunisticDataWithIdentifier:toIDs:
service:account:incomingMessage:fromID:context:
service:account:incomingData:fromID:context:
service:account:incomingUnhandledProtobuf:fromID:context:
service:account:incomingResourceAtURL:fromID:context:
service:account:incomingResourceAtURL:metadata:fromID:context:
service:account:incomingPendingMessageOfType:fromID:context:
service:activeAccountsChanged:
service:devicesChanged:
service:nearbyDevicesChanged:
service:connectedDevicesChanged:
service:linkedDevicesChanged:
service:account:identifier:didSendWithSuccess:error:
service:account:identifier:didSendWithSuccess:error:context:
service:account:identifier:sentBytes:totalBytes:
service:account:identifier:hasBeenDeliveredWithContext:
service:account:identifier:fromID:hasBeenDeliveredWithContext:
service:account:inviteReceivedForSession:fromID:
service:account:inviteReceivedForSession:fromID:withOptions:
service:account:inviteReceivedForSession:fromID:withContext:
service:account:receivedGroupSessionParticipantUpdate:
service:account:receivedGroupSessionParticipantUpdate:context:
service:account:receivedGroupSessionParticipantDataUpdate:
serviceSpaceDidBecomeAvailable:
serviceAllowedTrafficClassifiersDidReset:
service:didSwitchActivePairedDevice:acknowledgementBlock:
tokenURI
deviceTokenForTokenURI:
handleForTokenURI:
signPayload:completion:
verifySignedPayload:matchesPayload:fromTokenURI:completion:
T@"<SKAMessagingProvidingDelegate>",W,N
initWithDelegate:serviceIdentifier:pushManager:queue:
service:didHintCheckingTransportLogWithReason:
setService:
pushManager
setPushManager:
setServiceIdentifier:
_service
_pushManager
_serviceIdentifier
T@"IDSService",&,N,V_service
T@"<SKAPushManaging>",&,N,V_pushManager
T@"NSString",&,N,V_serviceIdentifier
T@"<SKAMessagingProvidingDelegate>",W,N,V_delegate
_generateKey
_generateKeyFromKeyData:
privateKey
initWithBytes:length:
appendData:
setPrivateKey:
initWithNewKeyMaterial
initWithPrivateKeyMaterial:
signPayload:
publicKeyMaterial
privateKeyMaterial
_privateKey
T^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v},N,V_privateKey
T@"NSData",R,N
publishingServiceClientWasInvalidated:
clientConnection
_missingEntitlmentErrorForStatusTypeIdentifier:
_accountNotCapableError
UUID
UUIDString
_dateCreatedDriftError
_delayForStatusPublishRequest:
publishingManager
accountIsStatusKitCapableWithCompletion:
_unableToResolveSenderHandleError
setAccountIsStatusKitCapable:
setAccountCheckCompleted:
queue
accountIsStatusKitCapable
deviceToDeviceEncryptedDatabaseCapableWithCompletion:
_serverBagNumberForKey:
_serverBagTimeIntervalForKey:withDefaultValue:
_scheduledPublishMaxDelayTime
_unscheduledPublishMaxDelayTime
_secondaryDeviceRepublishMaxDelayTime
_secondaryDeviceRepublishMinDelayTime
_randomSecondaryDeviceRepublishDelay
_randomScheduledPublishDelay
_randomUnscheduledPublishDelay
_noUsersToShareWithError
publishStatusRequest:statusTypeIdentifier:completion:
invitedHandlesForStatusTypeIdentifier:completion:
isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:
isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:
removeInvitedHandles:statusTypeIdentifier:completion:
removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:
registerForDelegateCallbacksWithStatusTypeIdentifier:completion:
initWithXPCConnection:queue:delegate:databaseManager:invitationManager:publishingManager:channelManager:
statusTypeIdenfifier
setClientConnection:
databaseProvider
setDatabaseProvider:
setPublishingManager:
accountCheckCompleted
setQueue:
_accountIsStatusKitCapable
_accountCheckCompleted
_statusTypeIdenfifier
_clientConnection
_databaseProvider
_publishingManager
_queue
T@"SKAStatusPublishingServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusPublishingServiceClientDelegate>",W,N,V_delegate
T@"<SKADatabaseProviding>",&,N,V_databaseProvider
T@"SKAInvitationManager",&,N,V_invitationManager
T@"<SKAStatusPublishingManaging>",&,N,V_publishingManager
TB,N,V_accountIsStatusKitCapable
TB,N,V_accountCheckCompleted
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
T@"NSString",R,C,N,V_statusTypeIdenfifier
channelMatchesClientStatusTypeIdentifier:
_subscriptionMetadataForChannel:
subscriptionStateChangedForSubscriptions:completion:
subscriptionReceivedStatusUpdate:completion:
subscriptionInvitationReceived:completion:
_currentStatusForChannel:
_handlesAssociatedWithChannel:
initWithSubscriptionIdentifier:statusTypeIdentifier:isPersonalStatusSubscription:currentStatus:ownerHandles:
isExpired
dateReceived
rawData
invitation
skInvitationPayload
initWithStatusPayload:statusUniqueIdentifier:datePublished:dateCreated:dateReceived:invitationPayload:
releaseAllTransientSubscriptionAssertionsAssociatedWithClient:completion:
subscriptionServiceClientWasInvalidated:
clientIsEntitledForSubscriptionWithStatusTypeIdentifier:
existingChannelForHandle:statusTypeIdentifier:databaseContext:
allExistingChannelsForStatusTypeIdentifier:includingPersonalChannel:databaseContext:
subscriptionManager
allSubscriptionIdentifiersWithActiveAssertionsForStatusTypeIdentifier:completion:
allStatusSubscriptionIdentifiersWithActiveSubscriptionsWithCompletion:
existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
_inTrafficError
_validateChannelIsKnownForSubscriptionIdentifier:statusTypeIdentifier:databaseContext:
_subscriptionIdentifierNotFoundError:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
initWithSubscriptionValidationToken:encryptionValidationToken:
subscriptionValidationToken
validatePersonalChannel:matchesSubscriptionValidationToken:fromSender:
encryptionValidationToken
validatePersonalChannel:matchesEncryptionValidationToken:fromSender:
hasPrefix:
_genericMissingSubscriptionEntitlmentError
subscriptionMetadataForHandle:statusTypeIdentifier:completion:
allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:
allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:
subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:
subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:
subscriptionServiceClientConnectionWasInvalidated:
subscriptionServiceClientConnectionWasInterrupted:
initWithXPCConnection:queue:delegate:databaseManager:subscriptionManager:encryptionManager:inTrafficMode:
handleRemoteDatabaseChangeForChannels:
handleReceivedStatusUpdate:onChannel:
handleReceivedInvitationForChannel:
setSubscriptionManager:
_subscriptionManager
T@"SKAStatusSubscriptionServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusSubscriptionServiceClientDelegate>",W,N,V_delegate
T@"<SKAStatusSubscriptionManaging>",&,N,V_subscriptionManager
weakToStrongObjectsMapTable
strongToStrongObjectsMapTable
_clientPayload:isValidWithError:
_addPresenceAssertionForClient:presenceIdentifier:isPersonal:payload:
_recalculateActivityTracking
_handleBulkUpdateParticipantPayloads:forChannel:
_sendPresenceAssertionMessageForChannel:withPayload:isRefresh:completion:
_findOrCreatePresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
_maxPayloadSizeBytes
_payloadOversizeError
initWithKeyMaterial:
_keyGenerationError
_rollChannelForCryptoFailureIfAllowed:
_payloadGenerationError
setLastAssertionSendTime:
_setCheckpointForChannel:checkpoint:
assertPresence:onChannel:membershipKey:serverKey:timestamp:withChannelToken:isRefresh:completion:
_presencePayloadForChannel:clientPayload:timestamp:completion:
pollActiveParticipantsForChannel:membershipKey:serverKey:withChannelToken:completion:
_clearPresentDevicesForChannel:
_presentDeviceFromPayload:onChannel:
_addPresentDeviceForChannel:presentDevice:
_presentDevicesChangedForChannel:
_removePresenceAssertionForClient:presenceIdentifier:
_sendPresenceDeactivationMessageForChannel:completion:
_noExistingAssertionError
_findPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
releasePresenceOnChannel:membershipKey:serverKey:timestamp:withChannelToken:completion:
activePresenceAssertionsByClient
_activePresentDevicesForChannel:
lastAssertionSendTime
_handleIncomingPayloadUpdate:onChannel:
_currentCheckpointForChannel:
prevVersion
currentVersion
activePresenceSubscriptionAssertionsExistForChannelIdentifier:
_sendPollingMessageForChannel:completion:
encryptedUpdatePayload
decryptPayload:
updateType
_removePresentDeviceForChannel:presentDevice:
_createPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
_activePresenceAssertionExistsForPresenceIdentifier:
isSelfDevice
_shouldReassert
_markReassert
_currentPayloadForPresenceIdentifier:
presenceManager:didReceivePresentDevicesUpdateForPresenceIdentifier:
currentCheckpointForChannel:databaseContext:
setCurrentCheckpointForChannel:checkpoint:databaseContext:
_activePresenceAssertionsForClient:
addIndex:
enumerateObjectsUsingBlock:
removeObjectsAtIndexes:
deviceIdentifier
initWithArray:
sortDescriptorWithKey:ascending:selector:
sortedArrayUsingDescriptors:
_activePresenceAssertionsExist
enableActivityTracking
disableActivityTracking
objectEnumerator
hasChanges
save:
_noExistingChannelError
keyMaterial
presenceManager:didCreateChannel:
createPresenceChannelWithMembershipKey:serverKey:completion:
data
setSignature:
encryptPayload:
serverUpdateTimestampSeconds
encryptedParticipantPayload
dateWithTimeIntervalSince1970:
_mostRecentAssertionTimeForTokenURI:onChannel:
_deviceIdentifierForToken:
initWithHandle:deviceIdentifier:payload:assertionTime:selfHandle:selfDevice:
assertionTime
ska_sha256Hash
cStringUsingEncoding:
initWithUUIDBytes:
_shouldCryptoRoll
_markCryptoRoll
presenceManager:didRequestToRollChannel:
_reassertResetTimeSeconds
_cryptoRollResetTimeSeconds
retainPresenceAssertionForPresenceIdentifier:isPersonal:withPresencePayload:client:completion:
releasePresenceAssertionForPresenceIdentifier:isPersonal:client:completion:
releaseAllPresenceAssertionsAssociatedWithClient:completion:
presentDevicesForPresenceIdentifier:isPersonal:completion:
channelReceivedIncomingPayloadUpdate:channel:
initWithDatabaseManager:channelManager:subscriptionManager:accountProvider:messagingProvider:delegate:
_sortAndDedupePresenceIdentifiers:
setActivePresenceAssertionsByClient:
activeParticipantsByChannel
setActiveParticipantsByChannel:
channelFetchQueue
setChannelFetchQueue:
_activePresenceAssertionsByClient
_activeParticipantsByChannel
_lastAssertionSendTime
_channelFetchQueue
T@"NSMapTable",&,N,V_activePresenceAssertionsByClient
T@"NSMapTable",&,N,V_activeParticipantsByChannel
T@"<SKAPresenceManagingDelegate>",W,N,V_delegate
T@"NSDate",&,N,V_lastAssertionSendTime
T@"NSObject<OS_dispatch_queue>",&,N,V_channelFetchQueue
existingStatusForUniqueIdentifier:databaseContext:
createStatusWithUniqueIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:channelIdentifier:databaseContext:
statusReceivingManager:didReceiveStatusUpdate:onChannel:
cleanupOldStatusUpdatesForChannelIdentifier:excludingStatusUniqueIdentifier:databaseContext:
handleIncomingStatusData:onChannelIdentifier:dateReceived:dateExpired:serverTime:
initWithDatabaseManager:encryptionManager:delegate:
T@"<SKAStatusReceivingManagingDelegate>",W,N,V_delegate
dateCreatedKeyPath
statusUniqueIdentifierKeyPath
predicateForStatusUniqueIdentifier:
sortDescriptorForDateCreatedAscending:
initWithCoreDataInvitedUser:
serverKey
peerKey
membershipKey
initWithCoreDataChannels:
dateExpired
initWithChannelIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:uniqueIdentifier:
initWithCoreDataStatus:
invitedHandle
senderHandle
dateInvitationPayloadCreated
initWithInvitedHandle:senderHande:invitationPayloadData:dateInvitationPayloadCreated:
invitationIdentifier
dateInvitationCreated
incomingRatchetState
initWithInvitationIdentifier:senderHandle:invitedHandle:statusTypeIdentifier:dateInvitationCreated:incomingRatchetState:presenceIdentifier:channelToken:serverKey:peerKey:invitationPayload:
initWithCoreDataReceivedInvitation:
initWithStatusTypeIdentifier:dateCreated:payloadData:statusUniqueIdentifier:retryCount:
initWithCoreDataPendingPublishRequest:
originalOutgoingRatchetState
dateGenerated
initWithOriginalOutgoingRatchetState:dateGenerated:
initWithCoreDataGeneratedEncryptionKey:
applicationIdentifier
initWithChannelIdentifier:statusTypeIdentifier:applicationIdentifier:
initWithCoreDataSubscriptionAssertion:
lastSubscriptionDate
initWithChannelIdentifier:lastSubscriptionDate:
initWithCoreDataTransientSubscriptionHistory:
removedHandle
dateRemoved
initWithHandle:statusTypeIdentifier:presenceIdentifier:dateRemoved:
initWithCoreDataRemovedUser:
_getStatusJWTToken
_jwtTokenNotFoundError
setSimpleJwt:
hasRetryIntervalSeconds
retryIntervalSeconds
channelIdentity
channelId
createChannelWithProtoData:completion:
_getPresenceJWTToken
setChannelPublicKey:
setServerEncryptionKey:
_getNonce
setNonce:
setSignNonce:
setSharedOwnershipAuth:
setChannelToken:
initWithBase64EncodedString:options:
setChannelId:
setPublishInitiateTimestampMillis:
setPendingPublishHint:
setScheduledPublishHint:
setRetryCount:
setChannelIdentity:
setPublishPayloadExpiryTtlMillis:
_createPayloadDataFromData:
setPublishPayload:
setPushPriority:
setChannelPublishPayload:
_serverResponseError
publishStatus:completion:
setRequestFlag:
getUUIDBytes:
dataWithBytes:length:
setClientTimestampSeconds:
setEncryptedParticipantPayload:
setActivationRequest:
setRequest:
activationResponse
activationExpirySeconds
sendPresenceMessage:completion:
setDeactivationRequest:
deactivationResponse
setPollingRequest:
pollingResponse
subscribedStatusChannelsWithCompletion:
subscribeToStatusChannels:
unsubscribeFromStatusChannels:
subscribedPresenceChannelsWithCompletion:
subscribeToPresenceChannels:
unsubscribeFromPresenceChannels:
dataWithJSONObject:options:error:
presenceJwtTokenForPrimaryAccountWithError:
statusJwtTokenForPrimaryAccountWithError:
channelManager:didReceiveData:onChannel:dateReceived:dateExpired:
channelManager:failedToSubscribeToChannel:withError:
pushManager:didReceiveData:onChannel:dateReceived:dateExpired:
pushManager:failedToSubscribeToChannel:withError:
activeStatusChannelSubscriptionsWithCompletion:
activePresenceChannelSubscriptionsWithCompletion:
initWithPushManager:accountProvider:delegate:
T@"<SKAChannelManagingDelegate>",W,N,V_delegate
setRetryIntervalSeconds:
setHasRetryIntervalSeconds:
_retryIntervalSeconds
TI,N,V_retryIntervalSeconds
invitationType
_invitationType
_senderHandle
_invitedHandle
_statusTypeIdentifier
_peerKey
_serverKey
_invitationIdentifier
_dateInvitationCreated
_incomingRatchetState
_invitationPayload
Tq,R,N,V_invitationType
T@"NSString",R,N,V_senderHandle
T@"NSString",R,N,V_invitedHandle
T@"NSString",R,N,V_statusTypeIdentifier
T@"NSString",R,N,V_presenceIdentifier
T@"NSData",R,N,V_peerKey
T@"NSData",R,N,V_serverKey
T@"NSString",R,N,V_invitationIdentifier
T@"NSDate",R,N,V_dateInvitationCreated
T@"NSData",R,N,V_incomingRatchetState
T@"NSData",R,N,V_invitationPayload
T@"SKHandle",R,N
T@"MPStatusKitIncomingRatchet",R,N
initWithData:dateCreated:
T@"SKInvitationPayload",R,N
_lastSubscriptionDate
T@"NSString",R,N,V_channelIdentifier
T@"NSDate",R,N,V_lastSubscriptionDate
objectForKeyedSubscript:
ska_dictionaryForKey:
_initializeNewKeyMaterial
_randomBytesWithLength:error:
keyData
dataWithLength:
bytes
mutableBytes
subdataWithRange:
_newZeroingDataWithBytes:length:
setKeyData:
_keyData
T@"NSData",&,N,V_keyData
_jwtTokenForPrimaryAccountForIdentifier:withError:
_primarySystemiCloudAccountWithError:
aida_tokenWithExpiryCheckForService:
_shouldAttemptReauth
_markReauthAttempt
setAuthenticationType:
setIsUsernameEditable:
setServiceType:
aida_alternateDSID
setAltDSID:
authenticateWithContext:completion:
aida_accountForPrimaryiCloudAccount
_maxReauthCount
_authResetTime
tokenFetchQueue
setTokenFetchQueue:
_tokenFetchQueue
T@"NSObject<OS_dispatch_queue>",&,N,V_tokenFetchQueue
hasEncryptedParticipantPayload
setServerUpdateTimestampSeconds:
setHasServerUpdateTimestampSeconds:
hasServerUpdateTimestampSeconds
_serverUpdateTimestampSeconds
_encryptedParticipantPayload
T@"NSData",&,N,V_encryptedParticipantPayload
TQ,N,V_serverUpdateTimestampSeconds
hasChannelId
hasChannelToken
_channelId
T@"NSData",&,N,V_channelId
T@"NSData",&,N,V_channelToken
addListener:
_initializeAPSConnection
_pushEnvironment
initWithEnvironmentName:namedDelegatePort:queue:
initWithAPSConnection:mobileNetworkManager:
isUnderFirstDataProtectionLock
_setNonWakingTopics:
setTrackActivityPresence:
_sharedChannelsIsDisabledByServer
initWithProtoData:messageType:
protoResponse
setCompletionBlock:
setTimeout:
messageDelivery
sendMessage:
_switchFilterToNonwakingForTopic:
_switchFilterToEnabledForTopic:
nonWakingTopics
enabledTopics
removeObject:
setEnabledTopics:ignoredTopics:opportunisticTopics:nonWakingTopics:
trackActivityPresence
publicToken
initWithPushTopic:protoData:
_subscribeToChannels:forTopic:
_unsubscribeFromChannels:forTopic:
_subscribedChannelsForTopic:WithCompletion:
initWithChannelID:
connection
subscribeToChannels:forTopic:
unsubscribeFromChannels:forTopic:
channelID
getRegisteredChannelsForTopic:withCompletion:
isConnected
dateWithTimeIntervalSinceReferenceDate:
expirationDate
failureReason
connection:didReceivePublicToken:
connection:didReceiveToken:forTopic:identifier:
connection:didReceiveToken:forInfo:
connection:didReceiveURLToken:forInfo:
connection:didReceiveURLTokenError:forInfo:
connection:didReceiveIncomingMessage:
connection:didReceiveMessageForTopic:userInfo:
connection:didSendOutgoingMessage:
connection:didFailToSendOutgoingMessage:error:
connection:didChangeConnectedStatus:
connectionDidReconnect:
connection:channelSubscriptionsFailedWithFailures:
systemDidLeaveFirstDataProtectionLock
switchStatusFilterToNonwaking
switchStatusFilterToEnabled
switchPresenceFilterToNonwaking
switchPresenceFilterToEnabled
T@"<SKAPushManagingDelegate>",W,N
initWithQueue:systemMonitor:inTrafficMode:
systemMonitor
setSystemMonitor:
setConnection:
setMessageDelivery:
_systemMonitor
_connection
_messageDelivery
T@"SKASystemMonitor",&,N,V_systemMonitor
T@"APSConnection",&,N,V_connection
T@"FTMessageDelivery",&,N,V_messageDelivery
T@"<SKAPushManagingDelegate>",W,N,V_delegate
_dateCreated
_datePublished
_dateReceived
_dateExpired
_rawData
_uniqueIdentifier
T@"NSString",R,C,N,V_channelIdentifier
T@"NSDate",R,C,N,V_dateCreated
T@"NSDate",R,C,N,V_datePublished
T@"NSDate",R,C,N,V_dateReceived
T@"NSDate",R,C,N,V_dateExpired
T@"NSData",R,N,V_rawData
T@"NSString",R,C,N,V_uniqueIdentifier
hasChannelIdentity
_channelIdentity
T@"ChannelIdentity",&,N,V_channelIdentity
setHasClientTimestampSeconds:
hasClientTimestampSeconds
clientTimestampSeconds
_clientTimestampSeconds
TQ,N,V_clientTimestampSeconds
_addTransientSubscriptionAssertionForClient:subscriptionIdentifier:
_markCacheSubscriptionDateForChannelIdentifier:
updateRegisteredSubscriptionsForActiveAssertionsWithCompletion:
_removeTransientSubscriptionAssertionForClient:subscriptionIdentifier:
activeTransientSubscriptionsByClient
existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
createSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:statusTypeIdentifier:databaseContext:
deleteSubscriptionAssertionWithSubscriptionIdentifier:applicationIdentifier:databaseContext:
_fetchAllClientActiveSubscriptionAssertions
activePresenceSubscriptionsByClient
_removePresenceSubscriptionAssertionForClient:subscriptionIdentifier:
_fetchAllActivePresenceSubscriptions
_maxPresenceSubscriptionCacheCount
_tooManySubscriptionsError
_addPresenceSubscriptionAssertionForClient:subscriptionIdentifier:
_activeTransientSubscriptionsForClient:
_activePresenceSubscriptionsForClient:
createOrUpdateTransientSubscriptionHistoryForChannelIdentifier:lastSubscriptionDate:databaseContext:
_fetchAllActiveSubscriptionAssertionsWithCache
arrayByAddingObjectsFromArray:
_sortAndDedupeSubscriptionIdentifiers:
_enforceSubscriptionsHardCapOnSubscriptionIdentifiers:
differenceFromArray:
removals
object
_filterSubscriptionIdentifierToStatus:
_filterSubscriptionIdentifierToPresence:
insertions
_activeTransientAssertionsExist
_hardMaxSubscriptionCount
subarrayWithRange:
allPersistentSubscriptionAssertionChannelIdentifiersWithDatabaseContext:
_allPersonalChannelIdentifiersRequiringSelfSubscriptionWithDatabaseContext:
_maxSubscriptionCacheCount
_recentlyReleasedTransientSubscriptionAssertionIdentifiersExcludingSubscriptionIdentifiers:count:presenceCount:databaseContext:
_subscriptionTTL
existingRecentTransientSubscriptionHistoriesWithLimit:databaseContext:
allObjects
_statusTypeIdentifiersRequiringSelfSubscription
retainPresenceSubscriptionAssertionForSubscriptionIdentifier:client:completion:
releasePresenceSubscriptionAssertionForSubscriptionIdentifier:client:completion:
releaseAllPresenceSubscriptionAssertionsAssociatedWithClient:completion:
initWithDatabaseManager:channelManager:pushManager:
setActiveTransientSubscriptionsByClient:
setActivePresenceSubscriptionsByClient:
_activeTransientSubscriptionsByClient
_activePresenceSubscriptionsByClient
T@"NSMapTable",&,N,V_activeTransientSubscriptionsByClient
T@"NSMapTable",&,N,V_activePresenceSubscriptionsByClient
isEqualToTransientSubscription:
clearOneofValuesForAuthCredentialOneof
hasSimpleJwt
hasSharedOwnershipAuth
authCredentialOneof
setAuthCredentialOneof:
setHasAuthCredentialOneof:
hasAuthCredentialOneof
authCredentialOneofAsString:
StringAsAuthCredentialOneof:
simpleJwt
sharedOwnershipAuth
_authCredentialOneof
_sharedOwnershipAuth
_simpleJwt
T@"NSString",&,N,V_simpleJwt
T@"SharedOwnershipAuth",&,N,V_sharedOwnershipAuth
Ti,N,V_authCredentialOneof
hasChannelPublishPayload
channelPublishPayload
_channelPublishPayload
T@"ChannelPublishPayload",&,N,V_channelPublishPayload
setHasPublishInitiateTimestampMillis:
hasPublishInitiateTimestampMillis
hasPublishPayload
setHasPublishPayloadExpiryTtlMillis:
hasPublishPayloadExpiryTtlMillis
pushPriority
setHasPushPriority:
hasPushPriority
pushPriorityAsString:
StringAsPushPriority:
setHasPendingPublishHint:
hasPendingPublishHint
setHasScheduledPublishHint:
hasScheduledPublishHint
setHasRetryCount:
hasRetryCount
publishInitiateTimestampMillis
publishPayload
publishPayloadExpiryTtlMillis
pendingPublishHint
scheduledPublishHint
_publishInitiateTimestampMillis
_publishPayloadExpiryTtlMillis
_publishPayload
_pushPriority
_retryCount
_pendingPublishHint
_scheduledPublishHint
TQ,N,V_publishInitiateTimestampMillis
T@"NSData",&,N,V_publishPayload
TQ,N,V_publishPayloadExpiryTtlMillis
Ti,N,V_pushPriority
TB,N,V_pendingPublishHint
TB,N,V_scheduledPublishHint
TI,N,V_retryCount
initWithDelegate:
initWithDatabaseProvider:delegate:
_inTextTrafficMode
initWithMachServiceName:
_setupMaintenanceActivity
serviceName
_publishingServiceListener:shouldAcceptNewConnection:
_subscriptionServiceListener:shouldAcceptNewConnection:
_presenceServiceListener:shouldAcceptNewConnection:
sk_stringValueForEntitlement:
initWithXPCConnection:queue:delegate:subscriptionManager:presenceManager:invitationManager:databaseManager:
clientIsEntitledForAtLeastOneSubscriptionServiceType:
subscriptionServiceConnectedClients
publishingServiceConnectedClients
presenceConnectedClients
_notifyPresenceClientsIfNeededOfChannelChangeForChannel:
_kettleFeatureEnabled
donateReceivedStatusToBiomeOnChannel:
_shouldDonateToBiomeForStatusTypeIdentifier:
_senderHandlesForChannel:
userStatusChangeStream
initWithIDSHandles:statusChangeType:
source
sendEvent:
standardUserDefaults
handleReceivedPresentDevicesUpdateForPresenceIdentifier:
handleReceivedInvitationForPresenceIdentifier:
refreshAssertionsForPresenceIdentifier:
initWithStatusPayload:isScheduledRequest:
objectForKey:inDomain:
cleanupDecommisionedChannelsWithDatabaseContext:
listener:shouldAcceptNewConnection:
databaseDidReceiveRemoteChangesForChannels:
databaseManager:didCreateChannel:
presenceClientWasInvalidated:
shutdown
logState
publishingServiceListener
setPublishingServiceListener:
publishingServiceConnectionQueue
setPublishingServiceConnectionQueue:
setPublishingServiceConnectedClients:
subscriptionServiceListener
setSubscriptionServiceListener:
subscriptionServiceConnectionQueue
setSubscriptionServiceConnectionQueue:
setSubscriptionServiceConnectedClients:
presenceListener
setPresenceListener:
presenceConnectionQueue
setPresenceConnectionQueue:
setPresenceConnectedClients:
invitationManagerMessagingQueue
setInvitationManagerMessagingQueue:
invitationMessagingProvider
setInvitationMessagingProvider:
statusReceivingManager
setStatusReceivingManager:
_publishingServiceListener
_publishingServiceConnectionQueue
_publishingServiceConnectedClients
_subscriptionServiceListener
_subscriptionServiceConnectionQueue
_subscriptionServiceConnectedClients
_presenceListener
_presenceConnectionQueue
_presenceConnectedClients
_invitationManagerMessagingQueue
_invitationMessagingProvider
_statusReceivingManager
T@"NSXPCListener",&,N,V_publishingServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_publishingServiceConnectionQueue
T@"NSMutableArray",&,N,V_publishingServiceConnectedClients
T@"NSXPCListener",&,N,V_subscriptionServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_subscriptionServiceConnectionQueue
T@"NSMutableArray",&,N,V_subscriptionServiceConnectedClients
T@"NSXPCListener",&,N,V_presenceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_presenceConnectionQueue
T@"NSMutableArray",&,N,V_presenceConnectedClients
T@"NSObject<OS_dispatch_queue>",&,N,V_invitationManagerMessagingQueue
T@"<SKAMessagingProviding>",&,N,V_invitationMessagingProvider
T@"<SKAStatusReceivingManaging>",&,N,V_statusReceivingManager
handle
_handle
_dateRemoved
T@"NSString",R,N,V_handle
T@"NSDate",R,N,V_dateRemoved
createPersistentContainer
containerName
bundleForClass:
mergedModelFromBundles:
initWithName:managedObjectModel:
localPersistentStoreDescription
cloudPersistentStoreDescription
setPersistentStoreDescriptions:
loadPersistentStoresWithCompletionHandler:
defaultCenter
handlePersistentStoreRemoteChangeNotification:
addObserver:selector:name:object:
createCkContainer
ckContainerIdentifier
initWithContainerIdentifier:environment:
initWithContainerID:
defaultManager
URLForDirectory:inDomain:appropriateForURL:create:error:
URLByAppendingPathComponent:isDirectory:
fileManager
path
fileExistsAtPath:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
databaseDirectoryURL
localDatabaseFileURL
persistentStoreDescriptionWithURL:
setType:
setConfiguration:
setShouldAddStoreAsynchronously:
setOption:forKey:
cloudDatabaseFileURL
initWithContainerIdentifier:
setUseDeviceToDeviceEncryption:
setApsConnectionMachServiceName:
setCloudKitContainerOptions:
processPersistentStoreRemoteChanges
persistentContainer
fetchRequest
appTransactionAuthorName
predicateWithFormat:argumentArray:
setPredicate:
lastProcessedPersistentHistoryToken
fetchHistoryAfterToken:
setFetchRequest:
executeRequest:error:
result
changes
changedObjectID
entity
name
extractModifiedChannelFromPersistentStoreRemoteChangeForChannel:managedObjectContext:
extractModifiedChannelFromPersistentStoreRemoteChangeForReceivedInvitation:managedObjectContext:
lastObject
token
setLastProcessedPersistentHistoryToken:
performBlockAndWait:
changeType
existingManagedObjectWithID:managedObjectContext:
channel
existingObjectWithID:error:
lastProcessedPersistentHistoryTokenFileURL
dataWithContentsOfURL:
unarchivedObjectOfClass:fromData:error:
archivedDataWithRootObject:requiringSecureCoding:error:
writeToURL:atomically:
overrideDeviceEncryptionCheck
ckContainer
supportsDeviceToDeviceEncryption
accountInfoWithCompletionHandler:
databaseHasBeenCreated
historyProcessingQueue
setHistoryProcessingQueue:
setPersistentContainer:
setCkContainer:
_historyProcessingQueue
_persistentContainer
_ckContainer
T@"NSObject<OS_dispatch_queue>",&,N,V_historyProcessingQueue
T@"NSPersistentContainer",&,N,V_persistentContainer
T@"CKContainer",&,N,V_ckContainer
T@"<SKADatabaseProvidingDelegate>",W,N,V_delegate
_originalOutgoingRatchetState
_dateGenerated
T@"NSData",R,N,V_originalOutgoingRatchetState
T@"NSDate",R,N,V_dateGenerated
outgoingRatchet
dateInvitationCreatedKeyPath
senderHandleKeyPath
predicateForSenderHandleString:
predicateForSenderHandle:
sortDescriptorForDateInvitationCreatedOrderedAscending:
sortDescriptorForSenderHandleOrderedAscending:
dateGeneratedKeyPath
ska_appearsToBeEmail
_connection:isEntitledForSubscriptionWithStatusTypeIdentifier:
clientIsEntitledForAtLeastOneSubscriptionServiceType
T@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
setEncryptedUpdatePayload:
setCurrentVersion:
setHasCurrentVersion:
hasCurrentVersion
setPrevVersion:
setHasPrevVersion:
hasPrevVersion
hasEncryptedUpdatePayload
_currentVersion
_prevVersion
_encryptedUpdatePayload
TQ,N,V_currentVersion
TQ,N,V_prevVersion
T@"NSData",&,N,V_encryptedUpdatePayload
hasPayload
hasSignature
_signature
T@"DecryptedParticipantPayload",&,N,V_payload
T@"NSData",&,N,V_signature
setPadding:
setUpdateType:
setHasUpdateType:
hasUpdateType
updateTypeAsString:
StringAsUpdateType:
hasPadding
padding
_padding
_updateType
Ti,N,V_updateType
T@"NSData",&,N,V_padding
applicationIdentifierKeyPath
predicateForApplicationIdentifier:
requestFlag
setHasRequestFlag:
hasRequestFlag
requestFlagAsString:
StringAsRequestFlag:
_requestFlag
Ti,N,V_requestFlag
_statusPayload
_invitation
T@"SKStatusPayload",R,N,V_statusPayload
T@"SKADatabaseReceivedInvitation",R,N,V_invitation
invitationPayloadData
_invitationPayloadData
_dateInvitationPayloadCreated
T@"NSData",R,N,V_invitationPayloadData
T@"NSDate",R,N,V_dateInvitationPayloadCreated
_existingPersonalChannelForStatusTypeIdentifier:databaseContext:
andPredicateWithSubpredicates:
setSortDescriptors:
setFetchLimit:
executeFetchRequest:error:
deleteObject:
_existingChannelsForChannelIdentifier:databaseContext:
_existingChannelsForPresenceIdentifier:isPersonal:databaseContext:
_existingChannelsForChannelIdentifier:isPersonal:databaseContext:
_existingChannelsForDatabaseChannel:databaseContext:
_existingReceivedInvitationsForHandle:statusTypeIdentifier:databaseContext:
refreshObject:mergeChanges:
allValues
initWithContext:
setStatusType:
setChannelType:
setDecomissioned:
setPersonal:
setIdentifier:
setPeerKey:
setServerKey:
setMembershipKey:
_existingPersonalChannelForDatabaseChannel:databaseContext:
setCurrentOutgoingRatchetState:
_existingPersonalChannelsForStatusTypeIdentifier:databaseContext:
setOriginalOutgoingRatchetState:
setDateGenerated:
addGeneratedEncryptionKeysObject:
generatedEncryptionKeys
_existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
_existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
setApplicationIdentifier:
setStatusTypeIdentifier:
_existingTransientSubscriptionHistoryForChannelIdentifier:databaseContext:
setLastSubscriptionDate:
_existingTransientSubscriptionHistoryWithLimit:orderedByLastSubscriptionDateAscending:databaseContext:
setInvitedHandle:
setInvitationPayload:
setDateInvitationPayloadCreated:
setSenderHandle:
addInvitedUsersObject:
_existingInvitedUsersForDatabaseInvitedUser:databaseChannel:databaseContext:
_existingInvitedUsersForInvitedHandle:channel:databaseContext:
predicateForInvitedHandle:
predicateForChannel:
setUniqueIdentifier:
setDatePublished:
setDateReceived:
setRawData:
setDateExpired:
_existingChannelCheckpointForChannelIdentifier:databaseContext:
checkpoint
setCheckpoint:
setChannelID:
setPayloadData:
_existingPendingPublishRequestForUniqueIdentifier:databaseContext:
_existingPendingPublishRequestsForStatusTypeIdentifier:databaseContext:
_existingPendingPublishRequestsWithDatabaseContext:
setDateRemoved:
setRemovedHandle:
_existingRemovedUsersForHandle:statusTypeIdentifier:databaseContext:
_existingRemovedUsersForHandle:presenceIdentifier:databaseContext:
setInvitationIdentifier:
setDateInvitationCreated:
setIncomingRatchetState:
addReceivedInvitationsObject:
receivedInvitations
_existingReceivedInvitationsForChannelIdentifier:sortedByDateReceived:databaseContect:
_existingDecomissionedPersonalChannelsWithDatabaseContext:
deletePersonalChannelForStatusTypeIdentifier:databaseContext:
decomissionAllPersonalChannelsWithStatusTypeIdentifier:databaseContext:
T@"<SKADatabaseProviding>",R,N,V_databaseProvider
T@"<SKADatabaseManagingDelegate>",R,W,N,V_delegate
datePublishedKeyPath
uniqueIdentifierKeyPath
sortDescriptorForDatePublishedAscending:
valueForEntitlement:
_applicationIdentifier
T@"NSString",R,N,V_applicationIdentifier
appendFormat:
clientPrefixedPresenceIdentifierForPresenceIdentifier:
_noClientIDError
setActiveAssertion:
setCurrentPayload:
accountIsPresenceCapableWithCompletion:
_crossAccountError
_noChannelError
setActiveSubscription:
_noChannelCreatedError
setActiveSubscriptionIdentifier:
clientID
_shortHashOfClientID:
initWithFormat:
componentsSeparatedByString:
setAccountIsPresenceCapable:
accountIsPresenceCapable
presenceIdentifierMatchesClient:
oversizeLogger
setWithArray:
isEqualToSet:
rawPresenceIdentifierForPrefixedPresenceIdentifier:
presentHandlesChangedForPresenceIdentifier:completion:
invitedHandlesChangedForPresenceIdentifier:completion:
activeSubscription
activeSubscriptionIdentifier
presenceIdenfifier
activeAssertion
currentPayload
invitedHandlesForPresenceIdentifier:completion:
presentDevicesForPresenceIdentifier:completion:
isHandleInvited:fromSenderHandle:forPresenceIdentifier:completion:
inviteHandles:fromSenderHandle:presenceIdentifier:completion:
removeInvitedHandles:presenceIdentifier:completion:
retainTransientSubscriptionAssertionForPresenceIdentifier:completion:
releaseTransientSubscriptionAssertionForPresenceIdentifier:completion:
assertPresenceForIdentifier:withPresencePayload:completion:
releasePresenceForIdentifier:completion:
fetchPresenceCapability:
registerForDelegateCallbacksWithPresenceIdentifier:isPersonal:completion:
presenceClientConnectionWasInvalidated:
presenceClientConnectionWasInterrupted:
lastSeenPresentDevices
setLastSeenPresentDevices:
_accountIsPresenceCapable
_activeSubscription
_activeAssertion
_presenceIdenfifier
_activeSubscriptionIdentifier
_lastSeenPresentDevices
_currentPayload
T@"SKAPresenceClientConnection",&,N,V_clientConnection
T@"<SKAPresenceClientDelegate>",W,N,V_delegate
TB,N,V_accountIsPresenceCapable
TB,N,V_activeSubscription
T@"NSString",&,N,V_activeSubscriptionIdentifier
TB,N,V_activeAssertion
T@"NSSet",&,N,V_lastSeenPresentDevices
T@"SKPresencePayload",&,N,V_currentPayload
T@"NSString",R,C,N,V_presenceIdenfifier
_payloadData
_statusUniqueIdentifier
T@"NSString",R,C,N,V_statusTypeIdentifier
T@"NSData",R,N,V_payloadData
T@"NSString",R,C,N,V_statusUniqueIdentifier
Tq,R,N,V_retryCount
containsString:
UTF8String
stringWithCapacity:
clearOneofValuesForResponse
setActivationResponse:
setDeactivationResponse:
setPollingResponse:
hasActivationResponse
hasDeactivationResponse
hasPollingResponse
response
setResponse:
setHasResponse:
hasResponse
responseAsString:
StringAsResponse:
_activationResponse
_deactivationResponse
_pollingResponse
_response
T@"ChannelActivityActivationResponse",&,N,V_activationResponse
T@"ChannelActivityDeactivationResponse",&,N,V_deactivationResponse
T@"ChannelActivityPollingResponse",&,N,V_pollingResponse
Ti,N,V_response
hasChannelPublicKey
hasNonce
hasSignNonce
hasServerEncryptionKey
channelPublicKey
nonce
signNonce
serverEncryptionKey
_channelPublicKey
_nonce
_serverEncryptionKey
_signNonce
T@"NSData",&,N,V_channelPublicKey
T@"NSData",&,N,V_nonce
T@"NSData",&,N,V_signNonce
T@"NSData",&,N,V_serverEncryptionKey
_clientIDForConnection:
T@"<SKAPresenceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
T@"NSString",R
setActivationExpirySeconds:
setHasActivationExpirySeconds:
hasActivationExpirySeconds
_activationExpirySeconds
TI,N,V_activationExpirySeconds
invitedHandleKeyPath
channelKeyPath
initWithOptions:capacity:
_updateLockState
_listenForKeyBagChangeNotifications
_deviceStillUnderFirstLock
_deliverNotificationSelectorToListeners:
performSelectorOnMainThread:withObject:waitUntilDone:
removeListener:
ivarLock
setIvarLock:
underFirstLock
setUnderFirstLock:
listeners
setListeners:
_underFirstLock
_ivarLock
_listeners
T{os_unfair_lock_s=I},N,V_ivarLock
TB,N,V_underFirstLock
T@"NSHashTable",&,N,V_listeners
clearOneofValuesForRequest
hasActivationRequest
hasDeactivationRequest
hasPollingRequest
request
setHasRequest:
hasRequest
requestAsString:
StringAsRequest:
activationRequest
deactivationRequest
pollingRequest
_activationRequest
_deactivationRequest
_pollingRequest
_request
T@"ChannelActivityActivationRequest",&,N,V_activationRequest
T@"ChannelActivityDeactivationRequest",&,N,V_deactivationRequest
T@"ChannelActivityPollingRequest",&,N,V_pollingRequest
Ti,N,V_request
fetchRequestWithEntityName:
T@"NSData",&,D,N
Ts,D,N
T@"NSDate",C,D,N
TB,D,N
T@"NSString",C,D,N
T@"NSSet",&,D,N
Tq,D,N
T@"Channel",&,D,N
Ti,D,N
@16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@56@0:8@16@24@32@40@48
@24@0:8@16
@32@0:8@16@24
@"NSData"56@0:8@"SKStatusPayload"16@"NSString"24@"NSDate"32@"NSDate"40@"SKADatabaseChannel"48
@"SKAStatusUnencryptedEnvelope"24@0:8@"NSData"16
@"SKADecryptedStatusPayload"32@0:8@"NSData"16@"SKADatabaseChannel"24
@"NSString"24@0:8@"SKADatabaseChannel"16
@44@0:8@16S24@28@36
@44@0:8@16@24S32@36
v16@0:8
@"<SKADatabaseManaging>"
@"<SKAInvitationManaging>"
v24@0:8@16
@"NSDictionary"
@40@0:8@16@24@32
@"SKHandle"
@"NSString"
v56@0:8@16@24@32@40@?48
v48@0:8@16@24@32@?40
v36@0:8@16B24@?28
v40@0:8@16@24@?32
v32@0:8@16@?24
v56@0:8@16@24@32@40@48
v44@0:8@16@24@32B40
B32@0:8@16^@24
v56@0:8@"NSString"16@"NSArray"24@"SKHandle"32@"SKInvitationPayload"40@?<v@?B@"NSError">48
v48@0:8@"NSString"16@"NSArray"24@"SKHandle"32@?<v@?B@"NSError">40
v36@0:8@"NSString"16B24@?<v@?B@"NSError">28
v40@0:8@"NSString"16@"NSArray"24@?<v@?@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSError">24
v56@0:8@"NSDictionary"16@"SKHandle"24@"NSString"32@"SKHandle"40@"NSString"48
v44@0:8@"NSString"16@"SKHandle"24@"SKHandle"32B40
B32@0:8@"NSString"16^@24
v32@0:8@"NSString"16@?<v@?B>24
v36@0:8@"NSString"16B24@?<v@?B>28
v40@0:8@"SKHandle"16@"SKHandle"24@?<v@?B@"NSError">32
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?@"SKHandleInvitability"@"NSError">40
@"SKHandle"24@0:8@"SKHandle"16
@"<SKAInvitationManagingDelegate>"16@0:8
v24@0:8@"<SKAInvitationManagingDelegate>"16
@60@0:8@16@24@32@40@48B56
B40@0:8@16@24^@32
B48@0:8@16@24@32^@40
@48@0:8@16@24^B32^@40
@48@0:8@16@24@32@40
v20@0:8B16
@"<SKAInvitationManagingDelegate>"
@"<SKAMessagingProviding>"
@"<SKAChannelManaging>"
@"<SKAAccountProviding>"
@"<SKAPresenceManaging>"
@"NSObject<OS_dispatch_queue>"
@"NSMutableDictionary"
@20@0:8B16
@36@0:8@16B24@28
@"SKPresencePayload"
@"NSObject<OS_os_activity>"
@24@0:8^{_NSZone=}16
i16@0:8
v20@0:8i16
@20@0:8i16
i24@0:8@16
@"AuthCredential"
{?="channelOwnershipType"b1}
v24@0:8Q16
@"NSData"
{?="timestamp"b1}
B32@0:8@16@24
@24@0:8@?16
@"NSXPCConnection"
@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>"
@24@0:8Q16
v20@0:8I16
I16@0:8
@"NSMutableArray"
{?="serverTimestampSeconds"b1"version"b1"responseMessageIndex"b1"status"b1"totalResponseMessages"b1}
v52@0:8@16@24d32B40@?44
v32@0:8@16@24
v24@0:8q16
v52@0:8@"SKStatusPublishRequest"16@"NSString"24d32B40@?<v@?@"NSString"@"NSError">44
v32@0:8@"NSString"16@"SKStatusPublishRequest"24
v60@0:8@16@24d32B40Q44@?52
v24@0:8d16
v40@0:8@16@24@32
d16@0:8
q16@0:8
@"<SKAStatusEncryptionManaging>"
@112@0:8@16q24@32B40B44@48@56@64@72@80@88@96@104
@"NSDate"
@"NSArray"
v64@0:8@16@24@32@40@48@56
v56@0:8@16@24q32@40@48
v52@0:8@16@24@32B40@44
v60@0:8@16@24@32B40@44@52
v56@0:8@16@24@32q40q48
v48@0:8@16@24@32@40
v64@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"NSString"48@"IDSMessageContext"56
v40@0:8@"IDSService"16@"NSString"24@"NSArray"32
v56@0:8@"IDSService"16@"IDSAccount"24@"NSDictionary"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSProtobuf"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSString"40@"IDSMessageContext"48
v64@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSDictionary"40@"NSString"48@"IDSMessageContext"56
v56@0:8@"IDSService"16@"IDSAccount"24q32@"NSString"40@"IDSMessageContext"48
v32@0:8@"IDSService"16@"NSSet"24
v32@0:8@"IDSService"16@"NSArray"24
v52@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44
v60@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44@"IDSMessageContext"52
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32q40q48
v48@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@40
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@"NSString"40@48
v48@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSDictionary"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSData"48
v40@0:8@"IDSService"16@"IDSAccount"24@"IDSGroupSessionParticipantUpdate"32
v48@0:8@"IDSService"16@"IDSAccount"24@"IDSGroupSessionParticipantUpdate"32@"IDSMessageContext"40
v24@0:8@"IDSService"16
v40@0:8@"IDSService"16@"IDSDevice"24@?<v@?>32
B60@0:8@16@24@32B40^@44^@52
B44@0:8@16B24^@28^@36
B60@0:8@"NSDictionary"16@"SKHandle"24@"SKHandle"32B40^@44^@52
B60@0:8@"NSDictionary"16@"NSArray"24@"SKHandle"32B40^@44^@52
B44@0:8@"NSDictionary"16B24^@28^@36
@"NSData"16@0:8
@"NSData"24@0:8@"NSString"16
@"SKHandle"24@0:8@"NSString"16
v32@0:8@"SKHandle"16@?<v@?B>24
B24@0:8@"SKHandle"16
B24@0:8@"NSString"16
v32@0:8@"NSData"16@?<v@?@"NSError"@"NSData">24
v48@0:8@"NSData"16@"NSData"24@"NSString"32@?<v@?@"NSError"B>40
@"<SKAMessagingProvidingDelegate>"16@0:8
v24@0:8@"<SKAMessagingProvidingDelegate>"16
v32@0:8@16q24
@"<SKAMessagingProvidingDelegate>"
@"IDSService"
@"<SKAPushManaging>"
^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v}16@0:8
v24@0:8^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v}16
^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v}
v40@0:8@"SKStatusPublishRequest"16@"NSString"24@?<v@?@"NSString"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSArray"@"NSError">24
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?B@"NSError">40
v56@0:8@"NSArray"16@"SKHandle"24@"SKInvitationPayload"32@"NSString"40@?<v@?@"NSError">48
v40@0:8@"NSArray"16@"NSString"24@?<v@?@"NSError">32
v24@0:8@"SKAStatusPublishingServiceClientConnection"16
@72@0:8@16@24@32@40@48@56@64
v24@0:8@?16
d32@0:8@16d24
d24@0:8@16
@"SKAStatusPublishingServiceClientConnection"
@"<SKAStatusPublishingServiceClientDelegate>"
@"<SKADatabaseProviding>"
@"SKAInvitationManager"
@"<SKAStatusPublishingManaging>"
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSArray"@"NSError">28
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSArray"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">24
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError">32
v48@0:8@"NSString"16@"NSString"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKSubscriptionValidationTokens"@"NSError">32
v48@0:8@"SKSubscriptionValidationTokens"16@"SKHandle"24@"NSString"32@?<v@?q@"NSError">40
v24@0:8@"SKAStatusSubscriptionServiceClientConnection"16
@68@0:8@16@24@32@40@48@56B64
q40@0:8@16@24@32
B40@0:8@16@24@32
@"SKAStatusSubscriptionServiceClientConnection"
@"<SKAStatusSubscriptionServiceClientDelegate>"
@"<SKAStatusSubscriptionManaging>"
v52@0:8@16B24@28@36@?44
v44@0:8@16B24@28@?36
v52@0:8@"NSString"16B24@"SKPresencePayload"28@"<SKAClientConnectionRepresentable>"36@?<v@?@"NSError">44
v44@0:8@"NSString"16B24@"<SKAClientConnectionRepresentable>"28@?<v@?@"NSError">36
v32@0:8@"<SKAClientConnectionRepresentable>"16@?<v@?@"NSError">24
v32@0:8@"NSData"16@"SKADatabaseChannel"24
v44@0:8@"NSString"16B24@"NSManagedObjectContext"28@?<v@?@"SKADatabaseChannel"@"NSError">36
@64@0:8@16@24@32@40@48@56
v44@0:8@16@24B32@?36
Q24@0:8@16
v32@0:8@16Q24
B44@0:8@16@24B32@36
@"NSMapTable"
@"<SKAPresenceManagingDelegate>"
v56@0:8@"NSData"16@"NSString"24@"NSDate"32@"NSDate"40@"NSDate"48
@"<SKAStatusReceivingManagingDelegate>"
v56@0:8@"<SKAPushManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAPushManaging>"16@"NSString"24@"NSError"32
v72@0:8@16@24@32@40B48B52Q56@?64
v76@0:8@16@24@32@40@48@56B64@?68
v64@0:8@16@24@32@40@48@?56
v24@0:8@?<v@?@"NSString"@"NSData"@"NSError">16
v40@0:8@"SKAPresenceMembershipKey"16@"SKAPresenceEncryptionKey"24@?<v@?@"NSString"@"NSData"@"NSError">32
v72@0:8@"NSData"16@"NSString"24@"NSData"32@"NSDate"40B48B52Q56@?<v@?@"NSError">64
v76@0:8@"NSData"16@"NSString"24@"SKAPresenceMembershipKey"32@"SKAPresenceEncryptionKey"40@"NSDate"48@"NSData"56B64@?<v@?@"NSError"dQ@"NSArray">68
v64@0:8@"NSString"16@"SKAPresenceMembershipKey"24@"SKAPresenceEncryptionKey"32@"NSDate"40@"NSData"48@?<v@?@"NSError">56
v56@0:8@"NSString"16@"SKAPresenceMembershipKey"24@"SKAPresenceEncryptionKey"32@"NSData"40@?<v@?@"NSError"Q@"NSArray">48
v24@0:8@?<v@?@"NSArray">16
v24@0:8@"NSArray"16
@"NSDate"16@0:8
@"<SKAChannelManagingDelegate>"
{?="retryIntervalSeconds"b1"status"b1}
@104@0:8@16@24@32@40@48@56@64@72@80@88@96
@32@0:8Q16^@24
@24@0:8^@16
@"NSString"24@0:8^@16
v24@0:8@?<v@?B@"NSError">16
@32@0:8@16^@24
{?="serverUpdateTimestampSeconds"b1}
v28@0:8@16B24
v32@0:8@"APSConnection"16@"NSData"24
v48@0:8@"APSConnection"16@"NSData"24@"NSString"32@"NSString"40
v40@0:8@"APSConnection"16@"NSData"24@"APSAppTokenInfo"32
v40@0:8@"APSConnection"16@"APSURLToken"24@"APSURLTokenInfo"32
v40@0:8@"APSConnection"16@"NSError"24@"APSURLTokenInfo"32
v32@0:8@"APSConnection"16@"APSIncomingMessage"24
v40@0:8@"APSConnection"16@"NSString"24@"NSDictionary"32
v32@0:8@"APSConnection"16@"APSOutgoingMessage"24
v40@0:8@"APSConnection"16@"APSOutgoingMessage"24@"NSError"32
v28@0:8@"APSConnection"16B24
v24@0:8@"APSConnection"16
v32@0:8@"APSConnection"16@"NSArray"24
v32@0:8@"NSData"16@?<v@?@"NSData"@"NSError">24
@"<SKAPushManagingDelegate>"16@0:8
v24@0:8@"<SKAPushManagingDelegate>"16
@36@0:8@16@24B32
@"<SKAPushManagingDelegate>"
@"SKASystemMonitor"
@"APSConnection"
@"FTMessageDelivery"
@"ChannelIdentity"
{?="clientTimestampSeconds"b1}
v48@0:8@"NSString"16@"NSString"24@"<SKAClientConnectionRepresentable>"32@?<v@?@"NSError">40
v40@0:8@"NSString"16@"<SKAClientConnectionRepresentable>"24@?<v@?@"NSError">32
v24@0:8@?<v@?@"NSError">16
v32@0:8@"NSString"16@?<v@?@"NSArray">24
@48@0:8@16q24q32@40
@"SharedOwnershipAuth"
{?="authCredentialOneof"b1}
@"ChannelPublishPayload"
{?="publishInitiateTimestampMillis"b1"publishPayloadExpiryTtlMillis"b1"pushPriority"b1"retryCount"b1"pendingPublishHint"b1"scheduledPublishHint"b1}
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
v52@0:8@16@24@32@40B48
v56@0:8@"NSString"16@"NSDictionary"24@"NSString"32@"NSString"40@"NSString"48
v52@0:8@"NSString"16@"NSString"24@"NSString"32@"NSString"40B48
v56@0:8@"<SKAChannelManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAChannelManaging>"16@"NSString"24@"NSError"32
v40@0:8@"<SKAStatusReceivingManaging>"16@"SKADatabaseStatus"24@"SKADatabaseChannel"32
v32@0:8@"<SKADatabaseManaging>"16@"SKADatabaseChannel"24
v40@0:8@"<SKAInvitationManaging>"16@"SKADatabaseReceivedInvitation"24@"SKADatabaseChannel"32
v32@0:8@"<SKAInvitationManaging>"16@"SKADatabaseChannel"24
v24@0:8@"SKAStatusPublishingServiceClient"16
v24@0:8@"SKAStatusSubscriptionServiceClient"16
v24@0:8@"SKAPresenceClient"16
v32@0:8@"<SKAPresenceManaging>"16@"NSString"24
v32@0:8@"<SKAPresenceManaging>"16@"SKADatabaseChannel"24
@"NSXPCListener"
@"<SKAStatusReceivingManaging>"
@"NSManagedObjectContext"16@0:8
v24@0:8@?<v@?B>16
@"<SKADatabaseProvidingDelegate>"
@"NSPersistentContainer"
@"CKContainer"
@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>"
{?="currentVersion"b1"prevVersion"b1}
@"DecryptedParticipantPayload"
{?="updateType"b1}
{?="clientTimestampSeconds"b1"requestFlag"b1}
@"SKStatusPayload"
@"SKADatabaseReceivedInvitation"
@84@0:8@16@24@32@40@48@56@64B72@76
@32@0:8q16@24
@80@0:8@16@24@32@40@48@56@64@72
Q32@0:8@16@24
B40@0:8@16Q24@32
@112@0:8@16@24@32@40@48@56@64@72@80@88@96@104
@"SKADatabaseChannel"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"36@0:8@"NSString"16B24@"NSManagedObjectContext"28
@"SKADatabaseChannel"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"36@0:8@"NSString"16B24@"NSManagedObjectContext"28
@"SKADatabaseChannel"48@0:8@"NSString"16@"NSString"24@"NSData"32@"NSManagedObjectContext"40
@"SKADatabaseChannel"84@0:8@"NSString"16@"NSString"24@"NSData"32@"NSData"40@"NSData"48@"NSData"56@"NSDate"64B72@"NSManagedObjectContext"76
B32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseChannel"40@0:8@"SKADatabaseChannel"16@"NSData"24@"NSManagedObjectContext"32
@"SKAGeneratedEncryptionKey"40@0:8@"NSData"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"NSArray"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"NSArray"24@0:8@"NSManagedObjectContext"16
@"NSArray"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"48@0:8@"NSString"16@"NSString"24@"NSString"32@"NSManagedObjectContext"40
B40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSDate"24@"NSManagedObjectContext"32
@"NSArray"32@0:8q16@"NSManagedObjectContext"24
@"NSArray"40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"SKADatabaseInvitedUser"48@0:8@"SKInvitationPayload"16@"SKADatabaseInvitedUser"24@"SKADatabaseChannel"32@"NSManagedObjectContext"40
@"SKADatabaseInvitedUser"56@0:8@"SKHandle"16@"SKHandle"24@"SKInvitationPayload"32@"SKADatabaseChannel"40@"NSManagedObjectContext"48
B40@0:8@"SKADatabaseChannel"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"80@0:8@"NSString"16@"NSDate"24@"NSDate"32@"NSDate"40@"NSDate"48@"NSData"56@"NSString"64@"NSManagedObjectContext"72
@"SKADatabaseStatus"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"32@0:8@"NSString"16@"NSManagedObjectContext"24
v40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabasePendingPublishRequest"56@0:8@"NSString"16@"NSDate"24@"NSData"32@"NSString"40@"NSManagedObjectContext"48
@"SKADatabasePendingPublishRequest"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"NSArray"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseRemovedUser"48@0:8@"SKHandle"16@"NSDate"24@"NSString"32@"NSManagedObjectContext"40
@"SKADatabaseRemovedUser"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
Q32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
B40@0:8@"SKADatabaseChannel"16Q24@"NSManagedObjectContext"32
@"SKADatabaseReceivedInvitation"112@0:8@"SKADatabaseChannel"16@"SKHandle"24@"SKHandle"32@"NSString"40@"NSDate"48@"NSData"56@"NSString"64@"NSData"72@"NSData"80@"NSData"88@"NSData"96@"NSManagedObjectContext"104
v40@0:8@"NSString"16@"SKADatabaseReceivedInvitation"24@"NSManagedObjectContext"32
v24@0:8@"NSManagedObjectContext"16
v40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@36@0:8q16B24@28
@"<SKADatabaseManagingDelegate>"
{?="requestFlag"b1}
v48@0:8@"NSArray"16@"SKHandle"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"NSString"16@"SKPresencePayload"24@?<v@?@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSError">28
v24@0:8@"SKAPresenceClientConnection"16
@"SKAPresenceClientConnection"
@"<SKAPresenceClientDelegate>"
@"NSSet"
{?="serverTimestampSeconds"b1"status"b1}
@56@0:8@16@24@32@40q48
@"ChannelActivityActivationResponse"
@"ChannelActivityDeactivationResponse"
@"ChannelActivityPollingResponse"
{?="response"b1}
@"<SKAPresenceClientConnectionLifecycleDelegate>"
{?="serverTimestampSeconds"b1"version"b1"activationExpirySeconds"b1"responseMessageIndex"b1"status"b1"totalResponseMessages"b1}
v24@0:8:16
{os_unfair_lock_s=I}16@0:8
v20@0:8{os_unfair_lock_s=I}16
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"NSHashTable"
@"ChannelActivityActivationRequest"
@"ChannelActivityDeactivationRequest"
@"ChannelActivityPollingRequest"
{?="request"b1}
@(#)PROGRAM:StatusKitAgentCore  PROJECT:StatusKit-1
'0On
F58;>AD
F58;>AD
)GQp
2QWv
)1Po
v8@?0
com.apple.StatusKit
SKAStatusEncryptionManager
channelID
%K == %@
com.apple.StatusKit.InvitationManager.cleanup
v24@?0@"SKADatabaseChannel"8@"NSError"16
v12@?0B8
com.apple.availability
com.apple.statuskit.cleanup
v20@?0B8@"NSError"12
v32@?0@"NSString"8@"NSData"16@"NSError"24
Sender handle is invalid, or could not determine a valid default sender handle.
Invited handles are invalid
Could not find or create a channel to send invitation for status of type "%@".
Could not find or create a channel to send invitation for presence "%@".
Key roll failed
Could not uninvite handle(s) "%@" because we could not find an existing invitation for those handle(s)
Could not any existing invitations to delete
Presence has been disabled by the server
SKAInvitationManager
activity-presence-enabled
lastSubscriptionDate
channelIdentifier
<%@: %p; presenceIdentifier = %@
SKAPresenceAssertion
dateRemoved
removedHandle
statusTypeIdentifier
presenceIdentifier
%@ %@
channel_topic
auth_credential
channel_ownership_type
SELF_USER_OWNERSHIP
SHARED_OWNERSHIP
(unknown: %i)
<%@: %p; subscriptionIdentifier = %@
SKAPresenceSubscriptionAssertion
identifier
personal
decomissioned
statusType
encryptionKeys
dateChannelCreated
channelType
%K != nil
token_uri
presence_identifier
channel_identifier
timestamp
client_payload
v16@?0@"NSError"8
com.apple.StatusKit.publish.types
com.apple.StatusKit.publish.allTypes
<%@ PID=%ld>
SKAStatusPublishingServiceClientConnection
status
uuid
server_timestamp_seconds
version
participant_payload
response_message_index
total_response_messages
SUCCESS
AUTH_EXPIRED
AUTH_FAILED
BAD_REQUEST
CHANNEL_IDENTITY_VALIDATION_FAILED
INTERNAL_ERROR
STALE_PUBLISH_REJECTED
RATE_LIMITED
com.apple.StatusKitAgent
lastPublishTime
rapidPublishCount
com.apple.StatusKitAgent.PublishingManager
com.apple.statuskit.pendingPublish
v24@?0@"NSString"8@"NSError"16
shared-channels-stale-publish-wait-time-seconds
shared-channels-rate-limit-wait-time-seconds
shared-channels-request-retry-count
shared-channels-client-rate-limit-max-rapid-publishes
shared-channels-client-rate-limit-rapid-publish-time-seconds
SKAStatusPublishingManager
Could not find or create a channel to publish status of type "%@".
Status Publish Request %@ created at %@ is not newer than existing status %@ at %@
Status Publish Request has the same status unique identifier as existing status: %@
Status Publish Request has been rate-limtited
<%@: %p; identifier = "%@"; personal = %ld, decomissioned = %ld, statusType = "%@"; dateCreated = "%@">;
SKADatabaseChannel
IDSRegistrationPropertySupportsSharedExperiencePresence
%@_%p
v16@?0q8
v24@?0@"NSData"8@"NSError"16
No valid IDS destinations could be determined
status-kit-keysharing-disabled
status-kit-selfsharing-disabled
SKAMessagingProvider
SKAPresenceMembershipKey
Client is not entitled to publish status of type "%@". Missing entitlement "%@"
Could not determine any users to share with from request
System iCloud account does not exist or is not statuskit capable
Could not determine sender handle to use
dateCreated of StatusPayload differs too much from server time
SKAStatusPublishingServiceClient
v24@?0@"SKHandleInvitability"8@"NSError"16
shared-channels-scheduled-publish-variance-max-slop-period-seconds
shared-channels-unscheduled-publish-variance-max-slop-period-seconds
shared-channels-secondary-device-republish-variance-min-slop-period-seconds
Client is not entitled to subscription information for status of type "%@". Missing entitlement "%@"
com.apple.StatusKit.subscribe.types
Client is not entitled to subscription information for status. Missing entitlement "%@"
Traffic mode is enable and status access is unavailable
Subscription not found matching subscription identifier: "%@"
SKAStatusSubscriptionServiceClient
v16@?0@"NSArray"8
lastReassertTime
lastCryptoRollTime
com.apple.StatusKitAgent.PresenceManager
com.apple.StatusKitAgent.ChannelFetchQueue
v32@?0@"NSError"8d16@"NSArray"24
v40@?0@"NSError"8d16Q24@"NSArray"32
v16@?0@"NSData"8
v32@?0@"NSError"8Q16@"NSArray"24
v24@?0@"NSError"8@"NSArray"16
v32@?0@"SKAPresenceAssertion"8Q16^B24
v32@?0@"SKPresentDevice"8Q16^B24
v24@?0@"NSError"8@"NSData"16
v20@?0@"NSError"8B16
No existing assertion exists
No channel exists for presence identifier
Failed to generate cryptographic keys for channel
Failed to generate payload for presence message
Payload is too large
shared-channels-reassert-reset-time-seconds
shared-channels-crypto-roll-reset-time-seconds
shared-channels-max-presence-payload-size-bytes
SKAPresenceManager
com.apple.StatusKit.StatusReceivingManager.cleanup
SKAStatusReceivingManager
dateCreated
statusUniqueIdentifier
SKAChannelManagerErrorDomain
SKAChannelManagerErrorRetryIntervalKey
StatusKitDataKey
com.apple.icloud.presence.shared.experience
com.apple.icloud.presence.mode.status
Generic non-success response status
SKAChannelManager
Could not fetch JWT token for authenticating request
Error in server response
retry_interval_seconds
<%@: %p; identifier = "%@"; dateCreated = "%@"; invitationPayload: "%@">
SKADatabaseReceivedInvitation
SKAPresenceEncryptionKey
com.apple.gs.sharedchannels.auth
com.apple.gs.sharedexperiences.auth
lastReauthTime
reauthCount
SKAAccountProviderErrorDomain
Reauth has hit rate limit
v24@?0@"NSDictionary"8@"NSError"16
shared-channels-reauth-max-count
shared-channels-reauth-backoff-time-seconds
SKAAccountProvider
encrypted_participant_payload
server_update_timestamp_seconds
channel_id
channel_token
com.apple.icloud.presence.channel.management
com.apple.aps.StatusKit
SKPushManagerErrorDomain
IMMobileNetworkManager
useSandbox
v40@?0@"IDSBaseMessage"8@"NSError"16q24@"NSDictionary"32
v24@?0@"NSArray"8@"NSError"16
shared-channels-disabled
SKAPushManager
<%@: %p; uniqueIdentifier = "%@"; channelIdentifier = "%@"; dateCreated = "%@"; dateExpired = "%@">;
SKADatabaseStatus
channel_identity
client_timestamp_seconds
lastFaultTime
com.apple.StatusKitAgent.SubscriptionManager
v32@?0@"SKATransientSubscriptionAssertion"8Q16^B24
v32@?0@"SKAPresenceSubscriptionAssertion"8Q16^B24
com.apple.focus.status
There are too many presence subscriptions
shared-channels-subscription-cache-size
activity-presence-max-subscription-size
shared-channels-max-subscription-size
shared-channels-subscription-ttl-minutes
SKAStatusSubscriptionManager
SKATransientSubscriptionAssertion
simple_jwt
shared_ownership_auth
auth_credential_oneof
PBUNSET
channel_publish_payload
publish_initiate_timestamp_millis
publish_payload
publish_payload_expiry_ttl_millis
push_priority
pending_publish_hint
scheduled_publish_hint
retry_count
NORMAL
HIGH
LDMGlobalEnabled
com.apple.private.alloy.status.keysharing
com.apple.StatusKit.publish
com.apple.StatusKit.subscribe
com.apple.StatusKit.presence
SKAStatusServer
com.apple.StatusKit.presence.clientID
BiomeDonationEnabled
Kettle
FeatureComplete
com.apple.statuskit.maintenance
v16@?0@"NSObject<OS_xpc_object>"8
com.apple.StatusKitAgent.CoreData.historyProcessing
v24@?0@"NSPersistentStoreDescription"8@"NSError"16
StatusKitAgent
SKADatabaseModel
com.apple.statuskit
StatusKit
database
statuskit-local-v1.db
statuskit-cloud.db
lastProcessedPersistentHistoryToken.data
Local
com.apple.aps.StatusKit.CloudKitMirroring
Cloud
author != %@
v24@?0@"CKAccountInfo"8@"NSError"16
skipHSA2
SKADatabaseProvider
SKAGeneratedEncryptionKey
dateInvitationCreated
senderHandle
dateGenerated
com.apple.StatusKit.subscribe.allTypes
SKAStatusSubscriptionServiceClientConnection
current_version
prev_version
encrypted_update_payload
payload
signature
update_type
padding
PARTICIPANT_ADDED
PARTICIPANT_REMOVED
applicationIdentifier
request_flag
NEW_REQUEST
REFRESH_REQUEST
UPDATE_MISSED
<%@: %p; statusPayload = "%@"; invitation = "%@">;
v32@?0@"ReceivedInvitation"8Q16^B24
v32@?0@"Channel"8Q16^B24
SKADatabaseManager
datePublished
uniqueIdentifier
%02lx
System iCloud account does not exist or is not presence capable
No channel exists or could be created for presence identifier
Missing client ID entitlement
This action isn't available when isPersonal is True
SKAPresenceClient
StatusKit-oversized
%@-%@-%@
%02x
activation_response
deactivation_response
polling_response
response
channel_public_key
nonce
sign_nonce
server_encryption_key
SKAPresenceClientConnection
activation_expiry_seconds
invitedHandle
channel
SKASystemMonitor
activation_request
deactivation_request
polling_request
request
Channel
ChannelCheckpoint
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
Channel does not have a current outgoing ratchet, rolling encryption key to generate a new one.
Encryption key rolled successfully, fetching new key
Key roll failed, unable to encrypt status
Error encrypting status: %@
Message encrypted successfully
Unable to encrypt status due to nil outgoing encryption key
Attempting to decrypt incoming status on personal channel using keys from %ld outgoing ratchets.
Status payload successfully decrypteded from generatedKey: %@
Status payload not decrypteded from generatedKey: %@
Status payload failed to decrypt with all known generated encryption keys.
Attempting to decrypt incoming status on non personal channel using incoming ratchet state from %ld received invitations.
Status payload successfully decrypteded from invitation: %@
Status payload not decrypted from invitation: %@
Status payload failed to decrypt with all known invitations.
Decrypteded payload: %@
Status payload failed to decrypt with error: %@
Status payload decypted to nil data
Status payload successfully decrypted
Extracting status payload, but envelope dictionary is not deserializable. Returning nil payload.
Extracting status payload, but encrypted payload is missing, is this an empty status update, or a malformed status: %@
Failed to extract status payload, signature is missing: %@
Failed to extract status payload, ratchet index is missing: %@
Failed to extract status payload, ratchet index is an invalid number: %@
Successfully decrypted status payload
Failed to decrypt status payload
Finding most recent incoming ratchet for personal channel from %ld outgoing ratchets.
Finding most recent incoming ratchet for non personal channel using incoming ratchet state from %ld received invitations.
Unable to find most recent incoming ratchet for channel: %@
Error serializing status envelope dictionary: %@
Error deserializing status envelope data as dictionary: %@
In Traffic Mode--will drop incoming status invitations
Request to invite handles contains no valid handles to invite. InvitedHandles: %@
Error resolving sender handle. UnresolvedSenderHandle: %@
Error fetching or creating personal channel: %@
Could not find or create personal channel
Adding invited handles %@ to database for channel: %@
Inivtation was not sent for handles %@ due to key roll error: %@
Invitations for newly invited handles %@ was already sent during key roll, skipping individual message send.
Invitation failed with error: %@
Presence has been disabled by the server.
Error fetching or creating presence channel: %@
Could not find or create presence channel
Could not find channel for presence identifier %@
Presence invitation sent successfully to self-account devices. ID:%@
Self presence invitation send failed with error: %@ message: %@, ID:%@.  Maybe no other device on account?
Could not find existing personal channel to revoke all invitations for
Finished deleting all invited user database records for channel %@, initiating key roll
Unable to find any invitations to revoke, taking no action, returning error
Could not find existing personal channel to revoke invitations for
Successfully deleted database record for invited user: %@.  Adding to removed users
Unable to find database record for invited user attempted to delete: %@
Finished deleting database records for uninvited users, initiating key roll
Finished rolling presence channel
Error rolling presence channel
Received request to roll encryption key for personal channel with statusTypeIdentifier: %@
Not rolling encryption key because a personal channel does not exist for statusTypeIdentifier: %@
Error encounted during key roll for statusTypeIdentifier: %@ error: %@
Received callback for message with identifier: %@ did send with success: %d
Invitation message failed to send! Removing record of invitation.
Could not find channel matching channel ID
Could not find channel ID matching message ID.
Received request to roll personal channel with statusTypeIdentifier: %@
Channel creation failed! Aborting channel roll.
Failed to copy invited users! Aborting channel roll.
Succesfully rolled personal channel with statusTypeIdentifier: %@
Asked to roll personal channel for %@, but no channel exists
Received request to roll presence channel with presence identifier: %@
Succesfully rolled presence channel with presenceIdentifier: %@
Asked to roll presence channel for %@, but no channel exists
Generating new outgoing ratchet
Storing newly generated outgoing ratchet
Messaging %ld existing invited users with the newly generated subscription keys
Outgoing IDS messages for encryption key roll failed to send: %@
Not sending any invitations following key roll as there are no invited users for channel %@
Failing to send invitation to zero invited users
Error generating incoming ratchet: %@
Error serializing incoming ratchet
Database InvitedUser does not have an invited SKHandle: %@
Sending invitation message with new encryption key ratchet index %ld to handle "%@" with invitation payload %@
Invitation sent successfully. ID: %@
Invitation send failed with error: %@ message: %@ ID: %@
Sending presence invitation message to handle "%@"
Presence invitation sent successfully. ID:%@
Presence invitation send failed with error: %@ message: %@, ID:%@
Invited handle failed validation, ignoring: %@
Validated invited handle set does not match unvalidated handles. Unvalidated set may have contained duplicate or invalid handles. Validated: %@ Unvalidated: %@
Incoming invitation from handle: %@
Invitation message missing channel identifier, dropping invitation: %@
Invitation message missing date invitation created, dropping invitation: %@
Invitation message has both status and presence, dropping invitation: %@
Treating invite as a status invite
We're in traffic mode--dropping incoming invitation
Invitation message uses legacy status type identifier, dropping invitation: %@
Invitation message missing incoming ratchet state, dropping invitation: %@
No existing channel matches incoming invitation, creating new channel
Treating invite as a presence invite
Invitation message missing channel token, dropping invitation: %@
Invitation message missing peer key data, dropping invitation: %@
Invitation message missing server key data, dropping invitation: %@
Invitation message is for a personal presence channel but does not come from a device on our account: %@
Invitation message missing membership key data, dropping invitation: %@
Invitation message missing date channel created. Using current server time
Could not find or create channel for incoming invitation, dropping invitation.
Invitation missing presence and status identifiers, dropping invitation: %@
Storing received invitation
Cleaning up ReceivedInvitations from handle: %@
Removing old channels for handle: %@
fromHandle "%@" is NOT a valid sender handle for active iCloud account
fromHandle "%@" is a valid sender handle for active iCloud account
toHandle "%@" inviteability check completed with result: %d
Handle is invalid, and not inviteable: %@
handle "%@" is present as a removed user
Channel has no existing encryption key data, initiating key roll to generate first key
Generating first encryption key for personal channel failed: %@
Found existing encryption keys, attempting to ratchet forward from current ratchet index: %ld
Rolling encryption key for personal channel failed: %@
Ratchet forward succeeded. New ratchet index: %ld. Persisting this state.
Error fetching or update invited user for handle: %@
Removing handle %@ from removed users because of invite
Invited handle has a nil handle string: %@
Found %ld existing invited user for invitedHandle %@ (ignoring sender handle).
Existing invited user was invited from the same handle: %@. Updating payload, and not creating a new InvitedUser record.
Existing invited user was invited from %@, but we are attempting to invite from %@. Will update this users payload, but may still need to create a new InvitedUser record
Updating invitation payload on invitedUser: %@
Received a nil updated user from call to updateInvitationPayload
Invitation payload is already up to date
Could not find an existing invited user matching handle: %@ and senderHandle %@, attempting to create a new one.
Received a nil created user from createInvitedUserWithHandle
Could not find an existing personal status channel, attempting to create a new one.
Account refresh required for error: %@
Account refresh succeeded, reattempting channel creation
Account refresh failed with error: %@
Error is an auth expired error, we should attempt reauth
Error is an auth failed error, we should attempt reauth
Error is an auth missing auth token error, we should attempt reauth
Error does not appear to be auth related, we should not attempt reauth
Server bag indicates presence enablement with status: %ld
Creating PresenceAssertion for identifier "%@"
PresenceAssertion
Deallocing PresenceAssertion for channel "%@", releasing os_activity
Creating PresenceSubscriptionAssertion for channel "%@"
PresenceSubscriptionAssertion
Deallocing PresenceSubscriptionAssertion for channel "%@", releasing os_activity
XPC connection to PID %ld interrupted
XPC connection to PID %ld invalidated
XPC Error (async): %{public}@
XPC Error (synchronous): %{public}@
Deallocing {pointer: %p}
Client is not entitled for any status types
Client is not entitled to publish status of type %{public}@
Client is currently rate-limited.  Enqueing requests as pending publish.
Publishing status unique identifier: %@ to channel: %@
Error publishing status with the channel manager: %@
Attempting reauth to resolve error
Account refresh succeeded, publishing pending publish requests
Removing pending publish based on error
Rolling channel.
Channel was rolled succesfully.
Channel roll failed.
Not rolling channel because this is a secondary device publish.
Attempting retry with delay.
Retrying after %f sec delay
Retry interval is 0--not retrying
Successfully published status %@ to channel %@
Dropping and removing status publish request with unique identifier %@. Error: %@
Could not find or create a personal channel for statusTypeIdentifier %@ error: %@
Pending publish request has already been scheduled.  Not enqueing again
Will attempt to process %ld pending publish requests after a %.2f second delay
Skipping publish of pending request that lacks an status identifier
Deleting pending status with ID %@ as it has expired
Deleting pending status with ID %@ as it has passed the max retry count of %lu
Attempting to publish pending request with ID: %@
Publish of pending status request with ID:%@ finished with error:%@
No pending publish requests
Publish requested for reason: %lu
Dropping status publish request, a status with unique identifier %@ has already been published. PublishRequest: %@
Dropping status publish request, existing status %@ was created at %@, publish request %@ from %@ is not newer.
In window for rate limit backoff.  We'll be free again at %@
We've left the rate-limit backoff window.
Incrementing rapid publish counter.
Deleting pending publish request with ID: %@ because it is older than newly received publish request with ID %@
Creating new pending status publish request for status unique identifier: %@
Pending status publish request already exists for status unique identifier: %@
StatusTypeIdentifier %@ corresponds to personal channel %@
Could not find an existing personal status channel for statusTypeIdentifier %@, attempting to create a new one.
Channel creation request failed with error: %@
Channel creation request succeeded, new personal channel for statusTypeIdentifier %@ has channel identifier %@
Deleting pending status publish request with identifier: %@
Delete failed for pending status publish request with identifier: %@
Publish was rejected for being stale. Abandoning.
Publish was rejected for being malformed. Abandoning.
Channel identity validation failed. We should roll this channel.
Publish was rejected because we've hit a rate limit.
Server bag indicates our pending publish request delay time should be %.2f
Server bag indicates our rate limit delay time should be %.2f
Server bag indicates our max retry count should be %lu
Server bag indicates our max rapid publishes should be %lu
Server bag indicates our rapid publish timescale should be %lu
Failed to create currentOutgoingRatchet due to invalid data. Error: %@
Initializing messaging provider with service %@ and delegate %@
Keysharing has been disabled by the server! Not initializing messaging service
Keysharing has been disabled by the server! Not sending message
Failed to generate IDS destination for handle: %@
No valid IDS destinations generated from handles: %@
Sending message %@ to destinations %@ options: %@
Successfully sent invitation message, assigned message identifier: %@
Failed to send invitation message with error: %@
Self sharing has been disabled by the server! Not sending message
No destinations for self devices
Sender handle "%@" is a valid sender handle for active iCloud account
Sender handle "%@" is not a valid sender handle for active iCloud account
Received incoming message: %@ fromID: %@
Keysharing has been disabled by the server! Dropping incoming message
Message: %@ did send with success: %d
Received didHintCheckingTransportLogWithReason
Resolved default caller ID: %@
Unable to determine default caller ID among URIs: %@
Signature verification returned with result: %d
Keysharing has been disabled in the server bag!
Self sharing has been disabled in the server bag!
Private key material nil or incorrect length
Signing completed with error: %@
Public key externalization completed with error: %@
Private key externalization completed with error: %@
Membership key generation completed with error: %@
Membership key generation from data completed with error: %@
Publishing service client connection was interrupted: %@
Publishing service client connection was invalidated: %@
Received request to publish status: %@
Rejecting publish request, client is not entitled
Account is not StatusKit capable
dateCreated not set on statusPublishRequest:%@. Setting to serverTime: %@
dateCreated time differs too much from server time.  delta = %f
Personal channel does not exist for status type identifier
Attempting to determine if handle %@ has already been invited from handle: %@
Error resolving sender handle for isInvited check. UnresolvedSenderHandle: %@
We found a match to an existing invited user
We found an existing invitated user matching the requested user, but that invitation was sent with handle %@ instead of handle %@. Ignoring.
We did not find a match to any existing invited user
Received request to send invitation for personal channel with statusTypeIdentifier %@ to handles: %@
Failed to send invitation to handles with error: %@
Successfully sent invitation to handles: %@
Received request to remove invitation from personal channel with statusTypeIdentifier %@ for handles: %@
Invitation revocation for handles %@ failed with error: %@
Invitation revocation for handles %@ completed succesffully
Received request to remove all invitations from personal channel with statusTypeIdentifier %@
Invitation revocation for all handles failed with error: %@
Invitation revocation for all handles completed succesffully
Client %@ has registered for delegate callbacks for statusTypeIdentifier: %@.
Server bag unexpected value type for key "%@". Value: %@
Resolved secondary device republish delay of %.1f seconds, within allowed range of (%.1f,%.1f) seconds.
XPC Error notifying of remote database changes. Error: %{public}@
Connected client completed processing of remote database changes.
Notifying client of updated subscription: %@
XPC Error notifying client of status update. Error: %{public}@
Connected client completed processing of status update.
Connected client does not match status type identifier of changed subscription. Client: %@ Status: %@
XPC Error notifying of received invitation. Error: %{public}@
Notifying connected client of received channel invitation.
Connected client completed processing of channel invitation.
Connected client does not match invited channel status type.
Current status for channel is expired
No existing status for channel
Beginning release of transient subscription assertions associated with interrupted client
Error releasing transient subscription assertions associated with interrupted client: %@
Success releasing transient subscription assertions associated with interrupted client
Beginning release of transient subscription assertions associated with invalidated client
Error releasing transient subscription assertions associated with invalidated client: %@
Success releasing transient subscription assertions associated with invalidated client
Client is not entitled to access subscription information for status type: %@
Retrieving subscription information for handle: %@
Subscription information not found for handle: %@
Found subscription metadata: %@ for handle %@
Retrieving all subscription information for statusTypeIdentifier: %@
Found %ld channels for status type %@
Retrieving all active assertions for statusTypeIdentifier: %@
Retrieving all subscription assertions for statusTypeIdentifier: %@ applicationIdentifier: %@
Found %ld subscription assertions
Subscription information not found for personal channel with statusTypeIdentifier: %@
Found subscription metadata for personal channel: %@
Received request to retain transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain transient subscription assertion for status type: %@
We're in traffic mode -- rejecting subscription request
No subscription was found matching subscriptionIdentifier: %@ statusTypeIdentifier: %@
Error retaining transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release transient subscription assertion for status type: %@
Error releasing transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released transient subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to retain persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to retain persistent subscription assertion for status type: %@
Error retaining persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully retained persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request to release persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Client is not entitled to release persistent subscription assertion for status type: %@
Error releasing persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@ error: %@
Successfully released persistent subscription assertion for subscriptionIdentifier: %@ statusTypeIdentifier: %@
Received request for subscription and encryption validation token for handle "%@" statusTypeIdentifier: %@
Found channel %@ matching handle: %@
Did not find a channel matching handle: "%@". Returning empty string to indicate no match.
Received request for validate token "%@" from handle "%@" for statusTypeIdentifier: %@
Validating tokens against personal channel: %@
Received invalid validity for subscription channel validation. Not validating encryption token.
Sender "%@" asked us to verify that we do not have a personal channel, and they are correct
Sender "%@" asked us to verify a channel validation token, but we don't have a personal channel, this device may be out of sync, returning unknown
Attempting to validate subscription channel token "%@" against personal channel with identifier "%@"
Sender "%@" asked us to verify that we do not have a personal channel, but we do have channel %@. Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid subscription channel validation token
Sender "%@" has supplied a subscription channel validation token "%@", that does not match our current personal channel identifier "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Attempting to validate encryption token "%@" against personal channel %@
Sender "%@" provided encryption validation token "%@", but we do not have a local value to validate against. Returning valid.
Sender "%@" provided an nil encryption validation token, but we expected "%@". For backward compatibility, we assume nil means they are on an older OS and we should not fail validation. Returning valid.
Sender "%@" provided an empty encryption validation token, but we expected "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Sender "%@" has supplied a valid encryption validation token. Provided: "%@" Expected: "%@"
Sender "%@" has supplied an encryptoin validation token "%@", that does not match our expected value "%@". Informing client that validation token is invalid, allowing them to re-invite the sender, if appropriate.
Validated subscriptionIdentifier: %@ statusTypeIdentifier: %@
Failed to validate. subscriptionIdentifier: %@ does not match statusTypeIdentifier: %@
Failed to validate subscriptionIdentifier: %@ statusTypeIdentifier: %@
Payload is invalid! Aborting presence assertion. Error: %@
Presence assertion already existed, but still sending presence assertion to ensure apsd is in sync.
Updating active particpants for channel %@
Payload is oversized! Payload size:%lu Max size:%lu
_sendPresenceAssertionMessageForChannel - Failed to retrieve one or more required crypto keys. membershipKey %@ serverKey %@
Presence payload is nil
Sending presence assertion message for presence identifier %@ on channel %@
Account refresh succeeded, reattempting presence assertion
Account refresh did not fix secondary attempt %@
Should not reauth for error: %@
Presence assertion completed with success.
Sending polling request for channel: 
_sendPollingMessageForChannel - Failed to retrieve one or more required crypto keys. membershipKey %@ serverKey %@
Polling completed with success.
Updating present devices for channel: %@
Participant payload failed to be processed
Successfully removed presence assertion from in memory model for subscription identifier: %@
Deactivation message failed for %@ with error: %@
Deactivation message suceeded for %@
Could not find presence assertion to remove from in memory model for subscription identifier: %@
_sendPresenceDeactivationMessageForChannel - Failed to retrieve one or more required crypto keys. membershipKey %@ serverKey %@
Release completed with success.
Should not reauth for error releasing presence: %@
Presence release completed with success.
Disconnecting client had no active presence assertions, not updating registered subscriptions
Disconnecting client had %ld presence assertion, removing presence assertions and updating registrations for channels: %@
Completed sending deactivation message for presence identifier: %@ because of a disconnected client
Could not find presence assertion to remove from in memory model for presence identifier: %@
presentDevicesForPresenceIdentifier returning %lu devices
No channel currently exists, so returning empty set of present devices
Received incoming payload on channel %@
Failed to deserialize data on channel %@
We recently sent an assertion message. Delaying processing of incoming push
Last checkpoint matches current checkpoint -- not polling
Payload last checkpoint is 0 -- not polling
Last checkpoint does not match current checkpoint -- polling because we missed something. Payload last checkpoint: %lld ; Current saved checkpoint: %lld 
We want to poll but we currently have no connected clients with an active subscription.  Resetting state and dropping payload
Error updating active particpants for channel %@  based on polling response
Updating active particpants for channel %@  based on polling response
Encrypted update data missing on channel %@
Failed to instantiate server key for channel %@
Failed to decrypt payload for channel %@
Failed to deserialize update on channel %@
Missing participant payloads for update on channel %@
Failed to validate device on channel %@
The last checkpoint was 0, so we're clearing any previously present devices before adding the new one
Adding device %@ to channel %@
Removing device %@ from channel %@
Unkown update type on channel %@
Looking for self device in channel: %@
Present device: %@
Active assertion exists but we're missing or have expired from this channel: %@
Attempting to reassert to fix state
Error reasserting presence for channel %@
Updating active particpants for channel %@ following reassert
Not reasserting because of rate limit
Updated checkpoint to %lld on channel %@ with result %d
Found an existing presence assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added presence assertion to in memory model for presennce identifier: %@
Not creating a new presence assertion, one already exists.
Succesfully removed presence assertion for identifier: %@. Client had %ld presence assertions, now has %ld. Client: %@
Could not find presence assertion for subscription identifier: "%@". Active presence assertions: %@ for client: %@
Found an existing present device for channel: %@ and device:%@
Successfully added present device to in memory model for channel identifier: %@
Not creating a new present device, one already exists.
Succesfully removed present devices for identifier: %@. Channel had %ld presence assertions, now has %ld
Could not find present device for subscription identifier: "%@". Present devices: %@
Clearing present devices for channel: %@
Could not find an existing presence channel, attempting to create a new one.
_sendPresenceDeactivationMessageForChannel - Failed to create one or more required crypto keys. membershipKey %@ serverKey %@ peerKey %@
Failed to obtain material for one or more required crypto keys
Failed to get signature: %@
Failed to get peer key
Payload size: %ld
Payload data empty
Failed to instantiate peer key for decryption
Payload data failed to decrypt
Payload data missing signature
Payload channel ID does not match the channel it was published on
Payload presence ID does not match the identifier of the channel it was published on
Missing token URI
Signature verification for %@ failed with error %@
Payload data signature failed to verify
Assertion time is older than existing presence, dropping
Assertion time deviated too much from server received time! Asserting device clock out of sync or replay attack
Assertion time is more than a day in the future, dropping. Our clock might be out of sync
Incoming payload failed validation. Error: %@
Incoming present device has no client-specified payload
Self device identifier: %@
Other device identifier: %@
Constructed SKPresentDevice from payload: %@
Rolling channel to attempt to solve crypto error.
It's been too recent since our last crypto roll. Not rolling
Server bag indicates our reset time for reasserting presence should be %lu
Server bag indicates our reset time for resetting crypto roll rate limits presence should be %lu
Server bag indicates our maxPayload size should be %lu
Could not find channel matching incoming status update, ignoring.
Found channel matching channel identifier: %@.
Could not extract unencrypted envelope from incoming status update, ignoring.
Could not determine status unique identifier for incoming status update, ignoring.
Could not determine date published for incoming status update, ignoring.
Date created is too far in the future, ignoring.
We've already received a status with this unique identifier (%@), ignoring.
Received new status %@ for channel %@
Saved incoming status update to database with unique identifier: %@
Not informing delegate of status because it has expired
Received request to create a personal channel
Unable to fetch JWT token for icloud account.  Failing request.
Asking push manager to execute create channel request
Channel create request failed with error: %@
Channel create response received
Create channle response contains non success status: %ld - %@
Retry interval specified: %ld
Channel create success response received: %@
Received request to create a presence channel
Asking push manager to execute create presence channel request
Presence channel create request failed with error: %@
Presence channel create response received
Create presence channel response contains non success status: %ld - %@
Presence channel create success response received: %@
Received request to publish data on channel %@
Unable to fetch JWT auth token.  Failing request.
Sending publish request to push manager
Publish status request contains error: %@
Publish status request contains neither error nor proto response
Handling protobuf response data for completed status publish request
Publish status request completed with nonsuccess response status: %ld
Publish status request completed with success
Received request to assert presence on channel %@
Sending presence activation request to push manager
Presence assertion response contains error: %@
Presence assertion response contains neither error nor proto response
Handling protobuf response data for completed presence assertion request
Presence assertion request completed with nonsuccess response status: %ld
Presence assertion request completed with success
Received request to release presence on channel %@
Sending presence deactivation request to push manager
Presence assertion release response contains error: %@
Presence assertion release response contains neither error nor proto response
Handling protobuf response data for completed presence assertion release request
Presence assertion release request completed with nonsuccess response status: %ld
Presence assertion release request completed with success
Received request to poll presence on channel %@
Sending polling request to push manager
Polling response contains error: %@
Polling response contains neither error nor proto response
Handling protobuf response data for completed polling request
Polling request completed with nonsuccess response status: %ld
Polling request completed with success
Fetching subscribed channels
Received %ld subscribed channels: %@
Subscribing to channels: %@
Unsubscribing from channels: %@
Enabling activity tracking
Disabling activity tracking
Retrieving JWT token from account provider
Could not fetch JWT token!: Error: %@
Received data on channel: %@
Failed to subscribe to channel: %@ Error: %@
Failed to create incomingRatchet due to invalid data. Error: %@
keyMaterial nil or incorrect length
Can not encrypt empty/nil data
Could not encrypt. Status: %i
Encrypted data is too small to decrypt (invalid size)
Could not decrypt. Status: %i
Could not generate random bytes. %i
Unable to fetch system account! Likely no iCloud account signed in.
Unable to fetch JWT token!
Fetched token hash:%@ for %@
Reauth has hit rate limit.  Not attempting.
Unable to fetch account store!
Unable to fetch system account! Likely no iCloud account signed in. Error: %@
altDSID not available for account
Auth refresh suceeded.
Auth refresh failed with error: %@
Fetching primary iCloud account
Primary iCloud account determined: %@
Failed to find primary iCloud account
Server bag indicates our max reauth count should be %lu
Server bag indicates our reauth backoff time should be %lu
In Traffic Mode--will not honor status subscriptions and will drop incoming status's
Received did leave first unlock notification.
Initializing APS connection.
Deferring connection initialization as device is before first unlock.
Using sandbox push environment
Using production push environment
Shared channels disabled by server! Aborting
No active APS connection. Cannot change topic filter.
Not under first data protection lock but no APS connection!
Trying to create a channel resulted in error %@
Create channel reverse push completed, calling completion with proto response
Sending create channel message.
Switching %@ to non-waking
Switching %@ to enabled
Traffic mode is enabled. Aborting publish
Publishing status
Publishing status failed with resultCode %ld error: %@
Publishing status, reverse push completed, calling completion with protobuf response data
Asked to enable activity tracking but we're missing a connection.  Likely before first unlock
No APSConnection. Cannot fetch push token
Sending presence protobuff message to server
Presence protobuff send failed with resultCode %ld error: %@
Presence protobuff sent, reverse push completed, calling completion with protobuf response data
Not subscribing to status channels because traffic mode is enabled
Subscribing to channels: %@ for topic %@
Error fetching subscribed channels! Error: %@
Fetching subscribed channels completed with channels: %@
APSConnection server is disconnected. Using current system time
APSConnection server time is invalid. Using current system time
Receieved aps incoming message: %@ -- expiration: %@
Status kit message data undecodable
Channel subscription failed. Failures: %@
Shared channels has been disabled in the server bag!
Date expired: %@, isExpired: %d
Transient subscription assertion already existed, but still refreshing registered subscription assertions, to ensure apsd is in sync.
Failed to update registered subscriptions following transient assertion retain with error: %@
Successfully updated registered subscriptions following transient assertion retain
Successfully removed transient subscription assertion from in memory model for subscription identifier: %@
Could not find transient subscription assertion to remove from in memory model for subscription identifier: %@
Failed to update registered subscriptions following transient assertion release with error: %@
Successfully updated registered subscriptions following transient assertion release
Disconnecting client had no active transient subscription assertions, not updating registered subscriptions
Disconnecting client had %ld transient subscription assertion, removing transient assertions and updating registrations for channels: %@
Failed to update registered subscriptions following client disconnect with error: %@
Successfully updated registered subscriptions following client disconnect
A subscription assertion already exists, no need to create a new one. Existing: %@
Created subscription assertion: %@
Failed to update registered subscriptions following persistent assertion retain with error: %@
Successfully updated registered subscriptions following persistent assertion retain
Did not delete persistent subscription assertion because one was not found for subscription identifier: %@
Successfully removed persistent subscription assertion from database for subscription identifier: %@
Failed to update registered subscriptions following persistent assertion release with error: %@
Successfully updated registered subscriptions following persistent assertion release
Returning %lu active assertions.
Returning %lu active subscriptions.
Disconnecting presence client had no active transient subscription assertions, not updating registered subscriptions
Disconnecting presence client had %ld transient subscription assertion, removing transient assertions and updating registrations for channels: %@
Successfully removed presence subscription assertion from in memory model for subscription identifier: %@
Could not find presence subscription assertion to remove from in memory model for subscription identifier: %@
Failed to update registered subscriptions following presence assertion release with error: %@
Successfully updated registered subscriptions following presence assertion release
Presence subscription assertion already existed, but still refreshing registered subscription assertions, to ensure apsd is in sync.
Failed to update registered subscriptions following presence assertion retain with error: %@
Successfully updated registered subscriptions following presence assertion retain
Found an existing transient subscription assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added transient subscription assertion to in memory model for subscription identifier: %@
Not creating a new transient subscription assertion, one already exists.
Found an existing presence subscription assertion for "%@" and client: %@. ExistingAssertion: %@
Successfully added presence subscription assertion to in memory model for subscription identifier: %@
Not creating a new presence subscription assertion, one already exists.
Marking subscription change time for channel %@
Succesfully removed transient subscription assertion for identifier: %@. Client had %ld transient subscription assertions, now has %ld. Client: %@
Could not find transient subscription assertion for subscription identifier: "%@". Active transient subscription assertions: %@ for client: %@
Succesfully removed presence subscription assertion for identifier: %@. Client had %ld transient subscription assertions, now has %ld. Client: %@
Could not find presence subscription assertion for subscription identifier: "%@". Active transient subscription assertions: %@ for client: %@
StatusKitAgent wants to be subscribed to: %@
StatusKitAgent was previously subscriped to: %@
No changes for active subscriptions based on current assertions. Subscribed to: %@
Subscriptions updated. Subscribed to: %@
Active subscription count %ld does not exceed cap of %ld
Active subscription count %ld exceeds cap of %ld
Transient subscription assertions: %@
Persistent subscription assertions: %@
Personal channels requiring self subscription: %@
Cached channels for subscription: %@
Finding at most %ld cached channels to subscribe to
Channel from history is gone from database: %@
Personal channel has no identifier: %@
No personal channel for statusTypeIdentifier: %@
Server bag indicates our max subscription count should be %lu
Server bag indicates our max presence subscription count should be %lu
Server bag indicates our hard max subscription count should be %lu
Server bag indicates our subscription TTL should be %f seconds
Creating TransientSubscriptionAssertion for channel "%@"
TransientSubscriptionAssertion
Deallocing TransientSubscriptionAssertion for channel "%@", releasing os_activity
Initializing
Shutting down
Logging state
Receiving XPC connection from PID %ld for publishing service
Receiving XPC connection from PID %ld for subscription service
Receiving XPC connection from PID %ld for presence
Receiving XPC connection from PID %ld for unknown service name: %{public}@
Rejected XPC connection from PID %ld for publishing service. Client is not entitled for any publishing service.
Accepted XPC connection from PID %ld for publishing service
Incoming XPC connection from PID %ld for presence service
Accepting XPC connection from PID %ld for presence service with clientid:%@
Rejecting incoming XPC connection from PID %ld because of missing or blank entitlement: %@
Rejected XPC connection from PID %ld for subscription service. Client is not entitled for any subscription service.
Accepted XPC connection from PID %ld for subscription service
Subscription service client was invalidated. Removing client: %@
Publishing service client was invalidated. Removing client: %@
Presence client was invalidated. Removing client: %@
Received remote database changes for channels: %@
Error updating subscriptions following remote database changes: %@
Success updating subscriptions following remote database changes
Could not find channel matching changed channelIdentifier: %@
Could not find any database channel matching changed channelIdentifiers
Incoming message received. Service: %@ senderID: %@ guid: %@
Handling message as key invite
Received network reachable notification
Kettle feature flag not enabled.  Exiting.
Handling as status update
We're in traffic mode--dropping incoming status
Handling as presence update
Unrecognized channel type for incoming message
Unable to find database channel for channel id for incoming message
Failed to subscribe to channel %@ with error: %@
Server received status update: %@
Writing to Biome event with IDSHandle: %@, statusTypeIdentifier %@
Channel created with identifier: %@ type: %@
Updating registered subscription to allow self subscription to personal channel, if necessary
Updating registered subscription failed with error: %@
Updating registered subscription to allow self subscriptions completed
Server received present devices update on presence identifier: %@
New presence channel created. Sending self invite for channel: %@
Sent self-invite with success:%d and error:%@
Finished rolling channel with success %d
Received channel invitation on channel: %@
Handling invitation as status invite
Handling invitation as presence invite
New received invitation for presence identifier %@ updated the mapped channel.  Notifying connected clients to reassert if needed
Revoked invitation(s) on channel: %@. Republishing current status
Finished republishing status.  ID:%@ error:%@
Couldn't decrypt current status on channel
No current status to republish
Scheduling maintenance XPC activity %@
Finished maintenance subscription update with error %@
Removing decomissioned channels
Creating persistent container
Failed to load persistent store. Error: %@ Store: %@
Completed loading of persistent store: %@
Completed creation of persistent container
Failed creation of persistent container
Persistent store remote change notification received.
Error executing history change request: %@
History change request found no results.
Have channel matching persistent history change. Channel: %@ Change: %@
Could not find channel matching persisent history change: %@
Ignoring delete channel change: %@
Have received invitation matching persistent history change. ReceivedInvitation: %@ Change: %@
ReceivedInvitation matching persistent history change has channel. Channel: %@ Change: %@
ReceivedInvitation matching persistent history change has not channel. ReceivedInvitation: %@ Change: %@
Could not find encryption key matching persisent history change: %@
Ignoring delete received invitation change: %@
Did not find object matching change history event. Object has already been deleted. Error: %@
Error fetching object matching change transaction. Error: %@
Last processed persistent history token is nil at URL %@
Error unarchiving last processed persistent history token. Error: %@
Error archiving last processed persistent history token. Error: %@
Archived last processed persistent history token is zero length
Overriding device-to-device encryption check because default has been set.
Account supports device-to-device encryption
Account does not support device-to-device encryption and is not statuskit capable
Failed to create outgoing ratchet due to invalid data. Error: %@
Failed to create outgoing ratchet due to nil outgoing ratchet state
Failed to create incoming ratchet due to failure to access subscription keys
Failed to create incoming ratchet due to lack of outgoing ratchet
Client is not entitled to subscription information for status of type %{public}@
Error fetching personal status channel. Error: %@
Fetch request for personal status channel type "%@" completed with result: %@
Error fetching decomissioned channel. Error: %@
Fetch request for decomissioned personal channels completed with %lu results
Deleted existing channel.
Could not find existing channel
More than one personal channel exists for channel identifier: %@
Error executing fetch for subscription validation. Error: %@
Fetch request for channels by identifier returned a nil result
Fetch request for channel by identifier %@ found no match.
Fetch request for channels by identifier %@ returned a nil result
Beginning fetch request for channels with presence identifier: %@
Fetch request for channel by identifier found no match.
Fetch request for channel by identifier completed with %ld result(s)
Preferring invitation %@ from %@ among %ld result(s)
Invitation %@ corresponds to channelIdentifier: %@
Could not find any channels associated with channel identifier: %@
Invitation does not correspond to any channel. InvitationIdentifier: %@
No received invitation found matching handle %@ statusTypeIdentifier: %@
Invitation does not correspond to any channel. ReceivedInvitation: %@ handle: %@
Channel not found for channel identifier: %@
Beginning fetch request for channel by handle
Error executing fetch for channel by handle. Error: %@
Fetch request for channel by handle found no match.
Fetch request for channel by handle completed with %ld result(s)
Error saving managed object context for storing new personal channel. Error: %@
Error saving managed object context for storing new presence channel. Error: %@
Error saving managed object context for storing channel invitation. Error: %@
Error saving managed object context for updated outgoing ratchet state. Error: %@
Error saving managed object context for decomissioning. Error: %@
Could not find generated ratchet keys matching database channel. Channel: %@
Beginning fetch request for active subscription assertions
Error fetching subscription assertions. Error: %@
Fetch request for active subscription assertions completed
Error saving managed object context for storing persistent subscription assertion. Error: %@
Deleted existing assertion.
Could not find existing assertion
Error fetching transientSubscriptionHistory. Error: %@
Error fetching transientSubscriptionHistories. Error: %@
Found existing transient subscription history. Updating lastSubscrionDate.
Could not find existing transient subscription history. Creating a new one.
Error saving managed object context for storing transient subscription history. Error: %@
Error saving managed object context for storing invited user. Error: %@
Error saving managed object context for copyinh invited users. Error: %@
Multiple (%ld) entries in the database match a single invited user, updating all of them. InvitedUser: %@
Error saving managed object context for updating invitation payload on invited user. Error: %@
Error finding core data invited user to update invitation. No match for SKADatabaseInvitedUser: %@
Error finding core data channel matching SKADatabaseChannel: %@
Error fetching invited user. Error: %@
Fetch request for invited user executed with results: %@
Failed to normalize handle: "%@", returning nil existing invited user
Deleting existing invited user with handle: %@
Error saving managed object context for deleting invited users by handle. Error: %@
Could not find existing invited user matching handle: %@
Could not find existing database channel matching channel %@
Deleting all %ld existing invited users for channel %@
Error saving managed object context for deleting all invited users. Error: %@
Could not find any existing invited users to delete
Error saving managed object context for storing status. Error: %@
Beginning lookup of most recent status for channel
Error executing fetch for status by channel. Error: %@
Fetch request for status by channel found no match.
Fetch request for status by channel completed with %ld result(s)
Beginning lookup of most recent status for unique id
Error executing fetch for status by unique id. Error: %@
Fetch request for status by unique id found no match.
Fetch request for status by unique id completed with %ld result(s)
Found existing checkpoint %lld for channel %@
No existing checkpoint for channel: %@. Creating a new checkpoint
Error saving managed object context for channel checkpoint. Error: %@
Updated checkpoint for channel: %@
Error saving managed object context for storing checkpoint. Error: %@
Error fetching pending requests. Error: %@
Beginning database cleanup of statuses on channel identifier: %@
Error executing fetch for status cleanup. Error: %@
Fetch request for cleanup of statuses found no matches.
Fetch request for status cleanup completed with %ld result(s)
Keeping status %@ because it is our most recent status
Keeping status %@ because it is excluded from this cleanup request
Deleting status %@ as it is no longer the most recent
Error saving managed object context for status cleanup. Error: %@
Error saving managed object context for storing pending publish request. Error: %@
Error saving managed object context for deleting pending publish request. Error: %@
Deleted existing pending publish request with identifier: %@
Could not find existing pending publish request with identifier: %@
Error saving managed object context for incrementing pending publish request. Error: %@
Incremented pending publish request rc with identifier: %@
Error saving managed object context for storing removed user. Error: %@
Error saving managed object context for deleting removed user. Error: %@
Deleted existing removed user with handle: %@
Could not find existing removed user with handle: %@
Error fetching removed users. Error: %@
Beginning fetch request for ReceivedInvitation from handle %@ statusTypeIdentifier: %@
Error executing fetch for ReceivedInvitation by handle. Error: %@
Fetch request for ReceivedInvitation by handle found no match.
Fetch request for ReceivedInvitation by handle completed with %ld result(s)
Could not find core data channel to match channel identifier: %@
Error saving managed object context for storing received invitation. Error: %@
Could not find any existing channels matching channel identifier. Returning no received invitations. Channel identifier: %@
Deleting invitation %@ as it is no longer the most recent
Error saving managed object context for invitation cleanup. Error: %@
Deleting channel %@ as it is decomissioned and not recent or old
Not deleting channel %@ as it is in our most recent and old decomissioned channels
Error saving managed object context for decomissioned channel cleanup. Error: %@
No decomissioned channel to clean up
Channel cleanup is disabled.
Presence client connection was interrupted: %@
Error releasing presence assertions associated with interrupted client: %@
Success releasing presence assertions associated with interrupted client
Presence client connection was invalidated: %@
Beginning release of presence subscription assertions associated with interrupted client
Error releasing presence subscription assertions associated with invalidated client: %@
Success releasing presence subscription assertions associated with invalidated client
Beginning release of presence assertions associated with interrupted client
Error releasing presence assertions associated with invalidated client: %@
Success releasing presence assertions associated with invalidated client
Client did not specify a payload
Missing client ID entitlement or presence identifier
Retaining presence assertion for presenceIdentifier: %@
Error retaining presence assertion for presenceIdentifier: %@ error: %@
Successfully retained presence assertion for presenceIdentifier: %@
Error releasing presence assertion for presenceIdentifier: %@ error: %@
Successfully released presence assertion for presenceIdentifier: %@
Presence account check completed with result: %d
Inviting handles isn't available when isPersonal is true
Received request to send invitation for presence channel with presence identifier %@ to handles: %@
Account is not Presence capable
Personal channel does not exist for presence identifier
Client %@ has registered for delegate callbacks for presence identifier: %@.
Inviting (or removing) handles isn't available when isPersonal is true
Unable to find or create channel for presenceIdentifier: %@
Error retaining presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@ error: %@
Successfully retained presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@
Successfully released presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@
Notifying client of updated present devices
XPC Error notifying client of present devices update. Error: %{public}@
Retrieved present devices. Presence: %{public}@ Handles: %@ Error: %@
Retrieved present devices. Presence: %{public}@ Handles: %@
Notifying delegate of present devices change
Connected client completed processing of present devices update.
No change in present devices - not notifying delegate
Connected client does not match presence identifier of changed channel. Client: %@ Presence: %@
Notifying client of updated invitations
XPC Error notifying client of invitations update. Error: %{public}@
Connected client completed processing of invited handles update.
Unable to find channel for presenceIdentifier: %@
Moving over to new channel for subscription for presence identifier %@. Old channel %@ New channel %@
Error releasing presence subscription assertion for subscriptionIdentifier: %@ presenceIdentifier: %@ error: %@
Reasserting presence to handle change in underlying channel for presenceIdentifier %@
Client does not have a presence client ID
Delivering %@ to %@
SKAStatusEncryptionManager
SKAStatusEncryptionManaging
NSObject
SKAStatusUnencryptedEnvelope
KeyPathConstants
Predicates
SKAOutgoingInvitationState
SKAInvitationManager
SKAInvitationManaging
SortDescriptors
SKAPresenceAssertion
SharedChannelCreateRequest
NSCopying
SKAPresenceSubscriptionAssertion
DecryptedParticipantPayload
SKAStatusPublishingServiceClientConnection
ChannelActivityPollingResponse
SKAStatusPublishingManager
SKAStatusPublishingManaging
SKADatabaseChannel
CurrentOutgoingRatchet
SKAMessagingProvider
IDSServiceDelegate
SKAMessagingProviding
SKAPresenceMembershipKey
SKAStatusPublishingServiceClient
SKStatusPublishingDaemonProtocol
SKAStatusPublishingServiceClientConnectionLifecycleDelegate
SKAStatusSubscriptionServiceClient
SKStatusSubscriptionDaemonProtocol
SKAClientConnectionRepresentable
SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate
SKAPresenceManager
SKAPresenceManaging
SKAStatusReceivingManager
SKAStatusReceivingManaging
CoreData
SKAChannelManager
SKAPushManagingDelegate
SKAChannelManaging
SharedChannelPublishResponse
SKADatabaseReceivedInvitation
SKHandle
IncomingRatchet
SKInvitationPayload
SKADatabaseTransientSubscriptionHistory
StatusKitAgent
SKAPresenceEncryptionKey
SKAAccountProvider
SKAAccountProviding
ChannelActivityParticipantPayload
ChannelIdentity
SKAPushManager
APSConnectionDelegate
SKASystemMonitorListener
SKAPushManaging
SKADatabaseStatus
SharedChannelCreateResponse
ChannelActivityDeactivationRequest
SKAStatusSubscriptionManager
SKAStatusSubscriptionManaging
SKATransientSubscriptionAssertion
AuthCredential
SharedChannelPublishRequest
ChannelPublishPayload
SKAStatusServer
NSXPCListenerDelegate
SKADatabaseProvidingDelegate
SKAMessagingProvidingDelegate
SKAChannelManagingDelegate
SKAStatusReceivingManagingDelegate
SKADatabaseManagingDelegate
SKAInvitationManagingDelegate
SKAStatusPublishingServiceClientDelegate
SKAStatusSubscriptionServiceClientDelegate
SKAPresenceClientDelegate
SKAPresenceManagingDelegate
SKADatabaseRemovedUser
SKADatabaseProvider
SKADatabaseProviding
SKAGeneratedEncryptionKey
Ratchets
SKAStatusSubscriptionServiceClientConnection
ChannelActivityUpdate
SignedParticipantPayload
ChannelActivityUpdatePayload
ChannelActivityActivationRequest
SKADecryptedStatusPayload
SKADatabaseInvitedUser
SKADatabaseManager
SKADatabaseManaging
SKADatabaseSubscriptionAssertion
ChannelActivityPollingRequest
SKAPresenceClient
SKPresenceDaemonProtocol
SKAPresenceClientConnectionLifecycleDelegate
ChannelActivityDeactivationResponse
SKADatabasePendingPublishRequest
SharedChannelActivityResponse
SharedOwnershipAuth
SKAPresenceClientConnection
ChannelActivityActivationResponse
SKASystemMonitor
SharedChannelActivityRequest
Channel
CoreDataProperties
ChannelCheckpoint
GeneratedEncryptionKey
InvitedUser
PendingPublishRequest
ReceivedInvitation
RemovedUser
Status
SubscriptionAssertion
TransientSubscriptionHistory
initWithFormat:
componentsJoinedByString:
signData:withAlgorithm:completion:
dataWithJSONObject:options:error:
deviceForFromID:
initWithHandle:deviceIdentifier:payload:assertionTime:selfHandle:selfDevice:
subdataWithRange:
userInfo
changeType
setPersistentStoreDescriptions:
serializedData
dataWithLength:
componentsSeparatedByString:
setDateCreated:
deviceIdentifier
loadPersistentStoresWithCompletionHandler:
subscribeToChannels:forTopic:
userStatusChangeStream
changedObjectID
dataWithPropertyList:format:options:error:
addDelegate:queue:
setPersonal:
initWithIDSHandles:statusChangeType:
performBlockAndWait:
changes
setDateExpired:
initWithIndex:chainKey:signingKey:error:
addGeneratedEncryptionKeysObject:
setDateGenerated:
performSelectorOnMainThread:withObject:waitUntilDone:
index
signingKey
addIndex:
presentHandlesChangedForPresenceIdentifier:completion:
containsObject:
setDateInvitationCreated:
setPredicate:
devices
valueForEntitlement:
addInvitedUsersObject:
valueForKey:
persistentStoreDescriptionWithURL:
remoteObjectProxyWithErrorHandler:
setDateInvitationPayloadCreated:
expirationDate
initWithAPSConnection:mobileNetworkManager:
initWithIsInvitable:wasRemoved:
containsString:
dictionary
copy
verifySignedData:matchesExpectedData:withTokenURI:forAlgorithm:completion:
setDatePublished:
removals
addObject:
initWithArray:
mergedModelFromBundles:
subscriptionInvitationReceived:completion:
removeAllObjects
setDateReceived:
date
addObjectsFromArray:
initWithBase64EncodedString:options:
dictionaryWithObjects:forKeys:count:
initWithMachServiceName:
removeObject:
setDateRemoved:
dateByAddingTimeInterval:
initWithBytes:length:
serviceName
subscriptionReceivedStatusUpdate:completion:
addObserver:selector:name:object:
differenceFromArray:
propertyListWithData:options:format:error:
count
removeObjectForKey:
weakToStrongObjectsMapTable
failureReason
initWithCapacity:
mutableBytes
invitedHandlesChangedForPresenceIdentifier:completion:
initWithName:managedObjectModel:
countByEnumeratingWithState:objects:count:
removeObjectsAtIndexes:
protoResponse
mutableCopy
writeToURL:atomically:
initWithChannelID:
addReceivedInvitationsObject:
domain
setDecomissioned:
setRawData:
aida_accountForPrimaryiCloudAccount
name
setRemoteObjectInterface:
publicToken
isConnected
initWithOptions:capacity:
fetchHistoryAfterToken:
aida_alternateDSID
doubleValue
setEnabledTopics:ignoredTopics:opportunisticTopics:nonWakingTopics:
setRemovedHandle:
aida_tokenWithExpiryCheckForService:
initWithPrefixedURI:
subscriptionStateChangedForSubscriptions:completion:
result
fetchRequestWithEntityName:
nonWakingTopics
subscriptionValidationToken
enabledTopics
resume
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
fileExistsAtPath:
initWithContainerID:
substringToIndex:
setExportedInterface:
allObjects
initWithContainerIdentifier:
isEqualToSet:
setExportedObject:
initWithProtoData:messageType:
isEqualToString:
supportsDeviceToDeviceEncryption
numberWithBool:
setAltDSID:
initWithContainerIdentifier:environment:
encryptedMessage
setFetchLimit:
numberWithDouble:
setSenderHandle:
initWithContext:
setApplicationIdentifier:
initWithPushTopic:protoData:
setFetchRequest:
isEqualToURI:
numberWithInt:
setApsConnectionMachServiceName:
setIdentifier:
firstObject
_newZeroingDataWithBytes:length:
numberWithUnsignedInt:
allValues
setServerKey:
synchronousRemoteObjectProxyWithErrorHandler:
initWithService:
fromID
setIncomingRatchetState:
allocWithZone:
numberWithUnsignedLongLong:
setServiceType:
setAuthenticationType:
timeIntervalSince1970
setInterruptionHandler:
initWithStatusPayload:
encryptionValidationToken
numberWithUnsignedShort:
andPredicateWithSubpredicates:
setChannelID:
setInvalidationHandler:
timeIntervalSinceDate:
sortDescriptorWithKey:ascending:
dateWithTimeIntervalSince1970:
object
setShouldAddStoreAsynchronously:
initWithStatusPayload:isScheduledRequest:
setInvitationIdentifier:
getRegisteredChannelsForTopic:withCompletion:
objectAtIndex:
appendData:
sortDescriptorWithKey:ascending:selector:
dateWithTimeIntervalSinceReferenceDate:
initWithStatusPayload:statusUniqueIdentifier:datePublished:dateCreated:dateReceived:invitationPayload:
entity
setInvitationPayload:
URIs
sortedArrayUsingDescriptors:
objectEnumerator
getUUIDBytes:
predicateWithFormat:
toID
appendFormat:
enumerateObjectsUsingBlock:
setInvitedHandle:
objectForKey:
source
errorWithDomain:code:userInfo:
initWithString:
setIsUsernameEditable:
token
predicateWithFormat:argumentArray:
accountInfoWithCompletionHandler:
standardUserDefaults
objectForKey:inDomain:
setSortDescriptors:
executeFetchRequest:error:
ratchetForward
save:
initWithData:
setStatusType:
objectForKeyedSubscript:
archivedDataWithRootObject:requiringSecureCoding:error:
initWithSubscriptionIdentifier:statusTypeIdentifier:isPersonalStatusSubscription:currentStatus:ownerHandles:
sealStatus:authenticating:error:
executeRequest:error:
array
originalGUID
setStatusTypeIdentifier:
initWithData:dateCreated:
initWithSubscriptionValidationToken:encryptionValidationToken:
trackActivityPresence
setLastSubscriptionDate:
isScheduledRequest
setStatusUniqueIdentifier:
sendEvent:
initWithData:error:
arrayByAddingObjectsFromArray:
unarchivedObjectOfClass:fromData:error:
isSecondaryDeviceRepublish
setMembershipKey:
setTimeout:
arrayWithObjects:count:
defaultCenter
setChannelType:
initWithUUIDBytes:
isSelfDevice
defaultManager
setObject:forKey:
initWithUnprefixedURI:
URLByAppendingPathComponent:isDirectory:
setCheckpoint:
sendMessage:
assertionTime
setObject:forKeyedSubscript:
URLForDirectory:inDomain:appropriateForURL:create:error:
unprefixedURI
sendMessage:toDestinations:priority:options:identifier:error:
_setNonWakingTopics:
setTrackActivityPresence:
unsealStatusWithIndex:encryptedMessage:authenticating:signature:error:
_setQueue:
UTF8String
currentSubscriptionKeys
handleString
setOption:forKey:
refreshIDStatusForDestination:service:listenerID:queue:completionBlock:
UUID
setType:
authenticateWithContext:completion:
unsubscribeFromChannels:forTopic:
existingObjectWithID:error:
setOriginalOutgoingRatchetState:
hasChanges
base64EncodedStringWithOptions:
refreshObject:mergeChanges:
UUIDString
setUniqueIdentifier:
setCloudKitContainerOptions:
daemonDelegateXPCInterface
hasPrefix:
setUseDeviceToDeviceEncryption:
boolValue
lastObject
setCompletionBlock:
insertions
deleteObject:
daemonXPCInterface
bundleForClass:
setConfiguration:
intValue
stringWithCapacity:
data
setPayloadData:
stringWithFormat:
setWithArray:
bytes
integerValue
code
path
setPeerKey:
initWithEnvironmentName:namedDelegatePort:queue:
dataWithBytes:length:
strongToStrongObjectsMapTable
cStringUsingEncoding:
setCurrentOutgoingRatchetState:
sharedInstanceForBagType:
dataWithContentsOfURL:
subarrayWithRange:
chainKey
invalidate
length
init
signingKeyIdentifier
logger
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
encodeStatusPayload:statusUniqueIdentifier:dateCreated:currentServerTime:channel:
extractEnvelopeFromStatusEnvelopeData:
decryptStatusPayloadFromStatusEnvelopeData:channel:
encryptionValidationTokenForChannel:
initWithDatabaseManager:invitationManager:
_encryptPayload:channel:
_decryptPayload:withRatchetIndex:signatureData:channel:
_decryptPayloadData:withIncomingRatchet:withRatchetIndex:signatureData:
_mostRecentIncomingRatchetForChannel:
_serializeDictionaryAsBinaryPlist:
_deserializeBinaryPlistDictionaryData:
databaseManager
invitationManager
.cxx_destruct
_databaseManager
_invitationManager
T@"<SKADatabaseManaging>",R,N,V_databaseManager
T@"<SKAInvitationManaging>",R,N,V_invitationManager
initWithEnvelopeDictionary:
statusUniqueIdentifier
datePublished
dateCreated
envelopeDictionary
setEnvelopeDictionary:
_envelopeDictionary
T@"NSDictionary",&,N,V_envelopeDictionary
T@"NSString",R,N
T@"NSDate",R,N
identifierKeyPath
predicateForChannelIdentifier:
initWithToHandle:fromHandle:channelIdentifier:
toHandle
setToHandle:
fromHandle
setFromHandle:
channelIdentifier
setChannelIdentifier:
_toHandle
_fromHandle
_channelIdentifier
T@"SKHandle",&,N,V_toHandle
T@"SKHandle",&,N,V_fromHandle
T@"NSString",&,N,V_channelIdentifier
_invalidSenderHandleError
_invalidInvitedHandlesError
_noPersonalChannelErrorForStatusTypeIdentifier:
_noPresenceChannelForIdentifier:
_keyRollFailedErrorWithUnderlyingError:
_unableToFindExistingInvitationForHandlesError:
_unableToFindAnyExistingInvitationToDeleteError
_presenceDisabledError
sendInvitationForPersonalChannelWithStatusTypeIdentifier:toHandles:fromSenderHandle:withInvitationPayload:completion:
sendInvitationForPresenceChannelWithPresenceIdentifier:toHandles:fromSenderHandle:completion:
sendSelfInvitationForPresenceChannelWithPresenceIdentifier:isPersonal:completion:
revokeInvitationFromPersonalChannelWithStatusTypeIdentifier:forHandles:completion:
revokeInvitationFromPresenceChannelWithPresenceIdentifier:forHandles:completion:
revokeAllInvitationsFromPersonalChannelWithStatusTypeIdentifier:completion:
handleIncomingInvitationMessage:fromHandle:fromID:toHandle:messageGuid:
outgoingMessageWithIdentifier:fromHandle:toHandle:didSendWithSuccess:
rollEncryptionKeyForPersonalChannelWithStatusTypeIdentifier:error:
rollPersonalChannelWithStatusTypeIdentifier:completion:
rollPresenceChannelWithPresenceIdentifier:isPersonal:completion:
isHandleInviteable:fromHandle:completion:
fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:
fetchHandleInvitability:fromHandle:forPresenceIdentifier:completion:
resolveSenderHandleWithPreferredSenderHandle:
delegate
setDelegate:
T@"<SKAInvitationManagingDelegate>",W,N
initWithMessagingProvider:databaseManager:accountProvider:channelManager:presenceManager:trafficMode:
_rollEncryptionKeyForChannel:databaseContext:error:
_sendInvitationMessageForChannel:toInvitedUsers:subscriptionKeys:error:
_sendInvitationMessageForPresenceChannel:toInvitedUsers:error:
_invitationMessageForPresenceChannel:
_validateInvitedHandles:
_validateInvitedHandle:
_isHandleInviteable:completion:
isPresenceHandleInviteable:fromHandle:completion:
_isPresenceHandleInviteable:completion:
_ratchetEncryptionKeyForwardOrKeyRollForPersonalChannel:databaseContext:invitationWasSentViaKeyRoll:error:
_addInvitedHandles:senderHandle:toDatabaseForPersonalChannel:withInvitationPayload:databaseContext:
_addInvitedHandles:senderHandle:toDatabaseForPresenceChannel:databaseContext:
_updateOrCreateInvitedUserWithHandle:senderHandle:onChannel:withInvitationPayload:databaseContext:
_findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
_createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
_shouldReauthForError:
_presenceEnabledByServer
setDatabaseManager:
messagingProvider
setMessagingProvider:
channelManager
setChannelManager:
accountProvider
setAccountProvider:
presenceManager
setPresenceManager:
backgroundCleanupQueue
setBackgroundCleanupQueue:
outgoingInvitationMapping
setOutgoingInvitationMapping:
trafficModeEnabled
setTrafficModeEnabled:
presenceEnabledByServer
setPresenceEnabledByServer:
_trafficModeEnabled
_delegate
_messagingProvider
_channelManager
_accountProvider
_presenceManager
_backgroundCleanupQueue
_outgoingInvitationMapping
T@"<SKADatabaseManaging>",&,N,V_databaseManager
T@"<SKAMessagingProviding>",&,N,V_messagingProvider
T@"<SKAChannelManaging>",&,N,V_channelManager
T@"<SKAAccountProviding>",&,N,V_accountProvider
T@"<SKAPresenceManaging>",&,N,V_presenceManager
T@"NSObject<OS_dispatch_queue>",&,N,V_backgroundCleanupQueue
T@"NSMutableDictionary",&,N,V_outgoingInvitationMapping
TB,N,V_trafficModeEnabled
TB,N,V_presenceEnabledByServer
T@"<SKAInvitationManagingDelegate>",W,N,V_delegate
lastSubscriptionDateKeyPath
channelIdentifierKeyPath
predicateForLastSubscriptionDate:
sortDescriptorForLastSubscriptionDateAscending:
dealloc
initWithPresenceIdentifier:isPersonal:payload:
isEqualToPresenceAssertion:
presenceIdentifier
isPersonal
payload
setPayload:
osActivity
_isPersonal
_presenceIdentifier
_payload
_osActivity
T@"NSObject<OS_os_activity>",R,N,V_osActivity
T@"NSString",R,C,N,V_presenceIdentifier
TB,R,N,V_isPersonal
T@"SKPresencePayload",C,N,V_payload
dateRemovedKeyPath
handleKeyPath
statusTypeIdentifierKeyPath
presenceIdentifierKeyPath
predicateForHandle:
predicateForHandleString:
predicateForStatusTypeIdentifier:
predicateForPresenceIdentifier:
copyWithZone:
hasChannelTopic
hasAuthCredential
channelOwnershipType
setChannelOwnershipType:
setHasChannelOwnershipType:
hasChannelOwnershipType
channelOwnershipTypeAsString:
StringAsChannelOwnershipType:
dictionaryRepresentation
readFrom:
writeTo:
copyTo:
mergeFrom:
channelTopic
setChannelTopic:
authCredential
setAuthCredential:
_authCredential
_channelOwnershipType
_channelTopic
_has
TB,R,N
T@"NSString",&,N,V_channelTopic
T@"AuthCredential",&,N,V_authCredential
TB,N
Ti,N,V_channelOwnershipType
initWithSubscriptionIdentifier:
isEqualToPresenceSubscription:
subscriptionIdentifier
_subscriptionIdentifier
T@"NSString",R,C,N,V_subscriptionIdentifier
personalKeyPath
decomissionedKeyPath
statusTypeKeyPath
encryptionKeysKeyPath
dateChannelCreatedKeyPath
channelTypeKeyPath
predicateForPersonal:
predicateForDecomissioned:
predicateForChannelTypeStatus
predicateForChannelTypePresence
predicateForCreationDateNotNil
sortDescriptorForStatusTypeIdentifierOrderedAscending:
sortDescriptorForPersonalOrderedAscending:
sortDescriptorForChannelIdentifierOrderedAscending:
sortDescriptorForCreationDateAscending:
hasTokenUri
hasPresenceIdentifier
hasChannelIdentifier
setTimestamp:
setHasTimestamp:
hasTimestamp
hasClientPayload
tokenUri
setTokenUri:
setPresenceIdentifier:
timestamp
clientPayload
setClientPayload:
_timestamp
_clientPayload
_tokenUri
T@"NSString",&,N,V_tokenUri
T@"NSString",&,N,V_presenceIdentifier
TQ,N,V_timestamp
T@"NSData",&,N,V_clientPayload
clientIsEntitledForAtLeastOnePublishingServiceType:
_connection:isEntitledForPublishingWithStatusTypeIdentifier:
initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:
asynchronousRemoteDaemonDelegateWithErrorHandler:
synchronousRemoteDaemonDelegateWithErrorHandler:
clientIsEntitledForPublishingWithStatusTypeIdentifier:
processIdentifier
xpcConnection
setXpcConnection:
connectionLifecycleDelegate
setConnectionLifecycleDelegate:
_xpcConnection
_connectionLifecycleDelegate
T@"NSXPCConnection",&,N,V_xpcConnection
T@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
Ti,R
participantPayloadType
status
setStatus:
setHasStatus:
hasStatus
statusAsString:
StringAsStatus:
hasUuid
setServerTimestampSeconds:
setHasServerTimestampSeconds:
hasServerTimestampSeconds
setVersion:
setHasVersion:
hasVersion
clearParticipantPayloads
addParticipantPayload:
participantPayloadsCount
participantPayloadAtIndex:
setResponseMessageIndex:
setHasResponseMessageIndex:
hasResponseMessageIndex
setTotalResponseMessages:
setHasTotalResponseMessages:
hasTotalResponseMessages
uuid
setUuid:
serverTimestampSeconds
version
participantPayloads
setParticipantPayloads:
responseMessageIndex
totalResponseMessages
_serverTimestampSeconds
_version
_participantPayloads
_responseMessageIndex
_status
_totalResponseMessages
_uuid
Ti,N,V_status
T@"NSData",&,N,V_uuid
TQ,N,V_serverTimestampSeconds
TQ,N,V_version
T@"NSMutableArray",&,N,V_participantPayloads
TI,N,V_responseMessageIndex
TI,N,V_totalResponseMessages
_errorForStatusPublishRequestWithIdentifier:requestedStatusCreationDate:isOlderThanExistingStatus:existingStatusCreationDate:
_errorForDuplicateStatusPublishRequestWithIdentifier:
_errorForRateLimit
publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:completion:
removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:
publishPendingRequestForReason:
initWithDatabaseManager:channelManager:accountProvider:encryptionManager:invitationManager:
_publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:retryCount:completion:
publishPendingRequestsWithDelay:
_shouldAllowPublishForPublishRequest:onChannel:error:
_shouldClientRateLimit
_markPublishAttempt
_removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:databaseContext:
ensurePendingPublishRequestExistsWithPublishRequest:forStatusTypeIdentifier:databaseContext:
findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:
createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:
_removePendingPublishRequestWithUniqueIdentifier:databaseContext:
_shouldAbandonRequestForError:
_shouldRollChannelForError:
_shouldRetryWithDelayForError:
_pendingDelayTime
_rateLimitDelayTime
_maxRetryCount
_maxRapidPublishes
_rapidPublishesTimescale
encryptionManager
setEncryptionManager:
setInvitationManager:
internalWorkQueue
setInternalWorkQueue:
pendingRequestScheduled
setPendingRequestScheduled:
clientIsRateLimited
setClientIsRateLimited:
_pendingRequestScheduled
_clientIsRateLimited
_encryptionManager
_internalWorkQueue
T@"<SKAStatusEncryptionManaging>",&,N,V_encryptionManager
T@"<SKAInvitationManaging>",&,N,V_invitationManager
T@"NSObject<OS_dispatch_queue>",&,N,V_internalWorkQueue
TB,V_pendingRequestScheduled
TB,V_clientIsRateLimited
initWithChannelToken:channelType:identifier:personal:decomissioned:currentOutgoingRatchetState:dateCreated:statusType:presenceIdentifier:invitedUsers:presenceServerKey:presencePeerKey:presenceMembershipKey:
channelToken
identifier
isDecomissioned
currentOutgoingRatchetState
dateChannelCreated
setDateChannelCreated:
statusType
channelType
invitedUsers
presenceServerKey
presencePeerKey
presenceMembershipKey
_personal
_decomissioned
_channelToken
_identifier
_currentOutgoingRatchetState
_dateChannelCreated
_statusType
_channelType
_invitedUsers
_presenceServerKey
_presencePeerKey
_presenceMembershipKey
T@"NSData",R,N,V_channelToken
T@"NSString",R,C,N,V_identifier
personal
TB,R,N,GisPersonal,V_personal
decomissioned
TB,R,N,GisDecomissioned,V_decomissioned
T@"NSData",R,N,V_currentOutgoingRatchetState
T@"NSDate",&,N,V_dateChannelCreated
T@"NSString",R,C,N,V_statusType
Tq,R,N,V_channelType
T@"NSArray",R,C,N,V_invitedUsers
T@"NSData",R,N,V_presenceServerKey
T@"NSData",R,N,V_presencePeerKey
T@"NSData",R,N,V_presenceMembershipKey
currentOutgoingRatchet
T@"MPStatusKitOutgoingRatchet",R,N
_noValidIDSDetintationError
service:account:incomingOpportunisticData:withIdentifier:fromID:context:
service:didSendOpportunisticDataWithIdentifier:toIDs:
service:account:incomingMessage:fromID:context:
service:account:incomingData:fromID:context:
service:account:incomingUnhandledProtobuf:fromID:context:
service:account:incomingResourceAtURL:fromID:context:
service:account:incomingResourceAtURL:metadata:fromID:context:
service:account:incomingPendingMessageOfType:fromID:context:
service:activeAccountsChanged:
service:devicesChanged:
service:nearbyDevicesChanged:
service:connectedDevicesChanged:
service:linkedDevicesChanged:
service:account:identifier:didSendWithSuccess:error:
service:account:identifier:didSendWithSuccess:error:context:
service:account:identifier:sentBytes:totalBytes:
service:account:identifier:hasBeenDeliveredWithContext:
service:account:identifier:fromID:hasBeenDeliveredWithContext:
service:account:inviteReceivedForSession:fromID:
service:account:inviteReceivedForSession:fromID:withOptions:
service:account:inviteReceivedForSession:fromID:withContext:
service:account:receivedGroupSessionParticipantUpdate:
service:account:receivedGroupSessionParticipantUpdate:context:
service:account:receivedGroupSessionParticipantDataUpdate:
serviceSpaceDidBecomeAvailable:
serviceAllowedTrafficClassifiersDidReset:
service:didSwitchActivePairedDevice:acknowledgementBlock:
sendMessage:toHandle:fromHandle:limitToPresenceCapable:identifier:error:
sendMessage:toHandles:fromHandle:limitToPresenceCapable:identifier:error:
sendMessageToSelfDevices:limitToPresenceCapable:identifier:error:
tokenURI
deviceToken
deviceTokenForTokenURI:
handleForTokenURI:
isHandleMessageable:completion:
isHandleMessageableForPresence:completion:
isHandleAvailableToMessageFrom:
isFromIDFromSelfAccount:
signPayload:completion:
verifySignedPayload:matchesPayload:fromTokenURI:completion:
T@"<SKAMessagingProvidingDelegate>",W,N
initWithDelegate:serviceIdentifier:pushManager:queue:
service:didHintCheckingTransportLogWithReason:
_keysharingIsDisabledByServer
_selfSharingIsDisabledByServer
service
setService:
pushManager
setPushManager:
serviceIdentifier
setServiceIdentifier:
_service
_pushManager
_serviceIdentifier
T@"IDSService",&,N,V_service
T@"<SKAPushManaging>",&,N,V_pushManager
T@"NSString",&,N,V_serviceIdentifier
T@"<SKAMessagingProvidingDelegate>",W,N,V_delegate
initWithNewKeyMaterial
initWithPrivateKeyMaterial:
signPayload:
publicKeyMaterial
privateKeyMaterial
_generateKey
_generateKeyFromKeyData:
privateKey
setPrivateKey:
_privateKey
T^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v},N,V_privateKey
T@"NSData",R,N
_missingEntitlmentErrorForStatusTypeIdentifier:
_noUsersToShareWithError
_accountNotCapableError
_unableToResolveSenderHandleError
_dateCreatedDriftError
publishStatusRequest:statusTypeIdentifier:completion:
invitedHandlesForStatusTypeIdentifier:completion:
isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:
isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:
inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:
removeInvitedHandles:statusTypeIdentifier:completion:
removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:
registerForDelegateCallbacksWithStatusTypeIdentifier:completion:
publishingServiceClientConnectionWasInvalidated:
publishingServiceClientConnectionWasInterrupted:
initWithXPCConnection:queue:delegate:databaseManager:invitationManager:publishingManager:channelManager:
accountIsStatusKitCapableWithCompletion:
_serverBagNumberForKey:
_serverBagTimeIntervalForKey:withDefaultValue:
_scheduledPublishMaxDelayTime
_unscheduledPublishMaxDelayTime
_randomScheduledPublishDelay
_randomUnscheduledPublishDelay
_secondaryDeviceRepublishMaxDelayTime
_secondaryDeviceRepublishMinDelayTime
_randomSecondaryDeviceRepublishDelay
_delayForStatusPublishRequest:
statusTypeIdenfifier
clientConnection
setClientConnection:
databaseProvider
setDatabaseProvider:
publishingManager
setPublishingManager:
accountIsStatusKitCapable
setAccountIsStatusKitCapable:
accountCheckCompleted
setAccountCheckCompleted:
queue
setQueue:
_accountIsStatusKitCapable
_accountCheckCompleted
_statusTypeIdenfifier
_clientConnection
_databaseProvider
_publishingManager
_queue
T@"SKAStatusPublishingServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusPublishingServiceClientDelegate>",W,N,V_delegate
T@"<SKADatabaseProviding>",&,N,V_databaseProvider
T@"SKAInvitationManager",&,N,V_invitationManager
T@"<SKAStatusPublishingManaging>",&,N,V_publishingManager
TB,N,V_accountIsStatusKitCapable
TB,N,V_accountCheckCompleted
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
T@"NSString",R,C,N,V_statusTypeIdenfifier
_genericMissingSubscriptionEntitlmentError
_inTrafficError
_subscriptionIdentifierNotFoundError:
subscriptionMetadataForHandle:statusTypeIdentifier:completion:
allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:
allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:
allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:
allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:
subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:
retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:
deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:
subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:
validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:
subscriptionServiceClientConnectionWasInvalidated:
subscriptionServiceClientConnectionWasInterrupted:
initWithXPCConnection:queue:delegate:databaseManager:subscriptionManager:encryptionManager:inTrafficMode:
handleRemoteDatabaseChangeForChannels:
handleReceivedStatusUpdate:onChannel:
handleReceivedInvitationForChannel:
_subscriptionMetadataForChannel:
_handlesAssociatedWithChannel:
_currentStatusForChannel:
channelMatchesClientStatusTypeIdentifier:
validatePersonalChannel:matchesSubscriptionValidationToken:fromSender:
validatePersonalChannel:matchesEncryptionValidationToken:fromSender:
_validateChannelIsKnownForSubscriptionIdentifier:statusTypeIdentifier:databaseContext:
subscriptionManager
setSubscriptionManager:
_subscriptionManager
T@"SKAStatusSubscriptionServiceClientConnection",&,N,V_clientConnection
T@"<SKAStatusSubscriptionServiceClientDelegate>",W,N,V_delegate
T@"<SKAStatusSubscriptionManaging>",&,N,V_subscriptionManager
compare:
_noExistingAssertionError
_noExistingChannelError
_keyGenerationError
_payloadGenerationError
_payloadOversizeError
retainPresenceAssertionForPresenceIdentifier:isPersonal:withPresencePayload:client:completion:
releasePresenceAssertionForPresenceIdentifier:isPersonal:client:completion:
releaseAllPresenceAssertionsAssociatedWithClient:completion:
presentDevicesForPresenceIdentifier:isPersonal:completion:
channelReceivedIncomingPayloadUpdate:channel:
findOrCreatePresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
findPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
createPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
initWithDatabaseManager:channelManager:subscriptionManager:accountProvider:messagingProvider:delegate:
_clientPayload:isValidWithError:
_sendPresenceAssertionMessageForChannel:withPayload:isRefresh:completion:
_sendPollingMessageForChannel:completion:
_handleBulkUpdateParticipantPayloads:forChannel:
_sendPresenceDeactivationMessageForChannel:completion:
_handleIncomingPayloadUpdate:onChannel:
_presentDevicesChangedForChannel:
_currentCheckpointForChannel:
_setCheckpointForChannel:checkpoint:
_addPresenceAssertionForClient:presenceIdentifier:isPersonal:payload:
_removePresenceAssertionForClient:presenceIdentifier:
_activePresenceAssertionsForClient:
_addPresentDeviceForChannel:presentDevice:
_removePresentDeviceForChannel:presentDevice:
_activePresentDevicesForChannel:
_clearPresentDevicesForChannel:
_sortAndDedupePresenceIdentifiers:
_recalculateActivityTracking
_activePresenceAssertionsExist
_activePresenceAssertionExistsForPresenceIdentifier:
_currentPayloadForPresenceIdentifier:
_findOrCreatePresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
_findPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
_createPresenceChannelForPresenceIdentifier:isPersonal:databaseContext:completion:
_presencePayloadForChannel:clientPayload:timestamp:completion:
_presentDeviceFromPayload:onChannel:
_mostRecentAssertionTimeForTokenURI:onChannel:
_deviceIdentifierForToken:
_rollChannelForCryptoFailureIfAllowed:
_shouldReassert
_markReassert
_shouldCryptoRoll
_markCryptoRoll
_reassertResetTimeSeconds
_cryptoRollResetTimeSeconds
_maxPayloadSizeBytes
activePresenceAssertionsByClient
setActivePresenceAssertionsByClient:
activeParticipantsByChannel
setActiveParticipantsByChannel:
lastAssertionSendTime
setLastAssertionSendTime:
channelFetchQueue
setChannelFetchQueue:
_activePresenceAssertionsByClient
_activeParticipantsByChannel
_lastAssertionSendTime
_channelFetchQueue
T@"NSMapTable",&,N,V_activePresenceAssertionsByClient
T@"NSMapTable",&,N,V_activeParticipantsByChannel
T@"<SKAPresenceManagingDelegate>",W,N,V_delegate
T@"NSDate",&,N,V_lastAssertionSendTime
T@"NSObject<OS_dispatch_queue>",&,N,V_channelFetchQueue
handleIncomingStatusData:onChannelIdentifier:dateReceived:dateExpired:serverTime:
initWithDatabaseManager:encryptionManager:delegate:
T@"<SKAStatusReceivingManagingDelegate>",W,N,V_delegate
dateCreatedKeyPath
statusUniqueIdentifierKeyPath
predicateForStatusUniqueIdentifier:
sortDescriptorForDateCreatedAscending:
initWithCoreDataChannels:
initWithCoreDataStatus:
initWithCoreDataInvitedUser:
initWithCoreDataReceivedInvitation:
initWithCoreDataPendingPublishRequest:
initWithCoreDataGeneratedEncryptionKey:
initWithCoreDataSubscriptionAssertion:
initWithCoreDataTransientSubscriptionHistory:
initWithCoreDataRemovedUser:
_jwtTokenNotFoundError
_serverResponseError
pushManager:didReceiveData:onChannel:dateReceived:dateExpired:
pushManager:failedToSubscribeToChannel:withError:
createChannelWithCompletion:
createPresenceChannelWithMembershipKey:serverKey:completion:
publishData:onChannel:withChannelToken:publishInitiateTime:isPendingPublish:isScheduledPublish:retryCount:completion:
assertPresence:onChannel:membershipKey:serverKey:timestamp:withChannelToken:isRefresh:completion:
releasePresenceOnChannel:membershipKey:serverKey:timestamp:withChannelToken:completion:
pollActiveParticipantsForChannel:membershipKey:serverKey:withChannelToken:completion:
activeStatusChannelSubscriptionsWithCompletion:
subscribeToStatusChannels:
unsubscribeFromStatusChannels:
activePresenceChannelSubscriptionsWithCompletion:
subscribeToPresenceChannels:
unsubscribeFromPresenceChannels:
enableActivityTracking
disableActivityTracking
serverTime
initWithPushManager:accountProvider:delegate:
_createPayloadDataFromData:
_getPresenceJWTToken
_getStatusJWTToken
_getNonce
T@"<SKAChannelManagingDelegate>",W,N,V_delegate
setRetryIntervalSeconds:
setHasRetryIntervalSeconds:
hasRetryIntervalSeconds
retryIntervalSeconds
_retryIntervalSeconds
TI,N,V_retryIntervalSeconds
initWithInvitationIdentifier:senderHandle:invitedHandle:statusTypeIdentifier:dateInvitationCreated:incomingRatchetState:presenceIdentifier:channelToken:serverKey:peerKey:invitationPayload:
invitationType
senderHandle
invitedHandle
statusTypeIdentifier
peerKey
serverKey
invitationIdentifier
dateInvitationCreated
incomingRatchetState
invitationPayload
_invitationType
_senderHandle
_invitedHandle
_statusTypeIdentifier
_peerKey
_serverKey
_invitationIdentifier
_dateInvitationCreated
_incomingRatchetState
_invitationPayload
Tq,R,N,V_invitationType
T@"NSString",R,N,V_senderHandle
T@"NSString",R,N,V_invitedHandle
T@"NSString",R,N,V_statusTypeIdentifier
T@"NSString",R,N,V_presenceIdentifier
T@"NSData",R,N,V_peerKey
T@"NSData",R,N,V_serverKey
T@"NSString",R,N,V_invitationIdentifier
T@"NSDate",R,N,V_dateInvitationCreated
T@"NSData",R,N,V_incomingRatchetState
T@"NSData",R,N,V_invitationPayload
invitedSKHandle
senderSKHandle
T@"SKHandle",R,N
incomingRatchet
T@"MPStatusKitIncomingRatchet",R,N
skInvitationPayload
T@"SKInvitationPayload",R,N
initWithChannelIdentifier:lastSubscriptionDate:
lastSubscriptionDate
_lastSubscriptionDate
T@"NSString",R,N,V_channelIdentifier
T@"NSDate",R,N,V_lastSubscriptionDate
ska_dictionaryForKey:
ska_dataFrombase64EncodedStringForKey:
ska_dateFromUnixTimestampForKey:
ska_stringForKey:
ska_numberForKey:
initWithKeyMaterial:
encryptPayload:
decryptPayload:
keyMaterial
_initializeNewKeyMaterial
_randomBytesWithLength:error:
keyData
setKeyData:
_keyData
T@"NSData",&,N,V_keyData
statusJwtTokenForPrimaryAccountWithError:
presenceJwtTokenForPrimaryAccountWithError:
refreshCredentialForPrimaryAccountWithCompletion:
_jwtTokenForPrimaryAccountForIdentifier:withError:
_primarySystemiCloudAccountWithError:
_shouldAttemptReauth
_markReauthAttempt
_maxReauthCount
_authResetTime
tokenFetchQueue
setTokenFetchQueue:
_tokenFetchQueue
T@"NSObject<OS_dispatch_queue>",&,N,V_tokenFetchQueue
hasEncryptedParticipantPayload
setServerUpdateTimestampSeconds:
setHasServerUpdateTimestampSeconds:
hasServerUpdateTimestampSeconds
encryptedParticipantPayload
setEncryptedParticipantPayload:
serverUpdateTimestampSeconds
_serverUpdateTimestampSeconds
_encryptedParticipantPayload
T@"NSData",&,N,V_encryptedParticipantPayload
TQ,N,V_serverUpdateTimestampSeconds
hasChannelId
hasChannelToken
channelId
setChannelId:
setChannelToken:
_channelId
T@"NSData",&,N,V_channelId
T@"NSData",&,N,V_channelToken
connection:didReceivePublicToken:
connection:didReceiveToken:forTopic:identifier:
connection:didReceiveToken:forInfo:
connection:didReceiveURLToken:forInfo:
connection:didReceiveURLTokenError:forInfo:
connection:didReceiveIncomingMessage:
connection:didReceiveMessageForTopic:userInfo:
connection:didSendOutgoingMessage:
connection:didFailToSendOutgoingMessage:error:
connection:didChangeConnectedStatus:
connectionDidReconnect:
connection:channelSubscriptionsFailedWithFailures:
systemDidLeaveFirstDataProtectionLock
createChannelWithProtoData:completion:
publishStatus:completion:
sendPresenceMessage:completion:
subscribedStatusChannelsWithCompletion:
subscribedPresenceChannelsWithCompletion:
switchStatusFilterToNonwaking
switchStatusFilterToEnabled
switchPresenceFilterToNonwaking
switchPresenceFilterToEnabled
pushToken
T@"<SKAPushManagingDelegate>",W,N
initWithQueue:systemMonitor:inTrafficMode:
_initializeAPSConnection
_pushEnvironment
_switchFilterToNonwakingForTopic:
_switchFilterToEnabledForTopic:
_subscribeToChannels:forTopic:
_unsubscribeFromChannels:forTopic:
_subscribedChannelsForTopic:WithCompletion:
_sharedChannelsIsDisabledByServer
systemMonitor
setSystemMonitor:
connection
setConnection:
messageDelivery
setMessageDelivery:
_systemMonitor
_connection
_messageDelivery
T@"SKASystemMonitor",&,N,V_systemMonitor
T@"APSConnection",&,N,V_connection
T@"FTMessageDelivery",&,N,V_messageDelivery
T@"<SKAPushManagingDelegate>",W,N,V_delegate
initWithChannelIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:uniqueIdentifier:
isExpired
dateReceived
dateExpired
rawData
uniqueIdentifier
_dateCreated
_datePublished
_dateReceived
_dateExpired
_rawData
_uniqueIdentifier
T@"NSString",R,C,N,V_channelIdentifier
T@"NSDate",R,C,N,V_dateCreated
T@"NSDate",R,C,N,V_datePublished
T@"NSDate",R,C,N,V_dateReceived
T@"NSDate",R,C,N,V_dateExpired
T@"NSData",R,N,V_rawData
T@"NSString",R,C,N,V_uniqueIdentifier
hasChannelIdentity
channelIdentity
setChannelIdentity:
_channelIdentity
T@"ChannelIdentity",&,N,V_channelIdentity
setClientTimestampSeconds:
setHasClientTimestampSeconds:
hasClientTimestampSeconds
clientTimestampSeconds
_clientTimestampSeconds
TQ,N,V_clientTimestampSeconds
_tooManySubscriptionsError
retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:
releaseAllTransientSubscriptionAssertionsAssociatedWithClient:completion:
retainPresenceSubscriptionAssertionForSubscriptionIdentifier:client:completion:
releasePresenceSubscriptionAssertionForSubscriptionIdentifier:client:completion:
releaseAllPresenceSubscriptionAssertionsAssociatedWithClient:completion:
updateRegisteredSubscriptionsForActiveAssertionsWithCompletion:
allSubscriptionIdentifiersWithActiveAssertionsForStatusTypeIdentifier:completion:
allStatusSubscriptionIdentifiersWithActiveSubscriptionsWithCompletion:
activePresenceSubscriptionAssertionsExistForChannelIdentifier:
initWithDatabaseManager:channelManager:pushManager:
_addTransientSubscriptionAssertionForClient:subscriptionIdentifier:
_addPresenceSubscriptionAssertionForClient:subscriptionIdentifier:
_markCacheSubscriptionDateForChannelIdentifier:
_removeTransientSubscriptionAssertionForClient:subscriptionIdentifier:
_removePresenceSubscriptionAssertionForClient:subscriptionIdentifier:
_activePresenceSubscriptionsForClient:
_activeTransientSubscriptionsForClient:
_sortAndDedupeSubscriptionIdentifiers:
_enforceSubscriptionsHardCapOnSubscriptionIdentifiers:
_fetchAllClientActiveSubscriptionAssertions
_fetchAllActiveSubscriptionAssertionsWithCache
_fetchAllActivePresenceSubscriptions
_recentlyReleasedTransientSubscriptionAssertionIdentifiersExcludingSubscriptionIdentifiers:count:presenceCount:databaseContext:
_allPersonalChannelIdentifiersRequiringSelfSubscriptionWithDatabaseContext:
_statusTypeIdentifiersRequiringSelfSubscription
_activeTransientAssertionsExist
_filterSubscriptionIdentifierToStatus:
_filterSubscriptionIdentifierToPresence:
_maxSubscriptionCacheCount
_maxPresenceSubscriptionCacheCount
_hardMaxSubscriptionCount
_subscriptionTTL
activeTransientSubscriptionsByClient
setActiveTransientSubscriptionsByClient:
activePresenceSubscriptionsByClient
setActivePresenceSubscriptionsByClient:
_activeTransientSubscriptionsByClient
_activePresenceSubscriptionsByClient
T@"NSMapTable",&,N,V_activeTransientSubscriptionsByClient
T@"NSMapTable",&,N,V_activePresenceSubscriptionsByClient
isEqualToTransientSubscription:
hasSimpleJwt
setSimpleJwt:
hasSharedOwnershipAuth
setSharedOwnershipAuth:
authCredentialOneof
setAuthCredentialOneof:
setHasAuthCredentialOneof:
hasAuthCredentialOneof
authCredentialOneofAsString:
StringAsAuthCredentialOneof:
clearOneofValuesForAuthCredentialOneof
simpleJwt
sharedOwnershipAuth
_authCredentialOneof
_sharedOwnershipAuth
_simpleJwt
T@"NSString",&,N,V_simpleJwt
T@"SharedOwnershipAuth",&,N,V_sharedOwnershipAuth
Ti,N,V_authCredentialOneof
hasChannelPublishPayload
channelPublishPayload
setChannelPublishPayload:
_channelPublishPayload
T@"ChannelPublishPayload",&,N,V_channelPublishPayload
setPublishInitiateTimestampMillis:
setHasPublishInitiateTimestampMillis:
hasPublishInitiateTimestampMillis
hasPublishPayload
setPublishPayloadExpiryTtlMillis:
setHasPublishPayloadExpiryTtlMillis:
hasPublishPayloadExpiryTtlMillis
pushPriority
setPushPriority:
setHasPushPriority:
hasPushPriority
pushPriorityAsString:
StringAsPushPriority:
setPendingPublishHint:
setHasPendingPublishHint:
hasPendingPublishHint
setScheduledPublishHint:
setHasScheduledPublishHint:
hasScheduledPublishHint
setRetryCount:
setHasRetryCount:
hasRetryCount
publishInitiateTimestampMillis
publishPayload
setPublishPayload:
publishPayloadExpiryTtlMillis
pendingPublishHint
scheduledPublishHint
retryCount
_publishInitiateTimestampMillis
_publishPayloadExpiryTtlMillis
_publishPayload
_pushPriority
_retryCount
_pendingPublishHint
_scheduledPublishHint
TQ,N,V_publishInitiateTimestampMillis
T@"NSData",&,N,V_publishPayload
TQ,N,V_publishPayloadExpiryTtlMillis
Ti,N,V_pushPriority
TB,N,V_pendingPublishHint
TB,N,V_scheduledPublishHint
TI,N,V_retryCount
sharedInstance
listener:shouldAcceptNewConnection:
databaseDidReceiveRemoteChangesForChannels:
service:didReceiveIncomingMessage:fromID:toID:messageGuid:
service:outgoingMessageWithIdentifier:fromID:toID:didSendWithSuccess:
networkBecameReachable
channelManager:didReceiveData:onChannel:dateReceived:dateExpired:
channelManager:failedToSubscribeToChannel:withError:
statusReceivingManager:didReceiveStatusUpdate:onChannel:
databaseManager:didCreateChannel:
invitationManager:didReceiveInvitation:forChannel:
invitationManager:didRevokeInvitationOnChannel:
publishingServiceClientWasInvalidated:
subscriptionServiceClientWasInvalidated:
presenceClientWasInvalidated:
presenceManager:didReceivePresentDevicesUpdateForPresenceIdentifier:
presenceManager:didCreateChannel:
presenceManager:didRequestToRollChannel:
shutdown
logState
_publishingServiceListener:shouldAcceptNewConnection:
_presenceServiceListener:shouldAcceptNewConnection:
_subscriptionServiceListener:shouldAcceptNewConnection:
donateReceivedStatusToBiomeOnChannel:
_senderHandlesForChannel:
_shouldDonateToBiomeForStatusTypeIdentifier:
_notifyPresenceClientsIfNeededOfChannelChangeForChannel:
_kettleFeatureEnabled
_inTextTrafficMode
_setupMaintenanceActivity
publishingServiceListener
setPublishingServiceListener:
publishingServiceConnectionQueue
setPublishingServiceConnectionQueue:
publishingServiceConnectedClients
setPublishingServiceConnectedClients:
subscriptionServiceListener
setSubscriptionServiceListener:
subscriptionServiceConnectionQueue
setSubscriptionServiceConnectionQueue:
subscriptionServiceConnectedClients
setSubscriptionServiceConnectedClients:
presenceListener
setPresenceListener:
presenceConnectionQueue
setPresenceConnectionQueue:
presenceConnectedClients
setPresenceConnectedClients:
invitationManagerMessagingQueue
setInvitationManagerMessagingQueue:
invitationMessagingProvider
setInvitationMessagingProvider:
statusReceivingManager
setStatusReceivingManager:
_publishingServiceListener
_publishingServiceConnectionQueue
_publishingServiceConnectedClients
_subscriptionServiceListener
_subscriptionServiceConnectionQueue
_subscriptionServiceConnectedClients
_presenceListener
_presenceConnectionQueue
_presenceConnectedClients
_invitationManagerMessagingQueue
_invitationMessagingProvider
_statusReceivingManager
T@"NSXPCListener",&,N,V_publishingServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_publishingServiceConnectionQueue
T@"NSMutableArray",&,N,V_publishingServiceConnectedClients
T@"NSXPCListener",&,N,V_subscriptionServiceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_subscriptionServiceConnectionQueue
T@"NSMutableArray",&,N,V_subscriptionServiceConnectedClients
T@"NSXPCListener",&,N,V_presenceListener
T@"NSObject<OS_dispatch_queue>",&,N,V_presenceConnectionQueue
T@"NSMutableArray",&,N,V_presenceConnectedClients
T@"NSObject<OS_dispatch_queue>",&,N,V_invitationManagerMessagingQueue
T@"<SKAMessagingProviding>",&,N,V_invitationMessagingProvider
T@"<SKAStatusReceivingManaging>",&,N,V_statusReceivingManager
initWithHandle:statusTypeIdentifier:presenceIdentifier:dateRemoved:
handle
dateRemoved
_handle
_dateRemoved
T@"NSString",R,N,V_handle
T@"NSDate",R,N,V_dateRemoved
handlePersistentStoreRemoteChangeNotification:
newBackgroundContext
deviceToDeviceEncryptedDatabaseCapableWithCompletion:
databaseHasBeenCreated
initWithDelegate:
persistentContainer
createPersistentContainer
appTransactionAuthorName
containerName
ckContainerIdentifier
ckContainer
createCkContainer
fileManager
databaseDirectoryURL
localDatabaseFileURL
cloudDatabaseFileURL
lastProcessedPersistentHistoryTokenFileURL
localPersistentStoreDescription
cloudPersistentStoreDescription
processPersistentStoreRemoteChanges
extractModifiedChannelFromPersistentStoreRemoteChangeForChannel:managedObjectContext:
extractModifiedChannelFromPersistentStoreRemoteChangeForReceivedInvitation:managedObjectContext:
existingManagedObjectWithID:managedObjectContext:
lastProcessedPersistentHistoryToken
setLastProcessedPersistentHistoryToken:
overrideDeviceEncryptionCheck
historyProcessingQueue
setHistoryProcessingQueue:
setPersistentContainer:
setCkContainer:
_historyProcessingQueue
_persistentContainer
_ckContainer
T@"NSObject<OS_dispatch_queue>",&,N,V_historyProcessingQueue
T@"NSPersistentContainer",&,N,V_persistentContainer
T@"CKContainer",&,N,V_ckContainer
T@"<SKADatabaseProvidingDelegate>",W,N,V_delegate
initWithOriginalOutgoingRatchetState:dateGenerated:
originalOutgoingRatchetState
dateGenerated
_originalOutgoingRatchetState
_dateGenerated
T@"NSData",R,N,V_originalOutgoingRatchetState
T@"NSDate",R,N,V_dateGenerated
outgoingRatchet
dateInvitationCreatedKeyPath
senderHandleKeyPath
predicateForSenderHandle:
predicateForSenderHandleString:
sortDescriptorForDateInvitationCreatedOrderedAscending:
sortDescriptorForSenderHandleOrderedAscending:
dateGeneratedKeyPath
idsDestination
normalizedHandleString
isNormalizedEqualToHandle:
clientIsEntitledForAtLeastOneSubscriptionServiceType:
_connection:isEntitledForSubscriptionWithStatusTypeIdentifier:
clientIsEntitledForAtLeastOneSubscriptionServiceType
clientIsEntitledForSubscriptionWithStatusTypeIdentifier:
T@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
setCurrentVersion:
setHasCurrentVersion:
hasCurrentVersion
setPrevVersion:
setHasPrevVersion:
hasPrevVersion
hasEncryptedUpdatePayload
currentVersion
prevVersion
encryptedUpdatePayload
setEncryptedUpdatePayload:
_currentVersion
_prevVersion
_encryptedUpdatePayload
TQ,N,V_currentVersion
TQ,N,V_prevVersion
T@"NSData",&,N,V_encryptedUpdatePayload
hasPayload
hasSignature
signature
setSignature:
_signature
T@"DecryptedParticipantPayload",&,N,V_payload
T@"NSData",&,N,V_signature
updateType
setUpdateType:
setHasUpdateType:
hasUpdateType
updateTypeAsString:
StringAsUpdateType:
hasPadding
padding
setPadding:
_padding
_updateType
Ti,N,V_updateType
T@"NSData",&,N,V_padding
applicationIdentifierKeyPath
predicateForApplicationIdentifier:
requestFlag
setRequestFlag:
setHasRequestFlag:
hasRequestFlag
requestFlagAsString:
StringAsRequestFlag:
_requestFlag
Ti,N,V_requestFlag
initWithStatusPayload:invitation:
statusPayload
invitation
_statusPayload
_invitation
T@"SKStatusPayload",R,N,V_statusPayload
T@"SKADatabaseReceivedInvitation",R,N,V_invitation
initWithInvitedHandle:senderHande:invitationPayloadData:dateInvitationPayloadCreated:
invitationPayloadData
dateInvitationPayloadCreated
_invitationPayloadData
_dateInvitationPayloadCreated
T@"NSData",R,N,V_invitationPayloadData
T@"NSDate",R,N,V_dateInvitationPayloadCreated
existingPersonalChannelForStatusTypeIdentifier:databaseContext:
existingChannelForSubscriptionIdentifier:databaseContext:
existingChannelForPresenceIdentifier:isPersonal:databaseContext:
existingChannelForHandle:statusTypeIdentifier:databaseContext:
allExistingChannelsForHandle:statusTypeIdentifier:databaseContext:
allExistingChannelsForStatusTypeIdentifier:includingPersonalChannel:databaseContext:
createPersonalChannelForStatusTypeIdentifier:channelIdentifier:channelToken:databaseContext:
createPresenceChannelForPresenceIdentifier:channelIdentifier:channelToken:peerKey:serverKey:membershipKey:creationDate:isPersonal:databaseContext:
deletePersonalChannelForStatusTypeIdentifier:databaseContext:
createChannelForStatusTypeIdentifier:channelIdentifier:databaseContext:
updatePersonalChannel:withCurrentOutgoingRatchetState:databaseContext:
decomissionAllPersonalChannelsWithStatusTypeIdentifier:databaseContext:
decomissionChannelWithIdentifier:databaseContext:
createGeneratedEncryptionKeyWithOriginalOutgoingRatchetState:personalChannel:databaseContext:
generatedEncryptionKeysForPersonalChannel:databaseContext:
allPersistentSubscriptionAssertionChannelIdentifiersWithDatabaseContext:
existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
createSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:statusTypeIdentifier:databaseContext:
deleteSubscriptionAssertionWithSubscriptionIdentifier:applicationIdentifier:databaseContext:
createOrUpdateTransientSubscriptionHistoryForChannelIdentifier:lastSubscriptionDate:databaseContext:
existingRecentTransientSubscriptionHistoriesWithLimit:databaseContext:
existingInvitedUsersForInvitedHandle:onChannel:databaseContext:
updateInvitationPayload:onExistingInvitedUser:channel:databaseContext:
createInvitedUserWithHandle:senderHandle:invitationPayload:channel:databaseContext:
copyInvitedUsersFromChannel:toChannel:databaseContext:
deleteInvitedUserForHandle:personalChannel:databaseContext:
deleteInvitedUserForHandle:presenceChannel:databaseContext:
deleteAllInvitedUsersForPersonalChannel:databaseContext:
existingInvitedUsersForPersonalChannel:databaseContext:
createStatusWithUniqueIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:channelIdentifier:databaseContext:
existingStatusForChannel:databaseContext:
existingStatusForUniqueIdentifier:databaseContext:
cleanupOldStatusUpdatesForChannelIdentifier:excludingStatusUniqueIdentifier:databaseContext:
createPendingPublishRequestWithUniqueIdentifier:dateCreated:payloadData:statusTypeIdentifier:databaseContext:
existingPendingPublishRequestsWithDatabaseContext:
existingPendingPublishRequestForUniqueIdentifier:withDatabaseContext:
existingPendingPublishRequestsForStatusTypeIdentifier:withDatabaseContext:
incrementPendingPublishRequestRetryCountWithUniqueIdentifier:databaseContext:
deletePendingPublishRequestWithWithUniqueIdentifier:databaseContext:
createRemovedUserWithHandle:dateRemoved:statusTypeIdentifier:databaseContext:
existingRemovedUserWithHandle:statusTypeIdentifier:withDatabaseContext:
deleteRemovedUserWithHandle:statusTypeIdentifier:databaseContext:
createRemovedUserWithHandle:dateRemoved:presenceIdentifier:databaseContext:
existingRemovedUserWithHandle:presenceIdentifier:withDatabaseContext:
deleteRemovedUserWithHandle:presenceIdentifier:databaseContext:
currentCheckpointForChannel:databaseContext:
setCurrentCheckpointForChannel:checkpoint:databaseContext:
createReceivedInvitationForChannel:senderHandle:invitedHandle:invitationIdentifier:dateInvitationCreated:incomingRatchetState:presenceIdentifier:channelToken:serverKey:peerKey:invitationPayload:databaseContext:
receivedInvitationsForChannel:databaseContext:
cleanupOldReceivedInvitationsForChannelIdentifier:excludingInvitation:databaseContext:
cleanupDecommisionedChannelsWithDatabaseContext:
cleanupOldChannelsForHandle:statusTypeIdentifier:databaseContext:
initWithDatabaseProvider:delegate:
_existingPersonalChannelForStatusTypeIdentifier:databaseContext:
_existingDecomissionedPersonalChannelsWithDatabaseContext:
_existingPersonalChannelsForStatusTypeIdentifier:databaseContext:
_existingChannelsForDatabaseChannel:databaseContext:
_existingPersonalChannelForDatabaseChannel:databaseContext:
_existingChannelsForChannelIdentifier:isPersonal:databaseContext:
_existingChannelsForChannelIdentifier:databaseContext:
_existingChannelsForPresenceIdentifier:isPersonal:databaseContext:
_existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:
_existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:
_existingTransientSubscriptionHistoryForChannelIdentifier:databaseContext:
_existingTransientSubscriptionHistoryWithLimit:orderedByLastSubscriptionDateAscending:databaseContext:
_existingInvitedUsersForDatabaseInvitedUser:databaseChannel:databaseContext:
_existingInvitedUsersForInvitedHandle:channel:databaseContext:
_existingChannelCheckpointForChannelIdentifier:databaseContext:
_existingPendingPublishRequestForUniqueIdentifier:databaseContext:
_existingPendingPublishRequestsForStatusTypeIdentifier:databaseContext:
_existingPendingPublishRequestsWithDatabaseContext:
_existingRemovedUsersForHandle:statusTypeIdentifier:databaseContext:
_existingRemovedUsersForHandle:presenceIdentifier:databaseContext:
_existingReceivedInvitationsForHandle:statusTypeIdentifier:databaseContext:
_existingReceivedInvitationsForChannelIdentifier:sortedByDateReceived:databaseContect:
T@"<SKADatabaseProviding>",R,N,V_databaseProvider
T@"<SKADatabaseManagingDelegate>",R,W,N,V_delegate
datePublishedKeyPath
uniqueIdentifierKeyPath
sortDescriptorForDatePublishedAscending:
sk_stringArrayValueForEntitlement:
sk_booleanValueForEntitlement:
sk_stringValueForEntitlement:
initWithChannelIdentifier:statusTypeIdentifier:applicationIdentifier:
applicationIdentifier
_applicationIdentifier
T@"NSString",R,N,V_applicationIdentifier
ska_hexString
_noChannelError
_noChannelCreatedError
_noClientIDError
_crossAccountError
oversizeLogger
invitedHandlesForPresenceIdentifier:completion:
presentDevicesForPresenceIdentifier:completion:
isHandleInvited:fromSenderHandle:forPresenceIdentifier:completion:
inviteHandles:fromSenderHandle:presenceIdentifier:completion:
removeInvitedHandles:presenceIdentifier:completion:
retainTransientSubscriptionAssertionForPresenceIdentifier:completion:
releaseTransientSubscriptionAssertionForPresenceIdentifier:completion:
assertPresenceForIdentifier:withPresencePayload:completion:
releasePresenceForIdentifier:completion:
fetchPresenceCapability:
registerForDelegateCallbacksWithPresenceIdentifier:isPersonal:completion:
presenceClientConnectionWasInvalidated:
presenceClientConnectionWasInterrupted:
initWithXPCConnection:queue:delegate:subscriptionManager:presenceManager:invitationManager:databaseManager:
clientPrefixedPresenceIdentifierForPresenceIdentifier:
rawPresenceIdentifierForPrefixedPresenceIdentifier:
_shortHashOfClientID:
accountIsPresenceCapableWithCompletion:
presenceIdentifierMatchesClient:
handleReceivedPresentDevicesUpdateForPresenceIdentifier:
handleReceivedInvitationForPresenceIdentifier:
refreshAssertionsForPresenceIdentifier:
presenceIdenfifier
accountIsPresenceCapable
setAccountIsPresenceCapable:
activeSubscription
setActiveSubscription:
activeSubscriptionIdentifier
setActiveSubscriptionIdentifier:
activeAssertion
setActiveAssertion:
lastSeenPresentDevices
setLastSeenPresentDevices:
currentPayload
setCurrentPayload:
_accountIsPresenceCapable
_activeSubscription
_activeAssertion
_presenceIdenfifier
_activeSubscriptionIdentifier
_lastSeenPresentDevices
_currentPayload
T@"SKAPresenceClientConnection",&,N,V_clientConnection
T@"<SKAPresenceClientDelegate>",W,N,V_delegate
TB,N,V_accountIsPresenceCapable
TB,N,V_activeSubscription
T@"NSString",&,N,V_activeSubscriptionIdentifier
TB,N,V_activeAssertion
T@"NSSet",&,N,V_lastSeenPresentDevices
T@"SKPresencePayload",&,N,V_currentPayload
T@"NSString",R,C,N,V_presenceIdenfifier
initWithStatusTypeIdentifier:dateCreated:payloadData:statusUniqueIdentifier:retryCount:
payloadData
_payloadData
_statusUniqueIdentifier
T@"NSString",R,C,N,V_statusTypeIdentifier
T@"NSData",R,N,V_payloadData
T@"NSString",R,C,N,V_statusUniqueIdentifier
Tq,R,N,V_retryCount
ska_appearsToBeEmail
ska_sha256Hash
hasActivationResponse
setActivationResponse:
hasDeactivationResponse
setDeactivationResponse:
hasPollingResponse
setPollingResponse:
response
setResponse:
setHasResponse:
hasResponse
responseAsString:
StringAsResponse:
clearOneofValuesForResponse
activationResponse
deactivationResponse
pollingResponse
_activationResponse
_deactivationResponse
_pollingResponse
_response
T@"ChannelActivityActivationResponse",&,N,V_activationResponse
T@"ChannelActivityDeactivationResponse",&,N,V_deactivationResponse
T@"ChannelActivityPollingResponse",&,N,V_pollingResponse
Ti,N,V_response
hasChannelPublicKey
hasNonce
hasSignNonce
hasServerEncryptionKey
channelPublicKey
setChannelPublicKey:
nonce
setNonce:
signNonce
setSignNonce:
serverEncryptionKey
setServerEncryptionKey:
_channelPublicKey
_nonce
_serverEncryptionKey
_signNonce
T@"NSData",&,N,V_channelPublicKey
T@"NSData",&,N,V_nonce
T@"NSData",&,N,V_signNonce
T@"NSData",&,N,V_serverEncryptionKey
_clientIDForConnection:
clientID
T@"<SKAPresenceClientConnectionLifecycleDelegate>",W,N,V_connectionLifecycleDelegate
T@"NSString",R
setActivationExpirySeconds:
setHasActivationExpirySeconds:
hasActivationExpirySeconds
activationExpirySeconds
_activationExpirySeconds
TI,N,V_activationExpirySeconds
invitedHandleKeyPath
channelKeyPath
predicateForInvitedHandle:
predicateForChannel:
addListener:
removeListener:
isUnderFirstDataProtectionLock
_listenForKeyBagChangeNotifications
_deviceStillUnderFirstLock
_updateLockState
_deliverNotificationSelectorToListeners:
ivarLock
setIvarLock:
underFirstLock
setUnderFirstLock:
listeners
setListeners:
_underFirstLock
_ivarLock
_listeners
T{os_unfair_lock_s=I},N,V_ivarLock
TB,N,V_underFirstLock
T@"NSHashTable",&,N,V_listeners
hasActivationRequest
setActivationRequest:
hasDeactivationRequest
setDeactivationRequest:
hasPollingRequest
setPollingRequest:
request
setRequest:
setHasRequest:
hasRequest
requestAsString:
StringAsRequest:
clearOneofValuesForRequest
activationRequest
deactivationRequest
pollingRequest
_activationRequest
_deactivationRequest
_pollingRequest
_request
T@"ChannelActivityActivationRequest",&,N,V_activationRequest
T@"ChannelActivityDeactivationRequest",&,N,V_deactivationRequest
T@"ChannelActivityPollingRequest",&,N,V_pollingRequest
Ti,N,V_request
fetchRequest
T@"NSData",&,D,N
Ts,D,N
T@"NSDate",C,D,N
TB,D,N
T@"NSString",C,D,N
membershipKey
generatedEncryptionKeys
T@"NSSet",&,D,N
receivedInvitations
channelID
checkpoint
Tq,D,N
channel
T@"Channel",&,D,N
Ti,D,N
removedHandle
@16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@56@0:8@16@24@32@40@48
@24@0:8@16
@32@0:8@16@24
@"NSData"56@0:8@"SKStatusPayload"16@"NSString"24@"NSDate"32@"NSDate"40@"SKADatabaseChannel"48
@"SKAStatusUnencryptedEnvelope"24@0:8@"NSData"16
@"SKADecryptedStatusPayload"32@0:8@"NSData"16@"SKADatabaseChannel"24
@"NSString"24@0:8@"SKADatabaseChannel"16
@44@0:8@16S24@28@36
@44@0:8@16@24S32@36
v16@0:8
@"<SKADatabaseManaging>"
@"<SKAInvitationManaging>"
v24@0:8@16
@"NSDictionary"
@40@0:8@16@24@32
@"SKHandle"
@"NSString"
v56@0:8@16@24@32@40@?48
v48@0:8@16@24@32@?40
v36@0:8@16B24@?28
v40@0:8@16@24@?32
v32@0:8@16@?24
v56@0:8@16@24@32@40@48
v44@0:8@16@24@32B40
B32@0:8@16^@24
v56@0:8@"NSString"16@"NSArray"24@"SKHandle"32@"SKInvitationPayload"40@?<v@?B@"NSError">48
v48@0:8@"NSString"16@"NSArray"24@"SKHandle"32@?<v@?B@"NSError">40
v36@0:8@"NSString"16B24@?<v@?B@"NSError">28
v40@0:8@"NSString"16@"NSArray"24@?<v@?@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSError">24
v56@0:8@"NSDictionary"16@"SKHandle"24@"NSString"32@"SKHandle"40@"NSString"48
v44@0:8@"NSString"16@"SKHandle"24@"SKHandle"32B40
B32@0:8@"NSString"16^@24
v32@0:8@"NSString"16@?<v@?B>24
v36@0:8@"NSString"16B24@?<v@?B>28
v40@0:8@"SKHandle"16@"SKHandle"24@?<v@?B@"NSError">32
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?@"SKHandleInvitability"@"NSError">40
@"SKHandle"24@0:8@"SKHandle"16
@"<SKAInvitationManagingDelegate>"16@0:8
v24@0:8@"<SKAInvitationManagingDelegate>"16
@60@0:8@16@24@32@40@48B56
B40@0:8@16@24^@32
B48@0:8@16@24@32^@40
@48@0:8@16@24^B32^@40
@48@0:8@16@24@32@40
v20@0:8B16
@"<SKAInvitationManagingDelegate>"
@"<SKAMessagingProviding>"
@"<SKAChannelManaging>"
@"<SKAAccountProviding>"
@"<SKAPresenceManaging>"
@"NSObject<OS_dispatch_queue>"
@"NSMutableDictionary"
@20@0:8B16
@36@0:8@16B24@28
@"SKPresencePayload"
@"NSObject<OS_os_activity>"
@24@0:8^{_NSZone=}16
i16@0:8
v20@0:8i16
@20@0:8i16
i24@0:8@16
@"AuthCredential"
{?="channelOwnershipType"b1}
v24@0:8Q16
@"NSData"
{?="timestamp"b1}
B32@0:8@16@24
@24@0:8@?16
@"NSXPCConnection"
@"<SKAStatusPublishingServiceClientConnectionLifecycleDelegate>"
@24@0:8Q16
v20@0:8I16
I16@0:8
@"NSMutableArray"
{?="serverTimestampSeconds"b1"version"b1"responseMessageIndex"b1"status"b1"totalResponseMessages"b1}
v52@0:8@16@24d32B40@?44
v32@0:8@16@24
v24@0:8q16
v52@0:8@"SKStatusPublishRequest"16@"NSString"24d32B40@?<v@?@"NSString"@"NSError">44
v32@0:8@"NSString"16@"SKStatusPublishRequest"24
v60@0:8@16@24d32B40Q44@?52
v24@0:8d16
v40@0:8@16@24@32
d16@0:8
q16@0:8
@"<SKAStatusEncryptionManaging>"
@112@0:8@16q24@32B40B44@48@56@64@72@80@88@96@104
@"NSDate"
@"NSArray"
v64@0:8@16@24@32@40@48@56
v56@0:8@16@24q32@40@48
v52@0:8@16@24@32B40@44
v60@0:8@16@24@32B40@44@52
v56@0:8@16@24@32q40q48
v48@0:8@16@24@32@40
v64@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"NSString"48@"IDSMessageContext"56
v40@0:8@"IDSService"16@"NSString"24@"NSArray"32
v56@0:8@"IDSService"16@"IDSAccount"24@"NSDictionary"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSProtobuf"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSString"40@"IDSMessageContext"48
v64@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSDictionary"40@"NSString"48@"IDSMessageContext"56
v56@0:8@"IDSService"16@"IDSAccount"24q32@"NSString"40@"IDSMessageContext"48
v32@0:8@"IDSService"16@"NSSet"24
v32@0:8@"IDSService"16@"NSArray"24
v52@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44
v60@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44@"IDSMessageContext"52
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32q40q48
v48@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@40
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@"NSString"40@48
v48@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSDictionary"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSData"48
v40@0:8@"IDSService"16@"IDSAccount"24@"IDSGroupSessionParticipantUpdate"32
v48@0:8@"IDSService"16@"IDSAccount"24@"IDSGroupSessionParticipantUpdate"32@"IDSMessageContext"40
v24@0:8@"IDSService"16
v40@0:8@"IDSService"16@"IDSDevice"24@?<v@?>32
B60@0:8@16@24@32B40^@44^@52
B44@0:8@16B24^@28^@36
B60@0:8@"NSDictionary"16@"SKHandle"24@"SKHandle"32B40^@44^@52
B60@0:8@"NSDictionary"16@"NSArray"24@"SKHandle"32B40^@44^@52
B44@0:8@"NSDictionary"16B24^@28^@36
@"NSData"16@0:8
@"NSData"24@0:8@"NSString"16
@"SKHandle"24@0:8@"NSString"16
v32@0:8@"SKHandle"16@?<v@?B>24
B24@0:8@"SKHandle"16
B24@0:8@"NSString"16
v32@0:8@"NSData"16@?<v@?@"NSError"@"NSData">24
v48@0:8@"NSData"16@"NSData"24@"NSString"32@?<v@?@"NSError"B>40
@"<SKAMessagingProvidingDelegate>"16@0:8
v24@0:8@"<SKAMessagingProvidingDelegate>"16
v32@0:8@16q24
@"<SKAMessagingProvidingDelegate>"
@"IDSService"
@"<SKAPushManaging>"
^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v}16@0:8
v24@0:8^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v}16
^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v}
v40@0:8@"SKStatusPublishRequest"16@"NSString"24@?<v@?@"NSString"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSArray"@"NSError">24
v48@0:8@"SKHandle"16@"SKHandle"24@"NSString"32@?<v@?B@"NSError">40
v56@0:8@"NSArray"16@"SKHandle"24@"SKInvitationPayload"32@"NSString"40@?<v@?@"NSError">48
v40@0:8@"NSArray"16@"NSString"24@?<v@?@"NSError">32
v24@0:8@"SKAStatusPublishingServiceClientConnection"16
@72@0:8@16@24@32@40@48@56@64
v24@0:8@?16
d32@0:8@16d24
d24@0:8@16
@"SKAStatusPublishingServiceClientConnection"
@"<SKAStatusPublishingServiceClientDelegate>"
@"<SKADatabaseProviding>"
@"SKAInvitationManager"
@"<SKAStatusPublishingManaging>"
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSArray"@"NSError">28
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSArray"@"NSError">32
v32@0:8@"NSString"16@?<v@?@"SKStatusSubscriptionMetadata"@"NSError">24
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError">32
v48@0:8@"NSString"16@"NSString"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"SKHandle"16@"NSString"24@?<v@?@"SKSubscriptionValidationTokens"@"NSError">32
v48@0:8@"SKSubscriptionValidationTokens"16@"SKHandle"24@"NSString"32@?<v@?q@"NSError">40
v24@0:8@"SKAStatusSubscriptionServiceClientConnection"16
@68@0:8@16@24@32@40@48@56B64
q40@0:8@16@24@32
B40@0:8@16@24@32
@"SKAStatusSubscriptionServiceClientConnection"
@"<SKAStatusSubscriptionServiceClientDelegate>"
@"<SKAStatusSubscriptionManaging>"
v52@0:8@16B24@28@36@?44
v44@0:8@16B24@28@?36
v52@0:8@"NSString"16B24@"SKPresencePayload"28@"<SKAClientConnectionRepresentable>"36@?<v@?@"NSError">44
v44@0:8@"NSString"16B24@"<SKAClientConnectionRepresentable>"28@?<v@?@"NSError">36
v32@0:8@"<SKAClientConnectionRepresentable>"16@?<v@?@"NSError">24
v32@0:8@"NSData"16@"SKADatabaseChannel"24
v44@0:8@"NSString"16B24@"NSManagedObjectContext"28@?<v@?@"SKADatabaseChannel"@"NSError">36
@64@0:8@16@24@32@40@48@56
v44@0:8@16@24B32@?36
Q24@0:8@16
v32@0:8@16Q24
B44@0:8@16@24B32@36
@"NSMapTable"
@"<SKAPresenceManagingDelegate>"
v56@0:8@"NSData"16@"NSString"24@"NSDate"32@"NSDate"40@"NSDate"48
@"<SKAStatusReceivingManagingDelegate>"
v56@0:8@"<SKAPushManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAPushManaging>"16@"NSString"24@"NSError"32
v72@0:8@16@24@32@40B48B52Q56@?64
v76@0:8@16@24@32@40@48@56B64@?68
v64@0:8@16@24@32@40@48@?56
v24@0:8@?<v@?@"NSString"@"NSData"@"NSError">16
v40@0:8@"SKAPresenceMembershipKey"16@"SKAPresenceEncryptionKey"24@?<v@?@"NSString"@"NSData"@"NSError">32
v72@0:8@"NSData"16@"NSString"24@"NSData"32@"NSDate"40B48B52Q56@?<v@?@"NSError">64
v76@0:8@"NSData"16@"NSString"24@"SKAPresenceMembershipKey"32@"SKAPresenceEncryptionKey"40@"NSDate"48@"NSData"56B64@?<v@?@"NSError"dQ@"NSArray">68
v64@0:8@"NSString"16@"SKAPresenceMembershipKey"24@"SKAPresenceEncryptionKey"32@"NSDate"40@"NSData"48@?<v@?@"NSError">56
v56@0:8@"NSString"16@"SKAPresenceMembershipKey"24@"SKAPresenceEncryptionKey"32@"NSData"40@?<v@?@"NSError"Q@"NSArray">48
v24@0:8@?<v@?@"NSArray">16
v24@0:8@"NSArray"16
@"NSDate"16@0:8
@"<SKAChannelManagingDelegate>"
{?="retryIntervalSeconds"b1"status"b1}
@104@0:8@16@24@32@40@48@56@64@72@80@88@96
@32@0:8Q16^@24
@24@0:8^@16
@"NSString"24@0:8^@16
v24@0:8@?<v@?B@"NSError">16
@32@0:8@16^@24
{?="serverUpdateTimestampSeconds"b1}
v28@0:8@16B24
v32@0:8@"APSConnection"16@"NSData"24
v48@0:8@"APSConnection"16@"NSData"24@"NSString"32@"NSString"40
v40@0:8@"APSConnection"16@"NSData"24@"APSAppTokenInfo"32
v40@0:8@"APSConnection"16@"APSURLToken"24@"APSURLTokenInfo"32
v40@0:8@"APSConnection"16@"NSError"24@"APSURLTokenInfo"32
v32@0:8@"APSConnection"16@"APSIncomingMessage"24
v40@0:8@"APSConnection"16@"NSString"24@"NSDictionary"32
v32@0:8@"APSConnection"16@"APSOutgoingMessage"24
v40@0:8@"APSConnection"16@"APSOutgoingMessage"24@"NSError"32
v28@0:8@"APSConnection"16B24
v24@0:8@"APSConnection"16
v32@0:8@"APSConnection"16@"NSArray"24
v32@0:8@"NSData"16@?<v@?@"NSData"@"NSError">24
@"<SKAPushManagingDelegate>"16@0:8
v24@0:8@"<SKAPushManagingDelegate>"16
@36@0:8@16@24B32
@"<SKAPushManagingDelegate>"
@"SKASystemMonitor"
@"APSConnection"
@"FTMessageDelivery"
@"ChannelIdentity"
{?="clientTimestampSeconds"b1}
v48@0:8@"NSString"16@"NSString"24@"<SKAClientConnectionRepresentable>"32@?<v@?@"NSError">40
v40@0:8@"NSString"16@"<SKAClientConnectionRepresentable>"24@?<v@?@"NSError">32
v24@0:8@?<v@?@"NSError">16
v32@0:8@"NSString"16@?<v@?@"NSArray">24
@48@0:8@16q24q32@40
@"SharedOwnershipAuth"
{?="authCredentialOneof"b1}
@"ChannelPublishPayload"
{?="publishInitiateTimestampMillis"b1"publishPayloadExpiryTtlMillis"b1"pushPriority"b1"retryCount"b1"pendingPublishHint"b1"scheduledPublishHint"b1}
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
v52@0:8@16@24@32@40B48
v56@0:8@"NSString"16@"NSDictionary"24@"NSString"32@"NSString"40@"NSString"48
v52@0:8@"NSString"16@"NSString"24@"NSString"32@"NSString"40B48
v56@0:8@"<SKAChannelManaging>"16@"NSData"24@"NSString"32@"NSDate"40@"NSDate"48
v40@0:8@"<SKAChannelManaging>"16@"NSString"24@"NSError"32
v40@0:8@"<SKAStatusReceivingManaging>"16@"SKADatabaseStatus"24@"SKADatabaseChannel"32
v32@0:8@"<SKADatabaseManaging>"16@"SKADatabaseChannel"24
v40@0:8@"<SKAInvitationManaging>"16@"SKADatabaseReceivedInvitation"24@"SKADatabaseChannel"32
v32@0:8@"<SKAInvitationManaging>"16@"SKADatabaseChannel"24
v24@0:8@"SKAStatusPublishingServiceClient"16
v24@0:8@"SKAStatusSubscriptionServiceClient"16
v24@0:8@"SKAPresenceClient"16
v32@0:8@"<SKAPresenceManaging>"16@"NSString"24
v32@0:8@"<SKAPresenceManaging>"16@"SKADatabaseChannel"24
@"NSXPCListener"
@"<SKAStatusReceivingManaging>"
@"NSManagedObjectContext"16@0:8
v24@0:8@?<v@?B>16
@"<SKADatabaseProvidingDelegate>"
@"NSPersistentContainer"
@"CKContainer"
@"<SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>"
{?="currentVersion"b1"prevVersion"b1}
@"DecryptedParticipantPayload"
{?="updateType"b1}
{?="clientTimestampSeconds"b1"requestFlag"b1}
@"SKStatusPayload"
@"SKADatabaseReceivedInvitation"
@84@0:8@16@24@32@40@48@56@64B72@76
@32@0:8q16@24
@80@0:8@16@24@32@40@48@56@64@72
Q32@0:8@16@24
B40@0:8@16Q24@32
@112@0:8@16@24@32@40@48@56@64@72@80@88@96@104
@"SKADatabaseChannel"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"36@0:8@"NSString"16B24@"NSManagedObjectContext"28
@"SKADatabaseChannel"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@"NSArray"36@0:8@"NSString"16B24@"NSManagedObjectContext"28
@"SKADatabaseChannel"48@0:8@"NSString"16@"NSString"24@"NSData"32@"NSManagedObjectContext"40
@"SKADatabaseChannel"84@0:8@"NSString"16@"NSString"24@"NSData"32@"NSData"40@"NSData"48@"NSData"56@"NSDate"64B72@"NSManagedObjectContext"76
B32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseChannel"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseChannel"40@0:8@"SKADatabaseChannel"16@"NSData"24@"NSManagedObjectContext"32
@"SKAGeneratedEncryptionKey"40@0:8@"NSData"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"NSArray"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"NSArray"24@0:8@"NSManagedObjectContext"16
@"NSArray"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"48@0:8@"NSString"16@"NSString"24@"NSString"32@"NSManagedObjectContext"40
B40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabaseSubscriptionAssertion"40@0:8@"NSString"16@"NSDate"24@"NSManagedObjectContext"32
@"NSArray"32@0:8q16@"NSManagedObjectContext"24
@"NSArray"40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
@"SKADatabaseInvitedUser"48@0:8@"SKInvitationPayload"16@"SKADatabaseInvitedUser"24@"SKADatabaseChannel"32@"NSManagedObjectContext"40
@"SKADatabaseInvitedUser"56@0:8@"SKHandle"16@"SKHandle"24@"SKInvitationPayload"32@"SKADatabaseChannel"40@"NSManagedObjectContext"48
B40@0:8@"SKADatabaseChannel"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"SKADatabaseChannel"24@"NSManagedObjectContext"32
B32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"80@0:8@"NSString"16@"NSDate"24@"NSDate"32@"NSDate"40@"NSDate"48@"NSData"56@"NSString"64@"NSManagedObjectContext"72
@"SKADatabaseStatus"32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
@"SKADatabaseStatus"32@0:8@"NSString"16@"NSManagedObjectContext"24
v40@0:8@"NSString"16@"NSString"24@"NSManagedObjectContext"32
@"SKADatabasePendingPublishRequest"56@0:8@"NSString"16@"NSDate"24@"NSData"32@"NSString"40@"NSManagedObjectContext"48
@"SKADatabasePendingPublishRequest"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"NSArray"32@0:8@"NSString"16@"NSManagedObjectContext"24
@"SKADatabaseRemovedUser"48@0:8@"SKHandle"16@"NSDate"24@"NSString"32@"NSManagedObjectContext"40
@"SKADatabaseRemovedUser"40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
B40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
Q32@0:8@"SKADatabaseChannel"16@"NSManagedObjectContext"24
B40@0:8@"SKADatabaseChannel"16Q24@"NSManagedObjectContext"32
@"SKADatabaseReceivedInvitation"112@0:8@"SKADatabaseChannel"16@"SKHandle"24@"SKHandle"32@"NSString"40@"NSDate"48@"NSData"56@"NSString"64@"NSData"72@"NSData"80@"NSData"88@"NSData"96@"NSManagedObjectContext"104
v40@0:8@"NSString"16@"SKADatabaseReceivedInvitation"24@"NSManagedObjectContext"32
v24@0:8@"NSManagedObjectContext"16
v40@0:8@"SKHandle"16@"NSString"24@"NSManagedObjectContext"32
@36@0:8q16B24@28
@"<SKADatabaseManagingDelegate>"
{?="requestFlag"b1}
v48@0:8@"NSArray"16@"SKHandle"24@"NSString"32@?<v@?@"NSError">40
v40@0:8@"NSString"16@"SKPresencePayload"24@?<v@?@"NSError">32
v36@0:8@"NSString"16B24@?<v@?@"NSError">28
v24@0:8@"SKAPresenceClientConnection"16
@"SKAPresenceClientConnection"
@"<SKAPresenceClientDelegate>"
@"NSSet"
{?="serverTimestampSeconds"b1"status"b1}
@56@0:8@16@24@32@40q48
@"ChannelActivityActivationResponse"
@"ChannelActivityDeactivationResponse"
@"ChannelActivityPollingResponse"
{?="response"b1}
@"<SKAPresenceClientConnectionLifecycleDelegate>"
{?="serverTimestampSeconds"b1"version"b1"activationExpirySeconds"b1"responseMessageIndex"b1"status"b1"totalResponseMessages"b1}
v24@0:8:16
{os_unfair_lock_s=I}16@0:8
v20@0:8{os_unfair_lock_s=I}16
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"NSHashTable"
@"ChannelActivityActivationRequest"
@"ChannelActivityDeactivationRequest"
@"ChannelActivityPollingRequest"
{?="request"b1}
