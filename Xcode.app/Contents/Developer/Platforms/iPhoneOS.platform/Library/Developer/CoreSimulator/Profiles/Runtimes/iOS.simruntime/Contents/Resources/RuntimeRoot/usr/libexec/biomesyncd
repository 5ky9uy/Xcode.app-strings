@(#)PROGRAM:biomesyncd  PROJECT:BiomeSync-98.0.2
CREATE TABLE Metadata (
 key TEXT UNIQUE PRIMARY KEY ON CONFLICT REPLACE NOT NULL,
 value
CREATE TABLE CKAtom (
 stream STRING NOT NULL,
 -- CKDistributedTimestamp
 site BLOB NOT NULL,
 clock INTEGER NOT NULL,
 type INTEGER NOT NULL,
 -- CRDTLocation
 location_id INTEGER NOT NULL,
 -- BMStoreBookmark
 segment_name TEXT,
 segment_offset INTEGER,
 -- CKAtomReference
 ref_type INTEGER,
 ref_site BLOB,
 ref_clock INTEGER,
 ref_location_id INTEGER,
 -- CKAtom value
 value_version INTEGER,
 value_data BLOB,
 on_disk BOOLEAN,
 CONSTRAINT "ref_type <=> (ref_site AND ref_clock)"
 CHECK ((ref_type IS NULL) == ((ref_site IS NULL) AND (ref_clock IS NULL))),
 CONSTRAINT "(ref_type, ref_site, ref_clock) != (type, site, clock)"
 CHECK (ref_type != type OR ref_site != site OR ref_clock != clock),
 CONSTRAINT "segment_name <=> segment_offset"
 CHECK ((segment_name IS NULL) == (segment_offset IS NULL)),
 CONSTRAINT "on_disk <=> segment_name"
 CHECK (CASE WHEN on_disk NOTNULL THEN segment_name NOTNULL ELSE segment_name ISNULL END),
 CONSTRAINT "on_disk <=> !data"
 CHECK (CASE WHEN on_disk NOTNULL THEN value_data ISNULL ELSE value_data NOTNULL END)
 FOREIGN KEY (location_id) REFERENCES CRDTLocation(id),
 FOREIGN KEY (ref_location_id) REFERENCES CRDTLocation(id)
 UNIQUE (stream, site, type, clock),
 UNIQUE (stream, site, clock, on_disk),
 UNIQUE (stream, site, type, clock, on_disk),
 UNIQUE (stream, site, type, segment_name, segment_offset)
CREATE INDEX idx_ckatom_ref_clock_type ON CKAtom(stream, ref_clock, type);
CREATE INDEX idx_ckatom_segment_name ON CKAtom(stream, segment_name);
CREATE TABLE CRDTLocation (
 id INTEGER primary key,
 stream STRING NOT NULL,
 site STRING NOT NULL,
 day INTEGER NOT NULL,
 state INTEGER NOT NULL
CREATE INDEX idx_crdt_location ON CRDTLocation(stream, site, day);
CREATE INDEX idx_crdt_location_state ON CRDTLocation(stream, site, state, day DESC);
CREATE TABLE TombstoneBookmark (
 stream STRING NOT NULL,
 site BLOB NOT NULL,
 segment_name TEXT,
 segment_offset INTEGER
CREATE INDEX idx_tombstone_bookmark ON TombstoneBookmark(stream, site);
CREATE TABLE DevicePeer (
 device_identifier STRING NOT NULL,
 me BOOLEAN,
 name STRING,
 model STRING,
 platform INTEGER,
 last_sync_date INTEGER,
 protocol_version INTEGER NOT NULL
CREATE TABLE SyncSessionLog (
 session_id BLOB,
 start_timestamp INTEGER,
 end_timestamp INTEGER,
 transport INTEGER,
 reason INTEGER,
 is_reciprocal BOOL
CREATE TABLE SyncMessageLog (
 session_id BLOB,
 message_id INTEGER,
 timestamp INTEGER,
 device_identifier STRING,
 reachable BOOL,
 is_reciprocal BOOL,
 atom_batch_bytes INTEGER
CREATE INDEX idx_syncmessagelog_session_id ON SyncMessageLog(session_id);
CREATE TABLE AtomMergedLog (
 session_id BLOB,
 message_id INTEGER,
 stream STRING,
 merge_result INTEGER,
 owning_site_identifier STRING,
 relayed_by_site_identifier STRING,
 synced_at INTEGER,
 event_created_at INTEGER
CREATE INDEX idx_atommergedlog_session_id ON AtomMergedLog(session_id);
CREATE INDEX idx_atommergedlog_owning_site_identifier ON AtomMergedLog(owning_site_identifier);
CREATE TABLE CKRecord (
 location_id INTEGER,
 sync_to_cloud_kit BOOL,
 record_metadata BLOB,
 record_name STRING,
 stream_identifier STRING,
 local_mergeable_value BLOB,
 deleting BOOL,
 record_type INTEGER,
 PRIMARY KEY (stream_identifier, record_name)
 FOREIGN KEY (location_id) REFERENCES CRDTLocation(id)
CREATE INDEX idx_ckrecord ON CKRecord(record_name);
CREATE TABLE CKMergeableRecordValue (
 stream_name STRING,
 record_name STRING,
 server_mergeable_value BLOB,
 FOREIGN KEY (stream_name, record_name) REFERENCES CKRecord(stream_identifier, record_name)
CREATE TABLE CKZone (
 zone_name STRING NOT NULL,
 zone_uuid STRING NOT NULL,
 recovery_state INTEGER,
 attempted_recovery_date INTEGER
0E333333
init
locationRow
stateVectorForLocationRow:
countByEnumeratingWithState:objects:count:
initWithMergeableDelta:error:
addObject:
mergeableValueID
identifier
initWithData:encoding:
setOriginatingSiteIdentifier:
location
mergeAtomBatches:sessionContext:forLocation:
ckMergeableValueID
initWriterWithMergeableValueID:metadata:formatVersion:error:
contentsVector
populateAtomBatch:withAtomsInClockVector:forLocation:ckFormatVersion:valueVersion:chunker:
finishWritingWithError:
splitWithMaximumSize:error:
size:error:
numberWithUnsignedInteger:
initWithAtomBatch:error:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
mergeDeltas:error:
mergeableDeltasForMetadata:error:
stateVector
deltaDeliveryRequirements
initWithStreamCRDT:locationRow:database:queue:maxDeltaSize:
streamCRDT
queue
setQueue:
maxDeltaSize
setMaxDeltaSize:
.cxx_destruct
_streamCRDT
_locationRow
_queue
_maxDeltaSize
T@"BMStreamCKCRDT",R,N,V_streamCRDT
T@"BMSyncCRDTLocationRow",R,N,V_locationRow
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
Tq,N,V_maxDeltaSize
initWithLocation:state:primaryKey:
initWithFormat:
state
initWithLocation:state:
primaryKey
_location
_state
_primaryKey
T@"BMStreamCRDTLocation",R,N,V_location
TQ,R,N,V_state
TQ,R,N,V_primaryKey
stringForColumn:
doubleForColumn:
initWithTimeIntervalSinceReferenceDate:
initWithStreamName:siteIdentifier:day:
intForColumn:
initWithFMResultSet:modifier:
streamName
siteIdentifier
timeIntervalSinceReferenceDate
numberWithDouble:
arrayWithObjects:count:
SELECT_FROM:COLUMNS:WHERE:
next
upsertLocation:
dictionaryWithObjects:forKeys:count:
UPDATE:SET:WHERE:
locationRowWithLocation:
INSERT_INTO:VALUES:
lastInsertRowId
DELETE_FROM:WHERE:
SELECT_FROM:COLUMNS:WHERE:ORDER_BY:LIMIT:
intForColumnIndex:
locationRowWithLocationID:
updateLocationState:forLocation:
updateAllLocationsAtOrBefore:state:
insertLocationIfNotExists:withState:
removeAllDeletedLocationsBeforeHighestDeletedLocation:
previousLocationRowBeforeLocationRow:
locationsWithState:
highestDeletedLocationsForStream:
highestDeletedLocationForSiteIdentifier:inStream:
CRDTLocationCount
indexSetWithIndexesInRange:
modifier
initWithIdentifier:modifier:
timestamps
siteIdentifierObject
clockValue
initWithIndex:
_reinitializeSiteIdentifier:
addClockValuesInIndexSet:forSiteIdentifier:
allSiteIdentifiers
clockValuesForSiteIdentifier:
count
lastIndex
initWithSiteIdentifierObject:clockValue:
initWithTimestamps:
allKeys
timestampClockVectorForStreamIdentifier:
timestampClockVectorToTimeStampVector:
setVectorClockTo:forStreamIdentifier:
vectorClockForStreamIdentifier:
timestampVectorToTimeStampClockVector:
firstIndex
rangeTimestampClockVectorFromIndexClockVector:
multiStreamTimestampClockVectorToVectorClock:
multiStreamVectorClockToTimestampVectorClock:
multiStreamRangeClockVectorFromIndexClockVectors:
sessionID
setSessionID:
messageID
setMessageID:
originatingSiteIdentifier
_sessionID
_messageID
_originatingSiteIdentifier
T@"NSString",&,N,V_sessionID
TQ,N,V_messageID
T@"NSString",&,N,V_originatingSiteIdentifier
UUID
UUIDString
recordSessionStart:transport:reason:isReciprocal:
recordSessionEnd:
recordMessageToDeviceIdentifier:sessionID:messageID:reachable:bytes:isReciprocal:
recordAtomMergeResult:inStream:sessionID:messageID:ownerSite:originatingSite:eventCreatedAt:
initWithDatabase:
sessionContext
recordMessageToDeviceIdentifier:reachable:bytes:isReciprocal:sessionContext:
recordAtomMergeResult:inStream:ownerSite:originatingSite:eventCreatedAt:sessionContext:
_database
computeAggregatedSessionLogs
sendSyncSessionLog:
compactAndDeleteSessionLogs
initWithDatabase:activity:
computeAndSendAggregatedMetrics
_activity
length
initWithMaxBytes:
copyWithZone:
canAddAtomWithData:
didAddAtomWithData:
_maxBytes
_usedBytes
initWithMaxCount:
_maxCount
_atomCount
copy
initWithChunkerPolicy:
moreComing
setMoreComing:
_chunkerPolicy
_moreComing
TB,N,V_moreComing
initWithName:model:platform:
initWithDeviceIdentifier:metadata:protocolVersion:
initWithFMResultSet:
close
deviceIdentifier
deviceWithIdentifier:
metadata
name
numberWithBool:
model
platform
numberWithInteger:
protocolVersion
dateForColumnIndex:
localDevice
upsertSyncDevicePeer:isMe:
lastSyncDateFromAnyDevice
lastSyncDateOfDeviceWithIdentifier:
setLastSyncDate:forDeviceWithIdentifier:
allPeers
osBuildVersion
isEqualToString:
objectForKeyedSubscript:
null
unsignedIntegerValue
devicePeerMetadata
initFromDictionary:
dictionaryRepresentation
_name
_model
_platform
T@"NSString",R,C,N,V_name
T@"NSString",R,C,N,V_model
Tq,R,N,V_platform
setProtocolVersion:
_deviceIdentifier
_metadata
_protocolVersion
T@"NSString",R,C,N,V_deviceIdentifier
T@"BMSyncDevicePeerMetadata",R,N,V_metadata
TQ,N,V_protocolVersion
startRequestTimeout
stopRequestTimeout
requestBlock
removeObject:
setObject:forKeyedSubscript:
requestTimeoutDidFire
requestTimeoutHandler
initWithUUID:activity:requestBlock:queue:completionHandler:
runRequestOnDevice:
markAsInFlightToDevice:
markAsDeliveredToDevice:withError:
setState:
uuid
setUuid:
activity
setActivity:
setRequestBlock:
completionHandler
setCompletionHandler:
deliveredToDevices
setDeliveredToDevices:
inFlightToDevices
setInFlightToDevices:
errorFromDevice
setErrorFromDevice:
requestTimeout
setRequestTimeout:
setRequestTimeoutHandler:
setSessionContext:
_transaction
_deliveredToDevices
_inFlightToDevices
_errorFromDevice
_uuid
_requestBlock
_completionHandler
_requestTimeout
_requestTimeoutHandler
_sessionContext
TQ,N,V_state
T@"NSUUID",&,N,V_uuid
T@"NSObject<OS_xpc_object>",&,N,V_activity
T@?,C,N,V_requestBlock
T@?,C,N,V_completionHandler
T@"NSSet",&,N,V_deliveredToDevices
T@"NSSet",&,N,V_inFlightToDevices
T@"NSDictionary",&,N,V_errorFromDevice
T@"NSObject<OS_dispatch_source>",&,N,V_requestTimeout
T@?,C,N,V_requestTimeoutHandler
T@"BMSyncSessionContext",&,N,V_sessionContext
peerStatusTracker
metricsCollector
initWithQueue:forSharedUse:
setDelegate:
localDeviceIdentifierCreatingIfNecessary
registerRequests
start
fetchAtomBatchesIsReciprocal:reason:activity:completionHandler:
discoveredDevices
setWithArray:
containsObject:
isSubsetOfSet:
unionSet:
bmDeviceIdentifier
siteSuffix
allObjects
allValues
completeRequest:deliveredToDevices:withErrors:
removeObjectForKey:
buildAtomBatchRequestWithIsReciprocal:sequenceNumber:transportType:
objectForKey:
sendFetchAtomBatchesRequest:toDevice:forRequest:
errorWithDomain:code:userInfo:
setObject:forKey:
runRequest:onDevice:
isReciprocalRequest
handleFetchAtomBatchesResponse:options:error:fromDevice:forRequest:isReciprocal:
sendRequest:request:toDevice:responseHandler:
clockVectorForStreamsSupportingTransportType:direction:
localDeviceUpdatingIfNecessary
setPeer:
setWalltime:
setBatchSize:
setBatchSequenceNumber:
setVectorClock:
setIsReciprocalRequest:
setAtomBatchVersion:
fetchAtomBatchesRequestHandler
registerRequestID:requestHandler:
device
statusFlags
supportsSyncingWithPlatform:overTransport:inDirection:
removeAllObjects
stop
atomBatchVersion
vectorClock
atomBatchesInClockVector:targetPlatform:transportType:direction:ckFormatVersion:chunker:
setUnseenPeers:
setAtomBatches:
batchSequenceNumber
deletedLocations
setDeletedLocations:
finishRequest:toDevice:withError:peerInfo:
peer
setBmDeviceIdentifier:
atomBatchBytes
atomBatches
mergeAtomBatches:deletedLocations:sessionContext:
completeRequestIfDeliveredToAllNearbyDevices:
upsertSyncDevicePeer:
localDeviceUpdatingIfNeccesaryWithProtocolVersion:
rapportManager:isDeviceSupported:
rapportManager:didDiscoverBMRapportDevice:
rapportManager:didLoseNearbyBMRapportDevice:
rapportManager:localDeviceUpdated:
rapportManagerDiscoveryTimedOut:
initWithDistributedSyncMultiStreamManager:queue:
initWithDistributedSyncMultiStreamManager:rapportManager:atomBatchChunkerPolicy:queue:
startClient
startServer
syncNowWithReason:activity:completionHandler:
setMetricsCollector:
reciprocalCompletionBlock
setReciprocalCompletionBlock:
_syncManager
_rapportManager
_requestQueue
_localDeviceIdentifier
_atomBatchChunkerPolicy
_peerStatusTracker
_metricsCollector
_reciprocalCompletionBlock
T@?,C,N,V_reciprocalCompletionBlock
T@"NSObject<OS_dispatch_queue>",R,N,V_queue
T@"BMSyncDevicePeerStatusTracker",R,N,V_peerStatusTracker
T@"BMSyncSessionMetricsCollector",&,N,V_metricsCollector
initWithQueue:
database
setDatabase:
distributedSyncMultiStreamManager
setDistributedSyncMultiStreamManager:
rapportSyncEngine
setRapportSyncEngine:
cloudKitSyncEngine
setCloudKitSyncEngine:
syncScheduler
setSyncScheduler:
_distributedSyncMultiStreamManager
_rapportSyncEngine
_cloudKitSyncEngine
_syncScheduler
T@"BMSyncDatabase",&,N,V_database
T@"BMDistributedSyncMultiStreamManager",&,N,V_distributedSyncMultiStreamManager
T@"BMRapportSyncEngine",&,N,V_rapportSyncEngine
T@"BMCloudKitSyncEngine",&,N,V_cloudKitSyncEngine
T@"BMSyncScheduler",&,N,V_syncScheduler
sendEvent:payload:
dictionaryWithSyncDatabase:
dateOfLastVacuum
timeIntervalSinceDate:
databaseSizeInKilobytes
numberWithUnsignedLongLong:
walSizeInKilobytes
numRowsInTable:
sizeOfTableInKilobytes:
sendSyncDatabaseSummaryWithDatabase:
initWithQueue:core:
vacuumWithShouldContinueBlock:
setDateOfLastVacuum:
syncNowIfPolicyAllowsWithReason:transportType:activity:
contextSyncManager
currentHandler
stringWithUTF8String:
handleFailureInFunction:file:lineNumber:description:
syncAllTransportsNowIfPolicyAllowsWithReason:activity:
setValue:forKey:
initWithArray:
valueForKey:
compareToVector:
encodeObject:forKey:
decodeObjectOfClasses:forKey:
mutableCopy
archivedDataWithRootObject:requiringSecureCoding:error:
unarchivedObjectOfClass:fromData:error:
supportsSecureCoding
deserialize:error:
encodeWithCoder:
initWithCoder:
TB,R
serialize:
_vectorClock
handleFailureInMethod:object:file:lineNumber:description:
initWithAssignerPolicy:
newEnumeratorFromStartTime:options:
newEnumeratorFromBookmark:options:
descriptor
config
remoteStreamName
newTombstoneEnumeratorFromStartTime:
segmentName
offset
newTombstoneEnumeratorFromBookmark:
dataUsingEncoding:
initWithIdentifier:
latestDistributedTimestampForSiteIdentifier:inStream:
timestamp
locationWithStreamName:siteIdentifier:timestamp:
ckMergeableValueIDWithFormatVersion:
initWithMergeableValueID:timestamp:type:
initWithLocation:timestamp:referenceLocation:causalReference:type:bookmark:
ckAtomRowForAtomWithBookmark:type:forSiteIdentifier:inStream:
containsCKAtomRowWithSegment:inStream:
frame
data
dataVersion
initWithEventData:dataVersion:dataTimestamp:
initWithAtomType:value:version:
causalReference
ckAtomRowWithTimestamp:inStream:
type
bookmark
deleteEventAtBookmark:outTombstoneBookmark:
value
eventData
eventBodyClass
registeredEventClass
writeEventBodyClass:
dataTimestamp
_writeEventData:dataVersion:timestamp:outBookmark:
addAtomWithValueData:toAtomBatch:fromAtomTableRecord:version:atomValueVersion:
setSiteIdentifier:
setClock:
setModifier:
unordered
setUnordered:
references
setType:
setIdentifier:
appendWithProxyBlock:
setAtomType:
setAtomBehavior:
setValue:
setVersion:
appendAtomWithBlock:
distributedSiteIdentifier
datastorePath
segmentSize
initWithStoreBasePath:segmentSize:
setStoreLocationOption:
setRemoteStreamName:
initWithStream:permission:config:includeTombstones:
ingestNewChangesForSite:transportType:
readerForSiteIdentifier:
latestCKAtomRowOfType:forSiteIdentifier:inStream:
newEnumeratorFromBookmark:reader:
nextEvent
initWithDatabase:transcationBatchSize:
ckAtomTableRecordForEvent:ofType:atBookmark:previousTableRecord:siteIdentifier:
addCKAtomRow:inStream:
supportsTransport:direction:
upsertCKRecordWithLocation:inStream:
executeOperationWithBlock:
latestTombstoneBookmarkForSiteIdentifier:inStream:
newTombstoneEnumeratorFromBookmark:reader:
nextTombstoneEvent
eventBody
initWithStream:segment:iterationStartTime:offset:
deletionReason
saveLatestTombstoneBookmark:forSiteIdentifier:inStream:
deleteLocationsUpToTTLAtTombstone:siteIdentifier:
deletedExpiredBufferedLocationsForSiteIdentifier:
computeHighestLocationToDeleteUpToBookmark:forSiteIdentifier:inStream:
deleteAtOrBeforeHighestDeletedLocation:
highestLocationWithBufferedAtomsOlderThan:forSiteIdentifier:inStream:
updateAllCKRecordsAtOrBeforeLocationToBeDeletedOnSync:
deleteAllAtomsAtOrBeforeLocation:
markCKRecordsAtOrBeforeLocationToBeDeletedOnSync:
atomValueFromEvent:ofType:version:
serialize
addAtomToAtomBatch:ifChunkerAllows:fromAtomTableRecord:atomValueData:version:atomValueVersion:
atomRowsInTimestampClockVector:forLocation:inStream:enumerateWithBlock:
ingestNewChangesFromAllSitesInVectorClock:transportType:
locationsInClockVector:inStream:enumerateWithBlock:
initWithStream:config:
atomsAtOrBeforeLocation:ofType:enumerateWithBlock:
deleteCKRecordsAtOrBeforeLocation:
initWithCKMergeableValueID:
compare:
beginTransaction
containsCKAtomRowWithTimestamp:inStream:onDisk:
bm_description
proxyAtIndex:
reference
initWithCKMergeableValueID:streamName:
atomType
version
initWithLocation:timestamp:referenceLocation:causalReference:type:valueVersion:valueData:
enumerateAtomsWithOptions:usingBlock:
commit
rollback
bytes
valueData
valueVersion
atomValueFromData:version:
referenceLocation
updateCKAtomRow:inStream:
atomRowsNotOnDiskReferencingSiteIdentifier:inStream:enumerateWithBlock:
isEqualToReference:
writeAtomValue:fromAtomRow:usingWriter:outBookmark:
handleDeleteAtomRow:usingPruner:outBookmark:outTombstoneBookmark:
timestampClockVectorForStreamName:
initWithStreamID:config:policy:locationAssignerPolicy:localSiteIdentifier:database:
atomsInClockVector:ckFormatVersion:chunker:transportType:enumerateWithBlock:
handleDeletedLocation:deleteCKRecord:
mergeAtomBatch:sessionContext:
clockVector
streamID
_localSiteIdentifier
_config
_policy
_locationBuilder
_locationRowCache
_streamID
_streamName
T@"BMSyncStreamID",R,N,V_streamID
T@"NSString",R,N,V_streamName
stringWithFormat:
dictionary
allocWithZone:
readFrom:
writeTo:
_type
_value
_has
dateForColumn:
zoneName
zoneUUID
recoveryState
attemptedRecoveryDate
_recoveryState
_zoneName
_zoneUUID
_attemptedRecoveryDate
T@"NSString",R,N,V_zoneName
T@"NSString",R,N,V_zoneUUID
Ti,R,N,V_recoveryState
T@"NSDate",R,N,V_attemptedRecoveryDate
ckZoneExists:
numberWithInt:
distantPast
ckZoneForZoneName:
ckZoneSetAttemptingRecoveryForZoneName:state:
ckZoneSetZoneVersionUUID:forZoneName:
ckZoneSetAttemptedRecoveryDate:state:forZoneName:
enumerateZonesWithBlock:
registerForSigterm
createDiscoveryClientWithControlFlags:
setDispatchQueue:
setControlFlags:
setServiceType:
handleDiscoveryClientInvalidation
setInvalidationHandler:
didDiscoverDevice:
setDeviceFoundHandler:
didLoseDevice:
setDeviceLostHandler:
device:didChange:
setDeviceChangedHandler:
localDeviceUpdated:
setLocalDeviceUpdatedHandler:
createSharedDiscoveryClientIfNotExists
createDiscoveryClientIfNotExists
activateDiscoveryClientWithCompletion:
handleDiscoveryClientActivationOrError:
activateWithCompletion:
activeDevices
registerRequestID:options:handler:
registerEventID:options:handler:
initWithRPCompanionLinkDevice:
rapportIdentifier
deregisterRequestID:
invalidate
sendRequest:request:device:options:responseHandler:
shortenedRapportIdentifier
requestQueue
client
setClient:
setDestinationDevice:
handleInterruptionForDevice:
setInterruptionHandler:
invalidateClientWithError:
handleActivationForDevice:error:
sendNextRequestToDevice:
linkState
sendEvent:event:toDevice:completionHandler:
activateDirectLinkToDevice:completionHandler:
code
domain
sendEventID:event:options:completion:
setLinkState:
popFirstObject
finishedSendingRequestsToDevice:
sendRequestID:request:options:responseHandler:
bm_companionLinkDeviceIdentifier
proximity
serviceTypes
delegate
activateDiscoveryLinkWithCompletion:
registerEventID:eventHandler:
invalidateDirectLinkToDevice:
registeredRequests
setRegisteredRequests:
_discoveryClient
_discoveryClientState
_devices
_unsupportedDevices
_sharedUse
_sigtermSource
_delegate
_registeredRequests
T@"NSMutableDictionary",&,N,V_registeredRequests
T@"<BMRapportManagerDelegate>",W,N,V_delegate
array
substringToIndex:
dispatchQueue
handleInvalidationWithError:
decodeObjectOfClass:forKey:
setDevice:
setRequestQueue:
_rapportIdentifier
_bmDeviceIdentifier
_device
_client
_linkState
T@"NSMutableArray",&,N,V_requestQueue
T@"NSArray",R,N
TQ,N,V_linkState
T@"NSString",R,N,V_rapportIdentifier
T@"NSString",R,N
T@"NSString",&,N,V_bmDeviceIdentifier
T@"RPCompanionLinkDevice",&,N,V_device
T@"RPCompanionLinkClient",&,N,V_client
Tq,R,N
doubleValue
walltime
_peer
_walltime
T@"BMSyncDevicePeer",&,N,V_peer
Td,N,V_walltime
boolValue
addEntriesFromDictionary:
batchSize
_isReciprocalRequest
_atomBatchVersion
_batchSize
_batchSequenceNumber
T@"BMMultiStreamVectorClock",&,N,V_vectorClock
TQ,N,V_atomBatchVersion
TB,N,V_isReciprocalRequest
TQ,N,V_batchSize
TQ,N,V_batchSequenceNumber
setWithObjects:
unarchivedObjectOfClasses:fromData:error:
unseenPeers
setAtomBatchBytes:
_unseenPeers
_atomBatches
_atomBatchBytes
_deletedLocations
T@"NSArray",&,N,V_unseenPeers
T@"NSDictionary",&,N,V_atomBatches
TQ,N,V_atomBatchBytes
T@"NSDictionary",&,N,V_deletedLocations
standardUserDefaults
identifierFromDescriptor:
initWithDictionary:
eventStringFromDescriptor:
currentDevice
syncableStreamIDsForPlatform:
loadAdditionalSyncPolicyDictionaries
addObjectsFromArray:
policyForStreamID:forPlatform:
bmUserDefaultsString:
initWithStreamID:policyDictionary:
directionsSupportedForTransport:
_supportsTransport:direction:outSupportedDirections:
syncableStreamIDs
policyForStreamID:
minimumTimeBetweenSyncsForTransport:
minimumTimeBetweenSyncsAttemptsForTransport:
_policyDictionary
unsignedLongValue
enumerateWithBlock:
_timestamp
_referenceLocation
_causalReference
_bookmark
_valueVersion
_valueData
T@"BMSyncCRDTLocationRow",R,N,V_location
T@"CKDistributedTimestamp",R,N,V_timestamp
T@"BMSyncCRDTLocationRow",R,N,V_referenceLocation
T@"CKAtomReference",R,N,V_causalReference
T@"BMStoreBookmark",R,N,V_bookmark
TQ,R,N,V_type
Tq,R,N,V_valueVersion
T@"NSData",R,N,V_valueData
longForColumn:
dataForColumn:
numberWithUnsignedLong:
numberWithUnsignedChar:
lastErrorMessage
SELECT_ATOMS_WHERE:ORDER_BY:LIMIT:
SELECT_FROM:COLUMNS:WHERE:GROUP_BY:
stringForColumnIndex:
unsignedLongLongIntForColumnIndex:
addClockValuesInIndexSet:withAtomState:forSiteIdentifier:
timestampCount
enumerateRangesUsingBlock:
SELECT_FROM:COLUMNS:JOIN:WHERE:GROUP_BY:HAVING:ORDER_BY:LIMIT:
longLongValue
numberWithLongLong:
SELECT_FROM:COLUMNS:JOIN:WHERE:ORDER_BY:LIMIT:
latestCKAtomRowForSiteIdentifier:inStream:
ckAtomCount
containsCKAtomRowWithTimestamp:inStream:
CKAtomRowSiteIdentifiers
initWithMachServiceName:
resume
processWithXPCConnection:
boolForEntitlement:
triggerRapportSyncWithReply:
triggerCloudKitSyncWithReply:
rapportSyncWithReply:
cloudKitSyncWithReply:
peerInformationWithReply:
interfaceWithProtocol:
setExportedInterface:
setExportedObject:
setRemoteObjectInterface:
syncCloudKitNowIfPolicyAllowsWithReason:activity:completionHandler:
syncRapportNowIfPolicyAllowsWithReason:activity:completionHandler:
_rapportSyncWithSyncTriggeredHandler:syncCompletedHandler:
_cloudKitSyncWithSyncTriggeredHandler:syncCompletedHandler:
listener:shouldAcceptNewConnection:
_core
_listener
idsDeviceIdentifier
T@"NSString",R
compareToTimestampVector:
_SELECT_FROM:COLUMNS:JOIN:WHERE:GROUP_BY:ORDER_BY:LIMIT:
componentsJoinedByString:
appendString:
arrayWithCapacity:
objectAtIndexedSubscript:
appendFormat:
integerValue
executeQuery:withArgumentsInArray:
executeQuery:
containsString:
executeUpdate:withArgumentsInArray:
valueForMetadataKey:
dateWithTimeIntervalSinceReferenceDate:
setValue:forMetadataKey:
lastRapportSyncAttemptDate
setLastRapportSyncAttemptDate:
lastCloudKitSyncAttemptDate
setLastCloudKitSyncAttemptDate:
ckSyncEngineMetaData
saveCKSyncEngineMetaData:
clearCKSyncEngineMetaData
mergeableRecordValueKey
setMergeableRecordValueKey:
T@"NSDate",&,N
T@"NSString",&,N
saveCKMergeableRecordValueRecordName:zoneName:mergeableRecordValueData:
clearCKMergeableRecordValueServerMergeableValuesForRecordName:zoneName:
clearCKMergeableRecordValueServerMergeableValuesForZoneName:
enumerateMergeableRecordValuesForRecordName:zoneName:withBlock:
encodeAsProto
proto
initWithProto:
initWithData:
initWithProtoData:
serializeProto
_version
T@"BMStoreEventAtomValue",R,N,V_value
Tq,R,N,V_version
numberWithUnsignedInt:
unsignedIntValue
_dataVersion
_eventData
_dataTimestamp
T@"NSData",R,N,V_eventData
TI,R,N,V_dataVersion
Td,R,N,V_dataTimestamp
setUnderlyingQueue:
setMaxConcurrentOperationCount:
distributedSyncManagers
policy
streamNameToStreamDescriptorDict
streamDescriptorSupportsCloudKitSync:
ckRecordForRecordName:zoneName:recordType:
locationID
saveCKRecordHighestDeletedLocationRow:recordName:zoneName:recordExists:
initWithZoneName:
zoneID
initWithRecordName:zoneID:
arrayWithObjects:
uploadChangesWithError:
fetchChangesWithError:
initWithAsyncOperationBlock:
addOperation:
setNeedsToFetchChanges
fetchChangesWithCompletionHandler:
clearCKRecordLocalMergeableValueAndSetToSyncForZone:
localSiteIdentifier
newHighestDeletedLocationRecordIDFor:stream:
ckRecordsToSyncToCloudKitForZone:
gatherAllCKSyncRecordRecordsToBeDeleted
minusSet:
addRecordIDsToSave:recordIDsToDelete:
recordIDsToSave
recordIDsToDelete
modifyPendingChangesWithCompletionHandler:
accountStatus
deviceToDeviceEncryptionAvailability
setFetchChangesForMergeableValues:
initWithContainerIdentifier:environment:
initWithContainerID:options:
handleTransitionToNewMergeableValueRecordValueKey
privateCloudDatabase
initWithDatabase:dataSource:metadata:
setAutomaticSyncingEnabled:
initWithConfiguration:
isManateeAvailable:
accountInfoWithCompletionHandler:
streamSupportsCloudKitSync:
recordName
initWithZoneName:recordName:
deleteCKRecordAtLocation:
recordID
expirationTimeForStreamDesc:
floatValue
isRecordNewerThanMostRecentDeleteForSiteIdentifier:
encryptedValues
saveCKRecordServerMergeableValue:recordName:zoneName:locationRow:
saveSystemFieldsDataForRecord:syncToCloudKit:recordType:
resetCKRecordsMetaDataAndSetToSyncForZone:
longValue
recordType
handleSyncRecordDidFetchRecord:
handleZoneVersionDidFetchRecord:
handleHighestDeletedLocationDidFetchRecord:
localMergeableValue
mergeRecordValue:error:
saveCKRecordLocalMergeableValue:recordName:zoneName:locationRow:
handleDidSaveRecordSyncRecord:
handleDidSaveRecordZoneVersionRecord:
handleDidSaveRecordHighestDeletedLocation:
resetMetadataForRecord:zoneName:
initWithZoneID:
addRecordZonesToSave:recordZoneIDsToDelete:
newZoneVersionRecordIDForZone:
userInfo
handleZoneReset:
handleFailedToSaveSyncRecordUnknownItem:
handleFailedToSaveSyncRecordResaveRecord:
handleFailedToSaveSyncRecordServerRecordChanged:error:
handleFailedToSaveSyncRecordServerManateeDecryptionError:error:
resaveRecordOnError:
resaveRecord:
handleServerRecordChangedForHighestDeletedLocationError:
handleFailedToSaveRecordSyncRecord:error:
handleFailedToSaveRecordZoneVersion:error:
handleFailedToSaveRecordHighestDeletedLocation:error:
createCKRecordFromRecordID:newRecord:recordType:
numberWithLong:
setExpirationAfterTimeInterval:
initWithRecordType:recordID:
suggestedDeltaSizeForContainer:
addDeltasToSaveFromMergeable:error:
handleZoneVersionRecordToSaveForRecordID:
handleSyncRecordRecordToSaveForRecordID:
handleHighestDeletedLocationRecordToSaveForRecordID:
deleteAllCKRecordsInZone:
handleRecordWithIDDeletedSyncRecord:
streamIdentifier
mergeIntoMergeable:error:
enumerateRecordsWithBlock:
initWithZoneName:ownerName:
syncEngine:recordToSaveForRecordID:
syncEngine:didSaveRecord:
syncEngine:failedToSaveRecord:error:
syncEngine:didDeleteRecordWithID:
syncEngine:failedToDeleteRecordWithID:error:
syncEngine:didFetchRecord:
syncEngine:recordWithIDWasDeleted:recordType:
syncEngine:didUpdateMetadata:
syncEngine:didSaveRecordZone:
syncEngine:didDeleteRecordZoneWithID:
syncEngine:failedToFetchChangesForRecordZoneID:error:
syncEngine:failedToSaveRecordZone:error:
syncEngine:failedToDeleteRecordZoneWithID:error:
syncEngine:zoneWithIDChanged:
syncEngine:zoneWithIDWasDeleted:
syncEngine:zoneWithIDWasDeletedDueToUserEncryptedDataReset:
syncEngine:zoneWithIDWasPurged:
syncEngine:accountChangedFromUserRecordID:toUserRecordID:
syncEngineDidBeginFetchingChanges:
syncEngineWillBeginFetchingChanges:
syncEngineDidEndFetchingChanges:
syncEngine:willBeginFetchingChangesForZoneIDs:
syncEngine:didEndFetchingChangesForZoneID:
syncEngineWillBeginModifyingPendingChanges:
syncEngineDidEndModifyingPendingChanges:
syncEngine:nextBatchOfRecordsToModifyForZoneIDs:
syncEngine:didCompleteModifyRecordsBatch:error:
recordZonesToSaveForSyncEngine:
recordZoneIDsToDeleteForSyncEngine:
syncEngine:shouldFetchChangesForZoneID:
syncEngine:shouldFetchAssetContentsForZoneID:
syncEngine:relatedApplicationBundleIdentifiersForZoneIDs:recordIDs:
initWithDistributedSyncMultiStreamManager:database:queue:
startWithCompletionBlock:
dataSource
setDataSource:
container
setContainer:
configuration
setConfiguration:
ckSyncEngine
setCkSyncEngine:
_dataReceivedFromSiteIdentifiers
_operationQueue
_dataSource
_container
_configuration
_ckSyncEngine
_mergeableRecordValueKey
T@"<CKSyncEngineDataSource>",&,N,V_dataSource
T@"CKContainer",&,N,V_container
T@"CKSyncEngineConfiguration",&,N,V_configuration
T@"CKSyncEngine",&,N,V_ckSyncEngine
T@"NSString",R,N,V_mergeableRecordValueKey
timestampCountForSiteIdentifier:
initWithData:error:
updateClockVectorByUnionWithUnseenSiteIdentifiers:
dataWithError:
arrayWithArray:
initWithStreamCRDT:database:localSiteIdentifier:policy:
mergeAtomBatch:deletedLocations:sessionContext:
atomBatchesInClockVector:ckFormatVersion:chunker:transportType:
T@"BMSyncPolicy",R,N,V_policy
T@"BMSyncDatabase",R,N,V_db
indexSetWithIndex:
initWithDistributedSyncManagers:peerStatusTracker:
_distributedSyncManagers
_streamNameToStreamDescriptorDict
T@"NSDictionary",R,N,V_distributedSyncManagers
T@"NSDictionary",R,N,V_streamNameToStreamDescriptorDict
configForSyncStreamID:
distributedSyncMultiStreamManagerWithDatabase:
_recordName
_streamIdentifier
_localMergeableValue
_locationID
T@"NSString",R,N,V_recordName
T@"NSString",R,N,V_streamIdentifier
T@"NSData",R,N,V_localMergeableValue
T@"NSNumber",R,N,V_locationID
initForReadingFromData:error:
getSystemFieldsDataForRecordName:zoneName:recordType:
recordFromSystemFieldsData:
recordChangeTag
initRequiringSecureCoding:
encodeSystemFieldsWithCoder:
encodedData
ckRecordExists:zoneName:recordType:
dataForColumnIndex:
enumerateCKSyncRecordRecordsSetForDeletingUsingBlock:
deleteCKRecordsForStreamName:
ckRecordCountForRecordType:
streamForStreamIdentifier:
hasPrefix:
substringFromIndex:
identifierForPublicStreamNamed:
identifierForRestrictedStreamNamed:
pathForStreamIdentifier:streamType:
storeConfigurationForStream:
newRestrictedStreamDefaultConfiguration
path
_path
T@"NSString",R,N,V_name
isCancelled
willChangeValueForKey:
didChangeValueForKey:
block
isFinished
isExecuting
isAsynchronous
_executing
_finished
_block
T@?,R,C,N,V_block
open
doRapportSyncNowWithReason:
clearCachedStatements
doCloudKitSyncNowWithReason:
initWithRapportSyncEngine:cloudKitSyncEngine:peerStatusTracker:database:queue:
initWithCustomFunctionName:
initWithSQLStatements:
sqlStatements
_sqlStatements
T@"NSArray",R,N,V_sqlStatements
customFunctionName
_customFunctionName
T@"NSString",R,N,V_customFunctionName
syncDirectory
stringByAppendingPathComponent:
defaultDatabasePath
stringByAppendingString:
initWithPath:queue:
databaseWithPath:
setShouldCacheStatements:
initWithFormat:arguments:
setState:error:
internalState
setState:errorFormat:
databasePath
stringByDeletingLastPathComponent
defaultManager
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
localizedFailureReason
openWithFlags:
lastErrorCode
stringByDeletingPathExtension
fileExistsAtPath:
sqliteHandle
executeStatements:
tableExists:
setUserVersion:
userVersion
methodForSelector:
lastError
removeItemAtPath:error:
corruptionHandler
_tryOpen:
isOpen
beginDeferredTransaction
objectForColumnIndex:
executeUpdate:
isEqualToSet:
defaultDatabaseWALPath
initWithPath:
migration_StarSkySchema11ToSydRoSchema12
migration_Schema20ToSchema21
error
setCorruptionHandler:
_fmdb
_flags
__error_ivar
__internal_state_ivar
_corruptionHandler
T@"NSString",R,N,V__error_ivar
TQ,R,N,V__internal_state_ivar
TI,R,N
T@?,C,N,V_corruptionHandler
TQ,R,N
setLocalDeviceIdentifier:
resultDictionary
nextWithError:
_numPagesToVacuum
_sizeOfFileInKilobytes:
attributesOfItemAtPath:error:
fileSize
sharedInstance
dateFormatter
_dateFormatter
isEqualToDate:
stringFromDate:
recordNameFromSite:day:
substringWithRange:
componentsSeparatedByString:
dateFromString:
initWithTriple:
characterAtIndex:
initWithName:zoneID:
pruningPolicy
maxAge
timeIntervalSinceNow
numberWithFloat:
dayFromRecordName:
triple
_siteIdentifier
_day
T@"NSString",R,N,V_siteIdentifier
T@"NSDate",R,N,V_day
truncateDateToDay:
initWithURL:
fileURLWithPath:
FMDBUserVersion
fileSystemRepresentation
sqlitePath
setMaxBusyRetryTimeInterval:
openWithFlags:vfs:
UTF8String
closeOpenResultSets
pointerValue
valueWithNonretainedObject:
objectEnumerator
objectsPassingTest:
anyObject
rekeyWithData:
setKeyWithData:
setDateFormat:
timeZoneForSecondsFromGMT:
setTimeZone:
initWithLocaleIdentifier:
setLocale:
errorWithMessage:
warnInUse
timeIntervalSince1970
objCType
charValue
unsignedCharValue
shortValue
unsignedShortValue
unsignedLongLongValue
numberWithShort:
numberWithUnsignedShort:
executeQuery:withArgumentsInArray:orDictionary:orVAList:shouldBind:
databaseExists
cachedStatementForQuery:
setCachedStatement:forQuery:
useCount
setUseCount:
bindObject:toColumn:inStatement:
objectAtIndex:
stringWithCapacity:
extractSQL:argumentsList:intoString:arguments:
executeUpdate:error:withArgumentsInArray:orDictionary:orVAList:
executeStatements:withResultBlock:
logsErrors
startSavePointWithName:error:
rollbackToSavePointWithName:error:
releaseSavePointWithName:error:
checkpoint:name:logFrameCount:checkpointCount:error:
crashOnErrors
setCachedStatements:
makeFunctionNamed:arguments:block:
databaseWithURL:
FMDBVersion
sqliteLibVersion
isSQLiteThreadSafe
storeableDateFormat:
databaseURL
limitFor:value:
maxBusyRetryTimeInterval
busyRetryTimeout
setBusyRetryTimeout:
hasOpenResultSets
rekey:
setKey:
goodConnection
hadError
lastExtendedErrorCode
changes
executeQuery:withParameterDictionary:
executeQueryWithFormat:
executeQuery:values:error:
executeQuery:withVAList:
executeUpdate:values:error:
executeUpdate:withParameterDictionary:
executeUpdate:withVAList:
executeUpdateWithFormat:
executeUpdate:withErrorAndBindings:
update:withErrorAndBindings:
prepare:
beginImmediateTransaction
beginExclusiveTransaction
inTransaction
interrupt
inSavePoint:
checkpoint:error:
checkpoint:name:error:
shouldCacheStatements
makeFunctionNamed:maximumArguments:withBlock:
valueType:
valueInt:
valueLong:
valueDouble:
valueData:
valueString:
resultNullInContext:
resultInt:context:
resultLong:context:
resultDouble:context:
resultData:context:
resultString:context:
resultError:context:
resultErrorCode:context:
resultErrorNoMemoryInContext:
resultErrorTooBigInContext:
traceExecution
setTraceExecution:
checkedOut
setCheckedOut:
setCrashOnErrors:
setLogsErrors:
cachedStatements
setIsOpen:
isInTransaction
_isExecutingStatement
_startBusyRetryTime
_openResultSets
_openFunctions
_dateFormat
_shouldCacheStatements
_traceExecution
_checkedOut
_crashOnErrors
_logsErrors
_isOpen
_isInTransaction
_maxBusyRetryTimeInterval
_cachedStatements
_databasePath
TB,V_traceExecution
TB,V_checkedOut
TB,V_crashOnErrors
TB,V_logsErrors
T@"NSMutableDictionary",&,V_cachedStatements
TB,N,V_isOpen
TB,R,N
TB,R,N,V_isInTransaction
TB,N,V_shouldCacheStatements
T@"NSString",R,N,V_databasePath
T@"NSURL",R,N
T^v,R,N
Td,N,V_maxBusyRetryTimeInterval
_useCount
_inUse
Tq,V_useCount
T^v,V_statement
TB,V_inUse
stringByReplacingOccurrencesOfString:withString:
getTableSchema:
columnExists:inTableWithName:
stringForQuery:
intForQuery:
longForQuery:
boolForQuery:
doubleForQuery:
dataForQuery:
dateForQuery:
getSchema
applicationID
setApplicationID:
columnExists:columnName:
validateSQL:error:
TI,N
setStatement:
setParentDB:
setShouldAutoClose:
inUse
setInUse:
dealloc
reset
resultSetDidClose:
statement
initWithCapacity:
lowercaseString
dictionaryWithCapacity:
columnNameToIndexMap
keyEnumerator
nextObject
objectForColumnName:
internalStepWithError:
stepWithError:
dictionaryWithObject:forKey:
intValue
columnIndexForName:
longForColumnIndex:
longLongIntForColumnIndex:
boolForColumnIndex:
doubleForColumnIndex:
hasDateFormatter
dateWithTimeIntervalSince1970:
dataWithBytes:length:
dataNoCopyForColumnIndex:
dataWithBytesNoCopy:length:freeWhenDone:
columnIndexIsNull:
UTF8StringForColumnIndex:
UTF8StringForColumn:
objectForColumn:
bindStatement:WithArgumentsInArray:orDictionary:orVAList:
bindWithArray:orDictionary:orVAList:
resultSetWithStatement:usingParentDatabase:shouldAutoClose:
columnCount
kvcMagic:
resultDict
step
hasAnotherRow
longLongIntForColumn:
unsignedLongLongIntForColumn:
boolForColumn:
dataNoCopyForColumn:
columnIsNull:
UTF8StringForColumnName:
columnNameForIndex:
bindWithArray:
bindWithDictionary:
parentDB
query
setQuery:
shouldAutoClose
_columnNameToIndexMap
_shouldAutoClose
_parentDB
_query
_statement
TB,N,V_shouldAutoClose
T@"_bmFMDatabase",&,N,V_parentDB
T@"NSString",&,V_query
T@"NSMutableDictionary",R
T@"_bmFMStatement",&,V_statement
Ti,R,N
T@"NSDictionary",R,N
exceptionWithName:reason:userInfo:
raise
executeLocked:
lastObject
removeLastObject
databasePool:shouldAddDatabaseToPool:
databasePool:didAddDatabase:
pushDatabaseBackInPool:
databasePoolWithPath:
databasePoolWithURL:
databasePoolWithPath:flags:
databasePoolWithURL:flags:
countOfCheckedInDatabases
countOfCheckedOutDatabases
countOfOpenDatabases
releaseAllDatabases
maximumNumberOfDatabasesToCreate
setMaximumNumberOfDatabasesToCreate:
_lockQueue
_databaseInPool
_databaseOutPool
_maximumNumberOfDatabasesToCreate
T@"NSString",C,V_path
T@,V_delegate
TQ,V_maximumNumberOfDatabasesToCreate
databaseQueueWithPath:
initWithPath:flags:
databaseQueueWithPath:flags:
initWithPath:flags:vfs:
databaseClass
beginTransaction:withBlock:
databaseQueueWithURL:
databaseQueueWithURL:flags:
initWithURL:flags:vfs:
initWithURL:flags:
inDatabase:
inTransaction:
inDeferredTransaction:
inExclusiveTransaction:
inImmediateTransaction:
setPath:
openFlags
vfsName
setVfsName:
_openFlags
_vfsName
T@"NSString",&,V_path
Ti,R,V_openFlags
T@"NSString",C,V_vfsName
BiomeSync
v8@?0
<%@: location=%@, state=%lu>
location_
ref_location_
%@%@
stream
site
state
CRDTLocation
stream = ?
 AND site = ?
 AND day = ?
id = ?
 AND day <= ?
 AND state = ?
 AND day < ?
 AND NOT EXISTS (SELECT * FROM CKAtom WHERE location_id = id)
day DESC
state = ?
day = (select max(day) from CRDTLocation i where i.stream = ? and i.site=CRDTLocation.site
 and state = ?)
 AND stream = ?
 AND state = ? 
count(*)
no session ID
device_identifier
name
model
platform
protocol_version
DevicePeer
me IS ?
device_identifier = ?
max(last_sync_date)
last_sync_date
deviceIdentifier
deviceMetadata
protocolVersion
BMRapportRequest
v16@?0@"BMRapportDevice"8
com.apple.biomesyncd.fetchAtomBatches
v32@?0@"NSDictionary"8@"NSDictionary"16@"NSError"24
senderModelID
Unable to determine sender model info
Unknown platform
v24@?0@"NSArray"8@"NSArray"16
v32@?0@"NSDictionary"8@"NSDictionary"16@?<v@?@"NSDictionary"@"NSDictionary"@"NSError">24
com.apple.biome.syncSessionLog
com.apple.biome.syncdatabase
database_size
wal_size
num_rows_CKAtom
CKAtom
table_size_CKAtom
num_rows_CKRecord
CKRecord
table_size_CKRecord
num_rows_CRDTLocation
time_since_vacuum
table_size_CRDTLocation
com.apple.biomesyncd
com.apple.biomesyncd.metrics-collection
v16@?0@"NSObject<OS_xpc_object>"8
com.apple.biomesyncd.database-maintenance
B8@?0
com.apple.biomesyncd.periodic-sync
com.apple.notifyd.matching
Notification
com.apple.rapport.CompanionLinkDeviceAdded
com.apple.rapport.matching
replyRequired
context_sync
void *BiomeLibraryLibrary(void)
biomesyncd.m
vectorClock
BMStreamCKCRDT.m
Invalid parameter not satisfying: %@
streamID
config
database
v24@?0@"CKAtomReferenceMutableProxy"8Q16
v24@?0@"CKAtomMutableProxy"8Q16
v16@?0^B8
v24@?0@"BMSyncCKAtomRow"8^B16
v24@?0@"BMSyncCRDTLocationRow"8^B16
v32@?0@"CKAtomProxy"8Q16^B24
BMFrameStatePreWrite
BMFrameStateWritten
BMFrameStatePreDelete
BMFrameStateDeleted
BMFrameStateEOF
BMFrameStateUnknown
BMFrameStateUnknown(%lu)
%@ %@
type
value
Append
TTLDelete
RandomDelete
Modify
Unknown
(unknown: %i)
zone_name
zone_uuid
recovery_state
attempted_recovery_date
CKZone
zone_name = ?
UUID not set
com.apple.biomesyncd.rapport
v16@?0@"RPCompanionLinkDevice"8
v20@?0@"RPCompanionLinkDevice"8I16
v16@?0@"NSError"8
v12@?0B8
~~REQUEST_ID~~
~~RESPONSE_HANDLER~~
~~OPTIONS~~
failed with error, 
completed
BMRapportDevice[%@]: id=%@ bmID=%@ model=%@ name=%@
device
Immed
Near
peer
walltime
batchSize
batchSequenceNumber
isReciprocalRequest
atomBatchVersion
unseenPeers
atomBatches
moreComing
deletedLocations
biomesyncdStrings
AdditionalSyncPolicies
eventClass
restricted/feedbackSocialHighlights
BMSocialHighlightFeedbackEvent
public/DeviceMetadata
BMDeviceMetadataEvent
restricted/SiriMemoryReferenceResolutionStream
BMSiriMemoryReferenceResolutionEvent
public/AppLaunch
BMAppLaunchEvent
overrideInternalPolicy
rapport
direction
outbound
cloudkit
none
BMSyncPolicy.m
Unexpected direction %lu
NSString *NSStringFromBMSyncTransportType(BMSyncTransportType)
No mapping found for BMSyncTransportType(%lu)
inbound
BMSyncDirection BMSyncDirectionFromNSString(NSString *__strong)
No mapping found for %@
BMSyncCKAtomRow.m
location
timestamp
<%@: type=%@, location=%@, atomID=%@, refID=%@ bookmarkOffset=%lu>
clock
segment_name
segment_offset
ref_type
ref_site
ref_clock
value_version
value_data
location_id
on_disk
ref_location_id
CKAtom.site = ?
 AND CKAtom.stream = ?
 AND clock = ?
 AND on_disk IS ?
clock DESC
max(clock)
v24@?0@"_bmFMResultSet"8^B16
location_id = ?
clock ASC
type = ?
 AND CKAtom.site = ?
 AND segment_name IS NOT ?
clock = ?
 AND type = ?
 AND segment_name = ?
 AND segment_offset = ?
site = ?
DISTINCT site
(ref_site = ?
 OR (ref_site IS NULL AND CKAtom.site = ?))
ref_clock ASC
type ASC
location.stream = ?
 AND location.site = ?
 AND location.day <= ?
ref_clock DESC
location_id IN (SELECT id from CRDTLocation where stream = ?
 AND day <= ?)
 AND clock != ?
 AND clock != (SELECT MAX(clock) FROM CKAtom WHERE stream = ?
 AND site = ?)
CKAtom.stream = ? 
 AND ((CKAtom.site = ? 
) OR (CKAtom.site = ? 
AND clock = ? 
OR clock = ? 
AND clock BETWEEN ? 
OR clock BETWEEN ? 
 AND ?
v32@?0{_NSRange=QQ}8^B24
)) AND on_disk IS ?
location.stream as location_stream
location.site as location_site
location.day as location_day
location.state as location_state
 LEFT JOIN CRDTLocation location ON location_id=location.id
location_id, location.stream, location.site, location.day, location.state
location.stream
location.site
location.day ASC
 AND CKAtom.location_id = ? 
CKAtom.stream = ?
COUNT ((CAST(segment_name AS INT) > ?
 OR segment_name = ?
 AND segment_offset > ?) OR NULL) == 0
location.day DESC
 AND on_disk IS NOT ?
CKAtom.*
ref_location.stream as ref_location_stream
ref_location.site as ref_location_site
ref_location.day as ref_location_day
ref_location.state as ref_location_state
 LEFT JOIN CRDTLocation ref_location ON ref_location_id=ref_location.id
com.apple.biomesyncd.sync
com.apple.private.biome.sync
com.apple.internal.biome.sync
-[BMSyncServiceServer triggerRapportSyncWithReply:]
-[BMSyncServiceServer rapportSyncWithError:]
-[BMSyncServiceServer triggerCloudKitSyncWithReply:]
-[BMSyncServiceServer cloudKitSyncWithError:]
isMe
platformDescription
BMRapportErrorDomain
SELECT %@ FROM %@
 WHERE 
 GROUP BY %@
 ORDER BY %@
 LIMIT %@
 HAVING 
UPDATE OR FAIL %@ SET 
 = ?, 
 = ?
INSERT INTO %@
) VALUES (
DELETE FROM %@
%@:%lu
com.apple.biome.sync.ckMetaData
LastSyncAttemptDate
LastCloudKitAttemptDate
MergeableRecordValueKey
CKMergeableRecordValue
stream_name
record_name
server_mergeable_value
stream_name = ?
 AND record_name = ?
TombstoneBookmark
AND site = ?
BMSyncAtomType(%llu)
BiomeStream
atomType
atomValue
data
dataVersion
dataTimestamp
recordOrder
zoneVersion
biomeCRDT
streamCRDT
zoneVersionUUID
com.apple.biome.sync
unknown
syncRecord
highestDeletedLocation
(unknown: %lu)
v16@?0@?<v@?>8
v24@?0@"CKAccountInfo"8@"NSError"16
v24@?0@"NSData"8^B16
v24@?0@"BMSyncCKRecord"8^B16
v24@?0@"BMSyncCKZone"8^B16
v16@?0@"CKAtomBatch"8
BMDistributedSyncMultiStreamManager.m
direction == BMSyncDirectionOutbound
stream_identifier
local_mergeable_value
sync_to_cloud_kit = ?
 AND deleting = ?
 AND record_type = ?
 AND stream_identifier = ?
record_metadata
sync_to_cloud_kit
record_name = ?
record_type
stream_identifier = ?
deleting
record_type = ?
 AND location_id IN (     SELECT id FROM CRDTLocation WHERE site = ?
     AND stream = ?
     AND day <= ?)
 LEFT JOIN CRDTLocation location ON location_id=location.id 
deleting = ?
 AND EXISTS (SELECT record_name FROM CKMergeableRecordValue WHERE CKMergeableRecordValue.stream_name=CKRecord.stream_identifier AND CKMergeableRecordValue.record_name=CKRecord.record_name AND server_mergeable_value IS NOT NULL)
v24@?0@"CKRecordID"8^B16
location_id =?
BMSyncStreamID.m
streamName.length
stream != BMPublicStreamUnknown
public/
restricted/
public/%@
restricted/%@
identifier
isExecuting
isFinished
never
com.apple.biome.syncNow
[BMCloudKitSyncEngine start] failed: %@
BMSyncScheduler
v20@?0B8@"NSError"12
eventData
migration_StarSkySchema11ToSydRoSchema12
ALTER TABLE CKRecord DROP COLUMN mergeable_value_delta
ALTER TABLE CKRecord ADD COLUMN server_mergeable_value BLOB
ALTER TABLE CKRecord ADD COLUMN local_mergeable_value BLOB
ALTER TABLE CKAtom ADD COLUMN value_version INTEGER
UPDATE CKAtom SET value_version = 0
CREATE INDEX IF NOT EXISTS idx_syncmessagelog_session_id ON SyncMessageLog(session_id)
CREATE INDEX IF NOT EXISTS idx_atommergedlog_owning_site_identifier ON AtomMergedLog(owning_site_identifier)
CREATE INDEX IF NOT EXISTS idx_atommergedlog_session_id ON AtomMergedLog(session_id)
CREATE TABLE CKZone(zone_name STRING NOT NULL, zone_uuid STRING NOT NULL, recovery_state INTEGER, attempted_recovery_date INTEGER)
migration_Schema20ToSchema21
ALTER TABLE CKRecord ADD COLUMN record_type INTEGER
UPDATE CKRecord SET record_type = 1
sync.db
-wal
BMSyncDatabase.m
path
recursion max
failed to create path: %@
PRAGMA journal_mode = WAL;PRAGMA foreign_keys = ON;
Metadata
version too new
com.apple.Biome
internal build version < 17
internal build version between 17 and 19
custom migration to version %u failed with error %@
migration to version %u failed with error %@
failed to delete corrupt database file: %@
unhandled state %llu
SELECT value FROM Metadata WHERE key=?
INSERT INTO Metadata VALUES (?, ?)
PRAGMA foreign_keys=OFF
idx_crdt_location
idx_crdt_location_state
SELECT type, name FROM sqlite_schema WHERE tbl_name = 'CRDTLocation'
table
CREATE TABLE new_CRDTLocation (id INTEGER primary key, stream STRING NOT NULL, site STRING NOT NULL, day INTEGER NOT NULL, state INTEGER NOT NULL)
INSERT INTO new_CRDTLocation SELECT * FROM CRDTLocation
DROP TABLE CRDTLocation
ALTER TABLE new_CRDTLocation RENAME TO CRDTLocation
CREATE INDEX IF NOT EXISTS idx_crdt_location ON CRDTLocation(stream, site, day)
CREATE INDEX IF NOT EXISTS idx_crdt_location_state ON CRDTLocation(stream, site, state, day DESC)
CREATE TABLE IF NOT EXISTS CKRecord (location_id INTEGER, sync_to_cloud_kit BOOL, record_metadata BLOB, record_name STRING, stream_identifier STRING, mergeable_value_delta BLOB, deleting BOOL, FOREIGN KEY (location_id) REFERENCES CRDTLocation(id));
CREATE INDEX IF NOT EXISTS idx_ckrecord ON CKRecord(record_name)
PRAGMA foreign_key_check
PRAGMA foreign_keys=ON
CREATE TABLE new_CKRecord (location_id INTEGER, sync_to_cloud_kit BOOL, record_metadata BLOB, record_name STRING, stream_identifier STRING, local_mergeable_value BLOB, deleting BOOL,  PRIMARY KEY (stream_identifier, record_name), FOREIGN KEY (location_id) REFERENCES CRDTLocation(id));
INSERT INTO new_CKRecord SELECT location_id, sync_to_cloud_kit, record_metadata, record_name, stream_identifier, local_mergeable_value, deleting FROM CKRecord
DROP TABLE CKRecord
ALTER TABLE new_CKRecord RENAME TO CKRecord
CREATE TABLE IF NOT EXISTS CKMergeableRecordValue (stream_name STRING, record_name STRING, server_mergeable_value BLOB, FOREIGN KEY (stream_name, record_name) REFERENCES CKRecord(stream_identifier, record_name))
select session_duration.session_id, duration, reachable_peers_cnt, is_reciprocal, reason as sync_reason, cast((select count(*) from DevicePeer) as text) as known_peers_cnt_str, cast(reachable_peers_cnt as real) / (select count(*) from DevicePeer) as peer_availabilty_pct, avg_sync_latency, atoms_dropped_cnt, atoms_causality_violation_cnt, atoms_received_cnt, atoms_relayed_cnt, relay_earliness, relay_unseen_peer_atom_cnt, atom_batch_bytes from ( select session_id, is_reciprocal, reason, (end_timestamp - start_timestamp) as duration from SyncSessionLog group by session_id, is_reciprocal, reason ) as session_duration left join ( select session_id, count(distinct device_identifier) as reachable_peers_cnt from SyncMessageLog group by session_id ) as reachable_peers on session_duration.session_id=reachable_peers.session_id left join ( select session_id, avg(case when event_created_at <> 0 then synced_at - event_created_at else null end) as avg_sync_latency from AtomMergedLog group by session_id ) as sync_latency on session_duration.session_id=sync_latency.session_id left join ( select a.session_id, sum(case when a.merge_result=1 THEN 1 else 0 end) as atoms_dropped_cnt, sum(case when a.merge_result=2 THEN 1 else 0 end) as atoms_causality_violation_cnt, sum(case when a.merge_result=3 THEN 1 else 0 end) as atoms_received_cnt from AtomMergedLog as a join SyncMessageLog as m on a.message_id=m.message_id and a.relayed_by_site_identifier = m.device_identifier and a.session_id=m.session_id group by a.session_id ) as merge_results on session_duration.session_id=merge_results.session_id left join ( select session_id, count(*) as atoms_relayed_cnt from AtomMergedLog as a where owning_site_identifier <> relayed_by_site_identifier and not exists ( select * from SyncMessageLog as m where a.session_id=m.session_id and device_identifier=owning_site_identifier and reachable=1 ) group by session_id ) as relay_count on session_duration.session_id=relay_count.session_id left join ( select relayed.session_id, avg(timestamp - synced_at) as relay_earliness from ( select atom.session_id, synced_at, timestamp from AtomMergedLog as atom, SyncMessageLog as message where owning_site_identifier <> relayed_by_site_identifier and not exists ( select * from SyncMessageLog as m where atom.session_id=m.session_id and device_identifier=owning_site_identifier and reachable=1 ) and device_identifier=owning_site_identifier and reachable=1 and timestamp > synced_at order by timestamp asc limit 1 ) as relayed group by relayed.session_id ) as earliness on session_duration.session_id=earliness.session_id left join ( select session_id, count(*) as relay_unseen_peer_atom_cnt from AtomMergedLog as a where owning_site_identifier <> relayed_by_site_identifier and not exists ( select * from SyncMessageLog as m where device_identifier=owning_site_identifier and reachable=1 ) group by session_id ) as atom_relay_unseen_device on session_duration.session_id=atom_relay_unseen_device.session_id left join ( select session_id, sum(atom_batch_bytes) as atom_batch_bytes from SyncMessageLog group by session_id ) as batch_bytes on session_duration.session_id=batch_bytes.session_id;
SyncSessionLog
session_id
transport
reason
is_reciprocal
start_timestamp
end_timestamp
session_id = ?
SyncMessageLog
message_id
reachable
atom_batch_bytes
AtomMergedLog
owning_site_identifier
relayed_by_site_identifier
merge_result
event_created_at
synced_at
DELETE FROM SyncMessageLog WHERE timestamp <> (SELECT max(timestamp) FROM SyncMessageLog message WHERE device_identifier=message.device_identifier)
DELETE FROM SyncSessionLog
DELETE FROM AtomMergedLog
LastVacuumDate
PRAGMA page_count
PRAGMA freelist_count
PRAGMA auto_vacuum
PRAGMA auto_vacuum = 2
VACUUM
PRAGMA incremental_vacuum(%lu)
SELECT name FROM sqlite_schema WHERE type='table' AND name=?
SELECT COUNT(*) FROM %@
SELECT SUM(pgsize) FROM dbstat WHERE name = ?
(%@, %@, %@)
(%@,%@,%@)
%@,%@
(%@,%@)
-[_bmFMDatabase initWithPath:]
FMDatabase.m
sqlite3_threadsafe()
2.7.7
FMDBVersion is invalid: Please use FMDBUserVersion instead.
:memory:
error opening!: %d
Closing leaked statement
error closing!: %d
%s:%d
-[_bmFMDatabase busyRetryTimeout]
FMDB: busyRetryTimeout no longer works, please use maxBusyRetryTimeInterval
-[_bmFMDatabase setBusyRetryTimeout:]
FMDB: setBusyRetryTimeout does nothing, please use setMaxBusyRetryTimeInterval:
B24@?0@"_bmFMStatement"8^B16
query
API misuse, -[_bmFMDatabase setCachedStatement:forQuery:] query must not be nil
en_US
select name from sqlite_master where type='table'
The _bmFMDatabase %@ is currently in use.
The _bmFMDatabase %@ is not open.
NULL
%@ executeQuery: %@
DB Error: %d "%@"
DB Query: %@
DB Path: %@
%@ = %@
Error: unable to bind (%d, %s
Could not find index for %@
data: %ld bytes
obj: %@
Error: the bind count is not correct for the # of variables (executeQuery)
Error inserting batch: %s
rollback transaction
commit transaction
begin exclusive transaction
begin deferred transaction
begin immediate transaction
savepoint '%@';
release savepoint '%@';
rollback transaction to savepoint '%@';
dbSavePoint%ld
%@ %ld hit(s) for query %@
WARNING: Requested sleep of %i milliseconds, but SQLite returned %i. Maybe SQLite wasn't built with HAVE_USLEEP=1?
select [sql] from sqlite_master where [type] = 'table' and lower(name) = ?
SELECT type, name, tbl_name, rootpage, sql FROM (SELECT * FROM sqlite_master UNION ALL SELECT * FROM sqlite_temp_master) WHERE type != 'meta' AND name NOT LIKE 'sqlite_%' ORDER BY tbl_name, type DESC, name
pragma table_info('%@')
pragma application_id
pragma application_id=%d
pragma user_version
pragma user_version = %d
FMResultSet.m
![statement inUse]
Warning: There seem to be no columns in this set.
%s:%d Database busy (%@)
-[_bmFMResultSet internalStepWithError:]
Database busy
Error calling sqlite3_step (%d: %s) rs
parentDB does not exist
_bmFMDatabase
Unknown error calling sqlite3_step (%d: %s) rs
Warning: I could not find the column named '%@'.
Database already in pool
The _bmFMDatabase being put back into the pool is already present in the pool
Maximum number of databases (%ld) has already been reached!
Could not open up the database at path %@
Could not create database queue for path %@
fmdb.%@
_bmFMDatabaseQueue could not reopen database for path %@
-[_bmFMDatabaseQueue inDatabase:]
FMDatabaseQueue.m
currentSyncQueue != self && "inDatabase: was called reentrantly on the same queue, which would lead to a deadlock"
Warning: there is at least one open result set around after performing [_bmFMDatabaseQueue inDatabase:]
savePoint%ld
locationRow is nil, returning empty state vector
mergeDeltas delta: %@
Failed to initWithMergeableDelta with error %@
BMStreamCKRecordCRDT: unable to init a CKAtomBatch with initWriterWithMergeableValueID:%@ error:%@
BMStreamCKRecordCRDT: unable to complete a CKAtomBatch with finishWritingWithError:%@ error:%@
BMStreamCKRecordCRDT: failed to split atom batch with error %@
BMStreamCKRecordCRDT: failed to calculate batch size with error %@
BMStreamCKRecordCRDT: split into batch of size %@
BMStreamCKRecordCRDT: unable to init a CKMergeableDelta with initWithAtomBatch:%@ error:%@
*** deltas: %@
unexpected modifier %lu
[BMSyncCRDTLocationRow initWithFMResultSet] streamName:%@ siteIdentifier:%@ dayTimestamp:%f nsDate:%@ prefix:%@
updateLocationState: %lu forLocation:%@
updateAllLocationsAtOrBefore:%@ to state %lu
BMMultiStreamVectorClockConverter found nil modifier on siteIdentifier: %@
Expected only one value in indexSet of timestampClockVector, found %lu
sessionContext is nil
BMRapportSyncEngine%@: completing request, still inflight: %@
BMRapportSyncEngine%@: completeRequest:deliveredToDevices %@ withErrors:%@
BMRapportSyncEngine%@: request %@ already finished running
BMRapportSyncEngine%@: sending request to device: %@
BMRapportSyncEngine%@: request timed out because no devices are nearby
BMRapportSyncEngine%@: current watch disallowed from syncing with non-paired device: %@
BMRapportSyncEngine%@: current platform disallowed from syncing with non-paired watch: %@
BMRapportSyncEngine%@: syncing with device platform disallowed for device: %@
BMRapportSyncEngine%@: received request %@ %@
BMRapportSyncEngine%@: unable to determine sender model info: %@
BMRapportSyncEngine%@: unable to determine platform for model %{public}@
BMRapportSyncEngine%@: replying with CKXUncompressedFormatVersion atom batch
BMRapportSyncEngine%@: mismatched protocol version %lu, expected %d
BMRapportSyncEngine%@: should issue reciprocal request, %@
BMRapportSyncEngine%@: fetch completion handler is reciprocal, YES, deviceIdentifiers, %@, errors, %@
BMRapportSyncEngine%@: handleFetchAtomBatchesResponse %@ error %@ fromDevice: %@
BMRapportSyncEngine%@: fetchAtomBatchesResponseHandler received response %@
BMRapportSyncEngine%@: asked to defer activity, won't issue more requests to device %@ even though more data is available
BMRapportSyncEngine%@: max request depth %lu hit, finishing request to device %@
BMRapportSyncEngine%@: sending request to device %@ with sequence number %lu
BMRapportSyncEngine%@: no more data coming from device %@ finishing request
BiomeSync is disabled on simulators, -[BMSyncCore start] returning NO
biomesyncd launched
biomesyncd last exit status: %lld
Tried to defer activity %s, but failed
biome activity fired "com.apple.biomesyncd.metrics-collection"
Database unavailable for activity "com.apple.biomesyncd.metrics-collection"
biome running activity "com.apple.biomesyncd.metrics-collection"
biome activity fired "com.apple.biomesyncd.database-maintenance"
database unavailable for activity "com.apple.biomesyncd.database-maintenance"
biome running activity "com.apple.biomesyncd.database-maintenance"
Received unexpected object on com.apple.notifyd.matching: %@
Received com.apple.notifyd.matching: %s
Handling com.apple.notifyd.matching: %s
Database unavailable to handle "com.apple.rapport.CompanionLinkDeviceAdded"
Received unexpected object on com.apple.rapport.matching: %@
Received com.apple.rapport.matching: %s
Handling com.apple.rapport.matching: %s
Database unavailable to handle RapportWake
Received SIGTERM
failed to set user dir suffix: %{darwin.errno}d
failed to initialize temporary directory: %{darwin.errno}d
failed to resolve temporary directory: %{darwin.errno}d
biome activity fired "%s"
Database unavailable for activity "%s"
biome running activity "%s"
Starting tombstone enumerator from 0 for stream %@ site %@
Starting tombstone enumerator from segment %@ offset %lu for stream %@ site %@
delete must reference a corresponding append
Expected no-data frame to be delete or pre-delete, but frame was %{public}@
appendRecord %@ is of unexpected type %lu
bookmark is nil, presumably because the referenced atom was a dummy append (dead on arrival) %@
deleting event at bookmark %@
dropping atom %@ as it is dead on arrival
writeAtomValue: %@
adding %@ to atomBatch
ingestChangesForSite: %@
observed new data from non-local site %@
read new appended BMStoreEvent: %@ at offset %lu
failed to insert record %@
read new deleted BMStoreEvent: %@ at offset %lu
failed to batch ingest changes
read BMStoreEvent tombstone: %@ at tombstone bookmark %@
tombstone with unexpected deletion reason %lu
failed to batch ingest deletions
deleteLocationsUpToTTLAtTombstone: %@, siteIdentifier: %@
deletedExpiredBufferedLocationsForSiteIdentifier: %@
failed to delete atoms with location: %@
atomTableRecord %@
%@ location is not active
BMSyncCKAtomRow missing bookmark %@
Next enumerator bookmark %@ doesn't match expected %@
read table BMStoreEvent: %@ at offset %lu
bookmark is DOA, not attempting to resolve event
populateAndEnumerateAtomBatches could not finish writing atomBatch with err: %@
atomsInClockVector: %@, stream: %@
creating new batch with location %@
could not create new batch with location %@
handleDeletedLocation: %@
failed to delete event at bookmark %@
deleted location already handled
location we haven't yet observed is now deleted %@
location is unexpectedly nil, unable to parse from mergeableValueID %@
location is unexpectedly nil
received missing location %@
location is not active %@ skipping merge to not resurrect a dead location
highest deleted location %@ is past incoming location %@
received data for new location %@
mergeAtoms: %lu location %@
dropping atom with timestamp %@ since already merged
atom with timestamp %@ already in table but not on disk
causalReference location is unexpectedly nil
failed to insert referenceLocationRow for location %@
addAtomRow: %@
failed to commit, rolling back
updating row for atom inferred to be applied to disk %@
failed to update row: %@
atom to apply to disk %@
causal reference cache hit
causal reference location %@ points to dead location, not a violation
causal reference violation: missing causal reference %@ reference location %@
unblocked: %@
failed to apply atom to disk
updating row for atom applied to disk %@
BMRapportManager: shared-use only supported internally
BMRapportManager: received SIGTERM
BMRapportManager: could not determine appropriate control flags for device platform: %@
BMRapportManager: createSharedDiscoveryClientIfNotExists not currently supported
BMRapportManager: shared discovery client already exists
BMRapportManager: already activated %@
BMRapportManager: already activating %@
BMRapportManager: activating %@
BMRapportManager: failed to activate with error: %@
BMRapportManager: activated successfully
BMRapportManager: invalidated
BMRapportManager: registerEventID %@
BMRapportManager: stop
sendRequest:request:device:options:responseHandler: passed nil device
BMRapportDevice[%@]: enqueueing request
device %@ requestQueue %@
BMRapportDevice[%@]: activating client
device: %@ linkState %lu
handleActivationForDevice:error: passed nil device
BMRapportDevice[%@]: activation %@%@
BMRapportDevice[%@]: determined to not support service com.apple.biomesyncd.rapport
handleInterruptionForDevice: passed nil device
BMRapportDevice[%@]: interrupted
sendNextRequestToDevice: passed nil device
BMRapportDevice[%@]: expected request id and response handler in %@
BMRapportDevice[%@]: being sent request %@ with options %@
finishedSendingRequestsToDevice: passed nil device
BMRapportDevice[%@]: request queue empty, invalidating client
BMRapportDevice[%@]: advertisement data changed
BMRapportDevice[%@]: pairing flags/attributes changed
BMRapportDevice[%@]: distance changed: %s
BMRapportDevice[%@]: distance wifi information element changed
BMRapportDevice[%@]: name changed: %@
BMRapportDevice[%@]: RSSI changed
BMRapportDevice[%@]: SSID changed
BMRapportDevice[%@]: proximity changed: %s
BMRapportDevice[%@]: distance/angle/something changed
BMRapportDevice[%@]: no transports available; expect a lost callback
BMRapportDevice[%@]: got unexpected change flag: RPDeviceChangeFlags(%x)
BMRapportManager: skipping RPCompanionLinkDevice missing identifier: %@
BMRapportManager: skipping RPCompanionLinkDevice missing model: %@
BMRapportManager: already discovered device, %@ as %@
BMRapportDevice[%@]: ignoring device not listing service com.apple.biomesyncd.rapport
BMRapportDevice[%@]: discovered
BMRapportDevice[%@]: ignoring unsupported device
BMRapportDevice[%@]: lost
BMRapportDevice[%@]: invalidated
failed to unarchive BMMultiStreamVectorClock with error %@
failed to archive BMMultiStreamVectorClock with error %@
failed to unarchive BMMultiStreamAtomBatches with error %@
failed to archive BMMultiStreamAtomBatches with error %@
Failed to insert: %@
stateVector: %@
Failed to update: %@
clock vector is empty %@
triggerRapportSyncWithReply called
rapportSyncWithError called
triggerCloudKitSyncWithReply called
cloudKitSyncWithError called
%@: tried to initialize with a non-BMPBSyncAtomValue proto
%@: tried to initialize a BMPBSyncAtomValue proto, missing type or value
failed to deserialize BMSyncAtomValue with error %@
cannot deserialize atom value of version %lu
failed to serialize BMSyncAtomValue with error %@
cannot serialize atom value with version %lu
%@: tried to initialize with a non-BMPBStoreEventAtomValue proto
%@: tried to initialize a BMPBStoreEventAtomValue proto: missing dataVersion or dataTimestamp
unknown value in BMCloudKitRecordTypeString: %lu
syncNowWithReason
transitioning records over to new CKMergeableRecordValue with key %{public}@
failed to reset records for stream %{public}@ when transitioning to new CKMergeableRecordValue
ingest events from stream: %{public}@
syncNowWithReason found %lu records to sync and %lu records to delete
syncNowWithReason after removing duplicates, sending CKSyncEngine %lu records to sync and %lu records to delete
after modifying changes, we have %lu records to sync and %lu records to delete as a result of error handling
unable to obtain Manatee accountInfo
CloudKit container is not accessible. Status: %ld
This account is eligible to sync with manatee containers
Manatee is available on the current device
iCloud account doesn't support end-to-end encryption: %ld
account status is CKAccountStatusTemporarilyUnavailable
iCloud account status: %ld
unable to initialize CloudKit container
unable to initialize CloudKit configuration
unable to initialize ckSyncEngine
accountInfoWithCompletionHandler returned error: %@
zoneWithIDChanged: %{public}@
failedToFetchChangesForRecordZoneID: %{public}@
shouldFetchChangesForZoneID: %{public}@ returning: %{public}@
didDeleteRecordWithID: %{public}@ in zone: %{public}@
isRecordNewerThanMostRecentDeleteForSiteIdentifier: Could not create location from CKRecord: %{public}@
Error serverValue is nil for delta %{public}@ %{public}@
Error encoding serverValue for %{public}@ %{public}@, %{public}@
handleSyncRecordDidFetchRecord: Can't build location from record stream:%{public}@ recordName:%{public}@
Error saving [saveCKRecordServerMergeableValue:serverValueData] for %{public}@ %{public}@, %{public}@
didFetchRecord: %{public}@
didFetchRecord: unknown record type: %{public}@
handleDidSaveRecordSyncRecord: serverValue nil for for %{public}@ %{public}@
handleDidSaveRecordSyncRecord: Unable to unarchive localMergeableValue for %{public}@ %{public}@ %{public}@
nil value for localValue for %{public}@ %{public}@
Error [localRecordValue mergeRecordValue:serverValue] for serverValue:%{public}@ record:%{public}@ zone:%{public}@ %{public}@
Error encoding localValue for %{public}@ %{public}@
didSaveRecord: %{public}@ recordType: %{public}@ zone: %{public}@
didSaveRecord: %{public}@ unknown recordType: %{public}@ zone: %{public}@
didSaveRecordZone: %{public}@
failedToDeleteRecordWithID: %{public}@, zone:%{public}@
failedToSaveRecordZone:%{public}@ error:%{public}@
failedToSaveRecordZone: %{public}@ and recoveryState:%{public}d
Add zone and add record request made %{public}@ %{public}@.
Zone ID is nil; record dropped %{public}@
Handling handleFailedToSaveSyncRecordServerRecordChanged: Merging clientCRDT into serverCRDT %{public}@ -> %{public}@
Error handleFailedToSaveSyncRecordServerRecordChanged: [serverCRDT mergeRecordValue:clientCRDT]; error: %{public}@
handleFailedToSaveSyncRecordServerRecordChanged: serverCRDT is nil for record: %{public}@ for error: %{public}@
handleFailedToSaveSyncRecordServerRecordChanged: error archiving serverCRDT error: %{public}@
Manatee identity loss reported: record:%{public}@, zoneID:%{public}@, error:%{public}@
Error not handled: failedToSaveRecord, error: %{public}@
Error not handled: failedToSaveRecord, zoneVersion error: %{public}@
Error not handled: failedToSaveRecord, hightestDeletedLocation error: %{public}@
failedToSaveRecord: %{public}@, %{public}@ %{public}@
Error not handled: failedToSaveRecord, unknown record type: %{public}@ error: %{public}@
streamCRDT is nil %{public}@
locationID can not be found for recordID %{public}@
expirationTimeInterval is almost expired: %{public}@, not saving recordID: %{public}@ because it will be TTL'd
recordToSaveForRecordID: newRecord? %d
handleSyncRecordRecordToSaveForRecordID: Unable to unarchive localMergeableValue for %{public}@ %{public}@ %{public}@
recordValue %{public}@
Error adding deltas to save for %{public}@ %{public}@ %{public}@
set mergeable and saved to record's encryptedValues
recordToSaveForRecordID %{public}@
failedToDeleteRecordZoneWithID: %{public}@ error: %{public}@
didDeleteRecordZoneWithID: %{public}@
didDeleteRecordZoneWithID re-creating zone:%{public}@
didDeleteRecordZoneWithID syncing %lu records for zone:%{public}@
didDeleteRecordZoneWithID not re-creating zone:%{public}@, removing all local records in zone
zoneWithIDWasDeleted: %{public}@
recordWithIDWasDeleted: %{public}@, type=%{public}@
recordWithIDWasDeleted received an unknown record type:%{public}@ for record:%{public}@
syncEngineWillBeginFetchingChanges
syncEngineDidEndFetchingChanges
*** recordName:%{public}@
syncEngineDidEndFetchingChanges: Unable to unarchive localMergeableValue for %{public}@ %{public}@ %{public}@
Has a localMergeableValue: %{public}@
Has no localMergeableValue
syncEngineDidEndFetchingChanges: Unable to unarchive mergeableRecordValue for %{public}@ %{public}@ %{public}@
Merging mergeableRecordValue %{public}@
Merging serverValue %{public}@
Unable to [recordValue mergeRecordValue:serverValue for %{public}@ %{public}@ %{public}@
Were there mergeableRecordValues: %{public}s
syncEngineDidEndFetchingChanges location: %{public}@
syncEngineDidEndFetchingChanges: Can't build location from record stream:%{public}@ recordName:%{public}@
syncEngineDidEndFetchingChanges locationRow: %{public}@
locationRow is unexpectly nil for location %{public}@
Unable to  [recordValue mergeIntoMergeable:recordCRDT] for recordName:%{public}@ site:%{public}@ error:%{public}@
Unable to archive recordValue %{public}@ %{public}@
syncEngineWillBeginModifyingPendingChanges
syncEngineDidEndModifyingPendingChanges
mergeAtomBatches: %lu deletedLocations: %@
Merging atom batches into %@
Failed to instantiate CKAtomBatch, %@, %@
Generating atom batch after clock: %@, version: %lu
Could not generate atom data from atomBatch: %@, error: %@
atomBatchesAfterClock %@ %@ %@
Unable to create unarchiver %@
Unable to create a record from systemFieldsData for %@
unable to create a record with initWithRecordType for %@
Failed to clear metadata for record %@ in zone %@
Error saving CKRecord in saveCKRecordServerMergeableValue: for %@ %@
clearCKRecordLocalMergeableValueAndSetToSyncForZone %@
Problems updating CKRecords at or before location %@
Problems deleting CKRecords at or before location %@
Failed to delete CKRecords for streamName:%@
Can not delete CKRecord at location %@
Failed to delete all data associated with zone %@
unrecognized transport type (%lu)
syncNowIfPolicyAllowsWithReason: begin rapport sync
syncNowIfPolicyAllowsWithReason: begin cloudkit sync
syncNowIfPolicyAllowsWithReason: group_notify done
last sync: %{public}@ (%f ago), last attempt: %{public}@ (%f ago)
Unable to perform Rapport sync now, because database is not currently accessible
Rapport syncNowWithCompletionHandler %@, errors: %@
skipping rapport sync
Unable to perform CloudKit sync now, because database is not currently accessible
CloudKit syncNowWithCompletionHandler %@, errors: %@
skipping cloudkit sync
transitioned to state %llu
unrecoverable error: %@
database corrupt: %@
database corrupt
error: %@
BMSyncDatabase state queried while opening
failed to close db %@
failed to commit transcation
%@ received nil deviceIdentifier
recordSessionStart: %@
recordSessionEnd: %@
recordMessageToDeviceIdentifier: %@, %@
recordAtomMergeResult: %@, %@
vacuumWithShouldContinueBlock querying page_count: %@
vacuumWithShouldContinueBlock querying freelist_count: %@
vacuumWithShouldContinueBlock calculating pages to vacuum -- pageCount %tu freeCount %tu loadFactor %f
vacuumWithShouldContinueBlock not enough pages to vacuum: pageCount: %lu; freeCount: %lu
vacuumWithShouldContinueBlock error querying auto_vacuum: %@
vacuumWithShouldContinueBlock current vacuum mode is %u
vacuumWithShouldContinueBlock error setting auto_vacuum
vacuumWithShouldContinueBlock successfully set auto_vacuum to INCREMENTAL
vacuumWithShouldContinueBlock error running initial VACUUM
vacuumWithShouldContinueBlock successfully ran initial VACUUM
vacuumWithShouldContinueBlock calculated pages to vacuum: %lu
vacuumWithShouldContinueBlock starting incremental_vacuum of batch size: %lu, pagesVacuumed: %lu
vacuumWithShouldContinueBlock error running incremental_vacuum
vacuumWithShouldContinueBlock successfully completed
%@ sizeOfFileInKilobytes error fetching attributes for filepath: %@, err: %@
%@ numRowsInTable table name: %@ does not exist
%@ numRowsInTable error querying pgsize for table: %@, err: %@
%@ sizeOfTable error querying pgsize for table: %@, err: %@
nil value encountered in [BMStreamCRDTLocation initWithStreamName:%@ siteIdentifier:%@ day:%@]
can not determine streamName
unknown mergeable value ID format version %lu
BMStreamCKRecordCRDT
CKVersionedMergeable
CKMergeable
NSObject
BMSyncCRDTLocationRow
_bmFMResultSet
BMMultiStreamVectorClockConverter
BMSyncSessionContext
BMSyncSessionMetricsCollector
BMSyncSessionMetricsAggregator
BMAtomBatchMaxBytes
BMAtomBatchChunkerPolicy
NSCopying
BMAtomBatchMaxCount
BMAtomBatchChunker
BMSyncDevicePeerTable
BMSyncDevicePeerMetadata
BMPeerToPeerMessageOPACKCodable
BMSyncDevicePeer
BMRapportRequest
BMRapportSyncEngine
BMRapportManagerDelegate
BMSyncCore
BiomeSync
BMMultiStreamTimestampClockVector
NSSecureCoding
NSCoding
BMStreamCKCRDT
BMPBSyncAtomValue
BMSyncCKZone
BMRapportManager
BMRapportDevice
BMPeerToPeerMessage
BMFetchAtomBatchesRequest
BMFetchAtomBatchesResponse
BMSyncPolicy
BatchEnumerate
BMSyncCKAtomRow
BMSyncServiceServerProtocol
BMSyncServiceClientProtocol
BMSyncServiceServer
NSXPCListenerDelegate
BMSyncDevice
BMSync
BMMultiStreamVectorClock
BMSyncDatabase
BMSyncMetadata
BMSyncCKMergeableRecordValue
TombstoneBookmark
BMSyncAtomValue
BMStoreEventAtomValue
BMCloudKitSyncEngine
CKSyncEngineDataSourcePrivate
CKSyncEngineDataSource
BMDistributedSyncManager
BMDistributedSyncMultiStreamManager
BMDistributedSyncMultiStreamManagerFactory
OPACKCodable
BMSyncCKRecord
BMSyncStreamID
BMAsyncBlockOperation
BMSyncScheduler
BMPBStoreEventAtomValue
BMSyncDatabaseSQLStatementMigration
BMSyncDatabaseCustomFunctionMigration
BMSyncDatabaseTransactionBatcher
BMSyncDevicePeerStatusTracker
BMSyncMetricsCollectorTable
Maintenance
BMDateFormatterVendor
BMStreamCRDTLocation
BMStreamCRDTLocationBuilder
BMStreamCRDTLocationDayAssigner
BMStreamCRDTLocationAssignerPolicy
_bmFMDatabase
_bmFMStatement
_bmFMDatabaseAdditions
_bmFMDatabasePool
_bmFMDatabaseQueue
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
B32@0:8@16^@24
@32@0:8@16^@24
B32@0:8@"NSArray"16^@24
@"NSArray"32@0:8@"CKMergeableDeltaMetadata"16^@24
@"CKDistributedTimestampStateVector"16@0:8
@56@0:8@16@24@32@40q48
v24@0:8@16
q16@0:8
v24@0:8q16
v16@0:8
@"BMSyncDatabase"
@"BMStreamCKCRDT"
@"BMSyncCRDTLocationRow"
@"NSObject<OS_dispatch_queue>"
@32@0:8@16Q24
@40@0:8@16Q24Q32
@"BMStreamCRDTLocation"
@24@0:8@16
B32@0:8Q16@24
B32@0:8@16Q24
@24@0:8Q16
@32@0:8@16@24
i16@0:8
v24@0:8Q16
@"NSString"
v44@0:8@16Q24Q32B40
v48@0:8@16B24Q28B36@40
v64@0:8Q16@24@32@40d48@56
@"NSObject<OS_xpc_object>"
@24@0:8^{_NSZone=}16
B24@0:8@"NSData"16
v24@0:8@"NSData"16
v20@0:8B16
@"<BMAtomBatchChunkerPolicy>"
B28@0:8@16B24
B32@0:8@16@24
@24@0:8@"NSDictionary"16
@"NSDictionary"16@0:8
@40@0:8@16@24q32
@40@0:8@16@24Q32
@"BMSyncDevicePeerMetadata"
@56@0:8@16@24@?32@40@?48
v32@0:8@16@24
@?16@0:8
v24@0:8@?16
@"NSObject<OS_os_transaction>"
@"NSMutableSet"
@"NSMutableDictionary"
@"NSUUID"
@"NSObject<OS_dispatch_source>"
@"BMSyncSessionContext"
B32@0:8@"BMRapportManager"16@"BMRapportDevice"24
v32@0:8@"BMRapportManager"16@"BMRapportDevice"24
v24@0:8@"BMRapportManager"16
@48@0:8@16@24@32@40
v40@0:8Q16@24@?32
v40@0:8@16@24@32
v44@0:8B16Q20@28@?36
@36@0:8B16Q20Q28
v60@0:8@16@24@32@40@48B56
v48@0:8@16@24@32@40
I16@0:8
@"BMDistributedSyncMultiStreamManager"
@"BMRapportManager"
@"NSObject<BMAtomBatchChunkerPolicy>"
@"BMSyncDevicePeerStatusTracker"
@"BMSyncSessionMetricsCollector"
@"BMRapportSyncEngine"
@"BMCloudKitSyncEngine"
@"BMSyncScheduler"
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@24@0:8^@16
@64@0:8@16@24@32@40@48@56
@56@0:8@16Q24@32@40@48
@40@0:8@16Q24q32
B48@0:8@16@24^@32^@40
B48@0:8@16@24@32^@40
B60@0:8@16@24@32@40C48q52
v52@0:8@16@24@32C40q44
v32@0:8@16Q24
v60@0:8@16@24@32C40q44@52
v52@0:8@16C24@28Q36@?44
v28@0:8@16B24
@"BMStoreConfig"
@"BMSyncPolicy"
@"BMStreamCRDTLocationBuilder"
@"NSCache"
@"BMSyncStreamID"
@"BMPBStoreEventAtomValue"
{?="type"b1}
@"NSDate"
B28@0:8@16i24
B36@0:8@16i24@28
@28@0:8@16B24
v32@0:8@16@?24
v48@0:8@16@24@32@?40
v56@0:8@16@24@32@40@?48
v28@0:8@16I24
@"RPCompanionLinkClient"
@"<BMRapportManagerDelegate>"
@"RPCompanionLinkDevice"
@"NSMutableArray"
d16@0:8
v24@0:8d16
@"BMSyncDevicePeer"
@"BMMultiStreamVectorClock"
@"NSArray"
@"NSDictionary"
@24@0:8q16
@32@0:8@16q24
d24@0:8Q16
Q24@0:8Q16
B40@0:8Q16Q24^Q32
B32@0:8Q16Q24
B40@0:8q16Q24Q32
@64@0:8@16@24@32@40Q48@56
@72@0:8@16@24@32@40Q48q56@64
@"CKDistributedTimestamp"
@"CKAtomReference"
@"BMStoreBookmark"
@"NSData"
@40@0:8Q16@24@32
B36@0:8@16@24B32
@48@0:8@16Q24@32@40
v40@0:8@16@24@?32
v40@0:8@16Q24@?32
@40@0:8@16@24@32
@40@0:8d16@24@32
v24@0:8@?<v@?@"NSError">16
v24@0:8@?<v@?@"NSArray"@"NSArray">16
v24@0:8@?<v@?@"NSArray"@"NSError">16
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
v32@0:8@?16@?24
@"BMSyncCore"
@"NSXPCListener"
@56@0:8@16@24@32@40@48
@72@0:8@16@24@32@40@48@56@64
@80@0:8@16@24@32@40@48@56@64@72
B40@0:8@16@24@32
@40@0:8Q16@24q32
@"BMStoreEventAtomValue"
@36@0:8@16I24d28
@"CKRecord"32@0:8@"CKSyncEngine"16@"CKRecordID"24
v32@0:8@"CKSyncEngine"16@"CKRecord"24
v40@0:8@"CKSyncEngine"16@"CKRecord"24@"NSError"32
v32@0:8@"CKSyncEngine"16@"CKRecordID"24
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"NSString"32
v32@0:8@"CKSyncEngine"16@"NSData"24
v32@0:8@"CKSyncEngine"16@"CKRecordZone"24
v32@0:8@"CKSyncEngine"16@"CKRecordZoneID"24
v40@0:8@"CKSyncEngine"16@"CKRecordZoneID"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordZone"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"CKRecordID"32
v24@0:8@"CKSyncEngine"16
v32@0:8@"CKSyncEngine"16@"NSArray"24
@"CKSyncEngineBatch"32@0:8@"CKSyncEngine"16@"NSSet"24
v40@0:8@"CKSyncEngine"16@"CKSyncEngineBatch"24@"NSError"32
@"NSArray"24@0:8@"CKSyncEngine"16
B32@0:8@"CKSyncEngine"16@"CKRecordZoneID"24
@"NSArray"40@0:8@"CKSyncEngine"16@"NSArray"24@"NSArray"32
B24@0:8q16
@"NSOperationQueue"
@"<CKSyncEngineDataSource>"
@"CKContainer"
@"CKSyncEngineConfiguration"
@"CKSyncEngine"
@44@0:8@16C24@28Q36
@32@0:8Q16Q24
@60@0:8@16q24Q32Q40C48@52
@"NSNumber"
@40@0:8@16^B24Q32
v40@0:8@16@24Q32
B48@0:8@16@24@32@40
B44@0:8@16@24@32B40
B40@0:8@16@24Q32
@24@0:8@?16
v40@0:8Q16Q24@32
v32@0:8Q16@24
B24@0:8Q16
{?="dataTimestamp"b1"dataVersion"b1}
@"_bmFMDatabase"
B24@0:8@?16
v56@0:8@16@24Q32B40Q44B52
v72@0:8Q16@24@32Q40@48@56d64
Q24@0:8@16
@"NSISO8601DateFormatter"
@"NSDateFormatter"
@40@0:8@16@24d32
@"<BMStreamCRDTLocationAssignerPolicy>"
@"BMStreamCRDTLocation"40@0:8@"NSString"16@"NSString"24d32
@24@0:8d16
^v16@0:8
r*16@0:8
i24@0:8i16i20
B28@0:8i16@20
v20@0:8i16
i36@0:8@16i24^{sqlite3_stmt=}28
v48@0:8@16[1{__va_list_tag=II^v^v}]24@32@40
@52@0:8@16@24@32[1{__va_list_tag=II^v^v}]40B48
B48@0:8^{sqlite3_stmt=}16@24@32[1{__va_list_tag=II^v^v}]40
@40@0:8@16@24^@32
@32@0:8@16[1{__va_list_tag=II^v^v}]24
B56@0:8@16^@24@32@40[1{__va_list_tag=II^v^v}]48
B40@0:8@16@24^@32
B32@0:8@16[1{__va_list_tag=II^v^v}]24
B32@0:8@16@?24
B28@0:8i16^@20
B36@0:8i16@20^@28
B52@0:8i16@20^i28^i36^@44
v36@0:8@16i24@?28
i24@0:8^v16
q24@0:8^v16
d24@0:8^v16
@24@0:8^v16
v24@0:8^v16
v28@0:8i16^v20
v32@0:8q16^v24
v32@0:8d16^v24
v32@0:8@16^v24
v20@0:8I16
@36@0:8@16@24B32
B24@0:8^@16
i24@0:8^@16
i24@0:8@16
i20@0:8i16
q24@0:8@16
q20@0:8i16
Q20@0:8i16
B20@0:8i16
d24@0:8@16
d20@0:8i16
@20@0:8i16
r*20@0:8i16
r*24@0:8@16
B40@0:8@16@24[1{__va_list_tag=II^v^v}]32
@"_bmFMStatement"
@28@0:8@16i24
@36@0:8@16i24@28
v32@0:8q16@?24
softlink:r:path:/System/Library/PrivateFrameworks/BiomeLibrary.framework/BiomeLibrary
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>BuildMachineOSBuild</key>
<string>20A241133</string>
<key>CFBundleIdentifier</key>
<string>com.apple.biomesyncd</string>
<key>CFBundleSupportedPlatforms</key>
<array>
<string>iPhoneSimulator</string>
</array>
<key>DTCompiler</key>
<string>com.apple.compilers.llvm.clang.1_0</string>
<key>DTPlatformBuild</key>
<string>20A5324u</string>
<key>DTPlatformName</key>
<string>iphonesimulator</string>
<key>DTPlatformVersion</key>
<string>16.0</string>
<key>DTSDKBuild</key>
<string>20A5324u</string>
<key>DTSDKName</key>
<string>iphonesimulator16.0.internal</string>
<key>DTXcode</key>
<string>1400</string>
<key>DTXcodeBuild</key>
<string>14A5229d</string>
<key>MinimumOSVersion</key>
<string>16.0</string>
<key>UIDeviceFamily</key>
<array>
<integer>1</integer>
<integer>2</integer>
</array>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>application-identifier</key>
<string>com.apple.biomesyncd</string>
<key>aps-connection-initiate</key>
<true/>
<key>aps-environment</key>
<string>serverPreferred</string>
<key>com.apple.CompanionLink</key>
<true/>
<key>com.apple.application-identifier</key>
<string>com.apple.biomesyncd</string>
<key>com.apple.developer.aps-environment</key>
<string>serverPreferred</string>
<key>com.apple.developer.icloud-container-environment</key>
<string>Production</string>
<key>com.apple.developer.icloud-container-identifiers</key>
<array>
<string>com.apple.biome.sync</string>
</array>
<key>com.apple.developer.icloud-services</key>
<array>
<string>CloudKit</string>
</array>
<key>com.apple.private.appleaccount.app-hidden-from-icloud-settings</key>
<true/>
<key>com.apple.private.aps-connection-initiate</key>
<true/>
<key>com.apple.private.biome.client-identifier</key>
<string>com.apple.biomesyncd</string>
<key>com.apple.private.biome.read-write</key>
<array>
<string>ContextSync.LOI</string>
</array>
<key>com.apple.private.biome.sensorActivation</key>
<true/>
<key>com.apple.private.cloudkit.serviceNameForContainerMap</key>
<dict>
<key>com.apple.biome.sync</key>
<string>com.apple.biome.sync</string>
</dict>
<key>com.apple.private.cloudkit.spi</key>
<true/>
<key>com.apple.private.ids.messaging</key>
<array>
<string>com.apple.private.alloy.contextsync</string>
</array>
<key>com.apple.private.ids.messaging.urgent-priority</key>
<array>
<string>com.apple.private.alloy.contextsync</string>
</array>
<key>com.apple.private.sandbox.profile:embedded</key>
<string>temporary-sandbox</string>
<key>com.apple.private.security.storage.Biome</key>
<true/>
<key>com.apple.private.tcc.allow</key>
<array>
<string>kTCCServiceLiverpool</string>
</array>
<key>com.apple.security.exception.files.home-relative-path.read-write</key>
<array>
<string>/Library/Biome/sync/</string>
<string>/Library/Biome/streams/public</string>
<string>/Library/Biome/streams/public/DeviceMetadata/</string>
<string>/Library/Biome/streams/public/AppIntent/</string>
<string>/Library/Biome/streams/public/AppLaunch/</string>
<string>/Library/Biome/streams/public/Workout/</string>
<string>/Library/Biome/streams/restricted</string>
<string>/Library/Biome/streams/restricted/feedbackSocialHighlights/</string>
<string>/Library/Biome/streams/restricted/SiriMemoryReferenceResolutionStream/</string>
<string>/Library/Biome/streams/restricted/Device.Power.PluggedIn/</string>
<string>/Library/Biome/streams/restricted/Device.Wireless.WiFi/</string>
<string>/Library/Biome/streams/restricted/Device.Power.BatteryLevel/</string>
</array>
<key>com.apple.security.exception.mach-lookup.global-name</key>
<array>
<string>com.apple.CompanionLink</string>
<string>com.apple.biomed.sensorActivation</string>
<string>com.apple.cloudd</string>
<string>com.apple.apsd</string>
<string>com.apple.identityservicesd.embedded.auth</string>
</array>
<key>com.apple.security.exception.shared-preference.read-only</key>
<array>
<string>com.apple.CloudKit</string>
<string>com.apple.ids</string>
<string>com.apple.facetime.bag</string>
</array>
<key>com.apple.security.exception.shared-preference.read-write</key>
<array>
<string>com.apple.biomesyncd</string>
<string>com.apple.contextsync.subscriptions</string>
</array>
<key>com.apple.security.network.client</key>
<true/>
<key>com.apple.security.network.server</key>
<true/>
<key>com.apple.security.ts.mobile-keybag-access</key>
<true/>
<key>com.apple.security.ts.tmpdir</key>
<string>com.apple.biomesyncd</string>
<key>com.apple.wifi.manager-access</key>
<true/>
<key>platform-application</key>
<true/>
</dict>
</plist>
@(#)PROGRAM:biomesyncd  PROJECT:BiomeSync-98.0.2
CREATE TABLE Metadata (
 key TEXT UNIQUE PRIMARY KEY ON CONFLICT REPLACE NOT NULL,
 value
CREATE TABLE CKAtom (
 stream STRING NOT NULL,
 -- CKDistributedTimestamp
 site BLOB NOT NULL,
 clock INTEGER NOT NULL,
 type INTEGER NOT NULL,
 -- CRDTLocation
 location_id INTEGER NOT NULL,
 -- BMStoreBookmark
 segment_name TEXT,
 segment_offset INTEGER,
 -- CKAtomReference
 ref_type INTEGER,
 ref_site BLOB,
 ref_clock INTEGER,
 ref_location_id INTEGER,
 -- CKAtom value
 value_version INTEGER,
 value_data BLOB,
 on_disk BOOLEAN,
 CONSTRAINT "ref_type <=> (ref_site AND ref_clock)"
 CHECK ((ref_type IS NULL) == ((ref_site IS NULL) AND (ref_clock IS NULL))),
 CONSTRAINT "(ref_type, ref_site, ref_clock) != (type, site, clock)"
 CHECK (ref_type != type OR ref_site != site OR ref_clock != clock),
 CONSTRAINT "segment_name <=> segment_offset"
 CHECK ((segment_name IS NULL) == (segment_offset IS NULL)),
 CONSTRAINT "on_disk <=> segment_name"
 CHECK (CASE WHEN on_disk NOTNULL THEN segment_name NOTNULL ELSE segment_name ISNULL END),
 CONSTRAINT "on_disk <=> !data"
 CHECK (CASE WHEN on_disk NOTNULL THEN value_data ISNULL ELSE value_data NOTNULL END)
 FOREIGN KEY (location_id) REFERENCES CRDTLocation(id),
 FOREIGN KEY (ref_location_id) REFERENCES CRDTLocation(id)
 UNIQUE (stream, site, type, clock),
 UNIQUE (stream, site, clock, on_disk),
 UNIQUE (stream, site, type, clock, on_disk),
 UNIQUE (stream, site, type, segment_name, segment_offset)
CREATE INDEX idx_ckatom_ref_clock_type ON CKAtom(stream, ref_clock, type);
CREATE INDEX idx_ckatom_segment_name ON CKAtom(stream, segment_name);
CREATE TABLE CRDTLocation (
 id INTEGER primary key,
 stream STRING NOT NULL,
 site STRING NOT NULL,
 day INTEGER NOT NULL,
 state INTEGER NOT NULL
CREATE INDEX idx_crdt_location ON CRDTLocation(stream, site, day);
CREATE INDEX idx_crdt_location_state ON CRDTLocation(stream, site, state, day DESC);
CREATE TABLE TombstoneBookmark (
 stream STRING NOT NULL,
 site BLOB NOT NULL,
 segment_name TEXT,
 segment_offset INTEGER
CREATE INDEX idx_tombstone_bookmark ON TombstoneBookmark(stream, site);
CREATE TABLE DevicePeer (
 device_identifier STRING NOT NULL,
 me BOOLEAN,
 name STRING,
 model STRING,
 platform INTEGER,
 last_sync_date INTEGER,
 protocol_version INTEGER NOT NULL
CREATE TABLE SyncSessionLog (
 session_id BLOB,
 start_timestamp INTEGER,
 end_timestamp INTEGER,
 transport INTEGER,
 reason INTEGER,
 is_reciprocal BOOL
CREATE TABLE SyncMessageLog (
 session_id BLOB,
 message_id INTEGER,
 timestamp INTEGER,
 device_identifier STRING,
 reachable BOOL,
 is_reciprocal BOOL,
 atom_batch_bytes INTEGER
CREATE INDEX idx_syncmessagelog_session_id ON SyncMessageLog(session_id);
CREATE TABLE AtomMergedLog (
 session_id BLOB,
 message_id INTEGER,
 stream STRING,
 merge_result INTEGER,
 owning_site_identifier STRING,
 relayed_by_site_identifier STRING,
 synced_at INTEGER,
 event_created_at INTEGER
CREATE INDEX idx_atommergedlog_session_id ON AtomMergedLog(session_id);
CREATE INDEX idx_atommergedlog_owning_site_identifier ON AtomMergedLog(owning_site_identifier);
CREATE TABLE CKRecord (
 location_id INTEGER,
 sync_to_cloud_kit BOOL,
 record_metadata BLOB,
 record_name STRING,
 stream_identifier STRING,
 local_mergeable_value BLOB,
 deleting BOOL,
 record_type INTEGER,
 PRIMARY KEY (stream_identifier, record_name)
 FOREIGN KEY (location_id) REFERENCES CRDTLocation(id)
CREATE INDEX idx_ckrecord ON CKRecord(record_name);
CREATE TABLE CKMergeableRecordValue (
 stream_name STRING,
 record_name STRING,
 server_mergeable_value BLOB,
 FOREIGN KEY (stream_name, record_name) REFERENCES CKRecord(stream_identifier, record_name)
CREATE TABLE CKZone (
 zone_name STRING NOT NULL,
 zone_uuid STRING NOT NULL,
 recovery_state INTEGER,
 attempted_recovery_date INTEGER
333333
sendEventID:event:options:completion:
setInterruptionHandler:
pointerValue
writeEventBodyClass:
longValue
characterAtIndex:
dictionaryWithObject:forKey:
nextObject
timestamps
setInvalidationHandler:
array
dictionaryWithObjects:forKeys:count:
registerRequestID:options:handler:
zoneID
lowercaseString
UUID
nextTombstoneEvent
arrayWithArray:
initWithConfiguration:
UUIDString
initWithRecordName:zoneID:
datastorePath
arrayWithCapacity:
setValue:
initWithContainerID:options:
initWithRecordType:recordID:
unarchivedObjectOfClass:fromData:error:
popFirstObject
arrayWithObjects:
setValue:forKey:
initWithContainerIdentifier:environment:
didChangeValueForKey:
null
sendRequestID:request:options:responseHandler:
isSubsetOfSet:
arrayWithObjects:count:
stringByAppendingPathComponent:
unarchivedObjectOfClasses:fromData:error:
initWithSiteIdentifierObject:clockValue:
stringByAppendingString:
unionSet:
keyEnumerator
initWithData:
maxAge
numberWithBool:
initWithStoreBasePath:segmentSize:
unordered
stringByDeletingLastPathComponent
privateCloudDatabase
initWithData:encoding:
remoteStreamName
numberWithDouble:
containsObject:
initWithStream:config:
setLocalDeviceUpdatedHandler:
stringByDeletingPathExtension
processWithXPCConnection:
setVersion:
unsignedCharValue
initWithData:error:
initWithStream:permission:config:includeTombstones:
containsString:
numberWithFloat:
unsignedIntValue
stringByReplacingOccurrencesOfString:withString:
dateWithTimeIntervalSince1970:
removeAllObjects
dispatchQueue
setLocale:
initWithStream:segment:iterationStartTime:offset:
numberWithInt:
contentsVector
unsignedIntegerValue
dateWithTimeIntervalSinceReferenceDate:
distantPast
setWithArray:
removeItemAtPath:error:
numberWithInteger:
contextSyncManager
fetchChangesWithCompletionHandler:
lastIndex
proximity
setMaxConcurrentOperationCount:
distributedSiteIdentifier
setWithObjects:
initWithDatabase:dataSource:metadata:
removeLastObject
copy
_writeEventData:dataVersion:timestamp:outBookmark:
numberWithLong:
proxyAtIndex:
unsignedLongLongValue
removeObject:
mergeIntoMergeable:error:
numberWithLongLong:
accountInfoWithCompletionHandler:
fileExistsAtPath:
atomType
decodeObjectOfClass:forKey:
stringWithCapacity:
unsignedLongValue
pruningPolicy
removeObjectForKey:
mergeRecordValue:error:
lastObject
shortValue
stringWithFormat:
accountStatus
fileSize
decodeObjectOfClasses:forKey:
numberWithShort:
unsignedShortValue
initWithDictionary:
count
stringWithUTF8String:
numberWithUnsignedChar:
setModifier:
fileSystemRepresentation
hasPrefix:
mergeableValueID
raise
domain
initWithTimeIntervalSinceReferenceDate:
countByEnumeratingWithState:objects:count:
numberWithUnsignedInt:
substringFromIndex:
fileURLWithPath:
siteIdentifierObject
numberWithUnsignedInteger:
initWithTimestamps:
setAtomBehavior:
activateWithCompletion:
substringToIndex:
setNeedsToFetchChanges
defaultManager
finishWritingWithError:
setAtomType:
activeDevices
numberWithUnsignedLong:
substringWithRange:
setObject:forKey:
size:error:
doubleValue
methodForSelector:
numberWithUnsignedLongLong:
setAutomaticSyncingEnabled:
suggestedDeltaSizeForContainer:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
setObject:forKeyedSubscript:
initWithFormat:
attributesOfItemAtPath:error:
firstIndex
length
numberWithUnsignedShort:
identifier
splitWithMaximumSize:error:
encodeObject:forKey:
initWithFormat:arguments:
floatValue
initWithZoneID:
objCType
initWithIdentifier:
encodeSystemFieldsWithCoder:
frame
initWithZoneName:
objectAtIndex:
initWithIdentifier:modifier:
clockValue
minusSet:
encodedData
addClockValuesInIndexSet:forSiteIdentifier:
initWithZoneName:ownerName:
initWithIndex:
clockValuesForSiteIdentifier:
encryptedValues
currentHandler
addClockValuesInIndexSet:withAtomState:forSiteIdentifier:
syncDirectory
objectEnumerator
deleteEventAtBookmark:outTombstoneBookmark:
idsDeviceIdentifier
modifier
enumerateAtomsWithOptions:usingBlock:
standardUserDefaults
initWithLocaleIdentifier:
initWriterWithMergeableValueID:metadata:formatVersion:error:
addDeltasToSaveFromMergeable:error:
setRemoteObjectInterface:
modifyPendingChangesWithCompletionHandler:
data
setClock:
addEntriesFromDictionary:
setRemoteStreamName:
userInfo
recordChangeTag
resume
addObject:
setControlFlags:
indexSetWithIndex:
enumerateRangesUsingBlock:
objectForKey:
addObjectsFromArray:
indexSetWithIndexesInRange:
deletionReason
setServiceType:
recordID
code
initWithMachServiceName:
addOperation:
intValue
recordIDsToDelete
integerValue
addRecordIDsToSave:recordIDsToDelete:
objectsPassingTest:
deregisterRequestID:
recordIDsToSave
mutableCopy
localizedFailureReason
dataUsingEncoding:
offset
interfaceWithProtocol:
addRecordZonesToSave:recordZoneIDsToDelete:
initWithMergeableDelta:error:
setDestinationDevice:
valueForKey:
timeIntervalSince1970
initForReadingFromData:error:
errorWithDomain:code:userInfo:
newEnumeratorFromBookmark:options:
initWithMergeableValueID:timestamp:type:
allObjects
timeIntervalSinceDate:
setDeviceChangedHandler:
dataWithBytes:length:
setSiteIdentifier:
setDeviceFoundHandler:
timeIntervalSinceNow
dataWithBytesNoCopy:length:freeWhenDone:
initRequiringSecureCoding:
statusFlags
newEnumeratorFromStartTime:options:
eventBody
initWithName:zoneID:
timeIntervalSinceReferenceDate
allSiteIdentifiers
setDeviceLostHandler:
invalidate
initWithArray:
boolForEntitlement:
dataWithError:
eventBodyClass
compare:
valueWithNonretainedObject:
osBuildVersion
allValues
setDispatchQueue:
timeZoneForSecondsFromGMT:
boolValue
compareToTimestampVector:
newRestrictedStreamDefaultConfiguration
allocWithZone:
setExpirationAfterTimeInterval:
isCancelled
recordType
compareToVector:
newTombstoneEnumeratorFromBookmark:
setExportedInterface:
pathForStreamIdentifier:streamType:
anyObject
initWithAtomBatch:error:
setStoreLocationOption:
bytes
deviceToDeviceEncryptionAvailability
segmentName
storeConfigurationForStream:
exceptionWithName:reason:userInfo:
appendAtomWithBlock:
setExportedObject:
isEqualToDate:
reference
setTimeZone:
newTombstoneEnumeratorFromStartTime:
segmentSize
isEqualToReference:
appendFormat:
setFetchChangesForMergeableValues:
setType:
dictionary
handleFailureInFunction:file:lineNumber:description:
setIdentifier:
timestampCount
appendString:
isEqualToSet:
references
setUnderlyingQueue:
willChangeValueForKey:
streamForStreamIdentifier:
sendEvent:payload:
componentsJoinedByString:
handleFailureInMethod:object:file:lineNumber:description:
appendWithProxyBlock:
UTF8String
isEqualToString:
timestampCountForSiteIdentifier:
initWithCapacity:
setUnordered:
registerEventID:options:handler:
longLongValue
dictionaryWithCapacity:
componentsSeparatedByString:
charValue
nextEvent
archivedDataWithRootObject:requiringSecureCoding:error:
init
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
mergeDeltas:error:
mergeableDeltasForMetadata:error:
stateVector
deltaDeliveryRequirements
initWithStreamCRDT:locationRow:database:queue:maxDeltaSize:
streamCRDT
locationRow
queue
setQueue:
maxDeltaSize
setMaxDeltaSize:
.cxx_destruct
_streamCRDT
_locationRow
_queue
_maxDeltaSize
T@"BMStreamCKCRDT",R,N,V_streamCRDT
T@"BMSyncCRDTLocationRow",R,N,V_locationRow
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
Tq,N,V_maxDeltaSize
initWithLocation:state:
initWithLocation:state:primaryKey:
location
state
primaryKey
_location
_state
_primaryKey
T@"BMStreamCRDTLocation",R,N,V_location
TQ,R,N,V_state
TQ,R,N,V_primaryKey
initWithFMResultSet:modifier:
locationRowWithLocation:
locationRowWithLocationID:
updateLocationState:forLocation:
updateAllLocationsAtOrBefore:state:
insertLocationIfNotExists:withState:
upsertLocation:
removeAllDeletedLocationsBeforeHighestDeletedLocation:
previousLocationRowBeforeLocationRow:
locationsWithState:
highestDeletedLocationsForStream:
highestDeletedLocationForSiteIdentifier:inStream:
CRDTLocationCount
_reinitializeSiteIdentifier:
timestampVectorToTimeStampClockVector:
timestampClockVectorToTimeStampVector:
multiStreamTimestampClockVectorToVectorClock:
multiStreamVectorClockToTimestampVectorClock:
rangeTimestampClockVectorFromIndexClockVector:
multiStreamRangeClockVectorFromIndexClockVectors:
sessionID
setSessionID:
messageID
setMessageID:
originatingSiteIdentifier
setOriginatingSiteIdentifier:
_sessionID
_messageID
_originatingSiteIdentifier
T@"NSString",&,N,V_sessionID
TQ,N,V_messageID
T@"NSString",&,N,V_originatingSiteIdentifier
initWithDatabase:
sessionContext
recordSessionStart:transport:reason:isReciprocal:
recordSessionEnd:
recordMessageToDeviceIdentifier:reachable:bytes:isReciprocal:sessionContext:
recordAtomMergeResult:inStream:ownerSite:originatingSite:eventCreatedAt:sessionContext:
_database
initWithDatabase:activity:
computeAndSendAggregatedMetrics
computeAggregatedSessionLogs
compactAndDeleteSessionLogs
_activity
copyWithZone:
canAddAtomWithData:
didAddAtomWithData:
initWithMaxBytes:
_maxBytes
_usedBytes
initWithMaxCount:
_maxCount
_atomCount
initWithChunkerPolicy:
moreComing
setMoreComing:
_chunkerPolicy
_moreComing
TB,N,V_moreComing
initWithFMResultSet:
localDevice
upsertSyncDevicePeer:isMe:
deviceWithIdentifier:
lastSyncDateFromAnyDevice
lastSyncDateOfDeviceWithIdentifier:
setLastSyncDate:forDeviceWithIdentifier:
allPeers
devicePeerMetadata
initFromDictionary:
dictionaryRepresentation
initWithName:model:platform:
name
model
platform
_name
_model
_platform
T@"NSString",R,C,N,V_name
T@"NSString",R,C,N,V_model
Tq,R,N,V_platform
initWithDeviceIdentifier:metadata:protocolVersion:
deviceIdentifier
metadata
protocolVersion
setProtocolVersion:
_deviceIdentifier
_metadata
_protocolVersion
T@"NSString",R,C,N,V_deviceIdentifier
T@"BMSyncDevicePeerMetadata",R,N,V_metadata
TQ,N,V_protocolVersion
initWithUUID:activity:requestBlock:queue:completionHandler:
runRequestOnDevice:
markAsInFlightToDevice:
markAsDeliveredToDevice:withError:
startRequestTimeout
stopRequestTimeout
requestTimeoutDidFire
setState:
uuid
setUuid:
activity
setActivity:
requestBlock
setRequestBlock:
completionHandler
setCompletionHandler:
deliveredToDevices
setDeliveredToDevices:
inFlightToDevices
setInFlightToDevices:
errorFromDevice
setErrorFromDevice:
requestTimeout
setRequestTimeout:
requestTimeoutHandler
setRequestTimeoutHandler:
setSessionContext:
_transaction
_deliveredToDevices
_inFlightToDevices
_errorFromDevice
_uuid
_requestBlock
_completionHandler
_requestTimeout
_requestTimeoutHandler
_sessionContext
TQ,N,V_state
T@"NSUUID",&,N,V_uuid
T@"NSObject<OS_xpc_object>",&,N,V_activity
T@?,C,N,V_requestBlock
T@?,C,N,V_completionHandler
T@"NSSet",&,N,V_deliveredToDevices
T@"NSSet",&,N,V_inFlightToDevices
T@"NSDictionary",&,N,V_errorFromDevice
T@"NSObject<OS_dispatch_source>",&,N,V_requestTimeout
T@?,C,N,V_requestTimeoutHandler
T@"BMSyncSessionContext",&,N,V_sessionContext
rapportManager:isDeviceSupported:
rapportManager:didDiscoverBMRapportDevice:
rapportManager:didLoseNearbyBMRapportDevice:
rapportManager:localDeviceUpdated:
rapportManagerDiscoveryTimedOut:
initWithDistributedSyncMultiStreamManager:queue:
initWithDistributedSyncMultiStreamManager:rapportManager:atomBatchChunkerPolicy:queue:
startClient
startServer
syncNowWithReason:activity:completionHandler:
completeRequestIfDeliveredToAllNearbyDevices:
completeRequest:deliveredToDevices:withErrors:
runRequest:onDevice:
fetchAtomBatchesIsReciprocal:reason:activity:completionHandler:
sendFetchAtomBatchesRequest:toDevice:forRequest:
buildAtomBatchRequestWithIsReciprocal:sequenceNumber:transportType:
registerRequests
fetchAtomBatchesRequestHandler
handleFetchAtomBatchesResponse:options:error:fromDevice:forRequest:isReciprocal:
finishRequest:toDevice:withError:peerInfo:
localDeviceUpdatingIfNecessary
siteSuffix
peerStatusTracker
metricsCollector
setMetricsCollector:
reciprocalCompletionBlock
setReciprocalCompletionBlock:
_syncManager
_rapportManager
_requestQueue
_localDeviceIdentifier
_atomBatchChunkerPolicy
_peerStatusTracker
_metricsCollector
_reciprocalCompletionBlock
T@?,C,N,V_reciprocalCompletionBlock
T@"NSObject<OS_dispatch_queue>",R,N,V_queue
T@"BMSyncDevicePeerStatusTracker",R,N,V_peerStatusTracker
T@"BMSyncSessionMetricsCollector",&,N,V_metricsCollector
initWithQueue:
start
database
setDatabase:
distributedSyncMultiStreamManager
setDistributedSyncMultiStreamManager:
rapportSyncEngine
setRapportSyncEngine:
cloudKitSyncEngine
setCloudKitSyncEngine:
syncScheduler
setSyncScheduler:
_distributedSyncMultiStreamManager
_rapportSyncEngine
_cloudKitSyncEngine
_syncScheduler
T@"BMSyncDatabase",&,N,V_database
T@"BMDistributedSyncMultiStreamManager",&,N,V_distributedSyncMultiStreamManager
T@"BMRapportSyncEngine",&,N,V_rapportSyncEngine
T@"BMCloudKitSyncEngine",&,N,V_cloudKitSyncEngine
T@"BMSyncScheduler",&,N,V_syncScheduler
sendSyncSessionLog:
sendSyncDatabaseSummaryWithDatabase:
dictionaryWithSyncDatabase:
supportsSecureCoding
deserialize:error:
encodeWithCoder:
initWithCoder:
TB,R
setVectorClockTo:forStreamIdentifier:
timestampClockVectorForStreamIdentifier:
allKeys
serialize:
_vectorClock
initWithStreamID:config:policy:locationAssignerPolicy:localSiteIdentifier:database:
newEnumeratorFromBookmark:reader:
newTombstoneEnumeratorFromBookmark:reader:
ckAtomTableRecordForEvent:ofType:atBookmark:previousTableRecord:siteIdentifier:
atomValueFromEvent:ofType:version:
handleDeleteAtomRow:usingPruner:outBookmark:outTombstoneBookmark:
writeAtomValue:fromAtomRow:usingWriter:outBookmark:
addAtomToAtomBatch:ifChunkerAllows:fromAtomTableRecord:atomValueData:version:atomValueVersion:
addAtomWithValueData:toAtomBatch:fromAtomTableRecord:version:atomValueVersion:
readerForSiteIdentifier:
ingestNewChangesFromAllSitesInVectorClock:transportType:
ingestNewChangesForSite:transportType:
deleteLocationsUpToTTLAtTombstone:siteIdentifier:
deletedExpiredBufferedLocationsForSiteIdentifier:
deleteAtOrBeforeHighestDeletedLocation:
populateAtomBatch:withAtomsInClockVector:forLocation:ckFormatVersion:valueVersion:chunker:
atomsInClockVector:ckFormatVersion:chunker:transportType:enumerateWithBlock:
handleDeletedLocation:deleteCKRecord:
mergeAtomBatch:sessionContext:
mergeAtomBatches:sessionContext:forLocation:
clockVector
streamID
streamName
_localSiteIdentifier
_config
_policy
_locationBuilder
_locationRowCache
_streamID
_streamName
T@"BMSyncStreamID",R,N,V_streamID
T@"NSString",R,N,V_streamName
readFrom:
writeTo:
_type
_value
_has
zoneName
zoneUUID
recoveryState
attemptedRecoveryDate
_recoveryState
_zoneName
_zoneUUID
_attemptedRecoveryDate
T@"NSString",R,N,V_zoneName
T@"NSString",R,N,V_zoneUUID
Ti,R,N,V_recoveryState
T@"NSDate",R,N,V_attemptedRecoveryDate
ckZoneExists:
ckZoneForZoneName:
ckZoneSetAttemptingRecoveryForZoneName:state:
ckZoneSetZoneVersionUUID:forZoneName:
ckZoneSetAttemptedRecoveryDate:state:forZoneName:
enumerateZonesWithBlock:
initWithQueue:forSharedUse:
registerForSigterm
createDiscoveryClientIfNotExists
createSharedDiscoveryClientIfNotExists
createDiscoveryClientWithControlFlags:
activateDiscoveryLinkWithCompletion:
activateDiscoveryClientWithCompletion:
handleDiscoveryClientActivationOrError:
handleDiscoveryClientInvalidation
registerRequestID:requestHandler:
registerEventID:eventHandler:
discoveredDevices
stop
sendRequest:request:toDevice:responseHandler:
sendRequest:request:device:options:responseHandler:
sendEvent:event:toDevice:completionHandler:
activateDirectLinkToDevice:completionHandler:
invalidateDirectLinkToDevice:
handleActivationForDevice:error:
handleInterruptionForDevice:
sendNextRequestToDevice:
finishedSendingRequestsToDevice:
device:didChange:
didDiscoverDevice:
didLoseDevice:
localDeviceUpdated:
delegate
setDelegate:
registeredRequests
setRegisteredRequests:
_discoveryClient
_discoveryClientState
_devices
_unsupportedDevices
_sharedUse
_sigtermSource
_delegate
_registeredRequests
T@"NSMutableDictionary",&,N,V_registeredRequests
T@"<BMRapportManagerDelegate>",W,N,V_delegate
initWithRPCompanionLinkDevice:
shortenedRapportIdentifier
serviceTypes
invalidateClientWithError:
handleInvalidationWithError:
rapportIdentifier
bmDeviceIdentifier
setBmDeviceIdentifier:
device
setDevice:
client
setClient:
requestQueue
setRequestQueue:
linkState
setLinkState:
_rapportIdentifier
_bmDeviceIdentifier
_device
_client
_linkState
T@"NSMutableArray",&,N,V_requestQueue
T@"NSArray",R,N
TQ,N,V_linkState
T@"NSString",R,N,V_rapportIdentifier
T@"NSString",R,N
T@"NSString",&,N,V_bmDeviceIdentifier
T@"RPCompanionLinkDevice",&,N,V_device
T@"RPCompanionLinkClient",&,N,V_client
Tq,R,N
peer
setPeer:
walltime
setWalltime:
_peer
_walltime
T@"BMSyncDevicePeer",&,N,V_peer
Td,N,V_walltime
vectorClock
setVectorClock:
atomBatchVersion
setAtomBatchVersion:
isReciprocalRequest
setIsReciprocalRequest:
batchSize
setBatchSize:
batchSequenceNumber
setBatchSequenceNumber:
_isReciprocalRequest
_atomBatchVersion
_batchSize
_batchSequenceNumber
T@"BMMultiStreamVectorClock",&,N,V_vectorClock
TQ,N,V_atomBatchVersion
TB,N,V_isReciprocalRequest
TQ,N,V_batchSize
TQ,N,V_batchSequenceNumber
unseenPeers
setUnseenPeers:
atomBatches
setAtomBatches:
atomBatchBytes
setAtomBatchBytes:
deletedLocations
setDeletedLocations:
_unseenPeers
_atomBatches
_atomBatchBytes
_deletedLocations
T@"NSArray",&,N,V_unseenPeers
T@"NSDictionary",&,N,V_atomBatches
TQ,N,V_atomBatchBytes
T@"NSDictionary",&,N,V_deletedLocations
bmUserDefaultsString:
loadAdditionalSyncPolicyDictionaries
syncableStreamIDs
eventStringFromDescriptor:
syncableStreamIDsForPlatform:
policyForStreamID:
policyForStreamID:forPlatform:
minimumTimeBetweenSyncsForTransport:
minimumTimeBetweenSyncsAttemptsForTransport:
initWithStreamID:policyDictionary:
directionsSupportedForTransport:
_supportsTransport:direction:outSupportedDirections:
supportsTransport:direction:
supportsSyncingWithPlatform:overTransport:inDirection:
registeredEventClass
_policyDictionary
enumerateWithBlock:
initWithLocation:timestamp:referenceLocation:causalReference:type:bookmark:
initWithLocation:timestamp:referenceLocation:causalReference:type:valueVersion:valueData:
timestamp
referenceLocation
causalReference
bookmark
type
valueVersion
valueData
_timestamp
_referenceLocation
_causalReference
_bookmark
_valueVersion
_valueData
T@"BMSyncCRDTLocationRow",R,N,V_location
T@"CKDistributedTimestamp",R,N,V_timestamp
T@"BMSyncCRDTLocationRow",R,N,V_referenceLocation
T@"CKAtomReference",R,N,V_causalReference
T@"BMStoreBookmark",R,N,V_bookmark
TQ,R,N,V_type
Tq,R,N,V_valueVersion
T@"NSData",R,N,V_valueData
addCKAtomRow:inStream:
ckAtomRowWithTimestamp:inStream:
latestCKAtomRowForSiteIdentifier:inStream:
timestampClockVectorForStreamName:
stateVectorForLocationRow:
latestCKAtomRowOfType:forSiteIdentifier:inStream:
ckAtomCount
containsCKAtomRowWithTimestamp:inStream:
containsCKAtomRowWithTimestamp:inStream:onDisk:
updateCKAtomRow:inStream:
ckAtomRowForAtomWithBookmark:type:forSiteIdentifier:inStream:
latestDistributedTimestampForSiteIdentifier:inStream:
containsCKAtomRowWithSegment:inStream:
CKAtomRowSiteIdentifiers
atomRowsNotOnDiskReferencingSiteIdentifier:inStream:enumerateWithBlock:
atomsAtOrBeforeLocation:ofType:enumerateWithBlock:
deleteAllAtomsAtOrBeforeLocation:
locationsInClockVector:inStream:enumerateWithBlock:
atomRowsInTimestampClockVector:forLocation:inStream:enumerateWithBlock:
computeHighestLocationToDeleteUpToBookmark:forSiteIdentifier:inStream:
highestLocationWithBufferedAtomsOlderThan:forSiteIdentifier:inStream:
SELECT_ATOMS_WHERE:ORDER_BY:LIMIT:
triggerRapportSyncWithReply:
triggerCloudKitSyncWithReply:
rapportSyncWithReply:
cloudKitSyncWithReply:
peerInformationWithReply:
listener:shouldAcceptNewConnection:
initWithQueue:core:
_cloudKitSyncWithSyncTriggeredHandler:syncCompletedHandler:
_rapportSyncWithSyncTriggeredHandler:syncCompletedHandler:
_core
_listener
currentDevice
bm_companionLinkDeviceIdentifier
T@"NSString",R
vectorClockForStreamIdentifier:
SELECT_FROM:COLUMNS:WHERE:
SELECT_FROM:COLUMNS:WHERE:ORDER_BY:LIMIT:
SELECT_FROM:COLUMNS:JOIN:WHERE:ORDER_BY:LIMIT:
SELECT_FROM:COLUMNS:WHERE:GROUP_BY:
_SELECT_FROM:COLUMNS:JOIN:WHERE:GROUP_BY:ORDER_BY:LIMIT:
SELECT_FROM:COLUMNS:JOIN:WHERE:GROUP_BY:HAVING:ORDER_BY:LIMIT:
UPDATE:SET:WHERE:
INSERT_INTO:VALUES:
DELETE_FROM:WHERE:
bm_description
lastRapportSyncAttemptDate
setLastRapportSyncAttemptDate:
lastCloudKitSyncAttemptDate
setLastCloudKitSyncAttemptDate:
ckSyncEngineMetaData
saveCKSyncEngineMetaData:
clearCKSyncEngineMetaData
mergeableRecordValueKey
setMergeableRecordValueKey:
T@"NSDate",&,N
T@"NSString",&,N
saveCKMergeableRecordValueRecordName:zoneName:mergeableRecordValueData:
clearCKMergeableRecordValueServerMergeableValuesForRecordName:zoneName:
clearCKMergeableRecordValueServerMergeableValuesForZoneName:
enumerateMergeableRecordValuesForRecordName:zoneName:withBlock:
latestTombstoneBookmarkForSiteIdentifier:inStream:
saveLatestTombstoneBookmark:forSiteIdentifier:inStream:
atomValueFromData:version:
initWithAtomType:value:version:
serializeProto
encodeAsProto
initWithProto:
initWithProtoData:
proto
serialize
value
version
_version
T@"BMStoreEventAtomValue",R,N,V_value
Tq,R,N,V_version
initWithEventData:dataVersion:dataTimestamp:
eventData
dataVersion
dataTimestamp
_dataVersion
_eventData
_dataTimestamp
T@"NSData",R,N,V_eventData
TI,R,N,V_dataVersion
Td,R,N,V_dataTimestamp
syncEngine:recordToSaveForRecordID:
syncEngine:didSaveRecord:
syncEngine:failedToSaveRecord:error:
syncEngine:didDeleteRecordWithID:
syncEngine:failedToDeleteRecordWithID:error:
syncEngine:didFetchRecord:
syncEngine:recordWithIDWasDeleted:recordType:
syncEngine:didUpdateMetadata:
syncEngine:didSaveRecordZone:
syncEngine:didDeleteRecordZoneWithID:
syncEngine:failedToFetchChangesForRecordZoneID:error:
syncEngine:failedToSaveRecordZone:error:
syncEngine:failedToDeleteRecordZoneWithID:error:
syncEngine:zoneWithIDChanged:
syncEngine:zoneWithIDWasDeleted:
syncEngine:zoneWithIDWasDeletedDueToUserEncryptedDataReset:
syncEngine:zoneWithIDWasPurged:
syncEngine:accountChangedFromUserRecordID:toUserRecordID:
syncEngineDidBeginFetchingChanges:
syncEngineWillBeginFetchingChanges:
syncEngineDidEndFetchingChanges:
syncEngine:willBeginFetchingChangesForZoneIDs:
syncEngine:didEndFetchingChangesForZoneID:
syncEngineWillBeginModifyingPendingChanges:
syncEngineDidEndModifyingPendingChanges:
syncEngine:nextBatchOfRecordsToModifyForZoneIDs:
syncEngine:didCompleteModifyRecordsBatch:error:
recordZonesToSaveForSyncEngine:
recordZoneIDsToDeleteForSyncEngine:
syncEngine:shouldFetchChangesForZoneID:
syncEngine:shouldFetchAssetContentsForZoneID:
syncEngine:relatedApplicationBundleIdentifiersForZoneIDs:recordIDs:
initWithDistributedSyncMultiStreamManager:database:queue:
streamDescriptorSupportsCloudKitSync:
streamSupportsCloudKitSync:
newHighestDeletedLocationRecordIDFor:stream:
newZoneVersionRecordIDForZone:
fetchChangesWithError:
handleTransitionToNewMergeableValueRecordValueKey
uploadChangesWithError:
isManateeAvailable:
startWithCompletionBlock:
isRecordNewerThanMostRecentDeleteForSiteIdentifier:
handleSyncRecordDidFetchRecord:
handleZoneVersionDidFetchRecord:
handleHighestDeletedLocationDidFetchRecord:
handleDidSaveRecordZoneVersionRecord:
handleDidSaveRecordHighestDeletedLocation:
handleDidSaveRecordSyncRecord:
handleZoneReset:
handleFailedToSaveSyncRecordUnknownItem:
handleFailedToSaveSyncRecordResaveRecord:
handleFailedToSaveSyncRecordServerRecordChanged:error:
handleFailedToSaveSyncRecordServerManateeDecryptionError:error:
handleFailedToSaveRecordSyncRecord:error:
handleFailedToSaveRecordZoneVersion:error:
handleFailedToSaveRecordHighestDeletedLocation:error:
resaveRecordOnError:
resaveRecord:
handleServerRecordChangedForHighestDeletedLocationError:
handleHighestDeletedLocationRecordToSaveForRecordID:
handleZoneVersionRecordToSaveForRecordID:
handleSyncRecordRecordToSaveForRecordID:
handleRecordWithIDDeletedSyncRecord:
dataSource
setDataSource:
container
setContainer:
configuration
setConfiguration:
ckSyncEngine
setCkSyncEngine:
_dataReceivedFromSiteIdentifiers
_operationQueue
_dataSource
_container
_configuration
_ckSyncEngine
_mergeableRecordValueKey
T@"<CKSyncEngineDataSource>",&,N,V_dataSource
T@"CKContainer",&,N,V_container
T@"CKSyncEngineConfiguration",&,N,V_configuration
T@"CKSyncEngine",&,N,V_ckSyncEngine
T@"NSString",R,N,V_mergeableRecordValueKey
initWithStreamCRDT:database:localSiteIdentifier:policy:
updateClockVectorByUnionWithUnseenSiteIdentifiers:
mergeAtomBatch:deletedLocations:sessionContext:
atomBatchesInClockVector:ckFormatVersion:chunker:transportType:
localSiteIdentifier
policy
T@"BMSyncPolicy",R,N,V_policy
T@"BMSyncDatabase",R,N,V_db
initWithDistributedSyncManagers:peerStatusTracker:
clockVectorForStreamsSupportingTransportType:direction:
atomBatchesInClockVector:targetPlatform:transportType:direction:ckFormatVersion:chunker:
mergeAtomBatches:deletedLocations:sessionContext:
distributedSyncManagers
streamNameToStreamDescriptorDict
_distributedSyncManagers
_streamNameToStreamDescriptorDict
T@"NSDictionary",R,N,V_distributedSyncManagers
T@"NSDictionary",R,N,V_streamNameToStreamDescriptorDict
distributedSyncMultiStreamManagerWithDatabase:
recordName
streamIdentifier
localMergeableValue
locationID
_recordName
_streamIdentifier
_localMergeableValue
_locationID
T@"NSString",R,N,V_recordName
T@"NSString",R,N,V_streamIdentifier
T@"NSData",R,N,V_localMergeableValue
T@"NSNumber",R,N,V_locationID
ckRecordsToSyncToCloudKitForZone:
recordFromSystemFieldsData:
createCKRecordFromRecordID:newRecord:recordType:
saveSystemFieldsDataForRecord:syncToCloudKit:recordType:
getSystemFieldsDataForRecordName:zoneName:recordType:
resetCKRecordsMetaDataAndSetToSyncForZone:
resetMetadataForRecord:zoneName:
saveCKRecordServerMergeableValue:recordName:zoneName:locationRow:
saveCKRecordHighestDeletedLocationRow:recordName:zoneName:recordExists:
saveCKRecordLocalMergeableValue:recordName:zoneName:locationRow:
clearCKRecordLocalMergeableValueAndSetToSyncForZone:
ckRecordForRecordName:zoneName:recordType:
ckRecordExists:zoneName:recordType:
updateAllCKRecordsAtOrBeforeLocationToBeDeletedOnSync:
markCKRecordsAtOrBeforeLocationToBeDeletedOnSync:
enumerateRecordsWithBlock:
deleteCKRecordsAtOrBeforeLocation:
deleteCKRecordsForStreamName:
deleteCKRecordAtLocation:
enumerateCKSyncRecordRecordsSetForDeletingUsingBlock:
gatherAllCKSyncRecordRecordsToBeDeleted
deleteAllCKRecordsInZone:
ckRecordCountForRecordType:
upsertCKRecordWithLocation:inStream:
identifierForPublicStreamNamed:
identifierForRestrictedStreamNamed:
identifierFromDescriptor:
path
config
descriptor
_path
T@"NSString",R,N,V_name
configForSyncStreamID:
initWithAsyncOperationBlock:
isFinished
isExecuting
isAsynchronous
block
_executing
_finished
_block
T@?,R,C,N,V_block
initWithRapportSyncEngine:cloudKitSyncEngine:peerStatusTracker:database:queue:
syncNowIfPolicyAllowsWithReason:transportType:activity:
syncAllTransportsNowIfPolicyAllowsWithReason:activity:
doRapportSyncNowWithReason:
syncRapportNowIfPolicyAllowsWithReason:activity:completionHandler:
doCloudKitSyncNowWithReason:
syncCloudKitNowIfPolicyAllowsWithReason:activity:completionHandler:
initWithSQLStatements:
sqlStatements
_sqlStatements
T@"NSArray",R,N,V_sqlStatements
initWithCustomFunctionName:
customFunctionName
_customFunctionName
T@"NSString",R,N,V_customFunctionName
defaultDatabasePath
defaultDatabaseWALPath
initWithPath:
initWithPath:queue:
setState:error:
setState:errorFormat:
_tryOpen:
open
close
beginTransaction
commit
rollback
clearCachedStatements
valueForMetadataKey:
setValue:forMetadataKey:
migration_StarSkySchema11ToSydRoSchema12
migration_Schema20ToSchema21
error
internalState
corruptionHandler
setCorruptionHandler:
_fmdb
_flags
__error_ivar
__internal_state_ivar
_corruptionHandler
T@"NSString",R,N,V__error_ivar
TQ,R,N,V__internal_state_ivar
TI,R,N
T@?,C,N,V_corruptionHandler
TQ,R,N
initWithDatabase:transcationBatchSize:
executeOperationWithBlock:
localDeviceIdentifierCreatingIfNecessary
localDeviceUpdatingIfNeccesaryWithProtocolVersion:
upsertSyncDevicePeer:
setLocalDeviceIdentifier:
recordMessageToDeviceIdentifier:sessionID:messageID:reachable:bytes:isReciprocal:
recordAtomMergeResult:inStream:sessionID:messageID:ownerSite:originatingSite:eventCreatedAt:
dateOfLastVacuum
setDateOfLastVacuum:
_numPagesToVacuum
vacuumWithShouldContinueBlock:
databaseSizeInKilobytes
walSizeInKilobytes
_sizeOfFileInKilobytes:
numRowsInTable:
sizeOfTableInKilobytes:
sharedInstance
dateFormatter
_dateFormatter
recordNameFromSite:day:
dayFromRecordName:
initWithStreamName:siteIdentifier:day:
triple
initWithTriple:
initWithZoneName:recordName:
initWithCKMergeableValueID:
initWithCKMergeableValueID:streamName:
ckMergeableValueID
ckMergeableValueIDWithFormatVersion:
expirationTimeForStreamDesc:
siteIdentifier
_siteIdentifier
_day
T@"NSString",R,N,V_siteIdentifier
T@"NSDate",R,N,V_day
initWithAssignerPolicy:
locationWithStreamName:siteIdentifier:timestamp:
truncateDateToDay:
databaseWithPath:
databaseWithURL:
FMDBUserVersion
FMDBVersion
sqliteLibVersion
isSQLiteThreadSafe
storeableDateFormat:
initWithURL:
databaseURL
sqliteHandle
sqlitePath
limitFor:value:
openWithFlags:
openWithFlags:vfs:
setMaxBusyRetryTimeInterval:
maxBusyRetryTimeInterval
busyRetryTimeout
setBusyRetryTimeout:
hasOpenResultSets
closeOpenResultSets
resultSetDidClose:
cachedStatementForQuery:
setCachedStatement:forQuery:
rekey:
rekeyWithData:
setKey:
setKeyWithData:
hasDateFormatter
setDateFormat:
dateFromString:
stringFromDate:
goodConnection
warnInUse
databaseExists
lastErrorMessage
hadError
lastErrorCode
lastExtendedErrorCode
errorWithMessage:
lastError
lastInsertRowId
changes
bindObject:toColumn:inStatement:
extractSQL:argumentsList:intoString:arguments:
executeQuery:withParameterDictionary:
executeQuery:withArgumentsInArray:orDictionary:orVAList:shouldBind:
bindStatement:WithArgumentsInArray:orDictionary:orVAList:
executeQuery:
executeQueryWithFormat:
executeQuery:withArgumentsInArray:
executeQuery:values:error:
executeQuery:withVAList:
executeUpdate:error:withArgumentsInArray:orDictionary:orVAList:
executeUpdate:
executeUpdate:withArgumentsInArray:
executeUpdate:values:error:
executeUpdate:withParameterDictionary:
executeUpdate:withVAList:
executeUpdateWithFormat:
executeStatements:
executeStatements:withResultBlock:
executeUpdate:withErrorAndBindings:
update:withErrorAndBindings:
prepare:
beginDeferredTransaction
beginImmediateTransaction
beginExclusiveTransaction
inTransaction
interrupt
startSavePointWithName:error:
releaseSavePointWithName:error:
rollbackToSavePointWithName:error:
inSavePoint:
checkpoint:error:
checkpoint:name:error:
checkpoint:name:logFrameCount:checkpointCount:error:
shouldCacheStatements
setShouldCacheStatements:
makeFunctionNamed:maximumArguments:withBlock:
makeFunctionNamed:arguments:block:
valueType:
valueInt:
valueLong:
valueDouble:
valueData:
valueString:
resultNullInContext:
resultInt:context:
resultLong:context:
resultDouble:context:
resultData:context:
resultString:context:
resultError:context:
resultErrorCode:context:
resultErrorNoMemoryInContext:
resultErrorTooBigInContext:
traceExecution
setTraceExecution:
checkedOut
setCheckedOut:
crashOnErrors
setCrashOnErrors:
logsErrors
setLogsErrors:
cachedStatements
setCachedStatements:
isOpen
setIsOpen:
isInTransaction
databasePath
_isExecutingStatement
_startBusyRetryTime
_openResultSets
_openFunctions
_dateFormat
_shouldCacheStatements
_traceExecution
_checkedOut
_crashOnErrors
_logsErrors
_isOpen
_isInTransaction
_maxBusyRetryTimeInterval
_cachedStatements
_databasePath
TB,V_traceExecution
TB,V_checkedOut
TB,V_crashOnErrors
TB,V_logsErrors
T@"NSMutableDictionary",&,V_cachedStatements
TB,N,V_isOpen
TB,R,N
TB,R,N,V_isInTransaction
TB,N,V_shouldCacheStatements
T@"NSString",R,N,V_databasePath
T@"NSURL",R,N
T^v,R,N
Td,N,V_maxBusyRetryTimeInterval
reset
useCount
setUseCount:
inUse
setInUse:
_useCount
_inUse
Tq,V_useCount
T^v,V_statement
TB,V_inUse
stringForQuery:
intForQuery:
longForQuery:
boolForQuery:
doubleForQuery:
dataForQuery:
dateForQuery:
tableExists:
getSchema
getTableSchema:
columnExists:inTableWithName:
applicationID
setApplicationID:
userVersion
setUserVersion:
columnExists:columnName:
validateSQL:error:
TI,N
dealloc
resultSetWithStatement:usingParentDatabase:shouldAutoClose:
columnCount
columnNameToIndexMap
kvcMagic:
resultDict
resultDictionary
next
nextWithError:
step
stepWithError:
internalStepWithError:
hasAnotherRow
columnIndexForName:
intForColumn:
intForColumnIndex:
longForColumn:
longForColumnIndex:
longLongIntForColumn:
longLongIntForColumnIndex:
unsignedLongLongIntForColumn:
unsignedLongLongIntForColumnIndex:
boolForColumn:
boolForColumnIndex:
doubleForColumn:
doubleForColumnIndex:
stringForColumnIndex:
stringForColumn:
dateForColumn:
dateForColumnIndex:
dataForColumn:
dataForColumnIndex:
dataNoCopyForColumn:
dataNoCopyForColumnIndex:
columnIndexIsNull:
columnIsNull:
UTF8StringForColumnIndex:
UTF8StringForColumn:
UTF8StringForColumnName:
objectForColumnIndex:
objectForColumnName:
objectForColumn:
columnNameForIndex:
objectAtIndexedSubscript:
objectForKeyedSubscript:
bindWithArray:orDictionary:orVAList:
bindWithArray:
bindWithDictionary:
parentDB
setParentDB:
query
setQuery:
statement
setStatement:
shouldAutoClose
setShouldAutoClose:
_columnNameToIndexMap
_shouldAutoClose
_parentDB
_query
_statement
TB,N,V_shouldAutoClose
T@"_bmFMDatabase",&,N,V_parentDB
T@"NSString",&,V_query
T@"NSMutableDictionary",R
T@"_bmFMStatement",&,V_statement
Ti,R,N
T@"NSDictionary",R,N
databasePool:shouldAddDatabaseToPool:
databasePool:didAddDatabase:
databasePoolWithPath:
databasePoolWithURL:
databasePoolWithPath:flags:
databasePoolWithURL:flags:
executeLocked:
pushDatabaseBackInPool:
countOfCheckedInDatabases
countOfCheckedOutDatabases
countOfOpenDatabases
releaseAllDatabases
maximumNumberOfDatabasesToCreate
setMaximumNumberOfDatabasesToCreate:
_lockQueue
_databaseInPool
_databaseOutPool
_maximumNumberOfDatabasesToCreate
T@"NSString",C,V_path
T@,V_delegate
TQ,V_maximumNumberOfDatabasesToCreate
databaseQueueWithPath:
databaseQueueWithURL:
databaseQueueWithPath:flags:
databaseQueueWithURL:flags:
databaseClass
initWithURL:flags:vfs:
initWithPath:flags:vfs:
initWithPath:flags:
initWithURL:flags:
inDatabase:
beginTransaction:withBlock:
inTransaction:
inDeferredTransaction:
inExclusiveTransaction:
inImmediateTransaction:
setPath:
openFlags
vfsName
setVfsName:
_openFlags
_vfsName
T@"NSString",&,V_path
Ti,R,V_openFlags
T@"NSString",C,V_vfsName
BiomeSync
v8@?0
<%@: location=%@, state=%lu>
location_
ref_location_
%@%@
stream
site
state
CRDTLocation
stream = ?
 AND site = ?
 AND day = ?
id = ?
 AND day <= ?
 AND state = ?
 AND day < ?
 AND NOT EXISTS (SELECT * FROM CKAtom WHERE location_id = id)
day DESC
state = ?
day = (select max(day) from CRDTLocation i where i.stream = ? and i.site=CRDTLocation.site
 and state = ?)
 AND stream = ?
 AND state = ? 
count(*)
no session ID
device_identifier
name
model
platform
protocol_version
DevicePeer
me IS ?
device_identifier = ?
max(last_sync_date)
last_sync_date
deviceIdentifier
deviceMetadata
protocolVersion
BMRapportRequest
v16@?0@"BMRapportDevice"8
com.apple.biomesyncd.fetchAtomBatches
v32@?0@"NSDictionary"8@"NSDictionary"16@"NSError"24
senderModelID
Unable to determine sender model info
Unknown platform
v24@?0@"NSArray"8@"NSArray"16
v32@?0@"NSDictionary"8@"NSDictionary"16@?<v@?@"NSDictionary"@"NSDictionary"@"NSError">24
com.apple.biome.syncSessionLog
com.apple.biome.syncdatabase
database_size
wal_size
num_rows_CKAtom
CKAtom
table_size_CKAtom
num_rows_CKRecord
CKRecord
table_size_CKRecord
num_rows_CRDTLocation
time_since_vacuum
table_size_CRDTLocation
com.apple.biomesyncd
com.apple.biomesyncd.metrics-collection
v16@?0@"NSObject<OS_xpc_object>"8
com.apple.biomesyncd.database-maintenance
B8@?0
com.apple.biomesyncd.periodic-sync
com.apple.notifyd.matching
Notification
com.apple.rapport.CompanionLinkDeviceAdded
com.apple.rapport.matching
replyRequired
context_sync
void *BiomeLibraryLibrary(void)
biomesyncd.m
vectorClock
BMStreamCKCRDT.m
Invalid parameter not satisfying: %@
streamID
config
database
v24@?0@"CKAtomReferenceMutableProxy"8Q16
v24@?0@"CKAtomMutableProxy"8Q16
v16@?0^B8
v24@?0@"BMSyncCKAtomRow"8^B16
v24@?0@"BMSyncCRDTLocationRow"8^B16
v32@?0@"CKAtomProxy"8Q16^B24
BMFrameStatePreWrite
BMFrameStateWritten
BMFrameStatePreDelete
BMFrameStateDeleted
BMFrameStateEOF
BMFrameStateUnknown
BMFrameStateUnknown(%lu)
%@ %@
type
value
Append
TTLDelete
RandomDelete
Modify
Unknown
(unknown: %i)
zone_name
zone_uuid
recovery_state
attempted_recovery_date
CKZone
zone_name = ?
UUID not set
com.apple.biomesyncd.rapport
v16@?0@"RPCompanionLinkDevice"8
v20@?0@"RPCompanionLinkDevice"8I16
v16@?0@"NSError"8
v12@?0B8
~~REQUEST_ID~~
~~RESPONSE_HANDLER~~
~~OPTIONS~~
failed with error, 
completed
BMRapportDevice[%@]: id=%@ bmID=%@ model=%@ name=%@
device
Immed
Near
peer
walltime
batchSize
batchSequenceNumber
isReciprocalRequest
atomBatchVersion
unseenPeers
atomBatches
moreComing
deletedLocations
biomesyncdStrings
AdditionalSyncPolicies
eventClass
restricted/feedbackSocialHighlights
BMSocialHighlightFeedbackEvent
public/DeviceMetadata
BMDeviceMetadataEvent
restricted/SiriMemoryReferenceResolutionStream
BMSiriMemoryReferenceResolutionEvent
public/AppLaunch
BMAppLaunchEvent
overrideInternalPolicy
rapport
direction
outbound
cloudkit
none
BMSyncPolicy.m
Unexpected direction %lu
NSString *NSStringFromBMSyncTransportType(BMSyncTransportType)
No mapping found for BMSyncTransportType(%lu)
inbound
BMSyncDirection BMSyncDirectionFromNSString(NSString *__strong)
No mapping found for %@
BMSyncCKAtomRow.m
location
timestamp
<%@: type=%@, location=%@, atomID=%@, refID=%@ bookmarkOffset=%lu>
clock
segment_name
segment_offset
ref_type
ref_site
ref_clock
value_version
value_data
location_id
on_disk
ref_location_id
CKAtom.site = ?
 AND CKAtom.stream = ?
 AND clock = ?
 AND on_disk IS ?
clock DESC
max(clock)
v24@?0@"_bmFMResultSet"8^B16
location_id = ?
clock ASC
type = ?
 AND CKAtom.site = ?
 AND segment_name IS NOT ?
clock = ?
 AND type = ?
 AND segment_name = ?
 AND segment_offset = ?
site = ?
DISTINCT site
(ref_site = ?
 OR (ref_site IS NULL AND CKAtom.site = ?))
ref_clock ASC
type ASC
location.stream = ?
 AND location.site = ?
 AND location.day <= ?
ref_clock DESC
location_id IN (SELECT id from CRDTLocation where stream = ?
 AND day <= ?)
 AND clock != ?
 AND clock != (SELECT MAX(clock) FROM CKAtom WHERE stream = ?
 AND site = ?)
CKAtom.stream = ? 
 AND ((CKAtom.site = ? 
) OR (CKAtom.site = ? 
AND clock = ? 
OR clock = ? 
AND clock BETWEEN ? 
OR clock BETWEEN ? 
 AND ?
v32@?0{_NSRange=QQ}8^B24
)) AND on_disk IS ?
location.stream as location_stream
location.site as location_site
location.day as location_day
location.state as location_state
 LEFT JOIN CRDTLocation location ON location_id=location.id
location_id, location.stream, location.site, location.day, location.state
location.stream
location.site
location.day ASC
 AND CKAtom.location_id = ? 
CKAtom.stream = ?
COUNT ((CAST(segment_name AS INT) > ?
 OR segment_name = ?
 AND segment_offset > ?) OR NULL) == 0
location.day DESC
 AND on_disk IS NOT ?
CKAtom.*
ref_location.stream as ref_location_stream
ref_location.site as ref_location_site
ref_location.day as ref_location_day
ref_location.state as ref_location_state
 LEFT JOIN CRDTLocation ref_location ON ref_location_id=ref_location.id
com.apple.biomesyncd.sync
com.apple.private.biome.sync
com.apple.internal.biome.sync
-[BMSyncServiceServer triggerRapportSyncWithReply:]
-[BMSyncServiceServer rapportSyncWithError:]
-[BMSyncServiceServer triggerCloudKitSyncWithReply:]
-[BMSyncServiceServer cloudKitSyncWithError:]
isMe
platformDescription
BMRapportErrorDomain
SELECT %@ FROM %@
 WHERE 
 GROUP BY %@
 ORDER BY %@
 LIMIT %@
 HAVING 
UPDATE OR FAIL %@ SET 
 = ?, 
 = ?
INSERT INTO %@
) VALUES (
DELETE FROM %@
%@:%lu
com.apple.biome.sync.ckMetaData
LastSyncAttemptDate
LastCloudKitAttemptDate
MergeableRecordValueKey
CKMergeableRecordValue
stream_name
record_name
server_mergeable_value
stream_name = ?
 AND record_name = ?
TombstoneBookmark
AND site = ?
BMSyncAtomType(%llu)
BiomeStream
atomType
atomValue
data
dataVersion
dataTimestamp
recordOrder
zoneVersion
biomeCRDT
streamCRDT
zoneVersionUUID
com.apple.biome.sync
unknown
syncRecord
highestDeletedLocation
(unknown: %lu)
v16@?0@?<v@?>8
v24@?0@"CKAccountInfo"8@"NSError"16
v24@?0@"NSData"8^B16
v24@?0@"BMSyncCKRecord"8^B16
v24@?0@"BMSyncCKZone"8^B16
v16@?0@"CKAtomBatch"8
BMDistributedSyncMultiStreamManager.m
direction == BMSyncDirectionOutbound
stream_identifier
local_mergeable_value
sync_to_cloud_kit = ?
 AND deleting = ?
 AND record_type = ?
 AND stream_identifier = ?
record_metadata
sync_to_cloud_kit
record_name = ?
record_type
stream_identifier = ?
deleting
record_type = ?
 AND location_id IN (     SELECT id FROM CRDTLocation WHERE site = ?
     AND stream = ?
     AND day <= ?)
 LEFT JOIN CRDTLocation location ON location_id=location.id 
deleting = ?
 AND EXISTS (SELECT record_name FROM CKMergeableRecordValue WHERE CKMergeableRecordValue.stream_name=CKRecord.stream_identifier AND CKMergeableRecordValue.record_name=CKRecord.record_name AND server_mergeable_value IS NOT NULL)
v24@?0@"CKRecordID"8^B16
location_id =?
BMSyncStreamID.m
streamName.length
stream != BMPublicStreamUnknown
public/
restricted/
public/%@
restricted/%@
identifier
isExecuting
isFinished
never
com.apple.biome.syncNow
[BMCloudKitSyncEngine start] failed: %@
BMSyncScheduler
v20@?0B8@"NSError"12
eventData
migration_StarSkySchema11ToSydRoSchema12
ALTER TABLE CKRecord DROP COLUMN mergeable_value_delta
ALTER TABLE CKRecord ADD COLUMN server_mergeable_value BLOB
ALTER TABLE CKRecord ADD COLUMN local_mergeable_value BLOB
ALTER TABLE CKAtom ADD COLUMN value_version INTEGER
UPDATE CKAtom SET value_version = 0
CREATE INDEX IF NOT EXISTS idx_syncmessagelog_session_id ON SyncMessageLog(session_id)
CREATE INDEX IF NOT EXISTS idx_atommergedlog_owning_site_identifier ON AtomMergedLog(owning_site_identifier)
CREATE INDEX IF NOT EXISTS idx_atommergedlog_session_id ON AtomMergedLog(session_id)
CREATE TABLE CKZone(zone_name STRING NOT NULL, zone_uuid STRING NOT NULL, recovery_state INTEGER, attempted_recovery_date INTEGER)
migration_Schema20ToSchema21
ALTER TABLE CKRecord ADD COLUMN record_type INTEGER
UPDATE CKRecord SET record_type = 1
sync.db
-wal
BMSyncDatabase.m
path
recursion max
failed to create path: %@
PRAGMA journal_mode = WAL;PRAGMA foreign_keys = ON;
Metadata
version too new
com.apple.Biome
internal build version < 17
internal build version between 17 and 19
custom migration to version %u failed with error %@
migration to version %u failed with error %@
failed to delete corrupt database file: %@
unhandled state %llu
SELECT value FROM Metadata WHERE key=?
INSERT INTO Metadata VALUES (?, ?)
PRAGMA foreign_keys=OFF
idx_crdt_location
idx_crdt_location_state
SELECT type, name FROM sqlite_schema WHERE tbl_name = 'CRDTLocation'
table
CREATE TABLE new_CRDTLocation (id INTEGER primary key, stream STRING NOT NULL, site STRING NOT NULL, day INTEGER NOT NULL, state INTEGER NOT NULL)
INSERT INTO new_CRDTLocation SELECT * FROM CRDTLocation
DROP TABLE CRDTLocation
ALTER TABLE new_CRDTLocation RENAME TO CRDTLocation
CREATE INDEX IF NOT EXISTS idx_crdt_location ON CRDTLocation(stream, site, day)
CREATE INDEX IF NOT EXISTS idx_crdt_location_state ON CRDTLocation(stream, site, state, day DESC)
CREATE TABLE IF NOT EXISTS CKRecord (location_id INTEGER, sync_to_cloud_kit BOOL, record_metadata BLOB, record_name STRING, stream_identifier STRING, mergeable_value_delta BLOB, deleting BOOL, FOREIGN KEY (location_id) REFERENCES CRDTLocation(id));
CREATE INDEX IF NOT EXISTS idx_ckrecord ON CKRecord(record_name)
PRAGMA foreign_key_check
PRAGMA foreign_keys=ON
CREATE TABLE new_CKRecord (location_id INTEGER, sync_to_cloud_kit BOOL, record_metadata BLOB, record_name STRING, stream_identifier STRING, local_mergeable_value BLOB, deleting BOOL,  PRIMARY KEY (stream_identifier, record_name), FOREIGN KEY (location_id) REFERENCES CRDTLocation(id));
INSERT INTO new_CKRecord SELECT location_id, sync_to_cloud_kit, record_metadata, record_name, stream_identifier, local_mergeable_value, deleting FROM CKRecord
DROP TABLE CKRecord
ALTER TABLE new_CKRecord RENAME TO CKRecord
CREATE TABLE IF NOT EXISTS CKMergeableRecordValue (stream_name STRING, record_name STRING, server_mergeable_value BLOB, FOREIGN KEY (stream_name, record_name) REFERENCES CKRecord(stream_identifier, record_name))
select session_duration.session_id, duration, reachable_peers_cnt, is_reciprocal, reason as sync_reason, cast((select count(*) from DevicePeer) as text) as known_peers_cnt_str, cast(reachable_peers_cnt as real) / (select count(*) from DevicePeer) as peer_availabilty_pct, avg_sync_latency, atoms_dropped_cnt, atoms_causality_violation_cnt, atoms_received_cnt, atoms_relayed_cnt, relay_earliness, relay_unseen_peer_atom_cnt, atom_batch_bytes from ( select session_id, is_reciprocal, reason, (end_timestamp - start_timestamp) as duration from SyncSessionLog group by session_id, is_reciprocal, reason ) as session_duration left join ( select session_id, count(distinct device_identifier) as reachable_peers_cnt from SyncMessageLog group by session_id ) as reachable_peers on session_duration.session_id=reachable_peers.session_id left join ( select session_id, avg(case when event_created_at <> 0 then synced_at - event_created_at else null end) as avg_sync_latency from AtomMergedLog group by session_id ) as sync_latency on session_duration.session_id=sync_latency.session_id left join ( select a.session_id, sum(case when a.merge_result=1 THEN 1 else 0 end) as atoms_dropped_cnt, sum(case when a.merge_result=2 THEN 1 else 0 end) as atoms_causality_violation_cnt, sum(case when a.merge_result=3 THEN 1 else 0 end) as atoms_received_cnt from AtomMergedLog as a join SyncMessageLog as m on a.message_id=m.message_id and a.relayed_by_site_identifier = m.device_identifier and a.session_id=m.session_id group by a.session_id ) as merge_results on session_duration.session_id=merge_results.session_id left join ( select session_id, count(*) as atoms_relayed_cnt from AtomMergedLog as a where owning_site_identifier <> relayed_by_site_identifier and not exists ( select * from SyncMessageLog as m where a.session_id=m.session_id and device_identifier=owning_site_identifier and reachable=1 ) group by session_id ) as relay_count on session_duration.session_id=relay_count.session_id left join ( select relayed.session_id, avg(timestamp - synced_at) as relay_earliness from ( select atom.session_id, synced_at, timestamp from AtomMergedLog as atom, SyncMessageLog as message where owning_site_identifier <> relayed_by_site_identifier and not exists ( select * from SyncMessageLog as m where atom.session_id=m.session_id and device_identifier=owning_site_identifier and reachable=1 ) and device_identifier=owning_site_identifier and reachable=1 and timestamp > synced_at order by timestamp asc limit 1 ) as relayed group by relayed.session_id ) as earliness on session_duration.session_id=earliness.session_id left join ( select session_id, count(*) as relay_unseen_peer_atom_cnt from AtomMergedLog as a where owning_site_identifier <> relayed_by_site_identifier and not exists ( select * from SyncMessageLog as m where device_identifier=owning_site_identifier and reachable=1 ) group by session_id ) as atom_relay_unseen_device on session_duration.session_id=atom_relay_unseen_device.session_id left join ( select session_id, sum(atom_batch_bytes) as atom_batch_bytes from SyncMessageLog group by session_id ) as batch_bytes on session_duration.session_id=batch_bytes.session_id;
SyncSessionLog
session_id
transport
reason
is_reciprocal
start_timestamp
end_timestamp
session_id = ?
SyncMessageLog
message_id
reachable
atom_batch_bytes
AtomMergedLog
owning_site_identifier
relayed_by_site_identifier
merge_result
event_created_at
synced_at
DELETE FROM SyncMessageLog WHERE timestamp <> (SELECT max(timestamp) FROM SyncMessageLog message WHERE device_identifier=message.device_identifier)
DELETE FROM SyncSessionLog
DELETE FROM AtomMergedLog
LastVacuumDate
PRAGMA page_count
PRAGMA freelist_count
PRAGMA auto_vacuum
PRAGMA auto_vacuum = 2
VACUUM
PRAGMA incremental_vacuum(%lu)
SELECT name FROM sqlite_schema WHERE type='table' AND name=?
SELECT COUNT(*) FROM %@
SELECT SUM(pgsize) FROM dbstat WHERE name = ?
(%@, %@, %@)
(%@,%@,%@)
%@,%@
(%@,%@)
-[_bmFMDatabase initWithPath:]
FMDatabase.m
sqlite3_threadsafe()
2.7.7
FMDBVersion is invalid: Please use FMDBUserVersion instead.
:memory:
error opening!: %d
Closing leaked statement
error closing!: %d
%s:%d
-[_bmFMDatabase busyRetryTimeout]
FMDB: busyRetryTimeout no longer works, please use maxBusyRetryTimeInterval
-[_bmFMDatabase setBusyRetryTimeout:]
FMDB: setBusyRetryTimeout does nothing, please use setMaxBusyRetryTimeInterval:
B24@?0@"_bmFMStatement"8^B16
query
API misuse, -[_bmFMDatabase setCachedStatement:forQuery:] query must not be nil
en_US
select name from sqlite_master where type='table'
The _bmFMDatabase %@ is currently in use.
The _bmFMDatabase %@ is not open.
NULL
%@ executeQuery: %@
DB Error: %d "%@"
DB Query: %@
DB Path: %@
%@ = %@
Error: unable to bind (%d, %s
Could not find index for %@
data: %ld bytes
obj: %@
Error: the bind count is not correct for the # of variables (executeQuery)
Error inserting batch: %s
rollback transaction
commit transaction
begin exclusive transaction
begin deferred transaction
begin immediate transaction
savepoint '%@';
release savepoint '%@';
rollback transaction to savepoint '%@';
dbSavePoint%ld
%@ %ld hit(s) for query %@
WARNING: Requested sleep of %i milliseconds, but SQLite returned %i. Maybe SQLite wasn't built with HAVE_USLEEP=1?
select [sql] from sqlite_master where [type] = 'table' and lower(name) = ?
SELECT type, name, tbl_name, rootpage, sql FROM (SELECT * FROM sqlite_master UNION ALL SELECT * FROM sqlite_temp_master) WHERE type != 'meta' AND name NOT LIKE 'sqlite_%' ORDER BY tbl_name, type DESC, name
pragma table_info('%@')
pragma application_id
pragma application_id=%d
pragma user_version
pragma user_version = %d
FMResultSet.m
![statement inUse]
Warning: There seem to be no columns in this set.
%s:%d Database busy (%@)
-[_bmFMResultSet internalStepWithError:]
Database busy
Error calling sqlite3_step (%d: %s) rs
parentDB does not exist
_bmFMDatabase
Unknown error calling sqlite3_step (%d: %s) rs
Warning: I could not find the column named '%@'.
Database already in pool
The _bmFMDatabase being put back into the pool is already present in the pool
Maximum number of databases (%ld) has already been reached!
Could not open up the database at path %@
Could not create database queue for path %@
fmdb.%@
_bmFMDatabaseQueue could not reopen database for path %@
-[_bmFMDatabaseQueue inDatabase:]
FMDatabaseQueue.m
currentSyncQueue != self && "inDatabase: was called reentrantly on the same queue, which would lead to a deadlock"
Warning: there is at least one open result set around after performing [_bmFMDatabaseQueue inDatabase:]
savePoint%ld
locationRow is nil, returning empty state vector
mergeDeltas delta: %@
Failed to initWithMergeableDelta with error %@
BMStreamCKRecordCRDT: unable to init a CKAtomBatch with initWriterWithMergeableValueID:%@ error:%@
BMStreamCKRecordCRDT: unable to complete a CKAtomBatch with finishWritingWithError:%@ error:%@
BMStreamCKRecordCRDT: failed to split atom batch with error %@
BMStreamCKRecordCRDT: failed to calculate batch size with error %@
BMStreamCKRecordCRDT: split into batch of size %@
BMStreamCKRecordCRDT: unable to init a CKMergeableDelta with initWithAtomBatch:%@ error:%@
*** deltas: %@
unexpected modifier %lu
[BMSyncCRDTLocationRow initWithFMResultSet] streamName:%@ siteIdentifier:%@ dayTimestamp:%f nsDate:%@ prefix:%@
updateLocationState: %lu forLocation:%@
updateAllLocationsAtOrBefore:%@ to state %lu
BMMultiStreamVectorClockConverter found nil modifier on siteIdentifier: %@
Expected only one value in indexSet of timestampClockVector, found %lu
sessionContext is nil
BMRapportSyncEngine%@: completing request, still inflight: %@
BMRapportSyncEngine%@: completeRequest:deliveredToDevices %@ withErrors:%@
BMRapportSyncEngine%@: request %@ already finished running
BMRapportSyncEngine%@: sending request to device: %@
BMRapportSyncEngine%@: request timed out because no devices are nearby
BMRapportSyncEngine%@: current watch disallowed from syncing with non-paired device: %@
BMRapportSyncEngine%@: current platform disallowed from syncing with non-paired watch: %@
BMRapportSyncEngine%@: syncing with device platform disallowed for device: %@
BMRapportSyncEngine%@: received request %@ %@
BMRapportSyncEngine%@: unable to determine sender model info: %@
BMRapportSyncEngine%@: unable to determine platform for model %{public}@
BMRapportSyncEngine%@: replying with CKXUncompressedFormatVersion atom batch
BMRapportSyncEngine%@: mismatched protocol version %lu, expected %d
BMRapportSyncEngine%@: should issue reciprocal request, %@
BMRapportSyncEngine%@: fetch completion handler is reciprocal, YES, deviceIdentifiers, %@, errors, %@
BMRapportSyncEngine%@: handleFetchAtomBatchesResponse %@ error %@ fromDevice: %@
BMRapportSyncEngine%@: fetchAtomBatchesResponseHandler received response %@
BMRapportSyncEngine%@: asked to defer activity, won't issue more requests to device %@ even though more data is available
BMRapportSyncEngine%@: max request depth %lu hit, finishing request to device %@
BMRapportSyncEngine%@: sending request to device %@ with sequence number %lu
BMRapportSyncEngine%@: no more data coming from device %@ finishing request
BiomeSync is disabled on simulators, -[BMSyncCore start] returning NO
biomesyncd launched
biomesyncd last exit status: %lld
Tried to defer activity %s, but failed
biome activity fired "com.apple.biomesyncd.metrics-collection"
Database unavailable for activity "com.apple.biomesyncd.metrics-collection"
biome running activity "com.apple.biomesyncd.metrics-collection"
biome activity fired "com.apple.biomesyncd.database-maintenance"
database unavailable for activity "com.apple.biomesyncd.database-maintenance"
biome running activity "com.apple.biomesyncd.database-maintenance"
Received unexpected object on com.apple.notifyd.matching: %@
Received com.apple.notifyd.matching: %s
Handling com.apple.notifyd.matching: %s
Database unavailable to handle "com.apple.rapport.CompanionLinkDeviceAdded"
Received unexpected object on com.apple.rapport.matching: %@
Received com.apple.rapport.matching: %s
Handling com.apple.rapport.matching: %s
Database unavailable to handle RapportWake
Received SIGTERM
failed to set user dir suffix: %{darwin.errno}d
failed to initialize temporary directory: %{darwin.errno}d
failed to resolve temporary directory: %{darwin.errno}d
biome activity fired "%s"
Database unavailable for activity "%s"
biome running activity "%s"
Starting tombstone enumerator from 0 for stream %@ site %@
Starting tombstone enumerator from segment %@ offset %lu for stream %@ site %@
delete must reference a corresponding append
Expected no-data frame to be delete or pre-delete, but frame was %{public}@
appendRecord %@ is of unexpected type %lu
bookmark is nil, presumably because the referenced atom was a dummy append (dead on arrival) %@
deleting event at bookmark %@
dropping atom %@ as it is dead on arrival
writeAtomValue: %@
adding %@ to atomBatch
ingestChangesForSite: %@
observed new data from non-local site %@
read new appended BMStoreEvent: %@ at offset %lu
failed to insert record %@
read new deleted BMStoreEvent: %@ at offset %lu
failed to batch ingest changes
read BMStoreEvent tombstone: %@ at tombstone bookmark %@
tombstone with unexpected deletion reason %lu
failed to batch ingest deletions
deleteLocationsUpToTTLAtTombstone: %@, siteIdentifier: %@
deletedExpiredBufferedLocationsForSiteIdentifier: %@
failed to delete atoms with location: %@
atomTableRecord %@
%@ location is not active
BMSyncCKAtomRow missing bookmark %@
Next enumerator bookmark %@ doesn't match expected %@
read table BMStoreEvent: %@ at offset %lu
bookmark is DOA, not attempting to resolve event
populateAndEnumerateAtomBatches could not finish writing atomBatch with err: %@
atomsInClockVector: %@, stream: %@
creating new batch with location %@
could not create new batch with location %@
handleDeletedLocation: %@
failed to delete event at bookmark %@
deleted location already handled
location we haven't yet observed is now deleted %@
location is unexpectedly nil, unable to parse from mergeableValueID %@
location is unexpectedly nil
received missing location %@
location is not active %@ skipping merge to not resurrect a dead location
highest deleted location %@ is past incoming location %@
received data for new location %@
mergeAtoms: %lu location %@
dropping atom with timestamp %@ since already merged
atom with timestamp %@ already in table but not on disk
causalReference location is unexpectedly nil
failed to insert referenceLocationRow for location %@
addAtomRow: %@
failed to commit, rolling back
updating row for atom inferred to be applied to disk %@
failed to update row: %@
atom to apply to disk %@
causal reference cache hit
causal reference location %@ points to dead location, not a violation
causal reference violation: missing causal reference %@ reference location %@
unblocked: %@
failed to apply atom to disk
updating row for atom applied to disk %@
BMRapportManager: shared-use only supported internally
BMRapportManager: received SIGTERM
BMRapportManager: could not determine appropriate control flags for device platform: %@
BMRapportManager: createSharedDiscoveryClientIfNotExists not currently supported
BMRapportManager: shared discovery client already exists
BMRapportManager: already activated %@
BMRapportManager: already activating %@
BMRapportManager: activating %@
BMRapportManager: failed to activate with error: %@
BMRapportManager: activated successfully
BMRapportManager: invalidated
BMRapportManager: registerEventID %@
BMRapportManager: stop
sendRequest:request:device:options:responseHandler: passed nil device
BMRapportDevice[%@]: enqueueing request
device %@ requestQueue %@
BMRapportDevice[%@]: activating client
device: %@ linkState %lu
handleActivationForDevice:error: passed nil device
BMRapportDevice[%@]: activation %@%@
BMRapportDevice[%@]: determined to not support service com.apple.biomesyncd.rapport
handleInterruptionForDevice: passed nil device
BMRapportDevice[%@]: interrupted
sendNextRequestToDevice: passed nil device
BMRapportDevice[%@]: expected request id and response handler in %@
BMRapportDevice[%@]: being sent request %@ with options %@
finishedSendingRequestsToDevice: passed nil device
BMRapportDevice[%@]: request queue empty, invalidating client
BMRapportDevice[%@]: advertisement data changed
BMRapportDevice[%@]: pairing flags/attributes changed
BMRapportDevice[%@]: distance changed: %s
BMRapportDevice[%@]: distance wifi information element changed
BMRapportDevice[%@]: name changed: %@
BMRapportDevice[%@]: RSSI changed
BMRapportDevice[%@]: SSID changed
BMRapportDevice[%@]: proximity changed: %s
BMRapportDevice[%@]: distance/angle/something changed
BMRapportDevice[%@]: no transports available; expect a lost callback
BMRapportDevice[%@]: got unexpected change flag: RPDeviceChangeFlags(%x)
BMRapportManager: skipping RPCompanionLinkDevice missing identifier: %@
BMRapportManager: skipping RPCompanionLinkDevice missing model: %@
BMRapportManager: already discovered device, %@ as %@
BMRapportDevice[%@]: ignoring device not listing service com.apple.biomesyncd.rapport
BMRapportDevice[%@]: discovered
BMRapportDevice[%@]: ignoring unsupported device
BMRapportDevice[%@]: lost
BMRapportDevice[%@]: invalidated
failed to unarchive BMMultiStreamVectorClock with error %@
failed to archive BMMultiStreamVectorClock with error %@
failed to unarchive BMMultiStreamAtomBatches with error %@
failed to archive BMMultiStreamAtomBatches with error %@
Failed to insert: %@
stateVector: %@
Failed to update: %@
clock vector is empty %@
triggerRapportSyncWithReply called
rapportSyncWithError called
triggerCloudKitSyncWithReply called
cloudKitSyncWithError called
%@: tried to initialize with a non-BMPBSyncAtomValue proto
%@: tried to initialize a BMPBSyncAtomValue proto, missing type or value
failed to deserialize BMSyncAtomValue with error %@
cannot deserialize atom value of version %lu
failed to serialize BMSyncAtomValue with error %@
cannot serialize atom value with version %lu
%@: tried to initialize with a non-BMPBStoreEventAtomValue proto
%@: tried to initialize a BMPBStoreEventAtomValue proto: missing dataVersion or dataTimestamp
unknown value in BMCloudKitRecordTypeString: %lu
syncNowWithReason
transitioning records over to new CKMergeableRecordValue with key %{public}@
failed to reset records for stream %{public}@ when transitioning to new CKMergeableRecordValue
ingest events from stream: %{public}@
syncNowWithReason found %lu records to sync and %lu records to delete
syncNowWithReason after removing duplicates, sending CKSyncEngine %lu records to sync and %lu records to delete
after modifying changes, we have %lu records to sync and %lu records to delete as a result of error handling
unable to obtain Manatee accountInfo
CloudKit container is not accessible. Status: %ld
This account is eligible to sync with manatee containers
Manatee is available on the current device
iCloud account doesn't support end-to-end encryption: %ld
account status is CKAccountStatusTemporarilyUnavailable
iCloud account status: %ld
unable to initialize CloudKit container
unable to initialize CloudKit configuration
unable to initialize ckSyncEngine
accountInfoWithCompletionHandler returned error: %@
zoneWithIDChanged: %{public}@
failedToFetchChangesForRecordZoneID: %{public}@
shouldFetchChangesForZoneID: %{public}@ returning: %{public}@
didDeleteRecordWithID: %{public}@ in zone: %{public}@
isRecordNewerThanMostRecentDeleteForSiteIdentifier: Could not create location from CKRecord: %{public}@
Error serverValue is nil for delta %{public}@ %{public}@
Error encoding serverValue for %{public}@ %{public}@, %{public}@
handleSyncRecordDidFetchRecord: Can't build location from record stream:%{public}@ recordName:%{public}@
Error saving [saveCKRecordServerMergeableValue:serverValueData] for %{public}@ %{public}@, %{public}@
didFetchRecord: %{public}@
didFetchRecord: unknown record type: %{public}@
handleDidSaveRecordSyncRecord: serverValue nil for for %{public}@ %{public}@
handleDidSaveRecordSyncRecord: Unable to unarchive localMergeableValue for %{public}@ %{public}@ %{public}@
nil value for localValue for %{public}@ %{public}@
Error [localRecordValue mergeRecordValue:serverValue] for serverValue:%{public}@ record:%{public}@ zone:%{public}@ %{public}@
Error encoding localValue for %{public}@ %{public}@
didSaveRecord: %{public}@ recordType: %{public}@ zone: %{public}@
didSaveRecord: %{public}@ unknown recordType: %{public}@ zone: %{public}@
didSaveRecordZone: %{public}@
failedToDeleteRecordWithID: %{public}@, zone:%{public}@
failedToSaveRecordZone:%{public}@ error:%{public}@
failedToSaveRecordZone: %{public}@ and recoveryState:%{public}d
Add zone and add record request made %{public}@ %{public}@.
Zone ID is nil; record dropped %{public}@
Handling handleFailedToSaveSyncRecordServerRecordChanged: Merging clientCRDT into serverCRDT %{public}@ -> %{public}@
Error handleFailedToSaveSyncRecordServerRecordChanged: [serverCRDT mergeRecordValue:clientCRDT]; error: %{public}@
handleFailedToSaveSyncRecordServerRecordChanged: serverCRDT is nil for record: %{public}@ for error: %{public}@
handleFailedToSaveSyncRecordServerRecordChanged: error archiving serverCRDT error: %{public}@
Manatee identity loss reported: record:%{public}@, zoneID:%{public}@, error:%{public}@
Error not handled: failedToSaveRecord, error: %{public}@
Error not handled: failedToSaveRecord, zoneVersion error: %{public}@
Error not handled: failedToSaveRecord, hightestDeletedLocation error: %{public}@
failedToSaveRecord: %{public}@, %{public}@ %{public}@
Error not handled: failedToSaveRecord, unknown record type: %{public}@ error: %{public}@
streamCRDT is nil %{public}@
locationID can not be found for recordID %{public}@
expirationTimeInterval is almost expired: %{public}@, not saving recordID: %{public}@ because it will be TTL'd
recordToSaveForRecordID: newRecord? %d
handleSyncRecordRecordToSaveForRecordID: Unable to unarchive localMergeableValue for %{public}@ %{public}@ %{public}@
recordValue %{public}@
Error adding deltas to save for %{public}@ %{public}@ %{public}@
set mergeable and saved to record's encryptedValues
recordToSaveForRecordID %{public}@
failedToDeleteRecordZoneWithID: %{public}@ error: %{public}@
didDeleteRecordZoneWithID: %{public}@
didDeleteRecordZoneWithID re-creating zone:%{public}@
didDeleteRecordZoneWithID syncing %lu records for zone:%{public}@
didDeleteRecordZoneWithID not re-creating zone:%{public}@, removing all local records in zone
zoneWithIDWasDeleted: %{public}@
recordWithIDWasDeleted: %{public}@, type=%{public}@
recordWithIDWasDeleted received an unknown record type:%{public}@ for record:%{public}@
syncEngineWillBeginFetchingChanges
syncEngineDidEndFetchingChanges
*** recordName:%{public}@
syncEngineDidEndFetchingChanges: Unable to unarchive localMergeableValue for %{public}@ %{public}@ %{public}@
Has a localMergeableValue: %{public}@
Has no localMergeableValue
syncEngineDidEndFetchingChanges: Unable to unarchive mergeableRecordValue for %{public}@ %{public}@ %{public}@
Merging mergeableRecordValue %{public}@
Merging serverValue %{public}@
Unable to [recordValue mergeRecordValue:serverValue for %{public}@ %{public}@ %{public}@
Were there mergeableRecordValues: %{public}s
syncEngineDidEndFetchingChanges location: %{public}@
syncEngineDidEndFetchingChanges: Can't build location from record stream:%{public}@ recordName:%{public}@
syncEngineDidEndFetchingChanges locationRow: %{public}@
locationRow is unexpectly nil for location %{public}@
Unable to  [recordValue mergeIntoMergeable:recordCRDT] for recordName:%{public}@ site:%{public}@ error:%{public}@
Unable to archive recordValue %{public}@ %{public}@
syncEngineWillBeginModifyingPendingChanges
syncEngineDidEndModifyingPendingChanges
mergeAtomBatches: %lu deletedLocations: %@
Merging atom batches into %@
Failed to instantiate CKAtomBatch, %@, %@
Generating atom batch after clock: %@, version: %lu
Could not generate atom data from atomBatch: %@, error: %@
atomBatchesAfterClock %@ %@ %@
Unable to create unarchiver %@
Unable to create a record from systemFieldsData for %@
unable to create a record with initWithRecordType for %@
Failed to clear metadata for record %@ in zone %@
Error saving CKRecord in saveCKRecordServerMergeableValue: for %@ %@
clearCKRecordLocalMergeableValueAndSetToSyncForZone %@
Problems updating CKRecords at or before location %@
Problems deleting CKRecords at or before location %@
Failed to delete CKRecords for streamName:%@
Can not delete CKRecord at location %@
Failed to delete all data associated with zone %@
unrecognized transport type (%lu)
syncNowIfPolicyAllowsWithReason: begin rapport sync
syncNowIfPolicyAllowsWithReason: begin cloudkit sync
syncNowIfPolicyAllowsWithReason: group_notify done
last sync: %{public}@ (%f ago), last attempt: %{public}@ (%f ago)
Unable to perform Rapport sync now, because database is not currently accessible
Rapport syncNowWithCompletionHandler %@, errors: %@
skipping rapport sync
Unable to perform CloudKit sync now, because database is not currently accessible
CloudKit syncNowWithCompletionHandler %@, errors: %@
skipping cloudkit sync
transitioned to state %llu
unrecoverable error: %@
database corrupt: %@
database corrupt
error: %@
BMSyncDatabase state queried while opening
failed to close db %@
failed to commit transcation
%@ received nil deviceIdentifier
recordSessionStart: %@
recordSessionEnd: %@
recordMessageToDeviceIdentifier: %@, %@
recordAtomMergeResult: %@, %@
vacuumWithShouldContinueBlock querying page_count: %@
vacuumWithShouldContinueBlock querying freelist_count: %@
vacuumWithShouldContinueBlock calculating pages to vacuum -- pageCount %tu freeCount %tu loadFactor %f
vacuumWithShouldContinueBlock not enough pages to vacuum: pageCount: %lu; freeCount: %lu
vacuumWithShouldContinueBlock error querying auto_vacuum: %@
vacuumWithShouldContinueBlock current vacuum mode is %u
vacuumWithShouldContinueBlock error setting auto_vacuum
vacuumWithShouldContinueBlock successfully set auto_vacuum to INCREMENTAL
vacuumWithShouldContinueBlock error running initial VACUUM
vacuumWithShouldContinueBlock successfully ran initial VACUUM
vacuumWithShouldContinueBlock calculated pages to vacuum: %lu
vacuumWithShouldContinueBlock starting incremental_vacuum of batch size: %lu, pagesVacuumed: %lu
vacuumWithShouldContinueBlock error running incremental_vacuum
vacuumWithShouldContinueBlock successfully completed
%@ sizeOfFileInKilobytes error fetching attributes for filepath: %@, err: %@
%@ numRowsInTable table name: %@ does not exist
%@ numRowsInTable error querying pgsize for table: %@, err: %@
%@ sizeOfTable error querying pgsize for table: %@, err: %@
nil value encountered in [BMStreamCRDTLocation initWithStreamName:%@ siteIdentifier:%@ day:%@]
can not determine streamName
unknown mergeable value ID format version %lu
BMStreamCKRecordCRDT
CKVersionedMergeable
CKMergeable
NSObject
BMSyncCRDTLocationRow
_bmFMResultSet
BMMultiStreamVectorClockConverter
BMSyncSessionContext
BMSyncSessionMetricsCollector
BMSyncSessionMetricsAggregator
BMAtomBatchMaxBytes
BMAtomBatchChunkerPolicy
NSCopying
BMAtomBatchMaxCount
BMAtomBatchChunker
BMSyncDevicePeerTable
BMSyncDevicePeerMetadata
BMPeerToPeerMessageOPACKCodable
BMSyncDevicePeer
BMRapportRequest
BMRapportSyncEngine
BMRapportManagerDelegate
BMSyncCore
BiomeSync
BMMultiStreamTimestampClockVector
NSSecureCoding
NSCoding
BMStreamCKCRDT
BMPBSyncAtomValue
BMSyncCKZone
BMRapportManager
BMRapportDevice
BMPeerToPeerMessage
BMFetchAtomBatchesRequest
BMFetchAtomBatchesResponse
BMSyncPolicy
BatchEnumerate
BMSyncCKAtomRow
BMSyncServiceServerProtocol
BMSyncServiceClientProtocol
BMSyncServiceServer
NSXPCListenerDelegate
BMSyncDevice
BMSync
BMMultiStreamVectorClock
BMSyncDatabase
BMSyncMetadata
BMSyncCKMergeableRecordValue
TombstoneBookmark
BMSyncAtomValue
BMStoreEventAtomValue
BMCloudKitSyncEngine
CKSyncEngineDataSourcePrivate
CKSyncEngineDataSource
BMDistributedSyncManager
BMDistributedSyncMultiStreamManager
BMDistributedSyncMultiStreamManagerFactory
OPACKCodable
BMSyncCKRecord
BMSyncStreamID
BMAsyncBlockOperation
BMSyncScheduler
BMPBStoreEventAtomValue
BMSyncDatabaseSQLStatementMigration
BMSyncDatabaseCustomFunctionMigration
BMSyncDatabaseTransactionBatcher
BMSyncDevicePeerStatusTracker
BMSyncMetricsCollectorTable
Maintenance
BMDateFormatterVendor
BMStreamCRDTLocation
BMStreamCRDTLocationBuilder
BMStreamCRDTLocationDayAssigner
BMStreamCRDTLocationAssignerPolicy
_bmFMDatabase
_bmFMStatement
_bmFMDatabaseAdditions
_bmFMDatabasePool
_bmFMDatabaseQueue
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
B32@0:8@16^@24
@32@0:8@16^@24
B32@0:8@"NSArray"16^@24
@"NSArray"32@0:8@"CKMergeableDeltaMetadata"16^@24
@"CKDistributedTimestampStateVector"16@0:8
@56@0:8@16@24@32@40q48
v24@0:8@16
q16@0:8
v24@0:8q16
v16@0:8
@"BMSyncDatabase"
@"BMStreamCKCRDT"
@"BMSyncCRDTLocationRow"
@"NSObject<OS_dispatch_queue>"
@32@0:8@16Q24
@40@0:8@16Q24Q32
@"BMStreamCRDTLocation"
@24@0:8@16
B32@0:8Q16@24
B32@0:8@16Q24
@24@0:8Q16
@32@0:8@16@24
i16@0:8
v24@0:8Q16
@"NSString"
v44@0:8@16Q24Q32B40
v48@0:8@16B24Q28B36@40
v64@0:8Q16@24@32@40d48@56
@"NSObject<OS_xpc_object>"
@24@0:8^{_NSZone=}16
B24@0:8@"NSData"16
v24@0:8@"NSData"16
v20@0:8B16
@"<BMAtomBatchChunkerPolicy>"
B28@0:8@16B24
B32@0:8@16@24
@24@0:8@"NSDictionary"16
@"NSDictionary"16@0:8
@40@0:8@16@24q32
@40@0:8@16@24Q32
@"BMSyncDevicePeerMetadata"
@56@0:8@16@24@?32@40@?48
v32@0:8@16@24
@?16@0:8
v24@0:8@?16
@"NSObject<OS_os_transaction>"
@"NSMutableSet"
@"NSMutableDictionary"
@"NSUUID"
@"NSObject<OS_dispatch_source>"
@"BMSyncSessionContext"
B32@0:8@"BMRapportManager"16@"BMRapportDevice"24
v32@0:8@"BMRapportManager"16@"BMRapportDevice"24
v24@0:8@"BMRapportManager"16
@48@0:8@16@24@32@40
v40@0:8Q16@24@?32
v40@0:8@16@24@32
v44@0:8B16Q20@28@?36
@36@0:8B16Q20Q28
v60@0:8@16@24@32@40@48B56
v48@0:8@16@24@32@40
I16@0:8
@"BMDistributedSyncMultiStreamManager"
@"BMRapportManager"
@"NSObject<BMAtomBatchChunkerPolicy>"
@"BMSyncDevicePeerStatusTracker"
@"BMSyncSessionMetricsCollector"
@"BMRapportSyncEngine"
@"BMCloudKitSyncEngine"
@"BMSyncScheduler"
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@24@0:8^@16
@64@0:8@16@24@32@40@48@56
@56@0:8@16Q24@32@40@48
@40@0:8@16Q24q32
B48@0:8@16@24^@32^@40
B48@0:8@16@24@32^@40
B60@0:8@16@24@32@40C48q52
v52@0:8@16@24@32C40q44
v32@0:8@16Q24
v60@0:8@16@24@32C40q44@52
v52@0:8@16C24@28Q36@?44
v28@0:8@16B24
@"BMStoreConfig"
@"BMSyncPolicy"
@"BMStreamCRDTLocationBuilder"
@"NSCache"
@"BMSyncStreamID"
@"BMPBStoreEventAtomValue"
{?="type"b1}
@"NSDate"
B28@0:8@16i24
B36@0:8@16i24@28
@28@0:8@16B24
v32@0:8@16@?24
v48@0:8@16@24@32@?40
v56@0:8@16@24@32@40@?48
v28@0:8@16I24
@"RPCompanionLinkClient"
@"<BMRapportManagerDelegate>"
@"RPCompanionLinkDevice"
@"NSMutableArray"
d16@0:8
v24@0:8d16
@"BMSyncDevicePeer"
@"BMMultiStreamVectorClock"
@"NSArray"
@"NSDictionary"
@24@0:8q16
@32@0:8@16q24
d24@0:8Q16
Q24@0:8Q16
B40@0:8Q16Q24^Q32
B32@0:8Q16Q24
B40@0:8q16Q24Q32
@64@0:8@16@24@32@40Q48@56
@72@0:8@16@24@32@40Q48q56@64
@"CKDistributedTimestamp"
@"CKAtomReference"
@"BMStoreBookmark"
@"NSData"
@40@0:8Q16@24@32
B36@0:8@16@24B32
@48@0:8@16Q24@32@40
v40@0:8@16@24@?32
v40@0:8@16Q24@?32
@40@0:8@16@24@32
@40@0:8d16@24@32
v24@0:8@?<v@?@"NSError">16
v24@0:8@?<v@?@"NSArray"@"NSArray">16
v24@0:8@?<v@?@"NSArray"@"NSError">16
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
v32@0:8@?16@?24
@"BMSyncCore"
@"NSXPCListener"
@56@0:8@16@24@32@40@48
@72@0:8@16@24@32@40@48@56@64
@80@0:8@16@24@32@40@48@56@64@72
B40@0:8@16@24@32
@40@0:8Q16@24q32
@"BMStoreEventAtomValue"
@36@0:8@16I24d28
@"CKRecord"32@0:8@"CKSyncEngine"16@"CKRecordID"24
v32@0:8@"CKSyncEngine"16@"CKRecord"24
v40@0:8@"CKSyncEngine"16@"CKRecord"24@"NSError"32
v32@0:8@"CKSyncEngine"16@"CKRecordID"24
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"NSString"32
v32@0:8@"CKSyncEngine"16@"NSData"24
v32@0:8@"CKSyncEngine"16@"CKRecordZone"24
v32@0:8@"CKSyncEngine"16@"CKRecordZoneID"24
v40@0:8@"CKSyncEngine"16@"CKRecordZoneID"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordZone"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"CKRecordID"32
v24@0:8@"CKSyncEngine"16
v32@0:8@"CKSyncEngine"16@"NSArray"24
@"CKSyncEngineBatch"32@0:8@"CKSyncEngine"16@"NSSet"24
v40@0:8@"CKSyncEngine"16@"CKSyncEngineBatch"24@"NSError"32
@"NSArray"24@0:8@"CKSyncEngine"16
B32@0:8@"CKSyncEngine"16@"CKRecordZoneID"24
@"NSArray"40@0:8@"CKSyncEngine"16@"NSArray"24@"NSArray"32
B24@0:8q16
@"NSOperationQueue"
@"<CKSyncEngineDataSource>"
@"CKContainer"
@"CKSyncEngineConfiguration"
@"CKSyncEngine"
@44@0:8@16C24@28Q36
@32@0:8Q16Q24
@60@0:8@16q24Q32Q40C48@52
@"NSNumber"
@40@0:8@16^B24Q32
v40@0:8@16@24Q32
B48@0:8@16@24@32@40
B44@0:8@16@24@32B40
B40@0:8@16@24Q32
@24@0:8@?16
v40@0:8Q16Q24@32
v32@0:8Q16@24
B24@0:8Q16
{?="dataTimestamp"b1"dataVersion"b1}
@"_bmFMDatabase"
B24@0:8@?16
v56@0:8@16@24Q32B40Q44B52
v72@0:8Q16@24@32Q40@48@56d64
Q24@0:8@16
@"NSISO8601DateFormatter"
@"NSDateFormatter"
@40@0:8@16@24d32
@"<BMStreamCRDTLocationAssignerPolicy>"
@"BMStreamCRDTLocation"40@0:8@"NSString"16@"NSString"24d32
@24@0:8d16
^v16@0:8
r*16@0:8
i24@0:8i16i20
B28@0:8i16@20
v20@0:8i16
i36@0:8@16i24^{sqlite3_stmt=}28
v48@0:8@16*24@32@40
@52@0:8@16@24@32*40B48
B48@0:8^{sqlite3_stmt=}16@24@32*40
@40@0:8@16@24^@32
@32@0:8@16*24
B56@0:8@16^@24@32@40*48
B40@0:8@16@24^@32
B32@0:8@16*24
B32@0:8@16@?24
B28@0:8i16^@20
B36@0:8i16@20^@28
B52@0:8i16@20^i28^i36^@44
v36@0:8@16i24@?28
i24@0:8^v16
q24@0:8^v16
d24@0:8^v16
@24@0:8^v16
v24@0:8^v16
v28@0:8i16^v20
v32@0:8q16^v24
v32@0:8d16^v24
v32@0:8@16^v24
v20@0:8I16
@36@0:8@16@24B32
B24@0:8^@16
i24@0:8^@16
i24@0:8@16
i20@0:8i16
q24@0:8@16
q20@0:8i16
Q20@0:8i16
B20@0:8i16
d24@0:8@16
d20@0:8i16
@20@0:8i16
r*20@0:8i16
r*24@0:8@16
B40@0:8@16@24*32
@"_bmFMStatement"
@28@0:8@16i24
@36@0:8@16i24@28
v32@0:8q16@?24
softlink:r:path:/System/Library/PrivateFrameworks/BiomeLibrary.framework/BiomeLibrary
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>BuildMachineOSBuild</key>
<string>20A241133</string>
<key>CFBundleIdentifier</key>
<string>com.apple.biomesyncd</string>
<key>CFBundleSupportedPlatforms</key>
<array>
<string>iPhoneSimulator</string>
</array>
<key>DTCompiler</key>
<string>com.apple.compilers.llvm.clang.1_0</string>
<key>DTPlatformBuild</key>
<string>20A5324u</string>
<key>DTPlatformName</key>
<string>iphonesimulator</string>
<key>DTPlatformVersion</key>
<string>16.0</string>
<key>DTSDKBuild</key>
<string>20A5324u</string>
<key>DTSDKName</key>
<string>iphonesimulator16.0.internal</string>
<key>DTXcode</key>
<string>1400</string>
<key>DTXcodeBuild</key>
<string>14A5229d</string>
<key>MinimumOSVersion</key>
<string>16.0</string>
<key>UIDeviceFamily</key>
<array>
<integer>1</integer>
<integer>2</integer>
</array>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>application-identifier</key>
<string>com.apple.biomesyncd</string>
<key>aps-connection-initiate</key>
<true/>
<key>aps-environment</key>
<string>serverPreferred</string>
<key>com.apple.CompanionLink</key>
<true/>
<key>com.apple.application-identifier</key>
<string>com.apple.biomesyncd</string>
<key>com.apple.developer.aps-environment</key>
<string>serverPreferred</string>
<key>com.apple.developer.icloud-container-environment</key>
<string>Production</string>
<key>com.apple.developer.icloud-container-identifiers</key>
<array>
<string>com.apple.biome.sync</string>
</array>
<key>com.apple.developer.icloud-services</key>
<array>
<string>CloudKit</string>
</array>
<key>com.apple.private.appleaccount.app-hidden-from-icloud-settings</key>
<true/>
<key>com.apple.private.aps-connection-initiate</key>
<true/>
<key>com.apple.private.biome.client-identifier</key>
<string>com.apple.biomesyncd</string>
<key>com.apple.private.biome.read-write</key>
<array>
<string>ContextSync.LOI</string>
</array>
<key>com.apple.private.biome.sensorActivation</key>
<true/>
<key>com.apple.private.cloudkit.serviceNameForContainerMap</key>
<dict>
<key>com.apple.biome.sync</key>
<string>com.apple.biome.sync</string>
</dict>
<key>com.apple.private.cloudkit.spi</key>
<true/>
<key>com.apple.private.ids.messaging</key>
<array>
<string>com.apple.private.alloy.contextsync</string>
</array>
<key>com.apple.private.ids.messaging.urgent-priority</key>
<array>
<string>com.apple.private.alloy.contextsync</string>
</array>
<key>com.apple.private.sandbox.profile:embedded</key>
<string>temporary-sandbox</string>
<key>com.apple.private.security.storage.Biome</key>
<true/>
<key>com.apple.private.tcc.allow</key>
<array>
<string>kTCCServiceLiverpool</string>
</array>
<key>com.apple.security.exception.files.home-relative-path.read-write</key>
<array>
<string>/Library/Biome/sync/</string>
<string>/Library/Biome/streams/public</string>
<string>/Library/Biome/streams/public/DeviceMetadata/</string>
<string>/Library/Biome/streams/public/AppIntent/</string>
<string>/Library/Biome/streams/public/AppLaunch/</string>
<string>/Library/Biome/streams/public/Workout/</string>
<string>/Library/Biome/streams/restricted</string>
<string>/Library/Biome/streams/restricted/feedbackSocialHighlights/</string>
<string>/Library/Biome/streams/restricted/SiriMemoryReferenceResolutionStream/</string>
<string>/Library/Biome/streams/restricted/Device.Power.PluggedIn/</string>
<string>/Library/Biome/streams/restricted/Device.Wireless.WiFi/</string>
<string>/Library/Biome/streams/restricted/Device.Power.BatteryLevel/</string>
</array>
<key>com.apple.security.exception.mach-lookup.global-name</key>
<array>
<string>com.apple.CompanionLink</string>
<string>com.apple.biomed.sensorActivation</string>
<string>com.apple.cloudd</string>
<string>com.apple.apsd</string>
<string>com.apple.identityservicesd.embedded.auth</string>
</array>
<key>com.apple.security.exception.shared-preference.read-only</key>
<array>
<string>com.apple.CloudKit</string>
<string>com.apple.ids</string>
<string>com.apple.facetime.bag</string>
</array>
<key>com.apple.security.exception.shared-preference.read-write</key>
<array>
<string>com.apple.biomesyncd</string>
<string>com.apple.contextsync.subscriptions</string>
</array>
<key>com.apple.security.network.client</key>
<true/>
<key>com.apple.security.network.server</key>
<true/>
<key>com.apple.security.ts.mobile-keybag-access</key>
<true/>
<key>com.apple.security.ts.tmpdir</key>
<string>com.apple.biomesyncd</string>
<key>com.apple.wifi.manager-access</key>
<true/>
<key>platform-application</key>
<true/>
</dict>
</plist>
