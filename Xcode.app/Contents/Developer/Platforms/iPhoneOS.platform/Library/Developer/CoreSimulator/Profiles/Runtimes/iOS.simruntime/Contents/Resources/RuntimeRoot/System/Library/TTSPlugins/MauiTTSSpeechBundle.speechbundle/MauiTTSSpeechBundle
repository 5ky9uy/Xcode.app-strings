com.apple.ttsbundle.
MauiServerSpeechDataProviderContext
TTSMauiSpeechServer
TTSMauiSpeechServerInstance
T^{__TTSPlayback=},N,V_playback
T@"ServerSpeechContext",&,N,V_speechContext
notifyMarkStart
Ti,N,V_audioByteCount
request
_currentBuffer
setFrameLength:
_playback
.cxx_destruct
_audioByteCount
T^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I},N,V_currentBuffer
outputByteCount
_appendPhonemesToSpeechContext:outData:
setErr:
_indexOfMarkerToStopBefore:markerStartIndex:audioStartOffset:markerCount:markers:
textRangeOffset
_shouldContinueSpeechGivenMark:markType:blockIfPaused:
_speechContext
_speechVocalizerPlaybackDataProviderWithVocalizer:playback:inContext:
_ttsVocalizerProcessText:callback:context:
_vocalizerMarkerToSpeechMark:
_vocalizerMessageBufferDone:context:outData:
audioBufferCallback
audioByteCount
clientRequest
clientServer
code
currentBuffer
defaultCStringEncoding
finished
getNewSpeechServerInstance
getVocalizerWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
hasPrefix:
identifier
initWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
initWithPCMFormat:frameCapacity:
initWithStreamDescription:
isVoiceValid:
markerBuffer
mutableAudioBufferList
outputFileID
outputPathURL
phonemesSpoken
playback
processGenericMarkerWithByteOffset:name:context:
processWordMarkerWithByteOffset:markerPosition:markerLength:context:secondPass:
setAudioByteCount:
setCurrentBuffer:
setFinished:
setNeedsReset:
setOutputByteCount:
setPhonemesSpoken:
setPlayback:
setSpeechContext:
setStartTime:
setWasStoppedBeforeFullSynthesis:
speechContext
speechRequestDidStartForService:
speechRequestDidSynthesizeSilentlyToURL:forService:
speechService
string
stringWithCString:encoding:
text
vocalizer
voiceType
volume
wasStoppedBeforeFullSynthesis
^{__TTSPlayback=}16@0:8
v24@0:8^{__TTSPlayback=}16
@16@0:8
v24@0:8@16
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16@0:8
v24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
i16@0:8
v20@0:8i16
v16@0:8
[32{?="eMrkType"i"cntSrcPos"Q"cntSrcTextLen"Q"cntDestPos"Q"cntDestLen"Q"usValue"S"ulValue"I"szValue"*}]
^{__TTSPlayback=}
@"ServerSpeechContext"
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}
@88@0:8@16@24B32B36q40q48q56@64@72^@80
B24@0:8@16
@40@0:8@16^{__TTSPlayback=}24^v32
I48@0:8{_VE_HSAFE=^vI}16@32^{?=iQ^vQ^{?}}40
v32@0:8@16^{?=iQ^vQ^{?}}24
q52@0:8@16q24I32q36^{?=iQQQQSI*}44
q20@0:8i16
StartSpeaking
Couldn't process text for server instance: %@
Told to stop speaking beyond a point that has already been spoken, consuming 0 bytes. marker destPos: %zu, audioByteCount: %d
No data consumed and our current buffer is empty. Marking as finished.
dataSizeToConsume was larger than our buffer length! Resetting to just consume the whole buffer. dataSizeToConsume: %u bufLen: %zu
com.apple.ttsbundle.
MauiServerSpeechDataProviderContext
TTSMauiSpeechServer
TTSMauiSpeechServerInstance
T^{__TTSPlayback=},N,V_playback
T@"ServerSpeechContext",&,N,V_speechContext
notifyMarkStart
Ti,N,V_audioByteCount
request
_currentBuffer
setFrameLength:
_playback
.cxx_destruct
_audioByteCount
T^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I},N,V_currentBuffer
outputByteCount
_appendPhonemesToSpeechContext:outData:
setErr:
_indexOfMarkerToStopBefore:markerStartIndex:audioStartOffset:markerCount:markers:
textRangeOffset
_shouldContinueSpeechGivenMark:markType:blockIfPaused:
_speechContext
_speechVocalizerPlaybackDataProviderWithVocalizer:playback:inContext:
_ttsVocalizerProcessText:callback:context:
_vocalizerMarkerToSpeechMark:
_vocalizerMessageBufferDone:context:outData:
audioBufferCallback
audioByteCount
clientRequest
clientServer
code
currentBuffer
defaultCStringEncoding
finished
getNewSpeechServerInstance
getVocalizerWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
hasPrefix:
identifier
initWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
initWithPCMFormat:frameCapacity:
initWithStreamDescription:
isVoiceValid:
markerBuffer
mutableAudioBufferList
outputFileID
outputPathURL
phonemesSpoken
playback
processGenericMarkerWithByteOffset:name:context:
processWordMarkerWithByteOffset:markerPosition:markerLength:context:secondPass:
setAudioByteCount:
setCurrentBuffer:
setFinished:
setNeedsReset:
setOutputByteCount:
setPhonemesSpoken:
setPlayback:
setSpeechContext:
setStartTime:
setWasStoppedBeforeFullSynthesis:
speechContext
speechRequestDidStartForService:
speechRequestDidSynthesizeSilentlyToURL:forService:
speechService
string
stringWithCString:encoding:
text
vocalizer
voiceType
volume
wasStoppedBeforeFullSynthesis
^{__TTSPlayback=}16@0:8
v24@0:8^{__TTSPlayback=}16
@16@0:8
v24@0:8@16
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16@0:8
v24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
i16@0:8
v20@0:8i16
v16@0:8
[32{?="eMrkType"i"cntSrcPos"Q"cntSrcTextLen"Q"cntDestPos"Q"cntDestLen"Q"usValue"S"ulValue"I"szValue"*}]
^{__TTSPlayback=}
@"ServerSpeechContext"
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}
@88@0:8@16@24B32B36q40q48q56@64@72^@80
B24@0:8@16
@40@0:8@16^{__TTSPlayback=}24^v32
I48@0:8{_VE_HSAFE=^vI}16@32^{?=iQ^vQ^{?}}40
v32@0:8@16^{?=iQ^vQ^{?}}24
q52@0:8@16q24I32q36^{?=iQQQQSI*}44
q20@0:8i16
StartSpeaking
Couldn't process text for server instance: %@
Told to stop speaking beyond a point that has already been spoken, consuming 0 bytes. marker destPos: %zu, audioByteCount: %d
No data consumed and our current buffer is empty. Marking as finished.
dataSizeToConsume was larger than our buffer length! Resetting to just consume the whole buffer. dataSizeToConsume: %u bufLen: %zu
