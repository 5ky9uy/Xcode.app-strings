com.apple.ttsbundle.
MauiServerSpeechDataProviderContext
TTSMauiSpeechServer
TTSMauiSpeechServerInstance
playback
setPlayback:
speechContext
setSpeechContext:
currentBuffer
setCurrentBuffer:
audioByteCount
setAudioByteCount:
.cxx_destruct
markerBuffer
_audioByteCount
_playback
_speechContext
_currentBuffer
T^{__TTSPlayback=},N,V_playback
T@"ServerSpeechContext",&,N,V_speechContext
T^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I},N,V_currentBuffer
Ti,N,V_audioByteCount
initWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
identifier
hasPrefix:
voiceType
setWasStoppedBeforeFullSynthesis:
request
text
wasStoppedBeforeFullSynthesis
clientRequest
outputPathURL
clientServer
speechService
speechRequestDidSynthesizeSilentlyToURL:forService:
setNeedsReset:
setFinished:
_vocalizerMessageBufferDone:context:outData:
getNewSpeechServerInstance
getVocalizerWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
isVoiceValid:
outputFileID
_ttsVocalizerProcessText:callback:context:
code
outputByteCount
notifyMarkStart
textRangeOffset
speechRequestDidStartForService:
setStartTime:
finished
_indexOfMarkerToStopBefore:markerStartIndex:audioStartOffset:markerCount:markers:
setErr:
volume
setOutputByteCount:
audioBufferCallback
initWithStreamDescription:
initWithPCMFormat:frameCapacity:
mutableAudioBufferList
setFrameLength:
_appendPhonemesToSpeechContext:outData:
phonemesSpoken
string
setPhonemesSpoken:
vocalizer
_vocalizerMarkerToSpeechMark:
_shouldContinueSpeechGivenMark:markType:blockIfPaused:
processWordMarkerWithByteOffset:markerPosition:markerLength:context:secondPass:
defaultCStringEncoding
stringWithCString:encoding:
processGenericMarkerWithByteOffset:name:context:
_speechVocalizerPlaybackDataProviderWithVocalizer:playback:inContext:
^{__TTSPlayback=}16@0:8
v24@0:8^{__TTSPlayback=}16
@16@0:8
v24@0:8@16
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16@0:8
v24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
i16@0:8
v20@0:8i16
v16@0:8
[32{?="eMrkType"i"cntSrcPos"Q"cntSrcTextLen"Q"cntDestPos"Q"cntDestLen"Q"usValue"S"ulValue"I"szValue"*}]
^{__TTSPlayback=}
@"ServerSpeechContext"
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}
@88@0:8@16@24B32B36q40q48q56@64@72^@80
B24@0:8@16
@40@0:8@16^{__TTSPlayback=}24^v32
I48@0:8{_VE_HSAFE=^vI}16@32^{?=iQ^vQ^{?}}40
v32@0:8@16^{?=iQ^vQ^{?}}24
q52@0:8@16q24I32q36^{?=iQQQQSI*}44
q20@0:8i16
StartSpeaking
Couldn't process text for server instance: %@
Told to stop speaking beyond a point that has already been spoken, consuming 0 bytes. marker destPos: %zu, audioByteCount: %d
No data consumed and our current buffer is empty. Marking as finished.
dataSizeToConsume was larger than our buffer length! Resetting to just consume the whole buffer. dataSizeToConsume: %u bufLen: %zu
com.apple.ttsbundle.
MauiServerSpeechDataProviderContext
TTSMauiSpeechServer
TTSMauiSpeechServerInstance
setPhonemesSpoken:
hasPrefix:
audioBufferCallback
outputFileID
processWordMarkerWithByteOffset:markerPosition:markerLength:context:secondPass:
setOutputByteCount:
clientRequest
speechRequestDidSynthesizeSilentlyToURL:forService:
volume
mutableAudioBufferList
phonemesSpoken
_ttsVocalizerProcessText:callback:context:
setFinished:
_shouldContinueSpeechGivenMark:markType:blockIfPaused:
initWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
setWasStoppedBeforeFullSynthesis:
textRangeOffset
finished
outputByteCount
string
processGenericMarkerWithByteOffset:name:context:
setNeedsReset:
code
voiceType
speechRequestDidStartForService:
initWithStreamDescription:
clientServer
setFrameLength:
initWithPCMFormat:frameCapacity:
vocalizer
wasStoppedBeforeFullSynthesis
notifyMarkStart
speechService
stringWithCString:encoding:
request
setStartTime:
text
outputPathURL
defaultCStringEncoding
identifier
setErr:
playback
setPlayback:
speechContext
setSpeechContext:
currentBuffer
setCurrentBuffer:
audioByteCount
setAudioByteCount:
.cxx_destruct
markerBuffer
_audioByteCount
_playback
_speechContext
_currentBuffer
T^{__TTSPlayback=},N,V_playback
T@"ServerSpeechContext",&,N,V_speechContext
T^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I},N,V_currentBuffer
Ti,N,V_audioByteCount
getNewSpeechServerInstance
getVocalizerWithLanguage:defaultLanguage:reinitIfNecessary:forceReinit:voiceType:gender:footprint:voiceName:voiceIdentifier:error:
isVoiceValid:
_speechVocalizerPlaybackDataProviderWithVocalizer:playback:inContext:
_vocalizerMessageBufferDone:context:outData:
_appendPhonemesToSpeechContext:outData:
_indexOfMarkerToStopBefore:markerStartIndex:audioStartOffset:markerCount:markers:
_vocalizerMarkerToSpeechMark:
^{__TTSPlayback=}16@0:8
v24@0:8^{__TTSPlayback=}16
@16@0:8
v24@0:8@16
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16@0:8
v24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
i16@0:8
v20@0:8i16
v16@0:8
[32{?="eMrkType"i"cntSrcPos"Q"cntSrcTextLen"Q"cntDestPos"Q"cntDestLen"Q"usValue"S"ulValue"I"szValue"*}]
^{__TTSPlayback=}
@"ServerSpeechContext"
^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}
@88@0:8@16@24B32B36q40q48q56@64@72^@80
B24@0:8@16
@40@0:8@16^{__TTSPlayback=}24^v32
I48@0:8{_VE_HSAFE=^vI}16@32^{?=iQ^vQ^{?}}40
v32@0:8@16^{?=iQ^vQ^{?}}24
q52@0:8@16q24I32q36^{?=iQQQQSI*}44
q20@0:8i16
StartSpeaking
Couldn't process text for server instance: %@
Told to stop speaking beyond a point that has already been spoken, consuming 0 bytes. marker destPos: %zu, audioByteCount: %d
No data consumed and our current buffer is empty. Marking as finished.
dataSizeToConsume was larger than our buffer length! Resetting to just consume the whole buffer. dataSizeToConsume: %u bufLen: %zu
