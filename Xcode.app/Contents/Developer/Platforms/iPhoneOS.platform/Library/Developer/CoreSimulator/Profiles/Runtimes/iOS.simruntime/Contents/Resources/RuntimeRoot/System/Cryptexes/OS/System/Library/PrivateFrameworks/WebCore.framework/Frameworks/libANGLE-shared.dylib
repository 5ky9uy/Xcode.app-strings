ANGLECoverageMaskEnabled
ANGLERasterizerDisabled
ANGLEDepthWriteEnabled
C\ A
GL_OVR_multiview2
nsion_pack_es31aGL_ANDROID_extenip_cull_distanceGL_EXT_clip_cullsellation_shaderGL_EXT_tessellat_geometry_shaderGL_EXT_geometry_GL_ANGLE_clip_cu
Frontend features
Frontend workarounds
OpenGL workarounds
OpenGL features
D3D workarounds
Vulkan features
Vulkan workarounds
Vulkan app workarounds
Metal features
Metal workarounds
Unknown
enabled
disabled
MTLB
NAME
blitStencilToBufferCS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertIndexU8ToU16
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertIndexU16
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertIndexU32
TYPE
HASH 
zOFFT
VERS
MDSZ
RFLT
ENDT
NAME
genTriFanIndicesFromArray
TYPE
HASH 
WOFFT
VERS
MDSZ
RFLT
ENDT
NAME
genTriFanIndicesFromElements
TYPE
HASH 
zx#O
`}OFFT
VERS
MDSZ
RFLT
ENDT
NAME
genLineLoopIndicesFromArray
TYPE
HASH 
`OFFT
VERS
MDSZ
RFLT
ENDT
NAME
genLineLoopIndicesFromElements
TYPE
HASH 
zS'h
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generate3DMipmaps
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generate2DMipmaps
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generateCubeMipmaps
TYPE
HASH 
uN`^^
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generate2DArrayMipmaps
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
readFromBufferToFloatTexture
TYPE
HASH 
P75S
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
readFromBufferToIntTexture
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
readFromBufferToUIntTexture
TYPE
HASH 
OOFFT
VERS
MDSZ
RFLT
ENDT
NAME
writeFromFloatTextureToBuffer
TYPE
HASH 
GOFFT
VERS
MDSZ
RFLT
ENDT
NAME
writeFromIntTextureToBuffer
TYPE
HASH 
PjXY
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
writeFromUIntTextureToBuffer
TYPE
HASH 
{B._S4
geMPS:
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertToFloatVertexFormatCS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
expandVertexFormatComponentsCS
TYPE
HASH 
m-&Zy
Ff@OmOE
?OFFT
VERS
MDSZ
RFLT
ENDT
NAME
combineVisibilityResult
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
fixIndexBuffer
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
genIndexBuffer
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitVS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearVS
TYPE
HASH 
9+P#
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertToFloatVertexFormatVS
TYPE
HASH 
iOFFT
VERS
MDSZ
RFLT
ENDT
NAME
expandVertexFormatComponentsVS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitFloatFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitIntFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitUIntFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
copyTextureFloatToUIntFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitDepthFS
TYPE
HASH 
_%Rr
zOFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitStencilFS
TYPE
HASH 
'@"!oW
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitDepthStencilFS
TYPE
HASH 
ANZVoaXH
COFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearFloatFS
TYPE
HASH 
@\_}
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearIntFS
TYPE
HASH 
pOFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearUIntFS
TYPE
HASH 
wOFFT
VERS
MDSZ
RFLT
ENDTRLST
UUID
ENDT(
CNST
kSourceTexture2Type
ENDT
ENDT)
CNST
kSourceBufferAligned
ENDT)
CNST
kSourceBufferAligned
ENDT
ENDTj
CNST\
kSourceBufferAligned
kSourceIndexIsU8
kSourceIndexIsU16
kSourceIndexIsU32
ENDT
ENDTj
CNST\
kSourceBufferAligned
kSourceIndexIsU8
kSourceIndexIsU16
kSourceIndexIsU32
ENDT
ENDT
ENDT
ENDT
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT$
CNST
kCopyFormatType
ENDT
ENDT/
CNST!
kCombineWithExistingResult
ENDT&
CNST
fixIndexBufferKey
ENDT&
CNST
fixIndexBufferKey
ENDT
ENDT
ENDT$
CNST
kCopyFormatType
ENDT
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDT'
CNST
kSourceTextureType
ENDT(
CNST
kSourceTexture2Type
ENDT?
CNST1
kSourceTextureType
kSourceTexture2Type
ENDT%
CNST
kNumColorOutputs
ENDT%
CNST
kNumColorOutputs
ENDT%
CNST
kNumColorOutputs
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
b0$
(",B
qMTD
qMTD
p` M
QEAD)
'#
a9 
`B L0
)2Dh
ND# K
P$v`
fPY8
AqPl
ADIte
<SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.function_constantboolkSourceTexture2Type2Dair.textureair.location_indexair.sampletexture2d<uint, sample>srcTexture2dkSourceTexture2Type2DArraytexture2d_array<uint, sample>srcTexture2dArraykSourceTexture2Type2DMSair.readtexture2d_ms<uint, read>srcTexture2dMSkSourceTexture2TypeCubetexturecube<uint, sample>srcTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infofloat2srcStartTexCoordssrcTexCoordStepsintsrcLevelsrcLayeruint2dstSizeuintdstBufferRowPitchresolveMSair.arg_type_sizeair.arg_type_align_sizeBlitStencilToBufferParamsoptionsair.read_writeucharbufferkSourceTexture2Typeair.sampler_stateomnipotent charSimple C++ TBAA
 ,m0
:XW(
;XW(
;XW(
zH+,M
_ZTS25BlitStencilToBufferParams
 ,q0AX
$6(
:d!
sBp
-P  
`H:@
Ldpl
+1K 
/1K 
C851
>1K 
a1K 
@@*0
0K@a@
__metal_implicit_fc_pred_13__metal_implicit_fc_pred_14__metal_implicit_fc_pred_15__metal_implicit_fc_pred_16llvm.global_ctors_ZL19kSourceTexture2Type_Z19kSourceTexture2Type.MTL_FC_INIT_4_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitStencilToBufferCSair.sample_texture_cube.u.v4i32air.convert.f.f32.s.i32air.read_texture_2d_ms.u.v4i32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i32air.get_num_samples_texture_2d_msair.convert.f.v2f32.u.v2i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
qqNS
"0A)
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsucharinputair.read_writeushortoutput
3j0
3jp
 n0C
3r 
_ZTS21IndexConversionParamsintomnipotent charSimple C++ TBAAshort
dl&H
U0l@
llvm.global_ctorsconvertIndexU8ToU1631001.718air64-apple-ios16.4.0-simulator
b0$
`B L(
#8MED
P$v`
fPY8
AqPl
QYEA
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkSourceBufferUnaligneducharinputkSourceBufferAlignedushortinputAlignedair.read_writeoutputomnipotent charSimple C++ TBAA
3n 
3p`
$3lP
n`]l
n`]l
3[/
&(#66
UH*,M
_ZTS21IndexConversionParamsintshort
]0l@
__metal_implicit_fc_pred_17__metal_implicit_fc_pred_18llvm.global_ctors_ZL20kSourceBufferAligned_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8convertIndexU1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
`B L(
#8MED
P$v`
fPY8
AqPl
QYEA1
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkSourceBufferUnaligneducharinputkSourceBufferAlignedinputAlignedair.read_writeoutputomnipotent charSimple C++ TBAA
3m 
3o`
$3k@
m`]k
m`]k
ksi{#
c+s1c
VH%,M
_ZTS21IndexConversionParamsint
__metal_implicit_fc_pred_17__metal_implicit_fc_pred_18llvm.global_ctors_ZL20kSourceBufferAligned_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8convertIndexU3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofirstVertexvertexCountair.arg_type_sizeair.arg_type_align_sizeIndexFromArrayParamsoptionsair.read_writeoutput
3eP
I3(k@
i3Pc0QhP
y3@a0Ua0
ksI#+s
_ZTS20IndexFromArrayParamsintomnipotent charSimple C++ TBAA
`l <
llvm.global_ctorsgenTriFanIndicesFromArray31001.718air64-apple-ios16.4.0-simulator
b0$
It  
`B L0
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkUseSourceBufferU8ucharinputU8kUseSourceBufferU16ushortinputU16kUseSourceBufferU32inputU32air.read_writeoutputkSourceBufferAlignedkSourceIndexIsU8kSourceIndexIsU16kSourceIndexIsU32omnipotent charSimple C++ TBAA
 `e0
L3r
3vP
I3<|P
q3Pt0Q
(lb0
t`]r
0Ut@
(ll@
tH+,M
D<l)
_ZTS21IndexConversionParamsintshort
|A)f
rl P
2(EQV
2dXP4
?l)\!
__metal_implicit_fc_pred_19__metal_implicit_fc_pred_20__metal_implicit_fc_pred_21llvm.global_ctors_ZL19kUseSourceBufferU32_ZL19kUseSourceBufferU16_ZL18kUseSourceBufferU8_ZL17kSourceIndexIsU32_Z17kSourceIndexIsU32.MTL_FC_INIT_400_b_ZL17kSourceIndexIsU16_Z17kSourceIndexIsU16.MTL_FC_INIT_300_b_Z16kSourceIndexIsU8.MTL_FC_INIT_200_b_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8genTriFanIndicesFromElements31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofirstVertexvertexCountair.arg_type_sizeair.arg_type_align_sizeIndexFromArrayParamsoptionsair.read_writeoutput
3eP
I3(k@
i3Pc0QhP
y3@a0Ua0
ksI#+s
_ZTS20IndexFromArrayParamsintomnipotent charSimple C++ TBAA
llvm.global_ctorsgenLineLoopIndicesFromArray31001.718air64-apple-ios16.4.0-simulator
b0$
It  
`B L0
B0D3I; `
H&.@
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkUseSourceBufferU8ucharinputU8kUseSourceBufferU16ushortinputU16kUseSourceBufferU32inputU32air.read_writeoutputkSourceBufferAlignedkSourceIndexIsU8kSourceIndexIsU16kSourceIndexIsU32omnipotent charSimple C++ TBAA
 `e0
L3r
3vP
I3<|P
q3Pt0Q
(lb0
t`]r
0Ut@
(ll@
tH+,M
D<l)
_ZTS21IndexConversionParamsintshort
Q F5EQ
__metal_implicit_fc_pred_19__metal_implicit_fc_pred_20__metal_implicit_fc_pred_21llvm.global_ctors_ZL19kUseSourceBufferU32_ZL19kUseSourceBufferU16_ZL18kUseSourceBufferU8_ZL17kSourceIndexIsU32_Z17kSourceIndexIsU32.MTL_FC_INIT_400_b_ZL17kSourceIndexIsU16_Z17kSourceIndexIsU16.MTL_FC_INIT_300_b_Z16kSourceIndexIsU8.MTL_FC_INIT_200_b_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8genLineLoopIndicesFromElements31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
qMTD
9MED
 x  
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort3gIndicesair.textureair.location_indexair.sampletexture3d<float, sample>srcTextureair.writetexture3d<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
`0F`
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
`0A 
sC`
1b`!
2 I`
?$sz
24N`
L8sJ
\.G
2PU0bp!
Z@f1
1(AM2
%`~p
!H%1
2h[P
]lep
1Ak
2x_P
1Ayle
}leH
12KP
peP<
!@d2l@
pC`'`0
Lle0
A^`E
n0Pa
_9(H
I /[
~!(H
LleP
v0Pa
tPs@
aox&
4/3K
!L?3l@
{0Pa
T<p
168b`!
sCp>[
sC@>
pC@>`0
BP2c;p
(TX
Lle(#
sCpC
%>"(H
1A,me 'QR(H
*TX
?bp!
1b`!
S`F 
P#A;l
P*A;l
.A;l
3A;l
:A;l
?A;l
FA;l
pJA;l
llvm.global_ctors_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerate3DMipmapsair.write_texture_3d.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v3i16air.wg.barrierair.fast_pow.f32air.sample_texture_3d.v4f32air.convert.f.f32.u.i32air.convert.f.v3f32.u.v3i16air.get_depth_texture_3dair.get_height_texture_3dair.get_width_texture_3d31001.718air64-apple-ios16.4.0-simulator
b0$
qMTD
9MED
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort2gIndicesair.textureair.location_indexair.sampletexture2d<float, sample>srcTextureair.writetexture2d<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
&Er0
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
@t0K@TX
C@Va+CH
A;7
z (H
1AJle
}P(H
,A2Pa
?bp!
1b`!
F`F 
!X`1l@
Q0b`
Lle(
!>bC
%Lt 
!H~1
2TVP
1A|le
sC "[
!L-2l@
jB&cRy
8b`!
:!(H
=Q(H
pC *`0
?bp!
1b`!
K`F 
e0Pa
R*8b
"A;l
'A;l
llvm.global_ctors_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerate2DMipmapsair.write_texture_2d.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v2i16air.wg.barrierair.sample_texture_2d.v4f32air.convert.f.f32.u.i32air.convert.f.v2f32.u.v2i16air.get_height_texture_2dair.get_width_texture_2d31001.718air64-apple-ios16.4.0-simulator
b0$
qMTD
TD$!N
 $E`-j
 B2#
8f0
(F@Bq
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort3gIndicesair.textureair.location_indexair.sampletexturecube<float, sample>srcTextureair.writetexturecube<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
?b`!
3${0
hBb 
20K0
2@QPU^
LleH
!Hb1
2HSPfP
1Amle0
sC`
p"`0
Y0b`
"(r"5
aNl$
pCp&`0
AP0!#p
5!(H
8Q(H
"3bA
T\B
!Xu2l@
T\p 
TXj!
A0b`
sC0/[
g0Pq
sCP3[
AmTF
sC 3
k0Pq
 Cp.
2u3K
p#A;l)
0+A;l
/A;l
llvm.global_ctors_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerateCubeMipmapsair.write_texture_cube.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v2i16air.wg.barrierair.sample_texture_cube.v4f32air.convert.f.f32.u.i32air.convert.f.v2f32.u.v2i16air.get_height_texture_cubeair.get_width_texture_cube31001.718air64-apple-ios16.4.0-simulator
b0$
qMTD
TD$!N
v@fs
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort3gIndicesair.textureair.location_indexair.sampletexture2d_array<float, sample>srcTextureair.writetexture2d_array<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
b0b`!
1b`!
@w0K@T\
C@`a+
Oleh
1AN
B/( 
!Tg1l@
2H[P*
8b`!
1Ax
sCP
sC 
2\XP0
2hY0
T\B&
!P62l@
&lR}
1"8b`!
89(H
H@*[
sC0+[
!]X%
Y9(H
pDq'
"A;l
*A;l
llvm.global_ctors_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerate2DArrayMipmapsair.write_texture_2d_array.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v2i16air.wg.barrierair.sample_texture_2d_array.v4f32air.convert.f.f32.u.i32air.convert.f.v2f32.u.v2i16air.get_height_texture_2d_arrayair.get_width_texture_2d_array31001.718air64-apple-ios16.4.0-simulator
b0$
,E.bI
`$dD
qMTD
qMTD
`B L
)"Dh
QEAD
47`P
P$v`
fPY8
AqPl
\]$]
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort3air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint3copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchbufferDepthPitchair.arg_type_sizeair.arg_type_align_sizeCopyPixelParamsoptionsucharbufferair.function_constantboolkCopyTextureType2Dair.textureair.writetexture2d<float, write>dstTexture2dkCopyTextureType2DArraytexture2d_array<float, write>dstTexture2dArraykCopyTextureType3Dtexture3d<float, write>dstTexture3dkCopyTextureTypeCubetexturecube<float, write>dstTextureCubeintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
LT*T
+pt@
FAp!
ksI#+s
_ZTS15CopyPixelParams
!$h0
%u(PA
@f!
\A^
jpA/
.Q$ma
kEY\@
F\T 
$6tc
$6tc
#$F
5D=n
"7PA
C Nc
d(V#5
`G!
b+7PA
aFbd
C0fd
!F!
!F!
!F!
/$CATF
O2t"'c
AB2-3K
:S.EB2-3K
=c.B
_$B3p
Hgf
 2 3b
gP>t
%32c
*xl@
!F!
6m3b
"B+4K
/xl@8
M`Be
sFP:
V0;z
Awpg
?b!!H
C0tg
!F!
DATF
O2!
C `h
d(hH
(UKB
 CQFc4
rOs
3!<6 
 R2UV
W&U$e
Pb$Wp
`R$5
^wU$
,ES[
`L,
 RL
S'<6 
jKC}
ac?6K
,:6f
Cl=j6
@fb6b
gVfc
ro 7K
^xl@
xl@x
xl@H
 ZCf
 Cpsf
n00
 \ D
 \ D
 C0~
e@ATF
ALl2
dP$o
 \ D
 \ D
 \ D
(!X+H4
(!X+
Ot=Q
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8readFromBufferToFloatTextureair.write_texture_cube.v4f32air.write_texture_3d.v4f32air.write_texture_2d_array.v4f32air.write_texture_2d.v4f32air.convert.u.v3i32.u.v3i16air.convert.f.f32.s.i32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.unpack.unorm4x8.srgb.v4f32air.unpack.unorm4x8.v4f32air.unpack.snorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
,E.bI
`$dD
qMTD
qMTD
`B L8
)"Dh
QEAD
#6SK\
P$v`
fPY8
AqPl
\[$Uu9
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort3air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint3copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchbufferDepthPitchair.arg_type_sizeair.arg_type_align_sizeCopyPixelParamsoptionsucharbufferair.function_constantboolkCopyTextureType2Dair.textureair.writetexture2d<int, write>dstTexture2dkCopyTextureType2DArraytexture2d_array<int, write>dstTexture2dArraykCopyTextureType3Dtexture3d<int, write>dstTexture3dkCopyTextureTypeCubetexturecube<int, write>dstTextureCubeintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~`]|
+pt@
FAp!
ksI#+s
_ZTS15CopyPixelParams
m0Ah
%u(PA
Q F!!
(xEe\
(2
JC'
Pc'
$Fb
(29
ml@ 
 ss
"/F
%R#hBATF
')R$h
Q'pA
ml@x
'<aA
^T%8
/-CATF
$-c3
R$-c3
77PA
h0;lS
hffF
Cufg
flf
(!X+H
f G'
dPG($
Fq4K
:ml@h
 \ D
 \ D
 \ D
ml@@
 \ D
ml@h
 \ D
 \ D
R7PA
38+~
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8readFromBufferToIntTextureair.write_texture_cube.s.v4i32air.write_texture_3d.s.v4i32air.write_texture_2d_array.s.v4i32air.write_texture_2d.s.v4i32air.convert.u.v3i32.u.v3i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
,E.bI
`$dD
qMTD
qMTD
`B L8
)"Dh
QEAD
P$v`
fPY8
AqPl
\\$Y
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort3air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint3copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchbufferDepthPitchair.arg_type_sizeair.arg_type_align_sizeCopyPixelParamsoptionsucharbufferair.function_constantboolkCopyTextureType2Dair.textureair.writetexture2d<uint, write>dstTexture2dkCopyTextureType2DArraytexture2d_array<uint, write>dstTexture2dArraykCopyTextureType3Dtexture3d<uint, write>dstTexture3dkCopyTextureTypeCubetexturecube<uint, write>dstTextureCubeintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~`]|
+pt@
FAp!
ksI#+s
_ZTS15CopyPixelParams
m0Ah
%u(PA
Q F!!
(xEe\
(2
H#'
NC'
$Fb
AATF
B[lip
?d#8
"aBATF
'"R$a
`@'#"
ml@0
1+pA
."CATF
RF\*
B77PA
T&eF
ZGl
`gl
eXf
(!X+
Cf4K
W:ml@
 \ D
ml@8
 \ D
ml@`
 \ D
 \ D
 \ D
ml@8
 \ D
ml@`
s[`C
kE*]@
BR7PA
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8readFromBufferToUIntTextureair.write_texture_cube.u.v4i32air.write_texture_3d.u.v4i32air.write_texture_2d_array.u.v4i32air.write_texture_2d.u.v4i32air.convert.u.v3i32.u.v3i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
&*"~{
`B L@
)"Dh
0lgE
L-qMTD
v@8Q
0Dr-.
P$v`
fPY8
AqPl
VtAG%-
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint2copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchtextureLeveltextureLayerboolreverseTextureRowOrderair.arg_type_sizeair.arg_type_align_sizeWritePixelParamsoptionsair.function_constantkCopyTextureType2Dair.texturetexture2d<float, read>srcTexture2dkCopyTextureType2DArraytexture2d_array<float, read>srcTexture2dArraykCopyTextureType3Dtexture3d<float, read>srcTexture3dkCopyTextureTypeCubetexturecube<float, read>srcTextureCubekCopyTextureType2DMStexture2d_ms<float, read>srcTexture2dMSair.read_writeucharbufferintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
*d[*
*p_,
*p` 
+pt@
ksI#+s
A0hL!
6 f!
A0hN
6 f!
A0hPa
6 f!
A0hR
6 f!
A0hT!
6 f!
ByPd
Lsi
_ZTS16WritePixelParams
H"$|!$JB$LB$NB$PB$RB$T
%\b%6
%DB%
(2bP
CHP  [2
2 G0P!,
DOP  [2
D0l@
12bP
sF`
Hj0m
FnP 
G}P 
B3bP
G0l@
!"3B
 2#?B
2hY0P!
H0l@
R'[2
K0l@
6`Pqr/\q
{s2D
?#7uC
6{s:
M0l@
12bP
A0P!,t
~s0P!
2ho
x0P#
7x3bP
P0l@
Q  [2
|0P!
,A(2h
S?[2
R-Q 
DGf0
?"4bP
pFAJ
$R%E
O+uS
{DJ#
;#_l
T0l@
TrVx
12bP
So%W
O)C`Z
B0P!,
x)s
tuZ
U0l@
_`P$
pC b`0
B0P!
/2h{
oF_C
2x793
#/_l
=ffF
r3Gv
v`Pv
rD0w
pC@w`0
C0P!
=2h
^0l@
C0P!
 1P#
sF 
%F!
UT1
|2P
%La%
A0l@
sF@
61P!
71b`
c`D@
P  [2
;1P#
NNx8
d1bP
E0P!
P  sC@
/6@@
A0l@
sF@
h1P!
i1b`
g`D@
,A[l
P  [2
m1P#
A0l@
sF 
q1P!
r1b`
(sq
i`D@
P  [2
v1P#
A0l@
z1P!
{1b`
k`D@
P  [2
N_x|
A0l@
(sm
m`D@
P  [2
A0l@
A0l@
12bP
,All
P  [2
F0P!,
,Al2h(
,Al
A0l@
F0P!
P  sC 
A0l@
F0P!
P  sC@
w!h
 FF
=Lz8
@0F
A0l@
/6@(
@0F
!?F
@0F
Fd|
A0l@
`>@A
@),(
A0l@
sF@
g(P 
0Kp"#
$2"
"2P!
#2b`
((s
u(2
~`D@
}(P 
x(P  [2
'2P#
 rAp
/6@PE!
rQ`G
@0F
EbE
P0" 
RR`I
$PDx
B0l@
B0l@
B0l@
B0l@
@&AMl
p/AMl
:AMl
CAMl
 ZAMl
0oAMl
hbKA
e8A!
e E!
exE!
exK!
e`O!
e8Y!
e ]!
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25__metal_implicit_fc_pred_26llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8writeFromFloatTextureToBufferair.read_texture_cube.v4f32air.read_texture_3d.v4f32air.convert.f.f32.u.i32air.read_texture_2d_ms.v4f32air.get_num_samples_texture_2d_msair.read_texture_2d_array.v4f32air.read_texture_2d.v4f32air.convert.u.v2i32.u.v2i16air.convert.s.i8.f.f32air.convert.u.i8.f.f32air.convert.u.i16.f.f32air.pack.snorm4x8.v4f32air.pack.unorm4x8.srgb.v4f32air.pack.unorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
GISD
!Pq
bK!V
"x  
`B L@
)"Dh
*$2F
P$v`
fPY8
AqPl
VtAG%-
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint2copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchtextureLeveltextureLayerboolreverseTextureRowOrderair.arg_type_sizeair.arg_type_align_sizeWritePixelParamsoptionsair.function_constantkCopyTextureType2Dair.texturetexture2d<int, read>srcTexture2dkCopyTextureType2DArraytexture2d_array<int, read>srcTexture2dArraykCopyTextureType3Dtexture3d<int, read>srcTexture3dkCopyTextureTypeCubetexturecube<int, read>srcTextureCubekCopyTextureType2DMStexture2d_ms<int, read>srcTexture2dMSair.read_writeucharbufferintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~H+,M
A2l@
B2l@
_ZTS16WritePixelParams
H"$|!$JB$LB$NB$PB$RB$T
%\b%6
%DB%
,b@d
1AHli
0(T8
8AADj
Ic0mi
?(C@
2DP0P
<(h1
<lip
-@c6(
~c4!
k!P
Pk1"pA
Q"8BADj
?^dG(
f0bP
@ sCp'[
p +g
pC@+`P$2&\$
"pI
K0l@
(Cp6
A0P!,t`js0P
 C@/
M0l@
!X7s
bGvj
`!x
CcDG
F}DADj
CD0J
PCJ+
6tC5
@ sC
Cul@
P:4OpA
R0l@
pC`S`P
tR3E
W0^a
dKCM
U0l@
P,%^pA
U0l@
Tq^x
ul@p
V0l@
hbK!
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25__metal_implicit_fc_pred_26llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8writeFromIntTextureToBufferair.read_texture_cube.s.v4i32air.read_texture_3d.s.v4i32air.read_texture_2d_ms.s.v4i32air.get_num_samples_texture_2d_msair.read_texture_2d_array.s.v4i32air.read_texture_2d.s.v4i32air.convert.u.v2i32.u.v2i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
GISD
!Pq
bK!V
"x  
`B L@
)"Dh
0,gE
*$2F
P$v`
fPY8
AqPl
VtAG%-
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint2copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchtextureLeveltextureLayerboolreverseTextureRowOrderair.arg_type_sizeair.arg_type_align_sizeWritePixelParamsoptionsair.function_constantkCopyTextureType2Dair.texturetexture2d<uint, read>srcTexture2dkCopyTextureType2DArraytexture2d_array<uint, read>srcTexture2dArraykCopyTextureType3Dtexture3d<uint, read>srcTexture3dkCopyTextureTypeCubetexturecube<uint, read>srcTextureCubekCopyTextureType2DMStexture2d_ms<uint, read>srcTexture2dMSair.read_writeucharbufferintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~H+,M
A2l@
B2l@
_ZTS16WritePixelParams
H"$|!$JB$LB$NB$PB$RB$T
%\b%6
%DB%
,b@d
1AHli
0(T8
8AADj
Ic0mi
?(C@
2DP0P
<(h1
<lip
-@c6(
~c4!
k!P
Pk1"pA
Q"8BADj
?^dG(
f0bP
@ sCp'[
p +g
pC@+`P$2&\$
"pI
K0l@
(Cp6
A0P!,t`js0P
 C@/
M0l@
!X7s
bGvj
`!x
CcDG
F}DADj
CD0J
PCJ+
6tC5
@ sC
Cul@
P:4OpA
R0l@
pC`S`P
tR3E
W0^a
dKCM
U0l@
P,%^pA
U0l@
Tq^x
ul@p
V0l@
hbK!
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25__metal_implicit_fc_pred_26llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8writeFromUIntTextureToBufferair.read_texture_cube.u.v4i32air.read_texture_3d.u.v4i32air.read_texture_2d_ms.u.v4i32air.get_num_samples_texture_2d_msair.read_texture_2d_array.u.v4i32air.read_texture_2d.u.v4i32air.convert.u.v2i32.u.v2i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
!D1a0
v@e@
@0DJ
P$v`
fPY8
AqPl
E%QcLT
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBufferintkCopyFormatTypeomnipotent charSimple C++ TBAA_ZTS16CopyVertexParams
 t`0
 td0
 th0
3t0
3tp
 x0C
r`]p0
3@{0Up 
ksi{#
c+s1c
]H%,M
2TB!
JAL
6@b6B
6D"7F
7JB<L
=Pb=R
=T">V
>ZB?\
D`bDb
 F"
]lBH
F0l@
F"
^@@M1
P"32&
"6R"
H0l@
F"
^@@M
K0l@
/&c3
 F"
 F"
28s2
L0l@
6ws:
@F"
@F"
N0l@
3?#D
F"
]lB0
^@@M
TBOpA
^@@%b
T0l@
0*x+
U0l@
AcpA
bt.
56fsF
^@@%
Y0l@
]lB0
^@@%p
\0l@
!X=0
TB~pA
]lBp
!p?0
`G"
`G"
A0l@
F"
A0l@
^@@%
!ED!8>
}~4
F"
A0l@
^@@%
]lB 
!EP!
`G"
A0l@
^@@E
!EZ!
d/C=
A0l@
^@@Eb
]lBX
`/CL
!E~!(
A0l@
F"
A0l@
^@@%<
F"
A0l@
^@@%
F"
A0l@
^@@%6
F"
A0l@
^@@%
`G"
`G"
B0l@
^@@Ec(
]lB`A!
B0l@
^@@Mz)
*,pE
*,@G
`/Cm
C*Q!
BIaM
XRHS
B0l@
^@@M
0*hWA
RTh[
Q!@[
Cr]!
`G"
Cb_!
B0l@
^@@E
!EF"(s
, YA
JX(z
*,@[
B0l@
!EH"8
c8_!
CZk!
*,he
F"
B0l@
^@@%$.
]lB o!
!ET"8x
i!hq
 ,(s
0*hsA
R[hw
cpo! w
F"
B0l@
^@@%t/
!E`"
c8u!
0*0}A
fba
,XyA
(!X+Tq
!Ep"
C0l@
^@@M
d/C?
F"
C0l@
^@@%j9
]lBP
!Ex"8
 ZCRs
 c#,
`G"
C0l@
^@@E ;
]lBH
C0l@
(!X+\x
F"
C0l@
^@@%r<
 ZCby
(!X+
d/C/
F"
C0l@
^@@%*=
]lBP
(!X+
d/C]
F"
C0l@
^@@%
 ZCB|
(!X+l|
F"
C0l@
^@@%z>
`G"
`G"
@9m?
(!X+H
(!X+
`/C;
(!X+
-1$J
 ZCl
(S$t
(!X+
(!X+
 ZCR
(!X+|
C"Y"
(!X+z
(6%@
(!X+b
0*H]B
`G"
?$5&
C:e"
 ,he
C"g"
 ,Pg
_&d/
D0l@
^@@E,M
!EV#(
 ,(m
D0l@
!EX#8
Cz{"
(!X+P
cxu"(}
(!X+
F"
?$>,
E0l@
^@@%|X
!Ed#8
 ZCv
 ZCb
(!X+
(!X+t
5-d/
F"
?$\-
E0l@
^@@%
!Ep#
wWzc
|ca
@90\
*1. 
*1.`
1.Jf
E0l@
]lBx
E0l@
^@@E)^
X/d/C
E0l@
^@@E
]lB8
E0l@
]lBp
 ,XC
"PCc/C
 ,HG
-44F
`G"
(<4v
F0l@
^@@E`j
]lBHQ#
 ,pU
 ,XW
"OC\
 ,@Y
,pQC
F0l@
#805
@X#Z
"8Wc/
F0l@
^@@M#l
]lB`_#
(~5n
+@aC
!h[c/C
!EB$
F0l@
^@@M
+peC
0*HgC
c#pk
0*xkC
p+A;l
2A;l
7A;l
p>A;l
`OA;l
[A;l
bA;l
nA;l
sA;l
zA;l
e`I!h
e(S!h
ePY!h
ep_!h
eXi!h
e8s!h
exy!`
eXE"h
e@O"h
eHY"h
ep_"h
e8i"h
e(s"h
e8}"h
ePA#h
ehQ#h
eX[#h
epa#h
e0e#h
eH}#h
llvm.global_ctors_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_i_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalconvertToFloatVertexFormatCS_ZL26convertToFloatVertexFormatjRU11MTLconstantK16CopyVertexParamsPU11MTLconstantKhPU9MTLdevicehair.convert.f.f32.u.i32air.convert.f.f32.s.i32air.convert.f.f32.s.i16air.unpack.snorm4x8.v4f32air.unpack.unorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializer
b0$
S@DG
P$v`
fPY8
AqPl
E%QcLT
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBuffer
L3k
3oP
@(vP
3Pm0QxP
3@k0Um
ksI#+s
_ZTS16CopyVertexParamsintomnipotent charSimple C++ TBAA
%,2K0T
,A1P
uU1K
0d`0
! 1T
2HA:l
llvm.global_ctorsexpandVertexFormatComponentsCSair.min.u.i3231001.718air64-apple-ios16.4.0-simulator
b0$
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infostartOffsetnumOffsetsair.arg_type_sizeair.arg_type_align_sizeCombineVisibilityResultOptionsoptionsushort4renderpassVisibilityResultair.read_writefinalResultsboolkCombineWithExistingResultomnipotent charSimple C++ TBAA
@P3g
3kP
I3(q
i3Pi0QnP
y3@g0Ui
ksi{#
c+s1c
SH%,M
_ZTS30CombineVisibilityResultOptionsint
1K`T4
8DcT
|@4F
\Pc7A
llvm.global_ctors_ZL26kCombineWithExistingResult_Z26kCombineWithExistingResult.MTL_FC_INIT_1000_b_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalcombineVisibilityResult31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializer
b0$
0*%H
`B L8
)"Dh
QEAD; `
$&h ,
P$v`
fPY8
AqPl
lD4<
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolindexBufferIsUint16air.bufferair.location_indexair.readair.address_spaceair.arg_type_sizeair.arg_type_align_sizeair.arg_type_nameushortair.arg_nameindexBufferUint16indexBufferIsUint32uintindexBufferUint32outIndexBufferIsUint16air.read_writeoutIndexBufferUint16outIndexBufferIsUint32outIndexBufferUint32air.buffer_sizeindexCountprimCountair.thread_position_in_gridprimfixIndexBufferKeyintomnipotent charSimple C++ TBAA
3n 
3p`
$3lP
@3Hv
XopqY7
Xopq
n0QlP
)pt@
FABA
ksI#+s
short
E@u 
x2K`
1L# h1
2 L@y
20Kp
Z7|
2HV@
Snl!
pc?A
z0l@
7$&
!87x0l@
7P1
1x0l@
Bpwqc
@vXAvZAvV
0P"p
d# 7
pCp'`0
P+2'0
#nl!
I0l@
t+ 7
O\ b
Snl!
.`PW
N\nl!
K0l@
3`@h
!&db
;x0l@
@&m`
A8l)
A8l)Z!
A:l)
9l)H#
 "A8l
/A8l
3A:l
aK1B
pCA:l
aKAG
PKA:l)n)
@OA8
__metal_implicit_fc_pred_27__metal_implicit_fc_pred_28__metal_implicit_fc_pred_29__metal_implicit_fc_pred_30llvm.global_ctors_ZL18fixIndexBufferMode_ZL13doPrimRestart_ZL22outIndexBufferIsUint32_ZL22outIndexBufferIsUint16_ZL19indexBufferIsUint32_ZL19indexBufferIsUint16_ZL17fixIndexBufferKey_Z17fixIndexBufferKey.MTL_FC_INIT_2000_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8fixIndexBuffer31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
J)Ar  
4 6,
`B L0
)"Dh
QEAD; `
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantbooloutIndexBufferIsUint16air.bufferair.location_indexair.read_writeair.address_spaceair.arg_type_sizeair.arg_type_align_sizeair.arg_type_nameushortair.arg_nameoutIndexBufferUint16outIndexBufferIsUint32uintoutIndexBufferUint32air.buffer_sizeair.readindexCountair.arg_unusedprimCountfirstVertexair.thread_position_in_gridprimfixIndexBufferKeyintomnipotent charSimple C++ TBAA
3n@
l0QlP
u3Lj
)pt@
ksI#+s
short
D@l 
 lpH
 u|7K
2,Jp
@MAu
pc?A
7x%
70=
.$nl!
DP!!
pc?!'
pc?A.
nx0l@
3nl!
G0l@
.x0l@
P R&0
nx0l@
D+bT
+ 7
+nl!
J0l@
nx0l@
Tnl!
JPgp*0l@
'n":
raKQ
A.l)
] ~a
] ~a
A8l)
 &A.l
*A8l
`6A.l
:A8l
] ~a
>A8l)
 CA.l
pGA8l
__metal_implicit_fc_pred_29__metal_implicit_fc_pred_30llvm.global_ctors_ZL18fixIndexBufferMode_ZL22outIndexBufferIsUint32_ZL22outIndexBufferIsUint16_ZL17fixIndexBufferKey_Z17fixIndexBufferKey.MTL_FC_INIT_2000_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8genIndexBuffer31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
Hn`H
S@%TDeT
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.positionair.arg_type_namefloat4air.arg_namepositionair.vertex_outputuser(locn1)float2texCoordsair.vertex_iduintvidair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerbooldstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptions
3r@
A3C
&(#66
UH*,M
omnipotent charSimple C++ TBAA_ZTS10BlitParams
/lxv
5((Pd
llvm.global_ctors_ZN2rx10mtl_shaderL8gCornersEblitVS31001.718air64-apple-ios16.4.0-simulator
b0$
Hq  
("(
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.positionair.arg_type_namefloat4air.vertex_iduintair.arg_namevidair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infoclearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsf\
3f0
3fp
 j0C
&(#66
<H*,M
omnipotent charSimple C++ TBAA_ZTS11ClearParams
llvm.global_ctors_ZN2rx10mtl_shaderL8gCornersEclearVS31001.718air64-apple-ios16.4.0-simulator
b0$
!D1a0
v@e@
@0DJ
P$v`
fPY8
AqPl
E%QcLT
<SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.vertex_idair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBufferintkCopyFormatTypeomnipotent charSimple C++ TBAA
 t`0
3s0
3sp
 w0C
q`]o0
3@z0Uo
ksi{#
c+s1c
YH%,M
<l@B
2TB!
_ZTS16CopyVertexParams
 td0A
JAL
6@b6B
6D"7F
7JB<L
=Pb=R
=T">V
>ZB?\
D`bDb
 F"
]lBH
F0l@
F"
^@@M1
P"32&
"6R"
H0l@
F"
^@@M
K0l@
/&c3
 F"
 F"
28s2
L0l@
6ws:
@F"
@F"
N0l@
3?#D
F"
]lB0
^@@M
TBOpA
^@@%b
T0l@
0*x+
U0l@
AcpA
bt.
56fsF
^@@%
Y0l@
]lB0
^@@%p
\0l@
!X=0
TB~pA
]lBp
!p?0
`G"
`G"
A0l@
F"
A0l@
^@@%
!ED!8>
}~4
F"
A0l@
^@@%
]lB 
!EP!
`G"
A0l@
^@@E
!EZ!
d/C=
A0l@
^@@Eb
]lBX
`/CL
!E~!(
A0l@
F"
A0l@
^@@%<
F"
A0l@
^@@%
F"
A0l@
^@@%6
F"
A0l@
^@@%
`G"
`G"
B0l@
^@@Ec(
]lB`A!
B0l@
^@@Mz)
*,pE
*,@G
`/Cm
C*Q!
BIaM
XRHS
B0l@
^@@M
0*hWA
RTh[
Q!@[
Cr]!
`G"
Cb_!
B0l@
^@@E
!EF"(s
, YA
JX(z
*,@[
B0l@
!EH"8
c8_!
CZk!
*,he
F"
B0l@
^@@%$.
]lB o!
!ET"8x
i!hq
 ,(s
0*hsA
R[hw
cpo! w
F"
B0l@
^@@%t/
!E`"
c8u!
0*0}A
fba
,XyA
(!X+Tq
!Ep"
C0l@
^@@M
d/C?
F"
C0l@
^@@%j9
]lBP
!Ex"8
 ZCRs
 c#,
`G"
C0l@
^@@E ;
]lBH
C0l@
(!X+\x
F"
C0l@
^@@%r<
 ZCby
(!X+
d/C/
F"
C0l@
^@@%*=
]lBP
(!X+
d/C]
F"
C0l@
^@@%
 ZCB|
(!X+l|
F"
C0l@
^@@%z>
`G"
`G"
@9m?
(!X+H
(!X+
`/C;
(!X+
-1$J
 ZCl
(S$t
(!X+
(!X+
 ZCR
(!X+|
C"Y"
(!X+z
(6%@
(!X+b
0*H]B
`G"
?$5&
C:e"
 ,he
C"g"
 ,Pg
_&d/
D0l@
^@@E,M
!EV#(
 ,(m
D0l@
!EX#8
Cz{"
(!X+P
cxu"(}
(!X+
F"
?$>,
E0l@
^@@%|X
!Ed#8
 ZCv
 ZCb
(!X+
(!X+t
5-d/
F"
?$\-
E0l@
^@@%
!Ep#
wWzc
|ca
@90\
*1. 
*1.`
1.Jf
E0l@
]lBx
E0l@
^@@E)^
X/d/C
E0l@
^@@E
]lB8
E0l@
]lBp
 ,XC
"PCc/C
 ,HG
-44F
`G"
(<4v
F0l@
^@@E`j
]lBHQ#
 ,pU
 ,XW
"OC\
 ,@Y
,pQC
F0l@
#805
@X#Z
"8Wc/
F0l@
^@@M#l
]lB`_#
(~5n
+@aC
!h[c/C
!EB$
F0l@
^@@M
+peC
0*HgC
c#pk
0*xkC
p+A;l
2A;l
7A;l
p>A;l
`OA;l
[A;l
bA;l
nA;l
sA;l
zA;l
e`I!h
e(S!h
ePY!h
ep_!h
eXi!h
e8s!h
exy!`
eXE"h
e@O"h
eHY"h
ep_"h
e8i"h
e(s"h
e8}"h
ePA#h
ehQ#h
eX[#h
epa#h
e0e#h
eH}#h
llvm.global_ctors_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_i_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalconvertToFloatVertexFormatVS_ZL26convertToFloatVertexFormatjRU11MTLconstantK16CopyVertexParamsPU11MTLconstantKhPU9MTLdevicehair.convert.f.f32.u.i32air.convert.f.f32.s.i32air.convert.f.f32.s.i16air.unpack.snorm4x8.v4f32air.unpack.unorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializer
b0$
S@DG
P$v`
fPY8
AqPl
E%QcLT
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.vertex_idair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBuffer
L3k
3oP
@(vP
3Pm0QxP
3@k0Um
ksI#+s
_ZTS16CopyVertexParamsintomnipotent charSimple C++ TBAA
AeT
0Eb0
A0l@
B0l@
2@A:l
llvm.global_ctorsexpandVertexFormatComponentsVSair.min.u.i3231001.718air64-apple-ios16.4.0-simulator
b0$
&*"~
xD4*
 m("$H
`B L(
)"Dh
hO4@A
%(k0
@0DJ
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_namefloat4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivepositionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcTextureCubekSourceTextureType3Dtexture3d<float, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
d1Cb
<<n0
=<w0
=<~0
0<|A
ksi{#
c+s1c
H&,M
_ZTS10BlitParams
)lxD
C0bP
D0P!,
04up
).1
NP  #
XP  #
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitFloatFS_ZL15blitReadTextureIfEDv4_T_9BlitVSOutN5metal9texture2dIS0_LNS3_6accessE0EvEENS3_15texture2d_arrayIS0_LS5_0EvEENS3_12texture2d_msIS0_LS5_1EvEENS3_11texturecubeIS0_LS5_0EvEENS3_9texture3dIS0_LS5_0EvEENS3_7samplerERU11MTLconstantK10BlitParamsair.sample_texture_3d.v4f32air.convert.f.f32.s.i32air.convert.f.f32.u.i32air.get_depth_texture_3dair.sample_texture_cube.v4f32air.read_texture_2d_ms.v4f32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
T+U$" V
reA]>
`B L@
$Q&
)"Dh
h64@9
dkaP
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<int, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<int, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<int, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<int, sample>srcTextureCubekSourceTextureType3Dtexture3d<int, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
e1Cr
:8k
!1CA
3O_
%RB%V
%Rac
ksI#+s
;k+s
_ZTS10BlitParams
)lxF
1T<
sB@
1AK
EaB@
k1b`
,A5P
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitIntFSair.convert.f.f32.s.i32air.sample_texture_3d.s.v4i32air.convert.f.f32.u.i32air.get_depth_texture_3dair.sample_texture_cube.s.v4i32air.read_texture_2d_ms.s.v4i32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.s.v4i32air.sample_texture_2d.s.v4i3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
T+U$" V
reA]>
`B L@
$Q&
)"Dh
'4@9
v@cS
v@7D
8Dj%: 
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameuint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<uint, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<uint, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<uint, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<uint, sample>srcTextureCubekSourceTextureType3Dtexture3d<uint, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
e1Cr
:8k
!1CA
3O_
%RB%V
%Rac
ksI#+s
;k+s
_ZTS10BlitParams
)lxF
1T<
sB@
1AK
EaB@
k1b`
,A5P
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitUIntFSair.convert.f.f32.u.i32air.sample_texture_3d.u.v4i32air.convert.f.f32.s.i32air.get_depth_texture_3dair.sample_texture_cube.u.v4i32air.read_texture_2d_ms.u.v4i32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
"<$d*
*BD@
`B L(
)"Dh
0,&8
D4@I
tCd ,l0
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameuint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcTextureCubekSourceTextureType3Dtexture3d<float, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
e1Cr
:8k
!1CA
3O_
%RB%V
%Rac
ksI#+s
;k+s
_ZTS10BlitParams
*lxF
C0bP
D0P!,
04vp
).1
NP  #
XP  #
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8copyTextureFloatToUIntFSair.convert.u.v4i32.f.v4f32_ZL15blitReadTextureIfEDv4_T_9BlitVSOutN5metal9texture2dIS0_LNS3_6accessE0EvEENS3_15texture2d_arrayIS0_LS5_0EvEENS3_12texture2d_msIS0_LS5_1EvEENS3_11texturecubeIS0_LS5_0EvEENS3_9texture3dIS0_LS5_0EvEENS3_7samplerERU11MTLconstantK10BlitParamsair.sample_texture_3d.v4f32air.convert.f.f32.s.i32air.convert.f.f32.u.i32air.get_depth_texture_3dair.sample_texture_cube.v4f32air.read_texture_2d_ms.v4f32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
(",B
wISD
qMTD
"lA
`B L
)2Dh
v@xa-
KlB0
P$v`
fPY8
AqPl
(OD1
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.depthair.depth_qualifierair.anyair.arg_type_namefloatair.arg_namedepthair.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordsair.function_constantboolkSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionskSourceTextureTypeair.sampler_stateomnipotent charSimple C++ TBAA
<P$M
I*l
&(#66
vH*,M
H),M
6 N!
6 N!
A0x@
6 V!
A0xB
6 V!
_ZTS10BlitParams
 ,r0AX
6<)a
7lq`
@F!
Da4!
fa4!
aAq
@F!
@`paP
__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitDepthFS_ZL11sampleDepthN5metal9texture2dIfLNS_6accessE0EvEENS_15texture2d_arrayIfLS1_0EvEENS_12texture2d_msIfLS1_1EvEENS_11texturecubeIfLS1_0EvEEDv2_fRU11MTLconstantK10BlitParamsair.sample_texture_cube.v4f32air.convert.f.f32.s.i32air.read_texture_2d_ms.v4f32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
(",B
wISD
qMTD
"lA
O(H4Q
,$fR
E%I |  
`B L0
)2Dh
ND# 
JjB0
P$v`
fPY8
AqPl
h]t!
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.stencilair.arg_type_nameuintair.arg_namestencilair.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordsair.function_constantboolkSourceTexture2Type2Dair.textureair.location_indexair.sampletexture2d<uint, sample>srcTexture2dkSourceTexture2Type2DArraytexture2d_array<uint, sample>srcTexture2dArraykSourceTexture2Type2DMSair.readtexture2d_ms<uint, read>srcTexture2dMSkSourceTexture2TypeCubetexturecube<uint, sample>srcTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionskSourceTexture2Typeair.sampler_stateomnipotent charSimple C++ TBAA
L)x
*x
H+,M
6 P!
6 P!
6 P!
A0x@
6 P!
_ZTS10BlitParams
 ,q0AX
%6/Q
1 F!
%hF!
Da4!
CPXa
C`\a
@``a
__metal_implicit_fc_pred_13__metal_implicit_fc_pred_14__metal_implicit_fc_pred_15__metal_implicit_fc_pred_16llvm.global_ctors_ZL19kSourceTexture2Type_Z19kSourceTexture2Type.MTL_FC_INIT_4_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitStencilFSair.sample_texture_cube.u.v4i32air.convert.f.f32.s.i32air.read_texture_2d_ms.u.v4i32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
(",B"
&*"~{
&*"~{
lE!YL
tBE"
P-T$"
`B L0
3Ax 
)2Dh
H,4@
%(b0
!R,mp
@0DJ
S@%TDeD
P$v`
fPY8
AqPl
gYH6Y
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.depthair.depth_qualifierair.anyair.arg_type_namefloatair.arg_namedepthair.stenciluintstencilair.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordsair.function_constantboolkSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcDepthTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcDepthTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcDepthTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcDepthTextureCubekSourceTexture2Type2Dtexture2d<uint, sample>srcStencilTexture2dkSourceTexture2Type2DArraytexture2d_array<uint, sample>srcStencilTexture2dArraykSourceTexture2Type2DMStexture2d_ms<uint, read>srcStencilTexture2dMSkSourceTexture2TypeCubetexturecube<uint, sample>srcStencilTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionskSourceTextureTypekSourceTexture2Typeair.sampler_stateomnipotent charSimple C++ TBAA_ZTS10BlitParams
 ,|0
5CQE
FADb$H
$P"%Rac
ksI#+s
;k+s
@7$m
sl@
,A3bP
!8y0
!H}`x
A1b`
 (2
sBP
sC0
sx0
__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_13__metal_implicit_fc_pred_14__metal_implicit_fc_pred_15__metal_implicit_fc_pred_16__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL19kSourceTexture2Type_Z19kSourceTexture2Type.MTL_FC_INIT_4_i_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitDepthStencilFSair.sample_texture_cube.u.v4i32air.convert.f.f32.s.i32air.read_texture_2d_ms.u.v4i32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i32_ZL11sampleDepthN5metal9texture2dIfLNS_6accessE0EvEENS_15texture2d_arrayIfLS1_0EvEENS_12texture2d_msIfLS1_1EvEENS_11texturecubeIfLS1_0EvEEDv2_fRU11MTLconstantK10BlitParamsair.sample_texture_cube.v4f32air.read_texture_2d_ms.v4f32air.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
'ISD
`B L
)"Dh
0,#,
'4@y
P$v`
fPY8
AqPl
HHD)
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_namefloat4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infoclearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsuintkNumColorOutputsomnipotent charSimple C++ TBAA
3w 
3y`
$3u
@3$N/D
DU3
D]3
`3$N8Du
De3
Dm3
p3$N9Dx
Du3
D}3
4Qa0
ksi{#
c+s1c
]H&,M
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7llvm.global_ctors_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8clearFloatFS31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
`B L
)"Dh
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofloat4clearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsuintkNumColorOutputsomnipotent charSimple C++ TBAAF
3x 
3z`
$3v
DU3
D]3
De3
Dm3
Du3
D}3
4Qa0
Pq0C
ksI#+s
;k+s
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7llvm.global_ctors_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8clearIntFS31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
`B L
)"Dh
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameuint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofloat4clearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsuintkNumColorOutputsomnipotent charSimple C++ TBAA
3x 
3z`
$3v
DU3
D]3
De3
Dm3
Du3
D}3
4Qa0
Pq0C
ksI#+s
;k+s
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7llvm.global_ctors_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8clearUIntFS31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
RBUFg
AIRR
kSourceTexture2Type
buffer
uchar
resolveMS
bool
dstBufferRowPitch
uint
dstSize
uint2
srcLayer
srcLevel
srcTexCoordSteps
srcStartTexCoords
float2
options
BlitStencilToBufferParams
srcTextureCube
texturecube<uint, sample>
srcTexture2dMS
texture2d_ms<uint, read>
srcTexture2dArray
texture2d_array<uint, sample>
srcTexture2d
texture2d<uint, sample>
gIndices
ushort2
blitStencilToBufferCS
ENDT
RBUF
AIRR
output
ushort
input
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
convertIndexU8ToU16
ENDT
RBUF
AIRR
kSourceBufferAligned
output
inputAligned
ushort
input
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
convertIndexU16
ENDT
RBUF
AIRR
kSourceBufferAligned
output
inputAligned
input
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
convertIndexU32
ENDT\
RBUFL
AIRR
output
vertexCount
firstVertex
options
IndexFromArrayParams
uint
genTriFanIndicesFromArray
ENDT
RBUF
AIRR
kSourceIndexIsU32
kSourceIndexIsU16
kSourceIndexIsU8
kSourceBufferAligned
output
inputU32
inputU16
ushort
inputU8
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
genTriFanIndicesFromElements
ENDT`
RBUFP
AIRR
output
vertexCount
firstVertex
options
IndexFromArrayParams
uint
genLineLoopIndicesFromArray
ENDT
RBUF
AIRR
kSourceIndexIsU32
kSourceIndexIsU16
kSourceIndexIsU8
kSourceBufferAligned
output
inputU32
inputU16
ushort
inputU8
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
genLineLoopIndicesFromElements
ENDT,
RBUF
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texture3d<float, write>
srcTexture
texture3d<float, sample>
gIndices
ushort3
lIndex
uint
generate3DMipmaps
ENDT 
RBUF
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texture2d<float, write>
srcTexture
texture2d<float, sample>
gIndices
ushort2
lIndex
uint
generate2DMipmaps
ENDT$
RBUF
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texturecube<float, write>
srcTexture
texturecube<float, sample>
gIndices
ushort3
lIndex
uint
generateCubeMipmaps
ENDT<
RBUF,
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texture2d_array<float, write>
srcTexture
texture2d_array<float, sample>
gIndices
ushort3
lIndex
uint
generate2DArrayMipmaps
ENDTh
RBUFX
AIRR
kCopyTextureType
kCopyFormatType
dstTextureCube
texturecube<float, write>
dstTexture3d
texture3d<float, write>
dstTexture2dArray
texture2d_array<float, write>
dstTexture2d
texture2d<float, write>
buffer
uchar
bufferDepthPitch
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint3
options
CopyPixelParams
gIndices
ushort3
readFromBufferToFloatTexture
ENDTd
RBUFT
AIRR
kCopyTextureType
kCopyFormatType
dstTextureCube
texturecube<int, write>
dstTexture3d
texture3d<int, write>
dstTexture2dArray
texture2d_array<int, write>
dstTexture2d
texture2d<int, write>
buffer
uchar
bufferDepthPitch
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint3
options
CopyPixelParams
gIndices
ushort3
readFromBufferToIntTexture
ENDTh
RBUFX
AIRR
kCopyTextureType
kCopyFormatType
dstTextureCube
texturecube<uint, write>
dstTexture3d
texture3d<uint, write>
dstTexture2dArray
texture2d_array<uint, write>
dstTexture2d
texture2d<uint, write>
buffer
uchar
bufferDepthPitch
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint3
options
CopyPixelParams
gIndices
ushort3
readFromBufferToUIntTexture
ENDT@
RBUF0
AIRR
kCopyTextureType
kCopyFormatType
buffer
uchar
srcTexture2dMS
texture2d_ms<float, read>
srcTextureCube
texturecube<float, read>
srcTexture3d
texture3d<float, read>
srcTexture2dArray
texture2d_array<float, read>
srcTexture2d
texture2d<float, read>
reverseTextureRowOrder
bool
textureLayer
textureLevel
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint2
options
WritePixelParams
gIndices
ushort2
writeFromFloatTextureToBuffer
ENDT0
RBUF 
AIRR
kCopyTextureType
kCopyFormatType
buffer
uchar
srcTexture2dMS
texture2d_ms<int, read>
srcTextureCube
texturecube<int, read>
srcTexture3d
texture3d<int, read>
srcTexture2dArray
texture2d_array<int, read>
srcTexture2d
texture2d<int, read>
reverseTextureRowOrder
bool
textureLayer
textureLevel
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint2
options
WritePixelParams
gIndices
ushort2
writeFromIntTextureToBuffer
ENDT8
RBUF(
AIRR
kCopyTextureType
kCopyFormatType
buffer
uchar
srcTexture2dMS
texture2d_ms<uint, read>
srcTextureCube
texturecube<uint, read>
srcTexture3d
texture3d<uint, read>
srcTexture2dArray
texture2d_array<uint, read>
srcTexture2d
texture2d<uint, read>
reverseTextureRowOrder
bool
textureLayer
textureLevel
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint2
options
WritePixelParams
gIndices
ushort2
writeFromUIntTextureToBuffer
ENDT
RBUFp
AIRR
kCopyFormatType
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
convertToFloatVertexFormatCS
ENDT 
RBUF
AIRR
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
expandVertexFormatComponentsCS
ENDTP
RBUF@
AIRR
kCombineWithExistingResult
bool
finalResults
renderpassVisibilityResult
ushort4
numOffsets
startOffset
options
CombineVisibilityResultOptions
uint
combineVisibilityResult
ENDTL
RBUF<
AIRR
fixIndexBufferKey
prim
primCount
indexCount
outIndexBufferUint32
outIndexBufferUint16
indexBufferUint32
uint
indexBufferUint16
ushort
fixIndexBuffer
ENDT 
RBUF
AIRR
fixIndexBufferKey
prim
firstVertex
primCount
indexCount
outIndexBufferUint32
uint
outIndexBufferUint16
ushort
genIndexBuffer
ENDT
RBUF
AIRR
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
uint
texCoords
float2
user(locn1)
position
float4
blitVS
ENDT$
RBUF
AIRR
clearDepth
float
clearColor
clearParams
ClearParams
uint
float4
clearVS
ENDT
RBUFx
AIRR
kCopyFormatType
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
convertToFloatVertexFormatVS
ENDT 
RBUF
AIRR
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
expandVertexFormatComponentsVS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<float, sample>
srcTextureCube
texturecube<float, sample>
srcTexture2dMS
texture2d_ms<float, read>
srcTexture2dArray
texture2d_array<float, sample>
srcTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
color7
color6
color5
color4
color3
color2
color1
color0
float4
blitFloatFS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<int, sample>
srcTextureCube
texturecube<int, sample>
srcTexture2dMS
texture2d_ms<int, read>
srcTexture2dArray
texture2d_array<int, sample>
srcTexture2d
texture2d<int, sample>
texCoords
float2
user(locn1)
position
float4
color7
color6
color5
color4
color3
color2
color1
color0
int4
blitIntFS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<uint, sample>
srcTextureCube
texturecube<uint, sample>
srcTexture2dMS
texture2d_ms<uint, read>
srcTexture2dArray
texture2d_array<uint, sample>
srcTexture2d
texture2d<uint, sample>
texCoords
float2
user(locn1)
position
float4
color7
color6
color5
color4
color3
color2
color1
color0
uint4
blitUIntFS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<float, sample>
srcTextureCube
texturecube<float, sample>
srcTexture2dMS
texture2d_ms<float, read>
srcTexture2dArray
texture2d_array<float, sample>
srcTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
float4
color7
color6
color5
color4
color3
color2
color1
color0
uint4
copyTextureFloatToUIntFS
ENDT
RBUF
AIRR
kSourceTextureType
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
srcTextureCube
texturecube<float, sample>
srcTexture2dMS
texture2d_ms<float, read>
srcTexture2dArray
texture2d_array<float, sample>
srcTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
float4
depth
float
blitDepthFS
ENDT
RBUF
AIRR
kSourceTexture2Type
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
srcTextureCube
texturecube<uint, sample>
srcTexture2dMS
texture2d_ms<uint, read>
srcTexture2dArray
texture2d_array<uint, sample>
srcTexture2d
texture2d<uint, sample>
texCoords
float2
user(locn1)
position
float4
stencil
uint
blitStencilFS
ENDT
RBUF
AIRR
kSourceTexture2Type
kSourceTextureType
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
srcStencilTextureCube
texturecube<uint, sample>
srcStencilTexture2dMS
texture2d_ms<uint, read>
srcStencilTexture2dArray
texture2d_array<uint, sample>
srcStencilTexture2d
texture2d<uint, sample>
srcDepthTextureCube
texturecube<float, sample>
srcDepthTexture2dMS
texture2d_ms<float, read>
srcDepthTexture2dArray
texture2d_array<float, sample>
srcDepthTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
float4
stencil
uint
depth
float
blitDepthStencilFS
ENDT
RBUF
AIRR
kNumColorOutputs
uint
clearDepth
float
clearColor
clearParams
ClearParams
color7
color6
color5
color4
color3
color2
color1
color0
float4
clearFloatFS
ENDT
RBUF
AIRR
kNumColorOutputs
uint
clearDepth
float
clearColor
float4
clearParams
ClearParams
color7
color6
color5
color4
color3
color2
color1
color0
int4
clearIntFS
ENDT
RBUF
AIRR
kNumColorOutputs
uint
clearDepth
float
clearColor
float4
clearParams
ClearParams
color7
color6
color5
color4
color3
color2
color1
color0
uint4
clearUIntFS
ENDT
"&*+."
Y!Y#Y&Y'Y;Y
EAEQEUEWEqEQNUNWNaNqN
F&F(F*F
acbBufferOffsets
depthRange
renderArea
flipXY
dither
misc
xfbBufferOffsets
xfbVerticesPerInstance
xfbBufferOffsets
xfbVerticesPerInstance
coverageMask
unused
 __unassigned_attribute__
#version 300 es
precision highp float;
#define kMaxTexUnits 4
#define kMaxLights   8
#define kTexUnits 
in vec4 pos;
in vec3 normal;
in mediump vec4 color;
in float pointsize;
#if kTexUnits >= 1
in mediump vec4 texcoord0;
#endif
#if kTexUnits >= 2
in mediump vec4 texcoord1;
#endif
#if kTexUnits >= 3
in mediump vec4 texcoord2;
#endif
#if kTexUnits >= 4
in mediump vec4 texcoord3;
#endif
uniform mat4 projection;
uniform mat4 modelview;
uniform mat4 modelview_invtr;
uniform mat4 texture_matrix[kMaxTexUnits];
// Point rasterization//////////////////////////////////////////////////////////
uniform float point_size_min;
uniform float point_size_max;
uniform vec3 point_distance_attenuation;
// Shading: flat shading, lighting, and materials///////////////////////////////
uniform mediump vec4 material_ambient;
uniform mediump vec4 material_diffuse;
uniform mediump vec4 material_specular;
uniform mediump vec4 material_emissive;
uniform float material_specular_exponent;
uniform mediump vec4 light_model_scene_ambient;
uniform mediump vec4 light_ambients[kMaxLights];
uniform mediump vec4 light_diffuses[kMaxLights];
uniform mediump vec4 light_speculars[kMaxLights];
uniform vec4 light_positions[kMaxLights];
uniform vec3 light_directions[kMaxLights];
uniform float light_spotlight_exponents[kMaxLights];
uniform float light_spotlight_cutoff_angles[kMaxLights];
uniform float light_attenuation_consts[kMaxLights];
uniform float light_attenuation_linears[kMaxLights];
uniform float light_attenuation_quadratics[kMaxLights];
// GL_OES_draw_texture uniforms/////////////////////////////////////////////////
uniform vec4 draw_texture_coords;
uniform vec2 draw_texture_dims;
uniform mediump vec4 draw_texture_normalized_crop_rect[kMaxTexUnits];
// Varyings/////////////////////////////////////////////////////////////////////
out vec4 pos_varying;
out vec3 normal_varying;
out mediump vec4 color_varying;
flat out mediump vec4 color_varying_flat;
#if kTexUnits >= 1
out mediump vec3 texcoord0_varying;
#endif
#if kTexUnits >= 2
out mediump vec3 texcoord1_varying;
#endif
#if kTexUnits >= 3
out mediump vec3 texcoord2_varying;
#endif
#if kTexUnits >= 4
out mediump vec3 texcoord3_varying;
#endif
float posDot(vec3 a, vec3 b)
    return max(dot(a, b), 0.0);
mediump vec4 doLighting(mediump vec4 vertexColor)
    mediump vec4 materialAmbientActual = material_ambient;
    mediump vec4 materialDiffuseActual = material_diffuse;
    if (enable_color_material)
    {
        materialAmbientActual = vertexColor;
        materialDiffuseActual = vertexColor;
    }
    mediump vec4 lightingResult = material_emissive + materialAmbientActual * light_model_scene_ambient;
    for (int i = 0; i < kMaxLights; i++)
    {
        if (!light_enables[i])
            continue;
        mediump vec4 lightAmbient  = light_ambients[i];
        mediump vec4 lightDiffuse  = light_diffuses[i];
        mediump vec4 lightSpecular = light_speculars[i];
        vec4 lightPos      = light_positions[i];
        vec3 lightDir      = light_directions[i];
        float attConst     = light_attenuation_consts[i];
        float attLinear    = light_attenuation_linears[i];
        float attQuadratic = light_attenuation_quadratics[i];
        float spotAngle    = light_spotlight_cutoff_angles[i];
        float spotExponent = light_spotlight_exponents[i];
        vec3 toLight;
        if (lightPos.w == 0.0)
        {
            toLight = lightPos.xyz;
        }
        else
        {
            toLight = (lightPos.xyz / lightPos.w - pos_varying.xyz);
        }
        float lightDist = length(toLight);
        vec3 toLightNormalized = normalize(toLight);
        vec3 h                 = toLightNormalized + vec3(0.0, 0.0, 1.0);
        float ndotL            = posDot(normal_varying, toLightNormalized);
        float ndoth            = posDot(normal_varying, normalize(h));
        float specAtt;
        if (ndotL != 0.0)
        {
            specAtt = 1.0;
        }
        else
        {
            specAtt = 0.0;
        }
        float att;
        if (lightPos.w != 0.0)
        {
            float attDenom =
                (attConst + attLinear * lightDist + attQuadratic * lightDist * lightDist);
            att = 1.0 / attDenom;
        }
        else
        {
            att = 1.0;
        }
        mediump float spot;
        mediump float spotAngleCos = cos(radians(spotAngle));
        vec3 toSurfaceDir  = -toLightNormalized;
        mediump float spotDot      = posDot(toSurfaceDir, normalize(lightDir));
        if (spotAngle == 180.0 || lightPos.w == 0.0)
        {
            spot = 1.0;
        }
        else
        {
            if (spotDot < spotAngleCos)
            {
                spot = 0.0;
            }
            else
            {
                spot = pow(spotDot, spotExponent);
            }
        }
        mediump vec4 contrib = materialAmbientActual * lightAmbient;
        contrib += ndotL * materialDiffuseActual * lightDiffuse;
        if (ndoth > 0.0 && material_specular_exponent > 0.0)
        {
            contrib += specAtt * pow(ndoth, material_specular_exponent) * material_specular *
                       lightSpecular;
        }
        else
        {
            if (ndoth > 0.0)
            {
                contrib += specAtt * material_specular * lightSpecular;
            }
        }
        contrib *= att * spot;
        lightingResult += contrib;
    }
    return lightingResult;
const mediump vec4 drawTextureVertices[6] = vec4[](
    vec4(0.0, 0.0, 0.0, 1.0),
    vec4(1.0, 0.0, 0.0, 1.0),
    vec4(1.0, 1.0, 0.0, 1.0),
    vec4(0.0, 0.0, 0.0, 1.0),
    vec4(1.0, 1.0, 0.0, 1.0),
    vec4(0.0, 1.0, 0.0, 1.0));
mediump vec4 drawTexturePosition(int vertexId)
    // The texture is drawn in the XY plane, so Z is constant.
    vec2 positionXY = draw_texture_coords.xy + drawTextureVertices[vertexId].xy * draw_texture_dims;
    return vec4(positionXY, draw_texture_coords.z, 1.0);
mediump vec3 drawTextureTexCoord(int vertexId, int textureUnit)
    // The texture is drawn in the XY plane, so Z is 0.
    mediump vec2 texCropPos = draw_texture_normalized_crop_rect[textureUnit].xy;
    mediump vec2 texCropDim = draw_texture_normalized_crop_rect[textureUnit].zw;
    mediump vec2 texCoords  = texCropPos + drawTextureVertices[vertexId].xy * texCropDim;
    return vec3(texCoords, 0.0);
vec4 calcWorldPosition(vec4 posInput)
    return modelview * posInput;
vec4 calcNdcFromWorldPosition(vec4 worldPos)
    return projection * worldPos;
float calcPointSize(vec4 ndcPos)
    float dist         = length(ndcPos.z);
    float attConst     = point_distance_attenuation[0];
    float attLinear    = point_distance_attenuation[1];
    float attQuad      = point_distance_attenuation[2];
    float attPart      = attConst + attLinear * dist + attQuad * dist * dist;
    float attPointSize = pointsize / pow(attPart, 0.5);
    return clamp(attPointSize, point_size_min, point_size_max);
vec3 calcNormal(vec3 normalInput)
    mat3 mvInvTr3 = mat3(modelview_invtr);
    vec3 result   = mvInvTr3 * normalInput;
    if (enable_rescale_normal)
    {
        float rescale   = 1.0;
        vec3 rescaleVec = vec3(mvInvTr3[2]);
        float len       = length(rescaleVec);
        if (len > 0.0)
        {
            rescale = 1.0 / len;
        }
        result *= rescale;
    }
    if (enable_normalize)
    {
        result = normalize(result);
    }
    return result;
void main()
    if (enable_draw_texture)
    {
        int vertexId        = gl_VertexID;
        mediump vec4 posDrawTexture = drawTexturePosition(vertexId);
        gl_Position = posDrawTexture;
        pos_varying = posDrawTexture;
        normal_varying = normal;
        gl_PointSize = pointsize;
#if kTexUnits >= 1
        texcoord0_varying = drawTextureTexCoord(vertexId, 0);
#endif
#if kTexUnits >= 2
        texcoord1_varying = drawTextureTexCoord(vertexId, 1);
#endif
#if kTexUnits >= 3
        texcoord2_varying = drawTextureTexCoord(vertexId, 2);
#endif
#if kTexUnits >= 4
        texcoord3_varying = drawTextureTexCoord(vertexId, 3);
#endif
    }
    else
    {
        vec4 worldPos = calcWorldPosition(pos);
        vec4 ndcPos   = calcNdcFromWorldPosition(worldPos);
        gl_Position = ndcPos;
        pos_varying = worldPos;
        normal_varying = calcNormal(normal);
        // Avoid calculating point size stuff
        // if we are not rendering points.
        if (point_rasterization)
        {
            gl_PointSize = calcPointSize(ndcPos);
        }
        else
        {
            gl_PointSize = pointsize;
        }
#if kTexUnits >= 1
        texcoord0_varying = (texture_matrix[0] * texcoord0).xyz;
#endif
#if kTexUnits >= 2
        texcoord1_varying = (texture_matrix[1] * texcoord1).xyz;
#endif
#if kTexUnits >= 3
        texcoord2_varying = (texture_matrix[2] * texcoord2).xyz;
#endif
#if kTexUnits >= 4
        texcoord3_varying = (texture_matrix[3] * texcoord3).xyz;
#endif
    }
    mediump vec4 vertex_color = color;
    if (enable_lighting)
    {
        vertex_color = doLighting(color);
    }
    vertex_color = clamp(vertex_color, vec4(0), vec4(1));
    color_varying      = vertex_color;
    color_varying_flat = vertex_color;
#version 300 es
precision highp float;
// Defines for GL constants
#define kMaxTexUnits                         4
#define kMaxClipPlanes                       6
#define kModulate                       0x2100
#define kDecal                          0x2101
#define kCombine                        0x8570
#define kReplace                        0x1E01
#define kBlend                          0x0BE2
#define kAdd                            0x0104
#define kAddSigned                      0x8574
#define kInterpolate                    0x8575
#define kSubtract                       0x84E7
#define kDot3Rgb                        0x86AE
#define kDot3Rgba                       0x86AF
#define kAlpha                          0x1906
#define kRGB                            0x1907
#define kRGBA                           0x1908
#define kLuminance                      0x1909
#define kLuminanceAlpha                 0x190A
#define kTexture                        0x1702
#define kConstant                       0x8576
#define kPrimaryColor                   0x8577
#define kPrevious                       0x8578
#define kSrcColor                       0x0300
#define kOneMinusSrcColor               0x0301
#define kSrcAlpha                       0x0302
#define kOneMinusSrcAlpha               0x0303
#define kLinear                         0x2601
#define kExp                            0x0800
#define kExp2                           0x0801
#define kNever                          0x0200
#define kLess                           0x0201
#define kEqual                          0x0202
#define kLequal                         0x0203
#define kGreater                        0x0204
#define kNotequal                       0x0205
#define kGequal                         0x0206
#define kAlways                         0x0207
#define kZero                              0x0
#define kOne                               0x1
#define kAnd                            0u
#define kAndInverted                    1u
#define kAndReverse                     2u
#define kClear                          3u
#define kCopy                           4u
#define kCopyInverted                   5u
#define kEquiv                          6u
#define kInvert                         7u
#define kNand                           8u
#define kNoop                           9u
#define kNor                            10u
#define kOr                             11u
#define kOrInverted                     12u
#define kOrReverse                      13u
#define kSet                            14u
#define kXor                            15u
// Texture units ///////////////////////////////////////////////////////////////
// These are not arrays because hw support for arrays
// of samplers is rather lacking.
uniform mediump sampler2D tex_sampler0;
uniform mediump samplerCube tex_cube_sampler0;
uniform mediump sampler2D tex_sampler1;
uniform mediump samplerCube tex_cube_sampler1;
uniform mediump sampler2D tex_sampler2;
uniform mediump samplerCube tex_cube_sampler2;
uniform mediump sampler2D tex_sampler3;
uniform mediump samplerCube tex_cube_sampler3;
uniform mediump vec4 texture_env_color[kMaxTexUnits];
uniform mediump float texture_env_rgb_scale[kMaxTexUnits];
uniform mediump float texture_env_alpha_scale[kMaxTexUnits];
// Vertex attributes////////////////////////////////////////////////////////////
in vec4 pos_varying;
in vec3 normal_varying;
in mediump vec4 color_varying;
flat in mediump vec4 color_varying_flat;
#if kTexUnits >= 1
in mediump vec3 texcoord0_varying;
#endif
#if kTexUnits >= 2
in mediump vec3 texcoord1_varying;
#endif
#if kTexUnits >= 3
in mediump vec3 texcoord2_varying;
#endif
#if kTexUnits >= 4
in mediump vec3 texcoord3_varying;
#endif
// Alpha test///////////////////////////////////////////////////////////////////
uniform mediump float alpha_test_ref;
// Fog /////////////////////////////////////////////////////////////////////////
uniform float fog_density;
uniform float fog_start;
uniform float fog_end;
uniform mediump vec4 fog_color;
// User clip plane /////////////////////////////////////////////////////////////
uniform vec4 clip_planes[kMaxClipPlanes];
// Logic Op ////////////////////////////////////////////////////////////////////
// Format is:
// - 4x4 bits depicting the bit width of each channel of color output
// - 4 bits for the op based on LogicalOperation's packing
uniform highp uint logic_op;
// Point rasterization//////////////////////////////////////////////////////////
// GL_OES_draw_texture//////////////////////////////////////////////////////////
inout mediump vec4 frag_color;
layout(noncoherent) inout mediump vec4 frag_color;
mediump vec4 applyLogicOp(mediump vec4 currentFragment)
    mediump vec4 previousFragment = frag_color;
    mediump uvec4 channelWidths = uvec4(logic_op & 0xFu,
                                        logic_op >> 4u & 0xFu,
                                        logic_op >> 8u & 0xFu,
                                        logic_op >> 12u & 0xFu);
    mediump uvec4 channelMasks = (uvec4(1) << channelWidths) - 1u;
    mediump uvec4 src = uvec4(round(currentFragment * vec4(channelMasks)));
    mediump uvec4 dst = uvec4(round(previousFragment * vec4(channelMasks)));
    mediump uvec4 result;
    switch (logic_op >> 16u & 0xFu)
    {
        case kAnd:
            result = src & dst;
            break;
        case kAndInverted:
            result = ~src & dst;
            break;
        case kAndReverse:
            result = src & ~dst;
            break;
        case kClear:
            result = uvec4(0);
            break;
        case kCopy:
            result = src;
            break;
        case kCopyInverted:
            result = ~src;
            break;
        case kEquiv:
            result = ~(src ^ dst);
            break;
        case kInvert:
            result = ~dst;
            break;
        case kNand:
            result = ~(src & dst);
            break;
        case kNoop:
            result = dst;
            break;
        case kNor:
            result = ~(src | dst);
            break;
        case kOr:
            result = src | dst;
            break;
        case kOrInverted:
            result = ~src | dst;
            break;
        case kOrReverse:
            result = src | ~dst;
            break;
        case kSet:
            result = channelMasks;
            break;
        case kXor:
            result = src ^ dst;
            break;
    }
    result &= channelMasks;
    // Avoid division by zero for formats without alpha
    channelMasks.a = max(channelMasks.a, 1u);
    return vec4(result) / vec4(channelMasks);
out mediump vec4 frag_color;
mediump vec4 applyLogicOp(mediump vec4 currentFragment)
    return currentFragment;
bool doAlphaTest(mediump vec4 currentFragment)
    bool shouldPassAlpha   = false;
    mediump float incAlpha = currentFragment.a;
    switch (alpha_func)
    {
        case kNever:
            shouldPassAlpha = false;
            break;
        case kLess:
            shouldPassAlpha = incAlpha < alpha_test_ref;
            break;
        case kLequal:
            shouldPassAlpha = incAlpha <= alpha_test_ref;
            break;
        case kEqual:
            shouldPassAlpha = incAlpha == alpha_test_ref;
            break;
        case kGequal:
            shouldPassAlpha = incAlpha >= alpha_test_ref;
            break;
        case kGreater:
            shouldPassAlpha = incAlpha > alpha_test_ref;
            break;
        case kNotequal:
            shouldPassAlpha = incAlpha != alpha_test_ref;
            break;
        case kAlways:
        default:
            shouldPassAlpha = true;
            break;
    }
    return shouldPassAlpha;
bool doClipPlaneTest()
    bool res = true;
    for (int i = 0; i < kMaxClipPlanes; i++)
    {
        if (clip_plane_enables[i])
        {
            float dist = dot(clip_planes[i].xyz, pos_varying.xyz) + clip_planes[i].w * pos_varying.w;
            res        = res && (dist >= 0.0);
        }
    }
    return res;
mediump vec4 doFog(mediump vec4 currentFragment)
    float eyeDist = -pos_varying.z / pos_varying.w;
    float f       = 1.0;
    switch (fog_mode)
    {
        case kExp:
            f = exp(-fog_density * eyeDist);
            break;
        case kExp2:
            f = exp(-(pow(fog_density * eyeDist, 2.0)));
            break;
        case kLinear:
            f = (fog_end - eyeDist) / (fog_end - fog_start);
            break;
        default:
            break;
    }
    f = clamp(f, 0.0, 1.0);
    mediump vec4 result = vec4(f * currentFragment.rgb + (1.0 - f) * fog_color.rgb, currentFragment.a);
    return result;
bool isTextureUnitEnabled(int unit)
    return enable_texture_2d[unit] || enable_texture_cube_map[unit];
mediump vec4 getTextureColor(int unit)
    mediump vec4 res;
    switch (unit)
    {
#if kTexUnits >= 1
        case 0:
            if (enable_texture_2d[0])
            {
                res = texture(tex_sampler0, texcoord0_varying.xy);
            }
            else if (enable_texture_cube_map[0])
            {
                res = texture(tex_cube_sampler0, texcoord0_varying);
            }
            break;
#endif
#if kTexUnits >= 2
        case 1:
            if (enable_texture_2d[1])
            {
                res = texture(tex_sampler1, texcoord1_varying.xy);
            }
            else if (enable_texture_cube_map[1])
            {
                res = texture(tex_cube_sampler1, texcoord1_varying);
            }
            break;
#endif
#if kTexUnits >= 3
        case 2:
            if (enable_texture_2d[2])
            {
                res = texture(tex_sampler2, texcoord2_varying.xy);
            }
            else if (enable_texture_cube_map[2])
            {
                res = texture(tex_cube_sampler2, texcoord2_varying);
            }
            break;
#endif
#if kTexUnits >= 4
        case 3:
            if (enable_texture_2d[3])
            {
                res = texture(tex_sampler3, texcoord3_varying.xy);
            }
            else if (enable_texture_cube_map[3])
            {
                // TODO: Weird stuff happens
                // res = texture(tex_cube_sampler3, texcoord3_varying);
            }
            break;
#endif
        default:
            break;
    }
    return res;
mediump vec4 getPointSpriteTextureColor(int unit)
    mediump vec4 res;
    switch (unit)
    {
        case 0:
            if (enable_texture_2d[0])
            {
                res = texture(tex_sampler0, gl_PointCoord.xy);
            }
            break;
        case 1:
            if (enable_texture_2d[1])
            {
                res = texture(tex_sampler1, gl_PointCoord.xy);
            }
            break;
        case 2:
            if (enable_texture_2d[2])
            {
                res = texture(tex_sampler2, gl_PointCoord.xy);
            }
            break;
        case 3:
            if (enable_texture_2d[3])
            {
                res = texture(tex_sampler3, gl_PointCoord.xy);
            }
            break;
        default:
            break;
    }
    return res;
mediump vec3 textureCombineSrcnOpnRgb(int srcnRgb,
                                      int opnRgb,
                                      mediump vec4 textureEnvColor,
                                      mediump vec4 vertexColor,
                                      mediump vec4 texturePrevColor,
                                      mediump vec4 textureColor)
    mediump vec3 res;
    mediump vec4 op;
    switch (srcnRgb)
    {
        case kTexture:
            op = textureColor;
            break;
        case kConstant:
            op = textureEnvColor;
            break;
        case kPrimaryColor:
            op = vertexColor;
            break;
        case kPrevious:
            op = texturePrevColor;
            break;
        default:
            op = texturePrevColor;
            break;
    }
    switch (opnRgb)
    {
        case kSrcColor:
            res = op.rgb;
            break;
        case kOneMinusSrcColor:
            res = 1.0 - op.rgb;
            break;
        case kSrcAlpha:
            res = vec3(op.a, op.a, op.a);
            break;
        case kOneMinusSrcAlpha:
            res = vec3(1.0 - op.a, 1.0 - op.a, 1.0 - op.a);
            break;
        default:
            break;
    }
    return res;
mediump float textureCombineSrcnOpnAlpha(int srcn,
                                         int opn,
                                         mediump vec4 textureEnvColor,
                                         mediump vec4 vertexColor,
                                         mediump vec4 texturePrevColor,
                                         mediump vec4 textureColor)
    mediump float res;
    mediump vec4 op;
    switch (srcn)
    {
        case kTexture:
            op = textureColor;
            break;
        case kConstant:
            op = textureEnvColor;
            break;
        case kPrimaryColor:
            op = vertexColor;
            break;
        case kPrevious:
            op = texturePrevColor;
            break;
        default:
            op = texturePrevColor;
            break;
    }
    switch (opn)
    {
        case kSrcAlpha:
            res = op.a;
            break;
        case kOneMinusSrcAlpha:
            res = 1.0 - op.a;
            break;
        default:
            break;
    }
    return res;
mediump vec4 textureCombine(int combineRgb,
                            int combineAlpha,
                            int src0Rgb,
                            int src0Alpha,
                            int src1Rgb,
                            int src1Alpha,
                            int src2Rgb,
                            int src2Alpha,
                            int op0Rgb,
                            int op0Alpha,
                            int op1Rgb,
                            int op1Alpha,
                            int op2Rgb,
                            int op2Alpha,
                            mediump vec4 textureEnvColor,
                            mediump float rgbScale,
                            mediump float alphaScale,
                            mediump vec4 vertexColor,
                            mediump vec4 texturePrevColor,
                            mediump vec4 textureColor)
    mediump vec3 resRgb;
    mediump float resAlpha;
    mediump vec3 arg0Rgb;
    mediump float arg0Alpha;
    mediump vec3 arg1Rgb;
    mediump float arg1Alpha;
    mediump vec3 arg2Rgb;
    mediump float arg2Alpha;
    mediump float dotVal;
    arg0Rgb   = textureCombineSrcnOpnRgb(src0Rgb, op0Rgb, textureEnvColor, vertexColor,
                                       texturePrevColor, textureColor);
    arg0Alpha = textureCombineSrcnOpnAlpha(src0Alpha, op0Alpha, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    if (combineRgb != kReplace)
    {
        arg1Rgb = textureCombineSrcnOpnRgb(src1Rgb, op1Rgb, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    }
    if (combineAlpha != kReplace)
    {
        arg1Alpha = textureCombineSrcnOpnAlpha(src1Alpha, op1Alpha, textureEnvColor, vertexColor,
                                               texturePrevColor, textureColor);
    }
    if (combineRgb == kInterpolate)
    {
        arg2Rgb = textureCombineSrcnOpnRgb(src2Rgb, op2Rgb, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    }
    if (combineAlpha == kInterpolate)
    {
        arg2Alpha = textureCombineSrcnOpnAlpha(src2Alpha, op2Alpha, textureEnvColor, vertexColor,
                                               texturePrevColor, textureColor);
    }
    switch (combineRgb)
    {
        case kReplace:
            resRgb = arg0Rgb;
            break;
        case kModulate:
            resRgb = arg0Rgb * arg1Rgb;
            break;
        case kAdd:
            resRgb = arg0Rgb + arg1Rgb;
            break;
        case kAddSigned:
            resRgb = arg0Rgb + arg1Rgb - 0.5;
            break;
        case kInterpolate:
            resRgb = arg0Rgb * arg2Rgb + arg1Rgb * (1.0 - arg2Rgb);
            break;
        case kSubtract:
            resRgb = arg0Rgb - arg1Rgb;
            break;
        default:
            break;
    }
    switch (combineAlpha)
    {
        case kReplace:
            resAlpha = arg0Alpha;
            break;
        case kModulate:
            resAlpha = arg0Alpha * arg1Alpha;
            break;
        case kAdd:
            resAlpha = arg0Alpha + arg1Alpha;
            break;
        case kAddSigned:
            resAlpha = arg0Alpha + arg1Alpha - 0.5;
            break;
        case kInterpolate:
            resAlpha = arg0Alpha * arg2Alpha + arg1Alpha * (1.0 - arg2Alpha);
            break;
        case kSubtract:
            resAlpha = arg0Alpha - arg1Alpha;
            break;
        default:
            break;
    }
    if (combineRgb == kDot3Rgb || combineRgb == kDot3Rgba)
    {
        dotVal = 4.0 * dot(arg0Rgb - 0.5, arg1Rgb - 0.5);
        if (combineRgb == kDot3Rgb)
        {
            return vec4(dotVal, dotVal, dotVal, resAlpha);
        }
        else
        {
            return vec4(dotVal, dotVal, dotVal, dotVal);
        }
    }
    else
    {
        return vec4(resRgb, resAlpha);
    }
mediump vec4 textureFunction(int unit,
                             int texFormat,
                             int envMode,
                             int combineRgb,
                             int combineAlpha,
                             int src0Rgb,
                             int src0Alpha,
                             int src1Rgb,
                             int src1Alpha,
                             int src2Rgb,
                             int src2Alpha,
                             int op0Rgb,
                             int op0Alpha,
                             int op1Rgb,
                             int op1Alpha,
                             int op2Rgb,
                             int op2Alpha,
                             mediump vec4 textureEnvColor,
                             mediump float rgbScale,
                             mediump float alphaScale,
                             mediump vec4 vertexColor,
                             mediump vec4 texturePrevColor,
                             mediump vec4 textureColor)
    if (!isTextureUnitEnabled(unit))
    {
        return texturePrevColor;
    }
    mediump vec4 res;
    switch (envMode)
    {
        case kReplace:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a;
                    break;
                case kRGBA:
                case kLuminanceAlpha:
                    res.rgba = textureColor.rgba;
                    break;
                case kRGB:
                case kLuminance:
                default:
                    res.rgb = textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kModulate:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = texturePrevColor.a * textureColor.a;
                    break;
                case kRGBA:
                case kLuminanceAlpha:
                    res.rgba = texturePrevColor.rgba * textureColor.rgba;
                    break;
                case kRGB:
                case kLuminance:
                default:
                    res.rgb = texturePrevColor.rgb * textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kDecal:
            switch (texFormat)
            {
                case kRGB:
                    res.rgb = textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
                case kRGBA:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.a) +
                              textureColor.rgb * textureColor.a;
                    res.a = texturePrevColor.a;
                    break;
                case kAlpha:
                case kLuminance:
                case kLuminanceAlpha:
                default:
                    res.rgb = texturePrevColor.rgb * textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kBlend:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
                case kLuminance:
                case kRGB:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.rgb) +
                              textureEnvColor.rgb * textureColor.rgb;
                    res.a = texturePrevColor.a;
                    break;
                case kLuminanceAlpha:
                case kRGBA:
                default:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.rgb) +
                              textureEnvColor.rgb * textureColor.rgb;
                    res.a = textureColor.a * texturePrevColor.a;
                    break;
            }
            break;
        case kAdd:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
                case kLuminance:
                case kRGB:
                    res.rgb = texturePrevColor.rgb + textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
                case kLuminanceAlpha:
                case kRGBA:
                default:
                    res.rgb = texturePrevColor.rgb + textureColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
            }
            break;
        case kCombine:
            res = textureCombine(combineRgb, combineAlpha, src0Rgb, src0Alpha, src1Rgb, src1Alpha,
                                 src2Rgb, src2Alpha, op0Rgb, op0Alpha, op1Rgb, op1Alpha, op2Rgb,
                                 op2Alpha, textureEnvColor, rgbScale, alphaScale, vertexColor,
                                 texturePrevColor, textureColor);
            res.rgb *= rgbScale;
            res.a *= alphaScale;
            break;
        default:
            break;
    }
    return clamp(res, 0.0, 1.0);
void main()
    if (enable_clip_planes && !enable_draw_texture)
    {
        if (!doClipPlaneTest())
        {
            discard;
        }
    }
    mediump vec4 vertex_color;
    if (shade_model_flat)
    {
        vertex_color = color_varying_flat;
    }
    else
    {
        vertex_color = color_varying;
    }
    mediump vec4 currentFragment = vertex_color;
    mediump vec4 texturePrevColor = currentFragment;
    for (int i = 0; i < kTexUnits; i++)
    {
        mediump vec4 textureColor;
        if (point_rasterization && point_sprite_enabled &&
            point_sprite_coord_replace[i]) {
            textureColor = getPointSpriteTextureColor(i);
        } else {
            textureColor = getTextureColor(i);
        }
        currentFragment = textureFunction(
            i, texture_format[i], texture_env_mode[i], combine_rgb[i], combine_alpha[i],
            src0_rgb[i], src0_alpha[i], src1_rgb[i], src1_alpha[i], src2_rgb[i], src2_alpha[i],
            op0_rgb[i], op0_alpha[i], op1_rgb[i], op1_alpha[i], op2_rgb[i], op2_alpha[i],
            texture_env_color[i], texture_env_rgb_scale[i], texture_env_alpha_scale[i],
            vertex_color, texturePrevColor, textureColor);
        texturePrevColor = currentFragment;
    }
    if (enable_fog)
    {
        currentFragment = doFog(currentFragment);
    }
    if (enable_alpha_test && !doAlphaTest(currentFragment))
    {
        discard;
    }
    frag_color = applyLogicOp(currentFragment);
 !"#$%&&&&'()*&&+,-./012&3
789:;<=>?&@ABCDE&FGHIJKLMNOPQR
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
ANGLE
Ga==
.M;vT
.eB5
@@XFB-Bindings@@ANGLE_@@XFB-OUT@@
 __unassigned_attribute__
angleUniforms
ANGLE_METAL_PRINT_MSL_ENABLE
ANGLE_MSL_VERSION_MAJOR
ANGLE_MSL_VERSION_MINOR
ANGLE
                    
 !%&'()*+,-./01234
ColorEXT
ndaryFragDataEXT
@\ A
`@10B
ANGLEUniformBlock
ANGLEUniforms
ANGLEAtomicCounters
10Dx4
cast
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/common/android_util.cpp
GLInternalFormatToNativePixelFormat
Unknown internalFormat: 
. Treating as 0
2.1.20348 git hash: e5671e16b83f
35c6f5eb4d05c0f68ff77d74edf80ecb
ASTC CPU decomp not available
as_type
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/BlitGL.cpp
copyImageToLUMAWorkaroundTexture
mFunctions->texImage2D(ToGLenum(target), static_cast<GLint>(level), internalFormat, sourceArea.width, sourceArea.height, 0, format, readType, nullptr)
copySubImageToLUMAWorkaroundTexture
mFunctions->copyTexImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, sourceArea.x, sourceArea.y, sourceArea.width, sourceArea.height, 0)
mFunctions->texImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), readType, nullptr)
blitColorBufferWithShader
mFunctions->copyTexImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, inBoundsSource.x, inBoundsSource.y, inBoundsSource.width, inBoundsSource.height, 0)
copySubTextureCPUReadback
mFunctions->texImage2D(ToGLenum(scratchTextureType), 0, texImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
Failed to allocate host memory
generateSRGBMipmap
mFunctions->generateMipmap(ToGLenum(sourceTarget))
a_texcoord
attribute
varying
texture2D
texture
#version 
 vec2 
uniform vec2 u_scale;
uniform vec2 u_offset;
 vec2 v_texcoord;
void main()
    gl_Position = vec4((
 * 2.0) - 1.0, 0.0, 1.0);
    v_texcoord = 
 * u_scale + u_offset;
sampler2D
samplerExternalOES
sampler2DRect
uvec4
#extension GL_OES_EGL_image_external : require
GL_ARB_texture_rectangle
#extension GL_ARB_texture_rectangle : require
gl_FragColor
precision highp float;
 u_source_texture;
uniform bool u_multiply_alpha;
uniform bool u_unmultiply_alpha;
vec2(textureSize(u_source_texture))
    if (clamp(v_texcoord, vec2(0.0), 
) != v_texcoord)
    {
        discard;
    }
    
 color = 
(u_source_texture, v_texcoord);
    if (u_multiply_alpha)
        color.xyz = color.xyz * color.a;
    if (u_unmultiply_alpha && color.a != 0.0)
         color.xyz = color.xyz / color.a;
    color = color * 
(color);
u_source_texture
u_scale
u_offset
u_multiply_alpha
u_unmultiply_alpha
Failed to compile internal blit shader.
CheckCompileStatus
Failed to link internal blit program.
CheckLinkStatus
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/BlobCache.cpp
CompressBlobCacheData
Failed to allocate memory for compression
Failed to compress cache data: 
DecompressBlobCacheData
Failed to allocate memory for decompression
Failed to decompress data: 
Failed to allocate memory for binary blob
Binary blob no longer available in cache (removed by a thread?)
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Buffer.cpp
bufferDataImpl
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/BufferGL.cpp
setData
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/BufferMtl.mm
setDataImpl
BufferMtl=%p(%lu)
setSubDataImpl
_emu
int abs_emu(int x) { return x * sign(x); }
bool isnan_emu(float x) { return (x > 0.0 || x < 0.0) ? false : x != 0.0; }
bvec2 isnan_emu(vec2 x)
    bvec2 isnan;
    for (int i = 0; i < 2; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bvec3 isnan_emu(vec3 x)
    bvec3 isnan;
    for (int i = 0; i < 3; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bvec4 isnan_emu(vec4 x)
    bvec4 isnan;
    for (int i = 0; i < 4; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
emu_precision float atan_emu(emu_precision float y, emu_precision float x)
    if (x > 0.0) return atan(y / x);
    else if (x < 0.0 && y >= 0.0) return atan(y / x) + 3.14159265;
    else if (x < 0.0 && y < 0.0) return atan(y / x) - 3.14159265;
    else return 1.57079632 * sign(y);
emu_precision vec
 atan_emu(emu_precision vec
 y, emu_precision vec
    return vec
atan_emu(y[
], x[
uint packUnorm2x16_emu(vec2 v)
    int x = int(round(clamp(v.x, 0.0, 1.0) * 65535.0));
    int y = int(round(clamp(v.y, 0.0, 1.0) * 65535.0));
    return uint((y << 16) | (x & 0xFFFF));
vec2 unpackUnorm2x16_emu(uint u)
    float x = float(u & 0xFFFFu) / 65535.0;
    float y = float(u >> 16) / 65535.0;
    return vec2(x, y);
uint packSnorm2x16_emu(vec2 v)
    #if defined(GL_ARB_shading_language_packing)
        return packSnorm2x16(v);
    #else
        int x = int(round(clamp(v.x, -1.0, 1.0) * 32767.0));
        int y = int(round(clamp(v.y, -1.0, 1.0) * 32767.0));
        return uint((y << 16) | (x & 0xFFFF));
    #endif
#if !defined(GL_ARB_shading_language_packing)
    float fromSnorm(uint x)
    {
        int xi = (int(x) & 0x7FFF) - (int(x) & 0x8000);
        return clamp(float(xi) / 32767.0, -1.0, 1.0);
    }
#endif
vec2 unpackSnorm2x16_emu(uint u)
    #if defined(GL_ARB_shading_language_packing)
        return unpackSnorm2x16(u);
    #else
        uint y = (u >> 16);
        uint x = u;
        return vec2(fromSnorm(x), fromSnorm(y));
    #endif
#if !defined(GL_ARB_shading_language_packing)
    uint f32tof16(float val)
    {
        uint f32 = floatBitsToUint(val);
        uint f16 = 0u;
        uint sign = (f32 >> 16) & 0x8000u;
        int exponent = int((f32 >> 23) & 0xFFu) - 127;
        uint mantissa = f32 & 0x007FFFFFu;
        if (exponent == 128)
        {
            // Infinity or NaN
            // NaN bits that are masked out by 0x3FF get discarded.
            // This can turn some NaNs to infinity, but this is allowed by the spec.
            f16 = sign | (0x1Fu << 10);
            f16 |= (mantissa & 0x3FFu);
        }
        else if (exponent > 15)
        {
            // Overflow - flush to Infinity
            f16 = sign | (0x1Fu << 10);
        }
        else if (exponent > -15)
        {
            // Representable value
            exponent += 15;
            mantissa >>= 13;
            f16 = sign | uint(exponent << 10) | mantissa;
        }
        else
        {
            f16 = sign;
        }
        return f16;
    }
#endif
uint packHalf2x16_emu(vec2 v)
    #if defined(GL_ARB_shading_language_packing)
        return packHalf2x16(v);
    #else
        uint x = f32tof16(v.x);
        uint y = f32tof16(v.y);
        return (y << 16) | x;
    #endif
#if !defined(GL_ARB_shading_language_packing)
    float f16tof32(uint val)
    {
        uint sign = (val & 0x8000u) << 16;
        int exponent = int((val & 0x7C00u) >> 10);
        uint mantissa = val & 0x03FFu;
        float f32 = 0.0;
        if(exponent == 0)
        {
            if (mantissa != 0u)
            {
                const float scale = 1.0 / (1 << 24);
                f32 = scale * mantissa;
            }
        }
        else if (exponent == 31)
        {
            return uintBitsToFloat(sign | 0x7F800000u | mantissa);
        }
        else
        {
            exponent -= 15;
            float scale;
            if(exponent < 0)
            {
                // The negative unary operator is buggy on OSX.
                // Work around this by using abs instead.
                scale = 1.0 / (1 << abs(exponent));
            }
            else
            {
                scale = 1 << exponent;
            }
            float decimal = 1.0 + float(mantissa) / float(1 << 10);
            f32 = scale * decimal;
        }
        if (sign != 0u)
        {
            f32 = -f32;
        }
        return f32;
    }
#endif
vec2 unpackHalf2x16_emu(uint u)
    #if defined(GL_ARB_shading_language_packing)
        return unpackHalf2x16(u);
    #else
        uint y = (u >> 16);
        uint x = u & 0xFFFFu;
        return vec2(f16tof32(x), f16tof32(y));
    #endif
Undefined function '
()' used in the following call chain:
Recursive function call in the following call chain:
 -> 
EGL_EXT_create_context_robustness
EGL_ANGLE_d3d_share_handle_client_buffer
EGL_ANGLE_d3d_texture_client_buffer
EGL_ANGLE_surface_d3d_texture_2d_share_handle
EGL_ANGLE_query_surface_pointer
EGL_ANGLE_window_fixed_size
EGL_ANGLE_keyed_mutex
EGL_ANGLE_surface_orientation
EGL_ANGLE_direct_composition
EGL_ANGLE_windows_ui_composition
EGL_NV_post_sub_buffer
EGL_KHR_create_context
EGL_KHR_image
EGL_KHR_image_base
EGL_KHR_image_pixmap
EGL_EXT_image_gl_colorspace
EGL_KHR_gl_colorspace
EGL_EXT_gl_colorspace_scrgb
EGL_EXT_gl_colorspace_scrgb_linear
EGL_EXT_gl_colorspace_display_p3
EGL_EXT_gl_colorspace_display_p3_linear
EGL_EXT_gl_colorspace_display_p3_passthrough
EGL_ANGLE_colorspace_attribute_passthrough
EGL_KHR_gl_texture_2D_image
EGL_KHR_gl_texture_cubemap_image
EGL_KHR_gl_texture_3D_image
EGL_KHR_gl_renderbuffer_image
EGL_KHR_get_all_proc_addresses
EGL_KHR_stream
EGL_KHR_stream_consumer_gltexture
EGL_NV_stream_consumer_gltexture_yuv
EGL_KHR_fence_sync
EGL_KHR_wait_sync
EGL_ANGLE_stream_producer_d3d_texture
EGL_ANGLE_create_context_webgl_compatibility
EGL_CHROMIUM_create_context_bind_generates_resource
EGL_CHROMIUM_sync_control
EGL_ANGLE_sync_control_rate
EGL_KHR_swap_buffers_with_damage
EGL_EXT_pixel_format_float
EGL_KHR_surfaceless_context
EGL_ANGLE_display_texture_share_group
EGL_ANGLE_display_semaphore_share_group
EGL_ANGLE_create_context_client_arrays
EGL_ANGLE_program_cache_control
EGL_ANGLE_robust_resource_initialization
EGL_ANGLE_iosurface_client_buffer
EGL_ANGLE_metal_texture_client_buffer
EGL_ANGLE_create_context_extensions_enabled
EGL_ANDROID_presentation_time
EGL_ANDROID_blob_cache
EGL_ANDROID_framebuffer_target
EGL_ANDROID_image_native_buffer
EGL_ANDROID_get_frame_timestamps
EGL_ANGLE_timestamp_surface_attribute
EGL_ANDROID_recordable
EGL_ANGLE_power_preference
EGL_ANGLE_wait_until_work_scheduled
EGL_ANGLE_image_d3d11_texture
EGL_ANDROID_create_native_client_buffer
EGL_ANDROID_get_native_client_buffer
EGL_ANDROID_native_fence_sync
EGL_ANGLE_create_context_backwards_compatible
EGL_KHR_no_config_context
EGL_IMG_context_priority
EGL_KHR_create_context_no_error
EGL_EXT_image_dma_buf_import
EGL_EXT_image_dma_buf_import_modifiers
EGL_NOK_texture_from_pixmap
EGL_NV_robustness_video_memory_purge
EGL_KHR_reusable_sync
EGL_ANGLE_external_context_and_surface
EGL_EXT_buffer_age
EGL_KHR_mutable_render_buffer
EGL_EXT_protected_content
EGL_ANGLE_create_surface_swap_interval
EGL_ANGLE_context_virtualization
EGL_KHR_lock_surface3
EGL_ANGLE_vulkan_image
EGL_ANGLE_metal_create_context_ownership_identity
EGL_KHR_partial_update
EGL_ANGLE_metal_shared_event_sync
EGL_ANGLE_device_d3d
EGL_ANGLE_device_cgl
EGL_ANGLE_device_eagl
EGL_ANGLE_device_metal
EGL_ANGLE_device_vulkan
EGL_EXT_device_drm
EGL_EXT_device_drm_render_node
EGL_EXT_client_extensions
EGL_EXT_device_query
EGL_EXT_platform_base
EGL_EXT_platform_device
EGL_KHR_platform_gbm
EGL_EXT_platform_wayland
EGL_ANGLE_platform_angle
EGL_ANGLE_platform_angle_d3d
EGL_ANGLE_platform_angle_d3d11on12
EGL_ANGLE_platform_angle_device_type_egl_angle
EGL_ANGLE_platform_angle_device_type_swiftshader
EGL_ANGLE_platform_angle_opengl
EGL_ANGLE_platform_angle_null
EGL_ANGLE_platform_angle_vulkan
EGL_ANGLE_platform_angle_metal
EGL_ANGLE_platform_device_context_volatile_eagl
EGL_ANGLE_platform_device_context_volatile_cgl
EGL_ANGLE_platform_angle_device_id
EGL_ANGLE_device_creation
EGL_ANGLE_device_creation_d3d11
EGL_ANGLE_x11_visual
EGL_ANGLE_experimental_present_path
EGL_KHR_client_get_all_proc_addresses
EGL_KHR_debug
EGL_ANGLE_feature_control
EGL_ANGLE_display_power_preference
gl_FragDepth
clamp
gl_PointSize
gl_DepthRange
near
diff
gl_NumSamples
gl_PerVertex
gl_in
unsupported shader version
Compute shader is not supported in this shader version.
Geometry shader is not supported in this shader version.
Tessellation shaders are not supported in this shader version.
internal compiler error translating pixel local storage
too many uniforms
gl_ClipDistance
gl_CullDistance
Shader parsing failed (mTreeRoot == nullptr)
Unsized global array type: 
angle_DrawID
gl_DrawID
angle_BaseVertex
gl_BaseVertex
angle_BaseInstance
gl_BaseInstance
:MaxVertexAttribs:
:MaxVertexUniformVectors:
:MaxVaryingVectors:
:MaxVertexTextureImageUnits:
:MaxCombinedTextureImageUnits:
:MaxTextureImageUnits:
:MaxFragmentUniformVectors:
:MaxDrawBuffers:
:OES_standard_derivatives:
:OES_EGL_image_external:
:OES_EGL_image_external_essl3:
:NV_EGL_stream_consumer_external:
:ARB_texture_rectangle:
:EXT_draw_buffers:
:FragmentPrecisionHigh:
:MaxExpressionComplexity:
:MaxCallStackDepth:
:MaxFunctionParameters:
:EXT_blend_func_extended:
:EXT_frag_depth:
:EXT_primitive_bounding_box:
:OES_primitive_bounding_box:
:EXT_separate_shader_objects:
:EXT_shader_texture_lod:
:EXT_shader_framebuffer_fetch:
:EXT_shader_framebuffer_fetch_non_coherent:
:NV_shader_framebuffer_fetch:
:ARM_shader_framebuffer_fetch:
:OVR_multiview2:
:OVR_multiview:
:EXT_YUV_target:
:EXT_geometry_shader:
:OES_geometry_shader:
:OES_shader_io_blocks:
:EXT_shader_io_blocks:
:EXT_gpu_shader5:
:OES_texture_3D:
:MaxVertexOutputVectors:
:MaxFragmentInputVectors:
:MinProgramTexelOffset:
:MaxProgramTexelOffset:
:MaxDualSourceDrawBuffers:
:MaxViewsOVR:
:NV_draw_buffers:
:ANGLE_multi_draw:
:ANGLE_base_vertex_base_instance_shader_builtin:
:APPLE_clip_distance:
:OES_texture_cube_map_array:
:EXT_texture_cube_map_array:
:EXT_shadow_samplers:
:OES_shader_multisample_interpolation:
:OES_shader_image_atomic:
:EXT_tessellation_shader:
:OES_texture_buffer:
:EXT_texture_buffer:
:OES_sample_variables:
:EXT_clip_cull_distance:
:ANGLE_clip_cull_distance:
:MinProgramTextureGatherOffset:
:MaxProgramTextureGatherOffset:
:MaxImageUnits:
:MaxSamples:
:MaxVertexImageUniforms:
:MaxFragmentImageUniforms:
:MaxComputeImageUniforms:
:MaxCombinedImageUniforms:
:MaxCombinedShaderOutputResources:
:MaxComputeWorkGroupCountX:
:MaxComputeWorkGroupCountY:
:MaxComputeWorkGroupCountZ:
:MaxComputeWorkGroupSizeX:
:MaxComputeWorkGroupSizeY:
:MaxComputeWorkGroupSizeZ:
:MaxComputeUniformComponents:
:MaxComputeTextureImageUnits:
:MaxComputeAtomicCounters:
:MaxComputeAtomicCounterBuffers:
:MaxVertexAtomicCounters:
:MaxFragmentAtomicCounters:
:MaxCombinedAtomicCounters:
:MaxAtomicCounterBindings:
:MaxVertexAtomicCounterBuffers:
:MaxFragmentAtomicCounterBuffers:
:MaxCombinedAtomicCounterBuffers:
:MaxAtomicCounterBufferSize:
:MaxGeometryUniformComponents:
:MaxGeometryUniformBlocks:
:MaxGeometryInputComponents:
:MaxGeometryOutputComponents:
:MaxGeometryOutputVertices:
:MaxGeometryTotalOutputComponents:
:MaxGeometryTextureImageUnits:
:MaxGeometryAtomicCounterBuffers:
:MaxGeometryAtomicCounters:
:MaxGeometryShaderStorageBlocks:
:MaxGeometryShaderInvocations:
:MaxGeometryImageUniforms:
:MaxClipDistances
:MaxCullDistances
:MaxCombinedClipAndCullDistances
:MaxTessControlInputComponents:
:MaxTessControlOutputComponents:
:MaxTessControlTextureImageUnits:
:MaxTessControlUniformComponents:
:MaxTessControlTotalOutputComponents:
:MaxTessControlImageUniforms:
:MaxTessControlAtomicCounters:
:MaxTessControlAtomicCounterBuffers:
:MaxTessPatchComponents:
:MaxPatchVertices:
:MaxTessGenLevel:
:MaxTessEvaluationInputComponents:
:MaxTessEvaluationOutputComponents:
:MaxTessEvaluationTextureImageUnits:
:MaxTessEvaluationUniformComponents:
:MaxTessEvaluationImageUniforms:
:MaxTessEvaluationAtomicCounters:
:MaxTessEvaluationAtomicCounterBuffers:
Call stack too deep (larger than 
) with the following call chain: 
Missing main()
Expression too complex.
Function has too many parameters.
gl_Position
cannot use both gl_FragData and gl_FragColor
cannot use both output variable sets (gl_FragData, gl_SecondaryFragDataEXT) and (gl_FragColor, gl_SecondaryFragColorEXT)
1.2.11
Undefined shift (operand out of range)
Constant folded undefined addition generated NaN
Constant folded addition overflowed to infinity
Constant folded undefined subtraction generated NaN
Constant folded subtraction overflowed to infinity
Constant folded undefined multiplication generated NaN
Constant folded multiplication overflowed to infinity
native context creation failed
ANGLE (
OpenGL ES 
.0 (ANGLE 
OpenGL ES GLSL ES 
OpenGL GLSL 
0 (ANGLE 
GL_OVR_multiview2
GL_OVR_multiview
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Context.cpp
initCaps
Limiting compressed format support.
Limit some features because 
FrameCapture is enabled
FrameCapture limits were forced
Disabling GL_OES_get_program_binary for trace portability
disable_program_binary
Limiting image unit count to 
Setting uniform buffer offset alignment to 
Setting texture buffer offset alignment to 
Disabling GL_EXT_map_buffer_range and GL_OES_mapbuffer during capture, which are not supported on some native drivers
Disabling GL_CHROMIUM_bind_uniform_location during capture, which is not supported on native drivers
Disabling GL_NV_shader_noperspective_interpolation during capture, which is not supported on some native drivers
Disabling GL_NV_framebuffer_blit during capture, which is not supported on some native drivers
Limiting draw buffer count to 
Enabling validation to prevent invalid calls from being captured. This effectively disables GL_KHR_no_error and enables GL_ANGLE_robust_client_memory.
Disabling GL_OES_depth32 during capture, which is not widely supported on mobile
Limiting max atomic counter buffer bindings to 
Limiting max shader storage buffer bindings to 
Limiting GL_MAX_SAMPLES to 
BlitFramebuffer called for non-existing buffers
Clear called for non-existing buffers
Error: 
, in 
v8@?0
Program pipeline link failed
prepareForDispatch
src/libANGLE/ProgramPipeline.h
resolveLink
ProgramPipeline link failed
Internal error: 
IncompleteTexture
This set of render targets requires 
 bytes of pixel storage. This device supports 
 bytes.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ContextMtl.mm
getRenderPassCommandEncoder
setupDraw
Draw call is unusable - please report a bug on bugs.webkit.org
handleDirtyRenderPass
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Debug.cpp
insertMessage
 (this message will no longer repeat)
EGL 
error
deprecated behavior
undefined behavior
portability
performance
marker
start of group
end of group
other message
HIGH
MEDIUM
NOTIFICATION
CRITICAL
ERROR
WARNING
INFO
EVENT
WARN
FATAL
ViewID_OVR
InstanceID
multiviewBaseViewLayerIndex
gl_out
initGlobals
' : 
internal error
out of memory
invalid character
invalid number
integer overflow
float overflow
token too long
invalid expression
division by zero
unexpected end of file found in comment
unexpected token
invalid directive name
macro name is reserved
macro redefined
predefined macro redefined
predefined macro undefined
unterminated macro invocation
macro undefined while being invoked
Not enough arguments for macro
Too many arguments for macro
duplicate macro parameter name
macro invocation chain too deep
unexpected #endif found without a matching #if
unexpected #else found without a matching #if
unexpected #else found after another #else
unexpected #elif found without a matching #if
unexpected #elif found after #else
unexpected end of file found in conditional block
invalid extension name
invalid extension behavior
invalid extension directive
invalid version number
invalid version directive
#version directive must occur before anything else, except for comments and white space
#version directive must occur on the first line of the shader
invalid line number
invalid file number
invalid line directive
extension directive must occur before any non-preprocessor tokens in ESSL1
extension directive must occur before any non-preprocessor tokens in ESSL3
shift exponent is negative or undefined
internal tokenizer error
unexpected end of file found in directive
unexpected token after conditional expression
unrecognized pragma
extension directive should occur before any non-preprocessor tokens
macro name with a double underscore is reserved - unintented behavior is possible
invariant
#pragma STDGL invariant(all) can not be used in fragment shader
invalid pragma value - 'on' or 'off' expected
behavior invalid
extension cannot have 'require' behavior
extension cannot have 'enable' behavior
GL_OVR_multiview2
GL_OVR_multiview
GL_ANDROID_extension_pack_es31a
GL_EXT_gpu_shader5
GL_EXT_texture_buffer
GL_EXT_texture_cube_map_array
GL_OES_sample_variables
GL_OES_shader_multisample_interpolation
GL_OES_shader_image_atomic
GL_OES_texture_storage_multisample_2d_array
GL_EXT_geometry_shader
GL_EXT_tessellation_shader
GL_EXT_shader_io_blocks
GL_EXT_clip_cull_distance
GL_ANGLE_clip_cull_distance
extension can be enabled on greater than ESSL 300
GL_APPLE_clip_distance
extension is not supported
client/version number not supported
__VERSION__
GL_EXT_base_instance
glDrawArraysInstancedBaseInstanceEXT
glDrawElementsInstancedBaseInstanceEXT
glDrawElementsInstancedBaseVertexBaseInstanceEXT
GL_EXT_blend_func_extended
glBindFragDataLocationEXT
glBindFragDataLocationIndexedEXT
glGetFragDataIndexEXT
glGetProgramResourceLocationIndexEXT
GL_EXT_buffer_storage
glBufferStorageEXT
GL_EXT_clear_texture
glClearTexImageEXT
glClearTexSubImageEXT
GL_EXT_clip_control
glClipControlEXT
GL_EXT_copy_image
glCopyImageSubDataEXT
GL_EXT_discard_framebuffer
glDiscardFramebufferEXT
GL_EXT_disjoint_timer_query
glBeginQueryEXT
glDeleteQueriesEXT
glEndQueryEXT
glGenQueriesEXT
glGetInteger64vEXT
glGetQueryObjecti64vEXT
glGetQueryObjectivEXT
glGetQueryObjectui64vEXT
glGetQueryObjectuivEXT
glGetQueryivEXT
glIsQueryEXT
glQueryCounterEXT
GL_EXT_draw_buffers
glDrawBuffersEXT
GL_EXT_draw_buffers_indexed
glBlendEquationSeparateiEXT
glBlendEquationiEXT
glBlendFuncSeparateiEXT
glBlendFunciEXT
glColorMaskiEXT
glDisableiEXT
glEnableiEXT
glIsEnablediEXT
GL_EXT_draw_elements_base_vertex
glDrawElementsBaseVertexEXT
glDrawElementsInstancedBaseVertexEXT
glDrawRangeElementsBaseVertexEXT
glMultiDrawElementsBaseVertexEXT
GL_EXT_draw_transform_feedback
glDrawTransformFeedbackEXT
glDrawTransformFeedbackInstancedEXT
glFramebufferTextureEXT
GL_EXT_instanced_arrays
glVertexAttribDivisorEXT
GL_EXT_map_buffer_range
glFlushMappedBufferRangeEXT
glMapBufferRangeEXT
GL_EXT_multi_draw_indirect
glMultiDrawArraysIndirectEXT
glMultiDrawElementsIndirectEXT
GL_EXT_multisampled_render_to_texture
glFramebufferTexture2DMultisampleEXT
glRenderbufferStorageMultisampleEXT
GL_EXT_multiview_draw_buffers
glGetIntegeri_vEXT
GL_EXT_occlusion_query_boolean
GL_EXT_primitive_bounding_box
glPrimitiveBoundingBoxEXT
GL_EXT_robustness
glGetGraphicsResetStatusEXT
glGetnUniformfvEXT
glGetnUniformivEXT
glReadnPixelsEXT
glPatchParameteriEXT
GL_EXT_texture_border_clamp
glGetSamplerParameterIivEXT
glGetSamplerParameterIuivEXT
glGetTexParameterIivEXT
glGetTexParameterIuivEXT
glSamplerParameterIivEXT
glSamplerParameterIuivEXT
glTexParameterIivEXT
glTexParameterIuivEXT
glTexBufferEXT
glTexBufferRangeEXT
GL_EXT_texture_view
glTextureViewEXT
GL_IMG_multisampled_render_to_texture
glFramebufferTexture2DMultisampleIMG
glRenderbufferStorageMultisampleIMG
GL_KHR_debug
glDebugMessageCallbackKHR
glDebugMessageControlKHR
glDebugMessageInsertKHR
glGetDebugMessageLogKHR
glGetObjectLabelKHR
glGetObjectPtrLabelKHR
glGetPointervKHR
glObjectLabelKHR
glObjectPtrLabelKHR
glPopDebugGroupKHR
glPushDebugGroupKHR
GL_KHR_robustness
glGetGraphicsResetStatusKHR
glGetnUniformfvKHR
glGetnUniformivKHR
glGetnUniformuivKHR
glReadnPixelsKHR
GL_NV_framebuffer_blit
glBlitFramebufferNV
GL_OES_EGL_image
glEGLImageTargetRenderbufferStorageOES
glEGLImageTargetTexture2DOES
GL_OES_copy_image
glCopyImageSubDataOES
GL_OES_draw_buffers_indexed
glBlendEquationSeparateiOES
glBlendEquationiOES
glBlendFuncSeparateiOES
glBlendFunciOES
glColorMaskiOES
glDisableiOES
glEnableiOES
glIsEnablediOES
GL_OES_draw_elements_base_vertex
glDrawElementsBaseVertexOES
glDrawElementsInstancedBaseVertexOES
glDrawRangeElementsBaseVertexOES
GL_OES_geometry_shader
glFramebufferTextureOES
GL_OES_get_program_binary
glGetProgramBinaryOES
glProgramBinaryOES
GL_OES_mapbuffer
glGetBufferPointervOES
glMapBufferOES
glUnmapBufferOES
GL_OES_primitive_bounding_box
glPrimitiveBoundingBoxOES
GL_OES_sample_shading
glMinSampleShadingOES
GL_OES_tessellation_shader
glPatchParameteriOES
GL_OES_texture_3D
glCompressedTexImage3DOES
glCompressedTexSubImage3DOES
glCopyTexSubImage3DOES
glFramebufferTexture3DOES
glTexImage3DOES
glTexSubImage3DOES
GL_OES_texture_border_clamp
glGetSamplerParameterIivOES
glGetSamplerParameterIuivOES
glGetTexParameterIivOES
glGetTexParameterIuivOES
glSamplerParameterIivOES
glSamplerParameterIuivOES
glTexParameterIivOES
glTexParameterIuivOES
GL_OES_texture_buffer
glTexBufferOES
glTexBufferRangeOES
glTexStorage3DMultisampleOES
GL_OES_texture_view
glTextureViewOES
GL_OES_vertex_array_object
glBindVertexArrayOES
glDeleteVertexArraysOES
glGenVertexArraysOES
glIsVertexArrayOES
GL_OES_viewport_array
glGetFloati_vOES
glScissorArrayvOES
glScissorIndexedOES
glScissorIndexedvOES
glViewportArrayvOES
glViewportIndexedfOES
glViewportIndexedfvOES
glActiveTexture
glAttachShader
glBindAttribLocation
glBindBuffer
glBindFramebuffer
glBindRenderbuffer
glBindTexture
glBlendColor
glBlendEquation
glBlendEquationSeparate
glBlendFunc
glBlendFuncSeparate
glBufferData
glBufferSubData
glCheckFramebufferStatus
glClear
glClearColor
glClearDepthf
glClearStencil
glColorMask
glCompileShader
glCompressedTexImage2D
glCompressedTexSubImage2D
glCopyTexImage2D
glCopyTexSubImage2D
glCreateProgram
glCreateShader
glCullFace
glDeleteBuffers
glDeleteFramebuffers
glDeleteProgram
glDeleteRenderbuffers
glDeleteShader
glDeleteTextures
glDepthFunc
glDepthMask
glDepthRangef
glDetachShader
glDisable
glDisableVertexAttribArray
glDrawArrays
glDrawElements
glEnable
glEnableVertexAttribArray
glFinish
glFlush
glFramebufferRenderbuffer
glFramebufferTexture2D
glFrontFace
glGenBuffers
glGenFramebuffers
glGenRenderbuffers
glGenTextures
glGenerateMipmap
glGetActiveAttrib
glGetActiveUniform
glGetAttachedShaders
glGetAttribLocation
glGetBooleanv
glGetBufferParameteriv
glGetError
glGetFloatv
glGetFramebufferAttachmentParameteriv
glGetIntegerv
glGetProgramInfoLog
glGetProgramiv
glGetRenderbufferParameteriv
glGetShaderInfoLog
glGetShaderPrecisionFormat
glGetShaderSource
glGetShaderiv
glGetString
glGetTexParameterfv
glGetTexParameteriv
glGetUniformLocation
glGetUniformfv
glGetUniformiv
glGetVertexAttribPointerv
glGetVertexAttribfv
glGetVertexAttribiv
glHint
glIsBuffer
glIsEnabled
glIsFramebuffer
glIsProgram
glIsRenderbuffer
glIsShader
glIsTexture
glLineWidth
glLinkProgram
glPixelStorei
glPolygonOffset
glReadPixels
glReleaseShaderCompiler
glRenderbufferStorage
glSampleCoverage
glScissor
glShaderBinary
glShaderSource
glStencilFunc
glStencilFuncSeparate
glStencilMask
glStencilMaskSeparate
glStencilOp
glStencilOpSeparate
glTexImage2D
glTexParameterf
glTexParameterfv
glTexParameteri
glTexParameteriv
glTexSubImage2D
glUniform1f
glUniform1fv
glUniform1i
glUniform1iv
glUniform2f
glUniform2fv
glUniform2i
glUniform2iv
glUniform3f
glUniform3fv
glUniform3i
glUniform3iv
glUniform4f
glUniform4fv
glUniform4i
glUniform4iv
glUniformMatrix2fv
glUniformMatrix3fv
glUniformMatrix4fv
glUseProgram
glValidateProgram
glVertexAttrib1f
glVertexAttrib1fv
glVertexAttrib2f
glVertexAttrib2fv
glVertexAttrib3f
glVertexAttrib3fv
glVertexAttrib4f
glVertexAttrib4fv
glVertexAttribPointer
glViewport
glBeginQuery
glBeginTransformFeedback
glBindBufferBase
glBindBufferRange
glBindSampler
glBindTransformFeedback
glBindVertexArray
glBlitFramebuffer
glClearBufferfi
glClearBufferfv
glClearBufferiv
glClearBufferuiv
glClientWaitSync
glCompressedTexImage3D
glCompressedTexSubImage3D
glCopyBufferSubData
glCopyTexSubImage3D
glDeleteQueries
glDeleteSamplers
glDeleteSync
glDeleteTransformFeedbacks
glDeleteVertexArrays
glDrawArraysInstanced
glDrawBuffers
glDrawElementsInstanced
glDrawRangeElements
glEndQuery
glEndTransformFeedback
glFenceSync
glFlushMappedBufferRange
glFramebufferTextureLayer
glGenQueries
glGenSamplers
glGenTransformFeedbacks
glGenVertexArrays
glGetActiveUniformBlockName
glGetActiveUniformBlockiv
glGetActiveUniformsiv
glGetBufferParameteri64v
glGetBufferPointerv
glGetFragDataLocation
glGetInteger64i_v
glGetInteger64v
glGetIntegeri_v
glGetInternalformativ
glGetProgramBinary
glGetQueryObjectuiv
glGetQueryiv
glGetSamplerParameterfv
glGetSamplerParameteriv
glGetStringi
glGetSynciv
glGetTransformFeedbackVarying
glGetUniformBlockIndex
glGetUniformIndices
glGetUniformuiv
glGetVertexAttribIiv
glGetVertexAttribIuiv
glInvalidateFramebuffer
glInvalidateSubFramebuffer
glIsQuery
glIsSampler
glIsSync
glIsTransformFeedback
glIsVertexArray
glMapBufferRange
glPauseTransformFeedback
glProgramBinary
glProgramParameteri
glReadBuffer
glRenderbufferStorageMultisample
glResumeTransformFeedback
glSamplerParameterf
glSamplerParameterfv
glSamplerParameteri
glSamplerParameteriv
glTexImage3D
glTexStorage2D
glTexStorage3D
glTexSubImage3D
glTransformFeedbackVaryings
glUniform1ui
glUniform1uiv
glUniform2ui
glUniform2uiv
glUniform3ui
glUniform3uiv
glUniform4ui
glUniform4uiv
glUniformBlockBinding
glUniformMatrix2x3fv
glUniformMatrix2x4fv
glUniformMatrix3x2fv
glUniformMatrix3x4fv
glUniformMatrix4x2fv
glUniformMatrix4x3fv
glUnmapBuffer
glVertexAttribDivisor
glVertexAttribI4i
glVertexAttribI4iv
glVertexAttribI4ui
glVertexAttribI4uiv
glVertexAttribIPointer
glWaitSync
glActiveShaderProgram
glBindImageTexture
glBindProgramPipeline
glBindVertexBuffer
glCreateShaderProgramv
glDeleteProgramPipelines
glDispatchCompute
glDispatchComputeIndirect
glDrawArraysIndirect
glDrawElementsIndirect
glFramebufferParameteri
glGenProgramPipelines
glGetBooleani_v
glGetFramebufferParameteriv
glGetMultisamplefv
glGetProgramInterfaceiv
glGetProgramPipelineInfoLog
glGetProgramPipelineiv
glGetProgramResourceIndex
glGetProgramResourceLocation
glGetProgramResourceName
glGetProgramResourceiv
glGetTexLevelParameterfv
glGetTexLevelParameteriv
glIsProgramPipeline
glMemoryBarrier
glMemoryBarrierByRegion
glProgramUniform1f
glProgramUniform1fv
glProgramUniform1i
glProgramUniform1iv
glProgramUniform1ui
glProgramUniform1uiv
glProgramUniform2f
glProgramUniform2fv
glProgramUniform2i
glProgramUniform2iv
glProgramUniform2ui
glProgramUniform2uiv
glProgramUniform3f
glProgramUniform3fv
glProgramUniform3i
glProgramUniform3iv
glProgramUniform3ui
glProgramUniform3uiv
glProgramUniform4f
glProgramUniform4fv
glProgramUniform4i
glProgramUniform4iv
glProgramUniform4ui
glProgramUniform4uiv
glProgramUniformMatrix2fv
glProgramUniformMatrix2x3fv
glProgramUniformMatrix2x4fv
glProgramUniformMatrix3fv
glProgramUniformMatrix3x2fv
glProgramUniformMatrix3x4fv
glProgramUniformMatrix4fv
glProgramUniformMatrix4x2fv
glProgramUniformMatrix4x3fv
glSampleMaski
glTexStorage2DMultisample
glUseProgramStages
glValidateProgramPipeline
glVertexAttribBinding
glVertexAttribFormat
glVertexAttribIFormat
glVertexBindingDivisor
glBlendBarrier
glBlendEquationSeparatei
glBlendEquationi
glBlendFuncSeparatei
glBlendFunci
glColorMaski
glCopyImageSubData
glDebugMessageCallback
glDebugMessageControl
glDebugMessageInsert
glDisablei
glDrawElementsBaseVertex
glDrawElementsInstancedBaseVertex
glDrawRangeElementsBaseVertex
glEnablei
glFramebufferTexture
glGetDebugMessageLog
glGetGraphicsResetStatus
glGetObjectLabel
glGetObjectPtrLabel
glGetPointerv
glGetSamplerParameterIiv
glGetSamplerParameterIuiv
glGetTexParameterIiv
glGetTexParameterIuiv
glGetnUniformfv
glGetnUniformiv
glGetnUniformuiv
glIsEnabledi
glMinSampleShading
glObjectLabel
glObjectPtrLabel
glPatchParameteri
glPopDebugGroup
glPrimitiveBoundingBox
glPushDebugGroup
glReadnPixels
glSamplerParameterIiv
glSamplerParameterIuiv
glTexBuffer
glTexBufferRange
glTexParameterIiv
glTexParameterIuiv
glTexStorage3DMultisample
GL_EXT_blend_minmax
glBlendEquationEXT
GL_EXT_debug_label
glGetObjectLabelEXT
GL_EXT_debug_marker
glInsertEventMarkerEXT
glPopGroupMarkerEXT
glPushGroupMarkerEXT
GL_EXT_draw_instanced
glDrawArraysInstancedEXT
glDrawElementsInstancedEXT
GL_EXT_memory_object
glBufferStorageMemEXT
glCreateMemoryObjectsEXT
glDeleteMemoryObjectsEXT
glGetMemoryObjectParameterivEXT
glGetUnsignedBytei_vEXT
glGetUnsignedBytevEXT
glIsMemoryObjectEXT
glMemoryObjectParameterivEXT
glNamedBufferStorageMemEXT
glTexStorageMem2DEXT
glTexStorageMem2DMultisampleEXT
glTexStorageMem3DEXT
glTexStorageMem3DMultisampleEXT
glTextureStorageMem2DEXT
glTextureStorageMem2DMultisampleEXT
glTextureStorageMem3DEXT
glTextureStorageMem3DMultisampleEXT
GL_EXT_memory_object_fd
glImportMemoryFdEXT
GL_EXT_memory_object_win32
glImportMemoryWin32HandleEXT
glImportMemoryWin32NameEXT
GL_EXT_multi_draw_arrays
glMultiDrawArraysEXT
glMultiDrawElementsEXT
GL_EXT_semaphore
glDeleteSemaphoresEXT
glGenSemaphoresEXT
glGetSemaphoreParameterui64vEXT
glIsSemaphoreEXT
glSemaphoreParameterui64vEXT
glSignalSemaphoreEXT
glWaitSemaphoreEXT
GL_EXT_semaphore_fd
glImportSemaphoreFdEXT
GL_EXT_semaphore_win32
glImportSemaphoreWin32HandleEXT
glImportSemaphoreWin32NameEXT
GL_EXT_separate_shader_objects
glActiveShaderProgramEXT
glBindProgramPipelineEXT
glCreateShaderProgramvEXT
glDeleteProgramPipelinesEXT
glGenProgramPipelinesEXT
glGetProgramPipelineInfoLogEXT
glGetProgramPipelineivEXT
glIsProgramPipelineEXT
glProgramParameteriEXT
glProgramUniform1fEXT
glProgramUniform1fvEXT
glProgramUniform1iEXT
glProgramUniform1ivEXT
glProgramUniform1uiEXT
glProgramUniform1uivEXT
glProgramUniform2fEXT
glProgramUniform2fvEXT
glProgramUniform2iEXT
glProgramUniform2ivEXT
glProgramUniform2uiEXT
glProgramUniform2uivEXT
glProgramUniform3fEXT
glProgramUniform3fvEXT
glProgramUniform3iEXT
glProgramUniform3ivEXT
glProgramUniform3uiEXT
glProgramUniform3uivEXT
glProgramUniform4fEXT
glProgramUniform4fvEXT
glProgramUniform4iEXT
glProgramUniform4ivEXT
glProgramUniform4uiEXT
glProgramUniform4uivEXT
glProgramUniformMatrix2fvEXT
glProgramUniformMatrix2x3fvEXT
glProgramUniformMatrix2x4fvEXT
glProgramUniformMatrix3fvEXT
glProgramUniformMatrix3x2fvEXT
glProgramUniformMatrix3x4fvEXT
glProgramUniformMatrix4fvEXT
glProgramUniformMatrix4x2fvEXT
glProgramUniformMatrix4x3fvEXT
glUseProgramStagesEXT
glValidateProgramPipelineEXT
GL_EXT_shader_framebuffer_fetch_non_coherent
glFramebufferFetchBarrierEXT
GL_EXT_texture_storage
glTexStorage1DEXT
glTexStorage2DEXT
glTexStorage3DEXT
glTextureStorage1DEXT
glTextureStorage2DEXT
glTextureStorage3DEXT
GL_KHR_parallel_shader_compile
glMaxShaderCompilerThreadsKHR
GL_NV_fence
glDeleteFencesNV
glFinishFenceNV
glGenFencesNV
glGetFenceivNV
glIsFenceNV
glSetFenceNV
glTestFenceNV
GL_NV_framebuffer_mixed_samples
glCoverageModulationNV
GL_NV_internalformat_sample_query
glGetInternalformatSampleivNV
glFramebufferTextureMultiviewOVR
gpu.angle
egl::Display::initialize
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Display.cpp
initialize
ANGLE Display::initialize error 
No configs were generated.
Failed to initialize display because device creation failed: 
native client buffer allocation failed.
OpenGL_ES OpenGL
true
false
Program binary not accessible.
Program binary too large or changed during access.
Failed to copy program binary into the cache.
ANGLE_DEFAULT_PLATFORM
metal
loseContextOnOutOfMemory
Some users rely on a lost context notification if a GL_OUT_OF_MEMORY error occurs
disableProgramCachingForTransformFeedback
On some GPUs, program binaries don't contain transform feedback varyings
scalarizeVecAndMatConstructorArgs
Always rewrite vec/mat constructors to be consistent
http://crbug.com/1165751
disableProgramBinary
Disable support for GL_OES_get_program_binary
http://anglebug.com/5007
disableDrawBuffersIndexed
Disable support for OES_draw_buffers_indexed and EXT_draw_buffers_indexed
http://anglebug.com/7724
disableAnisotropicFiltering
Disable support for anisotropic filtering
allowCompressedFormats
Allow compressed formats
singleThreadedTextureDecompression
Disables multi-threaded decompression of compressed texture formats
forceDepthAttachmentInitOnClear
Force depth attachment initialization on clear ops
https://anglebug.com/7246
enableCaptureLimits
Set the context limits like frame capturing was enabled
http://anglebug.com/5750
forceRobustResourceInit
Force-enable robust resource init
http://anglebug.com/6041
forceInitShaderVariables
Force-enable shader variable initialization
enableProgramBinaryForCapture
Even if FrameCapture is enabled, enable GL_OES_get_program_binary
http://anglebug.com/5658
forceGlErrorChecking
Force GL error checking (i.e. prevent applications from disabling error checking
https://issuetracker.google.com/220069903
emulatePixelLocalStorage
Emulate ANGLE_shader_pixel_local_storage using shader images
http://anglebug.com/7279
cacheCompiledShader
Enable to cache compiled shaders
http://anglebug.com/7036
Could not create the EAGL context.
Could set the EAGL context current.
Could not open the OpenGLES Framework.
OpenGL ES 2.0 is not supportable.
Could not make device EAGL context current.
Could not release device EAGL context.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
makeCurrent
Unable to make gl context current.
/System/Library/Frameworks/OpenGLES.framework/OpenGLES
OpenGL 
DisplayImpl::validateClientBuffer unimplemented.
DisplayImpl::validateImageClientBuffer unimplemented.
DisplayImpl::valdiatePixmap unimplemented.
ANGLE Metal Renderer
isMetal2_1 && (isOSX || isCatalyst) && !isARM
supportsEitherGPUFamily(3, 2)
supportsEitherGPUFamily(5, 2)
supportsEitherGPUFamily(3, 1)
supportsEitherGPUFamily(3, 1) && !isAMD()
isMetal2_1 && !isIntel() && !isNVIDIA()
isMetal2_2 && supportsEitherGPUFamily(3, 2) && !isSimulator
isMetal2_1 && !isNVIDIA()
(isOSX || isCatalyst) && !isARM
isAMD()
isOSX || isCatalyst || supportsAppleGPUFamily(3)
isOSX || isCatalyst || supportsAppleGPUFamily(4)
!isOSX && !isCatalyst && !isSimulator
isIntel() && GetMacOSVersion() < OSVersion(11, 0, 0)
isIntel() && GetMacOSVersion() < OSVersion(12, 0, 0)
isIntel() || isAMD()
isIntel()
supportsEitherGPUFamily(4, 2)
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/DisplayMtl.mm
getDefaultShadersLib
Internal error: 
hasBaseVertexInstancedDraw
The renderer supports base vertex instanced draw
hasExplicitMemBarrier
The renderer supports explicit memory barrier
hasCheapRenderPass
The renderer can cheaply break a render pass.
hasNonUniformDispatch
The renderer supports non uniform compute shader dispatch's group size
hasShaderStencilOutput
The renderer supports stencil output from fragment shader
hasTextureSwizzle
The renderer supports texture swizzle
hasDepthAutoResolve
The renderer supports MSAA depth auto resolve at the end of render pass
hasStencilAutoResolve
The renderer supports MSAA stencil auto resolve at the end of render pass
hasEvents
The renderer supports MTL(Shared)Event
allowInlineConstVertexData
The renderer supports using inline constant data for small client vertex data
allowSeparateDepthStencilBuffers
Some Apple platforms such as iOS allows separate depth and stencil buffers, whereas others such as macOS don't
allowRuntimeSamplerCompareMode
The renderer supports changing sampler's compare mode outside shaders
allowSamplerCompareGradient
The renderer supports sample_compare with gradients
allowSamplerCompareLod
The renderer supports sample_compare with lod
allowBufferReadWrite
The renderer supports buffer read and write in the same shader
allowMultisampleStoreAndResolve
The renderer supports MSAA store and resolve in the same pass
allowGenMultipleMipsPerPass
The renderer supports generating multiple mipmaps per pass
forceD24S8AsUnsupported
Force Depth24Stencil8 format as unsupported.
forceBufferGPUStorage
On systems that support both buffer' memory allocation on GPU and shared memory (such as macOS), force using GPU memory allocation for buffers everytime or not.
forceNonCSBaseMipmapGeneration
Turn this feature on to disallow Compute Shader based mipmap generation. Compute Shader based mipmap generation might cause GPU hang on some older iOS devices.
emulateTransformFeedback
Turn this on to allow transform feedback in Metal using a 2-pass VS for GLES3.
rewriteRowMajorMatrices
Rewrite row major matrices in shaders as column major.
intelExplicitBoolCastWorkaround
Insert explicit casts for float/double/unsigned/signed int on macOS 10.15 with Intel driver
intelDisableFastMath
Disable fast math in atan and invariance cases when running below macOS 12.0
allowRenderpassWithoutAttachment
Allow creation of render passes without any attachments
multisampleColorFormatShaderReadWorkaround
Add shaderRead usage to some multisampled texture formats
http://anglebug.com/7049
copyIOSurfaceToNonIOSurfaceForReadOptimization
some GPUs are faster to read an IOSurface texture by first copying the texture to a non-IOSurface texture
http://anglebug.com/7117 http://anglebug.com/7573
copyTextureToBufferForReadOptimization
some GPUs are faster to read a texture by first copying the texture to a buffer
http://anglebug.com/7117
limitMaxDrawBuffersForTesting
Used to check the backend works when the device's advertized limit is less than the code's limit
http://anglebug.com/7280
limitMaxColorTargetBitsForTesting
Metal iOS has a limit on the number of color target bits per pixel.
preemptivelyStartProvokingVertexCommandBuffer
AMD Metal Drivers appear to have a bug this works around
http://anglebug.com/7635
uploadDataToIosurfacesWithStagingBuffers
When uploading data to IOSurface-backed textures, use a staging buffer.
http://anglebug.com/7573
alwaysUseStagedBufferUpdates
Always update buffers by copying the data to a staging buffer and then blitting it to the actual buffer
http://anglebug.com/7544
useShadowBuffersWhenAppropriate
On some architectures using a shadow buffer can be faster for certain size buffers
alwaysUseManagedStorageModeForBuffers
Metal buffers can be managed, shared, or private. Sometimes managed is fastest
alwaysUseSharedStorageModeForBuffers
Metal buffers can be managed, shared, or private. Sometimes shared is fastest
preferCpuForBuffersubdata
Makes bufferSubData always update via CPU
disableProgrammableBlending
Disable programmable blending in order to test read_write pixel local storage textures
disableRWTextureTier2Support
Disable tier2 read_write textures in order to test tier1 support
disableRasterOrderGroups
Disable raster order groups in order to test pixel local storage memory barriers
Apple
Broadcom
Google
Intel
Mesa
Microsoft
NVIDIA
Imagination Technologies
Qualcomm
Samsung Electronics Co., Ltd.
Vivante
VMware
VirtIO
Test
NULL
Unknown
ANGLE_angleUniforms
unpackSnorm4x8
ANGLEDepthRangeParams
eglClientWaitSync
eglCreateImageKHR
eglCreateNativeClientBufferANDROID
eglCreatePlatformPixmapSurfaceEXT
CreatePlatformPixmapSurfaceEXT unimplemented.
eglCreatePlatformWindowSurfaceEXT
eglPlatformCreateWindowSurfaceEXT
eglCreateStreamKHR
eglCreateSyncKHR
eglDestroyImageKHR
eglDestroyStreamKHR
eglDestroySync
eglDupNativeFenceFDANDROID
eglGetSyncAttrib
eglPostSubBufferNV
eglPresentationTimeANDROID
eglGetCompositorTimingANDROIDD
eglGetNextFrameIdANDROID
eglQueryTimestampSupportedANDROID
eglGetFrameTimestampsANDROID
eglQueryDeviceAttribEXT
eglQueryDeviceStringEXT
eglQueryDisplayAttribEXT
eglQueryStreamKHR
eglQueryStreamu64KHR
eglQuerySurfacePointerANGLE
eglSetBlobCacheFuncsANDROID
eglSignalSyncKHR
eglStreamAttribKHR
eglStreamConsumerAcquireKHR
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerGLTextureExternalAttribsNV
eglStreamConsumerReleaseKHR
eglSwapBuffersWithDamageEXT
eglPrepareSwapBuffersANGLE
prepareSwap
eglWaitSync
eglCreateDeviceANGLE
eglCreateStreamProducerD3DTextureANGLE
eglStreamPostD3DTextureANGLE
eglGetMscRateANGLE
eglGetSyncValuesCHROMIUM
eglProgramCacheGetAttribANGLE
eglProgramCacheQueryANGLE
eglProgramCachePopulateANGLE
eglProgramCacheResizeANGLE
eglQueryStringiANGLE
eglSwapBuffersWithFrameTokenANGLE
eglReleaseHighPowerGPUANGLE
eglReacquireHighPowerGPUANGLE
eglHandleGPUSwitchANGLE
eglForceGPUSwitchANGLE
eglWaitUntilWorkScheduledANGLE
eglLockSurfaceKHR
eglUnlockSurfaceKHR
eglQuerySurface64KHR
eglExportVkImageANGLE
eglSetDamageRegionKHR
eglQueryDmaBufFormatsEXT
eglQueryDmaBufModifiersEXT
eglCopyMetalSharedEventANGLE
eglBindTexImage
eglClientWaitSync
eglCopyBuffers
eglCreateContext
eglCreateImage
eglCreatePbufferFromClientBuffer
eglCreatePbufferSurface
eglCreatePixmapSurface
eglCreatePlatformPixmapSurface
eglCreatePlatformWindowSurface
eglPlatformCreateWindowSurface
eglCreateSync
eglCreateWindowSurface
eglDestroyContext
eglDestroyImage
eglDestroySurface
eglDestroySync
eglGetSyncAttrib
eglInitialize
eglMakeCurrent
eglQueryContext
eglQueryString
1.5 (ANGLE 
eglQuerySurface
eglReleaseTexImage
eglReleaseThread
eglSurfaceAttrib
eglSwapBuffers
eglSwapInterval
eglTerminate
eglWaitClient
eglWaitGL
eglWaitNative
eglWaitSync
unique_lock::lock: references null mutex
unique_lock::lock: already locked
unique_lock::unlock: not locked
GMD_FIXED_EMIT
texelFetch
texelFetchOffset
texture1D
texture1DLod
texture1DProjLod
texture2DGradEXT
texture2DLod
texture2DLodEXT
texture2DProj
texture2DProjGradEXT
texture2DProjLod
texture2DProjLodEXT
texture2DRect
texture2DRectProj
texture3D
texture3DLod
texture3DProjLod
textureCube
textureCubeGradEXT
textureCubeLod
textureCubeLodEXT
textureCubeProjLod
textureGrad
textureGradOffset
textureLod
textureLodOffset
textureOffset
textureProj
textureProjGrad
textureProjGradOffset
textureProjLod
textureProjLodOffset
textureProjOffset
textureSize
imageLoad
imageStore
memoryBarrierImage
ANGLE_tensor<
metal::
packed_
uint32_t
metal::texture2d<
float
uint
, metal::access::read_write>
INFINITY
!=/*xor*/
ANGLE_equalStructArray
ANGLE_equal
ANGLE_notEqualStructArray
ANGLE_notEqual
ANGLE_notEqualStruct
kill
return
break
continue
ANGLE_radians
ANGLE_degrees
ANGLE_atan
ANGLE_mod
ANGLE_refract
ANGLE_distance
ANGLE_length
ANGLE_dot
ANGLE_normalize
ANGLE_faceforward
ANGLE_reflect
ANGLE_componentWiseMultiply
ANGLE_outerProduct
ANGLE_sign
metal::abs
metal::all
metal::any
metal::sin
metal::cos
metal::tan
metal::asin
metal::acos
metal::sinh
metal::cosh
metal::tanh
metal::asinh
metal::acosh
metal::atanh
metal::fma
metal::pow
metal::exp
metal::exp2
metal::log
metal::log2
metal::sqrt
metal::floor
metal::trunc
metal::ceil
metal::fract
metal::min
metal::max
metal::round
metal::rint
metal::clamp
ANGLE_mix_bool
metal::mix
metal::step
metal::smoothstep
metal::modf
metal::isnan
metal::isinf
metal::ldexp
metal::frexp
metal::rsqrt
metal::cross
metal::dfdx
metal::dfdy
metal::fwidth
metal::transpose
metal::determinant
ANGLE_inverse
as_type<int>
as_type<uint32_t>
as_type<float>
TOperator_TODO
as_type<int2>
as_type<uint2>
as_type<float2>
as_type<int3>
as_type<uint3>
as_type<float3>
as_type<int4>
as_type<uint4>
as_type<float4>
metal::pack_float_to_unorm2x16
metal::pack_float_to_snorm2x16
metal::pack_float_to_unorm4x8
metal::pack_float_to_snorm4x8
metal::unpack_unorm2x16_to_float
metal::unpack_snorm2x16_to_float
metal::unpack_unorm4x8_to_float
metal::unpack_snorm4x8_to_float
ANGLE_pack_half_2x16
ANGLE_unpack_half_2x16
ANGLE_int_clamp(
, 0, 
.size()
if (
else
 else {}
switch (
case 
default:
 @@XFB-Bindings@@ 
[[early_fragment_tests]]
fragment 
vertex __VERTEX_OUT(
 [[stage_in]]
 [[buffer(
metal::sampler
 [[sampler(
 [[texture(
 [[instance_id]]
 [[base_instance]]
struct 
char 
 [[flat]]
 [[color(
, raster_order_group(0)
 [[depth(any), function_constant(
 [[sample_mask, function_constant(
raster_order_group(0), 
texture(
[[id(
 [[position]]
 [[clip_distance]] [
 [[point_size]]
 [[vertex_id]]
 [[point_coord]]
 [[front_facing]]
 [[invariant]]
baseInstance
constant 
for (
while (
metal::discard_fragment()
#if TRANSFORM_FEEDBACK_ENABLED
return;
#else
#endif
gl_FragData
eglChooseConfig
eglCopyBuffers
eglCreateContext
eglCreatePbufferSurface
eglCreatePixmapSurface
eglCreateWindowSurface
eglDestroyContext
eglDestroySurface
eglGetConfigAttrib
eglGetConfigs
eglGetCurrentSurface
eglInitialize
eglMakeCurrent
eglQueryContext
eglQuerySurface
eglSwapBuffers
eglTerminate
eglWaitGL
eglWaitNative
eglBindTexImage
eglReleaseTexImage
eglSurfaceAttrib
eglSwapInterval
eglCreatePbufferFromClientBuffer
eglWaitClient
eglClientWaitSync
eglCreateImage
eglCreatePlatformPixmapSurface
eglCreatePlatformWindowSurface
eglCreateSync
eglDestroyImage
eglDestroySync
eglGetPlatformDisplay
eglGetSyncAttrib
eglWaitSync
eglSetBlobCacheFuncsANDROID
eglCreateNativeClientBufferANDROID
eglGetCompositorTimingSupportedANDROID
eglGetCompositorTimingANDROID
eglGetNextFrameIdANDROID
eglGetFrameTimestampSupportedANDROID
eglGetFrameTimestampsANDROID
eglGetNativeClientBufferANDROID
eglDupNativeFenceFDANDROID
eglPresentationTimeANDROID
eglCreateDeviceANGLE
eglReleaseDeviceANGLE
eglQueryStringiANGLE
eglQueryDisplayAttribANGLE
eglCopyMetalSharedEventANGLE
eglReleaseHighPowerGPUANGLE
eglReacquireHighPowerGPUANGLE
eglHandleGPUSwitchANGLE
eglForceGPUSwitchANGLE
eglProgramCacheGetAttribANGLE
eglProgramCacheQueryANGLE
eglProgramCachePopulateANGLE
eglProgramCacheResizeANGLE
eglQuerySurfacePointerANGLE
eglCreateStreamProducerD3DTextureANGLE
eglStreamPostD3DTextureANGLE
eglSwapBuffersWithFrameTokenANGLE
eglGetMscRateANGLE
eglExportVkImageANGLE
eglWaitUntilWorkScheduledANGLE
eglGetSyncValuesCHROMIUM
eglQueryDeviceAttribEXT
eglQueryDisplayAttribEXT
eglQueryDmaBufFormatsEXT
eglQueryDmaBufModifiersEXT
eglCreatePlatformPixmapSurfaceEXT
eglCreatePlatformWindowSurfaceEXT
eglGetPlatformDisplayEXT
eglDebugMessageControlKHR
eglLabelObjectKHR
eglQueryDebugKHR
eglClientWaitSyncKHR
eglCreateSyncKHR
eglDestroySyncKHR
eglGetSyncAttribKHR
eglCreateImageKHR
eglDestroyImageKHR
eglLockSurfaceKHR
eglQuerySurface64KHR
eglUnlockSurfaceKHR
eglSetDamageRegionKHR
eglSignalSyncKHR
eglCreateStreamKHR
eglDestroyStreamKHR
eglQueryStreamKHR
eglQueryStreamu64KHR
eglStreamAttribKHR
eglStreamConsumerAcquireKHR
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerReleaseKHR
eglSwapBuffersWithDamageKHR
eglWaitSyncKHR
eglPostSubBufferNV
eglStreamConsumerGLTextureExternalAttribsNV
Invalid
clBuildProgram
clCloneKernel
clCompileProgram
clCreateBuffer
clCreateBufferWithProperties
clCreateCommandQueue
clCreateCommandQueueWithProperties
clCreateContext
clCreateContextFromType
clCreateImage
clCreateImage2D
clCreateImage3D
clCreateImageWithProperties
clCreateKernel
clCreateKernelsInProgram
clCreatePipe
clCreateProgramWithBinary
clCreateProgramWithBuiltInKernels
clCreateProgramWithIL
clCreateProgramWithSource
clCreateSampler
clCreateSamplerWithProperties
clCreateSubBuffer
clCreateSubDevices
clCreateUserEvent
clEnqueueBarrier
clEnqueueBarrierWithWaitList
clEnqueueCopyBuffer
clEnqueueCopyBufferRect
clEnqueueCopyBufferToImage
clEnqueueCopyImage
clEnqueueCopyImageToBuffer
clEnqueueFillBuffer
clEnqueueFillImage
clEnqueueMapBuffer
clEnqueueMapImage
clEnqueueMarker
clEnqueueMarkerWithWaitList
clEnqueueMigrateMemObjects
clEnqueueNDRangeKernel
clEnqueueNativeKernel
clEnqueueReadBuffer
clEnqueueReadBufferRect
clEnqueueReadImage
clEnqueueSVMFree
clEnqueueSVMMap
clEnqueueSVMMemFill
clEnqueueSVMMemcpy
clEnqueueSVMMigrateMem
clEnqueueSVMUnmap
clEnqueueTask
clEnqueueUnmapMemObject
clEnqueueWaitForEvents
clEnqueueWriteBuffer
clEnqueueWriteBufferRect
clEnqueueWriteImage
clFinish
clFlush
clGetCommandQueueInfo
clGetContextInfo
clGetDeviceAndHostTimer
clGetDeviceIDs
clGetDeviceInfo
clGetEventInfo
clGetEventProfilingInfo
clGetExtensionFunctionAddress
clGetExtensionFunctionAddressForPlatform
clGetHostTimer
clGetImageInfo
clGetKernelArgInfo
clGetKernelInfo
clGetKernelSubGroupInfo
clGetKernelWorkGroupInfo
clGetMemObjectInfo
clGetPipeInfo
clGetPlatformIDs
clGetPlatformInfo
clGetProgramBuildInfo
clGetProgramInfo
clGetSamplerInfo
clGetSupportedImageFormats
clIcdGetPlatformIDsKHR
clLinkProgram
clReleaseCommandQueue
clReleaseContext
clReleaseDevice
clReleaseEvent
clReleaseKernel
clReleaseMemObject
clReleaseProgram
clReleaseSampler
clRetainCommandQueue
clRetainContext
clRetainDevice
clRetainEvent
clRetainKernel
clRetainMemObject
clRetainProgram
clRetainSampler
clSVMAlloc
clSVMFree
clSetCommandQueueProperty
clSetContextDestructorCallback
clSetDefaultDeviceCommandQueue
clSetEventCallback
clSetKernelArg
clSetKernelArgSVMPointer
clSetKernelExecInfo
clSetMemObjectDestructorCallback
clSetProgramReleaseCallback
clSetProgramSpecializationConstant
clSetUserEventStatus
clUnloadCompiler
clUnloadPlatformCompiler
clWaitForEvents
eglBindAPI
eglGetCurrentContext
eglGetCurrentDisplay
eglGetDisplay
eglGetError
eglGetProcAddress
eglPrepareSwapBuffersANGLE
eglQueryAPI
glAccum
glAcquireTexturesANGLE
glAlphaFunc
glAlphaFuncx
glAreTexturesResident
glArrayElement
glBegin
glBeginConditionalRender
glBeginPerfMonitorAMD
glBeginPixelLocalStorageANGLE
glBeginQueryIndexed
glBindBuffersBase
glBindBuffersRange
glBindFragDataLocation
glBindFragDataLocationIndexed
glBindFramebufferOES
glBindImageTextures
glBindRenderbufferOES
glBindSamplers
glBindTextureUnit
glBindTextures
glBindUniformLocationCHROMIUM
glBindVertexBuffers
glBitmap
glBlendBarrierKHR
glBlitFramebufferANGLE
glBlitNamedFramebuffer
glBufferStorage
glBufferStorageExternalEXT
glCallList
glCallLists
glCheckFramebufferStatusOES
glCheckNamedFramebufferStatus
glClampColor
glClearAccum
glClearBufferData
glClearBufferSubData
glClearColorx
glClearDepth
glClearDepthx
glClearIndex
glClearNamedBufferData
glClearNamedBufferSubData
glClearNamedFramebufferfi
glClearNamedFramebufferfv
glClearNamedFramebufferiv
glClearNamedFramebufferuiv
glClearTexImage
glClearTexSubImage
glClientActiveTexture
glClipControl
glClipPlane
glClipPlanef
glClipPlanex
glColor3b
glColor3bv
glColor3d
glColor3dv
glColor3f
glColor3fv
glColor3i
glColor3iv
glColor3s
glColor3sv
glColor3ub
glColor3ubv
glColor3ui
glColor3uiv
glColor3us
glColor3usv
glColor4b
glColor4bv
glColor4d
glColor4dv
glColor4f
glColor4fv
glColor4i
glColor4iv
glColor4s
glColor4sv
glColor4ub
glColor4ubv
glColor4ui
glColor4uiv
glColor4us
glColor4usv
glColor4x
glColorMaterial
glColorP3ui
glColorP3uiv
glColorP4ui
glColorP4uiv
glColorPointer
glCompressedCopyTextureCHROMIUM
glCompressedTexImage1D
glCompressedTexImage2DRobustANGLE
glCompressedTexImage3DRobustANGLE
glCompressedTexSubImage1D
glCompressedTexSubImage2DRobustANGLE
glCompressedTexSubImage3DRobustANGLE
glCompressedTextureSubImage1D
glCompressedTextureSubImage2D
glCompressedTextureSubImage3D
glCopyNamedBufferSubData
glCopyPixels
glCopySubTexture3DANGLE
glCopySubTextureCHROMIUM
glCopyTexImage1D
glCopyTexSubImage1D
glCopyTexture3DANGLE
glCopyTextureCHROMIUM
glCopyTextureSubImage1D
glCopyTextureSubImage2D
glCopyTextureSubImage3D
glCoverageModulationCHROMIUM
glCreateBuffers
glCreateFramebuffers
glCreateProgramPipelines
glCreateQueries
glCreateRenderbuffers
glCreateSamplers
glCreateTextures
glCreateTransformFeedbacks
glCreateVertexArrays
glCurrentPaletteMatrixOES
glDeleteFramebuffersOES
glDeleteLists
glDeletePerfMonitorsAMD
glDeleteRenderbuffersOES
glDepthRange
glDepthRangeArrayv
glDepthRangeIndexed
glDepthRangex
glDisableClientState
glDisableExtensionANGLE
glDisableVertexArrayAttrib
glDrawArraysInstancedANGLE
glDrawArraysInstancedBaseInstance
glDrawArraysInstancedBaseInstanceANGLE
glDrawBuffer
glDrawElementsInstancedANGLE
glDrawElementsInstancedBaseInstance
glDrawElementsInstancedBaseVertexBaseInstance
glDrawElementsInstancedBaseVertexBaseInstanceANGLE
glDrawPixels
glDrawTexfOES
glDrawTexfvOES
glDrawTexiOES
glDrawTexivOES
glDrawTexsOES
glDrawTexsvOES
glDrawTexxOES
glDrawTexxvOES
glDrawTransformFeedback
glDrawTransformFeedbackInstanced
glDrawTransformFeedbackStream
glDrawTransformFeedbackStreamInstanced
glEGLImageTargetTexStorageEXT
glEGLImageTargetTextureStorageEXT
glEdgeFlag
glEdgeFlagPointer
glEdgeFlagv
glEnableClientState
glEnableVertexArrayAttrib
glEnd
glEndConditionalRender
glEndList
glEndPerfMonitorAMD
glEndPixelLocalStorageANGLE
glEndQueryIndexed
glEvalCoord1d
glEvalCoord1dv
glEvalCoord1f
glEvalCoord1fv
glEvalCoord2d
glEvalCoord2dv
glEvalCoord2f
glEvalCoord2fv
glEvalMesh1
glEvalMesh2
glEvalPoint1
glEvalPoint2
glFeedbackBuffer
glFlushMappedNamedBufferRange
glFogCoordPointer
glFogCoordd
glFogCoorddv
glFogCoordf
glFogCoordfv
glFogf
glFogfv
glFogi
glFogiv
glFogx
glFogxv
glFramebufferMemorylessPixelLocalStorageANGLE
glFramebufferParameteriMESA
glFramebufferPixelLocalClearValuefvANGLE
glFramebufferPixelLocalClearValueivANGLE
glFramebufferPixelLocalClearValueuivANGLE
glFramebufferRenderbufferOES
glFramebufferTexture1D
glFramebufferTexture2DOES
glFramebufferTexture3D
glFramebufferTexturePixelLocalStorageANGLE
glFrustum
glFrustumf
glFrustumx
glGenFramebuffersOES
glGenLists
glGenPerfMonitorsAMD
glGenRenderbuffersOES
glGenerateMipmapOES
glGenerateTextureMipmap
glGetActiveAtomicCounterBufferiv
glGetActiveSubroutineName
glGetActiveSubroutineUniformName
glGetActiveSubroutineUniformiv
glGetActiveUniformBlockivRobustANGLE
glGetActiveUniformName
glGetBooleani_vRobustANGLE
glGetBooleanvRobustANGLE
glGetBufferParameteri64vRobustANGLE
glGetBufferParameterivRobustANGLE
glGetBufferPointervRobustANGLE
glGetBufferSubData
glGetClipPlane
glGetClipPlanef
glGetClipPlanex
glGetCompressedTexImage
glGetCompressedTexImageANGLE
glGetCompressedTextureImage
glGetCompressedTextureSubImage
glGetDoublei_v
glGetDoublev
glGetFixedv
glGetFloati_v
glGetFloatvRobustANGLE
glGetFragDataIndex
glGetFramebufferAttachmentParameterivOES
glGetFramebufferAttachmentParameterivRobustANGLE
glGetFramebufferParameterivMESA
glGetFramebufferParameterivRobustANGLE
glGetFramebufferPixelLocalStorageParameterfvANGLE
glGetFramebufferPixelLocalStorageParameterivANGLE
glGetInteger64i_vRobustANGLE
glGetInteger64vRobustANGLE
glGetIntegeri_vRobustANGLE
glGetIntegervRobustANGLE
glGetInternalformati64v
glGetInternalformativRobustANGLE
glGetLightfv
glGetLightiv
glGetLightxv
glGetMapdv
glGetMapfv
glGetMapiv
glGetMaterialfv
glGetMaterialiv
glGetMaterialxv
glGetMultisamplefvANGLE
glGetMultisamplefvRobustANGLE
glGetNamedBufferParameteri64v
glGetNamedBufferParameteriv
glGetNamedBufferPointerv
glGetNamedBufferSubData
glGetNamedFramebufferAttachmentParameteriv
glGetNamedFramebufferParameteriv
glGetNamedRenderbufferParameteriv
glGetPerfMonitorCounterDataAMD
glGetPerfMonitorCounterInfoAMD
glGetPerfMonitorCounterStringAMD
glGetPerfMonitorCountersAMD
glGetPerfMonitorGroupStringAMD
glGetPerfMonitorGroupsAMD
glGetPixelMapfv
glGetPixelMapuiv
glGetPixelMapusv
glGetPointervRobustANGLERobustANGLE
glGetPolygonStipple
glGetProgramInterfaceivRobustANGLE
glGetProgramResourceLocationIndex
glGetProgramStageiv
glGetProgramivRobustANGLE
glGetQueryBufferObjecti64v
glGetQueryBufferObjectiv
glGetQueryBufferObjectui64v
glGetQueryBufferObjectuiv
glGetQueryIndexediv
glGetQueryObjecti64v
glGetQueryObjecti64vRobustANGLE
glGetQueryObjectiv
glGetQueryObjectivRobustANGLE
glGetQueryObjectui64v
glGetQueryObjectui64vRobustANGLE
glGetQueryObjectuivRobustANGLE
glGetQueryivRobustANGLE
glGetRenderbufferImageANGLE
glGetRenderbufferParameterivOES
glGetRenderbufferParameterivRobustANGLE
glGetSamplerParameterIivRobustANGLE
glGetSamplerParameterIuivRobustANGLE
glGetSamplerParameterfvRobustANGLE
glGetSamplerParameterivRobustANGLE
glGetShaderivRobustANGLE
glGetSubroutineIndex
glGetSubroutineUniformLocation
glGetTexEnvfv
glGetTexEnviv
glGetTexEnvxv
glGetTexGendv
glGetTexGenfv
glGetTexGenfvOES
glGetTexGeniv
glGetTexGenivOES
glGetTexGenxvOES
glGetTexImage
glGetTexImageANGLE
glGetTexLevelParameterfvANGLE
glGetTexLevelParameterfvRobustANGLE
glGetTexLevelParameterivANGLE
glGetTexLevelParameterivRobustANGLE
glGetTexParameterIivRobustANGLE
glGetTexParameterIuivRobustANGLE
glGetTexParameterfvRobustANGLE
glGetTexParameterivRobustANGLE
glGetTexParameterxv
glGetTextureImage
glGetTextureLevelParameterfv
glGetTextureLevelParameteriv
glGetTextureParameterIiv
glGetTextureParameterIuiv
glGetTextureParameterfv
glGetTextureParameteriv
glGetTextureSubImage
glGetTransformFeedbacki64_v
glGetTransformFeedbacki_v
glGetTransformFeedbackiv
glGetTranslatedShaderSourceANGLE
glGetUniformSubroutineuiv
glGetUniformdv
glGetUniformfvRobustANGLE
glGetUniformivRobustANGLE
glGetUniformuivRobustANGLE
glGetVertexArrayIndexed64iv
glGetVertexArrayIndexediv
glGetVertexArrayiv
glGetVertexAttribIivRobustANGLE
glGetVertexAttribIuivRobustANGLE
glGetVertexAttribLdv
glGetVertexAttribPointervRobustANGLE
glGetVertexAttribdv
glGetVertexAttribfvRobustANGLE
glGetVertexAttribivRobustANGLE
glGetnColorTable
glGetnCompressedTexImage
glGetnConvolutionFilter
glGetnHistogram
glGetnMapdv
glGetnMapfv
glGetnMapiv
glGetnMinmax
glGetnPixelMapfv
glGetnPixelMapuiv
glGetnPixelMapusv
glGetnPolygonStipple
glGetnSeparableFilter
glGetnTexImage
glGetnUniformdv
glGetnUniformfvRobustANGLE
glGetnUniformivRobustANGLE
glGetnUniformuivRobustANGLE
glImportMemoryZirconHandleANGLE
glImportSemaphoreZirconHandleANGLE
glIndexMask
glIndexPointer
glIndexd
glIndexdv
glIndexf
glIndexfv
glIndexi
glIndexiv
glIndexs
glIndexsv
glIndexub
glIndexubv
glInitNames
glInterleavedArrays
glInvalidateBufferData
glInvalidateBufferSubData
glInvalidateNamedFramebufferData
glInvalidateNamedFramebufferSubData
glInvalidateTexImage
glInvalidateTexSubImage
glInvalidateTextureANGLE
glIsFramebufferOES
glIsList
glIsRenderbufferOES
glLabelObjectEXT
glLightModelf
glLightModelfv
glLightModeli
glLightModeliv
glLightModelx
glLightModelxv
glLightf
glLightfv
glLighti
glLightiv
glLightx
glLightxv
glLineStipple
glLineWidthx
glListBase
glLoadIdentity
glLoadMatrixd
glLoadMatrixf
glLoadMatrixx
glLoadName
glLoadPaletteFromModelViewMatrixOES
glLoadTransposeMatrixd
glLoadTransposeMatrixf
glLogicOp
glLogicOpANGLE
glLoseContextCHROMIUM
glMap1d
glMap1f
glMap2d
glMap2f
glMapBuffer
glMapGrid1d
glMapGrid1f
glMapGrid2d
glMapGrid2f
glMapNamedBuffer
glMapNamedBufferRange
glMaterialf
glMaterialfv
glMateriali
glMaterialiv
glMaterialx
glMaterialxv
glMatrixIndexPointerOES
glMatrixMode
glMultMatrixd
glMultMatrixf
glMultMatrixx
glMultTransposeMatrixd
glMultTransposeMatrixf
glMultiDrawArrays
glMultiDrawArraysANGLE
glMultiDrawArraysIndirect
glMultiDrawArraysIndirectCount
glMultiDrawArraysInstancedANGLE
glMultiDrawArraysInstancedBaseInstanceANGLE
glMultiDrawElements
glMultiDrawElementsANGLE
glMultiDrawElementsBaseVertex
glMultiDrawElementsIndirect
glMultiDrawElementsIndirectCount
glMultiDrawElementsInstancedANGLE
glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE
glMultiTexCoord1d
glMultiTexCoord1dv
glMultiTexCoord1f
glMultiTexCoord1fv
glMultiTexCoord1i
glMultiTexCoord1iv
glMultiTexCoord1s
glMultiTexCoord1sv
glMultiTexCoord2d
glMultiTexCoord2dv
glMultiTexCoord2f
glMultiTexCoord2fv
glMultiTexCoord2i
glMultiTexCoord2iv
glMultiTexCoord2s
glMultiTexCoord2sv
glMultiTexCoord3d
glMultiTexCoord3dv
glMultiTexCoord3f
glMultiTexCoord3fv
glMultiTexCoord3i
glMultiTexCoord3iv
glMultiTexCoord3s
glMultiTexCoord3sv
glMultiTexCoord4d
glMultiTexCoord4dv
glMultiTexCoord4f
glMultiTexCoord4fv
glMultiTexCoord4i
glMultiTexCoord4iv
glMultiTexCoord4s
glMultiTexCoord4sv
glMultiTexCoord4x
glMultiTexCoordP1ui
glMultiTexCoordP1uiv
glMultiTexCoordP2ui
glMultiTexCoordP2uiv
glMultiTexCoordP3ui
glMultiTexCoordP3uiv
glMultiTexCoordP4ui
glMultiTexCoordP4uiv
glNamedBufferData
glNamedBufferStorage
glNamedBufferStorageExternalEXT
glNamedBufferSubData
glNamedFramebufferDrawBuffer
glNamedFramebufferDrawBuffers
glNamedFramebufferParameteri
glNamedFramebufferReadBuffer
glNamedFramebufferRenderbuffer
glNamedFramebufferTexture
glNamedFramebufferTextureLayer
glNamedRenderbufferStorage
glNamedRenderbufferStorageMultisample
glNewList
glNormal3b
glNormal3bv
glNormal3d
glNormal3dv
glNormal3f
glNormal3fv
glNormal3i
glNormal3iv
glNormal3s
glNormal3sv
glNormal3x
glNormalP3ui
glNormalP3uiv
glNormalPointer
glOrtho
glOrthof
glOrthox
glPassThrough
glPatchParameterfv
glPixelLocalStorageBarrierANGLE
glPixelMapfv
glPixelMapuiv
glPixelMapusv
glPixelStoref
glPixelTransferf
glPixelTransferi
glPixelZoom
glPointParameterf
glPointParameterfv
glPointParameteri
glPointParameteriv
glPointParameterx
glPointParameterxv
glPointSize
glPointSizePointerOES
glPointSizex
glPolygonMode
glPolygonOffsetClamp
glPolygonOffsetClampEXT
glPolygonOffsetx
glPolygonStipple
glPopAttrib
glPopClientAttrib
glPopMatrix
glPopName
glPrimitiveRestartIndex
glPrioritizeTextures
glProgramUniform1d
glProgramUniform1dv
glProgramUniform2d
glProgramUniform2dv
glProgramUniform3d
glProgramUniform3dv
glProgramUniform4d
glProgramUniform4dv
glProgramUniformMatrix2dv
glProgramUniformMatrix2x3dv
glProgramUniformMatrix2x4dv
glProgramUniformMatrix3dv
glProgramUniformMatrix3x2dv
glProgramUniformMatrix3x4dv
glProgramUniformMatrix4dv
glProgramUniformMatrix4x2dv
glProgramUniformMatrix4x3dv
glProvokingVertex
glProvokingVertexANGLE
glPushAttrib
glPushClientAttrib
glPushMatrix
glPushName
glQueryCounter
glQueryMatrixxOES
glRasterPos2d
glRasterPos2dv
glRasterPos2f
glRasterPos2fv
glRasterPos2i
glRasterPos2iv
glRasterPos2s
glRasterPos2sv
glRasterPos3d
glRasterPos3dv
glRasterPos3f
glRasterPos3fv
glRasterPos3i
glRasterPos3iv
glRasterPos3s
glRasterPos3sv
glRasterPos4d
glRasterPos4dv
glRasterPos4f
glRasterPos4fv
glRasterPos4i
glRasterPos4iv
glRasterPos4s
glRasterPos4sv
glReadPixelsRobustANGLE
glReadnPixelsRobustANGLE
glRectd
glRectdv
glRectf
glRectfv
glRecti
glRectiv
glRects
glRectsv
glReleaseTexturesANGLE
glRenderMode
glRenderbufferStorageMultisampleANGLE
glRenderbufferStorageOES
glRequestExtensionANGLE
glRotated
glRotatef
glRotatex
glSampleCoveragex
glSampleMaskiANGLE
glSamplerParameterIivRobustANGLE
glSamplerParameterIuivRobustANGLE
glSamplerParameterfvRobustANGLE
glSamplerParameterivRobustANGLE
glScaled
glScalef
glScalex
glScissorArrayv
glScissorIndexed
glScissorIndexedv
glSecondaryColor3b
glSecondaryColor3bv
glSecondaryColor3d
glSecondaryColor3dv
glSecondaryColor3f
glSecondaryColor3fv
glSecondaryColor3i
glSecondaryColor3iv
glSecondaryColor3s
glSecondaryColor3sv
glSecondaryColor3ub
glSecondaryColor3ubv
glSecondaryColor3ui
glSecondaryColor3uiv
glSecondaryColor3us
glSecondaryColor3usv
glSecondaryColorP3ui
glSecondaryColorP3uiv
glSecondaryColorPointer
glSelectBuffer
glSelectPerfMonitorCountersAMD
glShadeModel
glShaderStorageBlockBinding
glShadingRateQCOM
glSpecializeShader
glTexCoord1d
glTexCoord1dv
glTexCoord1f
glTexCoord1fv
glTexCoord1i
glTexCoord1iv
glTexCoord1s
glTexCoord1sv
glTexCoord2d
glTexCoord2dv
glTexCoord2f
glTexCoord2fv
glTexCoord2i
glTexCoord2iv
glTexCoord2s
glTexCoord2sv
glTexCoord3d
glTexCoord3dv
glTexCoord3f
glTexCoord3fv
glTexCoord3i
glTexCoord3iv
glTexCoord3s
glTexCoord3sv
glTexCoord4d
glTexCoord4dv
glTexCoord4f
glTexCoord4fv
glTexCoord4i
glTexCoord4iv
glTexCoord4s
glTexCoord4sv
glTexCoordP1ui
glTexCoordP1uiv
glTexCoordP2ui
glTexCoordP2uiv
glTexCoordP3ui
glTexCoordP3uiv
glTexCoordP4ui
glTexCoordP4uiv
glTexCoordPointer
glTexEnvf
glTexEnvfv
glTexEnvi
glTexEnviv
glTexEnvx
glTexEnvxv
glTexGend
glTexGendv
glTexGenf
glTexGenfOES
glTexGenfv
glTexGenfvOES
glTexGeni
glTexGeniOES
glTexGeniv
glTexGenivOES
glTexGenxOES
glTexGenxvOES
glTexImage1D
glTexImage2DExternalANGLE
glTexImage2DMultisample
glTexImage2DRobustANGLE
glTexImage3DMultisample
glTexImage3DRobustANGLE
glTexParameterIivRobustANGLE
glTexParameterIuivRobustANGLE
glTexParameterfvRobustANGLE
glTexParameterivRobustANGLE
glTexParameterx
glTexParameterxv
glTexStorage1D
glTexStorage2DMultisampleANGLE
glTexStorageMemFlags2DANGLE
glTexStorageMemFlags2DMultisampleANGLE
glTexStorageMemFlags3DANGLE
glTexStorageMemFlags3DMultisampleANGLE
glTexSubImage1D
glTexSubImage2DRobustANGLE
glTexSubImage3DRobustANGLE
glTextureBarrier
glTextureBuffer
glTextureBufferRange
glTextureParameterIiv
glTextureParameterIuiv
glTextureParameterf
glTextureParameterfv
glTextureParameteri
glTextureParameteriv
glTextureStorage1D
glTextureStorage2D
glTextureStorage2DMultisample
glTextureStorage3D
glTextureStorage3DMultisample
glTextureSubImage1D
glTextureSubImage2D
glTextureSubImage3D
glTextureView
glTransformFeedbackBufferBase
glTransformFeedbackBufferRange
glTranslated
glTranslatef
glTranslatex
glUniform1d
glUniform1dv
glUniform2d
glUniform2dv
glUniform3d
glUniform3dv
glUniform4d
glUniform4dv
glUniformMatrix2dv
glUniformMatrix2x3dv
glUniformMatrix2x4dv
glUniformMatrix3dv
glUniformMatrix3x2dv
glUniformMatrix3x4dv
glUniformMatrix4dv
glUniformMatrix4x2dv
glUniformMatrix4x3dv
glUniformSubroutinesuiv
glUnmapNamedBuffer
glVertex2d
glVertex2dv
glVertex2f
glVertex2fv
glVertex2i
glVertex2iv
glVertex2s
glVertex2sv
glVertex3d
glVertex3dv
glVertex3f
glVertex3fv
glVertex3i
glVertex3iv
glVertex3s
glVertex3sv
glVertex4d
glVertex4dv
glVertex4f
glVertex4fv
glVertex4i
glVertex4iv
glVertex4s
glVertex4sv
glVertexArrayAttribBinding
glVertexArrayAttribFormat
glVertexArrayAttribIFormat
glVertexArrayAttribLFormat
glVertexArrayBindingDivisor
glVertexArrayElementBuffer
glVertexArrayVertexBuffer
glVertexArrayVertexBuffers
glVertexAttrib1d
glVertexAttrib1dv
glVertexAttrib1s
glVertexAttrib1sv
glVertexAttrib2d
glVertexAttrib2dv
glVertexAttrib2s
glVertexAttrib2sv
glVertexAttrib3d
glVertexAttrib3dv
glVertexAttrib3s
glVertexAttrib3sv
glVertexAttrib4Nbv
glVertexAttrib4Niv
glVertexAttrib4Nsv
glVertexAttrib4Nub
glVertexAttrib4Nubv
glVertexAttrib4Nuiv
glVertexAttrib4Nusv
glVertexAttrib4bv
glVertexAttrib4d
glVertexAttrib4dv
glVertexAttrib4iv
glVertexAttrib4s
glVertexAttrib4sv
glVertexAttrib4ubv
glVertexAttrib4uiv
glVertexAttrib4usv
glVertexAttribDivisorANGLE
glVertexAttribI1i
glVertexAttribI1iv
glVertexAttribI1ui
glVertexAttribI1uiv
glVertexAttribI2i
glVertexAttribI2iv
glVertexAttribI2ui
glVertexAttribI2uiv
glVertexAttribI3i
glVertexAttribI3iv
glVertexAttribI3ui
glVertexAttribI3uiv
glVertexAttribI4bv
glVertexAttribI4sv
glVertexAttribI4ubv
glVertexAttribI4usv
glVertexAttribL1d
glVertexAttribL1dv
glVertexAttribL2d
glVertexAttribL2dv
glVertexAttribL3d
glVertexAttribL3dv
glVertexAttribL4d
glVertexAttribL4dv
glVertexAttribLFormat
glVertexAttribLPointer
glVertexAttribP1ui
glVertexAttribP1uiv
glVertexAttribP2ui
glVertexAttribP2uiv
glVertexAttribP3ui
glVertexAttribP3uiv
glVertexAttribP4ui
glVertexAttribP4uiv
glVertexP2ui
glVertexP2uiv
glVertexP3ui
glVertexP3uiv
glVertexP4ui
glVertexP4uiv
glVertexPointer
glViewportArrayv
glViewportIndexedf
glViewportIndexedfv
glWeightPointerOES
glWindowPos2d
glWindowPos2dv
glWindowPos2f
glWindowPos2fv
glWindowPos2i
glWindowPos2iv
glWindowPos2s
glWindowPos2sv
glWindowPos3d
glWindowPos3dv
glWindowPos3f
glWindowPos3fv
glWindowPos3i
glWindowPos3iv
glWindowPos3s
glWindowPos3sv
wglChoosePixelFormat
wglCopyContext
wglCreateContext
wglCreateLayerContext
wglDeleteContext
wglDescribeLayerPlane
wglDescribePixelFormat
wglGetCurrentContext
wglGetCurrentDC
wglGetEnhMetaFilePixelFormat
wglGetLayerPaletteEntries
wglGetPixelFormat
wglGetProcAddress
wglMakeCurrent
wglRealizeLayerPalette
wglSetLayerPaletteEntries
wglSetPixelFormat
wglShareLists
wglSwapBuffers
wglSwapLayerBuffers
wglUseFontBitmaps
wglUseFontBitmapsA
wglUseFontBitmapsW
wglUseFontOutlines
wglUseFontOutlinesA
wglUseFontOutlinesW
Invalid buffer target.
Object cannot be used because it has not been generated.
Textarget must match the texture target type. Requested: %d Texture's: %d label: %s
Cannot have negative start.
Negative count.
Not enough space in bound transform feedback buffers.
Draw framebuffer is incomplete
Integer overflow.
Offset must be a multiple of the passed in datatype.
Negative offset.
No element array buffer and no pointer.
Insufficient buffer size.
Element value exceeds maximum element index.
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
Invalid enum provided.
Cannot have negative stride.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
Client data cannot be used with a non-default vertex array object.
GL_FIXED is not supported in WebGL.
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid type.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
Operation not permitted while pixel local storage is active.
GL_ANDROID_extension_pack_es31a
GL_ANGLE_base_vertex_base_instance_shader_builtin
GL_ANGLE_clip_cull_distance
GL_ANGLE_multi_draw
GL_ANGLE_shader_pixel_local_storage
GL_ANGLE_texture_multisample
GL_APPLE_clip_distance
GL_ARB_texture_rectangle
GL_ARM_shader_framebuffer_fetch
GL_EXT_blend_func_extended
GL_EXT_clip_cull_distance
GL_EXT_draw_buffers
GL_EXT_frag_depth
GL_EXT_geometry_shader
GL_OES_geometry_shader
GL_OES_shader_io_blocks
GL_EXT_shader_io_blocks
GL_EXT_gpu_shader5
GL_EXT_primitive_bounding_box
GL_OES_primitive_bounding_box
GL_EXT_separate_shader_objects
GL_EXT_shader_framebuffer_fetch
GL_EXT_shader_framebuffer_fetch_non_coherent
GL_EXT_shader_non_constant_global_initializers
GL_EXT_shader_texture_lod
GL_EXT_shadow_samplers
GL_EXT_tessellation_shader
GL_EXT_texture_buffer
GL_EXT_texture_cube_map_array
GL_EXT_YUV_target
GL_KHR_blend_equation_advanced
GL_NV_EGL_stream_consumer_external
GL_NV_shader_framebuffer_fetch
GL_NV_shader_noperspective_interpolation
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_OES_sample_variables
GL_OES_shader_multisample_interpolation
GL_OES_shader_image_atomic
GL_OES_standard_derivatives
GL_OES_texture_3D
GL_OES_texture_buffer
GL_OES_texture_cube_map_array
GL_OES_texture_storage_multisample_2d_array
GL_OVR_multiview
GL_OVR_multiview2
GL_WEBGL_video_texture
ANDROID_extension_pack_es31a
ANGLE_base_vertex_base_instance_shader_builtin
ANGLE_clip_cull_distance
ANGLE_multi_draw
ANGLE_shader_pixel_local_storage
ANGLE_texture_multisample
APPLE_clip_distance
ARB_texture_rectangle
ARM_shader_framebuffer_fetch
EXT_blend_func_extended
EXT_clip_cull_distance
EXT_draw_buffers
EXT_frag_depth
EXT_geometry_shader
OES_geometry_shader
OES_shader_io_blocks
EXT_shader_io_blocks
EXT_gpu_shader5
EXT_primitive_bounding_box
OES_primitive_bounding_box
EXT_separate_shader_objects
EXT_shader_framebuffer_fetch
EXT_shader_framebuffer_fetch_non_coherent
EXT_shader_non_constant_global_initializers
EXT_shader_texture_lod
EXT_shadow_samplers
EXT_tessellation_shader
EXT_texture_buffer
EXT_texture_cube_map_array
EXT_YUV_target
KHR_blend_equation_advanced
NV_EGL_stream_consumer_external
NV_shader_framebuffer_fetch
NV_shader_noperspective_interpolation
OES_EGL_image_external
OES_EGL_image_external_essl3
OES_sample_variables
OES_shader_multisample_interpolation
OES_shader_image_atomic
OES_standard_derivatives
OES_texture_3D
OES_texture_buffer
OES_texture_cube_map_array
OES_texture_storage_multisample_2d_array
OVR_multiview
OVR_multiview2
WEBGL_video_texture
require
enable
warn
disable
GL_ARB_shader_bit_encoding
GL_ARB_shading_language_packing
GL_NV_fragment_shader_interlock
GL_INTEL_fragment_shader_ordering
GL_ARB_fragment_shader_interlock
GL_NV_fence
glFenceSync failed to create a GLsync object.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/FenceNVGL.cpp
glClientWaitSync did not return GL_ALREADY_SIGNALED or GL_CONDITION_SATISFIED.
finish
GL_ARB_sync
GL_ARB_texture_rg
GL_EXT_texture_rg
GL_OES_rgb8_rgba8
GL_ARB_texture_rgb10_a2ui
GL_EXT_texture_sRGB
GL_EXT_sRGB
GL_EXT_texture_integer
GL_EXT_texture_norm16
GL_EXT_bgra
GL_EXT_texture_format_BGRA8888
GL_EXT_texture_type_2_10_10_10_REV
GL_EXT_packed_float
GL_EXT_packed_float GL_ARB_color_buffer_float
GL_EXT_color_buffer_float
GL_EXT_texture_shared_exponent
GL_ARB_texture_rg ARB_texture_float
GL_ARB_texture_rg GL_ARB_texture_float GL_ARB_color_buffer_float
GL_OES_texture_half_float GL_EXT_texture_rg
GL_OES_texture_half_float_linear
GL_EXT_texture_storage GL_OES_texture_half_float GL_EXT_texture_rg GL_EXT_color_buffer_half_float
GL_EXT_texture_rg GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_ARB_texture_float
GL_ARB_texture_float GL_ARB_color_buffer_float
GL_OES_texture_half_float
GL_EXT_texture_storage GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_EXT_color_buffer_half_float
GL_ARB_texture_rg GL_ARB_texture_float
GL_OES_texture_float GL_EXT_texture_rg
GL_OES_texture_float_linear
GL_OES_texture_float
GL_ARB_depth_texture
GL_OES_depth_texture
GL_OES_depth32
GL_ARB_depth_buffer_float
GL_EXT_packed_depth_stencil
GL_ARB_framebuffer_object
GL_OES_depth_texture GL_OES_packed_depth_stencil
GL_EXT_texture_sRGB_R8
GL_EXT_texture_sRGB_RG8
GL_ARB_texture_compression_rgtc
GL_EXT_texture_compression_rgtc
GL_ARB_texture_compression_bptc
GL_EXT_texture_compression_bptc
GL_ARB_ES3_compatibility
OES_compressed_EAC_R11_unsigned_texture
OES_compressed_EAC_R11_signed_texture
OES_compressed_EAC_RG11_unsigned_texture
OES_compressed_EAC_RG11_signed_texture
OES_compressed_ETC2_RGB8_texture
OES_compressed_ETC2_sRGB8_texture
OES_compressed_ETC2_punchthroughA_RGBA8_texture
OES_compressed_ETC2_punchthroughA_sRGB8_alpha_texture
OES_compressed_ETC2_RGBA8_texture
OES_compressed_ETC2_sRGB8_alpha8_texture
GL_EXT_texture_compression_s3tc
GL_EXT_texture_compression_dxt1
GL_ANGLE_texture_compression_dxt3
GL_ANGLE_texture_compression_dxt5
GL_EXT_texture_compression_s3tc_srgb
GL_EXT_texture_compression_s3tc GL_NV_sRGB_formats
GL_OES_compressed_ETC1_RGB8_texture
GL_KHR_texture_compression_astc_ldr
GL_OES_texture_compression_astc
GL_IMG_texture_compression_pvrtc
GL_IMG_texture_compression_pvrtc GL_EXT_pvrtc_sRGB
GL_ARB_ES2_compatibility
Framebuffer is incomplete: Framebuffer is surfaceless.
Framebuffer is incomplete: Internal error.
Framebuffer is incomplete: Depth stencil texture in color attachment.
Framebuffer is incomplete: Attachments have inconsistent bit plane counts.
Framebuffer is incomplete: If one attachment is layered, all must be layered.
Framebuffer is incomplete: If an attachments are layered, they must all be the same texture type.
Framebuffer is incomplete: Depth attachment has no depth bits.
Framebuffer is incomplete: Stencil attachment has no stencil bits.
Framebuffer is incomplete: Depth and stencil attachments are not the same.
Framebuffer is incomplete: WebGL depth stencil state is inconsistent.
Framebuffer is incomplete: Depth stencil attachment has no depth bits or no stencil bits.
Framebuffer is incomplete: Stencil attachment has depth bits.
Framebuffer is incomplete: No attachments and default size is zero.
Framebuffer is incomplete: Attachments are not all the same size.
Framebuffer is incomplete: All textures must have fixed samples if paired with multisample renderbuffers.
Framebuffer is incomplete: All attachments must be unique.
Framebuffer is incomplete: Attachment has zero size.
Framebuffer is incomplete: Attachment is not renderable.
Framebuffer is incomplete: Attachment layer is greater than texture layer count.
Framebuffer is incomplete: Attachment depth is greater than MAX_FRAMEBUFFER_LAYERS.
Framebuffer is incomplete: Attachment is an incomplete cube map.
Framebuffer is incomplete: Attachment level is not in the [base level, max level] range.
Framebuffer is incomplete: Attachment level not equal to the base level and the texture is not mipmap complete.
Framebuffer is incomplete: Attachment samples are greater than the maximum supported samples for this format.
Framebuffer is incomplete: Attachments have inconsistent fixed sample locations.
Framebuffer is incomplete: Attachments have different sample counts.
Framebuffer is incomplete: Depth stencil sample count must be divisible by the color sample count.
Framebuffer is incomplete: Attachments have inconsistent multiview enabled state.
Framebuffer is incomplete: Attachments have inconsistent multiview view counts.
Framebuffer is incomplete: Attachments have inconsistent multiview base view.
glReadPixels: GL_IMPLEMENTATION_COLOR_READ_FORMAT advertised by the driver is not handled by RGBA16 readPixels workaround.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/FramebufferGL.cpp
readPixels
checkStatus
GL framebuffer returned incomplete: 
Framebuffer is incomplete: Driver does not support this framebuffer configuration.
readPixelsRowByRow
readPixelsAllAtOnce
Initialize
RearrangeEXTTextureNorm16Pixels
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/FrameBufferMtl.mm
Framebuffer is incomplete: Mismatched attachment sizes are unsupported.
Framebuffer is incomplete: Separate depth and stencil buffers are unsupported.
Framebuffer is incomplete: The total number of color bits exceeds the number of output bits supported.
checkPackedDepthStencilAttachment
Packed depth stencil texture/buffer must not be mixed with other texture/buffer.
readPixelsImpl
readPixelsToPBO
readPixelsToBuffer
v8@?0
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/FunctionsEAGL.mm
OpenGLESLibrary_block_invoke
! Assert failed in 
frameworkLibrary
! Message: 
Unable to load OpenGLES.framework
EAGLContext
initEAGLContext_block_invoke
classEAGLContext
objc_getClass failed for EAGLContext
Missing shader object
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/GLES1Renderer.cpp
compileShader
Internal GLES 1 shader compile failed. Info log: 
GLES1Renderer shader compile failed.
Missing program object
linkProgram
Internal GLES 1 shader link failed. Info log: 
GLES1Renderer program link failed.
#define 
const int 
[kMaxTexUnits] = int[kMaxTexUnits](
bool 
[kMaxTexUnits] = bool[kMaxTexUnits](
[kMaxLights] = bool[kMaxLights](
[kMaxClipPlanes] = bool[kMaxClipPlanes](
enable_lighting
enable_color_material
enable_draw_texture
point_rasterization
enable_rescale_normal
enable_normalize
light_model_two_sided
light_enables
enable_fog
enable_clip_planes
point_sprite_enabled
enable_alpha_test
shade_model_flat
enable_texture_2d
enable_texture_cube_map
texture_format
point_sprite_coord_replace
clip_plane_enables
texture_env_mode
combine_rgb
combine_alpha
src0_rgb
src0_alpha
src1_rgb
src1_alpha
src2_rgb
src2_alpha
op0_rgb
op0_alpha
op1_rgb
op1_alpha
op2_rgb
op2_alpha
alpha_func
fog_mode
#extension GL_EXT_shader_framebuffer_fetch : require
#extension GL_EXT_shader_framebuffer_fetch_non_coherent : require
texcoord
projection
modelview
texture_matrix
modelview_invtr
tex_sampler
tex_cube_sampler
texture_env_color
texture_env_rgb_scale
texture_env_alpha_scale
alpha_test_ref
material_ambient
material_diffuse
material_specular
material_emissive
material_specular_exponent
light_model_scene_ambient
light_ambients
light_diffuses
light_speculars
light_positions
light_directions
light_spotlight_exponents
light_spotlight_cutoff_angles
light_attenuation_consts
light_attenuation_linears
light_attenuation_quadratics
fog_density
fog_start
fog_end
fog_color
clip_planes
logic_op
point_size_min
point_size_max
point_distance_attenuation
draw_texture_coords
draw_texture_dims
draw_texture_normalized_crop_rect
GL_KHR_blend_equation_advanced
GL_OES_compressed_EAC_R11_signed_texture
GL_OES_compressed_EAC_R11_unsigned_texture
GL_OES_compressed_EAC_RG11_signed_texture
GL_OES_compressed_EAC_RG11_unsigned_texture
GL_EXT_compressed_ETC1_RGB8_sub_texture
GL_OES_compressed_ETC2_punchthroughA_RGBA8_texture
GL_OES_compressed_ETC2_punchthroughA_sRGB8_alpha_texture
GL_OES_compressed_ETC2_RGB8_texture
GL_OES_compressed_ETC2_RGBA8_texture
GL_OES_compressed_ETC2_sRGB8_alpha8_texture
GL_OES_compressed_ETC2_sRGB8_texture
GL_OES_compressed_paletted_texture
GL_OES_depth24
GL_NV_depth_buffer_float2
GL_ANGLE_depth_texture
GL_OES_depth_texture_cube_map
GL_EXT_EGL_image_array
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_EXT_EGL_image_external_wrap_modes
GL_EXT_EGL_image_storage
GL_NV_EGL_stream_consumer_external
GL_OES_EGL_sync
GL_OES_element_index_uint
GL_EXT_external_buffer
GL_OES_fbo_render_mipmap
GL_EXT_float_blend
GL_EXT_frag_depth
GL_ANGLE_framebuffer_blit
GL_MESA_framebuffer_flip_y
GL_ANGLE_instanced_arrays
GL_EXT_multisample_compatibility
GL_EXT_multisampled_render_to_texture2
GL_KHR_no_error
GL_OES_packed_depth_stencil
GL_ANGLE_pack_reverse_row_order
GL_NV_pack_subimage
GL_AMD_performance_monitor
GL_NV_pixel_buffer_object
GL_EXT_polygon_offset_clamp
GL_EXT_protected_textures
GL_EXT_pvrtc_sRGB
GL_NV_read_depth
GL_NV_read_depth_stencil
GL_EXT_read_format_bgra
GL_NV_read_stencil
GL_KHR_robust_buffer_access_behavior
GL_NV_robustness_video_memory_purge
GL_EXT_shader_framebuffer_fetch
GL_OES_shader_io_blocks
GL_EXT_shader_non_constant_global_initializers
GL_NV_shader_noperspective_interpolation
GL_EXT_shader_texture_lod
GL_QCOM_shading_rate
GL_EXT_shadow_samplers
GL_EXT_sRGB_write_control
GL_OES_standard_derivatives
GL_OES_surfaceless_context
GL_ARB_sync
GL_KHR_texture_compression_astc_hdr
GL_KHR_texture_compression_astc_sliced_3d
GL_IMG_texture_compression_pvrtc2
GL_OES_texture_cube_map_array
GL_EXT_texture_filter_anisotropic
GL_EXT_texture_format_sRGB_override
GL_OES_texture_half_float
GL_OES_texture_npot
GL_EXT_texture_sRGB_decode
GL_OES_texture_stencil8
GL_ANGLE_texture_usage
GL_ANGLE_translated_shader_source
GL_EXT_unpack_subimage
GL_OES_vertex_half_float
GL_OES_vertex_type_10_10_10_2
GL_WEBGL_video_texture
GL_EXT_YUV_target
GL_ANGLE_base_vertex_base_instance
GL_ANGLE_base_vertex_base_instance_shader_builtin
GL_CHROMIUM_bind_generates_resource
GL_CHROMIUM_bind_uniform_location
GL_ANGLE_client_arrays
GL_CHROMIUM_color_buffer_float_rgb
GL_CHROMIUM_color_buffer_float_rgba
GL_ANGLE_compressed_texture_etc
GL_CHROMIUM_copy_compressed_texture
GL_CHROMIUM_copy_texture
GL_ANGLE_copy_texture_3d
GL_CHROMIUM_framebuffer_mixed_samples
GL_ANGLE_framebuffer_multisample
GL_ANGLE_get_image
GL_ANGLE_get_serialized_context_string
GL_ANGLE_get_tex_level_parameter
GL_ANGLE_logic_op
GL_CHROMIUM_lose_context
GL_ANGLE_lossy_etc_decode
GL_ANGLE_memory_object_flags
GL_ANGLE_memory_object_fuchsia
GL_ANGLE_memory_size
GL_ANGLE_multi_draw
GL_ANGLE_multiview_multisample
GL_ANGLE_program_binary
GL_ANGLE_program_cache_control
GL_ANGLE_provoking_vertex
GL_ANGLE_read_only_depth_stencil_feedback_loops
GL_ANGLE_relaxed_vertex_attribute_type
GL_ANGLE_request_extension
GL_ANGLE_rgbx_internal_format
GL_ANGLE_robust_client_memory
GL_ANGLE_robust_fragment_shader_output
GL_ANGLE_robust_resource_initialization
GL_ANGLE_semaphore_fuchsia
GL_ANGLE_shader_pixel_local_storage
GL_ANGLE_shader_pixel_local_storage_coherent
GL_CHROMIUM_sync_query
GL_ANGLE_texture_external_update
GL_CHROMIUM_texture_filtering_hint
GL_ANGLE_texture_multisample
GL_ANGLE_texture_rectangle
GL_ANGLE_vulkan_image
GL_ANGLE_webgl_compatibility
GL_ANGLE_yuv_internal_format
GL_OES_draw_texture
GL_OES_framebuffer_object
GL_OES_matrix_palette
GL_OES_point_size_array
GL_OES_point_sprite
GL_OES_query_matrix
GL_OES_texture_cube_map
Context has been lost.
v8@?0
Illegal character at fieldname start
fatal flex scanner internal error--no action found
out of dynamic memory in yy_create_buffer()
yyset_column called with no buffer
GL_FRAGMENT_PRECISION_HIGH
fatal flex scanner internal error--end of buffer missed
fatal error - scanner input buffer overflow
out of dynamic memory in yy_get_next_buffer()
Input buffer overflow
out of dynamic memory in yyensure_buffer_stack()
Illegal use of reserved word
Unsigned integers are unsupported prior to GLSL ES 3.00
Integer overflow
Floating-point suffix unsupported prior to GLSL ES 3.00
Float overflow
unsupported value
methods supported in GLSL ES 3.00 and above only
bit-wise operator supported in GLSL ES 3.00 and above only
integer modulus operator supported in GLSL ES 3.00 and above only
interface blocks supported in GLSL ES 3.00 and above only
cannot be a parameter type except for '(void)'
void
first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
unsupported interpolation qualifier
noperspective
layout
 supported in vertex shaders only
 supported in GLSL ES 1.00 only
storage qualifier supported in GLSL ES 3.00 and above only
centroid
unsupported storage qualifier
patch
storage qualifier supported in GLSL ES 3.10 and above only
buffer
 supported in compute shaders only
shared
sample
implicitly sized array supported in GLSL ES 3.00 and above only
arrays of arrays supported in GLSL ES 3.10 and above only
unsupported type
yuvCscStandardEXT
__samplerCubeArray
__samplerBuffer
__isamplerCubeArray
__isamplerBuffer
__usamplerCubeArray
__usamplerBuffer
__samplerCubeArrayShadow
samplerVideoWEBGL
__samplerExternal2DY2YEXT
__imageCubeArray
__iimageCubeArray
__uimageCubeArray
__imageBuffer
__iimageBuffer
__uimageBuffer
__pixelLocalANGLE
__ipixelLocalANGLE
__upixelLocalANGLE
syntax error
memory exhausted
itu_601
itu_601_full_range
itu_709
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/HandleAllocator.cpp
allocate
HandleAllocator::allocate reusing 
HandleAllocator::allocate allocating 
release
HandleAllocator::release releasing 
reserve
HandleAllocator::reserve reserving 
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ImageMtl.mm
ValidateClientBuffer
Unrecognized format
WARNING: 
ERROR: 
UNKOWN ERROR: 
invariant 
readonly 
writeonly 
coherent 
restrict 
volatile 
array[
] of 
 matrix of 
-component vector of 
 <anonymous>
 (specifier)
Temporary
Global
const
uniform
inout
VertexID
Position
PointSize
DrawID
FragCoord
FrontFacing
HelperInvocation
PointCoord
FragColor
FragData
FragDepth
SecondaryFragColorEXT
SecondaryFragDataEXT
ViewIDOVR
ViewportIndex
LayerOut
LayerIn
LastFragColor
LastFragData
smooth out
smooth centroid out
flat out
noperspective out
smooth in
flat in
noperspective in
smooth centroid in
flat
smooth
NumWorkGroups
WorkGroupSize
WorkGroupID
LocalInvocationID
GlobalInvocationID
LocalInvocationIndex
readonly
writeonly
gl_PrimitiveIDIn
gl_InvocationID
gl_PrimitiveID
precise
ClipDistance
CullDistance
sample in
sample out
SampleID
SamplePosition
SampleMaskIn
SampleMask
NumSamples
patch in
patch out
PatchVerticesIn
TessLevelOuter
TessLevelInner
BoundingBox
TessCoord
__pixel_localEXT
unknown qualifier
mediump
lowp
casting a negative float to uint is undefined
Zero divided by zero during constant folding generated NaN
Divide by zero during constant folding
Infinity divided by infinity during constant folding generated NaN
Constant folded division overflowed to infinity
Divide by zero error during constant folding
Negative modulus operator operand encountered during constant folding. Results are undefined.
operation result is undefined for the values passed in
instanceIdMod
gl_VertexID
Failed to set pixel unpack state.
Failed to set pixel pack state.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/IOSurfaceSurfaceEAGL.mm
attachToFramebuffer
IOSurfaces with OpenGL ES not supported on iOS Simulator
Failed to initialize IOSurface alpha channel.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/IOSurfaceSurfaceMtl.mm
ValidateAttributes
IOSurface bytes per elements does not match the pbuffer internal format.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/image_util/loadimage_astc.cpp
LoadASTCToRGBA8Inner
Trying to decompress ASTC without having ASTC support built.
ASTC decompression failed: 
Error decompressing program binary data fetched from cache.
Failed to load program binary from cache.
Error compressing binary data.
Error decompressing shader binary data from cache.
GPU.ANGLE.ShaderCache.LoadBinarySuccess
Error compressing shader binary data for insertion into cache.
GPU.ANGLE.ShaderCache.ShaderBinarySizeBytes
originalToModified
modifiedToOriginal
original
modified
flatten
v16@?0@"<MTLCommandBuffer>"8
Invalid ASCII string
Metal backend encountered an error
Metal backend encountered an error: 
[[attribute(
        
ANGLE_
xfbBuffer
.ANGLE_xfbBufferOffsets[
] + (gl_VertexID + (ANGLE_instanceIdMod - ANGLE_baseInstance) * 
.ANGLE_xfbVerticesPerInstance) * 
] = 
ANGLE_vertexOut.
device float* ANGLE_
#if TRANSFORM_FEEDBACK_ENABLED
    {
    }
#endif
OcclusionQueryPool
clearIntFS
clearUIntFS
clearFloatFS
blitIntFS
blitUIntFS
blitFloatFS
copyTextureFloatToUIntFS
readFromBufferToIntTexture
writeFromIntTextureToBuffer
readFromBufferToUIntTexture
writeFromUIntTextureToBuffer
readFromBufferToFloatTexture
writeFromFloatTextureToBuffer
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_render_utils.mm
handleError
clearVS
kNumColorOutputs
blitVS
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
blitDepthStencilFS
blitDepthFS
blitStencilFS
kSourceTexture2Type
blitStencilToBufferCS
kSourceBufferAligned
convertIndexU8ToU16
convertIndexU16
convertIndexU32
kSourceIndexIsU8
kSourceIndexIsU16
kSourceIndexIsU32
genTriFanIndicesFromArray
genLineLoopIndicesFromArray
Index offset is too large
generateTriFanBufferFromElementsArray
genTriFanIndicesFromElements
generateLineLoopBufferFromElementsArray
genLineLoopIndicesFromElements
generateLineLoopLastSegmentFromElementsArray
kCombineWithExistingResult
combineVisibilityResult
generate3DMipmaps
generate2DMipmaps
generate2DArrayMipmaps
generateCubeMipmaps
kCopyFormatType
kCopyTextureType
expandVertexFormatComponentsCS
expandVertexFormatComponentsVS
convertToFloatVertexFormatCS
convertToFloatVertexFormatVS
EnsureSpecializedComputePipelineInitialized
EnsureComputePipelineInitialized
EnsureSpecializedVertexShaderOnlyPipelineCacheInitialized
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_resources.mm
MakeTexture
resize
MakeBufferWithSharedMemOpt
MakeBufferWithResOpt
Render pipeline without vertex shader is invalid.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_state_cache.mm
createRenderPipelineState
createComputePipelineState
Render pipeline requires at least one render target for this device.
ValidateRenderPipelineState
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_utils.mm
Failed to create a scratch index buffer for GL_TRIANGLE_FAN, too many indices required.
TriangleFanBoundCheck
Internal error compiling Metal shader:
CreateMslShader
Apple
Radeon
Intel
Geforce
Quadro
main
.length()
textureVideoWEBGL
gl_FragDepthEXT
webgl_FragColor
webgl_FragData
gl_SecondaryFragColorEXT
webgl_SecondaryFragColor
gl_SecondaryFragDataEXT
webgl_SecondaryFragData
texture2DGradARB
texture2DProjGradARB
textureCubeGradARB
texture3DProj
shadow2DEXT
shadow2DProjEXT
precise 
uintBitsToFloat(
index = 
noncoherent
offset = 
layout(
location = 
binding = 
column_major
row_major
 += 
 -= 
 /= 
 %= 
 *= 
 <<= 
 >>= 
 &= 
 ^= 
 |= 
 << 
 >> 
 == 
 != 
 <= 
 >= 
 || 
 ^^ 
 && 
).length())
) ? (
) : (
case (
discard
return 
#define
#endif
#ifdef
packed
std140
std430
smooth out 
flat out 
noperspective out 
centroid out 
smooth in 
flat in 
noperspective in 
centroid in 
#pragma STDGL invariant(all)
layout (
invocations = 
) in;
max_vertices = 
) out;
layout (early_fragment_tests) in;
layout (local_size_x=
, local_size_y=
, local_size_z=
#if defined(GL_ARB_shader_viewport_layer_array)
#extension GL_ARB_shader_viewport_layer_array : require
#elif defined(GL_NV_viewport_array2)
#extension GL_NV_viewport_array2 : require
#endif
#extension GL_OVR_multiview
layout(num_views=
rgba32f
rgba16f
rgba32ui
rgba16ui
r32ui
rgba32i
rgba16i
rgba8i
r32i
rgba8
rgba8_snorm
unknown internal image format
unknown color space conversion standard
points
lines
triangles
lines_adjacency
triangles_adjacency
line_strip
triangle_strip
unknown geometry shader primitive type
(symbol id 
const bool
 (const float)
 (const int)
 (const uint)
 (const yuvCscStandardEXT)
Unknown constant
vector swizzle (
comma
move second child to first child
initialize first child with second child
add second child into first child
subtract second child into first child
multiply second child into first child
matrix mult second child into first child
vector scale second child into first child
matrix scale second child into first child
divide second child into first child
modulo second child into first child
bit-wise shift first child left by second child
bit-wise shift first child right by second child
bit-wise and second child into first child
bit-wise xor second child into first child
bit-wise or second child into first child
direct index
indirect index
direct index for structure
direct index for interface block
subtract
component-wise multiply
divide
modulo
bit-wise shift left
bit-wise shift right
bit-wise and
bit-wise xor
bit-wise or
Compare Equal
Compare Not Equal
Compare Less Than
Compare Greater Than
Compare Less Than or Equal
Compare Greater Than or Equal
vector-scale
vector-times-matrix
matrix-times-vector
matrix-scale
matrix-multiply
logical-or
logical-xor
logical-and
<unknown op>
 (field '
Negate value
Positive sign
negation
bit-wise not
Post-Increment
Post-Decrement
Pre-Increment
Pre-Decrement
Array length
component-wise not
Call a built-in function
 (internal function)
 (symbol id 
Ternary selection
Condition
true case
false case
If test
true case is null
Switch
Default
Case
Function Prototype
parameter: 
Function Definition:
node is still EOpNull!
Call a user-defined function
Call an internal function with raw implementation
Construct
component-wise equal
component-wise not equal
component-wise less than
component-wise greater than
component-wise less than or equal
component-wise greater than or equal
dot product
cross product
Code block
Precise Declaration:
Invariant Declaration:
Declaration
Loop with condition 
not 
tested first
Loop Condition
No loop condition
Loop Body
No loop body
Loop Terminal Expression
Branch: Kill
Branch: Break
Branch: Continue
Branch: Return
Branch: Unknown Branch
 with expression
Vertex
Tessellation control
Tessellation evaluation
Geometry
Fragment
Compute
GL_INVALID_ENUM
GL_VERTEX_SHADER
GL_TESS_CONTROL_SHADER_EXT
GL_TESS_EVALUATION_SHADER_EXT
GL_GEOMETRY_SHADER_EXT
GL_FRAGMENT_SHADER
GL_COMPUTE_SHADER
extension is not supported
extension is disabled
extension is being used
illegal vector field selection
vector field selection out of range
illegal - vector component fields not from the same set
illegal discard when pixel local storage is declared
discard
illegal return from main when pixel local storage is declared
return
value not assignable when pixel local storage is declared
gl_SampleMask
cannot convert from '
' to '
wrong operand type - no operation '
' exists that takes an operand of type 
 (or there is no acceptable conversion)
wrong operand types - no operation '
' exists that takes a left-hand operand of type '
' and a right operand of type '
' (or there is no acceptable conversion)
illegal type for precision qualifier
No precision specified for (float)
No precision specified (int)
No precision specified
 l-value of swizzle cannot have duplicate components
can't modify a readonly variable
 l-value required
can't modify a const
can't modify an attribute
can't modify an input
can't modify a uniform
can't modify a varying
can't modify gl_FragCoord
can't modify gl_FrontFacing
can't modify gl_HelperInvocation
can't modify gl_PointCoord
can't modify gl_NumWorkGroups
can't modify gl_WorkGroupSize
can't modify gl_WorkGroupID
can't modify gl_LocalInvocationID
can't modify gl_GlobalInvocationID
can't modify gl_LocalInvocationIndex
can't modify gl_ViewID_OVR
can't modify work group size variable
can't modify any member in gl_in
can't modify gl_PrimitiveIDIn
can't modify gl_InvocationID
can't modify gl_PrimitiveID in a fragment shader
can't modify gl_Layer in a fragment shader
can't modify gl_SampleID
can't modify gl_SampleMaskIn
can't modify gl_SamplePosition
can't modify gl_ClipDistance in a fragment shader
can't modify gl_CullDistance in a fragment shader
can't modify void
can't modify a variable with type 
l-value required
constant expression required
integer expression required
only allowed at global scope
reserved built-in name
webgl_
_webgl_
identifiers containing two consecutive underscores (__) are reserved as possible future keywords
all identifiers containing two consecutive underscores (__) are reserved - unintented behaviors are possible
constructor does not have any arguments
constructor
cannot convert a variable with type 
cannot convert a variable with writeonly
cannot convert a void
array constructor needs one argument per array element
constructing from a non-dereferenced array
Array constructor argument has an incorrect type
Number of constructor parameters does not match the number of structure fields
Structure constructor arguments do not match structure fields
a struct cannot be used as a constructor argument for this type
constructing matrix from matrix can only take one argument
not enough data provided for construction
too many arguments
illegal use of type 'void'
boolean expression expected
 (structure contains a sampler)
location must only be specified for a single input or output variable
location
invalid layout qualifier: only valid on program inputs and outputs
invalid layout qualifier: only valid on shader inputs, outputs, and uniforms
The std430 layout is supported only for shader storage blocks.
opaque types cannot be output parameters
array size must be a constant integer expression
array size must be non-negative
array size must be greater than zero
array size too large
cannot declare arrays of this qualifier
cannot declare arrays of arrays
vertex shader output cannot be an array of arrays
fragment shader input cannot be an array of arrays
fragment shader output cannot be an array of arrays
cannot declare arrays of structs of this qualifier
structures containing arrays may not be declared constant since they cannot be initialized
variables with qualifier 'const' must be initialized
implicitly sized arrays only allowed for tessellation shaders or geometry shader inputs
If index layout qualifier is specified for a fragment output, location must also be specified.
index
gl_LastFragData
gl_MaxDrawBuffers
redeclaration of gl_LastFragData as an array of arrays
redeclaration of gl_LastFragData with size != gl_MaxDrawBuffers
gl_ClipDistance
gl_MaxClipDistances
redeclaration of gl_ClipDistance as an array of arrays
redeclaration of gl_ClipDistance with size > gl_MaxClipDistances
gl_CullDistance
gl_MaxCullDistances
redeclaration of gl_CullDistance as an array of arrays
redeclaration of gl_CullDistance with size > gl_MaxCullDistances
gl_Position
gl_Position can only be redeclared as vec4
gl_PointSize
gl_PointSize can only be redeclared as float
When EXT_separate_shader_objects is enabled, both gl_Position and gl_PointSize must be redeclared before either is used
redefinition
Shared memory declarations cannot have layout specified
layout
layout qualifier only valid for interface blocks
invalid layout qualifier combination
storage qualifier supported in GLSL ES 3.00 and above only
Can only be highp
atomic counter
location must not be set for atomic_uint
no binding specified
empty array declaration needs to specify a size
cannot be used with a structure
cannot declare buffer variables at global scope(outside a block)
s must be uniform
cannot be used with a yuvCscStandardEXT
internal image format requires a floating image type
internal image format requires an integer image type
internal image format requires an unsigned image type
layout qualifier
No image internal format specified
unrecognized token
Except for images with the r32f, r32i and r32ui format qualifiers, image variables must be qualified readonly and/or writeonly
undefined use of pixel local storage outside a fragment shader
pixel local storage format requires pixelLocalANGLE
pixel local storage format requires ipixelLocalANGLE
pixel local storage format requires upixelLocalANGLE
illegal pixel local storage format
pixel local storage requires a format specifier
qualifier supported in GLSL ES 3.00 and above only
invalid layout qualifier: not supported
invalid layout qualifier: only valid when used with 'in' in a compute shader global layout declaration
invalid layout qualifier: not supported before GLSL ES 3.10, except pixel local storage
invalid layout qualifier: not supported before GLSL ES 3.10
invalid layout qualifier: only valid when used with images or pixel local storage 
invalid layout qualifier: only valid when used with images
invalid layout qualifier: only valid when used with a fragment shader output in ESSL version >= 3.00 and EXT_blend_func_extended is enabled
invalid layout qualifier: only valid when used with pixel local storage
binding
invalid layout qualifier: only valid when used with opaque types or blocks
invalid layout qualifier: only valid when used with atomic counters
offset
image binding greater than gl_MaxImageUnits
sampler binding greater than maximum texture units
uniform block binding greater than MAX_UNIFORM_BUFFER_BINDINGS
shader storage block binding greater than MAX_SHADER_STORAGE_BUFFER_BINDINGS
atomic counter binding greater than gl_MaxAtomicCounterBindings
pixel local storage handles cannot be aggregated in arrays
array
pixel local storage requires a binding index
duplicate pixel local storage binding index
Uniform location out of range
Attribute location out of range
invalid layout qualifier: only valid on program outputs
invalid layout qualifier: only valid when used with 'in' in a fragment shader
early_fragment_tests
'noncoherent' qualifier must be used when GL_EXT_shader_framebuffer_fetch_non_coherent extension is used
invalid layout qualifier: only valid when used with 'gl_LastFragData' or the variable decorated with 'inout' in a fragment shader
gl_InvocationID
tessellation-control per-vertex output l-value must be indexed with gl_InvocationID
Writeonly value cannot be passed for 'in' or 'inout' parameters.
assign
Constant value cannot be passed for 'out' or 'inout' parameters.
Cannot be qualified as invariant.
invariant
invalid layout qualifier: blending equation qualifiers are only permitted on the fragment 'out' qualifier 
blend_support_qualifier
undeclared identifier
variable expected
It is an error to use gl_WorkGroupSize before declaring the local group size
gl_WorkGroupSize
invalid or missing storage qualifier
assigning non-constant to '
global variable initializers must be constant expressions
global variable initializers should be constant expressions (uniforms and globals are allowed in global initializers for legacy compatibility)
 cannot initialize this type of qualifier 
not supported
first-class array
cannot be bool or int
'in' can be only used to specify the local group size
cannot be bool
cannot be array
cannot be matrix
must use 'flat' interpolation here
cannot be an array of structures
cannot be a structure containing an array
cannot be a structure containing a structure
cannot be a structure containing a bool
Local variables can only use the const storage qualifier.
Only allowed with shader storage blocks, variables declared within shader storage blocks and variables declared as image types.
coherent
restrict
volatile
Offset overlapping
Offset must be multiple of 4
Missing a valid input primitive declaration before declaring an unsized array input
Deferred
Geometry shader input variable must be declared as an array
Tessellation interface variables must be declared as an array
If a size is specified for a tessellation control or evaluation user-defined input variable, it must match the maximum patch size (gl_MaxPatchVertices).
If a size is specified for a tessellation control user-defined per-vertex output variable, it must match the the number of vertices in the output patch.
Expected invariant or precise
invariant varying
undeclared identifier declared as invariant or precise
invariant or precise declaration specifies qualifier
invariant or precise declaration specifies precision
invariant or precise declaration specifies layout
'layout'
Requires both binding and offset
precision is not supported in fragment shader
highp
illegal type argument for default precision qualifier
Array size or input primitive declaration doesn't match the size of earlier sized array inputs.
max_vertices can only be declared in 'out' layout in a geometry shader
invalid primitive type for 'in' layout
primitive doesn't match earlier input primitive declaration
invocations contradicts to the earlier declaration
invocations can only be declared in 'in' layout in a geometry shader
invalid primitive type for 'out' layout
primitive doesn't match earlier output primitive declaration
max_vertices contradicts to the earlier declaration
No vertices specified
Duplicated vertices specified
Duplicated primitive type declaration
Duplicated vertex spacing declaration
Duplicated ordering declaration
Duplicated point type declaration
Error during layout qualifier parsing.
Work group size does not match the previous declaration
in type qualifier supported in GLSL ES 3.10 only
No local work group size specified
gl_MaxComputeWorkGroupSize
invalid value: Value must be at least 1 and no greater than 
out type qualifier supported in GLSL ES 3.10 only
Number of views does not match the previous declaration
No num_views specified
num_views greater than the value of GL_MAX_VIEWS_OVR
in type qualifier without variable declaration supported in GLSL ES 3.10 and after
only early_fragment_tests is allowed as layout qualifier when not declaring a variable
out type qualifier without variable declaration is supported in GLSL ES 3.20, or if GL_KHR_blend_equation_advanced is enabled
only blend equations are allowed as layout qualifier when not declaring a variable
out type qualifier supported in GLSL ES 3.10 and after
in type qualifier supported in GLSL ES 3.10 and after
invalid qualifier: global layout can only be set for blocks
layout qualifiers supported in GLSL ES 3.00 and after
function parameter array must be sized at compile time
duplicate function prototype declarations are not allowed
function
local function prototype declarations are not allowed
function does not return a value:
function already has a body
Function parameter type cannot be a structure definition
Name of a built-in function cannot be redeclared as function
built-in functions cannot be redefined
function must have the same return type in all of its declarations
function must have the same parameter qualifiers in all of its declarations
redefinition of a function
function cannot take any parameter(s)
main
main function cannot return a value
no qualifiers allowed for function return
s can't be function return values
structures containing arrays can't be function return values
array constructor supported in GLSL ES 3.00 and above only
constructor can't be a structure definition
cannot construct this type
function parameter array must specify a size
implicitly sized array constructor must have at least one argument
implicitly sized array of arrays constructor argument is not an array
implicitly sized array of arrays constructor argument dimensionality is too low
invalid qualifier: interface blocks must be uniform in version lower than GLSL ES 3.10
invalid qualifier: 'patch out' requires a tessellation control shader
invalid qualifier: 'patch in' requires a tessellation evaluation shader
invalid qualifier: shader IO blocks need shader io block extension
type must be an array
invalid qualifier: interface blocks must be uniform or buffer
invalid qualifier on interface block
unsized arrays are not allowed with interface blocks
array of arrays are not allowed with interface blocks
geometry shader input block array size inconsistent with primitive
array of arrays are not allowed with I/O blocks
geometry shader input blocks must be an array
unsupported type - 
 types are not allowed in interface blocks
invalid qualifier on shader storage block member
invalid qualifier on uniform block member
invalid qualifier on interface block member
invalid layout qualifier: cannot be used here
extraneous layout qualifier: only has an effect on matrix types
array members of interface blocks must specify a size
redefinition of an interface block name
redefinition in an invalid interface block
redefinition of an interface block member name
redefinition of an interface block instance name
Embedded struct definitions are not allowed
struct
Struct nesting
Reference of struct type 
 exceeds maximum allowed nesting level of 
 left of '[' is not of type array, matrix, or vector 
expression
missing input primitive declaration before indexing gl_in.
array indexes for uniform block arrays must be constant integral expressions
array indexes for shader storage block arrays must be constant integral expressions
array indexes for fragment outputs must be constant integral expressions
array index for gl_FragData must be constant zero
array index for samplers must be constant integral expressions
array indexes for image arrays must be constant integral expressions
index expression is negative
array index for gl_FragData must be zero when GL_EXT_draw_buffers is disabled
array index out of range
matrix field selection out of range
cannot apply dot operator to an array
structure has no fields
Internal Error
 no such field in structure
interface block has no fields
 no such field in interface block
 field selection requires structure or vector on left hand side
 field selection requires structure, vector, or interface block on left hand side
Only std140 layout is allowed in WebGL
invalid layout qualifier: location requires an argument
points
lines
lines_adjacency
triangles
triangles_adjacency
line_strip
triangle_strip
invalid layout qualifier
quads
isolines
equal_spacing
fractional_even_spacing
fractional_odd_spacing
point_mode
blend_support_multiply
blend_support_screen
blend_support_overlay
blend_support_darken
blend_support_lighten
blend_support_colordodge
blend_support_colorburn
blend_support_hardlight
blend_support_softlight
blend_support_difference
blend_support_exclusion
blend_support_hsl_hue
blend_support_hsl_saturation
blend_support_hsl_color
blend_support_hsl_luminosity
blend_support_all_equations
out of range: 
 must be positive
out of range: num_views must be positive
out of range: invocations must be in the range of [1, MAX_GEOMETRY_SHADER_INVOCATIONS_OES]
out of range: max_vertices must be in the range of [0, gl_MaxGeometryOutputVertices]
out of range : vertices must be in the range of [1, gl_MaxPatchVertices]
out of range: index layout qualifier can only be 0 or 1
out of range: location must be non-negative
out of range: binding must be non-negative
out of range: offset must be non-negative
local_size_x
local_size_y
local_size_z
num_views
invocations
max_vertices
vertices
storage qualifier isn't supported in compute shaders
inout
storage qualifier isn't supported in non-fragment shaders
invalid qualifier: can be used with either function parameters or the variables for fetching input attachment data
duplicate field name in structure
redefinition of a struct
invalid qualifier on struct member
disallowed type in struct
array members of structs must specify a size
init-expression in a switch statement must be a scalar integer
switch
case labels need to be inside switch statements
case
case label must have a condition
case label must be a scalar integer
case label must be constant
default labels need to be inside switch statements
default
Invalid operation for variables with an opaque type
Invalid operation for variables with writeonly
Invalid operation for structs
Invalid operation for interface blocks
array / non-array mismatch
Invalid operation for arrays
array size mismatch
undefined operation for structs containing arrays
undefined operation for structs containing samplers
dimension mismatch
comparison operator only defined for scalars
sequence operator is not allowed for void, arrays, or structs containing arrays
continue statement only allowed in loops
break statement only allowed in loops and switch statements
non-void function must return a value
discard supported in fragment shaders only
void function cannot return a value
function return is not matching type:
Texture component must be a constant expression
Component must be in the range [0;3]
Texture offsets must be a constant expression
Texture offsets must be an array of 4 elements
Texture offset must be a constant expression
Texture offset value out of valid range
first argument must be an interpolant, or interpolant-array element
The value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable.
'imageStore' cannot be used with images qualified as 'readonly'
'imageLoad' cannot be used with images qualified as 'writeonly'
'imageAtomic' cannot be used with images qualified as 'readonly'
'imageAtomic' cannot be used with images qualified as 'writeonly'
Function call discards the 'readonly' qualifier from image
Function call discards the 'writeonly' qualifier from image
Function call discards the 'coherent' qualifier from image
Function call discards the 'volatile' qualifier from image
length
invalid method
method takes no parameters
length can only be called on arrays
missing input primitive declaration before calling length on gl_in
function name expected
no matching overloaded function found
mismatching ternary operator operand types '
 and '
ternary operator is not allowed for opaque types
ternary operator is not allowed for variables with writeonly
ternary operator is not allowed for structures or arrays
ternary operator is not allowed for interface blocks
ternary operator is not allowed for void
unknown matrix packing
unknown block storage
dimension out of bounds
mediump
lowp
image
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/PbufferSurfaceEAGL.cpp
bindTexImage
PbufferSurfaceEAGL::bindTexImage
VertexInMod
VertexIn
VertexOutMod
VertexOut
FragmentInMod
FragmentIn
FragmentOutMod
FragmentOut
UserUniformsMod
UserUniforms
AngleUniformsMod
AngleUniforms
NonConstGlobalsMod
NonConstGlobals
InvocationVertexGlobalsMod
InvocationVertexGlobals
InvocationFragmentGlobalsMod
InvocationFragmentGlobals
TextureEnvsMod
TextureEnvs
ImagesMod
Images
InstanceIdMod
InstanceId
UniformBufferMod
UniformBuffer
vertexInMod
vertexIn
vertexOutMod
vertexOut
fragmentInMod
fragmentIn
fragmentOutMod
fragmentOut
userUniformsMod
userUniforms
angleUniformsMod
angleUniforms
nonConstGlobalsMod
nonConstGlobals
invocationVertexGlobalsMod
invocationVertexGlobals
invocationFragmentGlobalsMod
invocationFragmentGlobals
textureEnvsMod
textureEnvs
imagesMod
images
instanceIdMod
instanceId
uniformBufferMod
uniformBuffer
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Platform.cpp
ANGLEGetDisplayPlatform
Invalid platform method count: 
, expected 
placeholder
Invalid platform method name: 
currentTime
monotonicallyIncreasingTime
logError
logWarning
logInfo
getTraceCategoryEnabledFlag
addTraceEvent
updateTraceEventDuration
histogramCustomCounts
histogramEnumeration
histogramSparse
histogramBoolean
placeholder1
placeholder2
cacheProgram
placeholder3
postWorkerTask
#version 310 es
void main()
    gl_Position = vec4(mix(vec2(-1), vec2(1), equal(gl_VertexID & ivec2(1, 2), ivec2(0))), 0, 1);
#version 310 es
#extension GL_EXT_shader_pixel_local_storage : require
 PLS{
}pls;
layout(binding=
)uniform readonly 
image2D i
uniform 
vec4 c
)uniform writeonly 
void main(){
highp ivec2 pixelCoord=ivec2(floor(gl_FragCoord.xy));
pls._
imageLoad(i
,pixelCoord)
imageStore(i
,pixelCoord,
__pixel_local_outEXT
__pixel_local_inEXT
rgba8ui
r32f
highp
vec4
ivec4
vec4(pls._
,0,0,1)
uvec4(pls._
__LINE__
__FILE__
__VERSION__
GL_ES
Integer overflow on line number
EOF while in a comment
out of dynamic memory in yy_create_buffer()
yyset_lineno called with no buffer
out of dynamic memory in yyensure_buffer_stack()
ANGLEGetDisplayPlatform
ANGLEResetDisplayPlatform
eglBindAPI
eglBindTexImage
eglChooseConfig
eglClientWaitSync
eglClientWaitSyncKHR
eglCopyBuffers
eglCopyMetalSharedEventANGLE
eglCreateContext
eglCreateDeviceANGLE
eglCreateImage
eglCreateImageKHR
eglCreateNativeClientBufferANDROID
eglCreatePbufferFromClientBuffer
eglCreatePbufferSurface
eglCreatePixmapSurface
eglCreatePlatformPixmapSurface
eglCreatePlatformPixmapSurfaceEXT
eglCreatePlatformWindowSurface
eglCreatePlatformWindowSurfaceEXT
eglCreateStreamKHR
eglCreateStreamProducerD3DTextureANGLE
eglCreateSync
eglCreateSyncKHR
eglCreateWindowSurface
eglDebugMessageControlKHR
eglDestroyContext
eglDestroyImage
eglDestroyImageKHR
eglDestroyStreamKHR
eglDestroySurface
eglDestroySync
eglDestroySyncKHR
eglDupNativeFenceFDANDROID
eglExportVkImageANGLE
eglForceGPUSwitchANGLE
eglGetCompositorTimingANDROID
eglGetCompositorTimingSupportedANDROID
eglGetConfigAttrib
eglGetConfigs
eglGetCurrentContext
eglGetCurrentDisplay
eglGetCurrentSurface
eglGetDisplay
eglGetError
eglGetFrameTimestampSupportedANDROID
eglGetFrameTimestampsANDROID
eglGetMscRateANGLE
eglGetNativeClientBufferANDROID
eglGetNextFrameIdANDROID
eglGetPlatformDisplay
eglGetPlatformDisplayEXT
eglGetProcAddress
eglGetSyncAttrib
eglGetSyncAttribKHR
eglGetSyncValuesCHROMIUM
eglHandleGPUSwitchANGLE
eglInitialize
eglLabelObjectKHR
eglLockSurfaceKHR
eglMakeCurrent
eglPostSubBufferNV
eglPrepareSwapBuffersANGLE
eglPresentationTimeANDROID
eglProgramCacheGetAttribANGLE
eglProgramCachePopulateANGLE
eglProgramCacheQueryANGLE
eglProgramCacheResizeANGLE
eglQueryAPI
eglQueryContext
eglQueryDebugKHR
eglQueryDeviceAttribEXT
eglQueryDeviceStringEXT
eglQueryDisplayAttribANGLE
eglQueryDisplayAttribEXT
eglQueryDmaBufFormatsEXT
eglQueryDmaBufModifiersEXT
eglQueryStreamKHR
eglQueryStreamu64KHR
eglQueryString
eglQueryStringiANGLE
eglQuerySurface
eglQuerySurface64KHR
eglQuerySurfacePointerANGLE
eglReacquireHighPowerGPUANGLE
eglReleaseDeviceANGLE
eglReleaseHighPowerGPUANGLE
eglReleaseTexImage
eglReleaseThread
eglSetBlobCacheFuncsANDROID
eglSetDamageRegionKHR
eglSignalSyncKHR
eglStreamAttribKHR
eglStreamConsumerAcquireKHR
eglStreamConsumerGLTextureExternalAttribsNV
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerReleaseKHR
eglStreamPostD3DTextureANGLE
eglSurfaceAttrib
eglSwapBuffers
eglSwapBuffersWithDamageKHR
eglSwapBuffersWithFrameTokenANGLE
eglSwapInterval
eglTerminate
eglUnlockSurfaceKHR
eglWaitClient
eglWaitGL
eglWaitNative
eglWaitSync
eglWaitSyncKHR
eglWaitUntilWorkScheduledANGLE
glAcquireTexturesANGLE
glActiveShaderProgram
glActiveShaderProgramEXT
glActiveTexture
glAlphaFunc
glAlphaFuncx
glAttachShader
glBeginPerfMonitorAMD
glBeginPixelLocalStorageANGLE
glBeginQuery
glBeginQueryEXT
glBeginTransformFeedback
glBindAttribLocation
glBindBuffer
glBindBufferBase
glBindBufferRange
glBindFragDataLocationEXT
glBindFragDataLocationIndexedEXT
glBindFramebuffer
glBindFramebufferOES
glBindImageTexture
glBindProgramPipeline
glBindProgramPipelineEXT
glBindRenderbuffer
glBindRenderbufferOES
glBindSampler
glBindTexture
glBindTransformFeedback
glBindUniformLocationCHROMIUM
glBindVertexArray
glBindVertexArrayOES
glBindVertexBuffer
glBlendBarrier
glBlendBarrierKHR
glBlendColor
glBlendEquation
glBlendEquationSeparate
glBlendEquationSeparatei
glBlendEquationSeparateiEXT
glBlendEquationSeparateiOES
glBlendEquationi
glBlendEquationiEXT
glBlendEquationiOES
glBlendFunc
glBlendFuncSeparate
glBlendFuncSeparatei
glBlendFuncSeparateiEXT
glBlendFuncSeparateiOES
glBlendFunci
glBlendFunciEXT
glBlendFunciOES
glBlitFramebuffer
glBlitFramebufferANGLE
glBlitFramebufferNV
glBufferData
glBufferStorageEXT
glBufferStorageExternalEXT
glBufferStorageMemEXT
glBufferSubData
glCheckFramebufferStatus
glCheckFramebufferStatusOES
glClear
glClearBufferfi
glClearBufferfv
glClearBufferiv
glClearBufferuiv
glClearColor
glClearColorx
glClearDepthf
glClearDepthx
glClearStencil
glClientActiveTexture
glClientWaitSync
glClipControlEXT
glClipPlanef
glClipPlanex
glColor4f
glColor4ub
glColor4x
glColorMask
glColorMaski
glColorMaskiEXT
glColorMaskiOES
glColorPointer
glCompileShader
glCompressedCopyTextureCHROMIUM
glCompressedTexImage2D
glCompressedTexImage2DRobustANGLE
glCompressedTexImage3D
glCompressedTexImage3DOES
glCompressedTexImage3DRobustANGLE
glCompressedTexSubImage2D
glCompressedTexSubImage2DRobustANGLE
glCompressedTexSubImage3D
glCompressedTexSubImage3DOES
glCompressedTexSubImage3DRobustANGLE
glCopyBufferSubData
glCopyImageSubData
glCopyImageSubDataEXT
glCopyImageSubDataOES
glCopySubTexture3DANGLE
glCopySubTextureCHROMIUM
glCopyTexImage2D
glCopyTexSubImage2D
glCopyTexSubImage3D
glCopyTexSubImage3DOES
glCopyTexture3DANGLE
glCopyTextureCHROMIUM
glCoverageModulationCHROMIUM
glCreateMemoryObjectsEXT
glCreateProgram
glCreateShader
glCreateShaderProgramv
glCreateShaderProgramvEXT
glCullFace
glCurrentPaletteMatrixOES
glDebugMessageCallback
glDebugMessageCallbackKHR
glDebugMessageControl
glDebugMessageControlKHR
glDebugMessageInsert
glDebugMessageInsertKHR
glDeleteBuffers
glDeleteFencesNV
glDeleteFramebuffers
glDeleteFramebuffersOES
glDeleteMemoryObjectsEXT
glDeletePerfMonitorsAMD
glDeleteProgram
glDeleteProgramPipelines
glDeleteProgramPipelinesEXT
glDeleteQueries
glDeleteQueriesEXT
glDeleteRenderbuffers
glDeleteRenderbuffersOES
glDeleteSamplers
glDeleteSemaphoresEXT
glDeleteShader
glDeleteSync
glDeleteTextures
glDeleteTransformFeedbacks
glDeleteVertexArrays
glDeleteVertexArraysOES
glDepthFunc
glDepthMask
glDepthRangef
glDepthRangex
glDetachShader
glDisable
glDisableClientState
glDisableExtensionANGLE
glDisableVertexAttribArray
glDisablei
glDisableiEXT
glDisableiOES
glDiscardFramebufferEXT
glDispatchCompute
glDispatchComputeIndirect
glDrawArrays
glDrawArraysIndirect
glDrawArraysInstanced
glDrawArraysInstancedANGLE
glDrawArraysInstancedBaseInstanceANGLE
glDrawArraysInstancedBaseInstanceEXT
glDrawArraysInstancedEXT
glDrawBuffers
glDrawBuffersEXT
glDrawElements
glDrawElementsBaseVertex
glDrawElementsBaseVertexEXT
glDrawElementsBaseVertexOES
glDrawElementsIndirect
glDrawElementsInstanced
glDrawElementsInstancedANGLE
glDrawElementsInstancedBaseInstanceEXT
glDrawElementsInstancedBaseVertex
glDrawElementsInstancedBaseVertexBaseInstanceANGLE
glDrawElementsInstancedBaseVertexBaseInstanceEXT
glDrawElementsInstancedBaseVertexEXT
glDrawElementsInstancedBaseVertexOES
glDrawElementsInstancedEXT
glDrawRangeElements
glDrawRangeElementsBaseVertex
glDrawRangeElementsBaseVertexEXT
glDrawRangeElementsBaseVertexOES
glDrawTexfOES
glDrawTexfvOES
glDrawTexiOES
glDrawTexivOES
glDrawTexsOES
glDrawTexsvOES
glDrawTexxOES
glDrawTexxvOES
glEGLImageTargetRenderbufferStorageOES
glEGLImageTargetTexStorageEXT
glEGLImageTargetTexture2DOES
glEGLImageTargetTextureStorageEXT
glEnable
glEnableClientState
glEnableVertexAttribArray
glEnablei
glEnableiEXT
glEnableiOES
glEndPerfMonitorAMD
glEndPixelLocalStorageANGLE
glEndQuery
glEndQueryEXT
glEndTransformFeedback
glFenceSync
glFinish
glFinishFenceNV
glFlush
glFlushMappedBufferRange
glFlushMappedBufferRangeEXT
glFogf
glFogfv
glFogx
glFogxv
glFramebufferFetchBarrierEXT
glFramebufferMemorylessPixelLocalStorageANGLE
glFramebufferParameteri
glFramebufferParameteriMESA
glFramebufferPixelLocalClearValuefvANGLE
glFramebufferPixelLocalClearValueivANGLE
glFramebufferPixelLocalClearValueuivANGLE
glFramebufferRenderbuffer
glFramebufferRenderbufferOES
glFramebufferTexture
glFramebufferTexture2D
glFramebufferTexture2DMultisampleEXT
glFramebufferTexture2DOES
glFramebufferTexture3DOES
glFramebufferTextureEXT
glFramebufferTextureLayer
glFramebufferTextureMultiviewOVR
glFramebufferTextureOES
glFramebufferTexturePixelLocalStorageANGLE
glFrontFace
glFrustumf
glFrustumx
glGenBuffers
glGenFencesNV
glGenFramebuffers
glGenFramebuffersOES
glGenPerfMonitorsAMD
glGenProgramPipelines
glGenProgramPipelinesEXT
glGenQueries
glGenQueriesEXT
glGenRenderbuffers
glGenRenderbuffersOES
glGenSamplers
glGenSemaphoresEXT
glGenTextures
glGenTransformFeedbacks
glGenVertexArrays
glGenVertexArraysOES
glGenerateMipmap
glGenerateMipmapOES
glGetActiveAttrib
glGetActiveUniform
glGetActiveUniformBlockName
glGetActiveUniformBlockiv
glGetActiveUniformBlockivRobustANGLE
glGetActiveUniformsiv
glGetAttachedShaders
glGetAttribLocation
glGetBooleani_v
glGetBooleani_vRobustANGLE
glGetBooleanv
glGetBooleanvRobustANGLE
glGetBufferParameteri64v
glGetBufferParameteri64vRobustANGLE
glGetBufferParameteriv
glGetBufferParameterivRobustANGLE
glGetBufferPointerv
glGetBufferPointervOES
glGetBufferPointervRobustANGLE
glGetClipPlanef
glGetClipPlanex
glGetCompressedTexImageANGLE
glGetDebugMessageLog
glGetDebugMessageLogKHR
glGetError
glGetFenceivNV
glGetFixedv
glGetFloatv
glGetFloatvRobustANGLE
glGetFragDataIndexEXT
glGetFragDataLocation
glGetFramebufferAttachmentParameteriv
glGetFramebufferAttachmentParameterivOES
glGetFramebufferAttachmentParameterivRobustANGLE
glGetFramebufferParameteriv
glGetFramebufferParameterivMESA
glGetFramebufferParameterivRobustANGLE
glGetFramebufferPixelLocalStorageParameterfvANGLE
glGetFramebufferPixelLocalStorageParameterivANGLE
glGetGraphicsResetStatus
glGetGraphicsResetStatusEXT
glGetInteger64i_v
glGetInteger64i_vRobustANGLE
glGetInteger64v
glGetInteger64vEXT
glGetInteger64vRobustANGLE
glGetIntegeri_v
glGetIntegeri_vRobustANGLE
glGetIntegerv
glGetIntegervRobustANGLE
glGetInternalformativ
glGetInternalformativRobustANGLE
glGetLightfv
glGetLightxv
glGetMaterialfv
glGetMaterialxv
glGetMemoryObjectParameterivEXT
glGetMultisamplefv
glGetMultisamplefvANGLE
glGetMultisamplefvRobustANGLE
glGetObjectLabel
glGetObjectLabelEXT
glGetObjectLabelKHR
glGetObjectPtrLabel
glGetObjectPtrLabelKHR
glGetPerfMonitorCounterDataAMD
glGetPerfMonitorCounterInfoAMD
glGetPerfMonitorCounterStringAMD
glGetPerfMonitorCountersAMD
glGetPerfMonitorGroupStringAMD
glGetPerfMonitorGroupsAMD
glGetPointerv
glGetPointervKHR
glGetPointervRobustANGLERobustANGLE
glGetProgramBinary
glGetProgramBinaryOES
glGetProgramInfoLog
glGetProgramInterfaceiv
glGetProgramInterfaceivRobustANGLE
glGetProgramPipelineInfoLog
glGetProgramPipelineInfoLogEXT
glGetProgramPipelineiv
glGetProgramPipelineivEXT
glGetProgramResourceIndex
glGetProgramResourceLocation
glGetProgramResourceLocationIndexEXT
glGetProgramResourceName
glGetProgramResourceiv
glGetProgramiv
glGetProgramivRobustANGLE
glGetQueryObjecti64vEXT
glGetQueryObjecti64vRobustANGLE
glGetQueryObjectivEXT
glGetQueryObjectivRobustANGLE
glGetQueryObjectui64vEXT
glGetQueryObjectui64vRobustANGLE
glGetQueryObjectuiv
glGetQueryObjectuivEXT
glGetQueryObjectuivRobustANGLE
glGetQueryiv
glGetQueryivEXT
glGetQueryivRobustANGLE
glGetRenderbufferImageANGLE
glGetRenderbufferParameteriv
glGetRenderbufferParameterivOES
glGetRenderbufferParameterivRobustANGLE
glGetSamplerParameterIiv
glGetSamplerParameterIivEXT
glGetSamplerParameterIivOES
glGetSamplerParameterIivRobustANGLE
glGetSamplerParameterIuiv
glGetSamplerParameterIuivEXT
glGetSamplerParameterIuivOES
glGetSamplerParameterIuivRobustANGLE
glGetSamplerParameterfv
glGetSamplerParameterfvRobustANGLE
glGetSamplerParameteriv
glGetSamplerParameterivRobustANGLE
glGetSemaphoreParameterui64vEXT
glGetShaderInfoLog
glGetShaderPrecisionFormat
glGetShaderSource
glGetShaderiv
glGetShaderivRobustANGLE
glGetString
glGetStringi
glGetSynciv
glGetTexEnvfv
glGetTexEnviv
glGetTexEnvxv
glGetTexGenfvOES
glGetTexGenivOES
glGetTexGenxvOES
glGetTexImageANGLE
glGetTexLevelParameterfv
glGetTexLevelParameterfvANGLE
glGetTexLevelParameterfvRobustANGLE
glGetTexLevelParameteriv
glGetTexLevelParameterivANGLE
glGetTexLevelParameterivRobustANGLE
glGetTexParameterIiv
glGetTexParameterIivEXT
glGetTexParameterIivOES
glGetTexParameterIivRobustANGLE
glGetTexParameterIuiv
glGetTexParameterIuivEXT
glGetTexParameterIuivOES
glGetTexParameterIuivRobustANGLE
glGetTexParameterfv
glGetTexParameterfvRobustANGLE
glGetTexParameteriv
glGetTexParameterivRobustANGLE
glGetTexParameterxv
glGetTransformFeedbackVarying
glGetTranslatedShaderSourceANGLE
glGetUniformBlockIndex
glGetUniformIndices
glGetUniformLocation
glGetUniformfv
glGetUniformfvRobustANGLE
glGetUniformiv
glGetUniformivRobustANGLE
glGetUniformuiv
glGetUniformuivRobustANGLE
glGetUnsignedBytei_vEXT
glGetUnsignedBytevEXT
glGetVertexAttribIiv
glGetVertexAttribIivRobustANGLE
glGetVertexAttribIuiv
glGetVertexAttribIuivRobustANGLE
glGetVertexAttribPointerv
glGetVertexAttribPointervRobustANGLE
glGetVertexAttribfv
glGetVertexAttribfvRobustANGLE
glGetVertexAttribiv
glGetVertexAttribivRobustANGLE
glGetnUniformfv
glGetnUniformfvEXT
glGetnUniformfvRobustANGLE
glGetnUniformiv
glGetnUniformivEXT
glGetnUniformivRobustANGLE
glGetnUniformuiv
glGetnUniformuivRobustANGLE
glHint
glImportMemoryFdEXT
glImportMemoryZirconHandleANGLE
glImportSemaphoreFdEXT
glImportSemaphoreZirconHandleANGLE
glInsertEventMarkerEXT
glInvalidateFramebuffer
glInvalidateSubFramebuffer
glInvalidateTextureANGLE
glIsBuffer
glIsEnabled
glIsEnabledi
glIsEnablediEXT
glIsEnablediOES
glIsFenceNV
glIsFramebuffer
glIsFramebufferOES
glIsMemoryObjectEXT
glIsProgram
glIsProgramPipeline
glIsProgramPipelineEXT
glIsQuery
glIsQueryEXT
glIsRenderbuffer
glIsRenderbufferOES
glIsSampler
glIsSemaphoreEXT
glIsShader
glIsSync
glIsTexture
glIsTransformFeedback
glIsVertexArray
glIsVertexArrayOES
glLabelObjectEXT
glLightModelf
glLightModelfv
glLightModelx
glLightModelxv
glLightf
glLightfv
glLightx
glLightxv
glLineWidth
glLineWidthx
glLinkProgram
glLoadIdentity
glLoadMatrixf
glLoadMatrixx
glLoadPaletteFromModelViewMatrixOES
glLogicOp
glLogicOpANGLE
glLoseContextCHROMIUM
glMapBufferOES
glMapBufferRange
glMapBufferRangeEXT
glMaterialf
glMaterialfv
glMaterialx
glMaterialxv
glMatrixIndexPointerOES
glMatrixMode
glMaxShaderCompilerThreadsKHR
glMemoryBarrier
glMemoryBarrierByRegion
glMemoryObjectParameterivEXT
glMinSampleShading
glMinSampleShadingOES
glMultMatrixf
glMultMatrixx
glMultiDrawArraysANGLE
glMultiDrawArraysIndirectEXT
glMultiDrawArraysInstancedANGLE
glMultiDrawArraysInstancedBaseInstanceANGLE
glMultiDrawElementsANGLE
glMultiDrawElementsBaseVertexEXT
glMultiDrawElementsIndirectEXT
glMultiDrawElementsInstancedANGLE
glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE
glMultiTexCoord4f
glMultiTexCoord4x
glNamedBufferStorageExternalEXT
glNormal3f
glNormal3x
glNormalPointer
glObjectLabel
glObjectLabelKHR
glObjectPtrLabel
glObjectPtrLabelKHR
glOrthof
glOrthox
glPatchParameteri
glPatchParameteriEXT
glPauseTransformFeedback
glPixelLocalStorageBarrierANGLE
glPixelStorei
glPointParameterf
glPointParameterfv
glPointParameterx
glPointParameterxv
glPointSize
glPointSizePointerOES
glPointSizex
glPolygonOffset
glPolygonOffsetClampEXT
glPolygonOffsetx
glPopDebugGroup
glPopDebugGroupKHR
glPopGroupMarkerEXT
glPopMatrix
glPrimitiveBoundingBox
glPrimitiveBoundingBoxEXT
glPrimitiveBoundingBoxOES
glProgramBinary
glProgramBinaryOES
glProgramParameteri
glProgramParameteriEXT
glProgramUniform1f
glProgramUniform1fEXT
glProgramUniform1fv
glProgramUniform1fvEXT
glProgramUniform1i
glProgramUniform1iEXT
glProgramUniform1iv
glProgramUniform1ivEXT
glProgramUniform1ui
glProgramUniform1uiEXT
glProgramUniform1uiv
glProgramUniform1uivEXT
glProgramUniform2f
glProgramUniform2fEXT
glProgramUniform2fv
glProgramUniform2fvEXT
glProgramUniform2i
glProgramUniform2iEXT
glProgramUniform2iv
glProgramUniform2ivEXT
glProgramUniform2ui
glProgramUniform2uiEXT
glProgramUniform2uiv
glProgramUniform2uivEXT
glProgramUniform3f
glProgramUniform3fEXT
glProgramUniform3fv
glProgramUniform3fvEXT
glProgramUniform3i
glProgramUniform3iEXT
glProgramUniform3iv
glProgramUniform3ivEXT
glProgramUniform3ui
glProgramUniform3uiEXT
glProgramUniform3uiv
glProgramUniform3uivEXT
glProgramUniform4f
glProgramUniform4fEXT
glProgramUniform4fv
glProgramUniform4fvEXT
glProgramUniform4i
glProgramUniform4iEXT
glProgramUniform4iv
glProgramUniform4ivEXT
glProgramUniform4ui
glProgramUniform4uiEXT
glProgramUniform4uiv
glProgramUniform4uivEXT
glProgramUniformMatrix2fv
glProgramUniformMatrix2fvEXT
glProgramUniformMatrix2x3fv
glProgramUniformMatrix2x3fvEXT
glProgramUniformMatrix2x4fv
glProgramUniformMatrix2x4fvEXT
glProgramUniformMatrix3fv
glProgramUniformMatrix3fvEXT
glProgramUniformMatrix3x2fv
glProgramUniformMatrix3x2fvEXT
glProgramUniformMatrix3x4fv
glProgramUniformMatrix3x4fvEXT
glProgramUniformMatrix4fv
glProgramUniformMatrix4fvEXT
glProgramUniformMatrix4x2fv
glProgramUniformMatrix4x2fvEXT
glProgramUniformMatrix4x3fv
glProgramUniformMatrix4x3fvEXT
glProvokingVertexANGLE
glPushDebugGroup
glPushDebugGroupKHR
glPushGroupMarkerEXT
glPushMatrix
glQueryCounterEXT
glQueryMatrixxOES
glReadBuffer
glReadPixels
glReadPixelsRobustANGLE
glReadnPixels
glReadnPixelsEXT
glReadnPixelsRobustANGLE
glReleaseShaderCompiler
glReleaseTexturesANGLE
glRenderbufferStorage
glRenderbufferStorageMultisample
glRenderbufferStorageMultisampleANGLE
glRenderbufferStorageMultisampleEXT
glRenderbufferStorageOES
glRequestExtensionANGLE
glResumeTransformFeedback
glRotatef
glRotatex
glSampleCoverage
glSampleCoveragex
glSampleMaski
glSampleMaskiANGLE
glSamplerParameterIiv
glSamplerParameterIivEXT
glSamplerParameterIivOES
glSamplerParameterIivRobustANGLE
glSamplerParameterIuiv
glSamplerParameterIuivEXT
glSamplerParameterIuivOES
glSamplerParameterIuivRobustANGLE
glSamplerParameterf
glSamplerParameterfv
glSamplerParameterfvRobustANGLE
glSamplerParameteri
glSamplerParameteriv
glSamplerParameterivRobustANGLE
glScalef
glScalex
glScissor
glSelectPerfMonitorCountersAMD
glSemaphoreParameterui64vEXT
glSetFenceNV
glShadeModel
glShaderBinary
glShaderSource
glShadingRateQCOM
glSignalSemaphoreEXT
glStencilFunc
glStencilFuncSeparate
glStencilMask
glStencilMaskSeparate
glStencilOp
glStencilOpSeparate
glTestFenceNV
glTexBuffer
glTexBufferEXT
glTexBufferOES
glTexBufferRange
glTexBufferRangeEXT
glTexBufferRangeOES
glTexCoordPointer
glTexEnvf
glTexEnvfv
glTexEnvi
glTexEnviv
glTexEnvx
glTexEnvxv
glTexGenfOES
glTexGenfvOES
glTexGeniOES
glTexGenivOES
glTexGenxOES
glTexGenxvOES
glTexImage2D
glTexImage2DExternalANGLE
glTexImage2DRobustANGLE
glTexImage3D
glTexImage3DOES
glTexImage3DRobustANGLE
glTexParameterIiv
glTexParameterIivEXT
glTexParameterIivOES
glTexParameterIivRobustANGLE
glTexParameterIuiv
glTexParameterIuivEXT
glTexParameterIuivOES
glTexParameterIuivRobustANGLE
glTexParameterf
glTexParameterfv
glTexParameterfvRobustANGLE
glTexParameteri
glTexParameteriv
glTexParameterivRobustANGLE
glTexParameterx
glTexParameterxv
glTexStorage1DEXT
glTexStorage2D
glTexStorage2DEXT
glTexStorage2DMultisample
glTexStorage2DMultisampleANGLE
glTexStorage3D
glTexStorage3DEXT
glTexStorage3DMultisample
glTexStorage3DMultisampleOES
glTexStorageMem2DEXT
glTexStorageMem2DMultisampleEXT
glTexStorageMem3DEXT
glTexStorageMem3DMultisampleEXT
glTexStorageMemFlags2DANGLE
glTexStorageMemFlags2DMultisampleANGLE
glTexStorageMemFlags3DANGLE
glTexStorageMemFlags3DMultisampleANGLE
glTexSubImage2D
glTexSubImage2DRobustANGLE
glTexSubImage3D
glTexSubImage3DOES
glTexSubImage3DRobustANGLE
glTransformFeedbackVaryings
glTranslatef
glTranslatex
glUniform1f
glUniform1fv
glUniform1i
glUniform1iv
glUniform1ui
glUniform1uiv
glUniform2f
glUniform2fv
glUniform2i
glUniform2iv
glUniform2ui
glUniform2uiv
glUniform3f
glUniform3fv
glUniform3i
glUniform3iv
glUniform3ui
glUniform3uiv
glUniform4f
glUniform4fv
glUniform4i
glUniform4iv
glUniform4ui
glUniform4uiv
glUniformBlockBinding
glUniformMatrix2fv
glUniformMatrix2x3fv
glUniformMatrix2x4fv
glUniformMatrix3fv
glUniformMatrix3x2fv
glUniformMatrix3x4fv
glUniformMatrix4fv
glUniformMatrix4x2fv
glUniformMatrix4x3fv
glUnmapBuffer
glUnmapBufferOES
glUseProgram
glUseProgramStages
glUseProgramStagesEXT
glValidateProgram
glValidateProgramPipeline
glValidateProgramPipelineEXT
glVertexAttrib1f
glVertexAttrib1fv
glVertexAttrib2f
glVertexAttrib2fv
glVertexAttrib3f
glVertexAttrib3fv
glVertexAttrib4f
glVertexAttrib4fv
glVertexAttribBinding
glVertexAttribDivisor
glVertexAttribDivisorANGLE
glVertexAttribDivisorEXT
glVertexAttribFormat
glVertexAttribI4i
glVertexAttribI4iv
glVertexAttribI4ui
glVertexAttribI4uiv
glVertexAttribIFormat
glVertexAttribIPointer
glVertexAttribPointer
glVertexBindingDivisor
glVertexPointer
glViewport
glWaitSemaphoreEXT
glWaitSync
glWeightPointerOES
Type
Array-ness
Array size
Precision
Structure name
Field number
Field name
Interpolation type
Invariance
Binding layout qualifier
Location layout qualifier
Offset layout qualifier
Instance name qualifier
Format qualifier
Layout qualifier
Matrix Packing
Field location
Field structure name
s of 
' member '
' differ between 
 and 
 shaders.
GPU.ANGLE.ProgramCache.ProgramCacheHitTimeUS
The sum of the number of active image uniforms, active shader storage blocks and active fragment shader outputs exceeds MAX_COMBINED_SHADER_OUTPUT_RESOURCES (
Failed to save linked program to memory program cache.
Invalid program binary format.
Insufficient buffer size
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Program.cpp
saveBinary
Program has not been successfully linked.
Both compute and graphics shaders are attached to the same program.
 shader is not compiled.
 shader version does not match other shader versions.
Work group size is not specified.
No compiled shaders.
The program must contain objects to form both a vertex and fragment shader.
Tessellation control and evaluation shaders must be specified together.
Input primitive type is not specified in the geometry shader.
Output primitive type is not specified in the geometry shader.
'max_vertices' is not specified in the geometry shader.
In Tessellation Control Shader, at least one layout qualifier specifying an output patch vertex count must exist.
The Tessellation Evaluation Shader object in a program must declare a primitive mode in its input layout.
Exceeded maximum uniform location size
Attribute (
) at location 
 is too big to fit
Attribute '
' aliases attribute '
' at location 
Too many attributes (
Saving program binary with transform feedback, which is not supported on this driver.
Failed to allocate enough memory to serialize a program. (
 bytes )
Invalid program binary version.
cannot load program binaries across different angle sh version.
Cannot load program binaries across different ES context versions.
Current driver does not support transform feedback in binary programs.
Capture of array elements is undefined and not supported.
Two transform feedback varyings include the same array element (
Two transform feedback varyings specify the same output variable (
Linked transform feedback stage 
 does not support transform feedback varying.
Transform feedback varying 
 does not exist in the vertex shader.
Struct cannot be captured directly (
Capture of arrays is undefined and not supported.
Cannot capture outbound array element '
Varying '
' is not an array to be captured by element.
 components (
) exceed the maximum separate components (
Transform feedback varying total components (
) exceed the maximum interleaved components (
Samplers of conflicting types refer to the same texture image unit (
Samplers of conflicting formats refer to the same texture image unit (
Location of variable 
 conflicts with another variable.
Could not fit output variable into available locations: 
 combined AtomicCounterBuffers count exceeds limit
 shader AtomicCounterBuffers count exceeds limit
ProgramGL::load
ProgramGL::link
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/ProgramGL.cpp
checkLinkStatus
Program link or binary loading failed: 
Program link or binary loading failed with no info log.
angle_ClipDistanceEnabled
ProgramGL::LinkTask::run
ProgramGL::LinkEventNativeParallel::wait
ProgramGL::LinkEventGL::wait
Multiple uniforms bound to location 
atomic counter count exceeds MAX_COMBINED_ATOMIC_COUNTERS
Name conflicts between uniform block field names: 
Name conflicts between a uniform and an attribute: 
Name conflicts between a uniform and a uniform block field: 
 does not consume all varyings generated by 
 does not generate all varyings consumed by 
 varying 
 does not match any 
 varying
gl_FragCoord
gl_PointCoord
gl_FragCoord can only be declared invariant if and only if gl_Position is declared invariant.
gl_PointCoord can only be declared invariant if and only if gl_PointSize is declared invariant.
If either shader redeclares the built-in arrays gl_ClipDistance[] the array must have the same size in both shaders. 
Output size 
, input size 
If either shader redeclares the built-in arrays gl_CullDistance[] the array must have the same size in both shaders. 
Ambiguous field '
' in blocks '
 shader) and '
 shader) which don't have instance names.
The sum of the number of active uniform blocks exceeds MAX_COMBINED_UNIFORM_BLOCKS (
The sum of the number of active shader storage blocks exceeds MAX_COMBINED_SHADER_STORAGE_BLOCKS (
 shader 
s count exceeds 
texture image unit
image uniform
atomic counter
MAX_TEXTURE_IMAGE_UNITS
MAX_
UNIFORM_VECTORS
UNIFORM_COMPONENTS
TEXTURE_IMAGE_UNITS
IMAGE_UNIFORMS
ATOMIC_COUNTERS
_EXT
uniform block
shader storage block
 count exceeds 
GL_MAX_
UNIFORM_BUFFERS
SHADER_STORAGE_BLOCKS
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ProgramMtl.mm
resizeDefaultUniformBlocksMemory
TRANSFORM_FEEDBACK_ENABLED
TransformFeedback
ANGLEUseSampleCompareGradient
ANGLEUseSampleCompareLod
main0
Internal error compiling shader with Metal backend.
-----
createMslShaderLib
 is not marked separable.
#define ANGLE_tensor metal::array
#pragma clang diagnostic ignored "-Wunused-value"
addressof
cast<>
elem_ref
swizzle_ref
texture1DProj
textureCubeProj
template <typename T>
ANGLE_ALWAYS_INLINE thread T * ANGLE_addressof(thread T &ref)
    return &ref;
template <typename T, int C1, int R1, int C2, int R2, typename Enable = void>
struct ANGLE_castMatrix
    static ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> exec(metal::matrix<T, C2, R2> const m2)
    {
        metal::matrix<T, C1, R1> m1;
        const int MinC = C1 <= C2 ? C1 : C2;
        const int MinR = R1 <= R2 ? R1 : R2;
        for (int c = 0; c < MinC; ++c)
        {
            for (int r = 0; r < MinR; ++r)
            {
                m1[c][r] = m2[c][r];
            }
            for (int r = R2; r < R1; ++r)
            {
                m1[c][r] = c == r ? T(1) : T(0);
            }
        }
        for (int c = C2; c < C1; ++c)
        {
            for (int r = 0; r < R1; ++r)
            {
                m1[c][r] = c == r ? T(1) : T(0);
            }
        }
        return m1;
    }
template <typename T, int C1, int R1, int C2, int R2>
struct ANGLE_castMatrix<T, C1, R1, C2, R2, ANGLE_enable_if_t<(C1 <= C2 && R1 <= R2)>>
    static ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> exec(metal::matrix<T, C2, R2> const m2)
    {
        metal::matrix<T, C1, R1> m1;
        for (size_t c = 0; c < C1; ++c)
        {
            m1[c] = ANGLE_cast<R1>(m2[c]);
        }
        return m1;
    }
template <int C1, int R1, int C2, int R2, typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> ANGLE_cast(metal::matrix<T, C2, R2> const m)
    return ANGLE_castMatrix<T, C1, R1, C2, R2>::exec(m);
template <bool B, typename T = void>
struct ANGLE_enable_if {};
template <typename T>
struct ANGLE_enable_if<true, T>
    using type = T;
template <bool B>
using ANGLE_enable_if_t = typename ANGLE_enable_if<B>::type;
template <typename T, int N1, int N2>
struct ANGLE_castVector {};
template <typename T, int N>
struct ANGLE_castVector<T, N, N>
    static ANGLE_ALWAYS_INLINE metal::vec<T, N> exec(metal::vec<T, N> const v)
    {
        return v;
    }
template <typename T>
struct ANGLE_castVector<T, 2, 3>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 2> exec(metal::vec<T, 3> const v)
    {
        return v.xy;
    }
template <typename T>
struct ANGLE_castVector<T, 2, 4>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 2> exec(metal::vec<T, 4> const v)
    {
        return v.xy;
    }
template <typename T>
struct ANGLE_castVector<T, 3, 4>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 3> exec(metal::vec<T, 4> const v)
    {
        return as_type<metal::vec<T, 3>>(v);
    }
template <int N1, int N2, typename T>
ANGLE_ALWAYS_INLINE metal::vec<T, N1> ANGLE_cast(metal::vec<T, N2> const v)
    return ANGLE_castVector<T, N1, N2>::exec(v);
template <typename T, int N>
struct ANGLE_VectorElemRef
    thread metal::vec<T, N> &mVec;
    T mRef;
    const int mIndex;
    ~ANGLE_VectorElemRef() { mVec[mIndex] = mRef; }
    ANGLE_VectorElemRef(thread metal::vec<T, N> &vec, int index)
        : mVec(vec), mRef(vec[index]), mIndex(index)
    {}
    operator thread T &() { return mRef; }
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_VectorElemRef<T, N> ANGLE_elem_ref(thread metal::vec<T, N> &vec, int index)
    return ANGLE_VectorElemRef<T, N>(vec, index);
template <typename T>
struct ANGLE_flatten_impl
    static ANGLE_ALWAYS_INLINE thread T *exec(thread T &x)
    {
        return &x;
    }
template <typename T, size_t N>
struct ANGLE_flatten_impl<metal::array<T, N>>
    static ANGLE_ALWAYS_INLINE auto exec(thread metal::array<T, N> &arr) -> T
    {
        return ANGLE_flatten_impl<T>::exec(arr[0]);
    }
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE auto ANGLE_flatten(thread metal::array<T, N> &arr) -> T
    return ANGLE_flatten_impl<T>::exec(arr[0]);
template <typename T>
struct ANGLE_InOut
    T mTemp;
    thread T &mDest;
    ~ANGLE_InOut() { mDest = mTemp; }
    ANGLE_InOut(thread T &dest)
        : mTemp(dest), mDest(dest)
    {}
    operator thread T &() { return mTemp; }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_InOut<T> ANGLE_inout(thread T &dest)
    return ANGLE_InOut<T>(dest);
template <typename T>
struct ANGLE_Out
    T mTemp;
    thread T &mDest;
    ~ANGLE_Out() { mDest = mTemp; }
    ANGLE_Out(thread T &dest)
        : mTemp(dest), mDest(dest)
    {}
    operator thread T &() { return mTemp; }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_Out<T> ANGLE_out(thread T &dest)
    return ANGLE_Out<T>(dest);
template <typename T, int VN, int SN>
struct ANGLE_SwizzleRef
    thread metal::vec<T, VN> &mVec;
    metal::vec<T, SN> mRef;
    int mIndices[SN];
    ~ANGLE_SwizzleRef()
    {
        for (int i = 0; i < SN; ++i)
        {
            const int j = mIndices[i];
            mVec[j] = mRef[i];
        }
    }
    ANGLE_SwizzleRef(thread metal::vec<T, VN> &vec, thread const int *indices)
        : mVec(vec)
    {
        for (int i = 0; i < SN; ++i)
        {
            const int j = indices[i];
            mIndices[i] = j;
            mRef[i] = mVec[j];
        }
    }
    operator thread metal::vec<T, SN> &() { return mRef; }
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_VectorElemRef<T, N> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0)
    return ANGLE_VectorElemRef<T, N>(vec, i0);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 2> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1)
    const int is[] = { i0, i1 };
    return ANGLE_SwizzleRef<T, N, 2>(vec, is);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 3> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1, int i2)
    const int is[] = { i0, i1, i2 };
    return ANGLE_SwizzleRef<T, N, 3>(vec, is);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 4> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1, int i2, int i3)
    const int is[] = { i0, i1, i2, i3 };
    return ANGLE_SwizzleRef<T, N, 4>(vec, is);
#define ANGLE_texelFetch(env, ...) ANGLE_texelFetch_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread Texture &texture,
    metal::int2 const coord,
    uint32_t level)
    return texture.read(uint2(coord), level);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread Texture &texture,
    metal::int3 const coord,
    uint32_t level)
    return texture.read(uint3(coord), level);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread metal::texture2d_array<T> &texture,
    metal::int3 const coord,
    uint32_t level)
    return texture.read(uint2(coord.xy), uint32_t(coord.z), level);
template <typename T>
struct ANGLE_TextureEnv
    thread T *texture;
    thread metal::sampler *sampler;
#define ANGLE_texelFetchOffset(env, ...) ANGLE_texelFetchOffset_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread Texture &texture,
    metal::int2 const coord,
    uint32_t level,
    metal::int2 const offset)
    return texture.read(uint2(coord + offset), level);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread Texture &texture,
    metal::int3 const coord,
    uint32_t level,
    metal::int3 const offset)
    return texture.read(uint3(coord + offset), level);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread metal::texture2d_array<T> &texture,
    metal::int3 const coord,
    uint32_t level,
    metal::int2 const offset)
    return texture.read(uint2(coord.xy + offset), uint32_t(coord.z), level);
metal::depth2d<
metal::depthcube<
metal::depth2d_array<
metal::texture2d_array<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias));
#define ANGLE_texture(env, ...) ANGLE_texture_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample_compare(sampler, coord.xy, coord.z);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias)
    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample_compare(sampler, coord.xyz, coord.w);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float compare)
    return texture.sample_compare(sampler, coord.xyz, uint32_t(metal::round(coord.w)), compare);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
#define ANGLE_texture1DLod(env, ...) ANGLE_texture1DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    float const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture1DProj(env, ...) ANGLE_texture1DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.x/coord.y, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.x/coord.w, metal::bias(bias));
#define ANGLE_texture1DProjLod(env, ...) ANGLE_texture1DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord.x/coord.y, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.x/coord.w, metal::level(level));
#define ANGLE_texture2D(env, ...) ANGLE_texture2D_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
#define ANGLE_texture2DGradEXT(env, ...) ANGLE_texture2DGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DGradEXT_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord, metal::gradient2d(dPdx, dPdy));
#define ANGLE_texture2DLod(env, ...) ANGLE_texture2DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture2DLodEXT ANGLE_texture2DLod
#define ANGLE_texture2DProj(env, ...) ANGLE_texture2DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));
#define ANGLE_texture2DProjGradEXT(env, ...) ANGLE_texture2DProjGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));
#define ANGLE_texture2DProjLod(env, ...) ANGLE_texture2DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));
#define ANGLE_texture2DProjLodEXT ANGLE_texture2DProjLod
#define ANGLE_texture2DRect(env, ...) ANGLE_texture2DRect_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRect_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
#define ANGLE_texture2DRectProj(env, ...) ANGLE_texture2DRectProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord.xy/coord.z);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample(sampler, coord.xy/coord.w);
#define ANGLE_texture3DLod(env, ...) ANGLE_texture3DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture3DProj(env, ...) ANGLE_texture3DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
#define ANGLE_texture3DProjLod(env, ...) ANGLE_texture3DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
#define ANGLE_textureCube(env, ...) ANGLE_textureCube_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
#define ANGLE_textureCubeGradEXT(env, ...) ANGLE_textureCubeGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeGradEXT_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));
#define ANGLE_textureCubeLod(env, ...) ANGLE_textureCubeLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_textureCubeLodEXT ANGLE_textureCubeLod
#define ANGLE_textureCubeProj(env, ...) ANGLE_textureCubeProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
#define ANGLE_textureCubeProjLod(env, ...) ANGLE_textureCubeProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
metal::texturecube<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy)) > coord.z);
    }
#define ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX 0
#define ANGLE_SAMPLE_COMPARE_LOD_INDEX      1
#define ANGLE_RASTERIZATION_DISCARD_INDEX   2
#define ANGLE_COVERAGE_MASK_ENABLED_INDEX   3
#define ANGLE_DEPTH_WRITE_ENABLED_INDEX     4
constant bool ANGLEUseSampleCompareGradient [[function_constant(ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX)]];
constant bool ANGLEUseSampleCompareLod      [[function_constant(ANGLE_SAMPLE_COMPARE_LOD_INDEX)]];
constant bool ANGLERasterizerDisabled       [[function_constant(ANGLE_RASTERIZATION_DISCARD_INDEX)]];
constant bool ANGLECoverageMaskEnabled      [[function_constant(ANGLE_COVERAGE_MASK_ENABLED_INDEX)]];
constant bool ANGLEDepthWriteEnabled        [[function_constant(ANGLE_DEPTH_WRITE_ENABLED_INDEX)]];
#define ANGLE_textureGrad(env, ...) ANGLE_textureGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy)) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xyz, metal::gradientcube(dPdx, dPdy)) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));
template <typename Texture, int N>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::vec<float, N> const coord,
    metal::vec<float, N> const dPdx,
    metal::vec<float, N> const dPdy)
    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy));
template <int N>
struct ANGLE_gradient_traits;
template <>
struct ANGLE_gradient_traits<2> { using type = metal::gradient2d; };
template <>
struct ANGLE_gradient_traits<3> { using type = metal::gradient3d; };
template <int N>
using ANGLE_gradient = typename ANGLE_gradient_traits<N>::type;
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy), offset) > coord.z);
    }
#define ANGLE_textureGradOffset(env, ...) ANGLE_textureGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    metal::int3 const offset)
    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    metal::int3 const offset)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture, int N>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::vec<float, N> const coord,
    metal::vec<float, N> const dPdx,
    metal::vec<float, N> const dPdy,
    metal::vec<int, N> const offset)
    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level)) > coord.z);
    }
#define ANGLE_textureLod(env, ...) ANGLE_textureLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_textureLodOffset(env, ...) ANGLE_textureLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level,
    metal::int2 const offset)
    return texture.sample(sampler, coord, metal::level(level), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    metal::int3 const offset)
    return texture.sample(sampler, coord, metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    int2 const offset)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level), offset) > coord.z);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    metal::int3 const offset)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level), offset);
#define ANGLE_textureOffset(env, ...) ANGLE_textureOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::int2 const offset)
    return texture.sample(sampler, coord, offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int3 const offset)
    return texture.sample(sampler, coord, offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int3 const offset,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset)
    return texture.sample_compare(sampler, coord.xy, coord.z, offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias), offset);
#define ANGLE_textureProj(env, ...) ANGLE_textureProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
metal::texture3d<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy)) > coord.z/coord.w);
    }
#define ANGLE_textureProjGrad(env, ...) ANGLE_textureProjGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset) > coord.z/coord.w);
    }
#define ANGLE_textureProjGradOffset(env, ...) ANGLE_textureProjGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    int3 const offset)
    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level)) > coord.z/coord.w);
    }
#define ANGLE_textureProjLod(env, ...) ANGLE_textureProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));
#define ANGLE_textureProjLodOffset(env, ...) ANGLE_textureProjLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int2 const offset)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset) > coord.z/coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int3 const offset)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level), offset);
#define ANGLE_textureProjOffset(env, ...) ANGLE_textureProjOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    int2 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    int2 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    int3 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias), offset);
#define ANGLE_textureSize(env, ...) ANGLE_textureSize_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread Texture &texture,
    int level)
    return int2(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::texture3d<T> &texture,
    int level)
    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_depth(uint32_t(level)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::depth2d_array<T> &texture,
    int level)
    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::texture2d_array<T> &texture,
    int level)
    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());
template <typename T, metal::access Access>
ANGLE_ALWAYS_INLINE auto ANGLE_imageLoad(
    thread const metal::texture2d<T, Access> &texture,
    metal::int2 coord)
    return texture.read(uint2(coord));
template <typename T, metal::access Access>
ANGLE_ALWAYS_INLINE auto ANGLE_imageStore(
    thread const metal::texture2d<T, Access> &texture,
    metal::int2 coord,
    metal::vec<T, 4> value)
    return texture.write(value, uint2(coord));
ANGLE_ALWAYS_INLINE void ANGLE_memoryBarrierImage()
    simdgroup_barrier(metal::mem_flags::mem_texture);
#include <metal_stdlib>
#define ANGLE_ALWAYS_INLINE __attribute__((always_inline))
ANGLE_ALWAYS_INLINE int ANGLE_int_clamp(int value, int minValue, int maxValue)
    return ((value < minValue) ?  minValue : ((value > maxValue) ? maxValue : value));
template <typename T, int N>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::vec<T, N> u, metal::vec<T, N> v)
    return metal::all(u == v);
#include <metal_math>
template <typename T, int C, int R>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::matrix<T, C, R> a, metal::matrix<T, C, R> b)
    for (int c = 0; c < C; ++c)
    {
        if (!ANGLE_equal(a[c], b[c]))
        {
            return false;
        }
    }
    return true;
#if TRANSFORM_FEEDBACK_ENABLED
    #define __VERTEX_OUT(args) void
#else
    #define __VERTEX_OUT(args) args
#endif
ANGLE_ALWAYS_INLINE void ANGLE_writeSampleMask(const uint32_t mask,
                                               thread uint& gl_SampleMask)
    if (ANGLECoverageMaskEnabled)
    {
        gl_SampleMask = as_type<int>(mask);
    }
TextureEnv<
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_radians(T x)
    return static_cast<T>(1.7453292519943295e-2) * x;
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_degrees(T x)
    return static_cast<T>(57.29577951308232) * x;
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_atan(T yOverX)
    return metal::atan(yOverX);
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_atan(T y, T x)
    return metal::atan2(y, x);
template <typename X, typename Y>
ANGLE_ALWAYS_INLINE X ANGLE_mod(X x, Y y)
    return x - y * metal::floor(x / y);
template <typename T, typename Enable = void>
struct ANGLE_refract_impl
    static ANGLE_ALWAYS_INLINE T exec(T i, T n, ANGLE_scalar_of_t<T> eta)
    {
        return metal::refract(i, n, eta);
    }
template <typename T>
struct ANGLE_refract_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T i, T n, T eta)
    {
        auto dotNI = n * i;
        auto k = T(1) - eta * eta * (T(1) - dotNI * dotNI);
        if (k < T(0))
        {
            return T(0);
        }
        else
        {
            return eta * i - (eta * dotNI + metal::sqrt(k)) * n;
        }
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_refract(T i, T n, ANGLE_scalar_of_t<T> eta)
    return ANGLE_refract_impl<T>::exec(i, n, eta);
template <typename T>
struct ANGLE_is_scalar {};
#define ANGLE_DEFINE_SCALAR(scalar) \
    template <> struct ANGLE_is_scalar<scalar> { enum { value = true }; }
ANGLE_DEFINE_SCALAR(bool);
ANGLE_DEFINE_SCALAR(char);
ANGLE_DEFINE_SCALAR(short);
ANGLE_DEFINE_SCALAR(int);
ANGLE_DEFINE_SCALAR(uchar);
ANGLE_DEFINE_SCALAR(ushort);
ANGLE_DEFINE_SCALAR(uint);
ANGLE_DEFINE_SCALAR(half);
ANGLE_DEFINE_SCALAR(float);
template <typename T>
struct ANGLE_is_vector
    enum { value = false };
#define ANGLE_DEFINE_VECTOR(scalar) \
    template <> struct ANGLE_is_vector<metal::scalar ## 2> { enum { value = true }; }; \
    template <> struct ANGLE_is_vector<metal::scalar ## 3> { enum { value = true }; }; \
    template <> struct ANGLE_is_vector<metal::scalar ## 4> { enum { value = true }; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4> { using type = scalar; }
ANGLE_DEFINE_VECTOR(bool);
ANGLE_DEFINE_VECTOR(char);
ANGLE_DEFINE_VECTOR(short);
ANGLE_DEFINE_VECTOR(int);
ANGLE_DEFINE_VECTOR(uchar);
ANGLE_DEFINE_VECTOR(ushort);
ANGLE_DEFINE_VECTOR(uint);
ANGLE_DEFINE_VECTOR(half);
ANGLE_DEFINE_VECTOR(float);
template <typename T>
struct ANGLE_scalar_of
    using type = T;
template <typename T>
using ANGLE_scalar_of_t = typename ANGLE_scalar_of<T>::type;
template <typename T>
struct ANGLE_is_matrix
    enum { value = false };
#define ANGLE_DEFINE_MATRIX(scalar) \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x4> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x4> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x4> { enum { value = true }; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x4> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x4> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x4> { using type = scalar; }
ANGLE_DEFINE_MATRIX(half);
ANGLE_DEFINE_MATRIX(float);
template <typename T, typename Enable = void>
struct ANGLE_distance_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x, T y)
    {
        return metal::distance(x, y);
    }
template <typename T>
struct ANGLE_distance_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x, T y)
    {
        return metal::abs(x - y);
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_distance(T x, T y)
    return ANGLE_distance_impl<T>::exec(x, y);
template <typename T, typename Enable = void>
struct ANGLE_length_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x)
    {
        return metal::length(x);
    }
template <typename T>
struct ANGLE_length_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::abs(x);
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_length(T x)
    return ANGLE_length_impl<T>::exec(x);
template <typename T, typename Enable = void>
struct ANGLE_dot_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x, T y)
    {
        return metal::dot(x, y);
    }
template <typename T>
struct ANGLE_dot_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x, T y)
    {
        return x * y;
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_dot(T x, T y)
    return ANGLE_dot_impl<T>::exec(x, y);
template <typename T, typename Enable = void>
struct ANGLE_normalize_impl
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::fast::normalize(x);
    }
template <typename T>
struct ANGLE_normalize_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return ANGLE_sign(x);
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_normalize(T x)
    return ANGLE_normalize_impl<T>::exec(x);
template <typename T, typename Enable = void>
struct ANGLE_faceforward_impl
    static ANGLE_ALWAYS_INLINE T exec(T n, T i, T nref)
    {
        return metal::faceforward(n, i, nref);
    }
template <typename T>
struct ANGLE_faceforward_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T n, T i, T nref)
    {
        return ANGLE_dot(nref, i) < T(0) ? n : -n;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_faceforward(T n, T i, T nref)
    return ANGLE_faceforward_impl<T>::exec(n, i, nref);
template <typename T, typename Enable = void>
struct ANGLE_reflect_impl
    static ANGLE_ALWAYS_INLINE T exec(T i, T n)
    {
        return metal::reflect(i, n);
    }
template <typename T>
struct ANGLE_reflect_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T i, T n)
    {
        return i - T(2) * ANGLE_dot(n, i) * n;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_reflect(T i, T n)
    return ANGLE_reflect_impl<T>::exec(i, n);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
        if (!ANGLE_equal(u[i], v[i])) return false;
    return true;
template <typename T>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(T u, T v)
    return u == v;
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_equalStructArray(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
    {
        if (ANGLE_equal(u[i], v[i]) == false) 
            return false;
    }
    return true;
template <typename T, int N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::vec<T, N> u, metal::vec<T, N> v)
    return !ANGLE_equal(u, v);
template <typename T>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqualStruct(thread const T &a, thread const T &b)
    return !ANGLE_equal(a, b);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::array<T, N> u, metal::array<T, N> v)
    return !ANGLE_equal(u,v);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqualStructArray(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
    {
        if (ANGLE_notEqualStruct(u[i], v[i]))
            return true;
    }
    return false;
template <typename T, int C, int R>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::matrix<T, C, R> u, metal::matrix<T, C, R> v)
    return !ANGLE_equal(u, v);
#include <metal_geometric>
template <typename T, typename Enable = void>
struct ANGLE_sign_impl
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::sign(x);
    }
template <>
struct ANGLE_sign_impl<int>
    static ANGLE_ALWAYS_INLINE int exec(int x)
    {
        return (0 < x) - (x < 0);
    }
template <int N>
struct ANGLE_sign_impl<metal::vec<int, N>>
    static ANGLE_ALWAYS_INLINE metal::vec<int, N> exec(metal::vec<int, N> x)
    {
        metal::vec<int, N> s;
        for (int i = 0; i < N; ++i)
        {
            s[i] = ANGLE_sign_impl<int>::exec(x[i]);
        }
        return s;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_sign(T x)
    return ANGLE_sign_impl<T>::exec(x);
#include <metal_common>
template <typename T, int N>
ANGLE_ALWAYS_INLINE metal::vec<T,N> ANGLE_mix_bool(metal::vec<T, N> a, metal::vec<T, N> b, metal::vec<bool, N> c)
    return metal::mix(a, b, static_cast<metal::vec<T,N>>(c));
#include <metal_relational>
#include <metal_graphics>
#include <metal_matrix>
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator+(metal::matrix<T, Cols, Rows> m, T x)
    m += x;
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator+=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] += x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator-(metal::matrix<T, Cols, Rows> m, T x)
    m -= x;
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator-=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] -= x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator/(metal::matrix<T, Cols, Rows> a, metal::matrix<T, Cols, Rows> b)
    for (size_t col = 0; col < Cols; ++col)
    {
        a[col] /= b[col];
    }
    return a;
#if __METAL_VERSION__ <= 220
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator/(metal::matrix<T, Cols, Rows> m, T x)
    m /= x;
    return m;
#endif
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator/=(thread metal::matrix<T, Cols, Rows> &a, metal::matrix<T, Cols, Rows> b)
    a = a / b;
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator/=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] /= x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> ANGLE_componentWiseMultiply(metal::matrix<T, Cols, Rows> a, metal::matrix<T, Cols, Rows> b)
    for (size_t col = 0; col < Cols; ++col)
    {
        a[col] *= b[col];
    }
    return a;
template <typename T, int M, int N>
ANGLE_ALWAYS_INLINE metal::matrix<T, N, M> ANGLE_outerProduct(metal::vec<T, M> u, metal::vec<T, N> v)
    metal::matrix<T, N, M> o;
    for (size_t n = 0; n < N; ++n)
    {
        o[n] = u * v[n];
    }
    return o;
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 2, 2> ANGLE_inverse(metal::matrix<T, 2, 2> m)
    metal::matrix<T, 2, 2> adj;
    adj[0][0] =  m[1][1];
    adj[0][1] = -m[0][1];
    adj[1][0] = -m[1][0];
    adj[1][1] =  m[0][0];
    T det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]);
    return adj * (T(1) / det);
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 3, 3> ANGLE_inverse(metal::matrix<T, 3, 3> m)
    T a = m[1][1] * m[2][2] - m[2][1] * m[1][2];
    T b = m[1][0] * m[2][2];
    T c = m[1][2] * m[2][0];
    T d = m[1][0] * m[2][1];
    T det = m[0][0] * (a) -
            m[0][1] * (b - c) +
            m[0][2] * (d - m[1][1] * m[2][0]);
    det = T(1) / det;
    metal::matrix<T, 3, 3> minv;
    minv[0][0] = (a) * det;
    minv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * det;
    minv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * det;
    minv[1][0] = (c - b) * det;
    minv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * det;
    minv[1][2] = (m[1][0] * m[0][2] - m[0][0] * m[1][2]) * det;
    minv[2][0] = (d - m[2][0] * m[1][1]) * det;
    minv[2][1] = (m[2][0] * m[0][1] - m[0][0] * m[2][1]) * det;
    minv[2][2] = (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * det;
    return minv;
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 4, 4> ANGLE_inverse(metal::matrix<T, 4, 4> m)
    T A2323 = m[2][2] * m[3][3] - m[2][3] * m[3][2];
    T A1323 = m[2][1] * m[3][3] - m[2][3] * m[3][1];
    T A1223 = m[2][1] * m[3][2] - m[2][2] * m[3][1];
    T A0323 = m[2][0] * m[3][3] - m[2][3] * m[3][0];
    T A0223 = m[2][0] * m[3][2] - m[2][2] * m[3][0];
    T A0123 = m[2][0] * m[3][1] - m[2][1] * m[3][0];
    T A2313 = m[1][2] * m[3][3] - m[1][3] * m[3][2];
    T A1313 = m[1][1] * m[3][3] - m[1][3] * m[3][1];
    T A1213 = m[1][1] * m[3][2] - m[1][2] * m[3][1];
    T A2312 = m[1][2] * m[2][3] - m[1][3] * m[2][2];
    T A1312 = m[1][1] * m[2][3] - m[1][3] * m[2][1];
    T A1212 = m[1][1] * m[2][2] - m[1][2] * m[2][1];
    T A0313 = m[1][0] * m[3][3] - m[1][3] * m[3][0];
    T A0213 = m[1][0] * m[3][2] - m[1][2] * m[3][0];
    T A0312 = m[1][0] * m[2][3] - m[1][3] * m[2][0];
    T A0212 = m[1][0] * m[2][2] - m[1][2] * m[2][0];
    T A0113 = m[1][0] * m[3][1] - m[1][1] * m[3][0];
    T A0112 = m[1][0] * m[2][1] - m[1][1] * m[2][0];
    T a = m[1][1] * A2323 - m[1][2] * A1323 + m[1][3] * A1223;
    T b = m[1][0] * A2323 - m[1][2] * A0323 + m[1][3] * A0223;
    T c = m[1][0] * A1323 - m[1][1] * A0323 + m[1][3] * A0123;
    T d = m[1][0] * A1223 - m[1][1] * A0223 + m[1][2] * A0123;
    T det = m[0][0] * ( a )
          - m[0][1] * ( b )
          + m[0][2] * ( c )
          - m[0][3] * ( d );
    det = T(1) / det;
    metal::matrix<T, 4, 4> im;
    im[0][0] = det *   ( a );
    im[0][1] = det * - ( m[0][1] * A2323 - m[0][2] * A1323 + m[0][3] * A1223 );
    im[0][2] = det *   ( m[0][1] * A2313 - m[0][2] * A1313 + m[0][3] * A1213 );
    im[0][3] = det * - ( m[0][1] * A2312 - m[0][2] * A1312 + m[0][3] * A1212 );
    im[1][0] = det * - ( b );
    im[1][1] = det *   ( m[0][0] * A2323 - m[0][2] * A0323 + m[0][3] * A0223 );
    im[1][2] = det * - ( m[0][0] * A2313 - m[0][2] * A0313 + m[0][3] * A0213 );
    im[1][3] = det *   ( m[0][0] * A2312 - m[0][2] * A0312 + m[0][3] * A0212 );
    im[2][0] = det *   ( c );
    im[2][1] = det * - ( m[0][0] * A1323 - m[0][1] * A0323 + m[0][3] * A0123 );
    im[2][2] = det *   ( m[0][0] * A1313 - m[0][1] * A0313 + m[0][3] * A0113 );
    im[2][3] = det * - ( m[0][0] * A1312 - m[0][1] * A0312 + m[0][3] * A0112 );
    im[3][0] = det * - ( d );
    im[3][1] = det *   ( m[0][0] * A1223 - m[0][1] * A0223 + m[0][2] * A0123 );
    im[3][2] = det * - ( m[0][0] * A1213 - m[0][1] * A0213 + m[0][2] * A0113 );
    im[3][3] = det *   ( m[0][0] * A1212 - m[0][1] * A0212 + m[0][2] * A0112 );
    return im;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator*=(thread metal::matrix<T, Cols, Rows> &a, metal::matrix<T, Cols, Cols> b)
    a = a * b;
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator++(thread metal::matrix<T, Cols, Rows> &a)
    a += T(1);
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator++(thread metal::matrix<T, Cols, Rows> &a, int)
    auto b = a;
    a += T(1);
    return b;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator--(thread metal::matrix<T, Cols, Rows> &a)
    a -= T(1);
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator--(thread metal::matrix<T, Cols, Rows> &a, int)
    auto b = a;
    a -= T(1);
    return b;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator-(metal::matrix<T, Cols, Rows> m)
    for (size_t col = 0; col < Cols; ++col)
    {
        thread auto &mCol = m[col];
        mCol = -mCol;
    }
    return m;
#include <metal_pack>
ANGLE_ALWAYS_INLINE uint32_t ANGLE_pack_half_2x16(float2 v)
    return as_type<uint32_t>(half2(v));
ANGLE_ALWAYS_INLINE float2 ANGLE_unpack_half_2x16(uint32_t x)
    return float2(as_type<half2>(x));
fixIndexBufferKey
genIndexBuffer
fixIndexBuffer
Cannot have multiple different work group size specifiers
Cannot have multiple different primitive specifiers
Cannot have multiple different invocations specifiers
Cannot have multiple different max_vertices specifiers
Cannot have multiple different vertices specifiers
Cannot have multiple index specifiers
qualifier sequence
unknown geometry shader primitive type
The invariant qualifier specified multiple times.
The precise qualifier specified multiple times.
The precision qualifier specified multiple times.
The layout qualifier specified multiple times.
The layout qualifier and invariant qualifier cannot coexist in the same declaration according to the grammar.
The interpolation qualifier specified multiple times.
 specified multiple times
Output layout location specified multiple times.
The invariant qualifier has to be first in the expression.
Storage qualifiers have to be after interpolation qualifiers.
Precision qualifiers have to be after interpolation qualifiers.
Storage qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after storage qualifiers.
Precision qualifiers have to be after memory qualifiers.
invalid parameter qualifier
Invalid parameter qualifier 
invalid qualifier combination
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/queryconversions.cpp
CastStateValues
Application querying parameter that does not exist.
Unreachable Code.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/QueryGL.cpp
init
QueryMtl=%p
_webgl_struct_
Performance: dynamic indexing of vectors and matrices is emulated and can be slow.
dyn_index_
write_
ivec
bvec
uvec
base
value
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/RenderbufferGL.cpp
setStorage
functions->renderbufferStorage(GL_RENDERBUFFER, renderbufferFormat.internalFormat, width, height)
setStorageMultisample
functions->renderbufferStorageMultisample( GL_RENDERBUFFER, samples, renderbufferFormat.internalFormat, width, height)
functions->renderbufferStorageMultisampleEXT( GL_RENDERBUFFER, samples, renderbufferFormat.internalFormat, width, height)
functions->renderbufferStorageMultisampleIMG( GL_RENDERBUFFER, samples, renderbufferFormat.internalFormat, width, height)
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/RenderBufferMtl.mm
setStorageImpl
Integer overflow.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/renderer_utils.cpp
ComputeStartVertex
LogFeatureStatus
Feature: 
 enabled
 disabled
ANGLE_FEATURE_OVERRIDES_ENABLED
ANGLE_FEATURE_OVERRIDES_DISABLED
debug.angle.feature_overrides_enabled
debug.angle.feature_overrides_disabled
avoid1BitAlphaTextureFormats
Issue with 1-bit alpha framebuffer formats
RGBA4IsNotSupportedForColorRendering
GL_RGBA4 is not color renderable
allowETCFormats
Enable ETC2/EAC on desktop OpenGL
allowAstcFormats
Enable ASTC on desktop OpenGL
doesSRGBClearsOnLinearFramebufferAttachments
Issue clearing framebuffers with linear attachments when GL_FRAMEBUFFER_SRGB is enabled
doWhileGLSLCausesGPUHang
Some GLSL constructs involving do-while loops cause GPU hangs
http://crbug.com/644669
vertexIDDoesNotIncludeBaseVertex
gl_VertexID in GLSL vertex shader doesn't include base vertex value
finishDoesNotCauseQueriesToBeAvailable
glFinish doesn't cause all queries to report available result
alwaysCallUseProgramAfterLink
Always call useProgram after a successful link to avoid a driver bug
http://crbug.com/110263
unpackOverlappingRowsSeparatelyUnpackBuffer
In the case of unpacking from a pixel unpack buffer, unpack overlapping rows row by row
packOverlappingRowsSeparatelyPackBuffer
In the case of packing to a pixel pack buffer, pack overlapping rows row by row
initializeCurrentVertexAttributes
During initialization, assign the current vertex attributes to the spec-mandated defaults
emulateAbsIntFunction
abs(i) where i is an integer returns unexpected result
http://crbug.com/642227
addAndTrueToLoopCondition
Calculation of loop conditions in for and while loop has bug
unpackLastRowSeparatelyForPaddingInclusion
When uploading textures from an unpack buffer, some drivers count an extra row padding
http://anglebug.com/1512
packLastRowSeparatelyForPaddingInclusion
When uploading textures from an pack buffer, some drivers count an extra row padding
emulateIsnanFloat
Using isnan() on highp float will get wrong answer
http://crbug.com/650547
useUnusedBlocksWithStandardOrSharedLayout
Unused std140 or shared uniform blocks will be treated as inactive
removeInvariantAndCentroidForESSL3
Fix spec difference between GLSL 4.1 or lower and ESSL3
rewriteFloatUnaryMinusOperator
Using '-<float>' will get wrong answer
http://crbug.com/308366
emulateAtan2Float
atan(y, x) may return a wrong answer
http://crbug.com/672380
reapplyUBOBindingsAfterUsingBinaryProgram
Some drivers forget about UBO bindings when using program binaries
http://anglebug.com/1637
emulateMaxVertexAttribStride
Some drivers return 0 when MAX_VERTEX_ATTRIB_STRIED queried
http://anglebug.com/1936
dontInitializeUninitializedLocals
Initializing uninitialized locals caused odd behavior in a few WebGL 2 tests
http://anglebug.com/2046
clampPointSize
The point size range reported from the API is inconsistent with the actual behavior
dontUseLoopsToInitializeVariables
For loops used to initialize variables hit native GLSL compiler bugs
http://crbug.com/809422
clampFragDepth
gl_FragDepth is not clamped correctly when rendering to a floating point depth buffer
rewriteRepeatedAssignToSwizzled
Repeated assignment to swizzled values inside a GLSL user-defined function have incorrect results
disableBlendFuncExtended
ARB_blend_func_extended does not pass the tests
http://anglebug.com/1085
unsizedSRGBReadPixelsDoesntTransform
Drivers returning raw sRGB values instead of linearized values when calling glReadPixels on unsized sRGB texture formats
http://crbug.com/550292 http://crbug.com/565179
queryCounterBitsGeneratesErrors
Drivers generate errors when querying the number of bits in timer queries
http://anglebug.com/3027
dontRelinkProgramsInParallel
Relinking a program in parallel is buggy
http://anglebug.com/3045
disableWorkerContexts
Some tests have been seen to fail using worker contexts
http://crbug.com/849576
limitWebglMaxTextureSizeTo4096
Limit webgl max texture size to 4096 to avoid frequent out-of-memory errors
http://crbug.com/927470
limitMaxMSAASamplesTo4
Various rendering bugs have been observed when using higher MSAA counts
http://crbug.com/797243
allowClearForRobustResourceInit
Using glClear for robust resource initialization is buggy on some drivers and leads to texture corruption. Default to data uploads except on MacOS where it is very slow.
https://crbug.com/848952 http://crbug.com/883276
clampArrayAccess
Clamp uniform array access to avoid reading invalid memory.
http://anglebug.com/2978
resetTexImage2DBaseLevel
Reset texture base level before calling glTexImage2D to work around pixel comparison failure.
https://crbug.com/705865
clearToZeroOrOneBroken
Clears when the clear color is all zeros or ones do not work.
https://crbug.com/710443
limitMax3dArrayTextureSizeTo1024
Limit max 3d texture size and max array texture layers to 1024 to avoid system hang
adjustSrcDstRegionForBlitFramebuffer
Many platforms have issues with blitFramebuffer when the parameters are large.
http://crbug.com/830046
clipSrcRegionForBlitFramebuffer
Issues with blitFramebuffer when the parameters don't match the framebuffer size.
RGBDXT1TexturesSampleZeroAlpha
Sampling BLACK texels from RGB DXT1 textures returns transparent black on Mac.
http://anglebug.com/3729
unfoldShortCircuits
Mac incorrectly executes both sides of && and || expressions when they should short-circuit.
http://anglebug.com/482
emulatePrimitiveRestartFixedIndex
When GL_PRIMITIVE_RESTART_FIXED_INDEX is not available, emulate it with GL_PRIMITIVE_RESTART and glPrimitiveRestartIndex.
http://anglebug.com/3997
setPrimitiveRestartFixedIndexForDrawArrays
Some drivers discard vertex data in DrawArrays calls when the fixed primitive restart index is within the number of primitives being drawn.
removeDynamicIndexingOfSwizzledVector
Dynamic indexing of swizzled l-values doesn't work correctly on various platforms.
http://crbug.com/709351
preAddTexelFetchOffsets
Intel Mac drivers mistakenly consider the parameter position of nagative vaule as invalid even if the sum of position and offset is in range, so we need to add workarounds by rewriting texelFetchOffset(sampler, position, lod, offset) into texelFetch(sampler, position + offset, lod).
http://crbug.com/642605
regenerateStructNames
All Mac drivers do not handle struct scopes correctly. This workaround overwrites a structname with a unique prefix.
http://crbug.com/403957
readPixelsUsingImplementationColorReadFormatForNorm16
Quite some OpenGL ES drivers don't implement readPixels for RGBA/UNSIGNED_SHORT from EXT_texture_norm16 correctly
http://anglebug.com/4214
flushBeforeDeleteTextureIfCopiedTo
Some drivers track CopyTex{Sub}Image texture dependencies incorrectly. Flush before glDeleteTextures in this case
http://anglebug.com/4267
Rewrite row major matrices in shaders as column major as a driver bug workaround
http://anglebug.com/2273
Disable OES_draw_buffers_indexed extension.
disableSemaphoreFd
Disable GL_EXT_semaphore_fd extension
https://crbug.com/1046462
disableTimestampQueries
Disable GL_EXT_disjoint_timer_query extension
https://crbug.com/811661
decodeEncodeSRGBForGenerateMipmap
Decode and encode before generateMipmap for srgb format textures.
http://anglebug.com/4646
emulateCopyTexImage2D
Replace CopyTexImage2D with TexImage2D + CopyTexSubImage2D.
emulateCopyTexImage2DFromRenderbuffers
CopyTexImage2D spuriously returns errors on iOS when copying from renderbuffers.
https://anglebug.com/4674
disableGPUSwitchingSupport
Disable GPU switching support (use only the low-power GPU) on older MacBook Pros.
https://crbug.com/1091824
disableNativeParallelCompile
Do not use native KHR_parallel_shader_compile even when available.
http://crbug.com/1094869
emulatePackSkipRowsAndPackSkipPixels
GL_PACK_SKIP_ROWS and GL_PACK_SKIP_PIXELS are ignored in Apple's OpenGL driver.
https://anglebug.com/4849
clampMscRate
Some drivers return bogus values for GetMscRate, so we clamp it to 30Hz
https://crbug.com/1042393
bindTransformFeedbackBufferBeforeBindBufferRange
Bind transform feedback buffers to the generic binding point before calling glBindBufferBase or glBindBufferRange.
https://anglebug.com/5140
disableSyncControlSupport
Speculative fix for issues on Linux/Wayland where exposing GLX_OML_sync_control renders Chrome unusable
https://crbug.com/1137851
keepBufferShadowCopy
Maintain a shadow copy of buffer data when the GL API does not permit reading data back.
setZeroLevelBeforeGenerateMipmap
glGenerateMipmap fails if the zero texture level is not set on some Mac drivers.
promotePackedFormatsTo8BitPerChannel
Packed color formats are buggy on Macs with AMD GPUs
http://anglebug.com/5469
initFragmentOutputVariables
No init gl_FragColor causes context lost
http://crbug.com/1171371
shiftInstancedArrayDataWithOffset
glDrawArraysInstanced is buggy on certain new Mac Intel GPUs
http://crbug.com/1144207
syncVertexArraysToDefault
Only use the default VAO because of missing support or driver bugs
http://anglebug.com/5577
sanitizeAMDGPURendererString
Strip precise kernel and DRM version information from amdgpu renderer strings.
http://crbug.com/1181193
unbindFBOBeforeSwitchingContext
Imagination GL drivers are buggy with context switching.
flushOnFramebufferChange
Switching framebuffers without a flush can lead to crashes on Intel 9th Generation GPU Macs.
http://crbug.com/1181068
disableMultisampledRenderToTexture
Many drivers have bugs when using GL_EXT_multisampled_render_to_texture
http://anglebug.com/2894
uploadTextureDataInChunks
Upload texture data in <120kb chunks to work around Mac driver hangs and crashes.
emulateImmutableCompressedTexture3D
Use non-immutable texture allocation to work around a driver bug.
https://crbug.com/1060012
emulateRGB10
Emulate RGB10 support using RGB10_A2.
https://crbug.com/1300575
alwaysUnbindFramebufferTexture2D
Force unbind framebufferTexture2D before binding renderbuffer to work around driver bug.
https://anglebug.com/5536
disableTextureClampToBorder
Imagination devices generate INVALID_ENUM when setting the texture border color.
https://anglebug.com/7405
passHighpToPackUnormSnormBuiltins
packUnorm4x8 fails on Pixel 4 if it is not passed a highp vec4.
http://anglebug.com/7527
emulateClipDistanceState
Some drivers ignore GL_CLIP_DISTANCEi_EXT state.
supportsFragmentShaderInterlockNV
Backend GL context supports NV_fragment_shader_interlock extension
supportsFragmentShaderOrderingINTEL
Backend GL context supports GL_INTEL_fragment_shader_ordering extension
supportsFragmentShaderInterlockARB
Backend GL context supports ARB_fragment_shader_interlock extension
supportsShaderFramebufferFetchEXT
Backend GL context supports EXT_shader_framebuffer_fetch extension
supportsShaderFramebufferFetchNonCoherentEXT
Backend GL context supports EXT_shader_framebuffer_fetch_non_coherent extension
supportsShaderPixelLocalStorageEXT
Backend GL context supports EXT_shader_pixel_local_storage extension
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/RendererGL.cpp
LogGLDebugMessage
Source: 
Type: 
ID: 
Severity: 
Message: 
extension `GL_ARB_gpu_shader5' unsupported in
extension `GL_EXT_gpu_shader5' unsupported in
Adreno (TM) 418
Adreno (TM) 530
Adreno (TM) 540
GL_EXT_texture_array
GL_EXT_texture_lod_bias
GL_EXT_framebuffer_object
ARB_draw_buffers
GL_ARB_get_program_binary
GL_ARB_sync
GL_ARB_uniform_buffer_object
GL_ARB_transform_feedback2
GL_EXT_framebuffer_multisample
GL_ARB_sampler_objects
GL_ARB_texture_swizzle
GL_EXT_texture_swizzle
GL_ARB_explicit_attrib_location
GL_ARB_framebuffer_no_attachments
GL_ARB_texture_multisample
GL_ARB_vertex_attrib_binding
GL_ARB_shader_storage_buffer_object
GL_ARB_explicit_uniform_location
GL_ARB_texture_gather
GL_ARB_shader_image_load_store
GL_ARB_shader_atomic_counters
GL_ARB_texture_cube_map_array
GL_ARB_pixel_buffer_object
GL_EXT_pixel_buffer_object
GL_ARB_map_buffer_range
GL_EXT_draw_buffers2
GL_ARB_draw_buffers_blend
GL_EXT_framebuffer_blit
GL_ARB_fragment_shader
GL_ARB_shader_texture_lod
GL_ARB_shader_viewport_layer_array
GL_NV_viewport_array2
GL_NV_texture_border_clamp
GL_ARB_instanced_arrays
GL_ARB_draw_instanced
GL_ARB_vertex_array_object
GL_ARB_timer_query
GL_ARB_robustness
GL_ARB_robust_buffer_access_behavior
GL_EXT_framebuffer_sRGB
GL_ARB_framebuffer_sRGB
GL_ARB_invalidate_subdata
GL_ARB_blend_func_extended
GL_ARB_provoking_vertex
GL_EXT_provoking_vertex
GL_ARB_gpu_shader5
GL_ARB_cull_distance
GL_ARB_texture_buffer_object
functions->standard == STANDARD_GL_DESKTOP && isAMD
functions->standard == STANDARD_GL_DESKTOP && isIntel
isIntel && !IsSandyBridge(device) && !IsIvyBridge(device) && !IsHaswell(device)
!isMesa || isIntel && (Is9thGenIntel(device) || IsGeminiLake(device) || IsCoffeeLake(device) || Is11thGenIntel(device) || Is12thGenIntel(device))
IsApple() && isIntel
isIntel && IsApple() && IsSkylake(device) && GetMacOSVersion() < OSVersion(10, 13, 2)
isIntel || isAMD
IsLinux() && functions->standard == STANDARD_GL_DESKTOP && isAMD
(IsApple() && functions->standard == STANDARD_GL_DESKTOP) || (IsLinux() && isAMD)
IsApple() && functions->standard == STANDARD_GL_DESKTOP && GetMacOSVersion() < OSVersion(10, 11, 0)
IsApple() && isIntel && GetMacOSVersion() < OSVersion(10, 12, 0)
IsApple() && isAMD
IsAndroid() && isQualcomm
functions->standard == STANDARD_GL_DESKTOP && isNvidia
isNvidia
IsApple() || isNvidia
functions->isAtMostGL(gl::Version(4, 1)) || (functions->standard == STANDARD_GL_DESKTOP && isAMD)
isAMD || IsAndroid()
IsAndroid() || isNvidia
(IsAndroid() && isQualcomm) || (isIntel && IsApple())
isAMD || isIntel
IsNexus5X(vendor, device)
IsAndroid() || (IsWindows() && isIntel)
(IsWindows() && (isIntel || isAMD)) || (IsLinux() && isNvidia) || IsIOS() || IsAndroid() || IsAndroidEmulator(functions)
IsAndroid() || limitMaxTextureSize
IsAndroid() || (IsApple() && (isIntel || isAMD || isNvidia))
limitMaxTextureSize
IsApple()
IsAndroid() || isAMD || !functions->hasExtension("GL_KHR_robust_buffer_access_behavior")
IsApple() && isIntel && GetMacOSVersion() >= OSVersion(10, 12, 4)
IsApple() && isIntel && GetMacOSVersion() < OSVersion(10, 12, 6)
IsLinux() || (IsAndroid() && isNvidia) || (IsWindows() && isNvidia) || (IsApple() && functions->standard == STANDARD_GL_ES)
IsApple() || (IsLinux() && isAMD)
functions->standard == STANDARD_GL_DESKTOP && functions->isAtLeastGL(gl::Version(3, 1)) && !functions->isAtLeastGL(gl::Version(4, 3))
features->emulatePrimitiveRestartFixedIndex.enabled && IsApple() && isIntel
IsApple() || IsAndroid() || IsWindows()
!isIntel && functions->standard == STANDARD_GL_ES && functions->isAtLeastGLES(gl::Version(3, 1)) && functions->hasGLESExtension("GL_EXT_texture_norm16")
IsWindows() && isAMD
IsLinux() && isAMD && isMesa && mesaVersion < (std::array<int, 3>{19, 3, 5})
(IsLinux() && isVMWare) || (IsAndroid() && isNvidia) || (IsAndroid() && GetAndroidSdkLevel() < 27 && IsAdreno5xxOrOlder(functions)) || (IsAndroid() && IsMaliT8xxOrOlder(functions)) || (IsAndroid() && IsMaliG31OrOlder(functions))
IsApple() && functions->standard == STANDARD_GL_ES && !(isAMD && IsWindows())
isApple
isDualGPUMacWithNVIDIA
isTSANBuild && IsLinux() && isNvidia
IsLinux() && IsWayland()
IsLinux() && isIntel && isMesa && mesaVersion[0] == 20
!CanMapBufferForRead(functions)
IsApple() && hasAMD
IsAdreno42xOr3xx(functions)
IsApple() && IsIntel(vendor) && !IsHaswell(device)
!nativegl::SupportsVertexArrayObjects(functions)
IsLinux() && hasAMD
IsPowerVR(vendor)
IsApple() && Has9thGenIntelGPU(systemInfo)
isAdreno4xxOnAndroidLessThan51 || isAdreno4xxOnAndroid70 || isAdreno5xxOnAndroidLessThan70 || isAdreno5xxOnAndroid71 || isLinuxVivante
isQualcomm
functions->standard == STANDARD_GL_DESKTOP
isNvidia && (IsWindows() || IsLinux())
isImagination
functions->isAtLeastGL(gl::Version(4, 3)) && functions->hasGLExtension("GL_NV_fragment_shader_interlock")
functions->isAtLeastGL(gl::Version(4, 4)) && functions->hasGLExtension("GL_INTEL_fragment_shader_ordering")
functions->isAtLeastGL(gl::Version(4, 5)) && functions->hasGLExtension("GL_ARB_fragment_shader_interlock")
functions->hasGLESExtension("GL_EXT_shader_framebuffer_fetch")
functions->hasGLESExtension("GL_EXT_shader_framebuffer_fetch_non_coherent")
GL_EXT_shader_pixel_local_storage
functions->hasGLESExtension("GL_EXT_shader_pixel_local_storage")
IsPowerVrRogue(functions)
GL_ARB_compute_shader
GL_ARB_occlusion_query2
GL_EXT_occlusion_query_boolean
GL_ARB_internalformat_query2
Unexpected driver error.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/renderergl_utils.cpp
CheckError
GL call 
 generated error 
 in 
Additional GL error 
 generated.
Integer overflow.
ShouldApplyLastRowPaddingWorkaround
GenerateTextureFormatCaps
glGetInternalformativ generated error 
 for format 
. Skipping multisample checks.
CheckSizedInternalFormatTextureRenderability
CheckInternalFormatRenderbufferRenderability
Mesa %d.%d.%d
Adreno (TM) %d
FD%d
PowerVR Rogue
ClearErrors
Preexisting GL error 
 as of 
gl_ClipDistance
counters
atomicCounters
memoryBarrierBuffer
textureCubeGrad
exp2
dPdx
dPdy
dUVdx
dUVdy
outerProduct
dFdx
dFdy
sign
ANGLECubeMapCoordTransform
ANGLECubeMapCoordTransformImplicit
lastFragmentOut
sampler
floor
beginInvocationInterlockNV
beginFragmentShaderOrderingINTEL
beginInvocationInterlockARB
endInvocationInterlockNV
endInvocationInterlockARB
unpackUnorm4x8
packUnorm4x8
from
transpose
main
GMT_DISABLE_SEPARATE_COMPOUND_EXPRESSIONS
SerializationNotAvailable
VERTEX
FRAGMENT
COMPUTE
GEOMETRY
TESS_CONTROL
TESS_EVALUATION
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Shader.cpp
resolveCompile
Integer overflow when computing the product of local_size_x, 
local_size_y and local_size_z.
The total number of invocations within a work group exceeds 
MAX_COMPUTE_WORK_GROUP_INVOCATIONS.
Exceeded maximum shared memory size
Failed to save compiled shader to memory shader cache.
Failed to allocate enough memory to serialize a shader. (
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/ShaderGL.cpp
checkShader
Shader compilation failed with no info log.
TranslateTaskGL::run
source
TranslateTask::run
<binary blob>
ANGLESurfaceRotation
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/State.cpp
setProgram
Attempted to use a program that was not successfully linked
gpu.angle
egl::Surface::prepareSwap
egl::Surface::swap
egl::Surface::swapWithDamage
egl::Surface::swapWithFrameToken
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Surface.cpp
operator()
Unhandled internal error: 
swapWithDamage implementation missing.
setPresentationTime implementation missing.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/SurfaceMtl.mm
obtainNextDrawable
main
atomicCounter
constant
device
thread
metal::texture1d<float>
metal::texture1d<int>
metal::texture1d<uint32_t>
metal::texture1d_array<float>
metal::texture1d_array<int>
metal::texture1d_array<uint32_t>
metal::texture_buffer<float>
metal::texture_buffer<int>
metal::texture_buffer<uint32_t>
metal::texture2d<float>
metal::texture2d<int>
metal::texture2d<uint32_t>
metal::texture3d<float>
metal::texture3d<int>
metal::texture3d<uint32_t>
metal::texturecube<float>
metal::texturecube<int>
metal::texturecube<uint32_t>
metal::texture2d_array<float>
metal::texture2d_array<int>
metal::texture2d_array<uint32_t>
metal::texture2d_ms<float>
metal::texture2d_ms<int>
metal::texture2d_ms<uint32_t>
metal::texture2d_ms_array<float>
metal::texture2d_ms_array<int>
metal::texture2d_ms_array<uint32_t>
metal::texturecube_array<float>
metal::texturecube_array<int>
metal::texturecube_array<uint32_t>
metal::TODO<float>
metal::TODO<int>
metal::TODO<uint32_t>
metal::depth2d<float>
metal::depth2d<int>
metal::depth2d<uint32_t>
metal::depthcube<float>
metal::depthcube<int>
metal::depthcube<uint32_t>
metal::depth2d_array<float>
metal::depth2d_array<int>
metal::depth2d_array<uint32_t>
metal::depthcube_array<float>
metal::depthcube_array<int>
metal::depthcube_array<uint32_t>
gl_in
angle_BaseInstance
angle_BaseVertex
gl_BaseInstance
gl_BaseVertex
gl_DrawID
gl_FragColor
gl_FragCoord
gl_FragDepth
gl_FrontFacing
gl_GlobalInvocationID
gl_HelperInvocation
gl_InstanceID
gl_InvocationID
gl_LastFragColor
gl_LastFragColorARM
gl_Layer
gl_LocalInvocationID
gl_LocalInvocationIndex
gl_NumSamples
gl_NumWorkGroups
gl_PatchVerticesIn
gl_PointCoord
gl_PointSize
gl_Position
gl_PrimitiveID
gl_PrimitiveIDIn
gl_SampleID
gl_SamplePosition
gl_SecondaryFragColorEXT
gl_TessCoord
gl_VertexID
gl_VertexIndex
gl_ViewID_OVR
gl_ViewportIndex
gl_WorkGroupID
gl_WorkGroupSize
gl_DepthRangeParameters
gl_DepthRange
gl_MaxVertexAttribs
gl_MaxVertexUniformVectors
gl_MaxVertexTextureImageUnits
gl_MaxCombinedTextureImageUnits
gl_MaxTextureImageUnits
gl_MaxFragmentUniformVectors
gl_MaxVaryingVectors
gl_MaxDrawBuffers
gl_MaxDualSourceDrawBuffersEXT
gl_MaxVertexOutputVectors
gl_MaxFragmentInputVectors
gl_MinProgramTexelOffset
gl_MaxProgramTexelOffset
gl_MaxImageUnits
gl_MaxVertexImageUniforms
gl_MaxFragmentImageUniforms
gl_MaxComputeImageUniforms
gl_MaxCombinedImageUniforms
gl_MaxCombinedShaderOutputResources
gl_MaxComputeWorkGroupCount
gl_MaxComputeWorkGroupSize
gl_MaxComputeUniformComponents
gl_MaxComputeTextureImageUnits
gl_MaxComputeAtomicCounters
gl_MaxComputeAtomicCounterBuffers
gl_MaxVertexAtomicCounters
gl_MaxFragmentAtomicCounters
gl_MaxCombinedAtomicCounters
gl_MaxAtomicCounterBindings
gl_MaxVertexAtomicCounterBuffers
gl_MaxFragmentAtomicCounterBuffers
gl_MaxCombinedAtomicCounterBuffers
gl_MaxAtomicCounterBufferSize
gl_MaxGeometryInputComponents
gl_MaxGeometryOutputComponents
gl_MaxGeometryImageUniforms
gl_MaxGeometryTextureImageUnits
gl_MaxGeometryOutputVertices
gl_MaxGeometryTotalOutputComponents
gl_MaxGeometryUniformComponents
gl_MaxGeometryAtomicCounters
gl_MaxGeometryAtomicCounterBuffers
gl_MaxTessControlInputComponents
gl_MaxTessControlOutputComponents
gl_MaxTessControlTextureImageUnits
gl_MaxTessControlUniformComponents
gl_MaxTessControlTotalOutputComponents
gl_MaxTessControlImageUniforms
gl_MaxTessControlAtomicCounters
gl_MaxTessControlAtomicCounterBuffers
gl_MaxTessPatchComponents
gl_MaxPatchVertices
gl_MaxTessGenLevel
gl_MaxTessEvaluationInputComponents
gl_MaxTessEvaluationOutputComponents
gl_MaxTessEvaluationTextureImageUnits
gl_MaxTessEvaluationUniformComponents
gl_MaxTessEvaluationImageUniforms
gl_MaxTessEvaluationAtomicCounters
gl_MaxTessEvaluationAtomicCounterBuffers
gl_MaxSamples
gl_MaxClipDistances
gl_MaxCullDistances
gl_MaxCombinedClipAndCullDistances
gl_FragData
gl_SecondaryFragDataEXT
gl_FragDepthEXT
gl_LastFragData
gl_SampleMaskIn
gl_SampleMask
gl_ClipDistance
gl_PerVertex
gl_in
gl_TessLevelOuter
gl_TessLevelInner
gl_out
gl_BoundingBox
gl_BoundingBoxEXT
gl_BoundingBoxOES
gl_CullDistance
radians(00B
radians(10B
radians(20B
radians(30B
degrees(00B
degrees(10B
degrees(20B
degrees(30B
sin(00B
sin(10B
sin(20B
sin(30B
cos(00B
cos(10B
cos(20B
cos(30B
tan(00B
tan(10B
tan(20B
tan(30B
asin(00B
asin(10B
asin(20B
asin(30B
acos(00B
acos(10B
acos(20B
acos(30B
atan(00B00B
atan(10B10B
atan(20B20B
atan(30B30B
atan(00B
atan(10B
atan(20B
atan(30B
sinh(00B
sinh(10B
sinh(20B
sinh(30B
cosh(00B
cosh(10B
cosh(20B
cosh(30B
tanh(00B
tanh(10B
tanh(20B
tanh(30B
asinh(00B
asinh(10B
asinh(20B
asinh(30B
acosh(00B
acosh(10B
acosh(20B
acosh(30B
atanh(00B
atanh(10B
atanh(20B
atanh(30B
pow(00B00B
pow(10B10B
pow(20B20B
pow(30B30B
exp(00B
exp(10B
exp(20B
exp(30B
log(00B
log(10B
log(20B
log(30B
exp2(00B
exp2(10B
exp2(20B
exp2(30B
log2(00B
log2(10B
log2(20B
log2(30B
sqrt(00B
sqrt(10B
sqrt(20B
sqrt(30B
inversesqrt(00B
inversesqrt(10B
inversesqrt(20B
inversesqrt(30B
abs(00B
abs(10B
abs(20B
abs(30B
abs(00D
abs(10D
abs(20D
abs(30D
sign(00B
sign(10B
sign(20B
sign(30B
sign(00D
sign(10D
sign(20D
sign(30D
floor(00B
floor(10B
floor(20B
floor(30B
trunc(00B
trunc(10B
trunc(20B
trunc(30B
round(00B
round(10B
round(20B
round(30B
roundEven(00B
roundEven(10B
roundEven(20B
roundEven(30B
ceil(00B
ceil(10B
ceil(20B
ceil(30B
fract(00B
fract(10B
fract(20B
fract(30B
mod(00B00B
mod(10B00B
mod(20B00B
mod(30B00B
mod(10B10B
mod(20B20B
mod(30B30B
min(00B00B
min(10B00B
min(20B00B
min(30B00B
min(10B10B
min(20B20B
min(30B30B
min(00D00D
min(10D10D
min(20D20D
min(30D30D
min(10D00D
min(20D00D
min(30D00D
min(00E00E
min(10E10E
min(20E20E
min(30E30E
min(10E00E
min(20E00E
min(30E00E
max(00B00B
max(10B00B
max(20B00B
max(30B00B
max(10B10B
max(20B20B
max(30B30B
max(00D00D
max(10D10D
max(20D20D
max(30D30D
max(10D00D
max(20D00D
max(30D00D
max(00E00E
max(10E10E
max(20E20E
max(30E30E
max(10E00E
max(20E00E
max(30E00E
clamp(00B00B00B
clamp(10B00B00B
clamp(20B00B00B
clamp(30B00B00B
clamp(10B10B10B
clamp(20B20B20B
clamp(30B30B30B
clamp(00D00D00D
clamp(10D00D00D
clamp(20D00D00D
clamp(30D00D00D
clamp(10D10D10D
clamp(20D20D20D
clamp(30D30D30D
clamp(00E00E00E
clamp(10E00E00E
clamp(20E00E00E
clamp(30E00E00E
clamp(10E10E10E
clamp(20E20E20E
clamp(30E30E30E
mix(00B00B00B
mix(10B10B00B
mix(20B20B00B
mix(30B30B00B
mix(10B10B10B
mix(20B20B20B
mix(30B30B30B
mix(00B00B00F
mix(10B10B10F
mix(20B20B20F
mix(30B30B30F
mix(00D00D00F
mix(10D10D10F
mix(20D20D20F
mix(30D30D30F
mix(00E00E00F
mix(10E10E10F
mix(20E20E20F
mix(30E30E30F
mix(00F00F00F
mix(10F10F10F
mix(20F20F20F
mix(30F30F30F
step(00B00B
step(10B10B
step(20B20B
step(30B30B
step(00B10B
step(00B20B
step(00B30B
smoothstep(00B00B00B
smoothstep(10B10B10B
smoothstep(20B20B20B
smoothstep(30B30B30B
smoothstep(00B00B10B
smoothstep(00B00B20B
smoothstep(00B00B30B
modf(00B00B
modf(10B10B
modf(20B20B
modf(30B30B
isnan(00B
isnan(10B
isnan(20B
isnan(30B
isinf(00B
isinf(10B
isinf(20B
isinf(30B
floatBitsToInt(00B
floatBitsToInt(10B
floatBitsToInt(20B
floatBitsToInt(30B
floatBitsToUint(00B
floatBitsToUint(10B
floatBitsToUint(20B
floatBitsToUint(30B
intBitsToFloat(00D
intBitsToFloat(10D
intBitsToFloat(20D
intBitsToFloat(30D
uintBitsToFloat(00E
uintBitsToFloat(10E
uintBitsToFloat(20E
uintBitsToFloat(30E
fma(00B00B00B
fma(10B10B10B
fma(20B20B20B
fma(30B30B30B
frexp(00B00D
frexp(10B10D
frexp(20B20D
frexp(30B30D
ldexp(00B00D
ldexp(10B10D
ldexp(20B20D
ldexp(30B30D
packSnorm2x16(10B
packHalf2x16(10B
unpackSnorm2x16(00E
unpackHalf2x16(00E
packUnorm2x16(10B
unpackUnorm2x16(00E
packUnorm4x8(30B
packSnorm4x8(30B
unpackUnorm4x8(00E
unpackSnorm4x8(00E
length(00B
length(10B
length(20B
length(30B
distance(00B00B
distance(10B10B
distance(20B20B
distance(30B30B
dot(00B00B
dot(10B10B
dot(20B20B
dot(30B30B
cross(20B20B
normalize(00B
normalize(10B
normalize(20B
normalize(30B
faceforward(00B00B00B
faceforward(10B10B10B
faceforward(20B20B20B
faceforward(30B30B30B
reflect(00B00B
reflect(10B10B
reflect(20B20B
reflect(30B30B
refract(00B00B00B
refract(10B10B00B
refract(20B20B00B
refract(30B30B00B
matrixCompMult(50B50B
matrixCompMult(A0BA0B
matrixCompMult(F0BF0B
matrixCompMult(90B90B
matrixCompMult(60B60B
matrixCompMult(D0BD0B
matrixCompMult(70B70B
matrixCompMult(E0BE0B
matrixCompMult(B0BB0B
outerProduct(10B10B
outerProduct(20B20B
outerProduct(30B30B
outerProduct(20B10B
outerProduct(10B20B
outerProduct(30B10B
outerProduct(10B30B
outerProduct(30B20B
outerProduct(20B30B
transpose(50B
transpose(A0B
transpose(F0B
transpose(60B
transpose(90B
transpose(70B
transpose(D0B
transpose(B0B
transpose(E0B
determinant(50B
determinant(A0B
determinant(F0B
inverse(50B
inverse(A0B
inverse(F0B
lessThan(10B10B
lessThan(20B20B
lessThan(30B30B
lessThan(10D10D
lessThan(20D20D
lessThan(30D30D
lessThan(10E10E
lessThan(20E20E
lessThan(30E30E
lessThanEqual(10B10B
lessThanEqual(20B20B
lessThanEqual(30B30B
lessThanEqual(10D10D
lessThanEqual(20D20D
lessThanEqual(30D30D
lessThanEqual(10E10E
lessThanEqual(20E20E
lessThanEqual(30E30E
greaterThan(10B10B
greaterThan(20B20B
greaterThan(30B30B
greaterThan(10D10D
greaterThan(20D20D
greaterThan(30D30D
greaterThan(10E10E
greaterThan(20E20E
greaterThan(30E30E
greaterThanEqual(10B10B
greaterThanEqual(20B20B
greaterThanEqual(30B30B
greaterThanEqual(10D10D
greaterThanEqual(20D20D
greaterThanEqual(30D30D
greaterThanEqual(10E10E
greaterThanEqual(20E20E
greaterThanEqual(30E30E
equal(10B10B
equal(20B20B
equal(30B30B
equal(10D10D
equal(20D20D
equal(30D30D
equal(10E10E
equal(20E20E
equal(30E30E
equal(10F10F
equal(20F20F
equal(30F30F
notEqual(10B10B
notEqual(20B20B
notEqual(30B30B
notEqual(10D10D
notEqual(20D20D
notEqual(30D30D
notEqual(10E10E
notEqual(20E20E
notEqual(30E30E
notEqual(10F10F
notEqual(20F20F
notEqual(30F30F
any(10F
any(20F
any(30F
all(10F
all(20F
all(30F
not(10F
not(20F
not(30F
bitfieldExtract(00D00D00D
bitfieldExtract(10D00D00D
bitfieldExtract(20D00D00D
bitfieldExtract(30D00D00D
bitfieldExtract(00E00D00D
bitfieldExtract(10E00D00D
bitfieldExtract(20E00D00D
bitfieldExtract(30E00D00D
bitfieldInsert(00D00D00D00D
bitfieldInsert(10D10D00D00D
bitfieldInsert(20D20D00D00D
bitfieldInsert(30D30D00D00D
bitfieldInsert(00E00E00D00D
bitfieldInsert(10E10E00D00D
bitfieldInsert(20E20E00D00D
bitfieldInsert(30E30E00D00D
bitfieldReverse(00D
bitfieldReverse(10D
bitfieldReverse(20D
bitfieldReverse(30D
bitfieldReverse(00E
bitfieldReverse(10E
bitfieldReverse(20E
bitfieldReverse(30E
bitCount(00D
bitCount(10D
bitCount(20D
bitCount(30D
bitCount(00E
bitCount(10E
bitCount(20E
bitCount(30E
findLSB(00D
findLSB(10D
findLSB(20D
findLSB(30D
findLSB(00E
findLSB(10E
findLSB(20E
findLSB(30E
findMSB(00D
findMSB(10D
findMSB(20D
findMSB(30D
findMSB(00E
findMSB(10E
findMSB(20E
findMSB(30E
uaddCarry(00E00E00E
uaddCarry(10E10E10E
uaddCarry(20E20E20E
uaddCarry(30E30E30E
usubBorrow(00E00E00E
usubBorrow(10E10E10E
usubBorrow(20E20E20E
usubBorrow(30E30E30E
umulExtended(00E00E00E00E
umulExtended(10E10E10E10E
umulExtended(20E20E20E20E
umulExtended(30E30E30E30E
imulExtended(00D00D00D00D
imulExtended(10D10D10D10D
imulExtended(20D20D20D20D
imulExtended(30D30D30D30D
texture2D(00I10B
texture2DProj(00I20B
texture2DProj(00I30B
textureCube(00K20B
texture3D(00J20B
texture3DProj(00J30B
shadow2DEXT(00d20B
shadow2DProjEXT(00d30B
texture2D(00M10B
texture2DProj(00M20B
texture2DProj(00M30B
texture2DRect(00O10B
texture2DRectProj(00O20B
texture2DRectProj(00O30B
texture2DGradEXT(00I10B10B10B
texture2DProjGradEXT(00I20B10B10B
texture2DProjGradEXT(00I30B10B10B
textureCubeGradEXT(00K20B20B20B
textureVideoWEBGL(00y10B
texture2D(00I10B00B
texture2DProj(00I20B00B
texture2DProj(00I30B00B
textureCube(00K20B00B
texture3D(00J20B00B
texture3DProj(00J30B00B
texture3DLod(00J20B00B
texture3DProjLod(00J30B00B
texture2DLod(00I10B00B
texture2DProjLod(00I20B00B
texture2DProjLod(00I30B00B
textureCubeLod(00K20B00B
texture2DLodEXT(00I10B00B
texture2DProjLodEXT(00I20B00B
texture2DProjLodEXT(00I30B00B
textureCubeLodEXT(00K20B00B
texture(00I10B
texture(00R10B
texture(00X10B
texture(00J20B
texture(00S20B
texture(00Y20B
texture(00K20B
texture(00T20B
texture(00Z20B
texture(00L20B
texture(00U20B
texture(00a20B
texture(00d20B
texture(00e30B
texture(00f30B
texture(00k30B
texture(00s30B
texture(00x30B
texture(00l30B00B
texture(00M10B
texture(00N10B
texture(00O10B
texture(00y10B
textureProj(00I20B
textureProj(00R20B
textureProj(00X20B
textureProj(00I30B
textureProj(00R30B
textureProj(00X30B
textureProj(00J30B
textureProj(00S30B
textureProj(00Y30B
textureProj(00d30B
textureProj(00M20B
textureProj(00M30B
textureProj(00N20B
textureProj(00N30B
textureProj(00O20B
textureProj(00O30B
textureLod(00I10B00B
textureLod(00R10B00B
textureLod(00X10B00B
textureLod(00J20B00B
textureLod(00S20B00B
textureLod(00Y20B00B
textureLod(00K20B00B
textureLod(00T20B00B
textureLod(00Z20B00B
textureLod(00L20B00B
textureLod(00U20B00B
textureLod(00a20B00B
textureLod(00d20B00B
textureLod(00k30B00B
textureLod(00s30B00B
textureLod(00x30B00B
textureSize(00I00D
textureSize(00R00D
textureSize(00X00D
textureSize(00J00D
textureSize(00S00D
textureSize(00Y00D
textureSize(00K00D
textureSize(00T00D
textureSize(00Z00D
textureSize(00L00D
textureSize(00U00D
textureSize(00a00D
textureSize(00d00D
textureSize(00e00D
textureSize(00f00D
textureSize(00k00D
textureSize(00s00D
textureSize(00x00D
textureSize(00l00D
textureSize(00j
textureSize(00r
textureSize(00w
textureSize(00P
textureSize(00V
textureSize(00b
textureSize(00Q
textureSize(00W
textureSize(00c
textureSize(00M00D
textureSize(00N00D
textureProjLod(00I20B00B
textureProjLod(00R20B00B
textureProjLod(00X20B00B
textureProjLod(00I30B00B
textureProjLod(00R30B00B
textureProjLod(00X30B00B
textureProjLod(00J30B00B
textureProjLod(00S30B00B
textureProjLod(00Y30B00B
textureProjLod(00d30B00B
texelFetch(00I10D00D
texelFetch(00R10D00D
texelFetch(00X10D00D
texelFetch(00J20D00D
texelFetch(00S20D00D
texelFetch(00Y20D00D
texelFetch(00L20D00D
texelFetch(00U20D00D
texelFetch(00a20D00D
texelFetch(00j00D
texelFetch(00r00D
texelFetch(00w00D
texelFetch(00P10D00D
texelFetch(00V10D00D
texelFetch(00b10D00D
texelFetch(00Q20D00D
texelFetch(00W20D00D
texelFetch(00c20D00D
texelFetch(00M10D00D
texelFetch(00N10D00D
textureGrad(00I10B10B10B
textureGrad(00R10B10B10B
textureGrad(00X10B10B10B
textureGrad(00J20B20B20B
textureGrad(00S20B20B20B
textureGrad(00Y20B20B20B
textureGrad(00K20B20B20B
textureGrad(00T20B20B20B
textureGrad(00Z20B20B20B
textureGrad(00d20B10B10B
textureGrad(00e30B20B20B
textureGrad(00L20B10B10B
textureGrad(00U20B10B10B
textureGrad(00a20B10B10B
textureGrad(00f30B10B10B
textureGrad(00k30B20B20B
textureGrad(00s30B20B20B
textureGrad(00x30B20B20B
textureProjGrad(00I20B10B10B
textureProjGrad(00R20B10B10B
textureProjGrad(00X20B10B10B
textureProjGrad(00I30B10B10B
textureProjGrad(00R30B10B10B
textureProjGrad(00X30B10B10B
textureProjGrad(00J30B20B20B
textureProjGrad(00S30B20B20B
textureProjGrad(00Y30B20B20B
textureProjGrad(00d30B10B10B
texture(00I10B00B
texture(00R10B00B
texture(00X10B00B
texture(00J20B00B
texture(00S20B00B
texture(00Y20B00B
texture(00K20B00B
texture(00T20B00B
texture(00Z20B00B
texture(00L20B00B
texture(00U20B00B
texture(00a20B00B
textureProj(00I20B00B
textureProj(00R20B00B
textureProj(00X20B00B
textureProj(00I30B00B
textureProj(00R30B00B
textureProj(00X30B00B
textureProj(00J30B00B
textureProj(00S30B00B
textureProj(00Y30B00B
texture(00d20B00B
texture(00e30B00B
textureProj(00d30B00B
texture(00k30B00B
texture(00s30B00B
texture(00x30B00B
texture(00M10B00B
textureProj(00M20B00B
textureProj(00M30B00B
texture(00N10B00B
textureProj(00N20B00B
textureProj(00N30B00B
textureOffset(00I10B10D
textureOffset(00R10B10D
textureOffset(00X10B10D
textureOffset(00J20B20D
textureOffset(00S20B20D
textureOffset(00Y20B20D
textureOffset(00d20B10D
textureOffset(00L20B10D
textureOffset(00U20B10D
textureOffset(00a20B10D
textureProjOffset(00I20B10D
textureProjOffset(00R20B10D
textureProjOffset(00X20B10D
textureProjOffset(00I30B10D
textureProjOffset(00R30B10D
textureProjOffset(00X30B10D
textureProjOffset(00J30B20D
textureProjOffset(00S30B20D
textureProjOffset(00Y30B20D
textureProjOffset(00d30B10D
textureLodOffset(00I10B00B10D
textureLodOffset(00R10B00B10D
textureLodOffset(00X10B00B10D
textureLodOffset(00J20B00B20D
textureLodOffset(00S20B00B20D
textureLodOffset(00Y20B00B20D
textureLodOffset(00d20B00B10D
textureLodOffset(00L20B00B10D
textureLodOffset(00U20B00B10D
textureLodOffset(00a20B00B10D
textureProjLodOffset(00I20B00B10D
textureProjLodOffset(00R20B00B10D
textureProjLodOffset(00X20B00B10D
textureProjLodOffset(00I30B00B10D
textureProjLodOffset(00R30B00B10D
textureProjLodOffset(00X30B00B10D
textureProjLodOffset(00J30B00B20D
textureProjLodOffset(00S30B00B20D
textureProjLodOffset(00Y30B00B20D
textureProjLodOffset(00d30B00B10D
texelFetchOffset(00I10D00D10D
texelFetchOffset(00R10D00D10D
texelFetchOffset(00X10D00D10D
texelFetchOffset(00J20D00D20D
texelFetchOffset(00S20D00D20D
texelFetchOffset(00Y20D00D20D
texelFetchOffset(00L20D00D10D
texelFetchOffset(00U20D00D10D
texelFetchOffset(00a20D00D10D
textureGradOffset(00I10B10B10B10D
textureGradOffset(00R10B10B10B10D
textureGradOffset(00X10B10B10B10D
textureGradOffset(00J20B20B20B20D
textureGradOffset(00S20B20B20B20D
textureGradOffset(00Y20B20B20B20D
textureGradOffset(00d20B10B10B10D
textureGradOffset(00L20B10B10B10D
textureGradOffset(00U20B10B10B10D
textureGradOffset(00a20B10B10B10D
textureGradOffset(00f30B10B10B10D
textureProjGradOffset(00I20B10B10B10D
textureProjGradOffset(00R20B10B10B10D
textureProjGradOffset(00X20B10B10B10D
textureProjGradOffset(00I30B10B10B10D
textureProjGradOffset(00R30B10B10B10D
textureProjGradOffset(00X30B10B10B10D
textureProjGradOffset(00J30B20B20B20D
textureProjGradOffset(00S30B20B20B20D
textureProjGradOffset(00Y30B20B20B20D
textureProjGradOffset(00d30B10B10B10D
textureOffset(00I10B10D00B
textureOffset(00R10B10D00B
textureOffset(00X10B10D00B
textureOffset(00J20B20D00B
textureOffset(00S20B20D00B
textureOffset(00Y20B20D00B
textureOffset(00d20B10D00B
textureOffset(00L20B10D00B
textureOffset(00U20B10D00B
textureOffset(00a20B10D00B
textureProjOffset(00I20B10D00B
textureProjOffset(00R20B10D00B
textureProjOffset(00X20B10D00B
textureProjOffset(00I30B10D00B
textureProjOffset(00R30B10D00B
textureProjOffset(00X30B10D00B
textureProjOffset(00J30B20D00B
textureProjOffset(00S30B20D00B
textureProjOffset(00Y30B20D00B
textureProjOffset(00d30B10D00B
textureGather(00I10B
textureGather(00R10B
textureGather(00X10B
textureGather(00I10B00D
textureGather(00R10B00D
textureGather(00X10B00D
textureGather(00L20B
textureGather(00U20B
textureGather(00a20B
textureGather(00L20B00D
textureGather(00U20B00D
textureGather(00a20B00D
textureGather(00K20B
textureGather(00T20B
textureGather(00Z20B
textureGather(00K20B00D
textureGather(00T20B00D
textureGather(00Z20B00D
textureGather(00k30B
textureGather(00s30B
textureGather(00x30B
textureGather(00k30B00D
textureGather(00s30B00D
textureGather(00x30B00D
textureGather(00l30B00B
textureGather(00d10B
textureGather(00d10B00B
textureGather(00f20B
textureGather(00f20B00B
textureGather(00e20B
textureGather(00e20B00B
textureGatherOffset(00I10B10D
textureGatherOffset(00R10B10D
textureGatherOffset(00X10B10D
textureGatherOffset(00L20B10D
textureGatherOffset(00U20B10D
textureGatherOffset(00a20B10D
textureGatherOffset(00d10B00B10D
textureGatherOffset(00f20B00B10D
textureGatherOffset(00I10B10D00D
textureGatherOffset(00R10B10D00D
textureGatherOffset(00X10B10D00D
textureGatherOffset(00L20B10D00D
textureGatherOffset(00U20B10D00D
textureGatherOffset(00a20B10D00D
textureGatherOffsets(00I10B10Dx4
textureGatherOffsets(00R10B10Dx4
textureGatherOffsets(00X10B10Dx4
textureGatherOffsets(00L20B10Dx4
textureGatherOffsets(00U20B10Dx4
textureGatherOffsets(00a20B10Dx4
textureGatherOffsets(00d10B00B10Dx4
textureGatherOffsets(00f20B00B10Dx4
textureGatherOffsets(00I10B10Dx400D
textureGatherOffsets(00R10B10Dx400D
textureGatherOffsets(00X10B10Dx400D
textureGatherOffsets(00L20B10Dx400D
textureGatherOffsets(00U20B10Dx400D
textureGatherOffsets(00a20B10Dx400D
rgb_2_yuv(20B00H
yuv_2_rgb(20B00H
dFdx(00B
dFdx(10B
dFdx(20B
dFdx(30B
dFdy(00B
dFdy(10B
dFdy(20B
dFdy(30B
fwidth(00B
fwidth(10B
fwidth(20B
fwidth(30B
interpolateAtCentroid(00B
interpolateAtCentroid(10B
interpolateAtCentroid(20B
interpolateAtCentroid(30B
interpolateAtSample(00B00D
interpolateAtSample(10B00D
interpolateAtSample(20B00D
interpolateAtSample(30B00D
interpolateAtOffset(00B10B
interpolateAtOffset(10B10B
interpolateAtOffset(20B10B
interpolateAtOffset(30B10B
atomicCounter(00G
atomicCounterIncrement(00G
atomicCounterDecrement(00G
atomicAdd(00E00E
atomicAdd(00D00D
atomicMin(00E00E
atomicMin(00D00D
atomicMax(00E00E
atomicMax(00D00D
atomicAnd(00E00E
atomicAnd(00D00D
atomicOr(00E00E
atomicOr(00D00D
atomicXor(00E00E
atomicXor(00D00D
atomicExchange(00E00E
atomicExchange(00D00D
atomicCompSwap(00E00E00E
atomicCompSwap(00D00D00D
imageSize(00z
imageSize(01K
imageSize(01V
imageSize(01A
imageSize(01L
imageSize(01W
imageSize(01B
imageSize(01M
imageSize(01X
imageSize(01C
imageSize(01N
imageSize(01Y
imageSize(01H
imageSize(01S
imageSize(01d
imageSize(01J
imageSize(01U
imageSize(01f
imageStore(00z10D30B
imageStore(01K10D30D
imageStore(01V10D30E
imageStore(01A20D30B
imageStore(01L20D30D
imageStore(01W20D30E
imageStore(01B20D30B
imageStore(01M20D30D
imageStore(01X20D30E
imageStore(01C20D30B
imageStore(01N20D30D
imageStore(01Y20D30E
imageStore(01H20D30B
imageStore(01S20D30D
imageStore(01d20D30E
imageStore(01J00D30B
imageStore(01U00D30D
imageStore(01f00D30E
imageLoad(00z10D
imageLoad(01K10D
imageLoad(01V10D
imageLoad(01A20D
imageLoad(01L20D
imageLoad(01W20D
imageLoad(01B20D
imageLoad(01M20D
imageLoad(01X20D
imageLoad(01C20D
imageLoad(01N20D
imageLoad(01Y20D
imageLoad(01H20D
imageLoad(01S20D
imageLoad(01d20D
imageLoad(01J00D
imageLoad(01U00D
imageLoad(01f00D
imageAtomicAdd(00z10D00E
imageAtomicAdd(01K10D00E
imageAtomicAdd(01V10D00E
imageAtomicAdd(01A20D00E
imageAtomicAdd(01L20D00E
imageAtomicAdd(01W20D00E
imageAtomicAdd(01C20D00E
imageAtomicAdd(01N20D00E
imageAtomicAdd(01Y20D00E
imageAtomicAdd(01J00D00E
imageAtomicAdd(01U00D00E
imageAtomicAdd(01f00D00E
imageAtomicAdd(01B20D00E
imageAtomicAdd(01M20D00E
imageAtomicAdd(01X20D00E
imageAtomicAdd(01H20D00E
imageAtomicAdd(01S20D00E
imageAtomicAdd(01d20D00E
imageAtomicAdd(01D00D00E
imageAtomicAdd(01O00D00E
imageAtomicAdd(01Z00D00E
imageAtomicAdd(01E10D00E
imageAtomicAdd(01P10D00E
imageAtomicAdd(01a10D00E
imageAtomicAdd(01I10D00E
imageAtomicAdd(01T10D00E
imageAtomicAdd(01e10D00E
imageAtomicAdd(01F10D00D00E
imageAtomicAdd(01Q10D00D00E
imageAtomicAdd(01b10D00D00E
imageAtomicAdd(01G20D00D00E
imageAtomicAdd(01R20D00D00E
imageAtomicAdd(01c20D00D00E
imageAtomicAdd(00z10D00D
imageAtomicAdd(01K10D00D
imageAtomicAdd(01V10D00D
imageAtomicAdd(01A20D00D
imageAtomicAdd(01L20D00D
imageAtomicAdd(01W20D00D
imageAtomicAdd(01C20D00D
imageAtomicAdd(01N20D00D
imageAtomicAdd(01Y20D00D
imageAtomicAdd(01J00D00D
imageAtomicAdd(01U00D00D
imageAtomicAdd(01f00D00D
imageAtomicAdd(01B20D00D
imageAtomicAdd(01M20D00D
imageAtomicAdd(01X20D00D
imageAtomicAdd(01H20D00D
imageAtomicAdd(01S20D00D
imageAtomicAdd(01d20D00D
imageAtomicAdd(01D00D00D
imageAtomicAdd(01O00D00D
imageAtomicAdd(01Z00D00D
imageAtomicAdd(01E10D00D
imageAtomicAdd(01P10D00D
imageAtomicAdd(01a10D00D
imageAtomicAdd(01I10D00D
imageAtomicAdd(01T10D00D
imageAtomicAdd(01e10D00D
imageAtomicAdd(01F10D00D00D
imageAtomicAdd(01Q10D00D00D
imageAtomicAdd(01b10D00D00D
imageAtomicAdd(01G20D00D00D
imageAtomicAdd(01R20D00D00D
imageAtomicAdd(01c20D00D00D
imageAtomicMin(00z10D00E
imageAtomicMin(01K10D00E
imageAtomicMin(01V10D00E
imageAtomicMin(01A20D00E
imageAtomicMin(01L20D00E
imageAtomicMin(01W20D00E
imageAtomicMin(01C20D00E
imageAtomicMin(01N20D00E
imageAtomicMin(01Y20D00E
imageAtomicMin(01J00D00E
imageAtomicMin(01U00D00E
imageAtomicMin(01f00D00E
imageAtomicMin(01B20D00E
imageAtomicMin(01M20D00E
imageAtomicMin(01X20D00E
imageAtomicMin(01H20D00E
imageAtomicMin(01S20D00E
imageAtomicMin(01d20D00E
imageAtomicMin(01D00D00E
imageAtomicMin(01O00D00E
imageAtomicMin(01Z00D00E
imageAtomicMin(01E10D00E
imageAtomicMin(01P10D00E
imageAtomicMin(01a10D00E
imageAtomicMin(01I10D00E
imageAtomicMin(01T10D00E
imageAtomicMin(01e10D00E
imageAtomicMin(01F10D00D00E
imageAtomicMin(01Q10D00D00E
imageAtomicMin(01b10D00D00E
imageAtomicMin(01G20D00D00E
imageAtomicMin(01R20D00D00E
imageAtomicMin(01c20D00D00E
imageAtomicMin(00z10D00D
imageAtomicMin(01K10D00D
imageAtomicMin(01V10D00D
imageAtomicMin(01A20D00D
imageAtomicMin(01L20D00D
imageAtomicMin(01W20D00D
imageAtomicMin(01C20D00D
imageAtomicMin(01N20D00D
imageAtomicMin(01Y20D00D
imageAtomicMin(01J00D00D
imageAtomicMin(01U00D00D
imageAtomicMin(01f00D00D
imageAtomicMin(01B20D00D
imageAtomicMin(01M20D00D
imageAtomicMin(01X20D00D
imageAtomicMin(01H20D00D
imageAtomicMin(01S20D00D
imageAtomicMin(01d20D00D
imageAtomicMin(01D00D00D
imageAtomicMin(01O00D00D
imageAtomicMin(01Z00D00D
imageAtomicMin(01E10D00D
imageAtomicMin(01P10D00D
imageAtomicMin(01a10D00D
imageAtomicMin(01I10D00D
imageAtomicMin(01T10D00D
imageAtomicMin(01e10D00D
imageAtomicMin(01F10D00D00D
imageAtomicMin(01Q10D00D00D
imageAtomicMin(01b10D00D00D
imageAtomicMin(01G20D00D00D
imageAtomicMin(01R20D00D00D
imageAtomicMin(01c20D00D00D
imageAtomicMax(00z10D00E
imageAtomicMax(01K10D00E
imageAtomicMax(01V10D00E
imageAtomicMax(01A20D00E
imageAtomicMax(01L20D00E
imageAtomicMax(01W20D00E
imageAtomicMax(01C20D00E
imageAtomicMax(01N20D00E
imageAtomicMax(01Y20D00E
imageAtomicMax(01J00D00E
imageAtomicMax(01U00D00E
imageAtomicMax(01f00D00E
imageAtomicMax(01B20D00E
imageAtomicMax(01M20D00E
imageAtomicMax(01X20D00E
imageAtomicMax(01H20D00E
imageAtomicMax(01S20D00E
imageAtomicMax(01d20D00E
imageAtomicMax(01D00D00E
imageAtomicMax(01O00D00E
imageAtomicMax(01Z00D00E
imageAtomicMax(01E10D00E
imageAtomicMax(01P10D00E
imageAtomicMax(01a10D00E
imageAtomicMax(01I10D00E
imageAtomicMax(01T10D00E
imageAtomicMax(01e10D00E
imageAtomicMax(01F10D00D00E
imageAtomicMax(01Q10D00D00E
imageAtomicMax(01b10D00D00E
imageAtomicMax(01G20D00D00E
imageAtomicMax(01R20D00D00E
imageAtomicMax(01c20D00D00E
imageAtomicMax(00z10D00D
imageAtomicMax(01K10D00D
imageAtomicMax(01V10D00D
imageAtomicMax(01A20D00D
imageAtomicMax(01L20D00D
imageAtomicMax(01W20D00D
imageAtomicMax(01C20D00D
imageAtomicMax(01N20D00D
imageAtomicMax(01Y20D00D
imageAtomicMax(01J00D00D
imageAtomicMax(01U00D00D
imageAtomicMax(01f00D00D
imageAtomicMax(01B20D00D
imageAtomicMax(01M20D00D
imageAtomicMax(01X20D00D
imageAtomicMax(01H20D00D
imageAtomicMax(01S20D00D
imageAtomicMax(01d20D00D
imageAtomicMax(01D00D00D
imageAtomicMax(01O00D00D
imageAtomicMax(01Z00D00D
imageAtomicMax(01E10D00D
imageAtomicMax(01P10D00D
imageAtomicMax(01a10D00D
imageAtomicMax(01I10D00D
imageAtomicMax(01T10D00D
imageAtomicMax(01e10D00D
imageAtomicMax(01F10D00D00D
imageAtomicMax(01Q10D00D00D
imageAtomicMax(01b10D00D00D
imageAtomicMax(01G20D00D00D
imageAtomicMax(01R20D00D00D
imageAtomicMax(01c20D00D00D
imageAtomicAnd(00z10D00E
imageAtomicAnd(01K10D00E
imageAtomicAnd(01V10D00E
imageAtomicAnd(01A20D00E
imageAtomicAnd(01L20D00E
imageAtomicAnd(01W20D00E
imageAtomicAnd(01C20D00E
imageAtomicAnd(01N20D00E
imageAtomicAnd(01Y20D00E
imageAtomicAnd(01J00D00E
imageAtomicAnd(01U00D00E
imageAtomicAnd(01f00D00E
imageAtomicAnd(01B20D00E
imageAtomicAnd(01M20D00E
imageAtomicAnd(01X20D00E
imageAtomicAnd(01H20D00E
imageAtomicAnd(01S20D00E
imageAtomicAnd(01d20D00E
imageAtomicAnd(01D00D00E
imageAtomicAnd(01O00D00E
imageAtomicAnd(01Z00D00E
imageAtomicAnd(01E10D00E
imageAtomicAnd(01P10D00E
imageAtomicAnd(01a10D00E
imageAtomicAnd(01I10D00E
imageAtomicAnd(01T10D00E
imageAtomicAnd(01e10D00E
imageAtomicAnd(01F10D00D00E
imageAtomicAnd(01Q10D00D00E
imageAtomicAnd(01b10D00D00E
imageAtomicAnd(01G20D00D00E
imageAtomicAnd(01R20D00D00E
imageAtomicAnd(01c20D00D00E
imageAtomicAnd(00z10D00D
imageAtomicAnd(01K10D00D
imageAtomicAnd(01V10D00D
imageAtomicAnd(01A20D00D
imageAtomicAnd(01L20D00D
imageAtomicAnd(01W20D00D
imageAtomicAnd(01C20D00D
imageAtomicAnd(01N20D00D
imageAtomicAnd(01Y20D00D
imageAtomicAnd(01J00D00D
imageAtomicAnd(01U00D00D
imageAtomicAnd(01f00D00D
imageAtomicAnd(01B20D00D
imageAtomicAnd(01M20D00D
imageAtomicAnd(01X20D00D
imageAtomicAnd(01H20D00D
imageAtomicAnd(01S20D00D
imageAtomicAnd(01d20D00D
imageAtomicAnd(01D00D00D
imageAtomicAnd(01O00D00D
imageAtomicAnd(01Z00D00D
imageAtomicAnd(01E10D00D
imageAtomicAnd(01P10D00D
imageAtomicAnd(01a10D00D
imageAtomicAnd(01I10D00D
imageAtomicAnd(01T10D00D
imageAtomicAnd(01e10D00D
imageAtomicAnd(01F10D00D00D
imageAtomicAnd(01Q10D00D00D
imageAtomicAnd(01b10D00D00D
imageAtomicAnd(01G20D00D00D
imageAtomicAnd(01R20D00D00D
imageAtomicAnd(01c20D00D00D
imageAtomicOr(00z10D00E
imageAtomicOr(01K10D00E
imageAtomicOr(01V10D00E
imageAtomicOr(01A20D00E
imageAtomicOr(01L20D00E
imageAtomicOr(01W20D00E
imageAtomicOr(01C20D00E
imageAtomicOr(01N20D00E
imageAtomicOr(01Y20D00E
imageAtomicOr(01J00D00E
imageAtomicOr(01U00D00E
imageAtomicOr(01f00D00E
imageAtomicOr(01B20D00E
imageAtomicOr(01M20D00E
imageAtomicOr(01X20D00E
imageAtomicOr(01H20D00E
imageAtomicOr(01S20D00E
imageAtomicOr(01d20D00E
imageAtomicOr(01D00D00E
imageAtomicOr(01O00D00E
imageAtomicOr(01Z00D00E
imageAtomicOr(01E10D00E
imageAtomicOr(01P10D00E
imageAtomicOr(01a10D00E
imageAtomicOr(01I10D00E
imageAtomicOr(01T10D00E
imageAtomicOr(01e10D00E
imageAtomicOr(01F10D00D00E
imageAtomicOr(01Q10D00D00E
imageAtomicOr(01b10D00D00E
imageAtomicOr(01G20D00D00E
imageAtomicOr(01R20D00D00E
imageAtomicOr(01c20D00D00E
imageAtomicOr(00z10D00D
imageAtomicOr(01K10D00D
imageAtomicOr(01V10D00D
imageAtomicOr(01A20D00D
imageAtomicOr(01L20D00D
imageAtomicOr(01W20D00D
imageAtomicOr(01C20D00D
imageAtomicOr(01N20D00D
imageAtomicOr(01Y20D00D
imageAtomicOr(01J00D00D
imageAtomicOr(01U00D00D
imageAtomicOr(01f00D00D
imageAtomicOr(01B20D00D
imageAtomicOr(01M20D00D
imageAtomicOr(01X20D00D
imageAtomicOr(01H20D00D
imageAtomicOr(01S20D00D
imageAtomicOr(01d20D00D
imageAtomicOr(01D00D00D
imageAtomicOr(01O00D00D
imageAtomicOr(01Z00D00D
imageAtomicOr(01E10D00D
imageAtomicOr(01P10D00D
imageAtomicOr(01a10D00D
imageAtomicOr(01I10D00D
imageAtomicOr(01T10D00D
imageAtomicOr(01e10D00D
imageAtomicOr(01F10D00D00D
imageAtomicOr(01Q10D00D00D
imageAtomicOr(01b10D00D00D
imageAtomicOr(01G20D00D00D
imageAtomicOr(01R20D00D00D
imageAtomicOr(01c20D00D00D
imageAtomicXor(00z10D00E
imageAtomicXor(01K10D00E
imageAtomicXor(01V10D00E
imageAtomicXor(01A20D00E
imageAtomicXor(01L20D00E
imageAtomicXor(01W20D00E
imageAtomicXor(01C20D00E
imageAtomicXor(01N20D00E
imageAtomicXor(01Y20D00E
imageAtomicXor(01J00D00E
imageAtomicXor(01U00D00E
imageAtomicXor(01f00D00E
imageAtomicXor(01B20D00E
imageAtomicXor(01M20D00E
imageAtomicXor(01X20D00E
imageAtomicXor(01H20D00E
imageAtomicXor(01S20D00E
imageAtomicXor(01d20D00E
imageAtomicXor(01D00D00E
imageAtomicXor(01O00D00E
imageAtomicXor(01Z00D00E
imageAtomicXor(01E10D00E
imageAtomicXor(01P10D00E
imageAtomicXor(01a10D00E
imageAtomicXor(01I10D00E
imageAtomicXor(01T10D00E
imageAtomicXor(01e10D00E
imageAtomicXor(01F10D00D00E
imageAtomicXor(01Q10D00D00E
imageAtomicXor(01b10D00D00E
imageAtomicXor(01G20D00D00E
imageAtomicXor(01R20D00D00E
imageAtomicXor(01c20D00D00E
imageAtomicXor(00z10D00D
imageAtomicXor(01K10D00D
imageAtomicXor(01V10D00D
imageAtomicXor(01A20D00D
imageAtomicXor(01L20D00D
imageAtomicXor(01W20D00D
imageAtomicXor(01C20D00D
imageAtomicXor(01N20D00D
imageAtomicXor(01Y20D00D
imageAtomicXor(01J00D00D
imageAtomicXor(01U00D00D
imageAtomicXor(01f00D00D
imageAtomicXor(01B20D00D
imageAtomicXor(01M20D00D
imageAtomicXor(01X20D00D
imageAtomicXor(01H20D00D
imageAtomicXor(01S20D00D
imageAtomicXor(01d20D00D
imageAtomicXor(01D00D00D
imageAtomicXor(01O00D00D
imageAtomicXor(01Z00D00D
imageAtomicXor(01E10D00D
imageAtomicXor(01P10D00D
imageAtomicXor(01a10D00D
imageAtomicXor(01I10D00D
imageAtomicXor(01T10D00D
imageAtomicXor(01e10D00D
imageAtomicXor(01F10D00D00D
imageAtomicXor(01Q10D00D00D
imageAtomicXor(01b10D00D00D
imageAtomicXor(01G20D00D00D
imageAtomicXor(01R20D00D00D
imageAtomicXor(01c20D00D00D
imageAtomicExchange(00z10D00E
imageAtomicExchange(01K10D00E
imageAtomicExchange(01V10D00E
imageAtomicExchange(01A20D00E
imageAtomicExchange(01L20D00E
imageAtomicExchange(01W20D00E
imageAtomicExchange(01C20D00E
imageAtomicExchange(01N20D00E
imageAtomicExchange(01Y20D00E
imageAtomicExchange(01J00D00E
imageAtomicExchange(01U00D00E
imageAtomicExchange(01f00D00E
imageAtomicExchange(01B20D00E
imageAtomicExchange(01M20D00E
imageAtomicExchange(01X20D00E
imageAtomicExchange(01H20D00E
imageAtomicExchange(01S20D00E
imageAtomicExchange(01d20D00E
imageAtomicExchange(01D00D00E
imageAtomicExchange(01O00D00E
imageAtomicExchange(01Z00D00E
imageAtomicExchange(01E10D00E
imageAtomicExchange(01P10D00E
imageAtomicExchange(01a10D00E
imageAtomicExchange(01I10D00E
imageAtomicExchange(01T10D00E
imageAtomicExchange(01e10D00E
imageAtomicExchange(01F10D00D00E
imageAtomicExchange(01Q10D00D00E
imageAtomicExchange(01b10D00D00E
imageAtomicExchange(01G20D00D00E
imageAtomicExchange(01R20D00D00E
imageAtomicExchange(01c20D00D00E
imageAtomicExchange(00z10D00D
imageAtomicExchange(01K10D00D
imageAtomicExchange(01V10D00D
imageAtomicExchange(01A20D00D
imageAtomicExchange(01L20D00D
imageAtomicExchange(01W20D00D
imageAtomicExchange(01C20D00D
imageAtomicExchange(01N20D00D
imageAtomicExchange(01Y20D00D
imageAtomicExchange(01J00D00D
imageAtomicExchange(01U00D00D
imageAtomicExchange(01f00D00D
imageAtomicExchange(01B20D00D
imageAtomicExchange(01M20D00D
imageAtomicExchange(01X20D00D
imageAtomicExchange(01H20D00D
imageAtomicExchange(01S20D00D
imageAtomicExchange(01d20D00D
imageAtomicExchange(01D00D00D
imageAtomicExchange(01O00D00D
imageAtomicExchange(01Z00D00D
imageAtomicExchange(01E10D00D
imageAtomicExchange(01P10D00D
imageAtomicExchange(01a10D00D
imageAtomicExchange(01I10D00D
imageAtomicExchange(01T10D00D
imageAtomicExchange(01e10D00D
imageAtomicExchange(01F10D00D00D
imageAtomicExchange(01Q10D00D00D
imageAtomicExchange(01b10D00D00D
imageAtomicExchange(01G20D00D00D
imageAtomicExchange(01R20D00D00D
imageAtomicExchange(01c20D00D00D
imageAtomicExchange(00z10D00B
imageAtomicExchange(01K10D00B
imageAtomicExchange(01V10D00B
imageAtomicExchange(01A20D00B
imageAtomicExchange(01L20D00B
imageAtomicExchange(01W20D00B
imageAtomicExchange(01C20D00B
imageAtomicExchange(01N20D00B
imageAtomicExchange(01Y20D00B
imageAtomicExchange(01J00D00B
imageAtomicExchange(01U00D00B
imageAtomicExchange(01f00D00B
imageAtomicExchange(01B20D00B
imageAtomicExchange(01M20D00B
imageAtomicExchange(01X20D00B
imageAtomicExchange(01H20D00B
imageAtomicExchange(01S20D00B
imageAtomicExchange(01d20D00B
imageAtomicExchange(01D00D00B
imageAtomicExchange(01O00D00B
imageAtomicExchange(01Z00D00B
imageAtomicExchange(01E10D00B
imageAtomicExchange(01P10D00B
imageAtomicExchange(01a10D00B
imageAtomicExchange(01I10D00B
imageAtomicExchange(01T10D00B
imageAtomicExchange(01e10D00B
imageAtomicExchange(01F10D00D00B
imageAtomicExchange(01Q10D00D00B
imageAtomicExchange(01b10D00D00B
imageAtomicExchange(01G20D00D00B
imageAtomicExchange(01R20D00D00B
imageAtomicExchange(01c20D00D00B
imageAtomicCompSwap(00z10D00E00E
imageAtomicCompSwap(01K10D00E00E
imageAtomicCompSwap(01V10D00E00E
imageAtomicCompSwap(01A20D00E00E
imageAtomicCompSwap(01L20D00E00E
imageAtomicCompSwap(01W20D00E00E
imageAtomicCompSwap(01C20D00E00E
imageAtomicCompSwap(01N20D00E00E
imageAtomicCompSwap(01Y20D00E00E
imageAtomicCompSwap(01J00D00E00E
imageAtomicCompSwap(01U00D00E00E
imageAtomicCompSwap(01f00D00E00E
imageAtomicCompSwap(01B20D00E00E
imageAtomicCompSwap(01M20D00E00E
imageAtomicCompSwap(01X20D00E00E
imageAtomicCompSwap(01H20D00E00E
imageAtomicCompSwap(01S20D00E00E
imageAtomicCompSwap(01d20D00E00E
imageAtomicCompSwap(01D00D00E00E
imageAtomicCompSwap(01O00D00E00E
imageAtomicCompSwap(01Z00D00E00E
imageAtomicCompSwap(01E10D00E00E
imageAtomicCompSwap(01P10D00E00E
imageAtomicCompSwap(01a10D00E00E
imageAtomicCompSwap(01I10D00E00E
imageAtomicCompSwap(01T10D00E00E
imageAtomicCompSwap(01e10D00E00E
imageAtomicCompSwap(01F10D00D00E00E
imageAtomicCompSwap(01Q10D00D00E00E
imageAtomicCompSwap(01b10D00D00E00E
imageAtomicCompSwap(01G20D00D00E00E
imageAtomicCompSwap(01R20D00D00E00E
imageAtomicCompSwap(01c20D00D00E00E
imageAtomicCompSwap(00z10D00D00D
imageAtomicCompSwap(01K10D00D00D
imageAtomicCompSwap(01V10D00D00D
imageAtomicCompSwap(01A20D00D00D
imageAtomicCompSwap(01L20D00D00D
imageAtomicCompSwap(01W20D00D00D
imageAtomicCompSwap(01C20D00D00D
imageAtomicCompSwap(01N20D00D00D
imageAtomicCompSwap(01Y20D00D00D
imageAtomicCompSwap(01J00D00D00D
imageAtomicCompSwap(01U00D00D00D
imageAtomicCompSwap(01f00D00D00D
imageAtomicCompSwap(01B20D00D00D
imageAtomicCompSwap(01M20D00D00D
imageAtomicCompSwap(01X20D00D00D
imageAtomicCompSwap(01H20D00D00D
imageAtomicCompSwap(01S20D00D00D
imageAtomicCompSwap(01d20D00D00D
imageAtomicCompSwap(01D00D00D00D
imageAtomicCompSwap(01O00D00D00D
imageAtomicCompSwap(01Z00D00D00D
imageAtomicCompSwap(01E10D00D00D
imageAtomicCompSwap(01P10D00D00D
imageAtomicCompSwap(01a10D00D00D
imageAtomicCompSwap(01I10D00D00D
imageAtomicCompSwap(01T10D00D00D
imageAtomicCompSwap(01e10D00D00D
imageAtomicCompSwap(01F10D00D00D00D
imageAtomicCompSwap(01Q10D00D00D00D
imageAtomicCompSwap(01b10D00D00D00D
imageAtomicCompSwap(01G20D00D00D00D
imageAtomicCompSwap(01R20D00D00D00D
imageAtomicCompSwap(01c20D00D00D00D
pixelLocalLoadANGLE(01g
pixelLocalLoadANGLE(01h
pixelLocalLoadANGLE(01i
pixelLocalStoreANGLE(01g30B
pixelLocalStoreANGLE(01h30D
pixelLocalStoreANGLE(01i30E
beginInvocationInterlockNV(
endInvocationInterlockNV(
beginFragmentShaderOrderingINTEL(
beginInvocationInterlockARB(
endInvocationInterlockARB(
memoryBarrier(
memoryBarrierAtomicCounter(
memoryBarrierBuffer(
memoryBarrierImage(
barrier(
memoryBarrierShared(
groupMemoryBarrier(
EmitVertex(
EndPrimitive(
subpassLoad(01j
subpassLoad(01k
subpassLoad(01l
subpassLoad(01m00D
subpassLoad(01n00D
subpassLoad(01o00D
radians
degrees
asin
acos
atan
sinh
cosh
tanh
asinh
acosh
atanh
exp2
log2
sqrt
inversesqrt
sign
floor
trunc
round
roundEven
ceil
fract
clamp
step
smoothstep
modf
isnan
isinf
floatBitsToInt
floatBitsToUint
intBitsToFloat
uintBitsToFloat
frexp
ldexp
packSnorm2x16
packHalf2x16
unpackSnorm2x16
unpackHalf2x16
packUnorm2x16
unpackUnorm2x16
packUnorm4x8
packSnorm4x8
unpackUnorm4x8
unpackSnorm4x8
length
distance
cross
normalize
faceforward
reflect
refract
matrixCompMult
outerProduct
transpose
determinant
inverse
lessThan
lessThanEqual
greaterThan
greaterThanEqual
equal
notEqual
bitfieldExtract
bitfieldInsert
bitfieldReverse
bitCount
findLSB
findMSB
uaddCarry
usubBorrow
umulExtended
imulExtended
texture2D
texture2DProj
textureCube
texture3D
texture3DProj
shadow2DEXT
shadow2DProjEXT
texture2DRect
texture2DRectProj
texture2DGradEXT
texture2DProjGradEXT
textureCubeGradEXT
textureVideoWEBGL
texture3DLod
texture3DProjLod
texture2DLod
texture2DProjLod
textureCubeLod
texture2DLodEXT
texture2DProjLodEXT
textureCubeLodEXT
texture
textureProj
textureLod
textureSize
textureProjLod
texelFetch
textureGrad
textureProjGrad
textureOffset
textureProjOffset
textureLodOffset
textureProjLodOffset
texelFetchOffset
textureGradOffset
textureProjGradOffset
textureGather
textureGatherOffset
textureGatherOffsets
rgb_2_yuv
yuv_2_rgb
dFdx
dFdy
fwidth
interpolateAtCentroid
interpolateAtSample
interpolateAtOffset
atomicCounter
atomicCounterIncrement
atomicCounterDecrement
atomicAdd
atomicMin
atomicMax
atomicAnd
atomicOr
atomicXor
atomicExchange
atomicCompSwap
imageSize
imageStore
imageLoad
imageAtomicAdd
imageAtomicMin
imageAtomicMax
imageAtomicAnd
imageAtomicOr
imageAtomicXor
imageAtomicExchange
imageAtomicCompSwap
pixelLocalLoadANGLE
pixelLocalStoreANGLE
beginInvocationInterlockNV
endInvocationInterlockNV
beginFragmentShaderOrderingINTEL
beginInvocationInterlockARB
endInvocationInterlockARB
memoryBarrier
memoryBarrierAtomicCounter
memoryBarrierBuffer
memoryBarrierImage
barrier
memoryBarrierShared
groupMemoryBarrier
EmitVertex
EndPrimitive
subpassLoad
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/SyncGL.cpp
v24@?0@"<MTLSharedEvent>"8Q16
v8@?0
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Texture.cpp
onDestroy
Unhandled internal error: 
Error releasing tex image from texture
releaseTexImageInternal
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/TextureGL.cpp
setImageHelper
functions->texImage2D(nativegl::GetTextureBindingTarget(target), static_cast<GLint>(level), texImageFormat.internalFormat, size.width, size.height, 0, texImageFormat.format, texImageFormat.type, pixels)
functions->texImage3D(ToGLenum(target), static_cast<GLint>(level), texImageFormat.internalFormat, size.width, size.height, size.depth, 0, texImageFormat.format, texImageFormat.type, pixels)
functions->texImage2D(nativegl::GetTextureBindingTarget(target), 0, texImageFormat.internalFormat, 1, 1, 0, texImageFormat.format, texImageFormat.type, nullptr)
setSubImageRowByRowWorkaround
Chunking upload of texture data to work around driver hangs.
setSubImagePaddingWorkaround
setCompressedImage
functions->compressedTexImage2D(ToGLenum(target), static_cast<GLint>(level), compressedTexImageFormat.internalFormat, size.width, size.height, 0, static_cast<GLsizei>(imageSize), pixels)
functions->compressedTexImage3D(ToGLenum(target), static_cast<GLint>(level), compressedTexImageFormat.internalFormat, size.width, size.height, size.depth, 0, static_cast<GLsizei>(imageSize), pixels)
copyImage
functions->texImage2D(ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), type, zero->data())
functions->texImage2D( ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), type, nullptr)
functions->copyTexSubImage2D(ToGLenum(target), static_cast<GLint>(level), 0, 0, sourceArea.x, sourceArea.y, sourceArea.width, sourceArea.height)
functions->copyTexImage2D( ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, sourceArea.x, sourceArea.y, sourceArea.width, sourceArea.height, 0)
functions->texStorage2D(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height)
functions->compressedTexImage2D( ToGLenum(type), static_cast<GLint>(level), compressedTexImageFormat.format, levelSize.width, levelSize.height, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage2D(ToGLenum(type), static_cast<GLint>(level), texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->compressedTexImage2D( ToGLenum(face), static_cast<GLint>(level), compressedTexImageFormat.format, levelSize.width, levelSize.height, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage2D( ToGLenum(face), static_cast<GLint>(level), texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->texStorage3D(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, size.depth)
functions->compressedTexImage3D( ToGLenum(type), i, compressedTexImageFormat.format, levelSize.width, levelSize.height, levelSize.depth, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage3D(ToGLenum(type), i, texImageFormat.internalFormat, levelSize.width, levelSize.height, levelSize.depth, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->texStorage2DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, gl::ConvertToGLBoolean(fixedSampleLocations))
functions->texImage2DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, gl::ConvertToGLBoolean(fixedSampleLocations))
functions->texStorage3DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, size.depth, gl::ConvertToGLBoolean(fixedSampleLocations))
setStorageExternalMemory
functions->texStorageMem2DEXT(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, memoryObjectGL->getMemoryObjectID(), offset)
functions->texStorageMem3DEXT(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, size.depth, memoryObjectGL->getMemoryObjectID(), offset)
setImageExternal
generateMipmap
functions->texImage2D( ToGLenum(getType()), effectiveBaseLevel + levelIdx, texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->generateMipmap(ToGLenum(getType()))
initializeContents
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/TextureMtl.mm
ensureTextureCreated
generateMipmapCPU
getAttachmentRenderTarget
setSubImageImpl
setPerSliceSubImage
convertAndSetPerSliceSubImage
copySubImageCPU
copySubTextureCPU
UploadPackedDepthStencilTextureContentsWithStagingBuffer
equal
Failed to allocate host memory
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/TransformFeedbackMtl.mm
getBufferOffsets
// BEGIN: Generated code for built-in function emulation
#if defined(GL_FRAGMENT_PRECISION_HIGH)
#define emu_precision highp
#define emu_precision mediump
#endif
// END: Generated code for built-in function emulation
#extension GL_NV_shader_framebuffer_fetch : 
#extension GL_NV_draw_buffers : 
#ifdef GL_EXT_geometry_shader
#extension GL_EXT_geometry_shader : 
#elif defined GL_OES_geometry_shader
#extension GL_OES_geometry_shader : 
#error "No geometry shader extensions available." // Only generate this if the extension is "required"
#extension GL_EXT_clip_cull_distance : 
#extension GL_EXT_shader_io_blocks : 
#extension GL_EXT_shader_pixel_local_storage : enable
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_EXT_shader_framebuffer_fetch : 
#extension GL_EXT_shader_framebuffer_fetch_non_coherent : 
#extension 
invariant gl_Position;
#define emu_precision
out vec4 webgl_FragColor;
out vec4 webgl_FragData[gl_MaxDrawBuffers];
out vec4 webgl_SecondaryFragColor;
out vec4 webgl_SecondaryFragData[
#extension GL_ARB_shader_texture_lod : 
#extension GL_ARB_draw_buffers : 
#extension GL_ARB_geometry_shader4 : 
#extension GL_ARB_texture_multisample : 
#extension GL_ARB_cull_distance : 
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_gpu_shader5 : enable
#extension GL_ARB_texture_cube_map_array : enable
#extension GL_OES_texture_cube_map_array : enable
#extension GL_EXT_texture_cube_map_array : enable
#extension GL_ARB_texture_buffer_objects : enable
#extension GL_OES_texture_buffer : enable
#extension GL_EXT_texture_buffer : enable
 : enable
 : require
mask
writeSampleMask
flippedPointCoord
flippedFragCoord
ClipDistance_
@@XFB-OUT@@
void
float
uint
bool
yuvCscStandardEXT
sampler2D
sampler3D
samplerCube
samplerExternalOES
__samplerExternal2DY2YEXT
sampler2DRect
sampler2DArray
sampler2DMS
sampler2DMSArray
samplerCubeArray
samplerBuffer
isampler2D
isampler3D
isamplerCube
isampler2DArray
isampler2DMS
isampler2DMSArray
isamplerCubeArray
isamplerBuffer
usampler2D
usampler3D
usamplerCube
usampler2DArray
usampler2DMS
usampler2DMSArray
usamplerCubeArray
usamplerBuffer
sampler2DShadow
samplerCubeShadow
sampler2DArrayShadow
samplerCubeArrayShadow
structure
interface block
image2D
iimage2D
uimage2D
image3D
iimage3D
uimage3D
image2DArray
iimage2DArray
uimage2DArray
imageCube
iimageCube
uimageCube
imageCubeArray
iimageCubeArray
uimageCubeArray
imageBuffer
iimageBuffer
uimageBuffer
atomic_uint
samplerVideoWEBGL
pixelLocalANGLE
ipixelLocalANGLE
upixelLocalANGLE
subpassInput
isubpassInput
usubpassInput
subpassInputMS
isubpassInputMS
usubpassInputMS
unknown type
mat2
mat2x3
mat2x4
mat3x2
mat3
mat3x4
mat4x2
mat4x3
mat4
vec2
vec3
vec4
ivec2
ivec3
ivec4
bvec2
bvec3
bvec4
uvec2
uvec3
uvec4
Unknown error.
Window System
Shader Compiler
Third Party
Application
Other
Unknown Source
Error
Deprecated behavior
Undefined behavior
Portability
Performance
Marker
Unknown Type
High
Medium
Notification
Unknown Severity
Not initialized.
Bad access.
Bad allocation.
Bad attribute.
Bad config.
Bad context.
Bad current surface.
Bad display.
Bad match.
Bad native window.
Bad native pixmap.
Bad parameter.
Bad surface.
Context lost.
Bad stream.
Bad state.
Bad device.
Unexpected transformation after AST post-processing
<validateNoMoreTransformations>
Found symbol with undefined precision <validatePrecision>
Found child with two parents
<validateSingleParent>
Found dead code after branch
<validateNoStatementsAfterBranch>
Found reference to undeclared or inconsistenly transformed nameless interface block <validateVariableReferences>
Found reference to inconsistenly transformed nameless interface block field <validateVariableReferences>
Found reference to undeclared or inconsistently transformed variable <validateVariableReferences>
Found inconsistent references to built-in variable <validateVariableReferences>
gl_LastFragData
Incorrect qualifier applied to redeclared built-in <validateQualifiers>
Found swizzle applied to swizzle
<validateNoSwizzleOfSwizzle>
<scalar array>
<vector array>
<matrix array>
Found index node with type that is inconsistent with the array being indexed <validateExpressionTypes>
Found direct index node with a non-constant index
<validateExpressionTypes>
Found node calling built-in without a reference to the built-in function <validateBuiltInOps>
Found node calling built-in with a reference to a different function <validateBuiltInOps>
Found switch selector expression that is not integer
Found switch selector expression that is not scalar
Found function with undefined precision on return value <validatePrecision>
Found function prototype with an invalid qualifier <validateQualifiers>
Found function prototype with an invalid qualifier on opaque parameter <validateQualifiers>
Found function parameter with undefined precision <validatePrecision>
Found redeclaration of struct or interface block with the same name in the same scope <validateStructUsage>
Found reference to struct or interface block with doubly created type <validateStructUsage>
Found reference to struct or interface block with no declaration <validateStructUsage>
Found two declarations of the same function argument <validateVariableReferences>
Found node calling a raw function (deprecated) <validateNoRawFunctionCalls>
<validateNullNodes>
Found nullptr child
Found node calling function without a reference to it
<validateFunctionCall>
Found node calling previously undeclared function <validateFunctionCall>
Found multiple declarations where SeparateDeclarations should have separated them <validateMultiDeclarations>
Found two declarations of the same variable <validateVariableReferences>
Found block field with undefined precision <validatePrecision>
barrier() may not be called at any point after a return statement in the function main().
barrier
barrier() may not be called in potentially divergent flow control.
The array must be sized by the shader either redeclaring it with a size or indexing it only with constant integral expressions
Cull distance functionality is not available
The sum of 'gl_ClipDistance' and 'gl_CullDistance' size is greater than gl_MaxCombinedClipAndCullDistances (
Loop index cannot be statically assigned to within the body of the loop
Index expression must be constant
This type of loop is not allowed
while
Missing init declaration
Invalid init declaration
Invalid type for loop index
Loop index cannot be initialized with non-constant expression
Missing condition
Invalid condition
Expected loop index
Invalid relational operator
Loop index cannot be compared with non-constant expression
Missing expression
Invalid expression
Invalid built-in call
Invalid operator
Loop index cannot be modified by non-constant expression
conflicting output locations with previously defined output '
output array locations would exceed MAX_DRAW_BUFFERS
output location must be < MAX_DRAW_BUFFERS
must explicitly specify all locations when using multiple fragment outputs
not allowed to specify yuv qualifier when using depth or multiple color fragment outputs
default
label statement nested inside control flow
duplicate default label
case label type does not match switch init-expression type
duplicate case label
statement before the first label
switch
no statement between the last label and the end of the switch statement
too complex expressions inside a switch statement
Size of declared variable exceeds implementation-defined limit
' conflicting location with '
display is not initialized.
display had a context loss
No context is current.
image is not valid.
device is EGL_NO_DEVICE.
device is not valid.
sync object is not valid.
Requested GLES version (%lx.%lx) is greater than max supported (%d, %d).
Requested GLES version (%lx.%lx) is greater than max supported 3.1 for WebGL.
Unsupported API.
EGL_ANGLE_surface_orientation is not enabled.
Attribute EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE requires EGL_ANGLE_robust_resource_initialization.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_GGP_STREAM_DESCRIPTOR_ANGLE requires EGL_ANGLE_ggp_stream_descriptor.
Attribute EGL_PROTECTED_CONTEXT_EXT requires extension EGL_EXT_protected_content.
EGL_PROTECTED_CONTENT_EXT must be either EGL_TRUE or EGL_FALSE.
Attribute EGL_SWAP_INTERVAL_ANGLE requires extension EGL_ANGLE_create_surface_swap_interval.
EGL_SWAP_INTERVAL_ANGLE must be within the EGLConfig min and max swap intervals.
<buftype> EGL_IOSURFACE_ANGLE requires the EGL_ANGLE_iosurface_client_buffer extension.
<buffer> must be non null
Attribute EGL_EXTERNAL_SURFACE_ANGLE requires EGL_ANGLE_external_context_and_surface.
<buffer> must be null
Width and Height are not supported for this <buftype>
Width and Height must be positive
Invalid value for EGL_TEXTURE_FORMAT
<buftype> doesn't support rectangle texture targets
Invalid value for EGL_TEXTURE_TARGET
<buftype> doesn't support iosurface plane
<buftype> doesn't support texture type
<buftype> doesn't support texture internal format
<buftype> doesn't support setting GL colorspace
IOSurface usage hint must only contain READ or WRITE
<buftype> doesn't support setting texture offset
invalid GL colorspace
EGL_IOSURFACE requires the texture target to match the config
EGL_IOSURFACE requires the EGL_TEXTURE_RGBA format
Missing required attribute for EGL_IOSURFACE
EGL_NOK_texture_from_pixmap is not enabled.
Unknown attribute: 0x%04lx
Congfig does not suport pixmaps.
If ctx is EGL_NO_CONTEXT, surfaces must be EGL_NO_SURFACE
If ctx is not EGL_NOT_CONTEXT, draw or read must both be EGL_NO_SURFACE, or both not
If ctx is not EGL_NO_CONTEXT, surfaces must not be EGL_NO_SURFACE
read and draw must both be valid surfaces, or both be EGL_NO_SURFACE
'dpy' not a valid EGLDisplay handle
'dpy' not initialized
EGL_IMAGE_PRESERVED must be EGL_TRUE or EGL_FALSE.
EGL_GL_TEXTURE_LEVEL cannot be used without KHR_gl_texture_*_image support.
EGL_GL_TEXTURE_LEVEL cannot be negative.
EGL_GL_TEXTURE_ZOFFSET cannot be used without KHR_gl_texture_3D_image support.
EGL_GL_COLORSPACE cannot be used without EGL_KHR_gl_colorspace support.
EGL_TEXTURE_INTERNAL_FORMAT_ANGLE cannot be used without EGL_ANGLE_image_d3d11_texture or EGL_ANGLE_vulkan_image support.
EGL_D3D11_TEXTURE_PLANE_ANGLE cannot be used without EGL_ANGLE_image_d3d11_texture support.
EGL_D3D11_TEXTURE_ARRAY_SLICE_ANGLE cannot be used without EGL_ANGLE_image_d3d11_texture support.
Parameter cannot be used if target is not EGL_LINUX_DMA_BUF_EXT
Parameter cannot be used without EGL_EXT_image_dma_buf_import support.
Invalid value for EGL_YUV_COLOR_SPACE_HINT_EXT.
Invalid value for EGL_SAMPLE_RANGE_HINT_EXT.
Invalid value for EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT or EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT.
Parameter cannot be used without EGL_EXT_image_dma_buf_import_modifiers support.
Attribute EGL_VULKAN_IMAGE_CREATE_INFO_{HI,LO}_ANGLE require extension EGL_ANGLE_vulkan_image.
invalid attribute: 0x%04lxX
KHR_gl_texture_2D_image not supported.
buffer cannot reference a 2D texture with the name 0.
target is not a 2D texture.
texture has a surface bound to it.
target 2D texture does not have a valid size at specified level.
EGL_PROTECTED_CONTENT_EXT attribute does not match protected state of target.
KHR_gl_texture_cubemap_image not supported.
buffer cannot reference a cubemap texture with the name 0.
target is not a cubemap texture.
target cubemap texture does not have a valid size at specified level and face.
if level is zero and the texture is incomplete, it must have all of its faces specified at level zero.
KHR_gl_texture_3D_image not supported.
buffer cannot reference a 3D texture with the name 0.
target is not a 3D texture.
target 3D texture does not have a valid size at specified level.
target 3D texture does not have enough layers for the specified Z offset at the specified level.
KHR_gl_renderbuffer_image not supported.
EGL_GL_TEXTURE_LEVEL cannot be used in conjunction with a renderbuffer target.
buffer cannot reference a renderbuffer with the name 0.
target is not a renderbuffer.
target renderbuffer cannot be multisampled.
EGL_ANDROID_image_native_buffer not supported.
ctx must be EGL_NO_CONTEXT.
EGL_ANGLE_image_d3d11_texture not supported.
EGL_EXT_image_dma_buf_import not supported.
buffer must be NULL.
Missing required parameter 0x%X for image target EGL_LINUX_DMA_BUF_EXT.
the list of attributes contains EGL_DMA_BUF_PLANE*_MODIFIER_LO_EXT but not EGL_DMA_BUF_PLANE*_MODIFIER_HI_EXT or vice versa.
EGL_ANGLE_metal_texture_client_buffer not supported.
EGL_ANGLE_vulkan_image not supported.
Missing required parameter 0x%X for image target EGL_VULKAN_IMAGE_ANGLE.
invalid target: 0x%X
EGL_GL_TEXTURE_ZOFFSET must be used with a 3D texture target.
EGL_KHR_image not supported.
Device creation extension not active
Invalid attrib_list parameter
D3D11 device creation extension not active
Invalid device_type parameter
Invalid device parameter
Device must have been created using eglCreateDevice
EGL_KHR_wait_sync extension is not available
Server-side waits cannot be performed without GL_OES_EGL_sync support.
flags must be zero
Invalid value parameter
Stream extension not active
Bad stream state
Consumer GLTexture extension not active
Invalid attribute
Stream consumer extension not active
EGL stream consumer external GL extension not enabled
Invalid stream
Invalid stream state
No external texture bound
Current GL context not associated with stream consumer
Invalid stream consumer type
Invalid color buffer type
Invalid plane count
Invalid texture unit
Plane count must be 0 for RGB buffer
Planes cannot be specified
Invalid YUV plane count
Invalid plane specified
Not all planes specified
No external texture bound at one or more specified texture units
Multiple planes bound to same texture object
Stream producer extension not active
Stream not in connecting state
Incompatible stream consumer type
Invalid subresource index
Invalid plane offset
Stream not fully configured
Incompatible stream producer
Texture is null
syncControlCHROMIUM extension not active
syncControlRateANGLE extension not active
numerator is null
denominator is null
ust is null
msc is null
sbc is null
EGL_KHR_swap_buffers_with_damage is not available.
Swap surface cannot be EGL_NO_SURFACE.
n_rects cannot be negative.
n_rects cannot be greater than zero when rects is NULL.
the 'engine' parameter has an unrecognized value
EGL_ANDROID_presentation_time is not available.
Blob cache functions can only be set once in the lifetime of a Display
Blob cache callbacks cannot be null.
num_config cannot be null.
EGL_EXT_platform_base not supported
ValidateCreatePlatformPixmapSurfaceEXT unimplemented.
Extension not supported
Invalid program cache attribute.
Program index out of range.
keysize and binarysize must always be valid pointers.
Invalid program key size.
key and binary must both be null or both non-null.
null pointer in arguments.
binarysize out of valid range.
limit must be non-negative.
Invalid cache resize mode.
Surface cannot be EGL_NO_SURFACE.
Surface does not support EGL_MULTISAMPLE_RESOLVE_BOX.
Invalid multisample resolve type.
Surface does not support EGL_SWAP_BEHAVIOR_PRESERVED.
Invalid swap behaviour.
EGL_WIDTH or EGL_HEIGHT cannot be set without EGL_ANGLE_window_fixed_size support.
EGL_WIDTH or EGL_HEIGHT cannot be set without EGL_FIXED_SIZE_ANGLE being enabled on the surface.
EGL_TIMESTAMPS_ANDROID cannot be used without EGL_ANDROID_get_frame_timestamps support.
Invalid value.
EGL_RENDER_BUFFER must be EGL_BACK_BUFFER or EGL_SINGLE_BUFFER.
Attribute EGL_RENDER_BUFFER requires EGL_KHR_mutable_render_buffer.
EGL_RENDER_BUFFER requires the surface type bit EGL_MUTABLE_RENDER_BUFFER_BIT_KHR.
Invalid surface attribute: 0x%04X
EGL_POST_SUB_BUFFER_SUPPORTED_NV cannot be used without EGL_ANGLE_surface_orientation support.
EGL_FIXED_SIZE_ANGLE cannot be used without EGL_ANGLE_window_fixed_size support.
EGL_SURFACE_ORIENTATION_ANGLE cannot be queried without EGL_ANGLE_surface_orientation support.
EGL_DIRECT_COMPOSITION_ANGLE cannot be used without EGL_ANGLE_direct_composition support.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE cannot be used without EGL_ANGLE_robust_resource_initialization support.
EGL_BUFFER_AGE_EXT cannot be used without EGL_EXT_buffer_age support.
The surface must be current to the current context in order to query buffer age per extension EGL_EXT_buffer_age.
EGL_KHR_lock_surface3 is not supported.
EGL_EXT_protected_content not supported
Attribute EGL_CONTEXT_PRIORITY_LEVEL_IMG requires extension EGL_IMG_context_priority.
Invalid context attribute: 0x%04X
EGL_KHR_debug extension is not available.
message controls must be EGL_TRUE or EGL_FALSE.
Unknown attribute: 0x%04X
EGL_ANDROID_get_frame_timestamps extension is not available.
invalid timing name.
names is NULL.
values is NULL.
numTimestamps must be at least 0.
invalid compositor timing.
compositor timing not supported by surface.
frameId is NULL.
invalid timestamp type.
timestamp collection is not enabled for this surface.
timestamps is NULL.
timestamp not supported by surface.
EGL_ANGLE_feature_control extension is not available.
index is negative.
name is not valid.
index is too big.
NULL buffer.
invalid attribute list.
incorrect channel size requested
invalid usage flag
invalid attribute
incorrect buffer dimensions requested
unsupported format
EGL_ANGLE_metal_shared_event_sync is not available.
EGL_ANDROID_native_fence_sync extension is not available.
EGL_ANGLE_swap_buffers_with_frame_token is not available.
EGL_KHR_reusable_sync extension is not available.
eglSignalSyncKHR invalid mode.
EGL_EXT_device_query not supported.
Invalid surface type
Config does not support EGL_LOCK_SURFACE_BIT
Surface cannot be current to a context for eglLockSurface()
Surface cannot be protected content for eglLockSurface()
Invalid EGL_MAP_PRESERVE_PIXELS_KHR value
Invalid EGL_LOCK_USAGE_HINT_KHR value
Invalid query surface64 attribute
Invalid eglQuerySurface64 attribute
value is NULL.
Surface is not locked
Surface is not locked.
Output VkImage pointer is null.
Output VkImageCreateInfo pointer is null.
surface is not a postable surface
surface is not the current draw surface for the calling thread
surface's swap behavior is not EGL_BUFFER_DESTROYED
damage region has already been set on surface since the most recent frame boundary
EGL_BUFFER_AGE_KHR attribute of surface has not been queried since the most recent frame boundary
EGL_EXT_dma_buf_import_modfier not supported
max_formats should not be negative
if max_formats is positive, formats should not be NULL
max_modifiers should not be negative
if max_modifiers is positive, modifiers should not be NULL
format should be one of the formats advertised by QueryDmaBufFormatsEXT
display is EGL_NO_DISPLAY.
display is not a valid display: 0x%p
when object type is EGL_OBJECT_DISPLAY_KHR, the object must be the same as the display.
unknown object type.
OpenGL profile mask requires an OpenGL context.
Invalid Context attribute.
Attribute EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE requires EGL_ANGLE_create_context_webgl_compatibility.
Attribute EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM requires EGL_CHROMIUM_create_context_bind_generates_resource.
Attribute EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_texture_share_group.
Attribute EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_semaphore_share_group.
Attribute EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE requires EGL_ANGLE_create_context_client_arrays.
Attribute EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE requires EGL_ANGLE_program_cache_control.
Attribute EGL_EXTENSIONS_ENABLED_ANGLE requires EGL_ANGLE_create_context_extensions_enabled.
Attribute EGL_POWER_PREFERENCE_ANGLE requires EGL_ANGLE_power_preference.
Attribute EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE requires EGL_ANGLE_create_context_backwards_compatible.
Attribute EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV requires extension EGL_NV_robustness_video_memory_purge.
Attribute EGL_EXTERNAL_CONTEXT_ANGLE requires EGL_ANGLE_external_context_and_surface.
Attribute EGL_EXTERNAL_CONTEXT_SAVE_STATE_ANGLE requires EGL_ANGLE_external_context_and_surface.
Attribute EGL_CONTEXT_VIRTUALIZATION_GROUP_ANGLE requires extension EGL_ANGLE_context_virtualization.
Attribute EGL_CONTEXT_METAL_OWNERSHIP_IDENTITY_ANGLE requires EGL_ANGLE_metal_create_context_ownership_identity.
Unknown attribute: 0x%04lxX
Invalid OpenGL profile mask.
Attribute must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM must be EGL_TRUE or EGL_FALSE.
EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
All contexts within a share group must be created with the same value of EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE.
EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
All contexts within a share group must be created with the same value of EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE.
EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_EXTENSIONS_ENABLED_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_POWER_PREFERENCE_ANGLE must be either EGL_LOW_POWER_ANGLE or EGL_HIGH_POWER_ANGLE.
EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE must be either EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_PRIORITY_LEVEL_IMG must be one of: EGL_CONTEXT_PRIORITY_LOW_IMG, EGL_CONTEXT_PRIORITY_MEDIUM_IMG, or EGL_CONTEXT_PRIORITY_HIGH_IMG.
EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV must be either EGL_TRUE or EGL_FALSE.
EGL_EXTERNAL_CONTEXT_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_EXTERNAL_CONTEXT_ANGLE doesn't allow creating with sharedContext.
EGL_EXTERNAL_CONTEXT_SAVE_STATE_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_METAL_OWNERSHIP_IDENTITY_ANGLE mustbe non-zero.
EXT_gl_colorspace_display_p3_linear is not available.
EXT_gl_colorspace_display_p3 is not available.
EGL_EXT_gl_colorspace_display_p3_passthrough is not available.
EXT_gl_colorspace_scrgb is not available.
EXT_gl_colorspace_scrgb_linear is not available.
Surface not compatible with OpenGL ES 1.x.
Surface not compatible with OpenGL ES 2.x.
Surface not compatible with OpenGL ES 3.x.
Surface not compatible with Context API.
Surface not compatible with OpenGL Desktop.
Context with no config is not supported.
Color buffer types are not compatible.
Color buffer sizes are not compatible.
Color buffer component types are not compatible.
Depth-stencil buffer types are not compatible.
Surface type is not compatible.
texture must be complete if level is non-zero.
if level is zero and the texture is incomplete, it must have no mip levels specified except zero.
EGL_KHR_fence_sync extension is not available
CreateSync can only be called on the current display
EGL_SYNC_FENCE_KHR cannot be used without GL_OES_EGL_sync support.
EGL_ANGLE_metal_shared_event_sync is not available
EGL_SYNC_METAL_SHARED_EVENT_ANGLE can't be NULL
Invalid type parameter
EGL_SYNC_CONDITION_KHR is not valid for this sync type.
Attempt to initialize readonly parameter
Latency must be positive
Consumer GL extension not enabled
Timeout must be positive
Invalid stream attribute
EGL_EXT_pixel_format_float is not enabled.
EGL_ANDROID_recordable is not enabled.
EGL_ANDROID_framebuffer_target is not enabled.
EGL_ANGLE_iosurface_client_buffer is not enabled.
EGL_KHR_lock_surface3 is not enabled.
EGL_bind_to_texture invalid attribute: 0x%X
EGL_color_buffer_type invalid attribute: 0x%X
EGL_native_renderable invalid attribute: 0x%X
EGL_transparent_type invalid attribute: 0x%X
EGL_RECORDABLE_ANDROID invalid attribute: 0x%X
EGL_COLOR_COMPONENT_TYPE_EXT invalid attribute: 0x%X
EGL_KHR_lock_surface3 invalid attribute: 0x%X
Platform ANGLE extension is not active
Platform Device extension is not active
Platform GBM extension is not active
Platform Wayland extension is not active
Bad platform type.
Invalid automatic trim attribute
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE extension not active.
Invalid D3D11on12 attribute
EGL_ANGLE_experimental_present_path extension not active
Invalid value for EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE
EGL_ANGLE_platform_angle_d3d is not supported
EGL_ANGLE_platform_angle_device_type_egl_angle is not supported
EGL_ANGLE_platform_angle_device_type_swiftshader is not supported
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE attrib
EGL_ANGLE_platform_angle extension not active
EGL_PLATFORM_ANGLE_DEBUG_LAYERS_ENABLED_ANGLE must be EGL_TRUE, EGL_FALSE, or EGL_DONT_CARE.
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_EAGL_ANGLE attrib
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_CGL_ANGLE attrib
EGL_ANGLE_platform_angle_device_id is not supported
Must specify major version if you specify a minor version.
EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_ENABLE_AUTOMATIC_TRIM_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE requires a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE requires a device type of EGL_PLATFORM_ANGLE_DEVICE_TYPE_HARDWARE_ANGLE or EGL_PLATFORM_ANGLE_DEVICE_TYPE_D3D_WARP_ANGLE
EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D_LUID_HIGH_ANGLE and EGL_PLATFORM_ANGLE_D3D_LUID_LOW_ANGLE require a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
If either EGL_PLATFORM_ANGLE_D3D_LUID_HIGH_ANGLE and/or EGL_PLATFORM_ANGLE_D3D_LUID_LOW_ANGLE are specified, at least one must non-zero.
If either EGL_PLATFORM_ANGLE_DEVICE_ID_HIGH_ANGLE and/or EGL_PLATFORM_ANGLE_DEVICE_ID_LOW_ANGLE are specified, at least one must non-zero.
This device type requires a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE or EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE.
This device type requires a platform type of EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE.
EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE currently only supports Vulkan 1.0.
EGL_PLATFORM_ANGLE_EGL_HANDLE_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE.
native_display should be a valid EGL device if platform equals EGL_PLATFORM_DEVICE_EXT
Attribute EGL_POWER_PREFERENCE_ANGLE requires EGL_ANGLE_display_power_preference.
EGL_ANGLE_feature_control is not supported
EGL_FEATURE_OVERRIDES_ENABLED_ANGLE must be a valid pointer
EGL_FEATURE_OVERRIDES_DISABLED_ANGLE must be a valid pointer
Direct3D platform is unsupported.
OpenGL platform is unsupported.
Display type EGL_PLATFORM_ANGLE_TYPE_NULL_ANGLE requires EGL_ANGLE_platform_angle_null.
Vulkan platform is unsupported.
Metal platform is unsupported.
Unknown platform type.
EGL_EXT_device_query extension is not available.
attribute is not valid.
Invalid or unsupported texture target.
A texture must be bound.
Insufficient buffer size.
Enum 0x%04X is currently not supported.
OpenGL ES 3.0 Required.
GLES1-only function.
Invalid pname.
Base level must be at least 0.
Base level must be 0.
Level of detail outside of range.
Enum requires GLES 3.1
Extension is not enabled.
EGL_ANGLE_robust_resource_initialization not enabled.
GL_EXT_protected_textures not enabled.
Protected Texture must match Protected Context
Sampler is not valid
Primcount must be greater than or equal to zero.
Attempting to draw without a program
At least one enabled attribute must have a divisor of zero.
Negative size.
The texture is a non-power-of-two texture.
Internal error: unknown internal format.
Integer overflow.
It is undefined behavior to use a pixel unpack buffer that is bound for transform feedback.
imageSize must be 0 if no texture data is provided.
imageSize is too small.
Stride is over the maximum stride allowed by WebGL.
Offset must be a multiple of the passed in datatype.
Stride must be a multiple of the passed in datatype.
Expected a program name, but found a shader name.
Program object expected.
Expected a shader name, but found a program name.
Shader object expected.
Invalid Attachment Type.
Invalid renderbuffer target.
Renderbuffer width and height cannot be negative and cannot exceed maximum texture size.
Invalid renderbuffer internalformat.
Desired resource size is greater than max renderbuffer size.
Invalid blit filter.
Invalid blit mask.
Only nearest filtering can be used when blitting buffers other than the color buffer.
Read and draw framebuffers must both exist for a blit to succeed.
Blitting to or from a YUV framebuffer is disallowed.
Blit feedback loop: the read and draw framebuffers are the same.
BlitFramebuffer dimensions out of 32-bit integer range.
If the read buffer contains fixed-point or floating-point values, the draw buffer must as well.
If the read buffer contains fixed-point values, the draw buffer must as well.
If the read buffer contains unsigned integer values the draw buffer must as well.
If the read buffer contains signed integer values the draw buffer must as well.
Attempt to blit from a multisampled framebuffer and the bounds or format of the color buffer don't match with the draw framebuffer.
Read and write color attachments cannot be the same image.
Cannot use GL_LINEAR filter when blitting a integer framebuffer.
Attempt to read from a missing color attachment of a complete framebuffer.
Depth/stencil buffer format combination not allowed for blit.
Attempt to blit from a multisampled framebuffer and the bounds don't match with the draw framebuffer.
Read and write depth stencil attachments cannot be the same image.
Attempt to read from a missing depth/stencil attachment of a complete framebuffer.
Attempt to read from a multi-view framebuffer.
Attempt to write to a multi-view framebuffer.
Invalid framebuffer target.
Object cannot be used because it has not been generated.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_WIDTH.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_HEIGHT.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_SAMPLES.
GL_EXT_geometry_shader or GL_OES_geometry_shader extension not enabled.
Framebuffer layer cannot be less than 0 or greater than GL_MAX_FRAMEBUFFER_LAYERS_EXT.
Default framebuffer is bound.
It is invalid to change default FBO's attachments
No Texture is bound to the specified target.
Mismatch between Texture and Context Protected Content state
Texture base level out of range
Texture format does not support mipmap generation.
Texture is not cubemap complete. All cubemaps faces must be defined and be the same size.
Cannot generate mipmaps for a zero-size texture in a WebGL context.
Negative buffer size.
Query extension not enabled.
Invalid query type.
Invalid query Id.
Other query is active.
Query type does not match target.
Query is not active.
Invalid query target.
Query is active.
Context has been lost.
Negative count.
Program not linked.
Invalid uniform location
Only array uniforms may have count > 1.
Sampler uniform value out of range.
Uniform type does not match uniform method.
Index must be less than MAX_DRAW_BUFFERS.
GL_ANGLE_texture_multisample_array not enabled.
Texture buffer extension not available.
Read buffer is GL_NONE.
Read buffer has no attachment.
name is not a valid renderbuffer.
Not a valid texture object name.
Passed in texture type must match the one originally used to define the texture.
Invalid target.
Negative offset.
The specified dimensions are outside of the bounds of the texture.
The texture is not complete.
Invalid region for compressed texture format.
Texture level does not exist.
Texture formats are not compatible
Samples must not be greater than maximum supported value for the format.
Offset overflows texture dimensions.
Border must be 0.
Missing read attachment.
Copying from a YUV framebuffer is disallowed.
The active read framebuffer object has multiview attachments.
Texture is immutable.
Invalid format.
Desired resource size is greater than max texture size.
Feedback loop formed between Framebuffer and active Texture.
There is no current program object specified by UseProgram, there is a current program pipeline object, and that object is empty (no executable code is installed for any stage).
A program object is active for at least one, but not all of the shader stages that were present when the program was linked.
It is a undefined behaviour to render without vertex shader stage or fragment shader stage.
An active buffer is mapped
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/validationES.cpp
ValidateDrawStates
This ANGLE implementation does not support separate front/back stencil writemasks, reference values, or stencil mask values.
Stencil reference and mask values must be the same for front facing and back facing triangles.
GL_BLEND with floating-point color attachments requires the EXT_float_blend extension.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination color factors in the blend function.
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR as color factors is not supported by this implementation.
Red, green and blue color writes must be enabled when writing to YUV framebuffers.
Blending must be disabled when writing to YUV framebuffers.
External texture attached to framebuffer is not YUV.
Advanced blend equation can only be used when only one draw buffer is not NONE
An enabled vertex array has no buffer.
An enabled vertex array has no buffer and no pointer.
Two textures of different types use the same sampler location.
Any command that transfers vertices to the GL requires a vertex shader if the current program uses a tessellation shader.
Tessellation requires both control and evaluation shaders.
Every binding point used in transform feedback mode must have a buffer object bound.
Program and framebuffer YUV output state does not match.
Mismatch between texture format and sampler type (signed/unsigned/float/shadow).
A transform feedback buffer that would be written to is also bound to a non-transform-feedback target, which would cause undefined behavior.
Vertex shader input type does not match the type of the bound vertex attribute.
Active draw buffers with missing fragment shader outputs.
Fragment shader output type does not match the bound framebuffer attachment type.
It is undefined behavior to use a vertex buffer that is bound for transform feedback.
Draw mode must match current transform feedback object's draw mode.
GL_EXT_tessellation_shader extension not enabled.
Invalid draw mode.
Primitive mode is incompatible with the input primitive type of the geometry shader.
When tessellation is active the primitive mode must be GL_PATCHES.
When tessellation is not active the primitive mode must not be GL_PATCHES.
The draw command is unsupported when transform feedback is active and not paused.
It is undefined behavior to use an element array buffer that is bound for transform feedback.
Must have element array buffer bound.
Program doesn't exist.
Negative number of attachments.
Invalid attachment when the default framebuffer is bound.
Index is greater than the maximum supported color attachments
Invalid attachment when a user framebuffer is bound.
EGL image is not valid.
Cannot create a 2D texture from a multisampled EGL image.
EGL image internal format is not supported as a texture.
Image is YUV, target must be TEXTURE_EXTERNAL_OES
The source EGL image is incompatible with the target texture type.
Mismatch between Image and Context Protected Content state
EGL image internal format is not supported as a renderbuffer.
Program binary format is not valid.
Cannot change program binary while program is associated with an active transform feedback object.
No program binary formats supported.
Invalid draw buffer.
Ith value does not match COLOR_ATTACHMENTi or NONE.
The default framebuffer must have exactly one draw buffer.
Only NONE or BACK are valid draw buffers for the default framebuffer
Invalid buffer target.
Can not get pointer for reserved buffer name zero.
Buffer is not mapped.
Negative length.
Attempted to map buffer object zero.
Mapped range does not fit into buffer dimensions.
Invalid access bits.
Length must not be zero.
Buffer is already mapped.
Need to map buffer for either reading or writing.
Invalid access bits when mapping buffer for reading
The explicit flushing bit may only be set if the buffer is mapped for writing.
Attempted to flush buffer object zero.
Attempted to flush a buffer not mapped for explicit flushing.
Flushed range does not fit into buffer mapping dimensions.
More parameters are required than were provided.
Attachment type must be compatible with attachment object.
Invalid parameter name for framebuffer attachment.
Enum requires GLES 3.0
No active compute shader stage in this program.
No active geometry shader stage in this program.
No defined conversion between clear value and attachment format.
dataSize is too small
A buffer must be bound.
GL_BUFFER_MAP_POINTER can only be queried with GetBufferPointerv.
A renderbuffer must be bound.
GL_ANGLE_get_image extension not enabled.
Index must be less than MAX_VERTEX_ATTRIBS.
It is undefined behavior to use a pixel pack buffer that is bound for transform feedback.
The provided parameters overflow with the provided buffer.
Invalid combination of pack parameters for WebGL.
Invalid format and type combination.
Index exceeds active uniform block count.
Internal format is not renderable.
GL_ANGLE_texture_multisample or GLES 3.1 required.
Invalid operation on multisampled framebuffer
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_TEXTURE_UNITS)
Width and height must be less than or equal to GL_MAX_TEXTURE_SIZE.
Samples may not be zero.
SizedInternalformat must be color-renderable, depth-renderable, or stencil-renderable.
Internalformat is one of the unsupported unsized base internalformats.
Zero is bound to target.
The value of TEXTURE_IMMUTABLE_FORMAT for the texture currently bound to target on the active texture unit is true.
Texture dimensions must all be greater than zero.
Index must be less than the value of SAMPLES.
MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS.
Vertex buffer is not big enough for the draw call
Reset status is not valid
Invalid logical operation.
Parameter outside of bounds.
Uniform size does not match uniform method.
The number of views in the active program and draw framebuffer does not match.
There is an active transform feedback object when the number of views in the active draw framebuffer is greater than 1.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
It is undefined behaviour to have a used but unbound uniform buffer.
It is undefined behaviour to use a uniform buffer that is too small.
It is undefined behavior to use an uniform buffer that is bound for transform feedback.
Active fragment shader does not include the layout qualifier matching the blend equation
Invalid wrap mode for texture type.
Texture wrap mode not recognized.
Texture only supports NEAREST and LINEAR filtering.
Texture filter not recognized.
Unknown parameter value.
Invalid enum provided.
GLES1-only function.
GL_OES_point_size_array not enabled.
Invalid client vertex array type.
Invalid stride for built-in vertex attribute.
Size for built-in vertex attribute is outside allowed range.
Invalid type for built-in vertex attribute.
Invalid light.
Light parameter out of range.
Invalid light parameter.
Material parameter out of range.
Invalid material parameter.
Invalid material face.
Invalid light model parameter.
Invalid clip plane.
Invalid fog mode.
Invalid fog density (must be nonnegative).
Invalid fog parameter.
Invalid texture environment mode.
Invalid texture combine mode.
Invalid texture combine source.
Invalid texture combine operand.
Invalid texture environment scale.
Invalid texture environment parameter.
Invalid texture environment target.
Invalid point parameter value (must be non-negative).
Invalid point parameter.
Invalid point size (must be positive).
Both width and height argument of drawn texture must be positive.
Near value cannot be greater than far.
Invalid projection matrix. Left/right, top/bottom, near/far intervals cannot be zero, and near/far cannot be less than zero.
Invalid width.
Invalid matrix mode.
Current matrix stack has only a single matrix.
Current matrix stack is full.
Invalid shading model.
Extension is not enabled.
Invalid framebuffer target.
Mipmap level must be 0 when attaching a texture.
Invalid or unsupported texture target.
Textarget must match the texture target type.
Level of detail outside of range.
Rectangle texture cannot have a compressed format.
Each cubemap face must have equal width and height.
Invalid or unsupported texture target.
A buffer must be bound.
Invalid internal format 0x%04X.
Invalid compressed image size.
Enum 0x%04X is currently not supported.
Invalid texture target and format combination.
Pixel data must be null.
Texture level must be zero.
Passed in texture target and format must match the one originally used to define the texture.
Pixel data cannot be null.
Invalid combination of format, type and internalFormat.
Texture dimensions must all be greater than zero.
Invalid level count.
Texture dimensions must be power-of-two.
Extension is not enabled.
Invalid framebuffer target.
Invalid debug source.
Invalid debug type.
Invalid debug severity.
If count is greater than zero, source and type cannot be GL_DONT_CARE.
Message length is larger than GL_MAX_DEBUG_MESSAGE_LENGTH.
Negative buffer size.
Cannot push more than GL_MAX_DEBUG_GROUP_STACK_DEPTH debug groups.
Cannot pop the default debug group.
Blit extension not available.
Scaling and flipping in BlitFramebufferANGLE not supported by this implementation.
Linear blit not supported in this extension.
Blits are only supported from 2D texture, renderbuffer or default framebuffer attachments in this extension.
Blits are only supported to 2D texture, renderbuffer or default framebuffer attachments in this extension.
Attempting to blit and the read and draw buffer formats don't match. read: 0x%04X draw: 0x%04X
Only whole-buffer blit is supported from a multisampled read buffer in this extension.
Only whole-buffer depth and stencil blits are supported by this extension.
Multisampled depth/stencil blit is not supported by this extension.
Invalid mask bits.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
Integer overflow.
Compressed texture dimensions must exactly match the dimensions of the data passed in.
Invalid buffer target.
Attempted to map buffer object zero.
Invalid access bits.
Buffer is already mapped.
Buffer is bound for transform feedback.
Location cannot be less than 0.
Location must be less than (MAX_VERTEX_UNIFORM_VECTORS + MAX_FRAGMENT_UNIFORM_VECTORS) * 4
Name contains invalid characters.
Attributes that begin with 'gl_' are not allowed.
components is not one of GL_RGB, GL_RGBA, GL_ALPHA or GL_NONE.
Source texture is not a valid texture object.
Invalid source texture level.
Source texture internal format is invalid.
Destination texture is not a valid texture object.
Copy*TextureCHROMIUM from EXTERNAL_OES to integer format requires OES_EGL_image_external_essl3
Invalid destination texture type.
Destination texture cannot be immutable.
Source texture must be a valid texture type.
Negative offset.
Negative size.
The destination level of the destination texture must be defined.
Source texture must level 0 defined.
Source texture must have a compressed internal format.
OpenGL ES 3.1 Required
Invalid shader type.
Invalid buffer usage enum.
Buffer is immutable.
An active buffer is mapped
Buffer is not updatable.
The provided parameters overflow with the provided buffer.
Insufficient buffer size.
Extension is not requestable.
Extension is not disablable.
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_COMBINED_IMAGE_UNITS)
Shader attachment already has a shader.
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid blend equation.
Invalid blend function.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination color factors in the blend function.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/validationES2.cpp
ValidateBlendFuncSeparate
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR as color factors is not supported by this implementation.
Invalid name.
Invalid width.
Near value cannot be greater than far.
Samples must not be greater than maximum supported value for the format.
Cull mode not recognized.
Expected a program name, but found a shader name.
Program object expected.
Shader object expected.
Expected a shader name, but found a program name.
Shader to be detached must be currently attached to the program.
Index must be less than program active uniform count.
Negative maxcount.
webgl_
_webgl_
A program must be bound.
Program not linked.
Compute shader precision not yet implemented.
Invalid or unsupported precision type.
Invalid pname.
param is negative.
Unpack alignment must be 1, 2, 4 or 8.
Invalid shader binary format.
Negative count.
Invalid stencil.
Viewport size cannot be negative.
Cap 0x%04X cannot be enabled or disabled while pixel local storage is active.
Current renderer doesn't support alpha-to-coverage.
ValidateEnable
Mipmap level must be 0 when attaching a texture.
Textarget must match the texture target type.
GL_ANGLE_texture_multisample or GLES 3.1 required.
GL_EXT_YUV_target not enabled.
Invalid Attachment Type.
zoffset is larger than MAX_3D_TEXTURE_SIZE-1
Texture has incompatible target.
OpenGL ES 3.0 Required.
Cannot link program while program is associated with an active transform feedback object.
Cannot change active program while transform feedback is unpaused.
GL_NV_fence is not supported
Invalid fence object.
Fence must be set.
Invalid value for condition.
The current context doesn't support setting a non-zero divisor on the attribute with index zero. Please reorder the attributes in your vertex shader so that attribute zero can have a zero divisor.
ValidateVertexAttribDivisorANGLE
Context does not support GL_ANGLE_texture_rectangle
GL_ANGLE_texture_multisample_array not enabled.
External texture extension not enabled
Vertex array does not exist.
name is not a valid buffer.
name is not a valid vertex array.
name is not a valid query.
name is not a valid transform feedback.
name is not a valid sampler.
name is not a valid framebuffer.
name is not a valid program pipeline.
Invalid identifier.
Label length is larger than GL_MAX_LABEL_LENGTH.
Not a valid sync pointer.
Location name lengths must not be greater than 256 characters.
Location lengths must not be greater than 1024 characters.
Attributes that begin with 'webgl_', or '_webgl_' are not allowed.
Invalid format.
Invalid or unsupported texture target.
Level of detail outside of range.
Desired resource size is greater than max texture size.
Rectangle texture cannot have a compressed format.
Each cubemap face must have equal width and height.
The cubemap depth must be a multiple of 6.
Enum 0x%04X is currently not supported.
No Texture is bound to the specified target.
Texture is immutable.
Compressed data is valid if-and-only-if the texture is compressed.
Invalid compressed image size.
Format must match internal format.
Invalid internal format 0x%04X.
Pixel data cannot be null.
Data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
An active buffer is mapped
Invalid combination of unpack parameters for WebGL.
Invalid copy texture format combination.
Invalid level count.
Texture dimensions must all be greater than zero.
OpenGL ES 3.0 Required.
Negative layer.
Mip level invalid for framebuffer texture attachment.
Layer invalid for framebuffer texture attachment.
Texture is not a three-dimensional, two-dimensional array, two-dimensional multisample array, cube map, or cube map array texture.
Compressed textures cannot be attached to a framebuffer.
Invalid framebuffer target.
Negative size.
Invalid element range.
No active read framebuffer.
Invalid read buffer
Read buffer must be GL_NONE or GL_BACK when reading from the default framebuffer.
Index is greater than the maximum supported color attachments
Not a valid compressed texture format.
Integer overflow.
Invalid buffer binding size.
Invalid boolean value. Must be GL_FALSE or GL_TRUE.
OpenGL ES 3.1 Required
Invalid pname.
drawbuffer
Index must be less than MAX_DRAW_BUFFERS.
Draw buffer must be zero when using depth or stencil.
Source texture is not a valid texture object.
Destination texture is not a valid texture object.
Invalid source texture level.
Invalid source texture height or width.
Destination texture cannot be immutable.
x = y = or z cannot be negative.
Cannot have negative height, width, or depth.
Destination texture too small.
Extension is not enabled.
Implementation format is emulated.
Attempt to delete an active transform feedback.
Invalid primitive mode.
Transform feedback is already active.
Transform feedback has a buffer bound to multiple outputs.
A program must be bound.
The active program has specified no output variables to record.
Every binding point used in transform feedback mode must have a buffer object bound.
EXT/OES_draw_buffers_indexed is not available.
Index must be less than MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
Index must be less than MAX_UNIFORM_BUFFER_BINDINGS.
Index must be less than the number of workgroup dimensions (3).
Enum requires GLES 3.1
Index must be less than MAX_ATOMIC_COUNTER_BUFFER_BINDINGS.
Index must be within [0, MAX_SHADER_STORAGE_BUFFER_BINDINGS).
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS.
Index must be within [0, MAX_IMAGE_UNITS).
A buffer must be bound.
Buffer is bound for transform feedback.
Buffer offset overflow.
The read and write copy regions alias memory.
Index must be within [0, NUM_EXTENSIONS).
Invalid name.
Index must be within [0, NUM_REQUESTABLE_EXTENSIONS_ANGLE).
Samples must not be greater than maximum supported value for the format.
Cannot have negative stride.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Client data cannot be used with a non-default vertex array object.
Negative buffer size.
Context has been lost.
Sync object does not exist.
Negative baseViewIndex.
Texture has incompatible target.
baseViewIndex+numViews cannot be greater than GL_MAX_ARRAY_TEXTURE_LAYERS.
No Transform Feedback object is active.
Negative count.
Count exceeds MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
Index must be less than the transform feedback varying count in the program.
The active Transform Feedback object is not paused.
Transform feedback object that does not exist.
The active Transform Feedback object is paused.
Program not linked.
Index must be less than program active uniform count.
Index must be less than program active uniform block count.
Invalid value for condition.
Invalid value for flags.
Invalid value for timeout.
Sampler is not valid
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_COMBINED_IMAGE_UNITS)
Fragment output color index must be zero or one.
Color number for secondary color greater than or equal to MAX_DUAL_SOURCE_DRAW_BUFFERS
Color number for primary color greater than or equal to MAX_DRAW_BUFFERS
GL_ANGLE_texture_multisample or GLES 3.1 required.
GL_ANGLE_texture_multisample, GL_ANGLE_get_tex_level_parameter or GLES 3.1 required.
Argument <%s> must be less than MAX_COLOR_ATTACHMENTS_WITH_ACTIVE_PIXEL_LOCAL_STORAGE_ANGLE when pixel local storage is active.
Argument <%s> must be less than (MAX_COMBINED_DRAW_BUFFERS_AND_PIXEL_LOCAL_STORAGE_PLANES_ANGLE - ACTIVE_PIXEL_LOCAL_STORAGE_PLANES_ANGLE) when pixel local storage is active.
internalformat is an ETC1 or PVRTC1 format.
internalformat is an ETC2/EAC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an ASTC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an S3TC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an RGTC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is a BPTC format and target is not GL_TEXTURE_2D_ARRAY.
Invalid type.
Format cannot be GL_DEPTH_COMPONENT or GL_DEPTH_STENCIL if target is GL_TEXTURE_3D
Vertex array does not exist.
Index is greater than or equal to the number of TRANSFORM_FEEDBACK_BUFFER indexed binding points.
Offset and size must be multiple of 4.
Target is TRANSFORM_FEEDBACK_BUFFER and transform feedback is currently active.
Offset must be multiple of value of UNIFORM_BUFFER_OFFSET_ALIGNMENT.
offset must be a multiple of 4.
Offset must be multiple of value of SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT.
Texture buffer extension not available.
Offset must be multiple of value of TEXTURE_BUFFER_OFFSET_ALIGNMENT.
GL_ANGLE_copy_texture_3d extension not available.
Index must be less than MAX_VERTEX_ATTRIBS.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
ANGLE_multiview is not available.
numViews cannot be less than 1.
numViews cannot be greater than GL_MAX_VIEWS_ANGLE.
EXT/OES_draw_buffers_indexed or ES 3.1 are required but not available.
OpenGL ES 3.1 Required
Default vertex array object is bound.
Client data cannot be used with a non-default vertex array object.
Draw indirect buffer must be bound.
indirect must be a multiple of the size of uint in basic machine units.
Draw mode must match current transform feedback object's draw mode.
The draw command is unsupported when transform feedback is active and not paused.
The provided parameters overflow with the provided buffer.
Must have element array buffer bound.
Extension is not enabled.
Ith value does not match COLOR_ATTACHMENTi or NONE.
Value must be greater than zero.
Invalid program interface.
Object cannot be used because it has not been generated.
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
Negative offset.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid program resource index.
Negative buffer size.
No active program for the compute shader stage.
num_groups_x cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[0]
num_groups_y cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[1]
num_groups_z cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[2]
Offset must be a multiple of sizeof(uint) in basic machine units.
Dispatch indirect buffer must be bound.
Insufficient buffer size.
Index must be within [0, MAX_IMAGE_UNITS).
Level is negative.
Negative layer.
access is not one of the supported tokens.
format is not one of supported image unit formats.
texture is not the name of an existing texture object.
Texture is not the name of an immutable texture object or a buffer texture.
Program not linked.
Invalid propCount.
Invalid bufSize.
Invalid program resource property.
Not an allowed program resource property for this program interface
Invalid pname.
Active atomic counter resources are not assigned name strings.
MAX_NUM_ACTIVE_VARIABLES requires a buffer or block interface.
Unrecognized shader stage bit.
Program doesn't exist.
Program object was not linked with its PROGRAM_SEPARABLE status set.
Expected a program name, but found a shader name.
Invalid shader type.
Negative count.
Program pipeline does not exist.
Invalid memory barrier bit.
Not a valid texture object name.
Level of detail outside of range.
Texture level must be zero.
GL_EXT_geometry_shader or GL_OES_geometry_shader extension not enabled.
GL_ANGLE_texture_multisample_array not enabled.
Target must be TEXTURE_2D_MULTISAMPLE_ARRAY_OES.
Negative size.
Depth must be less than or equal to MAX_ARRAY_TEXTURE_LAYERS
programInterface must be set to GL_PROGRAM_OUTPUT.
Texture buffer extension not available.
Target must be TEXTURE_BUFFER.
Internal format is not an accepted sized internal format.
If buffer is nonzero, it must match the name of an existing buffer object.
Offset must be multiple of value of TEXTURE_BUFFER_OFFSET_ALIGNMENT.
Texture buffer size must be a positive integer.
A buffer must be bound.
Texture buffer offset + size must be less than or equal to BUFFER_SIZE.
Draw framebuffer is incomplete
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
Invalid enum provided.
Uniform size does not match uniform method.
relativeOffset cannot be greater than MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
Invalid type.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
Draw buffer greater than MAX_DRAW_BUFFERS.
Index must be less than MAX_DRAW_BUFFERS.
OpenGL ES 3.2 Required
index
Enum 0x%04X is currently not supported.
Invalid pointer query.
OpenGL ES 1.x or 3.2 Required
GL_ANGLE_get_image extension not enabled.
Invalid or unsupported texture target.
Level is negative.
Level of detail outside of range.
Texture is compressed, call GetCompressedTexImage instead.
Texture is not compressed, call GetTexImage instead.
Implementation format is emulated.
Invalid renderbuffer target.
Extension is not enabled.
Element value exceeds element range.
Draw mode must match current transform feedback object's draw mode.
The draw command is unsupported when transform feedback is active and not paused.
GL_KHR_blend_equation_advanced extension not enabled.
Invalid provoking vertex.
Invalid memory object.
Invalid memory object parameter.
The memory object is immutable.
Invalid handle type.
name is not a valid buffer.
Not a valid texture object name.
Invalid image layout.
OpenGL ES 3.0 Required.
Texture is not immutable.
Level is larger than texture level count.
Negative layer.
Layer is larger than texture depth.
Attempted to begin pixel local storage with a multisampled framebuffer.
Attempted to begin pixel local storage with GL_DITHER enabled.
Attempted to begin pixel local storage with GL_RASTERIZER_DISCARD enabled.
Attempted to begin pixel local storage with GL_SAMPLE_ALPHA_TO_COVERAGE enabled.
Attempted to begin pixel local storage with GL_SAMPLE_COVERAGE enabled.
Planes must be greater than 0.
Planes must be less than or equal to GL_MAX_PIXEL_LOCAL_STORAGE_PLANES_ANGLE.
Framebuffer cannot have images attached to color attachment points on or after COLOR_ATTACHMENT0 + MAX_COLOR_ATTACHMENTS_WITH_ACTIVE_PIXEL_LOCAL_STORAGE_ANGLE.
Framebuffer cannot have images attached to color attachment points on or after COLOR_ATTACHMENT0 + MAX_COMBINED_DRAW_BUFFERS_AND_PIXEL_LOCAL_STORAGE_PLANES_ANGLE - <n>.
loadops cannot null.
Attempted to enable a pixel local storage plane that is in a deinitialized state.
Mismatched pixel local storage backing texture sizes.
Load Operation GL_LOAD_OP_LOAD_ANGLE is invalid for memoryless planes.
Pixel local storage backing texture dimensions not equal to the rendering area.
Draw framebuffer has no attachments and no enabled, texture-backed pixel local storage planes.
<n> != ACTIVE_PIXEL_LOCAL_STORAGE_PLANES_ANGLE
Enum 0x%04X is currently not supported.
GL_EXT_shader_framebuffer_fetch_non_coherent not enabled.
GL_EXT_tessellation_shader extension not enabled.
Invalid pname.
Value must be greater than zero.
Value must be less than or equal to MAX_PATCH_SIZE.
Create flags must only include bits defined by GL_ANGLE_external_objects_flags
Usage flags must only include bits defined by GL_ANGLE_external_objects_flags
Invalid buffer target.
Size must be greater than 0
Invalid buffer usage flags.
A buffer must be bound.
Buffer is immutable.
Invalid origin enum.
Invalid depth enum.
Offset must be zero for external buffers
Size must not exceed the size of clientbuffer
Negative buffer size.
Negative length.
Attribute list must be NULL or GL_NONE
Texture dimensions must all be greater than zero.
Desired resource size is greater than max texture size.
Invalid perf monitor.
Invalid perf monitor counter group.
Invalid perf monitor counter.
Invalid shading rate.
Plane cannot be less than 0.
Plane must be less than GL_MAX_PIXEL_LOCAL_STORAGE_PLANES_ANGLE.
Invalid pixel local storage internal format.
Invalid pixel local storage texture type.
GL_ANGLE_shader_pixel_local_storage not enabled.
Pixel local storage is not active.
Default framebuffer object name 0 does not support pixel local storage.
Invalid pixel local storage Load Operation: 0x%04X.
Invalid pixel local storage Store Operation: 0x%04X.
Invalid type.
Shader object expected.
Program object expected.
Invalid format.
Could not pack varying 
Note: Additional non-conformant packing restrictions are enforced on D3D9.
Failed to unmap the client data streaming buffer.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/VertexArrayGL.cpp
streamAttributes
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/VertexArrayMtl.mm
updateClientAttribs
convertVertexBufferCPU
convertVertexBufferGPU
Unsupported format conversion
StreamVertexData
thread constructor failed
'%x
ANGLE: %s: %s
SwapLayerEAGL
depthAttachment
addCompletedHandler:
enqueue
areRasterOrderGroupsSupported
languageVersion
attributes
mDisplayContext
bounds
pushDebugGroup:
commandBuffer
setBufferIndex:
computeCommandEncoder
setDestinationAlphaBlendFactor:
contentsScale
setPixelFormat:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
setScissorRect:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
setTextureType:
depth
setVisibilityResultMode:offset:
device
texture
UTF8String
display
addSublayer:
fastMathEnabled
arrayLength
layouts
blitCommandEncoder
newCommandQueue
colorAttachments
setArrayLength:
commit
setConstantValue:type:withName:
contents
setNeedsDisplay
copy
setSampleCount:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
setStoreAction:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
setVertexBuffer:offset:atIndex:
depthAttachmentPixelFormat
supportsFamily:
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawableSize
encodeSignalEvent:value:
encodeWaitForEvent:value:
encodedLength
endEncoding
fillBuffer:range:value:
frame
generateMipmapsForTexture:
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
height
init
initWithAPI:
initWithBytesNoCopy:length:encoding:freeWhenDone:
initWithSharedState:withContext:withFunctions:
initialized
insertDebugSignpost:
iosurface
isRasterizationEnabled
length
localizedDescription
mFunctions
mReadFramebuffer
mSwapState
maxTotalThreadsPerThreadgroup
mipmapLevelCount
name
newArgumentEncoderWithBufferIndex:
newBufferWithBytes:length:options:
newBufferWithLength:options:
newComputePipelineStateWithFunction:error:
newDepthStencilStateWithDescriptor:
newFunctionWithName:
newFunctionWithName:constantValues:error:
newLibraryWithData:error:
newLibraryWithSource:options:error:
newRenderPipelineStateWithDescriptor:error:
newSamplerStateWithDescriptor:
newSharedEvent
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
nextDrawable
notifyListener:atValue:block:
objectAtIndexedSubscript:
operatingSystemVersionString
pixelFormat
popDebugGroup
presentDrawable:
presentRenderbuffer:
processInfo
rangeOfString:
readWriteTextureSupport
removeFromSuperlayer
renderCommandEncoderWithDescriptor:
renderPassDescriptor
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
reset
resolveTexture
sampleCount
setAllowsNextDrawableTimeout:
setAlphaBlendOperation:
setAlphaToCoverageEnabled:
setArgumentBuffer:offset:
setBackFaceStencil:
setBlendColorRed:green:blue:alpha:
setBlendingEnabled:
setBuffer:offset:atIndex:
setBytes:length:atIndex:
setClearColor:
setClearDepth:
setClearStencil:
setCompareFunction:
setComputePipelineState:
setContentsScale:
setCullMode:
setCurrentContext:
setDefaultRasterSampleCount:
setDepth:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthCompareFunction:
setDepthFailureOperation:
setDepthPlane:
setDepthStencilPassOperation:
setDepthStencilState:
setDepthWriteEnabled:
setDestinationRGBBlendFactor:
setDevice:
setDrawableSize:
setFastMathEnabled:
setFormat:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBytes:length:atIndex:
setFragmentFunction:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentTexture:atIndex:
setFrame:
setFramebufferOnly:
setFrontFaceStencil:
setFrontFacingWinding:
setHeight:
setLabel:
setLanguageVersion:
setLevel:
setLoadAction:
setMagFilter:
setMaxAnisotropy:
setMinFilter:
setMipFilter:
setMipmapLevelCount:
setObject:atIndexedSubscript:
setOffset:
setPreprocessorMacros:
setPreserveInvariance:
setRAddressMode:
setRasterizationEnabled:
setReadMask:
setRenderPipelineState:
setRenderTargetHeight:
setRenderTargetWidth:
setResolveDepthPlane:
setResolveLevel:
setResolveSlice:
setResolveTexture:
setResourceOptions:
setRgbBlendOperation:
setSAddressMode:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSlice:
setSourceAlphaBlendFactor:
setSourceRGBBlendFactor:
setStencilAttachmentPixelFormat:
setStencilCompareFunction:
setStencilFailureOperation:
setStencilFrontReferenceValue:backReferenceValue:
setStencilReferenceValue:
setStepFunction:
setStepRate:
setStoreActionOptions:
setStride:
setTAddressMode:
setTexture:
setTexture:atIndex:
setTriangleFillMode:
setUsage:
setVertexBufferOffset:atIndex:
setVertexBytes:length:atIndex:
setVertexDescriptor:
setVertexFunction:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexTexture:atIndex:
setViewport:
setVisibilityResultBuffer:
setWidth:
setWriteMask:
signaledValue
stencilAttachment
stencilAttachmentPixelFormat
storageMode
storeAction
stringWithFormat:
stringWithUTF8String:
supports32BitFloatFiltering
supportsFeatureSet:
supportsTextureSampleCount:
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
textureType
threadExecutionWidth
usage
useResource:usage:stages:
vertexDescriptor
waitUntilCompleted
waitUntilScheduled
width
@40@0:8^{SharedSwapState=[3{SwapTexture=IIIQ}]{_opaque_pthread_mutex_t=q[56c]}^{SwapTexture}^{SwapTexture}^{SwapTexture}}16@24r^v32
v16@0:8
@"EAGLContext"
^{SharedSwapState=[3{SwapTexture=IIIQ}]{_opaque_pthread_mutex_t=q[56c]}^{SwapTexture}^{SwapTexture}^{SwapTexture}}
>>>>68:<
0H`x
 "$&(*,.02
68:<>HR
\^`bdfjl
6D<ANGLECoverageMaskEnabled
ANGLERasterizerDisabled
ANGLEDepthWriteEnabled
*7tE
;?E^
&&&&&&&&&&&&
xkAV
Frontend features
Frontend workarounds
OpenGL workarounds
OpenGL features
D3D workarounds
Vulkan features
Vulkan workarounds
Vulkan app workarounds
Metal features
Metal workarounds
Unknown
enabled
disabled
MTLB
NAME
blitStencilToBufferCS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertIndexU8ToU16
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertIndexU16
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertIndexU32
TYPE
HASH 
zOFFT
VERS
MDSZ
RFLT
ENDT
NAME
genTriFanIndicesFromArray
TYPE
HASH 
WOFFT
VERS
MDSZ
RFLT
ENDT
NAME
genTriFanIndicesFromElements
TYPE
HASH 
zx#O
`}OFFT
VERS
MDSZ
RFLT
ENDT
NAME
genLineLoopIndicesFromArray
TYPE
HASH 
`OFFT
VERS
MDSZ
RFLT
ENDT
NAME
genLineLoopIndicesFromElements
TYPE
HASH 
zS'h
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generate3DMipmaps
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generate2DMipmaps
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generateCubeMipmaps
TYPE
HASH 
uN`^^
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
generate2DArrayMipmaps
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
readFromBufferToFloatTexture
TYPE
HASH 
P75S
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
readFromBufferToIntTexture
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
readFromBufferToUIntTexture
TYPE
HASH 
OOFFT
VERS
MDSZ
RFLT
ENDT
NAME
writeFromFloatTextureToBuffer
TYPE
HASH 
GOFFT
VERS
MDSZ
RFLT
ENDT
NAME
writeFromIntTextureToBuffer
TYPE
HASH 
PjXY
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
writeFromUIntTextureToBuffer
TYPE
HASH 
{B._S4
geMPS:
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertToFloatVertexFormatCS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
expandVertexFormatComponentsCS
TYPE
HASH 
m-&Zy
Ff@OmOE
?OFFT
VERS
MDSZ
RFLT
ENDT
NAME
combineVisibilityResult
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
fixIndexBuffer
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
genIndexBuffer
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitVS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearVS
TYPE
HASH 
9+P#
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
convertToFloatVertexFormatVS
TYPE
HASH 
iOFFT
VERS
MDSZ
RFLT
ENDT
NAME
expandVertexFormatComponentsVS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitFloatFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitIntFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitUIntFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
copyTextureFloatToUIntFS
TYPE
HASH 
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitDepthFS
TYPE
HASH 
_%Rr
zOFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitStencilFS
TYPE
HASH 
'@"!oW
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
blitDepthStencilFS
TYPE
HASH 
ANZVoaXH
COFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearFloatFS
TYPE
HASH 
@\_}
OFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearIntFS
TYPE
HASH 
pOFFT
VERS
MDSZ
RFLT
ENDT
NAME
clearUIntFS
TYPE
HASH 
wOFFT
VERS
MDSZ
RFLT
ENDTRLST
UUID
ENDT(
CNST
kSourceTexture2Type
ENDT
ENDT)
CNST
kSourceBufferAligned
ENDT)
CNST
kSourceBufferAligned
ENDT
ENDTj
CNST\
kSourceBufferAligned
kSourceIndexIsU8
kSourceIndexIsU16
kSourceIndexIsU32
ENDT
ENDTj
CNST\
kSourceBufferAligned
kSourceIndexIsU8
kSourceIndexIsU16
kSourceIndexIsU32
ENDT
ENDT
ENDT
ENDT
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT9
CNST+
kCopyFormatType
kCopyTextureType
ENDT$
CNST
kCopyFormatType
ENDT
ENDT/
CNST!
kCombineWithExistingResult
ENDT&
CNST
fixIndexBufferKey
ENDT&
CNST
fixIndexBufferKey
ENDT
ENDT
ENDT$
CNST
kCopyFormatType
ENDT
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDTg
CNSTY
kNumColorOutputs
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
ENDT'
CNST
kSourceTextureType
ENDT(
CNST
kSourceTexture2Type
ENDT?
CNST1
kSourceTextureType
kSourceTexture2Type
ENDT%
CNST
kNumColorOutputs
ENDT%
CNST
kNumColorOutputs
ENDT%
CNST
kNumColorOutputs
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
ENDT
b0$
(",B
qMTD
qMTD
p` M
QEAD)
'#
a9 
`B L0
)2Dh
ND# K
P$v`
fPY8
AqPl
ADIte
<SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.function_constantboolkSourceTexture2Type2Dair.textureair.location_indexair.sampletexture2d<uint, sample>srcTexture2dkSourceTexture2Type2DArraytexture2d_array<uint, sample>srcTexture2dArraykSourceTexture2Type2DMSair.readtexture2d_ms<uint, read>srcTexture2dMSkSourceTexture2TypeCubetexturecube<uint, sample>srcTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infofloat2srcStartTexCoordssrcTexCoordStepsintsrcLevelsrcLayeruint2dstSizeuintdstBufferRowPitchresolveMSair.arg_type_sizeair.arg_type_align_sizeBlitStencilToBufferParamsoptionsair.read_writeucharbufferkSourceTexture2Typeair.sampler_stateomnipotent charSimple C++ TBAA
 ,m0
:XW(
;XW(
;XW(
zH+,M
_ZTS25BlitStencilToBufferParams
 ,q0AX
$6(
:d!
sBp
-P  
`H:@
Ldpl
+1K 
/1K 
C851
>1K 
a1K 
@@*0
0K@a@
__metal_implicit_fc_pred_13__metal_implicit_fc_pred_14__metal_implicit_fc_pred_15__metal_implicit_fc_pred_16llvm.global_ctors_ZL19kSourceTexture2Type_Z19kSourceTexture2Type.MTL_FC_INIT_4_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitStencilToBufferCSair.sample_texture_cube.u.v4i32air.convert.f.f32.s.i32air.read_texture_2d_ms.u.v4i32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i32air.get_num_samples_texture_2d_msair.convert.f.v2f32.u.v2i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
qqNS
"0A)
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsucharinputair.read_writeushortoutput
3j0
3jp
 n0C
3r 
_ZTS21IndexConversionParamsintomnipotent charSimple C++ TBAAshort
dl&H
U0l@
llvm.global_ctorsconvertIndexU8ToU1631001.718air64-apple-ios16.4.0-simulator
b0$
`B L(
#8MED
P$v`
fPY8
AqPl
QYEA
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkSourceBufferUnaligneducharinputkSourceBufferAlignedushortinputAlignedair.read_writeoutputomnipotent charSimple C++ TBAA
3n 
3p`
$3lP
n`]l
n`]l
3[/
&(#66
UH*,M
_ZTS21IndexConversionParamsintshort
]0l@
__metal_implicit_fc_pred_17__metal_implicit_fc_pred_18llvm.global_ctors_ZL20kSourceBufferAligned_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8convertIndexU1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
`B L(
#8MED
P$v`
fPY8
AqPl
QYEA1
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkSourceBufferUnaligneducharinputkSourceBufferAlignedinputAlignedair.read_writeoutputomnipotent charSimple C++ TBAA
3m 
3o`
$3k@
m`]k
m`]k
ksi{#
c+s1c
VH%,M
_ZTS21IndexConversionParamsint
__metal_implicit_fc_pred_17__metal_implicit_fc_pred_18llvm.global_ctors_ZL20kSourceBufferAligned_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8convertIndexU3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofirstVertexvertexCountair.arg_type_sizeair.arg_type_align_sizeIndexFromArrayParamsoptionsair.read_writeoutput
3eP
I3(k@
i3Pc0QhP
y3@a0Ua0
ksI#+s
_ZTS20IndexFromArrayParamsintomnipotent charSimple C++ TBAA
`l <
llvm.global_ctorsgenTriFanIndicesFromArray31001.718air64-apple-ios16.4.0-simulator
b0$
It  
`B L0
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkUseSourceBufferU8ucharinputU8kUseSourceBufferU16ushortinputU16kUseSourceBufferU32inputU32air.read_writeoutputkSourceBufferAlignedkSourceIndexIsU8kSourceIndexIsU16kSourceIndexIsU32omnipotent charSimple C++ TBAA
 `e0
L3r
3vP
I3<|P
q3Pt0Q
(lb0
t`]r
0Ut@
(ll@
tH+,M
D<l)
_ZTS21IndexConversionParamsintshort
|A)f
rl P
2(EQV
2dXP4
?l)\!
__metal_implicit_fc_pred_19__metal_implicit_fc_pred_20__metal_implicit_fc_pred_21llvm.global_ctors_ZL19kUseSourceBufferU32_ZL19kUseSourceBufferU16_ZL18kUseSourceBufferU8_ZL17kSourceIndexIsU32_Z17kSourceIndexIsU32.MTL_FC_INIT_400_b_ZL17kSourceIndexIsU16_Z17kSourceIndexIsU16.MTL_FC_INIT_300_b_Z16kSourceIndexIsU8.MTL_FC_INIT_200_b_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8genTriFanIndicesFromElements31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofirstVertexvertexCountair.arg_type_sizeair.arg_type_align_sizeIndexFromArrayParamsoptionsair.read_writeoutput
3eP
I3(k@
i3Pc0QhP
y3@a0Ua0
ksI#+s
_ZTS20IndexFromArrayParamsintomnipotent charSimple C++ TBAA
llvm.global_ctorsgenLineLoopIndicesFromArray31001.718air64-apple-ios16.4.0-simulator
b0$
It  
`B L0
B0D3I; `
H&.@
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcOffsetindexCountboolprimitiveRestartEnabledair.arg_type_sizeair.arg_type_align_sizeIndexConversionParamsoptionsair.function_constantkUseSourceBufferU8ucharinputU8kUseSourceBufferU16ushortinputU16kUseSourceBufferU32inputU32air.read_writeoutputkSourceBufferAlignedkSourceIndexIsU8kSourceIndexIsU16kSourceIndexIsU32omnipotent charSimple C++ TBAA
 `e0
L3r
3vP
I3<|P
q3Pt0Q
(lb0
t`]r
0Ut@
(ll@
tH+,M
D<l)
_ZTS21IndexConversionParamsintshort
Q F5EQ
__metal_implicit_fc_pred_19__metal_implicit_fc_pred_20__metal_implicit_fc_pred_21llvm.global_ctors_ZL19kUseSourceBufferU32_ZL19kUseSourceBufferU16_ZL18kUseSourceBufferU8_ZL17kSourceIndexIsU32_Z17kSourceIndexIsU32.MTL_FC_INIT_400_b_ZL17kSourceIndexIsU16_Z17kSourceIndexIsU16.MTL_FC_INIT_300_b_Z16kSourceIndexIsU8.MTL_FC_INIT_200_b_Z20kSourceBufferAligned.MTL_FC_INIT_100_bllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8genLineLoopIndicesFromElements31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
qMTD
9MED
 x  
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort3gIndicesair.textureair.location_indexair.sampletexture3d<float, sample>srcTextureair.writetexture3d<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
`0F`
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
`0A 
sC`
1b`!
2 I`
?$sz
24N`
L8sJ
\.G
2PU0bp!
Z@f1
1(AM2
%`~p
!H%1
2h[P
]lep
1Ak
2x_P
1Ayle
}leH
12KP
peP<
!@d2l@
pC`'`0
Lle0
A^`E
n0Pa
_9(H
I /[
~!(H
LleP
v0Pa
tPs@
aox&
4/3K
!L?3l@
{0Pa
T<p
168b`!
sCp>[
sC@>
pC@>`0
BP2c;p
(TX
Lle(#
sCpC
%>"(H
1A,me 'QR(H
*TX
?bp!
1b`!
S`F 
P#A;l
P*A;l
.A;l
3A;l
:A;l
?A;l
FA;l
pJA;l
llvm.global_ctors_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ17generate3DMipmapsjDv3_tN5metal9texture3dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerate3DMipmapsair.write_texture_3d.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v3i16air.wg.barrierair.fast_pow.f32air.sample_texture_3d.v4f32air.convert.f.f32.u.i32air.convert.f.v3f32.u.v3i16air.get_depth_texture_3dair.get_height_texture_3dair.get_width_texture_3d31001.718air64-apple-ios16.4.0-simulator
b0$
qMTD
9MED
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort2gIndicesair.textureair.location_indexair.sampletexture2d<float, sample>srcTextureair.writetexture2d<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
&Er0
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
@t0K@TX
C@Va+CH
A;7
z (H
1AJle
}P(H
,A2Pa
?bp!
1b`!
F`F 
!X`1l@
Q0b`
Lle(
!>bC
%Lt 
!H~1
2TVP
1A|le
sC "[
!L-2l@
jB&cRy
8b`!
:!(H
=Q(H
pC *`0
?bp!
1b`!
K`F 
e0Pa
R*8b
"A;l
'A;l
llvm.global_ctors_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ17generate2DMipmapsjDv2_tN5metal9texture2dIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerate2DMipmapsair.write_texture_2d.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v2i16air.wg.barrierair.sample_texture_2d.v4f32air.convert.f.f32.u.i32air.convert.f.v2f32.u.v2i16air.get_height_texture_2dair.get_width_texture_2d31001.718air64-apple-ios16.4.0-simulator
b0$
qMTD
TD$!N
 $E`-j
 B2#
8f0
(F@Bq
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort3gIndicesair.textureair.location_indexair.sampletexturecube<float, sample>srcTextureair.writetexturecube<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
?b`!
3${0
hBb 
20K0
2@QPU^
LleH
!Hb1
2HSPfP
1Amle0
sC`
p"`0
Y0b`
"(r"5
aNl$
pCp&`0
AP0!#p
5!(H
8Q(H
"3bA
T\B
!Xu2l@
T\p 
TXj!
A0b`
sC0/[
g0Pq
sCP3[
AmTF
sC 3
k0Pq
 Cp.
2u3K
p#A;l)
0+A;l
/A;l
llvm.global_ctors_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ19generateCubeMipmapsjDv3_tN5metal11texturecubeIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerateCubeMipmapsair.write_texture_cube.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v2i16air.wg.barrierair.sample_texture_cube.v4f32air.convert.f.f32.u.i32air.convert.f.v2f32.u.v2i16air.get_height_texture_cubeair.get_width_texture_cube31001.718air64-apple-ios16.4.0-simulator
b0$
qMTD
TD$!N
v@fs
P$v`
fPY8
AqPl
<HD!
sDSDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_index_in_threadgroupair.arg_type_nameuintair.arg_namelIndexair.thread_position_in_gridushort3gIndicesair.textureair.location_indexair.sampletexture2d_array<float, sample>srcTextureair.writetexture2d_array<float, write>dstMip1dstMip2dstMip3dstMip4air.bufferair.buffer_sizeair.readair.address_spaceair.struct_type_infosrcLevelnumMipLevelsToGenboolsRGBair.arg_type_sizeair.arg_type_align_sizeGenMipParamsoptionsair.sampler_state
3sP
q0=TT
i3(z`]q
&(#66
SH*,M
_ZTS12GenMipParamsintomnipotent charSimple C++ TBAAfloat
b0b`!
1b`!
@w0K@T\
C@`a+
Oleh
1AN
B/( 
!Tg1l@
2H[P*
8b`!
1Ax
sCP
sC 
2\XP0
2hY0
T\B&
!P62l@
&lR}
1"8b`!
89(H
H@*[
sC0+[
!]X%
Y9(H
pDq'
"A;l
*A;l
llvm.global_ctors_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sA_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sB_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sG_ZZ22generate2DArrayMipmapsjDv3_tN5metal15texture2d_arrayIfLNS0_6accessE0EvEENS1_IfLS2_2EvEES4_S4_S4_RU11MTLconstantK12GenMipParamsE2sR__air_sampler_stategenerate2DArrayMipmapsair.write_texture_2d_array.i16.v4f32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.max.u.v2i16air.wg.barrierair.sample_texture_2d_array.v4f32air.convert.f.f32.u.i32air.convert.f.v2f32.u.v2i16air.get_height_texture_2d_arrayair.get_width_texture_2d_array31001.718air64-apple-ios16.4.0-simulator
b0$
,E.bI
`$dD
qMTD
qMTD
`B L
)"Dh
QEAD
47`P
P$v`
fPY8
AqPl
\]$]
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort3air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint3copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchbufferDepthPitchair.arg_type_sizeair.arg_type_align_sizeCopyPixelParamsoptionsucharbufferair.function_constantboolkCopyTextureType2Dair.textureair.writetexture2d<float, write>dstTexture2dkCopyTextureType2DArraytexture2d_array<float, write>dstTexture2dArraykCopyTextureType3Dtexture3d<float, write>dstTexture3dkCopyTextureTypeCubetexturecube<float, write>dstTextureCubeintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
LT*T
+pt@
FAp!
ksI#+s
_ZTS15CopyPixelParams
!$h0
%u(PA
@f!
\A^
jpA/
.Q$ma
kEY\@
F\T 
$6tc
$6tc
#$F
5D=n
"7PA
C Nc
d(V#5
`G!
b+7PA
aFbd
C0fd
!F!
!F!
!F!
/$CATF
O2t"'c
AB2-3K
:S.EB2-3K
=c.B
_$B3p
Hgf
 2 3b
gP>t
%32c
*xl@
!F!
6m3b
"B+4K
/xl@8
M`Be
sFP:
V0;z
Awpg
?b!!H
C0tg
!F!
DATF
O2!
C `h
d(hH
(UKB
 CQFc4
rOs
3!<6 
 R2UV
W&U$e
Pb$Wp
`R$5
^wU$
,ES[
`L,
 RL
S'<6 
jKC}
ac?6K
,:6f
Cl=j6
@fb6b
gVfc
ro 7K
^xl@
xl@x
xl@H
 ZCf
 Cpsf
n00
 \ D
 \ D
 C0~
e@ATF
ALl2
dP$o
 \ D
 \ D
 \ D
(!X+H4
(!X+
Ot=Q
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8readFromBufferToFloatTextureair.write_texture_cube.v4f32air.write_texture_3d.v4f32air.write_texture_2d_array.v4f32air.write_texture_2d.v4f32air.convert.u.v3i32.u.v3i16air.convert.f.f32.s.i32air.convert.f.v3f32.u.v3i1air.fast_pow.v3f32air.unpack.unorm4x8.srgb.v4f32air.unpack.unorm4x8.v4f32air.unpack.snorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
,E.bI
`$dD
qMTD
qMTD
`B L8
)"Dh
QEAD
#6SK\
P$v`
fPY8
AqPl
\[$Uu9
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort3air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint3copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchbufferDepthPitchair.arg_type_sizeair.arg_type_align_sizeCopyPixelParamsoptionsucharbufferair.function_constantboolkCopyTextureType2Dair.textureair.writetexture2d<int, write>dstTexture2dkCopyTextureType2DArraytexture2d_array<int, write>dstTexture2dArraykCopyTextureType3Dtexture3d<int, write>dstTexture3dkCopyTextureTypeCubetexturecube<int, write>dstTextureCubeintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~`]|
+pt@
FAp!
ksI#+s
_ZTS15CopyPixelParams
m0Ah
%u(PA
Q F!!
(xEe\
(2
JC'
Pc'
$Fb
(29
ml@ 
 ss
"/F
%R#hBATF
')R$h
Q'pA
ml@x
'<aA
^T%8
/-CATF
$-c3
R$-c3
77PA
h0;lS
hffF
Cufg
flf
(!X+H
f G'
dPG($
Fq4K
:ml@h
 \ D
 \ D
 \ D
ml@@
 \ D
ml@h
 \ D
 \ D
R7PA
38+~
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8readFromBufferToIntTextureair.write_texture_cube.s.v4i32air.write_texture_3d.s.v4i32air.write_texture_2d_array.s.v4i32air.write_texture_2d.s.v4i32air.convert.u.v3i32.u.v3i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
,E.bI
`$dD
qMTD
qMTD
`B L8
)"Dh
QEAD
P$v`
fPY8
AqPl
\\$Y
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort3air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint3copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchbufferDepthPitchair.arg_type_sizeair.arg_type_align_sizeCopyPixelParamsoptionsucharbufferair.function_constantboolkCopyTextureType2Dair.textureair.writetexture2d<uint, write>dstTexture2dkCopyTextureType2DArraytexture2d_array<uint, write>dstTexture2dArraykCopyTextureType3Dtexture3d<uint, write>dstTexture3dkCopyTextureTypeCubetexturecube<uint, write>dstTextureCubeintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~`]|
+pt@
FAp!
ksI#+s
_ZTS15CopyPixelParams
m0Ah
%u(PA
Q F!!
(xEe\
(2
H#'
NC'
$Fb
AATF
B[lip
?d#8
"aBATF
'"R$a
`@'#"
ml@0
1+pA
."CATF
RF\*
B77PA
T&eF
ZGl
`gl
eXf
(!X+
Cf4K
W:ml@
 \ D
ml@8
 \ D
ml@`
 \ D
 \ D
 \ D
ml@8
 \ D
ml@`
s[`C
kE*]@
BR7PA
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8readFromBufferToUIntTextureair.write_texture_cube.u.v4i32air.write_texture_3d.u.v4i32air.write_texture_2d_array.u.v4i32air.write_texture_2d.u.v4i32air.convert.u.v3i32.u.v3i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
&*"~{
`B L@
)"Dh
0lgE
L-qMTD
v@8Q
0Dr-.
P$v`
fPY8
AqPl
VtAG%-
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint2copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchtextureLeveltextureLayerboolreverseTextureRowOrderair.arg_type_sizeair.arg_type_align_sizeWritePixelParamsoptionsair.function_constantkCopyTextureType2Dair.texturetexture2d<float, read>srcTexture2dkCopyTextureType2DArraytexture2d_array<float, read>srcTexture2dArraykCopyTextureType3Dtexture3d<float, read>srcTexture3dkCopyTextureTypeCubetexturecube<float, read>srcTextureCubekCopyTextureType2DMStexture2d_ms<float, read>srcTexture2dMSair.read_writeucharbufferintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
*d[*
*p_,
*p` 
+pt@
ksI#+s
A0hL!
6 f!
A0hN
6 f!
A0hPa
6 f!
A0hR
6 f!
A0hT!
6 f!
ByPd
Lsi
_ZTS16WritePixelParams
H"$|!$JB$LB$NB$PB$RB$T
%\b%6
%DB%
(2bP
CHP  [2
2 G0P!,
DOP  [2
D0l@
12bP
sF`
Hj0m
FnP 
G}P 
B3bP
G0l@
!"3B
 2#?B
2hY0P!
H0l@
R'[2
K0l@
6`Pqr/\q
{s2D
?#7uC
6{s:
M0l@
12bP
A0P!,t
~s0P!
2ho
x0P#
7x3bP
P0l@
Q  [2
|0P!
,A(2h
S?[2
R-Q 
DGf0
?"4bP
pFAJ
$R%E
O+uS
{DJ#
;#_l
T0l@
TrVx
12bP
So%W
O)C`Z
B0P!,
x)s
tuZ
U0l@
_`P$
pC b`0
B0P!
/2h{
oF_C
2x793
#/_l
=ffF
r3Gv
v`Pv
rD0w
pC@w`0
C0P!
=2h
^0l@
C0P!
 1P#
sF 
%F!
UT1
|2P
%La%
A0l@
sF@
61P!
71b`
c`D@
P  [2
;1P#
NNx8
d1bP
E0P!
P  sC@
/6@@
A0l@
sF@
h1P!
i1b`
g`D@
,A[l
P  [2
m1P#
A0l@
sF 
q1P!
r1b`
(sq
i`D@
P  [2
v1P#
A0l@
z1P!
{1b`
k`D@
P  [2
N_x|
A0l@
(sm
m`D@
P  [2
A0l@
A0l@
12bP
,All
P  [2
F0P!,
,Al2h(
,Al
A0l@
F0P!
P  sC 
A0l@
F0P!
P  sC@
w!h
 FF
=Lz8
@0F
A0l@
/6@(
@0F
!?F
@0F
Fd|
A0l@
`>@A
@),(
A0l@
sF@
g(P 
0Kp"#
$2"
"2P!
#2b`
((s
u(2
~`D@
}(P 
x(P  [2
'2P#
 rAp
/6@PE!
rQ`G
@0F
EbE
P0" 
RR`I
$PDx
B0l@
B0l@
B0l@
B0l@
@&AMl
p/AMl
:AMl
CAMl
 ZAMl
0oAMl
hbKA
e8A!
e E!
exE!
exK!
e`O!
e8Y!
e ]!
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25__metal_implicit_fc_pred_26llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8writeFromFloatTextureToBufferair.read_texture_cube.v4f32air.read_texture_3d.v4f32air.convert.f.f32.u.i32air.read_texture_2d_ms.v4f32air.get_num_samples_texture_2d_msair.read_texture_2d_array.v4f32air.read_texture_2d.v4f32air.convert.u.v2i32.u.v2i16air.convert.s.i8.f.f32air.convert.u.i8.f.f32air.convert.u.i16.f.f32air.pack.snorm4x8.v4f32air.pack.unorm4x8.srgb.v4f32air.pack.unorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
GISD
!Pq
bK!V
"x  
`B L@
)"Dh
*$2F
P$v`
fPY8
AqPl
VtAG%-
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint2copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchtextureLeveltextureLayerboolreverseTextureRowOrderair.arg_type_sizeair.arg_type_align_sizeWritePixelParamsoptionsair.function_constantkCopyTextureType2Dair.texturetexture2d<int, read>srcTexture2dkCopyTextureType2DArraytexture2d_array<int, read>srcTexture2dArraykCopyTextureType3Dtexture3d<int, read>srcTexture3dkCopyTextureTypeCubetexturecube<int, read>srcTextureCubekCopyTextureType2DMStexture2d_ms<int, read>srcTexture2dMSair.read_writeucharbufferintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~H+,M
A2l@
B2l@
_ZTS16WritePixelParams
H"$|!$JB$LB$NB$PB$RB$T
%\b%6
%DB%
,b@d
1AHli
0(T8
8AADj
Ic0mi
?(C@
2DP0P
<(h1
<lip
-@c6(
~c4!
k!P
Pk1"pA
Q"8BADj
?^dG(
f0bP
@ sCp'[
p +g
pC@+`P$2&\$
"pI
K0l@
(Cp6
A0P!,t`js0P
 C@/
M0l@
!X7s
bGvj
`!x
CcDG
F}DADj
CD0J
PCJ+
6tC5
@ sC
Cul@
P:4OpA
R0l@
pC`S`P
tR3E
W0^a
dKCM
U0l@
P,%^pA
U0l@
Tq^x
ul@p
V0l@
hbK!
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25__metal_implicit_fc_pred_26llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8writeFromIntTextureToBufferair.read_texture_cube.s.v4i32air.read_texture_3d.s.v4i32air.read_texture_2d_ms.s.v4i32air.get_num_samples_texture_2d_msair.read_texture_2d_array.s.v4i32air.read_texture_2d.s.v4i32air.convert.u.v2i32.u.v2i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
GISD
!Pq
bK!V
"x  
`B L@
)"Dh
0,gE
*$2F
P$v`
fPY8
AqPl
VtAG%-
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameushort2air.arg_namegIndicesair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infouint2copySizetextureOffsetuintbufferStartOffsetpixelSizebufferRowPitchtextureLeveltextureLayerboolreverseTextureRowOrderair.arg_type_sizeair.arg_type_align_sizeWritePixelParamsoptionsair.function_constantkCopyTextureType2Dair.texturetexture2d<uint, read>srcTexture2dkCopyTextureType2DArraytexture2d_array<uint, read>srcTexture2dArraykCopyTextureType3Dtexture3d<uint, read>srcTexture3dkCopyTextureTypeCubetexturecube<uint, read>srcTextureCubekCopyTextureType2DMStexture2d_ms<uint, read>srcTexture2dMSair.read_writeucharbufferintkCopyFormatTypekCopyTextureTypeomnipotent charSimple C++ TBAA
~H+,M
A2l@
B2l@
_ZTS16WritePixelParams
H"$|!$JB$LB$NB$PB$RB$T
%\b%6
%DB%
,b@d
1AHli
0(T8
8AADj
Ic0mi
?(C@
2DP0P
<(h1
<lip
-@c6(
~c4!
k!P
Pk1"pA
Q"8BADj
?^dG(
f0bP
@ sCp'[
p +g
pC@+`P$2&\$
"pI
K0l@
(Cp6
A0P!,t`js0P
 C@/
M0l@
!X7s
bGvj
`!x
CcDG
F}DADj
CD0J
PCJ+
6tC5
@ sC
Cul@
P:4OpA
R0l@
pC`S`P
tR3E
W0^a
dKCM
U0l@
P,%^pA
U0l@
Tq^x
ul@p
V0l@
hbK!
__metal_implicit_fc_pred_22__metal_implicit_fc_pred_23__metal_implicit_fc_pred_24__metal_implicit_fc_pred_25__metal_implicit_fc_pred_26llvm.global_ctors_ZL16kCopyTextureType_Z16kCopyTextureType.MTL_FC_INIT_20_i_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_illvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8writeFromUIntTextureToBufferair.read_texture_cube.u.v4i32air.read_texture_3d.u.v4i32air.read_texture_2d_ms.u.v4i32air.get_num_samples_texture_2d_msair.read_texture_2d_array.u.v4i32air.read_texture_2d.u.v4i32air.convert.u.v2i32.u.v2i1631001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
!D1a0
v@e@
@0DJ
P$v`
fPY8
AqPl
E%QcLT
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBufferintkCopyFormatTypeomnipotent charSimple C++ TBAA_ZTS16CopyVertexParams
 t`0
 td0
 th0
3t0
3tp
 x0C
r`]p0
3@{0Up 
ksi{#
c+s1c
]H%,M
2TB!
JAL
6@b6B
6D"7F
7JB<L
=Pb=R
=T">V
>ZB?\
D`bDb
 F"
]lBH
F0l@
F"
^@@M1
P"32&
"6R"
H0l@
F"
^@@M
K0l@
/&c3
 F"
 F"
28s2
L0l@
6ws:
@F"
@F"
N0l@
3?#D
F"
]lB0
^@@M
TBOpA
^@@%b
T0l@
0*x+
U0l@
AcpA
bt.
56fsF
^@@%
Y0l@
]lB0
^@@%p
\0l@
!X=0
TB~pA
]lBp
!p?0
`G"
`G"
A0l@
F"
A0l@
^@@%
!ED!8>
}~4
F"
A0l@
^@@%
]lB 
!EP!
`G"
A0l@
^@@E
!EZ!
d/C=
A0l@
^@@Eb
]lBX
`/CL
!E~!(
A0l@
F"
A0l@
^@@%<
F"
A0l@
^@@%
F"
A0l@
^@@%6
F"
A0l@
^@@%
`G"
`G"
B0l@
^@@Ec(
]lB`A!
B0l@
^@@Mz)
*,pE
*,@G
`/Cm
C*Q!
BIaM
XRHS
B0l@
^@@M
0*hWA
RTh[
Q!@[
Cr]!
`G"
Cb_!
B0l@
^@@E
!EF"(s
, YA
JX(z
*,@[
B0l@
!EH"8
c8_!
CZk!
*,he
F"
B0l@
^@@%$.
]lB o!
!ET"8x
i!hq
 ,(s
0*hsA
R[hw
cpo! w
F"
B0l@
^@@%t/
!E`"
c8u!
0*0}A
fba
,XyA
(!X+Tq
!Ep"
C0l@
^@@M
d/C?
F"
C0l@
^@@%j9
]lBP
!Ex"8
 ZCRs
 c#,
`G"
C0l@
^@@E ;
]lBH
C0l@
(!X+\x
F"
C0l@
^@@%r<
 ZCby
(!X+
d/C/
F"
C0l@
^@@%*=
]lBP
(!X+
d/C]
F"
C0l@
^@@%
 ZCB|
(!X+l|
F"
C0l@
^@@%z>
`G"
`G"
@9m?
(!X+H
(!X+
`/C;
(!X+
-1$J
 ZCl
(S$t
(!X+
(!X+
 ZCR
(!X+|
C"Y"
(!X+z
(6%@
(!X+b
0*H]B
`G"
?$5&
C:e"
 ,he
C"g"
 ,Pg
_&d/
D0l@
^@@E,M
!EV#(
 ,(m
D0l@
!EX#8
Cz{"
(!X+P
cxu"(}
(!X+
F"
?$>,
E0l@
^@@%|X
!Ed#8
 ZCv
 ZCb
(!X+
(!X+t
5-d/
F"
?$\-
E0l@
^@@%
!Ep#
wWzc
|ca
@90\
*1. 
*1.`
1.Jf
E0l@
]lBx
E0l@
^@@E)^
X/d/C
E0l@
^@@E
]lB8
E0l@
]lBp
 ,XC
"PCc/C
 ,HG
-44F
`G"
(<4v
F0l@
^@@E`j
]lBHQ#
 ,pU
 ,XW
"OC\
 ,@Y
,pQC
F0l@
#805
@X#Z
"8Wc/
F0l@
^@@M#l
]lB`_#
(~5n
+@aC
!h[c/C
!EB$
F0l@
^@@M
+peC
0*HgC
c#pk
0*xkC
p+A;l
2A;l
7A;l
p>A;l
`OA;l
[A;l
bA;l
nA;l
sA;l
zA;l
e`I!h
e(S!h
ePY!h
ep_!h
eXi!h
e8s!h
exy!`
eXE"h
e@O"h
eHY"h
ep_"h
e8i"h
e(s"h
e8}"h
ePA#h
ehQ#h
eX[#h
epa#h
e0e#h
eH}#h
llvm.global_ctors_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_i_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalconvertToFloatVertexFormatCS_ZL26convertToFloatVertexFormatjRU11MTLconstantK16CopyVertexParamsPU11MTLconstantKhPU9MTLdevicehair.convert.f.f32.u.i32air.convert.f.f32.s.i32air.convert.f.f32.s.i16air.unpack.snorm4x8.v4f32air.unpack.unorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializer
b0$
S@DG
P$v`
fPY8
AqPl
E%QcLT
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBuffer
L3k
3oP
@(vP
3Pm0QxP
3@k0Um
ksI#+s
_ZTS16CopyVertexParamsintomnipotent charSimple C++ TBAA
%,2K0T
,A1P
uU1K
0d`0
! 1T
2HA:l
llvm.global_ctorsexpandVertexFormatComponentsCSair.min.u.i3231001.718air64-apple-ios16.4.0-simulator
b0$
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.thread_position_in_gridair.arg_type_nameuintair.arg_nameidxair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infostartOffsetnumOffsetsair.arg_type_sizeair.arg_type_align_sizeCombineVisibilityResultOptionsoptionsushort4renderpassVisibilityResultair.read_writefinalResultsboolkCombineWithExistingResultomnipotent charSimple C++ TBAA
@P3g
3kP
I3(q
i3Pi0QnP
y3@g0Ui
ksi{#
c+s1c
SH%,M
_ZTS30CombineVisibilityResultOptionsint
1K`T4
8DcT
|@4F
\Pc7A
llvm.global_ctors_ZL26kCombineWithExistingResult_Z26kCombineWithExistingResult.MTL_FC_INIT_1000_b_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalcombineVisibilityResult31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializer
b0$
0*%H
`B L8
)"Dh
QEAD; `
$&h ,
P$v`
fPY8
AqPl
lD4<
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolindexBufferIsUint16air.bufferair.location_indexair.readair.address_spaceair.arg_type_sizeair.arg_type_align_sizeair.arg_type_nameushortair.arg_nameindexBufferUint16indexBufferIsUint32uintindexBufferUint32outIndexBufferIsUint16air.read_writeoutIndexBufferUint16outIndexBufferIsUint32outIndexBufferUint32air.buffer_sizeindexCountprimCountair.thread_position_in_gridprimfixIndexBufferKeyintomnipotent charSimple C++ TBAA
3n 
3p`
$3lP
@3Hv
XopqY7
Xopq
n0QlP
)pt@
FABA
ksI#+s
short
E@u 
x2K`
1L# h1
2 L@y
20Kp
Z7|
2HV@
Snl!
pc?A
z0l@
7$&
!87x0l@
7P1
1x0l@
Bpwqc
@vXAvZAvV
0P"p
d# 7
pCp'`0
P+2'0
#nl!
I0l@
t+ 7
O\ b
Snl!
.`PW
N\nl!
K0l@
3`@h
!&db
;x0l@
@&m`
A8l)
A8l)Z!
A:l)
9l)H#
 "A8l
/A8l
3A:l
aK1B
pCA:l
aKAG
PKA:l)n)
@OA8
__metal_implicit_fc_pred_27__metal_implicit_fc_pred_28__metal_implicit_fc_pred_29__metal_implicit_fc_pred_30llvm.global_ctors_ZL18fixIndexBufferMode_ZL13doPrimRestart_ZL22outIndexBufferIsUint32_ZL22outIndexBufferIsUint16_ZL19indexBufferIsUint32_ZL19indexBufferIsUint16_ZL17fixIndexBufferKey_Z17fixIndexBufferKey.MTL_FC_INIT_2000_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8fixIndexBuffer31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
J)Ar  
4 6,
`B L0
)"Dh
QEAD; `
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantbooloutIndexBufferIsUint16air.bufferair.location_indexair.read_writeair.address_spaceair.arg_type_sizeair.arg_type_align_sizeair.arg_type_nameushortair.arg_nameoutIndexBufferUint16outIndexBufferIsUint32uintoutIndexBufferUint32air.buffer_sizeair.readindexCountair.arg_unusedprimCountfirstVertexair.thread_position_in_gridprimfixIndexBufferKeyintomnipotent charSimple C++ TBAA
3n@
l0QlP
u3Lj
)pt@
ksI#+s
short
D@l 
 lpH
 u|7K
2,Jp
@MAu
pc?A
7x%
70=
.$nl!
DP!!
pc?!'
pc?A.
nx0l@
3nl!
G0l@
.x0l@
P R&0
nx0l@
D+bT
+ 7
+nl!
J0l@
nx0l@
Tnl!
JPgp*0l@
'n":
raKQ
A.l)
] ~a
] ~a
A8l)
 &A.l
*A8l
`6A.l
:A8l
] ~a
>A8l)
 CA.l
pGA8l
__metal_implicit_fc_pred_29__metal_implicit_fc_pred_30llvm.global_ctors_ZL18fixIndexBufferMode_ZL22outIndexBufferIsUint32_ZL22outIndexBufferIsUint16_ZL17fixIndexBufferKey_Z17fixIndexBufferKey.MTL_FC_INIT_2000_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8genIndexBuffer31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
Hn`H
S@%TDeT
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.positionair.arg_type_namefloat4air.arg_namepositionair.vertex_outputuser(locn1)float2texCoordsair.vertex_iduintvidair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerbooldstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptions
3r@
A3C
&(#66
UH*,M
omnipotent charSimple C++ TBAA_ZTS10BlitParams
/lxv
5((Pd
llvm.global_ctors_ZN2rx10mtl_shaderL8gCornersEblitVS31001.718air64-apple-ios16.4.0-simulator
b0$
Hq  
("(
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.positionair.arg_type_namefloat4air.vertex_iduintair.arg_namevidair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infoclearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsf\
3f0
3fp
 j0C
&(#66
<H*,M
omnipotent charSimple C++ TBAA_ZTS11ClearParams
llvm.global_ctors_ZN2rx10mtl_shaderL8gCornersEclearVS31001.718air64-apple-ios16.4.0-simulator
b0$
!D1a0
v@e@
@0DJ
P$v`
fPY8
AqPl
E%QcLT
<SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.vertex_idair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBufferintkCopyFormatTypeomnipotent charSimple C++ TBAA
 t`0
3s0
3sp
 w0C
q`]o0
3@z0Uo
ksi{#
c+s1c
YH%,M
<l@B
2TB!
_ZTS16CopyVertexParams
 td0A
JAL
6@b6B
6D"7F
7JB<L
=Pb=R
=T">V
>ZB?\
D`bDb
 F"
]lBH
F0l@
F"
^@@M1
P"32&
"6R"
H0l@
F"
^@@M
K0l@
/&c3
 F"
 F"
28s2
L0l@
6ws:
@F"
@F"
N0l@
3?#D
F"
]lB0
^@@M
TBOpA
^@@%b
T0l@
0*x+
U0l@
AcpA
bt.
56fsF
^@@%
Y0l@
]lB0
^@@%p
\0l@
!X=0
TB~pA
]lBp
!p?0
`G"
`G"
A0l@
F"
A0l@
^@@%
!ED!8>
}~4
F"
A0l@
^@@%
]lB 
!EP!
`G"
A0l@
^@@E
!EZ!
d/C=
A0l@
^@@Eb
]lBX
`/CL
!E~!(
A0l@
F"
A0l@
^@@%<
F"
A0l@
^@@%
F"
A0l@
^@@%6
F"
A0l@
^@@%
`G"
`G"
B0l@
^@@Ec(
]lB`A!
B0l@
^@@Mz)
*,pE
*,@G
`/Cm
C*Q!
BIaM
XRHS
B0l@
^@@M
0*hWA
RTh[
Q!@[
Cr]!
`G"
Cb_!
B0l@
^@@E
!EF"(s
, YA
JX(z
*,@[
B0l@
!EH"8
c8_!
CZk!
*,he
F"
B0l@
^@@%$.
]lB o!
!ET"8x
i!hq
 ,(s
0*hsA
R[hw
cpo! w
F"
B0l@
^@@%t/
!E`"
c8u!
0*0}A
fba
,XyA
(!X+Tq
!Ep"
C0l@
^@@M
d/C?
F"
C0l@
^@@%j9
]lBP
!Ex"8
 ZCRs
 c#,
`G"
C0l@
^@@E ;
]lBH
C0l@
(!X+\x
F"
C0l@
^@@%r<
 ZCby
(!X+
d/C/
F"
C0l@
^@@%*=
]lBP
(!X+
d/C]
F"
C0l@
^@@%
 ZCB|
(!X+l|
F"
C0l@
^@@%z>
`G"
`G"
@9m?
(!X+H
(!X+
`/C;
(!X+
-1$J
 ZCl
(S$t
(!X+
(!X+
 ZCR
(!X+|
C"Y"
(!X+z
(6%@
(!X+b
0*H]B
`G"
?$5&
C:e"
 ,he
C"g"
 ,Pg
_&d/
D0l@
^@@E,M
!EV#(
 ,(m
D0l@
!EX#8
Cz{"
(!X+P
cxu"(}
(!X+
F"
?$>,
E0l@
^@@%|X
!Ed#8
 ZCv
 ZCb
(!X+
(!X+t
5-d/
F"
?$\-
E0l@
^@@%
!Ep#
wWzc
|ca
@90\
*1. 
*1.`
1.Jf
E0l@
]lBx
E0l@
^@@E)^
X/d/C
E0l@
^@@E
]lB8
E0l@
]lBp
 ,XC
"PCc/C
 ,HG
-44F
`G"
(<4v
F0l@
^@@E`j
]lBHQ#
 ,pU
 ,XW
"OC\
 ,@Y
,pQC
F0l@
#805
@X#Z
"8Wc/
F0l@
^@@M#l
]lB`_#
(~5n
+@aC
!h[c/C
!EB$
F0l@
^@@M
+peC
0*HgC
c#pk
0*xkC
p+A;l
2A;l
7A;l
p>A;l
`OA;l
[A;l
bA;l
nA;l
sA;l
zA;l
e`I!h
e(S!h
ePY!h
ep_!h
eXi!h
e8s!h
exy!`
eXE"h
e@O"h
eHY"h
ep_"h
e8i"h
e(s"h
e8}"h
ePA#h
ehQ#h
eX[#h
epa#h
e0e#h
eH}#h
llvm.global_ctors_ZL15kCopyFormatType_Z15kCopyFormatType.MTL_FC_INIT_10_i_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalconvertToFloatVertexFormatVS_ZL26convertToFloatVertexFormatjRU11MTLconstantK16CopyVertexParamsPU11MTLconstantKhPU9MTLdevicehair.convert.f.f32.u.i32air.convert.f.f32.s.i32air.convert.f.f32.s.i16air.unpack.snorm4x8.v4f32air.unpack.unorm4x8.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializer
b0$
S@DG
P$v`
fPY8
AqPl
E%QcLT
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.vertex_idair.arg_type_nameuintair.arg_nameindexair.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infosrcBufferStartOffsetsrcStridesrcComponentBytessrcComponentsuchar4srcDefaultAlphaDatadstBufferStartOffsetdstStridedstComponentsvertexCountair.arg_type_sizeair.arg_type_align_sizeCopyVertexParamsoptionsucharsrcBufferair.read_writedstBuffer
L3k
3oP
@(vP
3Pm0QxP
3@k0Um
ksI#+s
_ZTS16CopyVertexParamsintomnipotent charSimple C++ TBAA
AeT
0Eb0
A0l@
B0l@
2@A:l
llvm.global_ctorsexpandVertexFormatComponentsVSair.min.u.i3231001.718air64-apple-ios16.4.0-simulator
b0$
&*"~
xD4*
 m("$H
`B L(
)"Dh
hO4@A
%(k0
@0DJ
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_namefloat4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivepositionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcTextureCubekSourceTextureType3Dtexture3d<float, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
d1Cb
<<n0
=<w0
=<~0
0<|A
ksi{#
c+s1c
H&,M
_ZTS10BlitParams
)lxD
C0bP
D0P!,
04up
).1
NP  #
XP  #
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitFloatFS_ZL15blitReadTextureIfEDv4_T_9BlitVSOutN5metal9texture2dIS0_LNS3_6accessE0EvEENS3_15texture2d_arrayIS0_LS5_0EvEENS3_12texture2d_msIS0_LS5_1EvEENS3_11texturecubeIS0_LS5_0EvEENS3_9texture3dIS0_LS5_0EvEENS3_7samplerERU11MTLconstantK10BlitParamsair.sample_texture_3d.v4f32air.convert.f.f32.s.i32air.convert.f.f32.u.i32air.get_depth_texture_3dair.sample_texture_cube.v4f32air.read_texture_2d_ms.v4f32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
T+U$" V
reA]>
`B L@
$Q&
)"Dh
h64@9
dkaP
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<int, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<int, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<int, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<int, sample>srcTextureCubekSourceTextureType3Dtexture3d<int, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
e1Cr
:8k
!1CA
3O_
%RB%V
%Rac
ksI#+s
;k+s
_ZTS10BlitParams
)lxF
1T<
sB@
1AK
EaB@
k1b`
,A5P
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitIntFSair.convert.f.f32.s.i32air.sample_texture_3d.s.v4i32air.convert.f.f32.u.i32air.get_depth_texture_3dair.sample_texture_cube.s.v4i32air.read_texture_2d_ms.s.v4i32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.s.v4i32air.sample_texture_2d.s.v4i3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
T+U$" V
reA]>
`B L@
$Q&
)"Dh
'4@9
v@cS
v@7D
8Dj%: 
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameuint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<uint, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<uint, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<uint, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<uint, sample>srcTextureCubekSourceTextureType3Dtexture3d<uint, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
e1Cr
:8k
!1CA
3O_
%RB%V
%Rac
ksI#+s
;k+s
_ZTS10BlitParams
)lxF
1T<
sB@
1AK
EaB@
k1b`
,A5P
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitUIntFSair.convert.f.f32.u.i32air.sample_texture_3d.u.v4i32air.convert.f.f32.s.i32air.get_depth_texture_3dair.sample_texture_cube.u.v4i32air.read_texture_2d_ms.u.v4i32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
"<$d*
*BD@
`B L(
)"Dh
0,&8
D4@I
tCd ,l0
P$v`
fPY8
AqPl
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameuint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordskSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcTextureCubekSourceTextureType3Dtexture3d<float, sample>srcTexture3dair.samplersamplertextureSamplerair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionsuintkNumColorOutputskPremultiplyAlphakUnmultiplyAlphakSourceTextureTypeomnipotent charSimple C++ TBAA
 MT5
 MT6
 MT7
4Qc0
e1Cr
:8k
!1CA
3O_
%RB%V
%Rac
ksI#+s
;k+s
_ZTS10BlitParams
*lxF
C0bP
D0P!,
04vp
).1
NP  #
XP  #
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_12__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i_ZL16kUnmultiplyAlpha_Z16kUnmultiplyAlpha.MTL_FC_INIT_2_b_ZL17kPremultiplyAlpha_Z17kPremultiplyAlpha.MTL_FC_INIT_1_b_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8copyTextureFloatToUIntFSair.convert.u.v4i32.f.v4f32_ZL15blitReadTextureIfEDv4_T_9BlitVSOutN5metal9texture2dIS0_LNS3_6accessE0EvEENS3_15texture2d_arrayIS0_LS5_0EvEENS3_12texture2d_msIS0_LS5_1EvEENS3_11texturecubeIS0_LS5_0EvEENS3_9texture3dIS0_LS5_0EvEENS3_7samplerERU11MTLconstantK10BlitParamsair.sample_texture_3d.v4f32air.convert.f.f32.s.i32air.convert.f.f32.u.i32air.get_depth_texture_3dair.sample_texture_cube.v4f32air.read_texture_2d_ms.v4f32air.get_num_samples_texture_2d_msair.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
(",B
wISD
qMTD
"lA
`B L
)2Dh
v@xa-
KlB0
P$v`
fPY8
AqPl
(OD1
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.depthair.depth_qualifierair.anyair.arg_type_namefloatair.arg_namedepthair.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordsair.function_constantboolkSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionskSourceTextureTypeair.sampler_stateomnipotent charSimple C++ TBAA
<P$M
I*l
&(#66
vH*,M
H),M
6 N!
6 N!
A0x@
6 V!
A0xB
6 V!
_ZTS10BlitParams
 ,r0AX
6<)a
7lq`
@F!
Da4!
fa4!
aAq
@F!
@`paP
__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitDepthFS_ZL11sampleDepthN5metal9texture2dIfLNS_6accessE0EvEENS_15texture2d_arrayIfLS1_0EvEENS_12texture2d_msIfLS1_1EvEENS_11texturecubeIfLS1_0EvEEDv2_fRU11MTLconstantK10BlitParamsair.sample_texture_cube.v4f32air.convert.f.f32.s.i32air.read_texture_2d_ms.v4f32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
(",B
wISD
qMTD
"lA
O(H4Q
,$fR
E%I |  
`B L0
)2Dh
ND# 
JjB0
P$v`
fPY8
AqPl
h]t!
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.stencilair.arg_type_nameuintair.arg_namestencilair.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordsair.function_constantboolkSourceTexture2Type2Dair.textureair.location_indexair.sampletexture2d<uint, sample>srcTexture2dkSourceTexture2Type2DArraytexture2d_array<uint, sample>srcTexture2dArraykSourceTexture2Type2DMSair.readtexture2d_ms<uint, read>srcTexture2dMSkSourceTexture2TypeCubetexturecube<uint, sample>srcTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionskSourceTexture2Typeair.sampler_stateomnipotent charSimple C++ TBAA
L)x
*x
H+,M
6 P!
6 P!
6 P!
A0x@
6 P!
_ZTS10BlitParams
 ,q0AX
%6/Q
1 F!
%hF!
Da4!
CPXa
C`\a
@``a
__metal_implicit_fc_pred_13__metal_implicit_fc_pred_14__metal_implicit_fc_pred_15__metal_implicit_fc_pred_16llvm.global_ctors_ZL19kSourceTexture2Type_Z19kSourceTexture2Type.MTL_FC_INIT_4_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitStencilFSair.sample_texture_cube.u.v4i32air.convert.f.f32.s.i32air.read_texture_2d_ms.u.v4i32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
(",B"
&*"~{
&*"~{
lE!YL
tBE"
P-T$"
`B L0
3Ax 
)2Dh
H,4@
%(b0
!R,mp
@0DJ
S@%TDeD
P$v`
fPY8
AqPl
gYH6Y
ALqD
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.depthair.depth_qualifierair.anyair.arg_type_namefloatair.arg_namedepthair.stenciluintstencilair.positionair.centerair.no_perspectivefloat4positionair.arg_unusedair.fragment_inputuser(locn1)air.perspectivefloat2texCoordsair.function_constantboolkSourceTextureType2Dair.textureair.location_indexair.sampletexture2d<float, sample>srcDepthTexture2dkSourceTextureType2DArraytexture2d_array<float, sample>srcDepthTexture2dArraykSourceTextureType2DMSair.readtexture2d_ms<float, read>srcDepthTexture2dMSkSourceTextureTypeCubetexturecube<float, sample>srcDepthTextureCubekSourceTexture2Type2Dtexture2d<uint, sample>srcStencilTexture2dkSourceTexture2Type2DArraytexture2d_array<uint, sample>srcStencilTexture2dArraykSourceTexture2Type2DMStexture2d_ms<uint, read>srcStencilTexture2dMSkSourceTexture2TypeCubetexturecube<uint, sample>srcStencilTextureCubeair.bufferair.buffer_sizeair.address_spaceair.struct_type_infosrcTexCoordsintsrcLevelsrcLayerdstFlipViewportXdstFlipViewportYdstLuminanceucharpaddingair.arg_type_sizeair.arg_type_align_sizeBlitParamsoptionskSourceTextureTypekSourceTexture2Typeair.sampler_stateomnipotent charSimple C++ TBAA_ZTS10BlitParams
 ,|0
5CQE
FADb$H
$P"%Rac
ksI#+s
;k+s
@7$m
sl@
,A3bP
!8y0
!H}`x
A1b`
 (2
sBP
sC0
sx0
__metal_implicit_fc_pred_10__metal_implicit_fc_pred_11__metal_implicit_fc_pred_13__metal_implicit_fc_pred_14__metal_implicit_fc_pred_15__metal_implicit_fc_pred_16__metal_implicit_fc_pred_8__metal_implicit_fc_pred_9llvm.global_ctors_ZL19kSourceTexture2Type_Z19kSourceTexture2Type.MTL_FC_INIT_4_i_ZL18kSourceTextureType_Z18kSourceTextureType.MTL_FC_INIT_3_i__air_sampler_state.57llvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8blitDepthStencilFSair.sample_texture_cube.u.v4i32air.convert.f.f32.s.i32air.read_texture_2d_ms.u.v4i32air.convert.u.v2i32.f.v2f32air.convert.f.v2f32.u.v2i32air.get_height_texture_2d_msair.get_width_texture_2d_msair.sample_texture_2d_array.u.v4i32air.sample_texture_2d.u.v4i32_ZL11sampleDepthN5metal9texture2dIfLNS_6accessE0EvEENS_15texture2d_arrayIfLS1_0EvEENS_12texture2d_msIfLS1_1EvEENS_11texturecubeIfLS1_0EvEEDv2_fRU11MTLconstantK10BlitParamsair.sample_texture_cube.v4f32air.read_texture_2d_ms.v4f32air.sample_texture_2d_array.v4f32air.sample_texture_2d.v4f3231001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
'ISD
`B L
)"Dh
0,#,
'4@y
P$v`
fPY8
AqPl
HHD)
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_namefloat4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infoclearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsuintkNumColorOutputsomnipotent charSimple C++ TBAA
3w 
3y`
$3u
@3$N/D
DU3
D]3
`3$N8Du
De3
Dm3
p3$N9Dx
Du3
D}3
4Qa0
ksi{#
c+s1c
]H&,M
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7llvm.global_ctors_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8clearFloatFS31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
`B L
)"Dh
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofloat4clearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsuintkNumColorOutputsomnipotent charSimple C++ TBAAF
3x 
3z`
$3v
DU3
D]3
De3
Dm3
Du3
D}3
4Qa0
Pq0C
ksI#+s
;k+s
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7llvm.global_ctors_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8clearIntFS31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
b0$
`B L
)"Dh
P$v`
fPY8
AqPl
SDK Versionwchar_sizeair.max_device_buffersair.max_constant_buffersair.max_threadgroup_buffersair.max_texturesair.max_read_write_texturesair.max_samplersApple metal version 31001.718 (metalfe-31001.718)Metalair.compile.denorms_disableair.compile.fast_math_enableair.compile.framebuffer_fetch_enableair.function_constantboolkColorOutputAvailable0air.render_targetair.arg_type_nameuint4air.arg_namecolor0kColorOutputAvailable1color1kColorOutputAvailable2color2kColorOutputAvailable3color3kColorOutputAvailable4color4kColorOutputAvailable5color5kColorOutputAvailable6color6kColorOutputAvailable7color7air.bufferair.buffer_sizeair.location_indexair.readair.address_spaceair.struct_type_infofloat4clearColorfloatclearDepthair.arg_type_sizeair.arg_type_align_sizeClearParamsclearParamsuintkNumColorOutputsomnipotent charSimple C++ TBAA
3x 
3z`
$3v
DU3
D]3
De3
Dm3
Du3
D}3
4Qa0
Pq0C
ksI#+s
;k+s
__metal_implicit_fc_pred_0__metal_implicit_fc_pred_1__metal_implicit_fc_pred_2__metal_implicit_fc_pred_3__metal_implicit_fc_pred_4__metal_implicit_fc_pred_5__metal_implicit_fc_pred_6__metal_implicit_fc_pred_7llvm.global_ctors_Z16kNumColorOutputs.MTL_FC_INIT_0_jllvm.compiler.used_GLOBAL__sub_I_mtl_default_shaders_src_autogen.metalair.normalize_function_constant_predicate.i8clearUIntFS31001.718air64-apple-ios16.4.0-simulatorair.static_initair.fc_initializerllvm.metadata
RBUFg
AIRR
kSourceTexture2Type
buffer
uchar
resolveMS
bool
dstBufferRowPitch
uint
dstSize
uint2
srcLayer
srcLevel
srcTexCoordSteps
srcStartTexCoords
float2
options
BlitStencilToBufferParams
srcTextureCube
texturecube<uint, sample>
srcTexture2dMS
texture2d_ms<uint, read>
srcTexture2dArray
texture2d_array<uint, sample>
srcTexture2d
texture2d<uint, sample>
gIndices
ushort2
blitStencilToBufferCS
ENDT
RBUF
AIRR
output
ushort
input
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
convertIndexU8ToU16
ENDT
RBUF
AIRR
kSourceBufferAligned
output
inputAligned
ushort
input
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
convertIndexU16
ENDT
RBUF
AIRR
kSourceBufferAligned
output
inputAligned
input
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
convertIndexU32
ENDT\
RBUFL
AIRR
output
vertexCount
firstVertex
options
IndexFromArrayParams
uint
genTriFanIndicesFromArray
ENDT
RBUF
AIRR
kSourceIndexIsU32
kSourceIndexIsU16
kSourceIndexIsU8
kSourceBufferAligned
output
inputU32
inputU16
ushort
inputU8
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
genTriFanIndicesFromElements
ENDT`
RBUFP
AIRR
output
vertexCount
firstVertex
options
IndexFromArrayParams
uint
genLineLoopIndicesFromArray
ENDT
RBUF
AIRR
kSourceIndexIsU32
kSourceIndexIsU16
kSourceIndexIsU8
kSourceBufferAligned
output
inputU32
inputU16
ushort
inputU8
uchar
primitiveRestartEnabled
bool
indexCount
srcOffset
options
IndexConversionParams
uint
genLineLoopIndicesFromElements
ENDT,
RBUF
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texture3d<float, write>
srcTexture
texture3d<float, sample>
gIndices
ushort3
lIndex
uint
generate3DMipmaps
ENDT 
RBUF
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texture2d<float, write>
srcTexture
texture2d<float, sample>
gIndices
ushort2
lIndex
uint
generate2DMipmaps
ENDT$
RBUF
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texturecube<float, write>
srcTexture
texturecube<float, sample>
gIndices
ushort3
lIndex
uint
generateCubeMipmaps
ENDT<
RBUF,
AIRR
sRGB
bool
numMipLevelsToGen
srcLevel
options
GenMipParams
dstMip4
dstMip3
dstMip2
dstMip1
texture2d_array<float, write>
srcTexture
texture2d_array<float, sample>
gIndices
ushort3
lIndex
uint
generate2DArrayMipmaps
ENDTh
RBUFX
AIRR
kCopyTextureType
kCopyFormatType
dstTextureCube
texturecube<float, write>
dstTexture3d
texture3d<float, write>
dstTexture2dArray
texture2d_array<float, write>
dstTexture2d
texture2d<float, write>
buffer
uchar
bufferDepthPitch
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint3
options
CopyPixelParams
gIndices
ushort3
readFromBufferToFloatTexture
ENDTd
RBUFT
AIRR
kCopyTextureType
kCopyFormatType
dstTextureCube
texturecube<int, write>
dstTexture3d
texture3d<int, write>
dstTexture2dArray
texture2d_array<int, write>
dstTexture2d
texture2d<int, write>
buffer
uchar
bufferDepthPitch
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint3
options
CopyPixelParams
gIndices
ushort3
readFromBufferToIntTexture
ENDTh
RBUFX
AIRR
kCopyTextureType
kCopyFormatType
dstTextureCube
texturecube<uint, write>
dstTexture3d
texture3d<uint, write>
dstTexture2dArray
texture2d_array<uint, write>
dstTexture2d
texture2d<uint, write>
buffer
uchar
bufferDepthPitch
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint3
options
CopyPixelParams
gIndices
ushort3
readFromBufferToUIntTexture
ENDT@
RBUF0
AIRR
kCopyTextureType
kCopyFormatType
buffer
uchar
srcTexture2dMS
texture2d_ms<float, read>
srcTextureCube
texturecube<float, read>
srcTexture3d
texture3d<float, read>
srcTexture2dArray
texture2d_array<float, read>
srcTexture2d
texture2d<float, read>
reverseTextureRowOrder
bool
textureLayer
textureLevel
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint2
options
WritePixelParams
gIndices
ushort2
writeFromFloatTextureToBuffer
ENDT0
RBUF 
AIRR
kCopyTextureType
kCopyFormatType
buffer
uchar
srcTexture2dMS
texture2d_ms<int, read>
srcTextureCube
texturecube<int, read>
srcTexture3d
texture3d<int, read>
srcTexture2dArray
texture2d_array<int, read>
srcTexture2d
texture2d<int, read>
reverseTextureRowOrder
bool
textureLayer
textureLevel
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint2
options
WritePixelParams
gIndices
ushort2
writeFromIntTextureToBuffer
ENDT8
RBUF(
AIRR
kCopyTextureType
kCopyFormatType
buffer
uchar
srcTexture2dMS
texture2d_ms<uint, read>
srcTextureCube
texturecube<uint, read>
srcTexture3d
texture3d<uint, read>
srcTexture2dArray
texture2d_array<uint, read>
srcTexture2d
texture2d<uint, read>
reverseTextureRowOrder
bool
textureLayer
textureLevel
bufferRowPitch
pixelSize
bufferStartOffset
uint
textureOffset
copySize
uint2
options
WritePixelParams
gIndices
ushort2
writeFromUIntTextureToBuffer
ENDT
RBUFp
AIRR
kCopyFormatType
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
convertToFloatVertexFormatCS
ENDT 
RBUF
AIRR
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
expandVertexFormatComponentsCS
ENDTP
RBUF@
AIRR
kCombineWithExistingResult
bool
finalResults
renderpassVisibilityResult
ushort4
numOffsets
startOffset
options
CombineVisibilityResultOptions
uint
combineVisibilityResult
ENDTL
RBUF<
AIRR
fixIndexBufferKey
prim
primCount
indexCount
outIndexBufferUint32
outIndexBufferUint16
indexBufferUint32
uint
indexBufferUint16
ushort
fixIndexBuffer
ENDT 
RBUF
AIRR
fixIndexBufferKey
prim
firstVertex
primCount
indexCount
outIndexBufferUint32
uint
outIndexBufferUint16
ushort
genIndexBuffer
ENDT
RBUF
AIRR
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
uint
texCoords
float2
user(locn1)
position
float4
blitVS
ENDT$
RBUF
AIRR
clearDepth
float
clearColor
clearParams
ClearParams
uint
float4
clearVS
ENDT
RBUFx
AIRR
kCopyFormatType
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
convertToFloatVertexFormatVS
ENDT 
RBUF
AIRR
dstBuffer
srcBuffer
uchar
vertexCount
dstComponents
dstStride
dstBufferStartOffset
srcDefaultAlphaData
uchar4
srcComponents
srcComponentBytes
srcStride
srcBufferStartOffset
options
CopyVertexParams
index
uint
expandVertexFormatComponentsVS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<float, sample>
srcTextureCube
texturecube<float, sample>
srcTexture2dMS
texture2d_ms<float, read>
srcTexture2dArray
texture2d_array<float, sample>
srcTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
color7
color6
color5
color4
color3
color2
color1
color0
float4
blitFloatFS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<int, sample>
srcTextureCube
texturecube<int, sample>
srcTexture2dMS
texture2d_ms<int, read>
srcTexture2dArray
texture2d_array<int, sample>
srcTexture2d
texture2d<int, sample>
texCoords
float2
user(locn1)
position
float4
color7
color6
color5
color4
color3
color2
color1
color0
int4
blitIntFS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<uint, sample>
srcTextureCube
texturecube<uint, sample>
srcTexture2dMS
texture2d_ms<uint, read>
srcTexture2dArray
texture2d_array<uint, sample>
srcTexture2d
texture2d<uint, sample>
texCoords
float2
user(locn1)
position
float4
color7
color6
color5
color4
color3
color2
color1
color0
uint4
blitUIntFS
ENDT
RBUF
AIRR
kSourceTextureType
kUnmultiplyAlpha
kPremultiplyAlpha
kNumColorOutputs
uint
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
textureSampler
sampler
srcTexture3d
texture3d<float, sample>
srcTextureCube
texturecube<float, sample>
srcTexture2dMS
texture2d_ms<float, read>
srcTexture2dArray
texture2d_array<float, sample>
srcTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
float4
color7
color6
color5
color4
color3
color2
color1
color0
uint4
copyTextureFloatToUIntFS
ENDT
RBUF
AIRR
kSourceTextureType
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
srcTextureCube
texturecube<float, sample>
srcTexture2dMS
texture2d_ms<float, read>
srcTexture2dArray
texture2d_array<float, sample>
srcTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
float4
depth
float
blitDepthFS
ENDT
RBUF
AIRR
kSourceTexture2Type
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
srcTextureCube
texturecube<uint, sample>
srcTexture2dMS
texture2d_ms<uint, read>
srcTexture2dArray
texture2d_array<uint, sample>
srcTexture2d
texture2d<uint, sample>
texCoords
float2
user(locn1)
position
float4
stencil
uint
blitStencilFS
ENDT
RBUF
AIRR
kSourceTexture2Type
kSourceTextureType
padding
uchar
dstLuminance
dstFlipViewportY
dstFlipViewportX
bool
srcLayer
srcLevel
srcTexCoords
options
BlitParams
srcStencilTextureCube
texturecube<uint, sample>
srcStencilTexture2dMS
texture2d_ms<uint, read>
srcStencilTexture2dArray
texture2d_array<uint, sample>
srcStencilTexture2d
texture2d<uint, sample>
srcDepthTextureCube
texturecube<float, sample>
srcDepthTexture2dMS
texture2d_ms<float, read>
srcDepthTexture2dArray
texture2d_array<float, sample>
srcDepthTexture2d
texture2d<float, sample>
texCoords
float2
user(locn1)
position
float4
stencil
uint
depth
float
blitDepthStencilFS
ENDT
RBUF
AIRR
kNumColorOutputs
uint
clearDepth
float
clearColor
clearParams
ClearParams
color7
color6
color5
color4
color3
color2
color1
color0
float4
clearFloatFS
ENDT
RBUF
AIRR
kNumColorOutputs
uint
clearDepth
float
clearColor
float4
clearParams
ClearParams
color7
color6
color5
color4
color3
color2
color1
color0
int4
clearIntFS
ENDT
RBUF
AIRR
kNumColorOutputs
uint
clearDepth
float
clearColor
float4
clearParams
ClearParams
color7
color6
color5
color4
color3
color2
color1
color0
uint4
clearUIntFS
ENDT
"&*+."
Y!Y#Y&Y'Y;Y
EAEQEUEWEqEQNUNWNaNqN
F&F(F*F
acbBufferOffsets
depthRange
renderArea
flipXY
dither
misc
xfbBufferOffsets
xfbVerticesPerInstance
xfbBufferOffsets
xfbVerticesPerInstance
coverageMask
unused
 __unassigned_attribute__
7@EKQW]
$$$$$$$$?ACHHHHH
#version 300 es
precision highp float;
#define kMaxTexUnits 4
#define kMaxLights   8
#define kTexUnits 
in vec4 pos;
in vec3 normal;
in mediump vec4 color;
in float pointsize;
#if kTexUnits >= 1
in mediump vec4 texcoord0;
#endif
#if kTexUnits >= 2
in mediump vec4 texcoord1;
#endif
#if kTexUnits >= 3
in mediump vec4 texcoord2;
#endif
#if kTexUnits >= 4
in mediump vec4 texcoord3;
#endif
uniform mat4 projection;
uniform mat4 modelview;
uniform mat4 modelview_invtr;
uniform mat4 texture_matrix[kMaxTexUnits];
// Point rasterization//////////////////////////////////////////////////////////
uniform float point_size_min;
uniform float point_size_max;
uniform vec3 point_distance_attenuation;
// Shading: flat shading, lighting, and materials///////////////////////////////
uniform mediump vec4 material_ambient;
uniform mediump vec4 material_diffuse;
uniform mediump vec4 material_specular;
uniform mediump vec4 material_emissive;
uniform float material_specular_exponent;
uniform mediump vec4 light_model_scene_ambient;
uniform mediump vec4 light_ambients[kMaxLights];
uniform mediump vec4 light_diffuses[kMaxLights];
uniform mediump vec4 light_speculars[kMaxLights];
uniform vec4 light_positions[kMaxLights];
uniform vec3 light_directions[kMaxLights];
uniform float light_spotlight_exponents[kMaxLights];
uniform float light_spotlight_cutoff_angles[kMaxLights];
uniform float light_attenuation_consts[kMaxLights];
uniform float light_attenuation_linears[kMaxLights];
uniform float light_attenuation_quadratics[kMaxLights];
// GL_OES_draw_texture uniforms/////////////////////////////////////////////////
uniform vec4 draw_texture_coords;
uniform vec2 draw_texture_dims;
uniform mediump vec4 draw_texture_normalized_crop_rect[kMaxTexUnits];
// Varyings/////////////////////////////////////////////////////////////////////
out vec4 pos_varying;
out vec3 normal_varying;
out mediump vec4 color_varying;
flat out mediump vec4 color_varying_flat;
#if kTexUnits >= 1
out mediump vec3 texcoord0_varying;
#endif
#if kTexUnits >= 2
out mediump vec3 texcoord1_varying;
#endif
#if kTexUnits >= 3
out mediump vec3 texcoord2_varying;
#endif
#if kTexUnits >= 4
out mediump vec3 texcoord3_varying;
#endif
float posDot(vec3 a, vec3 b)
    return max(dot(a, b), 0.0);
mediump vec4 doLighting(mediump vec4 vertexColor)
    mediump vec4 materialAmbientActual = material_ambient;
    mediump vec4 materialDiffuseActual = material_diffuse;
    if (enable_color_material)
    {
        materialAmbientActual = vertexColor;
        materialDiffuseActual = vertexColor;
    }
    mediump vec4 lightingResult = material_emissive + materialAmbientActual * light_model_scene_ambient;
    for (int i = 0; i < kMaxLights; i++)
    {
        if (!light_enables[i])
            continue;
        mediump vec4 lightAmbient  = light_ambients[i];
        mediump vec4 lightDiffuse  = light_diffuses[i];
        mediump vec4 lightSpecular = light_speculars[i];
        vec4 lightPos      = light_positions[i];
        vec3 lightDir      = light_directions[i];
        float attConst     = light_attenuation_consts[i];
        float attLinear    = light_attenuation_linears[i];
        float attQuadratic = light_attenuation_quadratics[i];
        float spotAngle    = light_spotlight_cutoff_angles[i];
        float spotExponent = light_spotlight_exponents[i];
        vec3 toLight;
        if (lightPos.w == 0.0)
        {
            toLight = lightPos.xyz;
        }
        else
        {
            toLight = (lightPos.xyz / lightPos.w - pos_varying.xyz);
        }
        float lightDist = length(toLight);
        vec3 toLightNormalized = normalize(toLight);
        vec3 h                 = toLightNormalized + vec3(0.0, 0.0, 1.0);
        float ndotL            = posDot(normal_varying, toLightNormalized);
        float ndoth            = posDot(normal_varying, normalize(h));
        float specAtt;
        if (ndotL != 0.0)
        {
            specAtt = 1.0;
        }
        else
        {
            specAtt = 0.0;
        }
        float att;
        if (lightPos.w != 0.0)
        {
            float attDenom =
                (attConst + attLinear * lightDist + attQuadratic * lightDist * lightDist);
            att = 1.0 / attDenom;
        }
        else
        {
            att = 1.0;
        }
        mediump float spot;
        mediump float spotAngleCos = cos(radians(spotAngle));
        vec3 toSurfaceDir  = -toLightNormalized;
        mediump float spotDot      = posDot(toSurfaceDir, normalize(lightDir));
        if (spotAngle == 180.0 || lightPos.w == 0.0)
        {
            spot = 1.0;
        }
        else
        {
            if (spotDot < spotAngleCos)
            {
                spot = 0.0;
            }
            else
            {
                spot = pow(spotDot, spotExponent);
            }
        }
        mediump vec4 contrib = materialAmbientActual * lightAmbient;
        contrib += ndotL * materialDiffuseActual * lightDiffuse;
        if (ndoth > 0.0 && material_specular_exponent > 0.0)
        {
            contrib += specAtt * pow(ndoth, material_specular_exponent) * material_specular *
                       lightSpecular;
        }
        else
        {
            if (ndoth > 0.0)
            {
                contrib += specAtt * material_specular * lightSpecular;
            }
        }
        contrib *= att * spot;
        lightingResult += contrib;
    }
    return lightingResult;
const mediump vec4 drawTextureVertices[6] = vec4[](
    vec4(0.0, 0.0, 0.0, 1.0),
    vec4(1.0, 0.0, 0.0, 1.0),
    vec4(1.0, 1.0, 0.0, 1.0),
    vec4(0.0, 0.0, 0.0, 1.0),
    vec4(1.0, 1.0, 0.0, 1.0),
    vec4(0.0, 1.0, 0.0, 1.0));
mediump vec4 drawTexturePosition(int vertexId)
    // The texture is drawn in the XY plane, so Z is constant.
    vec2 positionXY = draw_texture_coords.xy + drawTextureVertices[vertexId].xy * draw_texture_dims;
    return vec4(positionXY, draw_texture_coords.z, 1.0);
mediump vec3 drawTextureTexCoord(int vertexId, int textureUnit)
    // The texture is drawn in the XY plane, so Z is 0.
    mediump vec2 texCropPos = draw_texture_normalized_crop_rect[textureUnit].xy;
    mediump vec2 texCropDim = draw_texture_normalized_crop_rect[textureUnit].zw;
    mediump vec2 texCoords  = texCropPos + drawTextureVertices[vertexId].xy * texCropDim;
    return vec3(texCoords, 0.0);
vec4 calcWorldPosition(vec4 posInput)
    return modelview * posInput;
vec4 calcNdcFromWorldPosition(vec4 worldPos)
    return projection * worldPos;
float calcPointSize(vec4 ndcPos)
    float dist         = length(ndcPos.z);
    float attConst     = point_distance_attenuation[0];
    float attLinear    = point_distance_attenuation[1];
    float attQuad      = point_distance_attenuation[2];
    float attPart      = attConst + attLinear * dist + attQuad * dist * dist;
    float attPointSize = pointsize / pow(attPart, 0.5);
    return clamp(attPointSize, point_size_min, point_size_max);
vec3 calcNormal(vec3 normalInput)
    mat3 mvInvTr3 = mat3(modelview_invtr);
    vec3 result   = mvInvTr3 * normalInput;
    if (enable_rescale_normal)
    {
        float rescale   = 1.0;
        vec3 rescaleVec = vec3(mvInvTr3[2]);
        float len       = length(rescaleVec);
        if (len > 0.0)
        {
            rescale = 1.0 / len;
        }
        result *= rescale;
    }
    if (enable_normalize)
    {
        result = normalize(result);
    }
    return result;
void main()
    if (enable_draw_texture)
    {
        int vertexId        = gl_VertexID;
        mediump vec4 posDrawTexture = drawTexturePosition(vertexId);
        gl_Position = posDrawTexture;
        pos_varying = posDrawTexture;
        normal_varying = normal;
        gl_PointSize = pointsize;
#if kTexUnits >= 1
        texcoord0_varying = drawTextureTexCoord(vertexId, 0);
#endif
#if kTexUnits >= 2
        texcoord1_varying = drawTextureTexCoord(vertexId, 1);
#endif
#if kTexUnits >= 3
        texcoord2_varying = drawTextureTexCoord(vertexId, 2);
#endif
#if kTexUnits >= 4
        texcoord3_varying = drawTextureTexCoord(vertexId, 3);
#endif
    }
    else
    {
        vec4 worldPos = calcWorldPosition(pos);
        vec4 ndcPos   = calcNdcFromWorldPosition(worldPos);
        gl_Position = ndcPos;
        pos_varying = worldPos;
        normal_varying = calcNormal(normal);
        // Avoid calculating point size stuff
        // if we are not rendering points.
        if (point_rasterization)
        {
            gl_PointSize = calcPointSize(ndcPos);
        }
        else
        {
            gl_PointSize = pointsize;
        }
#if kTexUnits >= 1
        texcoord0_varying = (texture_matrix[0] * texcoord0).xyz;
#endif
#if kTexUnits >= 2
        texcoord1_varying = (texture_matrix[1] * texcoord1).xyz;
#endif
#if kTexUnits >= 3
        texcoord2_varying = (texture_matrix[2] * texcoord2).xyz;
#endif
#if kTexUnits >= 4
        texcoord3_varying = (texture_matrix[3] * texcoord3).xyz;
#endif
    }
    mediump vec4 vertex_color = color;
    if (enable_lighting)
    {
        vertex_color = doLighting(color);
    }
    vertex_color = clamp(vertex_color, vec4(0), vec4(1));
    color_varying      = vertex_color;
    color_varying_flat = vertex_color;
#version 300 es
precision highp float;
// Defines for GL constants
#define kMaxTexUnits                         4
#define kMaxClipPlanes                       6
#define kModulate                       0x2100
#define kDecal                          0x2101
#define kCombine                        0x8570
#define kReplace                        0x1E01
#define kBlend                          0x0BE2
#define kAdd                            0x0104
#define kAddSigned                      0x8574
#define kInterpolate                    0x8575
#define kSubtract                       0x84E7
#define kDot3Rgb                        0x86AE
#define kDot3Rgba                       0x86AF
#define kAlpha                          0x1906
#define kRGB                            0x1907
#define kRGBA                           0x1908
#define kLuminance                      0x1909
#define kLuminanceAlpha                 0x190A
#define kTexture                        0x1702
#define kConstant                       0x8576
#define kPrimaryColor                   0x8577
#define kPrevious                       0x8578
#define kSrcColor                       0x0300
#define kOneMinusSrcColor               0x0301
#define kSrcAlpha                       0x0302
#define kOneMinusSrcAlpha               0x0303
#define kLinear                         0x2601
#define kExp                            0x0800
#define kExp2                           0x0801
#define kNever                          0x0200
#define kLess                           0x0201
#define kEqual                          0x0202
#define kLequal                         0x0203
#define kGreater                        0x0204
#define kNotequal                       0x0205
#define kGequal                         0x0206
#define kAlways                         0x0207
#define kZero                              0x0
#define kOne                               0x1
#define kAnd                            0u
#define kAndInverted                    1u
#define kAndReverse                     2u
#define kClear                          3u
#define kCopy                           4u
#define kCopyInverted                   5u
#define kEquiv                          6u
#define kInvert                         7u
#define kNand                           8u
#define kNoop                           9u
#define kNor                            10u
#define kOr                             11u
#define kOrInverted                     12u
#define kOrReverse                      13u
#define kSet                            14u
#define kXor                            15u
// Texture units ///////////////////////////////////////////////////////////////
// These are not arrays because hw support for arrays
// of samplers is rather lacking.
uniform mediump sampler2D tex_sampler0;
uniform mediump samplerCube tex_cube_sampler0;
uniform mediump sampler2D tex_sampler1;
uniform mediump samplerCube tex_cube_sampler1;
uniform mediump sampler2D tex_sampler2;
uniform mediump samplerCube tex_cube_sampler2;
uniform mediump sampler2D tex_sampler3;
uniform mediump samplerCube tex_cube_sampler3;
uniform mediump vec4 texture_env_color[kMaxTexUnits];
uniform mediump float texture_env_rgb_scale[kMaxTexUnits];
uniform mediump float texture_env_alpha_scale[kMaxTexUnits];
// Vertex attributes////////////////////////////////////////////////////////////
in vec4 pos_varying;
in vec3 normal_varying;
in mediump vec4 color_varying;
flat in mediump vec4 color_varying_flat;
#if kTexUnits >= 1
in mediump vec3 texcoord0_varying;
#endif
#if kTexUnits >= 2
in mediump vec3 texcoord1_varying;
#endif
#if kTexUnits >= 3
in mediump vec3 texcoord2_varying;
#endif
#if kTexUnits >= 4
in mediump vec3 texcoord3_varying;
#endif
// Alpha test///////////////////////////////////////////////////////////////////
uniform mediump float alpha_test_ref;
// Fog /////////////////////////////////////////////////////////////////////////
uniform float fog_density;
uniform float fog_start;
uniform float fog_end;
uniform mediump vec4 fog_color;
// User clip plane /////////////////////////////////////////////////////////////
uniform vec4 clip_planes[kMaxClipPlanes];
// Logic Op ////////////////////////////////////////////////////////////////////
// Format is:
// - 4x4 bits depicting the bit width of each channel of color output
// - 4 bits for the op based on LogicalOperation's packing
uniform highp uint logic_op;
// Point rasterization//////////////////////////////////////////////////////////
// GL_OES_draw_texture//////////////////////////////////////////////////////////
inout mediump vec4 frag_color;
layout(noncoherent) inout mediump vec4 frag_color;
mediump vec4 applyLogicOp(mediump vec4 currentFragment)
    mediump vec4 previousFragment = frag_color;
    mediump uvec4 channelWidths = uvec4(logic_op & 0xFu,
                                        logic_op >> 4u & 0xFu,
                                        logic_op >> 8u & 0xFu,
                                        logic_op >> 12u & 0xFu);
    mediump uvec4 channelMasks = (uvec4(1) << channelWidths) - 1u;
    mediump uvec4 src = uvec4(round(currentFragment * vec4(channelMasks)));
    mediump uvec4 dst = uvec4(round(previousFragment * vec4(channelMasks)));
    mediump uvec4 result;
    switch (logic_op >> 16u & 0xFu)
    {
        case kAnd:
            result = src & dst;
            break;
        case kAndInverted:
            result = ~src & dst;
            break;
        case kAndReverse:
            result = src & ~dst;
            break;
        case kClear:
            result = uvec4(0);
            break;
        case kCopy:
            result = src;
            break;
        case kCopyInverted:
            result = ~src;
            break;
        case kEquiv:
            result = ~(src ^ dst);
            break;
        case kInvert:
            result = ~dst;
            break;
        case kNand:
            result = ~(src & dst);
            break;
        case kNoop:
            result = dst;
            break;
        case kNor:
            result = ~(src | dst);
            break;
        case kOr:
            result = src | dst;
            break;
        case kOrInverted:
            result = ~src | dst;
            break;
        case kOrReverse:
            result = src | ~dst;
            break;
        case kSet:
            result = channelMasks;
            break;
        case kXor:
            result = src ^ dst;
            break;
    }
    result &= channelMasks;
    // Avoid division by zero for formats without alpha
    channelMasks.a = max(channelMasks.a, 1u);
    return vec4(result) / vec4(channelMasks);
out mediump vec4 frag_color;
mediump vec4 applyLogicOp(mediump vec4 currentFragment)
    return currentFragment;
bool doAlphaTest(mediump vec4 currentFragment)
    bool shouldPassAlpha   = false;
    mediump float incAlpha = currentFragment.a;
    switch (alpha_func)
    {
        case kNever:
            shouldPassAlpha = false;
            break;
        case kLess:
            shouldPassAlpha = incAlpha < alpha_test_ref;
            break;
        case kLequal:
            shouldPassAlpha = incAlpha <= alpha_test_ref;
            break;
        case kEqual:
            shouldPassAlpha = incAlpha == alpha_test_ref;
            break;
        case kGequal:
            shouldPassAlpha = incAlpha >= alpha_test_ref;
            break;
        case kGreater:
            shouldPassAlpha = incAlpha > alpha_test_ref;
            break;
        case kNotequal:
            shouldPassAlpha = incAlpha != alpha_test_ref;
            break;
        case kAlways:
        default:
            shouldPassAlpha = true;
            break;
    }
    return shouldPassAlpha;
bool doClipPlaneTest()
    bool res = true;
    for (int i = 0; i < kMaxClipPlanes; i++)
    {
        if (clip_plane_enables[i])
        {
            float dist = dot(clip_planes[i].xyz, pos_varying.xyz) + clip_planes[i].w * pos_varying.w;
            res        = res && (dist >= 0.0);
        }
    }
    return res;
mediump vec4 doFog(mediump vec4 currentFragment)
    float eyeDist = -pos_varying.z / pos_varying.w;
    float f       = 1.0;
    switch (fog_mode)
    {
        case kExp:
            f = exp(-fog_density * eyeDist);
            break;
        case kExp2:
            f = exp(-(pow(fog_density * eyeDist, 2.0)));
            break;
        case kLinear:
            f = (fog_end - eyeDist) / (fog_end - fog_start);
            break;
        default:
            break;
    }
    f = clamp(f, 0.0, 1.0);
    mediump vec4 result = vec4(f * currentFragment.rgb + (1.0 - f) * fog_color.rgb, currentFragment.a);
    return result;
bool isTextureUnitEnabled(int unit)
    return enable_texture_2d[unit] || enable_texture_cube_map[unit];
mediump vec4 getTextureColor(int unit)
    mediump vec4 res;
    switch (unit)
    {
#if kTexUnits >= 1
        case 0:
            if (enable_texture_2d[0])
            {
                res = texture(tex_sampler0, texcoord0_varying.xy);
            }
            else if (enable_texture_cube_map[0])
            {
                res = texture(tex_cube_sampler0, texcoord0_varying);
            }
            break;
#endif
#if kTexUnits >= 2
        case 1:
            if (enable_texture_2d[1])
            {
                res = texture(tex_sampler1, texcoord1_varying.xy);
            }
            else if (enable_texture_cube_map[1])
            {
                res = texture(tex_cube_sampler1, texcoord1_varying);
            }
            break;
#endif
#if kTexUnits >= 3
        case 2:
            if (enable_texture_2d[2])
            {
                res = texture(tex_sampler2, texcoord2_varying.xy);
            }
            else if (enable_texture_cube_map[2])
            {
                res = texture(tex_cube_sampler2, texcoord2_varying);
            }
            break;
#endif
#if kTexUnits >= 4
        case 3:
            if (enable_texture_2d[3])
            {
                res = texture(tex_sampler3, texcoord3_varying.xy);
            }
            else if (enable_texture_cube_map[3])
            {
                // TODO: Weird stuff happens
                // res = texture(tex_cube_sampler3, texcoord3_varying);
            }
            break;
#endif
        default:
            break;
    }
    return res;
mediump vec4 getPointSpriteTextureColor(int unit)
    mediump vec4 res;
    switch (unit)
    {
        case 0:
            if (enable_texture_2d[0])
            {
                res = texture(tex_sampler0, gl_PointCoord.xy);
            }
            break;
        case 1:
            if (enable_texture_2d[1])
            {
                res = texture(tex_sampler1, gl_PointCoord.xy);
            }
            break;
        case 2:
            if (enable_texture_2d[2])
            {
                res = texture(tex_sampler2, gl_PointCoord.xy);
            }
            break;
        case 3:
            if (enable_texture_2d[3])
            {
                res = texture(tex_sampler3, gl_PointCoord.xy);
            }
            break;
        default:
            break;
    }
    return res;
mediump vec3 textureCombineSrcnOpnRgb(int srcnRgb,
                                      int opnRgb,
                                      mediump vec4 textureEnvColor,
                                      mediump vec4 vertexColor,
                                      mediump vec4 texturePrevColor,
                                      mediump vec4 textureColor)
    mediump vec3 res;
    mediump vec4 op;
    switch (srcnRgb)
    {
        case kTexture:
            op = textureColor;
            break;
        case kConstant:
            op = textureEnvColor;
            break;
        case kPrimaryColor:
            op = vertexColor;
            break;
        case kPrevious:
            op = texturePrevColor;
            break;
        default:
            op = texturePrevColor;
            break;
    }
    switch (opnRgb)
    {
        case kSrcColor:
            res = op.rgb;
            break;
        case kOneMinusSrcColor:
            res = 1.0 - op.rgb;
            break;
        case kSrcAlpha:
            res = vec3(op.a, op.a, op.a);
            break;
        case kOneMinusSrcAlpha:
            res = vec3(1.0 - op.a, 1.0 - op.a, 1.0 - op.a);
            break;
        default:
            break;
    }
    return res;
mediump float textureCombineSrcnOpnAlpha(int srcn,
                                         int opn,
                                         mediump vec4 textureEnvColor,
                                         mediump vec4 vertexColor,
                                         mediump vec4 texturePrevColor,
                                         mediump vec4 textureColor)
    mediump float res;
    mediump vec4 op;
    switch (srcn)
    {
        case kTexture:
            op = textureColor;
            break;
        case kConstant:
            op = textureEnvColor;
            break;
        case kPrimaryColor:
            op = vertexColor;
            break;
        case kPrevious:
            op = texturePrevColor;
            break;
        default:
            op = texturePrevColor;
            break;
    }
    switch (opn)
    {
        case kSrcAlpha:
            res = op.a;
            break;
        case kOneMinusSrcAlpha:
            res = 1.0 - op.a;
            break;
        default:
            break;
    }
    return res;
mediump vec4 textureCombine(int combineRgb,
                            int combineAlpha,
                            int src0Rgb,
                            int src0Alpha,
                            int src1Rgb,
                            int src1Alpha,
                            int src2Rgb,
                            int src2Alpha,
                            int op0Rgb,
                            int op0Alpha,
                            int op1Rgb,
                            int op1Alpha,
                            int op2Rgb,
                            int op2Alpha,
                            mediump vec4 textureEnvColor,
                            mediump float rgbScale,
                            mediump float alphaScale,
                            mediump vec4 vertexColor,
                            mediump vec4 texturePrevColor,
                            mediump vec4 textureColor)
    mediump vec3 resRgb;
    mediump float resAlpha;
    mediump vec3 arg0Rgb;
    mediump float arg0Alpha;
    mediump vec3 arg1Rgb;
    mediump float arg1Alpha;
    mediump vec3 arg2Rgb;
    mediump float arg2Alpha;
    mediump float dotVal;
    arg0Rgb   = textureCombineSrcnOpnRgb(src0Rgb, op0Rgb, textureEnvColor, vertexColor,
                                       texturePrevColor, textureColor);
    arg0Alpha = textureCombineSrcnOpnAlpha(src0Alpha, op0Alpha, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    if (combineRgb != kReplace)
    {
        arg1Rgb = textureCombineSrcnOpnRgb(src1Rgb, op1Rgb, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    }
    if (combineAlpha != kReplace)
    {
        arg1Alpha = textureCombineSrcnOpnAlpha(src1Alpha, op1Alpha, textureEnvColor, vertexColor,
                                               texturePrevColor, textureColor);
    }
    if (combineRgb == kInterpolate)
    {
        arg2Rgb = textureCombineSrcnOpnRgb(src2Rgb, op2Rgb, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    }
    if (combineAlpha == kInterpolate)
    {
        arg2Alpha = textureCombineSrcnOpnAlpha(src2Alpha, op2Alpha, textureEnvColor, vertexColor,
                                               texturePrevColor, textureColor);
    }
    switch (combineRgb)
    {
        case kReplace:
            resRgb = arg0Rgb;
            break;
        case kModulate:
            resRgb = arg0Rgb * arg1Rgb;
            break;
        case kAdd:
            resRgb = arg0Rgb + arg1Rgb;
            break;
        case kAddSigned:
            resRgb = arg0Rgb + arg1Rgb - 0.5;
            break;
        case kInterpolate:
            resRgb = arg0Rgb * arg2Rgb + arg1Rgb * (1.0 - arg2Rgb);
            break;
        case kSubtract:
            resRgb = arg0Rgb - arg1Rgb;
            break;
        default:
            break;
    }
    switch (combineAlpha)
    {
        case kReplace:
            resAlpha = arg0Alpha;
            break;
        case kModulate:
            resAlpha = arg0Alpha * arg1Alpha;
            break;
        case kAdd:
            resAlpha = arg0Alpha + arg1Alpha;
            break;
        case kAddSigned:
            resAlpha = arg0Alpha + arg1Alpha - 0.5;
            break;
        case kInterpolate:
            resAlpha = arg0Alpha * arg2Alpha + arg1Alpha * (1.0 - arg2Alpha);
            break;
        case kSubtract:
            resAlpha = arg0Alpha - arg1Alpha;
            break;
        default:
            break;
    }
    if (combineRgb == kDot3Rgb || combineRgb == kDot3Rgba)
    {
        dotVal = 4.0 * dot(arg0Rgb - 0.5, arg1Rgb - 0.5);
        if (combineRgb == kDot3Rgb)
        {
            return vec4(dotVal, dotVal, dotVal, resAlpha);
        }
        else
        {
            return vec4(dotVal, dotVal, dotVal, dotVal);
        }
    }
    else
    {
        return vec4(resRgb, resAlpha);
    }
mediump vec4 textureFunction(int unit,
                             int texFormat,
                             int envMode,
                             int combineRgb,
                             int combineAlpha,
                             int src0Rgb,
                             int src0Alpha,
                             int src1Rgb,
                             int src1Alpha,
                             int src2Rgb,
                             int src2Alpha,
                             int op0Rgb,
                             int op0Alpha,
                             int op1Rgb,
                             int op1Alpha,
                             int op2Rgb,
                             int op2Alpha,
                             mediump vec4 textureEnvColor,
                             mediump float rgbScale,
                             mediump float alphaScale,
                             mediump vec4 vertexColor,
                             mediump vec4 texturePrevColor,
                             mediump vec4 textureColor)
    if (!isTextureUnitEnabled(unit))
    {
        return texturePrevColor;
    }
    mediump vec4 res;
    switch (envMode)
    {
        case kReplace:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a;
                    break;
                case kRGBA:
                case kLuminanceAlpha:
                    res.rgba = textureColor.rgba;
                    break;
                case kRGB:
                case kLuminance:
                default:
                    res.rgb = textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kModulate:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = texturePrevColor.a * textureColor.a;
                    break;
                case kRGBA:
                case kLuminanceAlpha:
                    res.rgba = texturePrevColor.rgba * textureColor.rgba;
                    break;
                case kRGB:
                case kLuminance:
                default:
                    res.rgb = texturePrevColor.rgb * textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kDecal:
            switch (texFormat)
            {
                case kRGB:
                    res.rgb = textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
                case kRGBA:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.a) +
                              textureColor.rgb * textureColor.a;
                    res.a = texturePrevColor.a;
                    break;
                case kAlpha:
                case kLuminance:
                case kLuminanceAlpha:
                default:
                    res.rgb = texturePrevColor.rgb * textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kBlend:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
                case kLuminance:
                case kRGB:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.rgb) +
                              textureEnvColor.rgb * textureColor.rgb;
                    res.a = texturePrevColor.a;
                    break;
                case kLuminanceAlpha:
                case kRGBA:
                default:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.rgb) +
                              textureEnvColor.rgb * textureColor.rgb;
                    res.a = textureColor.a * texturePrevColor.a;
                    break;
            }
            break;
        case kAdd:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
                case kLuminance:
                case kRGB:
                    res.rgb = texturePrevColor.rgb + textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
                case kLuminanceAlpha:
                case kRGBA:
                default:
                    res.rgb = texturePrevColor.rgb + textureColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
            }
            break;
        case kCombine:
            res = textureCombine(combineRgb, combineAlpha, src0Rgb, src0Alpha, src1Rgb, src1Alpha,
                                 src2Rgb, src2Alpha, op0Rgb, op0Alpha, op1Rgb, op1Alpha, op2Rgb,
                                 op2Alpha, textureEnvColor, rgbScale, alphaScale, vertexColor,
                                 texturePrevColor, textureColor);
            res.rgb *= rgbScale;
            res.a *= alphaScale;
            break;
        default:
            break;
    }
    return clamp(res, 0.0, 1.0);
void main()
    if (enable_clip_planes && !enable_draw_texture)
    {
        if (!doClipPlaneTest())
        {
            discard;
        }
    }
    mediump vec4 vertex_color;
    if (shade_model_flat)
    {
        vertex_color = color_varying_flat;
    }
    else
    {
        vertex_color = color_varying;
    }
    mediump vec4 currentFragment = vertex_color;
    mediump vec4 texturePrevColor = currentFragment;
    for (int i = 0; i < kTexUnits; i++)
    {
        mediump vec4 textureColor;
        if (point_rasterization && point_sprite_enabled &&
            point_sprite_coord_replace[i]) {
            textureColor = getPointSpriteTextureColor(i);
        } else {
            textureColor = getTextureColor(i);
        }
        currentFragment = textureFunction(
            i, texture_format[i], texture_env_mode[i], combine_rgb[i], combine_alpha[i],
            src0_rgb[i], src0_alpha[i], src1_rgb[i], src1_alpha[i], src2_rgb[i], src2_alpha[i],
            op0_rgb[i], op0_alpha[i], op1_rgb[i], op1_alpha[i], op2_rgb[i], op2_alpha[i],
            texture_env_color[i], texture_env_rgb_scale[i], texture_env_alpha_scale[i],
            vertex_color, texturePrevColor, textureColor);
        texturePrevColor = currentFragment;
    }
    if (enable_fog)
    {
        currentFragment = doFog(currentFragment);
    }
    if (enable_alpha_test && !doAlphaTest(currentFragment))
    {
        discard;
    }
    frag_color = applyLogicOp(currentFragment);
 !"#$%&&&&'()*&&+,-./012&3
789:;<=>?&@ABCDE&FGHIJKLMNOPQR
"CMd{
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
ANGLE
Ga==
.M;vT
aa*aaaaaaaaaaM*aaaaaaa;;aaaa
222222?chrN
??????
?????
######
     ###
15>G
.eB5
%-5=EMU]emu}
oooo
"*2:BILT_g
'/7?GOW_gow
 "$)+
 __unassigned_attribute__
angleUniforms
ANGLE_METAL_PRINT_MSL_ENABLE
ANGLE_MSL_VERSION_MAJOR
ANGLE_MSL_VERSION_MINOR
ANGLE
"+O6
$).38=BGL
QV[`ej
                    
 %).26;@DHLPUZ^bglpty~
16;;;;D
HHHHH
HHHH!%*/49
7777
')%%%%%+-/%%%%%135%%%%%79;
-/135
LT\'*-{0{{
{{{{'{{{{{
6{{9{{={@G{{{{{{{{{{{{
QT{{Y\_
beh{{{{{
knq{x{{{
{{{{{{
,/2_gg
ggDDggpg
,,,,7777
I/258;>ADGQ6
!$'*-4!
/////////0
 "$MO'+
!&+05:?
!&+05:?
#*('
 !%&'()*+,-./01234
,6@J
9@@@@@
DKKKKK
OY\1_be
S>X@
fims
UUUUUUUUUUU,/258;
777#
> A"
"&7K]T
lorux
.38=BG
NQ^k
    
%*/4L
!%04;
!%)4?JU`kw
 KO$S(W,0`48<d
 "$&(*,.024_68:<>@B_DFHJLNPR^TV
Y[`cfim
!$'*-
ANGLEUniformBlock
ANGLEUniforms
ANGLEAtomicCounters
$-6cx
QZ?H
10Dx4
SUWY[]_acegiNkmoNqsNuwy{}
r?tv?xz???|~?
 "$&(*,.02468:<>@BDF
RTVXZ\^
bdfhj
nprtv
2222222222
467222722746
)*666*66*
))66*66
)*666**66*666**66
!$'*-03
XXXXXXXXXXXXXXXXXXXXXXXXXXXXX
00000
"2CM
'tttt''
JJJJ!!
ek88Sf

<>@BDFHJLNPRT
VXZ\^`bdfh
3333).
PV==00
      
1:CL*U
DDDDD?
+2++FO
[[[[[U
!++5
$$$$$$$.GVbt
75RRRRRRRRRRRRRRRRR8
'''''"
$;Wx
cast
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/common/android_util.cpp
GLInternalFormatToNativePixelFormat
Unknown internalFormat: 
. Treating as 0
2.1.20348 git hash: e5671e16b83f
35c6f5eb4d05c0f68ff77d74edf80ecb
ASTC CPU decomp not available
as_type
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/BlitGL.cpp
copyImageToLUMAWorkaroundTexture
mFunctions->texImage2D(ToGLenum(target), static_cast<GLint>(level), internalFormat, sourceArea.width, sourceArea.height, 0, format, readType, nullptr)
copySubImageToLUMAWorkaroundTexture
mFunctions->copyTexImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, sourceArea.x, sourceArea.y, sourceArea.width, sourceArea.height, 0)
mFunctions->texImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), readType, nullptr)
blitColorBufferWithShader
mFunctions->copyTexImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, inBoundsSource.x, inBoundsSource.y, inBoundsSource.width, inBoundsSource.height, 0)
copySubTextureCPUReadback
mFunctions->texImage2D(ToGLenum(scratchTextureType), 0, texImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
Failed to allocate host memory
generateSRGBMipmap
mFunctions->generateMipmap(ToGLenum(sourceTarget))
a_texcoord
attribute
varying
texture2D
texture
#version 
 vec2 
uniform vec2 u_scale;
uniform vec2 u_offset;
 vec2 v_texcoord;
void main()
    gl_Position = vec4((
 * 2.0) - 1.0, 0.0, 1.0);
    v_texcoord = 
 * u_scale + u_offset;
usampler2D
sampler2D
samplerExternalOES
sampler2DRect
uvec4
#extension GL_OES_EGL_image_external : require
GL_ARB_texture_rectangle
#extension GL_ARB_texture_rectangle : require
outputUint
gl_FragColor
outputFloat
precision highp float;
uniform 
 u_source_texture;
uniform bool u_multiply_alpha;
uniform bool u_unmultiply_alpha;
vec2(textureSize(u_source_texture))
vec2(1.0)
    if (clamp(v_texcoord, vec2(0.0), 
) != v_texcoord)
    {
        discard;
    }
    
 color = 
(u_source_texture, v_texcoord);
    if (u_multiply_alpha)
        color.xyz = color.xyz * color.a;
    if (u_unmultiply_alpha && color.a != 0.0)
         color.xyz = color.xyz / color.a;
    color = color * 
(color);
u_source_texture
u_scale
u_offset
u_multiply_alpha
u_unmultiply_alpha
Failed to compile internal blit shader.
CheckCompileStatus
Failed to link internal blit program.
CheckLinkStatus
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/BlobCache.cpp
CompressBlobCacheData
Failed to allocate memory for compression
Failed to compress cache data: 
DecompressBlobCacheData
Failed to allocate memory for decompression
Failed to decompress data: 
Failed to allocate memory for binary blob
Binary blob no longer available in cache (removed by a thread?)
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Buffer.cpp
bufferDataImpl
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/BufferGL.cpp
setData
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/BufferMtl.mm
setDataImpl
BufferMtl=%p(%lu)
setSubDataImpl
_emu
int abs_emu(int x) { return x * sign(x); }
bool isnan_emu(float x) { return (x > 0.0 || x < 0.0) ? false : x != 0.0; }
bvec2 isnan_emu(vec2 x)
    bvec2 isnan;
    for (int i = 0; i < 2; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bvec3 isnan_emu(vec3 x)
    bvec3 isnan;
    for (int i = 0; i < 3; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bvec4 isnan_emu(vec4 x)
    bvec4 isnan;
    for (int i = 0; i < 4; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
emu_precision float atan_emu(emu_precision float y, emu_precision float x)
    if (x > 0.0) return atan(y / x);
    else if (x < 0.0 && y >= 0.0) return atan(y / x) + 3.14159265;
    else if (x < 0.0 && y < 0.0) return atan(y / x) - 3.14159265;
    else return 1.57079632 * sign(y);
emu_precision vec
 atan_emu(emu_precision vec
 y, emu_precision vec
    return vec
atan_emu(y[
], x[
uint packUnorm2x16_emu(vec2 v)
    int x = int(round(clamp(v.x, 0.0, 1.0) * 65535.0));
    int y = int(round(clamp(v.y, 0.0, 1.0) * 65535.0));
    return uint((y << 16) | (x & 0xFFFF));
vec2 unpackUnorm2x16_emu(uint u)
    float x = float(u & 0xFFFFu) / 65535.0;
    float y = float(u >> 16) / 65535.0;
    return vec2(x, y);
uint packSnorm2x16_emu(vec2 v)
    #if defined(GL_ARB_shading_language_packing)
        return packSnorm2x16(v);
    #else
        int x = int(round(clamp(v.x, -1.0, 1.0) * 32767.0));
        int y = int(round(clamp(v.y, -1.0, 1.0) * 32767.0));
        return uint((y << 16) | (x & 0xFFFF));
    #endif
#if !defined(GL_ARB_shading_language_packing)
    float fromSnorm(uint x)
    {
        int xi = (int(x) & 0x7FFF) - (int(x) & 0x8000);
        return clamp(float(xi) / 32767.0, -1.0, 1.0);
    }
#endif
vec2 unpackSnorm2x16_emu(uint u)
    #if defined(GL_ARB_shading_language_packing)
        return unpackSnorm2x16(u);
    #else
        uint y = (u >> 16);
        uint x = u;
        return vec2(fromSnorm(x), fromSnorm(y));
    #endif
#if !defined(GL_ARB_shading_language_packing)
    uint f32tof16(float val)
    {
        uint f32 = floatBitsToUint(val);
        uint f16 = 0u;
        uint sign = (f32 >> 16) & 0x8000u;
        int exponent = int((f32 >> 23) & 0xFFu) - 127;
        uint mantissa = f32 & 0x007FFFFFu;
        if (exponent == 128)
        {
            // Infinity or NaN
            // NaN bits that are masked out by 0x3FF get discarded.
            // This can turn some NaNs to infinity, but this is allowed by the spec.
            f16 = sign | (0x1Fu << 10);
            f16 |= (mantissa & 0x3FFu);
        }
        else if (exponent > 15)
        {
            // Overflow - flush to Infinity
            f16 = sign | (0x1Fu << 10);
        }
        else if (exponent > -15)
        {
            // Representable value
            exponent += 15;
            mantissa >>= 13;
            f16 = sign | uint(exponent << 10) | mantissa;
        }
        else
        {
            f16 = sign;
        }
        return f16;
    }
#endif
uint packHalf2x16_emu(vec2 v)
    #if defined(GL_ARB_shading_language_packing)
        return packHalf2x16(v);
    #else
        uint x = f32tof16(v.x);
        uint y = f32tof16(v.y);
        return (y << 16) | x;
    #endif
#if !defined(GL_ARB_shading_language_packing)
    float f16tof32(uint val)
    {
        uint sign = (val & 0x8000u) << 16;
        int exponent = int((val & 0x7C00u) >> 10);
        uint mantissa = val & 0x03FFu;
        float f32 = 0.0;
        if(exponent == 0)
        {
            if (mantissa != 0u)
            {
                const float scale = 1.0 / (1 << 24);
                f32 = scale * mantissa;
            }
        }
        else if (exponent == 31)
        {
            return uintBitsToFloat(sign | 0x7F800000u | mantissa);
        }
        else
        {
            exponent -= 15;
            float scale;
            if(exponent < 0)
            {
                // The negative unary operator is buggy on OSX.
                // Work around this by using abs instead.
                scale = 1.0 / (1 << abs(exponent));
            }
            else
            {
                scale = 1 << exponent;
            }
            float decimal = 1.0 + float(mantissa) / float(1 << 10);
            f32 = scale * decimal;
        }
        if (sign != 0u)
        {
            f32 = -f32;
        }
        return f32;
    }
#endif
vec2 unpackHalf2x16_emu(uint u)
    #if defined(GL_ARB_shading_language_packing)
        return unpackHalf2x16(u);
    #else
        uint y = (u >> 16);
        uint x = u & 0xFFFFu;
        return vec2(f16tof32(x), f16tof32(y));
    #endif
Undefined function '
()' used in the following call chain:
Recursive function call in the following call chain:
 -> 
EGL_EXT_create_context_robustness
EGL_ANGLE_d3d_share_handle_client_buffer
EGL_ANGLE_d3d_texture_client_buffer
EGL_ANGLE_surface_d3d_texture_2d_share_handle
EGL_ANGLE_query_surface_pointer
EGL_ANGLE_window_fixed_size
EGL_ANGLE_keyed_mutex
EGL_ANGLE_surface_orientation
EGL_ANGLE_direct_composition
EGL_ANGLE_windows_ui_composition
EGL_NV_post_sub_buffer
EGL_KHR_create_context
EGL_KHR_image
EGL_KHR_image_base
EGL_KHR_image_pixmap
EGL_EXT_image_gl_colorspace
EGL_KHR_gl_colorspace
EGL_EXT_gl_colorspace_scrgb
EGL_EXT_gl_colorspace_scrgb_linear
EGL_EXT_gl_colorspace_display_p3
EGL_EXT_gl_colorspace_display_p3_linear
EGL_EXT_gl_colorspace_display_p3_passthrough
EGL_ANGLE_colorspace_attribute_passthrough
EGL_KHR_gl_texture_2D_image
EGL_KHR_gl_texture_cubemap_image
EGL_KHR_gl_texture_3D_image
EGL_KHR_gl_renderbuffer_image
EGL_KHR_get_all_proc_addresses
EGL_KHR_stream
EGL_KHR_stream_consumer_gltexture
EGL_NV_stream_consumer_gltexture_yuv
EGL_KHR_fence_sync
EGL_KHR_wait_sync
EGL_ANGLE_stream_producer_d3d_texture
EGL_ANGLE_create_context_webgl_compatibility
EGL_CHROMIUM_create_context_bind_generates_resource
EGL_CHROMIUM_sync_control
EGL_ANGLE_sync_control_rate
EGL_KHR_swap_buffers_with_damage
EGL_EXT_pixel_format_float
EGL_KHR_surfaceless_context
EGL_ANGLE_display_texture_share_group
EGL_ANGLE_display_semaphore_share_group
EGL_ANGLE_create_context_client_arrays
EGL_ANGLE_program_cache_control
EGL_ANGLE_robust_resource_initialization
EGL_ANGLE_iosurface_client_buffer
EGL_ANGLE_metal_texture_client_buffer
EGL_ANGLE_create_context_extensions_enabled
EGL_ANDROID_presentation_time
EGL_ANDROID_blob_cache
EGL_ANDROID_framebuffer_target
EGL_ANDROID_image_native_buffer
EGL_ANDROID_get_frame_timestamps
EGL_ANGLE_timestamp_surface_attribute
EGL_ANDROID_recordable
EGL_ANGLE_power_preference
EGL_ANGLE_wait_until_work_scheduled
EGL_ANGLE_image_d3d11_texture
EGL_ANDROID_create_native_client_buffer
EGL_ANDROID_get_native_client_buffer
EGL_ANDROID_native_fence_sync
EGL_ANGLE_create_context_backwards_compatible
EGL_KHR_no_config_context
EGL_IMG_context_priority
EGL_KHR_create_context_no_error
EGL_EXT_image_dma_buf_import
EGL_EXT_image_dma_buf_import_modifiers
EGL_NOK_texture_from_pixmap
EGL_NV_robustness_video_memory_purge
EGL_KHR_reusable_sync
EGL_ANGLE_external_context_and_surface
EGL_EXT_buffer_age
EGL_KHR_mutable_render_buffer
EGL_EXT_protected_content
EGL_ANGLE_create_surface_swap_interval
EGL_ANGLE_context_virtualization
EGL_KHR_lock_surface3
EGL_ANGLE_vulkan_image
EGL_ANGLE_metal_create_context_ownership_identity
EGL_KHR_partial_update
EGL_ANGLE_metal_shared_event_sync
EGL_ANGLE_device_d3d
EGL_ANGLE_device_cgl
EGL_ANGLE_device_eagl
EGL_ANGLE_device_metal
EGL_ANGLE_device_vulkan
EGL_EXT_device_drm
EGL_EXT_device_drm_render_node
EGL_EXT_client_extensions
EGL_EXT_device_query
EGL_EXT_platform_base
EGL_EXT_platform_device
EGL_KHR_platform_gbm
EGL_EXT_platform_wayland
EGL_ANGLE_platform_angle
EGL_ANGLE_platform_angle_d3d
EGL_ANGLE_platform_angle_d3d11on12
EGL_ANGLE_platform_angle_device_type_egl_angle
EGL_ANGLE_platform_angle_device_type_swiftshader
EGL_ANGLE_platform_angle_opengl
EGL_ANGLE_platform_angle_null
EGL_ANGLE_platform_angle_vulkan
EGL_ANGLE_platform_angle_metal
EGL_ANGLE_platform_device_context_volatile_eagl
EGL_ANGLE_platform_device_context_volatile_cgl
EGL_ANGLE_platform_angle_device_id
EGL_ANGLE_device_creation
EGL_ANGLE_device_creation_d3d11
EGL_ANGLE_x11_visual
EGL_ANGLE_experimental_present_path
EGL_KHR_client_get_all_proc_addresses
EGL_KHR_debug
EGL_ANGLE_feature_control
EGL_ANGLE_display_power_preference
gl_FragDepth
clamp
gl_PointSize
gl_DepthRange
near
diff
gl_NumSamples
gl_PerVertex
gl_in
unsupported shader version
Compute shader is not supported in this shader version.
Geometry shader is not supported in this shader version.
Tessellation shaders are not supported in this shader version.
internal compiler error translating pixel local storage
too many uniforms
gl_ClipDistance
gl_CullDistance
Shader parsing failed (mTreeRoot == nullptr)
Unsized global array type: 
angle_DrawID
gl_DrawID
angle_BaseVertex
gl_BaseVertex
angle_BaseInstance
gl_BaseInstance
:MaxVertexAttribs:
:MaxVertexUniformVectors:
:MaxVaryingVectors:
:MaxVertexTextureImageUnits:
:MaxCombinedTextureImageUnits:
:MaxTextureImageUnits:
:MaxFragmentUniformVectors:
:MaxDrawBuffers:
:OES_standard_derivatives:
:OES_EGL_image_external:
:OES_EGL_image_external_essl3:
:NV_EGL_stream_consumer_external:
:ARB_texture_rectangle:
:EXT_draw_buffers:
:FragmentPrecisionHigh:
:MaxExpressionComplexity:
:MaxCallStackDepth:
:MaxFunctionParameters:
:EXT_blend_func_extended:
:EXT_frag_depth:
:EXT_primitive_bounding_box:
:OES_primitive_bounding_box:
:EXT_separate_shader_objects:
:EXT_shader_texture_lod:
:EXT_shader_framebuffer_fetch:
:EXT_shader_framebuffer_fetch_non_coherent:
:NV_shader_framebuffer_fetch:
:ARM_shader_framebuffer_fetch:
:OVR_multiview2:
:OVR_multiview:
:EXT_YUV_target:
:EXT_geometry_shader:
:OES_geometry_shader:
:OES_shader_io_blocks:
:EXT_shader_io_blocks:
:EXT_gpu_shader5:
:OES_texture_3D:
:MaxVertexOutputVectors:
:MaxFragmentInputVectors:
:MinProgramTexelOffset:
:MaxProgramTexelOffset:
:MaxDualSourceDrawBuffers:
:MaxViewsOVR:
:NV_draw_buffers:
:ANGLE_multi_draw:
:ANGLE_base_vertex_base_instance_shader_builtin:
:APPLE_clip_distance:
:OES_texture_cube_map_array:
:EXT_texture_cube_map_array:
:EXT_shadow_samplers:
:OES_shader_multisample_interpolation:
:OES_shader_image_atomic:
:EXT_tessellation_shader:
:OES_texture_buffer:
:EXT_texture_buffer:
:OES_sample_variables:
:EXT_clip_cull_distance:
:ANGLE_clip_cull_distance:
:MinProgramTextureGatherOffset:
:MaxProgramTextureGatherOffset:
:MaxImageUnits:
:MaxSamples:
:MaxVertexImageUniforms:
:MaxFragmentImageUniforms:
:MaxComputeImageUniforms:
:MaxCombinedImageUniforms:
:MaxCombinedShaderOutputResources:
:MaxComputeWorkGroupCountX:
:MaxComputeWorkGroupCountY:
:MaxComputeWorkGroupCountZ:
:MaxComputeWorkGroupSizeX:
:MaxComputeWorkGroupSizeY:
:MaxComputeWorkGroupSizeZ:
:MaxComputeUniformComponents:
:MaxComputeTextureImageUnits:
:MaxComputeAtomicCounters:
:MaxComputeAtomicCounterBuffers:
:MaxVertexAtomicCounters:
:MaxFragmentAtomicCounters:
:MaxCombinedAtomicCounters:
:MaxAtomicCounterBindings:
:MaxVertexAtomicCounterBuffers:
:MaxFragmentAtomicCounterBuffers:
:MaxCombinedAtomicCounterBuffers:
:MaxAtomicCounterBufferSize:
:MaxGeometryUniformComponents:
:MaxGeometryUniformBlocks:
:MaxGeometryInputComponents:
:MaxGeometryOutputComponents:
:MaxGeometryOutputVertices:
:MaxGeometryTotalOutputComponents:
:MaxGeometryTextureImageUnits:
:MaxGeometryAtomicCounterBuffers:
:MaxGeometryAtomicCounters:
:MaxGeometryShaderStorageBlocks:
:MaxGeometryShaderInvocations:
:MaxGeometryImageUniforms:
:MaxClipDistances
:MaxCullDistances
:MaxCombinedClipAndCullDistances
:MaxTessControlInputComponents:
:MaxTessControlOutputComponents:
:MaxTessControlTextureImageUnits:
:MaxTessControlUniformComponents:
:MaxTessControlTotalOutputComponents:
:MaxTessControlImageUniforms:
:MaxTessControlAtomicCounters:
:MaxTessControlAtomicCounterBuffers:
:MaxTessPatchComponents:
:MaxPatchVertices:
:MaxTessGenLevel:
:MaxTessEvaluationInputComponents:
:MaxTessEvaluationOutputComponents:
:MaxTessEvaluationTextureImageUnits:
:MaxTessEvaluationUniformComponents:
:MaxTessEvaluationImageUniforms:
:MaxTessEvaluationAtomicCounters:
:MaxTessEvaluationAtomicCounterBuffers:
Call stack too deep (larger than 
) with the following call chain: 
Missing main()
Expression too complex.
Function has too many parameters.
gl_Position
cannot use both gl_FragData and gl_FragColor
cannot use both output variable sets (gl_FragData, gl_SecondaryFragDataEXT) and (gl_FragColor, gl_SecondaryFragColorEXT)
1.2.11
Undefined shift (operand out of range)
Constant folded undefined addition generated NaN
Constant folded addition overflowed to infinity
Constant folded undefined subtraction generated NaN
Constant folded subtraction overflowed to infinity
Constant folded undefined multiplication generated NaN
Constant folded multiplication overflowed to infinity
native context creation failed
ANGLE (
OpenGL ES 
.0 (ANGLE 
OpenGL ES GLSL ES 
OpenGL GLSL 
0 (ANGLE 
GL_OVR_multiview2
GL_OVR_multiview
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Context.cpp
initCaps
Limiting compressed format support.
Limit some features because 
FrameCapture is enabled
FrameCapture limits were forced
Disabling GL_OES_get_program_binary for trace portability
disable_program_binary
Limiting image unit count to 
Setting uniform buffer offset alignment to 
Setting texture buffer offset alignment to 
Disabling GL_EXT_map_buffer_range and GL_OES_mapbuffer during capture, which are not supported on some native drivers
Disabling GL_CHROMIUM_bind_uniform_location during capture, which is not supported on native drivers
Disabling GL_NV_shader_noperspective_interpolation during capture, which is not supported on some native drivers
Disabling GL_NV_framebuffer_blit during capture, which is not supported on some native drivers
Limiting draw buffer count to 
Enabling validation to prevent invalid calls from being captured. This effectively disables GL_KHR_no_error and enables GL_ANGLE_robust_client_memory.
Disabling GL_OES_depth32 during capture, which is not widely supported on mobile
Limiting max atomic counter buffer bindings to 
Limiting max shader storage buffer bindings to 
Limiting GL_MAX_SAMPLES to 
BlitFramebuffer called for non-existing buffers
Clear called for non-existing buffers
Error: 
, in 
v8@?0
Program pipeline link failed
prepareForDispatch
src/libANGLE/ProgramPipeline.h
resolveLink
ProgramPipeline link failed
Internal error: 
IncompleteTexture
This set of render targets requires 
 bytes of pixel storage. This device supports 
 bytes.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ContextMtl.mm
getRenderPassCommandEncoder
setupDraw
Draw call is unusable - please report a bug on bugs.webkit.org
handleDirtyRenderPass
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Debug.cpp
insertMessage
 (this message will no longer repeat)
EGL 
error
deprecated behavior
undefined behavior
portability
performance
marker
start of group
end of group
other message
HIGH
MEDIUM
NOTIFICATION
CRITICAL
ERROR
WARNING
INFO
EVENT
WARN
FATAL
ViewID_OVR
InstanceID
multiviewBaseViewLayerIndex
gl_out
initGlobals
' : 
internal error
out of memory
invalid character
invalid number
integer overflow
float overflow
token too long
invalid expression
division by zero
unexpected end of file found in comment
unexpected token
invalid directive name
macro name is reserved
macro redefined
predefined macro redefined
predefined macro undefined
unterminated macro invocation
macro undefined while being invoked
Not enough arguments for macro
Too many arguments for macro
duplicate macro parameter name
macro invocation chain too deep
unexpected #endif found without a matching #if
unexpected #else found without a matching #if
unexpected #else found after another #else
unexpected #elif found without a matching #if
unexpected #elif found after #else
unexpected end of file found in conditional block
invalid extension name
invalid extension behavior
invalid extension directive
invalid version number
invalid version directive
#version directive must occur before anything else, except for comments and white space
#version directive must occur on the first line of the shader
invalid line number
invalid file number
invalid line directive
extension directive must occur before any non-preprocessor tokens in ESSL1
extension directive must occur before any non-preprocessor tokens in ESSL3
shift exponent is negative or undefined
internal tokenizer error
unexpected end of file found in directive
unexpected token after conditional expression
unrecognized pragma
extension directive should occur before any non-preprocessor tokens
macro name with a double underscore is reserved - unintented behavior is possible
invariant
#pragma STDGL invariant(all) can not be used in fragment shader
invalid pragma value - 'on' or 'off' expected
behavior invalid
extension cannot have 'require' behavior
extension cannot have 'enable' behavior
GL_OVR_multiview2
GL_OVR_multiview
GL_ANDROID_extension_pack_es31a
GL_EXT_gpu_shader5
GL_EXT_texture_buffer
GL_EXT_texture_cube_map_array
GL_OES_sample_variables
GL_OES_shader_multisample_interpolation
GL_OES_shader_image_atomic
GL_OES_texture_storage_multisample_2d_array
GL_EXT_geometry_shader
GL_EXT_tessellation_shader
GL_EXT_shader_io_blocks
GL_EXT_clip_cull_distance
GL_ANGLE_clip_cull_distance
extension can be enabled on greater than ESSL 300
GL_APPLE_clip_distance
extension is not supported
client/version number not supported
__VERSION__
extension
GL_EXT_base_instance
glDrawArraysInstancedBaseInstanceEXT
glDrawElementsInstancedBaseInstanceEXT
glDrawElementsInstancedBaseVertexBaseInstanceEXT
GL_EXT_blend_func_extended
glBindFragDataLocationEXT
glBindFragDataLocationIndexedEXT
glGetFragDataIndexEXT
glGetProgramResourceLocationIndexEXT
GL_EXT_buffer_storage
glBufferStorageEXT
GL_EXT_clear_texture
glClearTexImageEXT
glClearTexSubImageEXT
GL_EXT_clip_control
glClipControlEXT
GL_EXT_copy_image
glCopyImageSubDataEXT
GL_EXT_discard_framebuffer
glDiscardFramebufferEXT
GL_EXT_disjoint_timer_query
glBeginQueryEXT
glDeleteQueriesEXT
glEndQueryEXT
glGenQueriesEXT
glGetInteger64vEXT
glGetQueryObjecti64vEXT
glGetQueryObjectivEXT
glGetQueryObjectui64vEXT
glGetQueryObjectuivEXT
glGetQueryivEXT
glIsQueryEXT
glQueryCounterEXT
GL_EXT_draw_buffers
glDrawBuffersEXT
GL_EXT_draw_buffers_indexed
glBlendEquationSeparateiEXT
glBlendEquationiEXT
glBlendFuncSeparateiEXT
glBlendFunciEXT
glColorMaskiEXT
glDisableiEXT
glEnableiEXT
glIsEnablediEXT
GL_EXT_draw_elements_base_vertex
glDrawElementsBaseVertexEXT
glDrawElementsInstancedBaseVertexEXT
glDrawRangeElementsBaseVertexEXT
glMultiDrawElementsBaseVertexEXT
GL_EXT_draw_transform_feedback
glDrawTransformFeedbackEXT
glDrawTransformFeedbackInstancedEXT
glFramebufferTextureEXT
GL_EXT_instanced_arrays
glVertexAttribDivisorEXT
GL_EXT_map_buffer_range
glFlushMappedBufferRangeEXT
glMapBufferRangeEXT
GL_EXT_multi_draw_indirect
glMultiDrawArraysIndirectEXT
glMultiDrawElementsIndirectEXT
GL_EXT_multisampled_render_to_texture
glFramebufferTexture2DMultisampleEXT
glRenderbufferStorageMultisampleEXT
GL_EXT_multiview_draw_buffers
glGetIntegeri_vEXT
GL_EXT_occlusion_query_boolean
GL_EXT_primitive_bounding_box
glPrimitiveBoundingBoxEXT
GL_EXT_robustness
glGetGraphicsResetStatusEXT
glGetnUniformfvEXT
glGetnUniformivEXT
glReadnPixelsEXT
glPatchParameteriEXT
GL_EXT_texture_border_clamp
glGetSamplerParameterIivEXT
glGetSamplerParameterIuivEXT
glGetTexParameterIivEXT
glGetTexParameterIuivEXT
glSamplerParameterIivEXT
glSamplerParameterIuivEXT
glTexParameterIivEXT
glTexParameterIuivEXT
glTexBufferEXT
glTexBufferRangeEXT
GL_EXT_texture_view
glTextureViewEXT
GL_IMG_multisampled_render_to_texture
glFramebufferTexture2DMultisampleIMG
glRenderbufferStorageMultisampleIMG
GL_KHR_debug
glDebugMessageCallbackKHR
glDebugMessageControlKHR
glDebugMessageInsertKHR
glGetDebugMessageLogKHR
glGetObjectLabelKHR
glGetObjectPtrLabelKHR
glGetPointervKHR
glObjectLabelKHR
glObjectPtrLabelKHR
glPopDebugGroupKHR
glPushDebugGroupKHR
GL_KHR_robustness
glGetGraphicsResetStatusKHR
glGetnUniformfvKHR
glGetnUniformivKHR
glGetnUniformuivKHR
glReadnPixelsKHR
GL_NV_framebuffer_blit
glBlitFramebufferNV
GL_OES_EGL_image
glEGLImageTargetRenderbufferStorageOES
glEGLImageTargetTexture2DOES
GL_OES_copy_image
glCopyImageSubDataOES
GL_OES_draw_buffers_indexed
glBlendEquationSeparateiOES
glBlendEquationiOES
glBlendFuncSeparateiOES
glBlendFunciOES
glColorMaskiOES
glDisableiOES
glEnableiOES
glIsEnablediOES
GL_OES_draw_elements_base_vertex
glDrawElementsBaseVertexOES
glDrawElementsInstancedBaseVertexOES
glDrawRangeElementsBaseVertexOES
GL_OES_geometry_shader
glFramebufferTextureOES
GL_OES_get_program_binary
glGetProgramBinaryOES
glProgramBinaryOES
GL_OES_mapbuffer
glGetBufferPointervOES
glMapBufferOES
glUnmapBufferOES
GL_OES_primitive_bounding_box
glPrimitiveBoundingBoxOES
GL_OES_sample_shading
glMinSampleShadingOES
GL_OES_tessellation_shader
glPatchParameteriOES
GL_OES_texture_3D
glCompressedTexImage3DOES
glCompressedTexSubImage3DOES
glCopyTexSubImage3DOES
glFramebufferTexture3DOES
glTexImage3DOES
glTexSubImage3DOES
GL_OES_texture_border_clamp
glGetSamplerParameterIivOES
glGetSamplerParameterIuivOES
glGetTexParameterIivOES
glGetTexParameterIuivOES
glSamplerParameterIivOES
glSamplerParameterIuivOES
glTexParameterIivOES
glTexParameterIuivOES
GL_OES_texture_buffer
glTexBufferOES
glTexBufferRangeOES
glTexStorage3DMultisampleOES
GL_OES_texture_view
glTextureViewOES
GL_OES_vertex_array_object
glBindVertexArrayOES
glDeleteVertexArraysOES
glGenVertexArraysOES
glIsVertexArrayOES
GL_OES_viewport_array
glGetFloati_vOES
glScissorArrayvOES
glScissorIndexedOES
glScissorIndexedvOES
glViewportArrayvOES
glViewportIndexedfOES
glViewportIndexedfvOES
glActiveTexture
glAttachShader
glBindAttribLocation
glBindBuffer
glBindFramebuffer
glBindRenderbuffer
glBindTexture
glBlendColor
glBlendEquation
glBlendEquationSeparate
glBlendFunc
glBlendFuncSeparate
glBufferData
glBufferSubData
glCheckFramebufferStatus
glClear
glClearColor
glClearDepthf
glClearStencil
glColorMask
glCompileShader
glCompressedTexImage2D
glCompressedTexSubImage2D
glCopyTexImage2D
glCopyTexSubImage2D
glCreateProgram
glCreateShader
glCullFace
glDeleteBuffers
glDeleteFramebuffers
glDeleteProgram
glDeleteRenderbuffers
glDeleteShader
glDeleteTextures
glDepthFunc
glDepthMask
glDepthRangef
glDetachShader
glDisable
glDisableVertexAttribArray
glDrawArrays
glDrawElements
glEnable
glEnableVertexAttribArray
glFinish
glFlush
glFramebufferRenderbuffer
glFramebufferTexture2D
glFrontFace
glGenBuffers
glGenFramebuffers
glGenRenderbuffers
glGenTextures
glGenerateMipmap
glGetActiveAttrib
glGetActiveUniform
glGetAttachedShaders
glGetAttribLocation
glGetBooleanv
glGetBufferParameteriv
glGetError
glGetFloatv
glGetFramebufferAttachmentParameteriv
glGetIntegerv
glGetProgramInfoLog
glGetProgramiv
glGetRenderbufferParameteriv
glGetShaderInfoLog
glGetShaderPrecisionFormat
glGetShaderSource
glGetShaderiv
glGetString
glGetTexParameterfv
glGetTexParameteriv
glGetUniformLocation
glGetUniformfv
glGetUniformiv
glGetVertexAttribPointerv
glGetVertexAttribfv
glGetVertexAttribiv
glHint
glIsBuffer
glIsEnabled
glIsFramebuffer
glIsProgram
glIsRenderbuffer
glIsShader
glIsTexture
glLineWidth
glLinkProgram
glPixelStorei
glPolygonOffset
glReadPixels
glReleaseShaderCompiler
glRenderbufferStorage
glSampleCoverage
glScissor
glShaderBinary
glShaderSource
glStencilFunc
glStencilFuncSeparate
glStencilMask
glStencilMaskSeparate
glStencilOp
glStencilOpSeparate
glTexImage2D
glTexParameterf
glTexParameterfv
glTexParameteri
glTexParameteriv
glTexSubImage2D
glUniform1f
glUniform1fv
glUniform1i
glUniform1iv
glUniform2f
glUniform2fv
glUniform2i
glUniform2iv
glUniform3f
glUniform3fv
glUniform3i
glUniform3iv
glUniform4f
glUniform4fv
glUniform4i
glUniform4iv
glUniformMatrix2fv
glUniformMatrix3fv
glUniformMatrix4fv
glUseProgram
glValidateProgram
glVertexAttrib1f
glVertexAttrib1fv
glVertexAttrib2f
glVertexAttrib2fv
glVertexAttrib3f
glVertexAttrib3fv
glVertexAttrib4f
glVertexAttrib4fv
glVertexAttribPointer
glViewport
glBeginQuery
glBeginTransformFeedback
glBindBufferBase
glBindBufferRange
glBindSampler
glBindTransformFeedback
glBindVertexArray
glBlitFramebuffer
glClearBufferfi
glClearBufferfv
glClearBufferiv
glClearBufferuiv
glClientWaitSync
glCompressedTexImage3D
glCompressedTexSubImage3D
glCopyBufferSubData
glCopyTexSubImage3D
glDeleteQueries
glDeleteSamplers
glDeleteSync
glDeleteTransformFeedbacks
glDeleteVertexArrays
glDrawArraysInstanced
glDrawBuffers
glDrawElementsInstanced
glDrawRangeElements
glEndQuery
glEndTransformFeedback
glFenceSync
glFlushMappedBufferRange
glFramebufferTextureLayer
glGenQueries
glGenSamplers
glGenTransformFeedbacks
glGenVertexArrays
glGetActiveUniformBlockName
glGetActiveUniformBlockiv
glGetActiveUniformsiv
glGetBufferParameteri64v
glGetBufferPointerv
glGetFragDataLocation
glGetInteger64i_v
glGetInteger64v
glGetIntegeri_v
glGetInternalformativ
glGetProgramBinary
glGetQueryObjectuiv
glGetQueryiv
glGetSamplerParameterfv
glGetSamplerParameteriv
glGetStringi
glGetSynciv
glGetTransformFeedbackVarying
glGetUniformBlockIndex
glGetUniformIndices
glGetUniformuiv
glGetVertexAttribIiv
glGetVertexAttribIuiv
glInvalidateFramebuffer
glInvalidateSubFramebuffer
glIsQuery
glIsSampler
glIsSync
glIsTransformFeedback
glIsVertexArray
glMapBufferRange
glPauseTransformFeedback
glProgramBinary
glProgramParameteri
glReadBuffer
glRenderbufferStorageMultisample
glResumeTransformFeedback
glSamplerParameterf
glSamplerParameterfv
glSamplerParameteri
glSamplerParameteriv
glTexImage3D
glTexStorage2D
glTexStorage3D
glTexSubImage3D
glTransformFeedbackVaryings
glUniform1ui
glUniform1uiv
glUniform2ui
glUniform2uiv
glUniform3ui
glUniform3uiv
glUniform4ui
glUniform4uiv
glUniformBlockBinding
glUniformMatrix2x3fv
glUniformMatrix2x4fv
glUniformMatrix3x2fv
glUniformMatrix3x4fv
glUniformMatrix4x2fv
glUniformMatrix4x3fv
glUnmapBuffer
glVertexAttribDivisor
glVertexAttribI4i
glVertexAttribI4iv
glVertexAttribI4ui
glVertexAttribI4uiv
glVertexAttribIPointer
glWaitSync
glActiveShaderProgram
glBindImageTexture
glBindProgramPipeline
glBindVertexBuffer
glCreateShaderProgramv
glDeleteProgramPipelines
glDispatchCompute
glDispatchComputeIndirect
glDrawArraysIndirect
glDrawElementsIndirect
glFramebufferParameteri
glGenProgramPipelines
glGetBooleani_v
glGetFramebufferParameteriv
glGetMultisamplefv
glGetProgramInterfaceiv
glGetProgramPipelineInfoLog
glGetProgramPipelineiv
glGetProgramResourceIndex
glGetProgramResourceLocation
glGetProgramResourceName
glGetProgramResourceiv
glGetTexLevelParameterfv
glGetTexLevelParameteriv
glIsProgramPipeline
glMemoryBarrier
glMemoryBarrierByRegion
glProgramUniform1f
glProgramUniform1fv
glProgramUniform1i
glProgramUniform1iv
glProgramUniform1ui
glProgramUniform1uiv
glProgramUniform2f
glProgramUniform2fv
glProgramUniform2i
glProgramUniform2iv
glProgramUniform2ui
glProgramUniform2uiv
glProgramUniform3f
glProgramUniform3fv
glProgramUniform3i
glProgramUniform3iv
glProgramUniform3ui
glProgramUniform3uiv
glProgramUniform4f
glProgramUniform4fv
glProgramUniform4i
glProgramUniform4iv
glProgramUniform4ui
glProgramUniform4uiv
glProgramUniformMatrix2fv
glProgramUniformMatrix2x3fv
glProgramUniformMatrix2x4fv
glProgramUniformMatrix3fv
glProgramUniformMatrix3x2fv
glProgramUniformMatrix3x4fv
glProgramUniformMatrix4fv
glProgramUniformMatrix4x2fv
glProgramUniformMatrix4x3fv
glSampleMaski
glTexStorage2DMultisample
glUseProgramStages
glValidateProgramPipeline
glVertexAttribBinding
glVertexAttribFormat
glVertexAttribIFormat
glVertexBindingDivisor
glBlendBarrier
glBlendEquationSeparatei
glBlendEquationi
glBlendFuncSeparatei
glBlendFunci
glColorMaski
glCopyImageSubData
glDebugMessageCallback
glDebugMessageControl
glDebugMessageInsert
glDisablei
glDrawElementsBaseVertex
glDrawElementsInstancedBaseVertex
glDrawRangeElementsBaseVertex
glEnablei
glFramebufferTexture
glGetDebugMessageLog
glGetGraphicsResetStatus
glGetObjectLabel
glGetObjectPtrLabel
glGetPointerv
glGetSamplerParameterIiv
glGetSamplerParameterIuiv
glGetTexParameterIiv
glGetTexParameterIuiv
glGetnUniformfv
glGetnUniformiv
glGetnUniformuiv
glIsEnabledi
glMinSampleShading
glObjectLabel
glObjectPtrLabel
glPatchParameteri
glPopDebugGroup
glPrimitiveBoundingBox
glPushDebugGroup
glReadnPixels
glSamplerParameterIiv
glSamplerParameterIuiv
glTexBuffer
glTexBufferRange
glTexParameterIiv
glTexParameterIuiv
glTexStorage3DMultisample
GL_EXT_blend_minmax
glBlendEquationEXT
GL_EXT_debug_label
glGetObjectLabelEXT
GL_EXT_debug_marker
glInsertEventMarkerEXT
glPopGroupMarkerEXT
glPushGroupMarkerEXT
GL_EXT_draw_instanced
glDrawArraysInstancedEXT
glDrawElementsInstancedEXT
GL_EXT_memory_object
glBufferStorageMemEXT
glCreateMemoryObjectsEXT
glDeleteMemoryObjectsEXT
glGetMemoryObjectParameterivEXT
glGetUnsignedBytei_vEXT
glGetUnsignedBytevEXT
glIsMemoryObjectEXT
glMemoryObjectParameterivEXT
glNamedBufferStorageMemEXT
glTexStorageMem2DEXT
glTexStorageMem2DMultisampleEXT
glTexStorageMem3DEXT
glTexStorageMem3DMultisampleEXT
glTextureStorageMem2DEXT
glTextureStorageMem2DMultisampleEXT
glTextureStorageMem3DEXT
glTextureStorageMem3DMultisampleEXT
GL_EXT_memory_object_fd
glImportMemoryFdEXT
GL_EXT_memory_object_win32
glImportMemoryWin32HandleEXT
glImportMemoryWin32NameEXT
GL_EXT_multi_draw_arrays
glMultiDrawArraysEXT
glMultiDrawElementsEXT
GL_EXT_semaphore
glDeleteSemaphoresEXT
glGenSemaphoresEXT
glGetSemaphoreParameterui64vEXT
glIsSemaphoreEXT
glSemaphoreParameterui64vEXT
glSignalSemaphoreEXT
glWaitSemaphoreEXT
GL_EXT_semaphore_fd
glImportSemaphoreFdEXT
GL_EXT_semaphore_win32
glImportSemaphoreWin32HandleEXT
glImportSemaphoreWin32NameEXT
GL_EXT_separate_shader_objects
glActiveShaderProgramEXT
glBindProgramPipelineEXT
glCreateShaderProgramvEXT
glDeleteProgramPipelinesEXT
glGenProgramPipelinesEXT
glGetProgramPipelineInfoLogEXT
glGetProgramPipelineivEXT
glIsProgramPipelineEXT
glProgramParameteriEXT
glProgramUniform1fEXT
glProgramUniform1fvEXT
glProgramUniform1iEXT
glProgramUniform1ivEXT
glProgramUniform1uiEXT
glProgramUniform1uivEXT
glProgramUniform2fEXT
glProgramUniform2fvEXT
glProgramUniform2iEXT
glProgramUniform2ivEXT
glProgramUniform2uiEXT
glProgramUniform2uivEXT
glProgramUniform3fEXT
glProgramUniform3fvEXT
glProgramUniform3iEXT
glProgramUniform3ivEXT
glProgramUniform3uiEXT
glProgramUniform3uivEXT
glProgramUniform4fEXT
glProgramUniform4fvEXT
glProgramUniform4iEXT
glProgramUniform4ivEXT
glProgramUniform4uiEXT
glProgramUniform4uivEXT
glProgramUniformMatrix2fvEXT
glProgramUniformMatrix2x3fvEXT
glProgramUniformMatrix2x4fvEXT
glProgramUniformMatrix3fvEXT
glProgramUniformMatrix3x2fvEXT
glProgramUniformMatrix3x4fvEXT
glProgramUniformMatrix4fvEXT
glProgramUniformMatrix4x2fvEXT
glProgramUniformMatrix4x3fvEXT
glUseProgramStagesEXT
glValidateProgramPipelineEXT
GL_EXT_shader_framebuffer_fetch_non_coherent
glFramebufferFetchBarrierEXT
GL_EXT_texture_storage
glTexStorage1DEXT
glTexStorage2DEXT
glTexStorage3DEXT
glTextureStorage1DEXT
glTextureStorage2DEXT
glTextureStorage3DEXT
GL_KHR_parallel_shader_compile
glMaxShaderCompilerThreadsKHR
GL_NV_fence
glDeleteFencesNV
glFinishFenceNV
glGenFencesNV
glGetFenceivNV
glIsFenceNV
glSetFenceNV
glTestFenceNV
GL_NV_framebuffer_mixed_samples
glCoverageModulationNV
GL_NV_internalformat_sample_query
glGetInternalformatSampleivNV
glFramebufferTextureMultiviewOVR
gpu.angle
egl::Display::initialize
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Display.cpp
initialize
ANGLE Display::initialize error 
No configs were generated.
Failed to initialize display because device creation failed: 
native client buffer allocation failed.
Google Inc.
OpenGL_ES OpenGL
OpenGL_ES
true
false
Program binary not accessible.
Program binary too large or changed during access.
Failed to copy program binary into the cache.
ANGLE_DEFAULT_PLATFORM
metal
loseContextOnOutOfMemory
Some users rely on a lost context notification if a GL_OUT_OF_MEMORY error occurs
disableProgramCachingForTransformFeedback
On some GPUs, program binaries don't contain transform feedback varyings
scalarizeVecAndMatConstructorArgs
Always rewrite vec/mat constructors to be consistent
http://crbug.com/1165751
disableProgramBinary
Disable support for GL_OES_get_program_binary
http://anglebug.com/5007
disableDrawBuffersIndexed
Disable support for OES_draw_buffers_indexed and EXT_draw_buffers_indexed
http://anglebug.com/7724
disableAnisotropicFiltering
Disable support for anisotropic filtering
allowCompressedFormats
Allow compressed formats
singleThreadedTextureDecompression
Disables multi-threaded decompression of compressed texture formats
forceDepthAttachmentInitOnClear
Force depth attachment initialization on clear ops
https://anglebug.com/7246
enableCaptureLimits
Set the context limits like frame capturing was enabled
http://anglebug.com/5750
forceRobustResourceInit
Force-enable robust resource init
http://anglebug.com/6041
forceInitShaderVariables
Force-enable shader variable initialization
enableProgramBinaryForCapture
Even if FrameCapture is enabled, enable GL_OES_get_program_binary
http://anglebug.com/5658
forceGlErrorChecking
Force GL error checking (i.e. prevent applications from disabling error checking
https://issuetracker.google.com/220069903
emulatePixelLocalStorage
Emulate ANGLE_shader_pixel_local_storage using shader images
http://anglebug.com/7279
cacheCompiledShader
Enable to cache compiled shaders
http://anglebug.com/7036
Could not create the EAGL context.
Could set the EAGL context current.
Could not open the OpenGLES Framework.
OpenGL ES 2.0 is not supportable.
Could not make device EAGL context current.
Could not release device EAGL context.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
makeCurrent
Unable to make gl context current.
/System/Library/Frameworks/OpenGLES.framework/OpenGLES
OpenGL 
DisplayImpl::validateClientBuffer unimplemented.
DisplayImpl::validateImageClientBuffer unimplemented.
DisplayImpl::valdiatePixmap unimplemented.
ANGLE Metal Renderer
isMetal2_1 && (isOSX || isCatalyst) && !isARM
supportsEitherGPUFamily(3, 2)
supportsEitherGPUFamily(5, 2)
supportsEitherGPUFamily(3, 1)
supportsEitherGPUFamily(3, 1) && !isAMD()
isMetal2_1 && !isIntel() && !isNVIDIA()
isMetal2_2 && supportsEitherGPUFamily(3, 2) && !isSimulator
isMetal2_1 && !isNVIDIA()
(isOSX || isCatalyst) && !isARM
isAMD()
isOSX || isCatalyst || supportsAppleGPUFamily(3)
isOSX || isCatalyst || supportsAppleGPUFamily(4)
!isOSX && !isCatalyst && !isSimulator
isIntel() && GetMacOSVersion() < OSVersion(11, 0, 0)
isIntel() && GetMacOSVersion() < OSVersion(12, 0, 0)
isIntel() || isAMD()
isIntel()
supportsEitherGPUFamily(4, 2)
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/DisplayMtl.mm
getDefaultShadersLib
Internal error: 
hasBaseVertexInstancedDraw
The renderer supports base vertex instanced draw
hasExplicitMemBarrier
The renderer supports explicit memory barrier
hasCheapRenderPass
The renderer can cheaply break a render pass.
hasNonUniformDispatch
The renderer supports non uniform compute shader dispatch's group size
hasShaderStencilOutput
The renderer supports stencil output from fragment shader
hasTextureSwizzle
The renderer supports texture swizzle
hasDepthAutoResolve
The renderer supports MSAA depth auto resolve at the end of render pass
hasStencilAutoResolve
The renderer supports MSAA stencil auto resolve at the end of render pass
hasEvents
The renderer supports MTL(Shared)Event
allowInlineConstVertexData
The renderer supports using inline constant data for small client vertex data
allowSeparateDepthStencilBuffers
Some Apple platforms such as iOS allows separate depth and stencil buffers, whereas others such as macOS don't
allowRuntimeSamplerCompareMode
The renderer supports changing sampler's compare mode outside shaders
allowSamplerCompareGradient
The renderer supports sample_compare with gradients
allowSamplerCompareLod
The renderer supports sample_compare with lod
allowBufferReadWrite
The renderer supports buffer read and write in the same shader
allowMultisampleStoreAndResolve
The renderer supports MSAA store and resolve in the same pass
allowGenMultipleMipsPerPass
The renderer supports generating multiple mipmaps per pass
forceD24S8AsUnsupported
Force Depth24Stencil8 format as unsupported.
forceBufferGPUStorage
On systems that support both buffer' memory allocation on GPU and shared memory (such as macOS), force using GPU memory allocation for buffers everytime or not.
forceNonCSBaseMipmapGeneration
Turn this feature on to disallow Compute Shader based mipmap generation. Compute Shader based mipmap generation might cause GPU hang on some older iOS devices.
emulateTransformFeedback
Turn this on to allow transform feedback in Metal using a 2-pass VS for GLES3.
rewriteRowMajorMatrices
Rewrite row major matrices in shaders as column major.
intelExplicitBoolCastWorkaround
Insert explicit casts for float/double/unsigned/signed int on macOS 10.15 with Intel driver
intelDisableFastMath
Disable fast math in atan and invariance cases when running below macOS 12.0
allowRenderpassWithoutAttachment
Allow creation of render passes without any attachments
multisampleColorFormatShaderReadWorkaround
Add shaderRead usage to some multisampled texture formats
http://anglebug.com/7049
copyIOSurfaceToNonIOSurfaceForReadOptimization
some GPUs are faster to read an IOSurface texture by first copying the texture to a non-IOSurface texture
http://anglebug.com/7117 http://anglebug.com/7573
copyTextureToBufferForReadOptimization
some GPUs are faster to read a texture by first copying the texture to a buffer
http://anglebug.com/7117
limitMaxDrawBuffersForTesting
Used to check the backend works when the device's advertized limit is less than the code's limit
http://anglebug.com/7280
limitMaxColorTargetBitsForTesting
Metal iOS has a limit on the number of color target bits per pixel.
preemptivelyStartProvokingVertexCommandBuffer
AMD Metal Drivers appear to have a bug this works around
http://anglebug.com/7635
uploadDataToIosurfacesWithStagingBuffers
When uploading data to IOSurface-backed textures, use a staging buffer.
http://anglebug.com/7573
alwaysUseStagedBufferUpdates
Always update buffers by copying the data to a staging buffer and then blitting it to the actual buffer
http://anglebug.com/7544
useShadowBuffersWhenAppropriate
On some architectures using a shadow buffer can be faster for certain size buffers
alwaysUseManagedStorageModeForBuffers
Metal buffers can be managed, shared, or private. Sometimes managed is fastest
alwaysUseSharedStorageModeForBuffers
Metal buffers can be managed, shared, or private. Sometimes shared is fastest
preferCpuForBuffersubdata
Makes bufferSubData always update via CPU
disableProgrammableBlending
Disable programmable blending in order to test read_write pixel local storage textures
disableRWTextureTier2Support
Disable tier2 read_write textures in order to test tier1 support
disableRasterOrderGroups
Disable raster order groups in order to test pixel local storage memory barriers
Apple
Broadcom
Google
Intel
Mesa
Microsoft
NVIDIA
Imagination Technologies
Qualcomm
Samsung Electronics Co., Ltd.
Vivante
VMware
VirtIO
Test
NULL
Unknown
ANGLE_angleUniforms
unpackSnorm4x8
ANGLEDepthRangeParams
eglClientWaitSync
eglCreateImageKHR
eglCreateNativeClientBufferANDROID
eglCreatePlatformPixmapSurfaceEXT
CreatePlatformPixmapSurfaceEXT unimplemented.
eglCreatePlatformWindowSurfaceEXT
eglPlatformCreateWindowSurfaceEXT
eglCreateStreamKHR
eglCreateSyncKHR
eglDestroyImageKHR
eglDestroyStreamKHR
eglDestroySync
eglDupNativeFenceFDANDROID
eglGetSyncAttrib
eglPostSubBufferNV
eglPresentationTimeANDROID
eglGetCompositorTimingANDROIDD
eglGetNextFrameIdANDROID
eglQueryTimestampSupportedANDROID
eglGetFrameTimestampsANDROID
eglQueryDeviceAttribEXT
eglQueryDeviceStringEXT
eglQueryDisplayAttribEXT
eglQueryStreamKHR
eglQueryStreamu64KHR
eglQuerySurfacePointerANGLE
eglSetBlobCacheFuncsANDROID
eglSignalSyncKHR
eglStreamAttribKHR
eglStreamConsumerAcquireKHR
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerGLTextureExternalAttribsNV
eglStreamConsumerReleaseKHR
eglSwapBuffersWithDamageEXT
eglPrepareSwapBuffersANGLE
prepareSwap
eglWaitSync
eglCreateDeviceANGLE
eglCreateStreamProducerD3DTextureANGLE
eglStreamPostD3DTextureANGLE
eglGetMscRateANGLE
eglGetSyncValuesCHROMIUM
eglProgramCacheGetAttribANGLE
eglProgramCacheQueryANGLE
eglProgramCachePopulateANGLE
eglProgramCacheResizeANGLE
eglQueryStringiANGLE
eglSwapBuffersWithFrameTokenANGLE
eglReleaseHighPowerGPUANGLE
eglReacquireHighPowerGPUANGLE
eglHandleGPUSwitchANGLE
eglForceGPUSwitchANGLE
eglWaitUntilWorkScheduledANGLE
eglLockSurfaceKHR
eglUnlockSurfaceKHR
eglQuerySurface64KHR
eglExportVkImageANGLE
eglSetDamageRegionKHR
eglQueryDmaBufFormatsEXT
eglQueryDmaBufModifiersEXT
eglCopyMetalSharedEventANGLE
eglBindTexImage
eglClientWaitSync
eglCopyBuffers
eglCreateContext
eglCreateImage
eglCreatePbufferFromClientBuffer
eglCreatePbufferSurface
eglCreatePixmapSurface
eglCreatePlatformPixmapSurface
eglCreatePlatformWindowSurface
eglPlatformCreateWindowSurface
eglCreateSync
eglCreateWindowSurface
eglDestroyContext
eglDestroyImage
eglDestroySurface
eglDestroySync
eglGetSyncAttrib
eglInitialize
eglMakeCurrent
eglQueryContext
eglQueryString
1.5 (ANGLE 
eglQuerySurface
eglReleaseTexImage
eglReleaseThread
eglSurfaceAttrib
eglSwapBuffers
eglSwapInterval
eglTerminate
eglWaitClient
eglWaitGL
eglWaitNative
eglWaitSync
unique_lock::lock: references null mutex
unique_lock::lock: already locked
unique_lock::unlock: not locked
GMD_FIXED_EMIT
texelFetch
texelFetchOffset
texture1D
texture1DLod
texture1DProjLod
texture2DGradEXT
texture2DLod
texture2DLodEXT
texture2DProj
texture2DProjGradEXT
texture2DProjLod
texture2DProjLodEXT
texture2DRect
texture2DRectProj
texture3D
texture3DLod
texture3DProjLod
textureCube
textureCubeGradEXT
textureCubeLod
textureCubeLodEXT
textureCubeProjLod
textureGrad
textureGradOffset
textureLod
textureLodOffset
textureOffset
textureProj
textureProjGrad
textureProjGradOffset
textureProjLod
textureProjLodOffset
textureProjOffset
textureSize
imageLoad
imageStore
memoryBarrierImage
ANGLE_tensor<
metal::
packed_
uint32_t
metal::texture2d<
float
uint
, metal::access::read_write>
INFINITY
!=/*xor*/
ANGLE_equalStructArray
ANGLE_equal
ANGLE_notEqualStructArray
ANGLE_notEqual
ANGLE_notEqualStruct
kill
return
break
continue
ANGLE_radians
ANGLE_degrees
ANGLE_atan
ANGLE_mod
ANGLE_refract
ANGLE_distance
ANGLE_length
ANGLE_dot
ANGLE_normalize
ANGLE_faceforward
ANGLE_reflect
ANGLE_componentWiseMultiply
ANGLE_outerProduct
ANGLE_sign
metal::abs
metal::all
metal::any
metal::sin
metal::cos
metal::tan
metal::asin
metal::acos
metal::sinh
metal::cosh
metal::tanh
metal::asinh
metal::acosh
metal::atanh
metal::fma
metal::pow
metal::exp
metal::exp2
metal::log
metal::log2
metal::sqrt
metal::floor
metal::trunc
metal::ceil
metal::fract
metal::min
metal::max
metal::round
metal::rint
metal::clamp
ANGLE_mix_bool
metal::mix
metal::step
metal::smoothstep
metal::modf
metal::isnan
metal::isinf
metal::ldexp
metal::frexp
metal::rsqrt
metal::cross
metal::dfdx
metal::dfdy
metal::fwidth
metal::transpose
metal::determinant
ANGLE_inverse
as_type<int>
as_type<uint32_t>
as_type<float>
TOperator_TODO
as_type<int2>
as_type<uint2>
as_type<float2>
as_type<int3>
as_type<uint3>
as_type<float3>
as_type<int4>
as_type<uint4>
as_type<float4>
metal::pack_float_to_unorm2x16
metal::pack_float_to_snorm2x16
metal::pack_float_to_unorm4x8
metal::pack_float_to_snorm4x8
metal::unpack_unorm2x16_to_float
metal::unpack_snorm2x16_to_float
metal::unpack_unorm4x8_to_float
metal::unpack_snorm4x8_to_float
ANGLE_pack_half_2x16
ANGLE_unpack_half_2x16
ANGLE_int_clamp(
, 0, 
.size()
if (
else
 else {}
switch (
case 
default:
 @@XFB-Bindings@@ 
[[early_fragment_tests]]
fragment 
vertex __VERTEX_OUT(
 [[stage_in]]
 [[buffer(
metal::sampler
 [[sampler(
 [[texture(
 [[instance_id]]
 [[base_instance]]
struct 
char 
 [[flat]]
 [[color(
, raster_order_group(0)
 [[depth(any), function_constant(
 [[sample_mask, function_constant(
raster_order_group(0), 
texture(
[[id(
 [[position]]
 [[clip_distance]] [
 [[point_size]]
 [[vertex_id]]
 [[point_coord]]
 [[front_facing]]
 [[invariant]]
baseInstance
constant 
for (
while (
metal::discard_fragment()
#if TRANSFORM_FEEDBACK_ENABLED
return;
#else
#endif
gl_FragData
eglChooseConfig
eglCopyBuffers
eglCreateContext
eglCreatePbufferSurface
eglCreatePixmapSurface
eglCreateWindowSurface
eglDestroyContext
eglDestroySurface
eglGetConfigAttrib
eglGetConfigs
eglGetCurrentSurface
eglInitialize
eglMakeCurrent
eglQueryContext
eglQuerySurface
eglSwapBuffers
eglTerminate
eglWaitGL
eglWaitNative
eglBindTexImage
eglReleaseTexImage
eglSurfaceAttrib
eglSwapInterval
eglCreatePbufferFromClientBuffer
eglWaitClient
eglClientWaitSync
eglCreateImage
eglCreatePlatformPixmapSurface
eglCreatePlatformWindowSurface
eglCreateSync
eglDestroyImage
eglDestroySync
eglGetPlatformDisplay
eglGetSyncAttrib
eglWaitSync
eglSetBlobCacheFuncsANDROID
eglCreateNativeClientBufferANDROID
eglGetCompositorTimingSupportedANDROID
eglGetCompositorTimingANDROID
eglGetNextFrameIdANDROID
eglGetFrameTimestampSupportedANDROID
eglGetFrameTimestampsANDROID
eglGetNativeClientBufferANDROID
eglDupNativeFenceFDANDROID
eglPresentationTimeANDROID
eglCreateDeviceANGLE
eglReleaseDeviceANGLE
eglQueryStringiANGLE
eglQueryDisplayAttribANGLE
eglCopyMetalSharedEventANGLE
eglReleaseHighPowerGPUANGLE
eglReacquireHighPowerGPUANGLE
eglHandleGPUSwitchANGLE
eglForceGPUSwitchANGLE
eglProgramCacheGetAttribANGLE
eglProgramCacheQueryANGLE
eglProgramCachePopulateANGLE
eglProgramCacheResizeANGLE
eglQuerySurfacePointerANGLE
eglCreateStreamProducerD3DTextureANGLE
eglStreamPostD3DTextureANGLE
eglSwapBuffersWithFrameTokenANGLE
eglGetMscRateANGLE
eglExportVkImageANGLE
eglWaitUntilWorkScheduledANGLE
eglGetSyncValuesCHROMIUM
eglQueryDeviceAttribEXT
eglQueryDisplayAttribEXT
eglQueryDmaBufFormatsEXT
eglQueryDmaBufModifiersEXT
eglCreatePlatformPixmapSurfaceEXT
eglCreatePlatformWindowSurfaceEXT
eglGetPlatformDisplayEXT
eglDebugMessageControlKHR
eglLabelObjectKHR
eglQueryDebugKHR
eglClientWaitSyncKHR
eglCreateSyncKHR
eglDestroySyncKHR
eglGetSyncAttribKHR
eglCreateImageKHR
eglDestroyImageKHR
eglLockSurfaceKHR
eglQuerySurface64KHR
eglUnlockSurfaceKHR
eglSetDamageRegionKHR
eglSignalSyncKHR
eglCreateStreamKHR
eglDestroyStreamKHR
eglQueryStreamKHR
eglQueryStreamu64KHR
eglStreamAttribKHR
eglStreamConsumerAcquireKHR
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerReleaseKHR
eglSwapBuffersWithDamageKHR
eglWaitSyncKHR
eglPostSubBufferNV
eglStreamConsumerGLTextureExternalAttribsNV
Invalid
clBuildProgram
clCloneKernel
clCompileProgram
clCreateBuffer
clCreateBufferWithProperties
clCreateCommandQueue
clCreateCommandQueueWithProperties
clCreateContext
clCreateContextFromType
clCreateImage
clCreateImage2D
clCreateImage3D
clCreateImageWithProperties
clCreateKernel
clCreateKernelsInProgram
clCreatePipe
clCreateProgramWithBinary
clCreateProgramWithBuiltInKernels
clCreateProgramWithIL
clCreateProgramWithSource
clCreateSampler
clCreateSamplerWithProperties
clCreateSubBuffer
clCreateSubDevices
clCreateUserEvent
clEnqueueBarrier
clEnqueueBarrierWithWaitList
clEnqueueCopyBuffer
clEnqueueCopyBufferRect
clEnqueueCopyBufferToImage
clEnqueueCopyImage
clEnqueueCopyImageToBuffer
clEnqueueFillBuffer
clEnqueueFillImage
clEnqueueMapBuffer
clEnqueueMapImage
clEnqueueMarker
clEnqueueMarkerWithWaitList
clEnqueueMigrateMemObjects
clEnqueueNDRangeKernel
clEnqueueNativeKernel
clEnqueueReadBuffer
clEnqueueReadBufferRect
clEnqueueReadImage
clEnqueueSVMFree
clEnqueueSVMMap
clEnqueueSVMMemFill
clEnqueueSVMMemcpy
clEnqueueSVMMigrateMem
clEnqueueSVMUnmap
clEnqueueTask
clEnqueueUnmapMemObject
clEnqueueWaitForEvents
clEnqueueWriteBuffer
clEnqueueWriteBufferRect
clEnqueueWriteImage
clFinish
clFlush
clGetCommandQueueInfo
clGetContextInfo
clGetDeviceAndHostTimer
clGetDeviceIDs
clGetDeviceInfo
clGetEventInfo
clGetEventProfilingInfo
clGetExtensionFunctionAddress
clGetExtensionFunctionAddressForPlatform
clGetHostTimer
clGetImageInfo
clGetKernelArgInfo
clGetKernelInfo
clGetKernelSubGroupInfo
clGetKernelWorkGroupInfo
clGetMemObjectInfo
clGetPipeInfo
clGetPlatformIDs
clGetPlatformInfo
clGetProgramBuildInfo
clGetProgramInfo
clGetSamplerInfo
clGetSupportedImageFormats
clIcdGetPlatformIDsKHR
clLinkProgram
clReleaseCommandQueue
clReleaseContext
clReleaseDevice
clReleaseEvent
clReleaseKernel
clReleaseMemObject
clReleaseProgram
clReleaseSampler
clRetainCommandQueue
clRetainContext
clRetainDevice
clRetainEvent
clRetainKernel
clRetainMemObject
clRetainProgram
clRetainSampler
clSVMAlloc
clSVMFree
clSetCommandQueueProperty
clSetContextDestructorCallback
clSetDefaultDeviceCommandQueue
clSetEventCallback
clSetKernelArg
clSetKernelArgSVMPointer
clSetKernelExecInfo
clSetMemObjectDestructorCallback
clSetProgramReleaseCallback
clSetProgramSpecializationConstant
clSetUserEventStatus
clUnloadCompiler
clUnloadPlatformCompiler
clWaitForEvents
eglBindAPI
eglGetCurrentContext
eglGetCurrentDisplay
eglGetDisplay
eglGetError
eglGetProcAddress
eglPrepareSwapBuffersANGLE
eglQueryAPI
glAccum
glAcquireTexturesANGLE
glAlphaFunc
glAlphaFuncx
glAreTexturesResident
glArrayElement
glBegin
glBeginConditionalRender
glBeginPerfMonitorAMD
glBeginPixelLocalStorageANGLE
glBeginQueryIndexed
glBindBuffersBase
glBindBuffersRange
glBindFragDataLocation
glBindFragDataLocationIndexed
glBindFramebufferOES
glBindImageTextures
glBindRenderbufferOES
glBindSamplers
glBindTextureUnit
glBindTextures
glBindUniformLocationCHROMIUM
glBindVertexBuffers
glBitmap
glBlendBarrierKHR
glBlitFramebufferANGLE
glBlitNamedFramebuffer
glBufferStorage
glBufferStorageExternalEXT
glCallList
glCallLists
glCheckFramebufferStatusOES
glCheckNamedFramebufferStatus
glClampColor
glClearAccum
glClearBufferData
glClearBufferSubData
glClearColorx
glClearDepth
glClearDepthx
glClearIndex
glClearNamedBufferData
glClearNamedBufferSubData
glClearNamedFramebufferfi
glClearNamedFramebufferfv
glClearNamedFramebufferiv
glClearNamedFramebufferuiv
glClearTexImage
glClearTexSubImage
glClientActiveTexture
glClipControl
glClipPlane
glClipPlanef
glClipPlanex
glColor3b
glColor3bv
glColor3d
glColor3dv
glColor3f
glColor3fv
glColor3i
glColor3iv
glColor3s
glColor3sv
glColor3ub
glColor3ubv
glColor3ui
glColor3uiv
glColor3us
glColor3usv
glColor4b
glColor4bv
glColor4d
glColor4dv
glColor4f
glColor4fv
glColor4i
glColor4iv
glColor4s
glColor4sv
glColor4ub
glColor4ubv
glColor4ui
glColor4uiv
glColor4us
glColor4usv
glColor4x
glColorMaterial
glColorP3ui
glColorP3uiv
glColorP4ui
glColorP4uiv
glColorPointer
glCompressedCopyTextureCHROMIUM
glCompressedTexImage1D
glCompressedTexImage2DRobustANGLE
glCompressedTexImage3DRobustANGLE
glCompressedTexSubImage1D
glCompressedTexSubImage2DRobustANGLE
glCompressedTexSubImage3DRobustANGLE
glCompressedTextureSubImage1D
glCompressedTextureSubImage2D
glCompressedTextureSubImage3D
glCopyNamedBufferSubData
glCopyPixels
glCopySubTexture3DANGLE
glCopySubTextureCHROMIUM
glCopyTexImage1D
glCopyTexSubImage1D
glCopyTexture3DANGLE
glCopyTextureCHROMIUM
glCopyTextureSubImage1D
glCopyTextureSubImage2D
glCopyTextureSubImage3D
glCoverageModulationCHROMIUM
glCreateBuffers
glCreateFramebuffers
glCreateProgramPipelines
glCreateQueries
glCreateRenderbuffers
glCreateSamplers
glCreateTextures
glCreateTransformFeedbacks
glCreateVertexArrays
glCurrentPaletteMatrixOES
glDeleteFramebuffersOES
glDeleteLists
glDeletePerfMonitorsAMD
glDeleteRenderbuffersOES
glDepthRange
glDepthRangeArrayv
glDepthRangeIndexed
glDepthRangex
glDisableClientState
glDisableExtensionANGLE
glDisableVertexArrayAttrib
glDrawArraysInstancedANGLE
glDrawArraysInstancedBaseInstance
glDrawArraysInstancedBaseInstanceANGLE
glDrawBuffer
glDrawElementsInstancedANGLE
glDrawElementsInstancedBaseInstance
glDrawElementsInstancedBaseVertexBaseInstance
glDrawElementsInstancedBaseVertexBaseInstanceANGLE
glDrawPixels
glDrawTexfOES
glDrawTexfvOES
glDrawTexiOES
glDrawTexivOES
glDrawTexsOES
glDrawTexsvOES
glDrawTexxOES
glDrawTexxvOES
glDrawTransformFeedback
glDrawTransformFeedbackInstanced
glDrawTransformFeedbackStream
glDrawTransformFeedbackStreamInstanced
glEGLImageTargetTexStorageEXT
glEGLImageTargetTextureStorageEXT
glEdgeFlag
glEdgeFlagPointer
glEdgeFlagv
glEnableClientState
glEnableVertexArrayAttrib
glEnd
glEndConditionalRender
glEndList
glEndPerfMonitorAMD
glEndPixelLocalStorageANGLE
glEndQueryIndexed
glEvalCoord1d
glEvalCoord1dv
glEvalCoord1f
glEvalCoord1fv
glEvalCoord2d
glEvalCoord2dv
glEvalCoord2f
glEvalCoord2fv
glEvalMesh1
glEvalMesh2
glEvalPoint1
glEvalPoint2
glFeedbackBuffer
glFlushMappedNamedBufferRange
glFogCoordPointer
glFogCoordd
glFogCoorddv
glFogCoordf
glFogCoordfv
glFogf
glFogfv
glFogi
glFogiv
glFogx
glFogxv
glFramebufferMemorylessPixelLocalStorageANGLE
glFramebufferParameteriMESA
glFramebufferPixelLocalClearValuefvANGLE
glFramebufferPixelLocalClearValueivANGLE
glFramebufferPixelLocalClearValueuivANGLE
glFramebufferRenderbufferOES
glFramebufferTexture1D
glFramebufferTexture2DOES
glFramebufferTexture3D
glFramebufferTexturePixelLocalStorageANGLE
glFrustum
glFrustumf
glFrustumx
glGenFramebuffersOES
glGenLists
glGenPerfMonitorsAMD
glGenRenderbuffersOES
glGenerateMipmapOES
glGenerateTextureMipmap
glGetActiveAtomicCounterBufferiv
glGetActiveSubroutineName
glGetActiveSubroutineUniformName
glGetActiveSubroutineUniformiv
glGetActiveUniformBlockivRobustANGLE
glGetActiveUniformName
glGetBooleani_vRobustANGLE
glGetBooleanvRobustANGLE
glGetBufferParameteri64vRobustANGLE
glGetBufferParameterivRobustANGLE
glGetBufferPointervRobustANGLE
glGetBufferSubData
glGetClipPlane
glGetClipPlanef
glGetClipPlanex
glGetCompressedTexImage
glGetCompressedTexImageANGLE
glGetCompressedTextureImage
glGetCompressedTextureSubImage
glGetDoublei_v
glGetDoublev
glGetFixedv
glGetFloati_v
glGetFloatvRobustANGLE
glGetFragDataIndex
glGetFramebufferAttachmentParameterivOES
glGetFramebufferAttachmentParameterivRobustANGLE
glGetFramebufferParameterivMESA
glGetFramebufferParameterivRobustANGLE
glGetFramebufferPixelLocalStorageParameterfvANGLE
glGetFramebufferPixelLocalStorageParameterivANGLE
glGetInteger64i_vRobustANGLE
glGetInteger64vRobustANGLE
glGetIntegeri_vRobustANGLE
glGetIntegervRobustANGLE
glGetInternalformati64v
glGetInternalformativRobustANGLE
glGetLightfv
glGetLightiv
glGetLightxv
glGetMapdv
glGetMapfv
glGetMapiv
glGetMaterialfv
glGetMaterialiv
glGetMaterialxv
glGetMultisamplefvANGLE
glGetMultisamplefvRobustANGLE
glGetNamedBufferParameteri64v
glGetNamedBufferParameteriv
glGetNamedBufferPointerv
glGetNamedBufferSubData
glGetNamedFramebufferAttachmentParameteriv
glGetNamedFramebufferParameteriv
glGetNamedRenderbufferParameteriv
glGetPerfMonitorCounterDataAMD
glGetPerfMonitorCounterInfoAMD
glGetPerfMonitorCounterStringAMD
glGetPerfMonitorCountersAMD
glGetPerfMonitorGroupStringAMD
glGetPerfMonitorGroupsAMD
glGetPixelMapfv
glGetPixelMapuiv
glGetPixelMapusv
glGetPointervRobustANGLERobustANGLE
glGetPolygonStipple
glGetProgramInterfaceivRobustANGLE
glGetProgramResourceLocationIndex
glGetProgramStageiv
glGetProgramivRobustANGLE
glGetQueryBufferObjecti64v
glGetQueryBufferObjectiv
glGetQueryBufferObjectui64v
glGetQueryBufferObjectuiv
glGetQueryIndexediv
glGetQueryObjecti64v
glGetQueryObjecti64vRobustANGLE
glGetQueryObjectiv
glGetQueryObjectivRobustANGLE
glGetQueryObjectui64v
glGetQueryObjectui64vRobustANGLE
glGetQueryObjectuivRobustANGLE
glGetQueryivRobustANGLE
glGetRenderbufferImageANGLE
glGetRenderbufferParameterivOES
glGetRenderbufferParameterivRobustANGLE
glGetSamplerParameterIivRobustANGLE
glGetSamplerParameterIuivRobustANGLE
glGetSamplerParameterfvRobustANGLE
glGetSamplerParameterivRobustANGLE
glGetShaderivRobustANGLE
glGetSubroutineIndex
glGetSubroutineUniformLocation
glGetTexEnvfv
glGetTexEnviv
glGetTexEnvxv
glGetTexGendv
glGetTexGenfv
glGetTexGenfvOES
glGetTexGeniv
glGetTexGenivOES
glGetTexGenxvOES
glGetTexImage
glGetTexImageANGLE
glGetTexLevelParameterfvANGLE
glGetTexLevelParameterfvRobustANGLE
glGetTexLevelParameterivANGLE
glGetTexLevelParameterivRobustANGLE
glGetTexParameterIivRobustANGLE
glGetTexParameterIuivRobustANGLE
glGetTexParameterfvRobustANGLE
glGetTexParameterivRobustANGLE
glGetTexParameterxv
glGetTextureImage
glGetTextureLevelParameterfv
glGetTextureLevelParameteriv
glGetTextureParameterIiv
glGetTextureParameterIuiv
glGetTextureParameterfv
glGetTextureParameteriv
glGetTextureSubImage
glGetTransformFeedbacki64_v
glGetTransformFeedbacki_v
glGetTransformFeedbackiv
glGetTranslatedShaderSourceANGLE
glGetUniformSubroutineuiv
glGetUniformdv
glGetUniformfvRobustANGLE
glGetUniformivRobustANGLE
glGetUniformuivRobustANGLE
glGetVertexArrayIndexed64iv
glGetVertexArrayIndexediv
glGetVertexArrayiv
glGetVertexAttribIivRobustANGLE
glGetVertexAttribIuivRobustANGLE
glGetVertexAttribLdv
glGetVertexAttribPointervRobustANGLE
glGetVertexAttribdv
glGetVertexAttribfvRobustANGLE
glGetVertexAttribivRobustANGLE
glGetnColorTable
glGetnCompressedTexImage
glGetnConvolutionFilter
glGetnHistogram
glGetnMapdv
glGetnMapfv
glGetnMapiv
glGetnMinmax
glGetnPixelMapfv
glGetnPixelMapuiv
glGetnPixelMapusv
glGetnPolygonStipple
glGetnSeparableFilter
glGetnTexImage
glGetnUniformdv
glGetnUniformfvRobustANGLE
glGetnUniformivRobustANGLE
glGetnUniformuivRobustANGLE
glImportMemoryZirconHandleANGLE
glImportSemaphoreZirconHandleANGLE
glIndexMask
glIndexPointer
glIndexd
glIndexdv
glIndexf
glIndexfv
glIndexi
glIndexiv
glIndexs
glIndexsv
glIndexub
glIndexubv
glInitNames
glInterleavedArrays
glInvalidateBufferData
glInvalidateBufferSubData
glInvalidateNamedFramebufferData
glInvalidateNamedFramebufferSubData
glInvalidateTexImage
glInvalidateTexSubImage
glInvalidateTextureANGLE
glIsFramebufferOES
glIsList
glIsRenderbufferOES
glLabelObjectEXT
glLightModelf
glLightModelfv
glLightModeli
glLightModeliv
glLightModelx
glLightModelxv
glLightf
glLightfv
glLighti
glLightiv
glLightx
glLightxv
glLineStipple
glLineWidthx
glListBase
glLoadIdentity
glLoadMatrixd
glLoadMatrixf
glLoadMatrixx
glLoadName
glLoadPaletteFromModelViewMatrixOES
glLoadTransposeMatrixd
glLoadTransposeMatrixf
glLogicOp
glLogicOpANGLE
glLoseContextCHROMIUM
glMap1d
glMap1f
glMap2d
glMap2f
glMapBuffer
glMapGrid1d
glMapGrid1f
glMapGrid2d
glMapGrid2f
glMapNamedBuffer
glMapNamedBufferRange
glMaterialf
glMaterialfv
glMateriali
glMaterialiv
glMaterialx
glMaterialxv
glMatrixIndexPointerOES
glMatrixMode
glMultMatrixd
glMultMatrixf
glMultMatrixx
glMultTransposeMatrixd
glMultTransposeMatrixf
glMultiDrawArrays
glMultiDrawArraysANGLE
glMultiDrawArraysIndirect
glMultiDrawArraysIndirectCount
glMultiDrawArraysInstancedANGLE
glMultiDrawArraysInstancedBaseInstanceANGLE
glMultiDrawElements
glMultiDrawElementsANGLE
glMultiDrawElementsBaseVertex
glMultiDrawElementsIndirect
glMultiDrawElementsIndirectCount
glMultiDrawElementsInstancedANGLE
glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE
glMultiTexCoord1d
glMultiTexCoord1dv
glMultiTexCoord1f
glMultiTexCoord1fv
glMultiTexCoord1i
glMultiTexCoord1iv
glMultiTexCoord1s
glMultiTexCoord1sv
glMultiTexCoord2d
glMultiTexCoord2dv
glMultiTexCoord2f
glMultiTexCoord2fv
glMultiTexCoord2i
glMultiTexCoord2iv
glMultiTexCoord2s
glMultiTexCoord2sv
glMultiTexCoord3d
glMultiTexCoord3dv
glMultiTexCoord3f
glMultiTexCoord3fv
glMultiTexCoord3i
glMultiTexCoord3iv
glMultiTexCoord3s
glMultiTexCoord3sv
glMultiTexCoord4d
glMultiTexCoord4dv
glMultiTexCoord4f
glMultiTexCoord4fv
glMultiTexCoord4i
glMultiTexCoord4iv
glMultiTexCoord4s
glMultiTexCoord4sv
glMultiTexCoord4x
glMultiTexCoordP1ui
glMultiTexCoordP1uiv
glMultiTexCoordP2ui
glMultiTexCoordP2uiv
glMultiTexCoordP3ui
glMultiTexCoordP3uiv
glMultiTexCoordP4ui
glMultiTexCoordP4uiv
glNamedBufferData
glNamedBufferStorage
glNamedBufferStorageExternalEXT
glNamedBufferSubData
glNamedFramebufferDrawBuffer
glNamedFramebufferDrawBuffers
glNamedFramebufferParameteri
glNamedFramebufferReadBuffer
glNamedFramebufferRenderbuffer
glNamedFramebufferTexture
glNamedFramebufferTextureLayer
glNamedRenderbufferStorage
glNamedRenderbufferStorageMultisample
glNewList
glNormal3b
glNormal3bv
glNormal3d
glNormal3dv
glNormal3f
glNormal3fv
glNormal3i
glNormal3iv
glNormal3s
glNormal3sv
glNormal3x
glNormalP3ui
glNormalP3uiv
glNormalPointer
glOrtho
glOrthof
glOrthox
glPassThrough
glPatchParameterfv
glPixelLocalStorageBarrierANGLE
glPixelMapfv
glPixelMapuiv
glPixelMapusv
glPixelStoref
glPixelTransferf
glPixelTransferi
glPixelZoom
glPointParameterf
glPointParameterfv
glPointParameteri
glPointParameteriv
glPointParameterx
glPointParameterxv
glPointSize
glPointSizePointerOES
glPointSizex
glPolygonMode
glPolygonOffsetClamp
glPolygonOffsetClampEXT
glPolygonOffsetx
glPolygonStipple
glPopAttrib
glPopClientAttrib
glPopMatrix
glPopName
glPrimitiveRestartIndex
glPrioritizeTextures
glProgramUniform1d
glProgramUniform1dv
glProgramUniform2d
glProgramUniform2dv
glProgramUniform3d
glProgramUniform3dv
glProgramUniform4d
glProgramUniform4dv
glProgramUniformMatrix2dv
glProgramUniformMatrix2x3dv
glProgramUniformMatrix2x4dv
glProgramUniformMatrix3dv
glProgramUniformMatrix3x2dv
glProgramUniformMatrix3x4dv
glProgramUniformMatrix4dv
glProgramUniformMatrix4x2dv
glProgramUniformMatrix4x3dv
glProvokingVertex
glProvokingVertexANGLE
glPushAttrib
glPushClientAttrib
glPushMatrix
glPushName
glQueryCounter
glQueryMatrixxOES
glRasterPos2d
glRasterPos2dv
glRasterPos2f
glRasterPos2fv
glRasterPos2i
glRasterPos2iv
glRasterPos2s
glRasterPos2sv
glRasterPos3d
glRasterPos3dv
glRasterPos3f
glRasterPos3fv
glRasterPos3i
glRasterPos3iv
glRasterPos3s
glRasterPos3sv
glRasterPos4d
glRasterPos4dv
glRasterPos4f
glRasterPos4fv
glRasterPos4i
glRasterPos4iv
glRasterPos4s
glRasterPos4sv
glReadPixelsRobustANGLE
glReadnPixelsRobustANGLE
glRectd
glRectdv
glRectf
glRectfv
glRecti
glRectiv
glRects
glRectsv
glReleaseTexturesANGLE
glRenderMode
glRenderbufferStorageMultisampleANGLE
glRenderbufferStorageOES
glRequestExtensionANGLE
glRotated
glRotatef
glRotatex
glSampleCoveragex
glSampleMaskiANGLE
glSamplerParameterIivRobustANGLE
glSamplerParameterIuivRobustANGLE
glSamplerParameterfvRobustANGLE
glSamplerParameterivRobustANGLE
glScaled
glScalef
glScalex
glScissorArrayv
glScissorIndexed
glScissorIndexedv
glSecondaryColor3b
glSecondaryColor3bv
glSecondaryColor3d
glSecondaryColor3dv
glSecondaryColor3f
glSecondaryColor3fv
glSecondaryColor3i
glSecondaryColor3iv
glSecondaryColor3s
glSecondaryColor3sv
glSecondaryColor3ub
glSecondaryColor3ubv
glSecondaryColor3ui
glSecondaryColor3uiv
glSecondaryColor3us
glSecondaryColor3usv
glSecondaryColorP3ui
glSecondaryColorP3uiv
glSecondaryColorPointer
glSelectBuffer
glSelectPerfMonitorCountersAMD
glShadeModel
glShaderStorageBlockBinding
glShadingRateQCOM
glSpecializeShader
glTexCoord1d
glTexCoord1dv
glTexCoord1f
glTexCoord1fv
glTexCoord1i
glTexCoord1iv
glTexCoord1s
glTexCoord1sv
glTexCoord2d
glTexCoord2dv
glTexCoord2f
glTexCoord2fv
glTexCoord2i
glTexCoord2iv
glTexCoord2s
glTexCoord2sv
glTexCoord3d
glTexCoord3dv
glTexCoord3f
glTexCoord3fv
glTexCoord3i
glTexCoord3iv
glTexCoord3s
glTexCoord3sv
glTexCoord4d
glTexCoord4dv
glTexCoord4f
glTexCoord4fv
glTexCoord4i
glTexCoord4iv
glTexCoord4s
glTexCoord4sv
glTexCoordP1ui
glTexCoordP1uiv
glTexCoordP2ui
glTexCoordP2uiv
glTexCoordP3ui
glTexCoordP3uiv
glTexCoordP4ui
glTexCoordP4uiv
glTexCoordPointer
glTexEnvf
glTexEnvfv
glTexEnvi
glTexEnviv
glTexEnvx
glTexEnvxv
glTexGend
glTexGendv
glTexGenf
glTexGenfOES
glTexGenfv
glTexGenfvOES
glTexGeni
glTexGeniOES
glTexGeniv
glTexGenivOES
glTexGenxOES
glTexGenxvOES
glTexImage1D
glTexImage2DExternalANGLE
glTexImage2DMultisample
glTexImage2DRobustANGLE
glTexImage3DMultisample
glTexImage3DRobustANGLE
glTexParameterIivRobustANGLE
glTexParameterIuivRobustANGLE
glTexParameterfvRobustANGLE
glTexParameterivRobustANGLE
glTexParameterx
glTexParameterxv
glTexStorage1D
glTexStorage2DMultisampleANGLE
glTexStorageMemFlags2DANGLE
glTexStorageMemFlags2DMultisampleANGLE
glTexStorageMemFlags3DANGLE
glTexStorageMemFlags3DMultisampleANGLE
glTexSubImage1D
glTexSubImage2DRobustANGLE
glTexSubImage3DRobustANGLE
glTextureBarrier
glTextureBuffer
glTextureBufferRange
glTextureParameterIiv
glTextureParameterIuiv
glTextureParameterf
glTextureParameterfv
glTextureParameteri
glTextureParameteriv
glTextureStorage1D
glTextureStorage2D
glTextureStorage2DMultisample
glTextureStorage3D
glTextureStorage3DMultisample
glTextureSubImage1D
glTextureSubImage2D
glTextureSubImage3D
glTextureView
glTransformFeedbackBufferBase
glTransformFeedbackBufferRange
glTranslated
glTranslatef
glTranslatex
glUniform1d
glUniform1dv
glUniform2d
glUniform2dv
glUniform3d
glUniform3dv
glUniform4d
glUniform4dv
glUniformMatrix2dv
glUniformMatrix2x3dv
glUniformMatrix2x4dv
glUniformMatrix3dv
glUniformMatrix3x2dv
glUniformMatrix3x4dv
glUniformMatrix4dv
glUniformMatrix4x2dv
glUniformMatrix4x3dv
glUniformSubroutinesuiv
glUnmapNamedBuffer
glVertex2d
glVertex2dv
glVertex2f
glVertex2fv
glVertex2i
glVertex2iv
glVertex2s
glVertex2sv
glVertex3d
glVertex3dv
glVertex3f
glVertex3fv
glVertex3i
glVertex3iv
glVertex3s
glVertex3sv
glVertex4d
glVertex4dv
glVertex4f
glVertex4fv
glVertex4i
glVertex4iv
glVertex4s
glVertex4sv
glVertexArrayAttribBinding
glVertexArrayAttribFormat
glVertexArrayAttribIFormat
glVertexArrayAttribLFormat
glVertexArrayBindingDivisor
glVertexArrayElementBuffer
glVertexArrayVertexBuffer
glVertexArrayVertexBuffers
glVertexAttrib1d
glVertexAttrib1dv
glVertexAttrib1s
glVertexAttrib1sv
glVertexAttrib2d
glVertexAttrib2dv
glVertexAttrib2s
glVertexAttrib2sv
glVertexAttrib3d
glVertexAttrib3dv
glVertexAttrib3s
glVertexAttrib3sv
glVertexAttrib4Nbv
glVertexAttrib4Niv
glVertexAttrib4Nsv
glVertexAttrib4Nub
glVertexAttrib4Nubv
glVertexAttrib4Nuiv
glVertexAttrib4Nusv
glVertexAttrib4bv
glVertexAttrib4d
glVertexAttrib4dv
glVertexAttrib4iv
glVertexAttrib4s
glVertexAttrib4sv
glVertexAttrib4ubv
glVertexAttrib4uiv
glVertexAttrib4usv
glVertexAttribDivisorANGLE
glVertexAttribI1i
glVertexAttribI1iv
glVertexAttribI1ui
glVertexAttribI1uiv
glVertexAttribI2i
glVertexAttribI2iv
glVertexAttribI2ui
glVertexAttribI2uiv
glVertexAttribI3i
glVertexAttribI3iv
glVertexAttribI3ui
glVertexAttribI3uiv
glVertexAttribI4bv
glVertexAttribI4sv
glVertexAttribI4ubv
glVertexAttribI4usv
glVertexAttribL1d
glVertexAttribL1dv
glVertexAttribL2d
glVertexAttribL2dv
glVertexAttribL3d
glVertexAttribL3dv
glVertexAttribL4d
glVertexAttribL4dv
glVertexAttribLFormat
glVertexAttribLPointer
glVertexAttribP1ui
glVertexAttribP1uiv
glVertexAttribP2ui
glVertexAttribP2uiv
glVertexAttribP3ui
glVertexAttribP3uiv
glVertexAttribP4ui
glVertexAttribP4uiv
glVertexP2ui
glVertexP2uiv
glVertexP3ui
glVertexP3uiv
glVertexP4ui
glVertexP4uiv
glVertexPointer
glViewportArrayv
glViewportIndexedf
glViewportIndexedfv
glWeightPointerOES
glWindowPos2d
glWindowPos2dv
glWindowPos2f
glWindowPos2fv
glWindowPos2i
glWindowPos2iv
glWindowPos2s
glWindowPos2sv
glWindowPos3d
glWindowPos3dv
glWindowPos3f
glWindowPos3fv
glWindowPos3i
glWindowPos3iv
glWindowPos3s
glWindowPos3sv
wglChoosePixelFormat
wglCopyContext
wglCreateContext
wglCreateLayerContext
wglDeleteContext
wglDescribeLayerPlane
wglDescribePixelFormat
wglGetCurrentContext
wglGetCurrentDC
wglGetEnhMetaFilePixelFormat
wglGetLayerPaletteEntries
wglGetPixelFormat
wglGetProcAddress
wglMakeCurrent
wglRealizeLayerPalette
wglSetLayerPaletteEntries
wglSetPixelFormat
wglShareLists
wglSwapBuffers
wglSwapLayerBuffers
wglUseFontBitmaps
wglUseFontBitmapsA
wglUseFontBitmapsW
wglUseFontOutlines
wglUseFontOutlinesA
wglUseFontOutlinesW
Invalid buffer target.
Object cannot be used because it has not been generated.
Textarget must match the texture target type. Requested: %d Texture's: %d label: %s
Cannot have negative start.
Negative count.
Not enough space in bound transform feedback buffers.
Draw framebuffer is incomplete
Integer overflow.
Offset must be a multiple of the passed in datatype.
Negative offset.
No element array buffer and no pointer.
Insufficient buffer size.
Element value exceeds maximum element index.
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
Invalid enum provided.
Cannot have negative stride.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
Client data cannot be used with a non-default vertex array object.
GL_FIXED is not supported in WebGL.
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid type.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
Operation not permitted while pixel local storage is active.
GL_ANDROID_extension_pack_es31a
GL_ANGLE_base_vertex_base_instance_shader_builtin
GL_ANGLE_clip_cull_distance
GL_ANGLE_multi_draw
GL_ANGLE_shader_pixel_local_storage
GL_ANGLE_texture_multisample
GL_APPLE_clip_distance
GL_ARB_texture_rectangle
GL_ARM_shader_framebuffer_fetch
GL_EXT_blend_func_extended
GL_EXT_clip_cull_distance
GL_EXT_draw_buffers
GL_EXT_frag_depth
GL_EXT_geometry_shader
GL_OES_geometry_shader
GL_OES_shader_io_blocks
GL_EXT_shader_io_blocks
GL_EXT_gpu_shader5
GL_EXT_primitive_bounding_box
GL_OES_primitive_bounding_box
GL_EXT_separate_shader_objects
GL_EXT_shader_framebuffer_fetch
GL_EXT_shader_framebuffer_fetch_non_coherent
GL_EXT_shader_non_constant_global_initializers
GL_EXT_shader_texture_lod
GL_EXT_shadow_samplers
GL_EXT_tessellation_shader
GL_EXT_texture_buffer
GL_EXT_texture_cube_map_array
GL_EXT_YUV_target
GL_KHR_blend_equation_advanced
GL_NV_EGL_stream_consumer_external
GL_NV_shader_framebuffer_fetch
GL_NV_shader_noperspective_interpolation
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_OES_sample_variables
GL_OES_shader_multisample_interpolation
GL_OES_shader_image_atomic
GL_OES_standard_derivatives
GL_OES_texture_3D
GL_OES_texture_buffer
GL_OES_texture_cube_map_array
GL_OES_texture_storage_multisample_2d_array
GL_OVR_multiview
GL_OVR_multiview2
GL_WEBGL_video_texture
ANDROID_extension_pack_es31a
ANGLE_base_vertex_base_instance_shader_builtin
ANGLE_clip_cull_distance
ANGLE_multi_draw
ANGLE_shader_pixel_local_storage
ANGLE_texture_multisample
APPLE_clip_distance
ARB_texture_rectangle
ARM_shader_framebuffer_fetch
EXT_blend_func_extended
EXT_clip_cull_distance
EXT_draw_buffers
EXT_frag_depth
EXT_geometry_shader
OES_geometry_shader
OES_shader_io_blocks
EXT_shader_io_blocks
EXT_gpu_shader5
EXT_primitive_bounding_box
OES_primitive_bounding_box
EXT_separate_shader_objects
EXT_shader_framebuffer_fetch
EXT_shader_framebuffer_fetch_non_coherent
EXT_shader_non_constant_global_initializers
EXT_shader_texture_lod
EXT_shadow_samplers
EXT_tessellation_shader
EXT_texture_buffer
EXT_texture_cube_map_array
EXT_YUV_target
KHR_blend_equation_advanced
NV_EGL_stream_consumer_external
NV_shader_framebuffer_fetch
NV_shader_noperspective_interpolation
OES_EGL_image_external
OES_EGL_image_external_essl3
OES_sample_variables
OES_shader_multisample_interpolation
OES_shader_image_atomic
OES_standard_derivatives
OES_texture_3D
OES_texture_buffer
OES_texture_cube_map_array
OES_texture_storage_multisample_2d_array
OVR_multiview
OVR_multiview2
WEBGL_video_texture
require
enable
warn
disable
GL_ARB_shader_bit_encoding
GL_ARB_shading_language_packing
GL_NV_fragment_shader_interlock
GL_INTEL_fragment_shader_ordering
GL_ARB_fragment_shader_interlock
GL_NV_fence
glFenceSync failed to create a GLsync object.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/FenceNVGL.cpp
glClientWaitSync did not return GL_ALREADY_SIGNALED or GL_CONDITION_SATISFIED.
finish
GL_ARB_sync
GL_ARB_texture_rg
GL_EXT_texture_rg
GL_OES_rgb8_rgba8
GL_ARB_texture_rgb10_a2ui
GL_EXT_texture_sRGB
GL_EXT_sRGB
GL_EXT_texture_integer
GL_EXT_texture_norm16
GL_EXT_bgra
GL_EXT_texture_format_BGRA8888
GL_EXT_texture_type_2_10_10_10_REV
GL_EXT_packed_float
GL_EXT_packed_float GL_ARB_color_buffer_float
GL_EXT_color_buffer_float
GL_EXT_texture_shared_exponent
GL_ARB_texture_rg ARB_texture_float
GL_ARB_texture_rg GL_ARB_texture_float GL_ARB_color_buffer_float
GL_OES_texture_half_float GL_EXT_texture_rg
GL_OES_texture_half_float_linear
GL_EXT_texture_storage GL_OES_texture_half_float GL_EXT_texture_rg GL_EXT_color_buffer_half_float
GL_EXT_texture_rg GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_ARB_texture_float
GL_ARB_texture_float GL_ARB_color_buffer_float
GL_OES_texture_half_float
GL_EXT_texture_storage GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_EXT_color_buffer_half_float
GL_ARB_texture_rg GL_ARB_texture_float
GL_OES_texture_float GL_EXT_texture_rg
GL_OES_texture_float_linear
GL_OES_texture_float
GL_ARB_depth_texture
GL_OES_depth_texture
GL_OES_depth32
GL_ARB_depth_buffer_float
GL_EXT_packed_depth_stencil
GL_ARB_framebuffer_object
GL_OES_depth_texture GL_OES_packed_depth_stencil
GL_EXT_texture_sRGB_R8
GL_EXT_texture_sRGB_RG8
GL_ARB_texture_compression_rgtc
GL_EXT_texture_compression_rgtc
GL_ARB_texture_compression_bptc
GL_EXT_texture_compression_bptc
GL_ARB_ES3_compatibility
OES_compressed_EAC_R11_unsigned_texture
OES_compressed_EAC_R11_signed_texture
OES_compressed_EAC_RG11_unsigned_texture
OES_compressed_EAC_RG11_signed_texture
OES_compressed_ETC2_RGB8_texture
OES_compressed_ETC2_sRGB8_texture
OES_compressed_ETC2_punchthroughA_RGBA8_texture
OES_compressed_ETC2_punchthroughA_sRGB8_alpha_texture
OES_compressed_ETC2_RGBA8_texture
OES_compressed_ETC2_sRGB8_alpha8_texture
GL_EXT_texture_compression_s3tc
GL_EXT_texture_compression_dxt1
GL_ANGLE_texture_compression_dxt3
GL_ANGLE_texture_compression_dxt5
GL_EXT_texture_compression_s3tc_srgb
GL_EXT_texture_compression_s3tc GL_NV_sRGB_formats
GL_OES_compressed_ETC1_RGB8_texture
GL_KHR_texture_compression_astc_ldr
GL_OES_texture_compression_astc
GL_IMG_texture_compression_pvrtc
GL_IMG_texture_compression_pvrtc GL_EXT_pvrtc_sRGB
GL_ARB_ES2_compatibility
Framebuffer is incomplete: Framebuffer is surfaceless.
Framebuffer is incomplete: Internal error.
Framebuffer is incomplete: Depth stencil texture in color attachment.
Framebuffer is incomplete: Attachments have inconsistent bit plane counts.
Framebuffer is incomplete: If one attachment is layered, all must be layered.
Framebuffer is incomplete: If an attachments are layered, they must all be the same texture type.
Framebuffer is incomplete: Depth attachment has no depth bits.
Framebuffer is incomplete: Stencil attachment has no stencil bits.
Framebuffer is incomplete: Depth and stencil attachments are not the same.
Framebuffer is incomplete: WebGL depth stencil state is inconsistent.
Framebuffer is incomplete: Depth stencil attachment has no depth bits or no stencil bits.
Framebuffer is incomplete: Stencil attachment has depth bits.
Framebuffer is incomplete: No attachments and default size is zero.
Framebuffer is incomplete: Attachments are not all the same size.
Framebuffer is incomplete: All textures must have fixed samples if paired with multisample renderbuffers.
Framebuffer is incomplete: All attachments must be unique.
Framebuffer is incomplete: Attachment has zero size.
Framebuffer is incomplete: Attachment is not renderable.
Framebuffer is incomplete: Attachment layer is greater than texture layer count.
Framebuffer is incomplete: Attachment depth is greater than MAX_FRAMEBUFFER_LAYERS.
Framebuffer is incomplete: Attachment is an incomplete cube map.
Framebuffer is incomplete: Attachment level is not in the [base level, max level] range.
Framebuffer is incomplete: Attachment level not equal to the base level and the texture is not mipmap complete.
Framebuffer is incomplete: Attachment samples are greater than the maximum supported samples for this format.
Framebuffer is incomplete: Attachments have inconsistent fixed sample locations.
Framebuffer is incomplete: Attachments have different sample counts.
Framebuffer is incomplete: Depth stencil sample count must be divisible by the color sample count.
Framebuffer is incomplete: Attachments have inconsistent multiview enabled state.
Framebuffer is incomplete: Attachments have inconsistent multiview view counts.
Framebuffer is incomplete: Attachments have inconsistent multiview base view.
glReadPixels: GL_IMPLEMENTATION_COLOR_READ_FORMAT advertised by the driver is not handled by RGBA16 readPixels workaround.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/FramebufferGL.cpp
readPixels
checkStatus
GL framebuffer returned incomplete: 
Framebuffer is incomplete: Driver does not support this framebuffer configuration.
readPixelsRowByRow
readPixelsAllAtOnce
Initialize
RearrangeEXTTextureNorm16Pixels
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/FrameBufferMtl.mm
Framebuffer is incomplete: Mismatched attachment sizes are unsupported.
Framebuffer is incomplete: Separate depth and stencil buffers are unsupported.
Framebuffer is incomplete: The total number of color bits exceeds the number of output bits supported.
checkPackedDepthStencilAttachment
Packed depth stencil texture/buffer must not be mixed with other texture/buffer.
readPixelsImpl
readPixelsToPBO
readPixelsToBuffer
v8@?0
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/FunctionsEAGL.mm
OpenGLESLibrary_block_invoke
! Assert failed in 
frameworkLibrary
! Message: 
Unable to load OpenGLES.framework
EAGLContext
initEAGLContext_block_invoke
classEAGLContext
objc_getClass failed for EAGLContext
Missing shader object
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/GLES1Renderer.cpp
compileShader
Internal GLES 1 shader compile failed. Info log: 
GLES1Renderer shader compile failed.
Missing program object
linkProgram
Internal GLES 1 shader link failed. Info log: 
GLES1Renderer program link failed.
#define 
const int 
[kMaxTexUnits] = int[kMaxTexUnits](
bool 
[kMaxTexUnits] = bool[kMaxTexUnits](
[kMaxLights] = bool[kMaxLights](
[kMaxClipPlanes] = bool[kMaxClipPlanes](
enable_lighting
enable_color_material
enable_draw_texture
point_rasterization
enable_rescale_normal
enable_normalize
light_model_two_sided
light_enables
enable_fog
enable_clip_planes
point_sprite_enabled
enable_alpha_test
shade_model_flat
enable_texture_2d
enable_texture_cube_map
texture_format
point_sprite_coord_replace
clip_plane_enables
texture_env_mode
combine_rgb
combine_alpha
src0_rgb
src0_alpha
src1_rgb
src1_alpha
src2_rgb
src2_alpha
op0_rgb
op0_alpha
op1_rgb
op1_alpha
op2_rgb
op2_alpha
alpha_func
fog_mode
#extension GL_EXT_shader_framebuffer_fetch : require
#extension GL_EXT_shader_framebuffer_fetch_non_coherent : require
pointsize
texcoord
projection
modelview
texture_matrix
modelview_invtr
tex_sampler
tex_cube_sampler
texture_env_color
texture_env_rgb_scale
texture_env_alpha_scale
alpha_test_ref
material_ambient
material_diffuse
material_specular
material_emissive
material_specular_exponent
light_model_scene_ambient
light_ambients
light_diffuses
light_speculars
light_positions
light_directions
light_spotlight_exponents
light_spotlight_cutoff_angles
light_attenuation_consts
light_attenuation_linears
light_attenuation_quadratics
fog_density
fog_start
fog_end
fog_color
clip_planes
logic_op
point_size_min
point_size_max
point_distance_attenuation
draw_texture_coords
draw_texture_dims
draw_texture_normalized_crop_rect
GL_KHR_blend_equation_advanced
GL_OES_compressed_EAC_R11_signed_texture
GL_OES_compressed_EAC_R11_unsigned_texture
GL_OES_compressed_EAC_RG11_signed_texture
GL_OES_compressed_EAC_RG11_unsigned_texture
GL_EXT_compressed_ETC1_RGB8_sub_texture
GL_OES_compressed_ETC2_punchthroughA_RGBA8_texture
GL_OES_compressed_ETC2_punchthroughA_sRGB8_alpha_texture
GL_OES_compressed_ETC2_RGB8_texture
GL_OES_compressed_ETC2_RGBA8_texture
GL_OES_compressed_ETC2_sRGB8_alpha8_texture
GL_OES_compressed_ETC2_sRGB8_texture
GL_OES_compressed_paletted_texture
GL_OES_depth24
GL_NV_depth_buffer_float2
GL_ANGLE_depth_texture
GL_OES_depth_texture_cube_map
GL_EXT_EGL_image_array
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_EXT_EGL_image_external_wrap_modes
GL_EXT_EGL_image_storage
GL_NV_EGL_stream_consumer_external
GL_OES_EGL_sync
GL_OES_element_index_uint
GL_EXT_external_buffer
GL_OES_fbo_render_mipmap
GL_EXT_float_blend
GL_EXT_frag_depth
GL_ANGLE_framebuffer_blit
GL_MESA_framebuffer_flip_y
GL_ANGLE_instanced_arrays
GL_EXT_multisample_compatibility
GL_EXT_multisampled_render_to_texture2
GL_KHR_no_error
GL_OES_packed_depth_stencil
GL_ANGLE_pack_reverse_row_order
GL_NV_pack_subimage
GL_AMD_performance_monitor
GL_NV_pixel_buffer_object
GL_EXT_polygon_offset_clamp
GL_EXT_protected_textures
GL_EXT_pvrtc_sRGB
GL_NV_read_depth
GL_NV_read_depth_stencil
GL_EXT_read_format_bgra
GL_NV_read_stencil
GL_KHR_robust_buffer_access_behavior
GL_NV_robustness_video_memory_purge
GL_EXT_shader_framebuffer_fetch
GL_OES_shader_io_blocks
GL_EXT_shader_non_constant_global_initializers
GL_NV_shader_noperspective_interpolation
GL_EXT_shader_texture_lod
GL_QCOM_shading_rate
GL_EXT_shadow_samplers
GL_EXT_sRGB_write_control
GL_OES_standard_derivatives
GL_OES_surfaceless_context
GL_ARB_sync
GL_KHR_texture_compression_astc_hdr
GL_KHR_texture_compression_astc_sliced_3d
GL_IMG_texture_compression_pvrtc2
GL_OES_texture_cube_map_array
GL_EXT_texture_filter_anisotropic
GL_EXT_texture_format_sRGB_override
GL_OES_texture_half_float
GL_OES_texture_npot
GL_EXT_texture_sRGB_decode
GL_OES_texture_stencil8
GL_ANGLE_texture_usage
GL_ANGLE_translated_shader_source
GL_EXT_unpack_subimage
GL_OES_vertex_half_float
GL_OES_vertex_type_10_10_10_2
GL_WEBGL_video_texture
GL_EXT_YUV_target
GL_ANGLE_base_vertex_base_instance
GL_ANGLE_base_vertex_base_instance_shader_builtin
GL_CHROMIUM_bind_generates_resource
GL_CHROMIUM_bind_uniform_location
GL_ANGLE_client_arrays
GL_CHROMIUM_color_buffer_float_rgb
GL_CHROMIUM_color_buffer_float_rgba
GL_ANGLE_compressed_texture_etc
GL_CHROMIUM_copy_compressed_texture
GL_CHROMIUM_copy_texture
GL_ANGLE_copy_texture_3d
GL_CHROMIUM_framebuffer_mixed_samples
GL_ANGLE_framebuffer_multisample
GL_ANGLE_get_image
GL_ANGLE_get_serialized_context_string
GL_ANGLE_get_tex_level_parameter
GL_ANGLE_logic_op
GL_CHROMIUM_lose_context
GL_ANGLE_lossy_etc_decode
GL_ANGLE_memory_object_flags
GL_ANGLE_memory_object_fuchsia
GL_ANGLE_memory_size
GL_ANGLE_multi_draw
GL_ANGLE_multiview_multisample
GL_ANGLE_program_binary
GL_ANGLE_program_cache_control
GL_ANGLE_provoking_vertex
GL_ANGLE_read_only_depth_stencil_feedback_loops
GL_ANGLE_relaxed_vertex_attribute_type
GL_ANGLE_request_extension
GL_ANGLE_rgbx_internal_format
GL_ANGLE_robust_client_memory
GL_ANGLE_robust_fragment_shader_output
GL_ANGLE_robust_resource_initialization
GL_ANGLE_semaphore_fuchsia
GL_ANGLE_shader_pixel_local_storage
GL_ANGLE_shader_pixel_local_storage_coherent
GL_CHROMIUM_sync_query
GL_ANGLE_texture_external_update
GL_CHROMIUM_texture_filtering_hint
GL_ANGLE_texture_multisample
GL_ANGLE_texture_rectangle
GL_ANGLE_vulkan_image
GL_ANGLE_webgl_compatibility
GL_ANGLE_yuv_internal_format
GL_OES_draw_texture
GL_OES_framebuffer_object
GL_OES_matrix_palette
GL_OES_point_size_array
GL_OES_point_sprite
GL_OES_query_matrix
GL_OES_texture_cube_map
Context has been lost.
v8@?0
Illegal character at fieldname start
fatal flex scanner internal error--no action found
out of dynamic memory in yy_create_buffer()
yyset_column called with no buffer
GL_FRAGMENT_PRECISION_HIGH
fatal flex scanner internal error--end of buffer missed
fatal error - scanner input buffer overflow
out of dynamic memory in yy_get_next_buffer()
Input buffer overflow
out of dynamic memory in yyensure_buffer_stack()
Illegal use of reserved word
Unsigned integers are unsupported prior to GLSL ES 3.00
Integer overflow
Floating-point suffix unsupported prior to GLSL ES 3.00
Float overflow
unsupported value
methods supported in GLSL ES 3.00 and above only
bit-wise operator supported in GLSL ES 3.00 and above only
integer modulus operator supported in GLSL ES 3.00 and above only
interface blocks supported in GLSL ES 3.00 and above only
cannot be a parameter type except for '(void)'
void
first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
unsupported interpolation qualifier
noperspective
layout
 supported in vertex shaders only
 supported in GLSL ES 1.00 only
storage qualifier supported in GLSL ES 3.00 and above only
centroid
unsupported storage qualifier
patch
storage qualifier supported in GLSL ES 3.10 and above only
buffer
 supported in compute shaders only
shared
sample
implicitly sized array supported in GLSL ES 3.00 and above only
arrays of arrays supported in GLSL ES 3.10 and above only
unsupported type
yuvCscStandardEXT
__samplerCubeArray
__samplerBuffer
__isamplerCubeArray
__isamplerBuffer
__usamplerCubeArray
__usamplerBuffer
__samplerCubeArrayShadow
samplerVideoWEBGL
__samplerExternal2DY2YEXT
__imageCubeArray
__iimageCubeArray
__uimageCubeArray
__imageBuffer
__iimageBuffer
__uimageBuffer
__pixelLocalANGLE
__ipixelLocalANGLE
__upixelLocalANGLE
syntax error
memory exhausted
itu_601
itu_601_full_range
itu_709
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/HandleAllocator.cpp
allocate
HandleAllocator::allocate reusing 
HandleAllocator::allocate allocating 
release
HandleAllocator::release releasing 
reserve
HandleAllocator::reserve reserving 
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ImageMtl.mm
ValidateClientBuffer
Unrecognized format
WARNING: 
ERROR: 
UNKOWN ERROR: 
invariant 
readonly 
writeonly 
coherent 
restrict 
volatile 
array[
] of 
 matrix of 
-component vector of 
 <anonymous>
 (specifier)
Temporary
Global
const
uniform
inout
VertexID
Position
PointSize
DrawID
FragCoord
FrontFacing
HelperInvocation
PointCoord
FragColor
FragData
FragDepth
SecondaryFragColorEXT
SecondaryFragDataEXT
ViewIDOVR
ViewportIndex
LayerOut
LayerIn
LastFragColor
LastFragData
smooth out
smooth centroid out
flat out
noperspective out
smooth in
flat in
noperspective in
smooth centroid in
flat
smooth
NumWorkGroups
WorkGroupSize
WorkGroupID
LocalInvocationID
GlobalInvocationID
LocalInvocationIndex
readonly
writeonly
gl_PrimitiveIDIn
gl_InvocationID
gl_PrimitiveID
precise
ClipDistance
CullDistance
sample in
sample out
SampleID
SamplePosition
SampleMaskIn
SampleMask
NumSamples
patch in
patch out
PatchVerticesIn
TessLevelOuter
TessLevelInner
BoundingBox
TessCoord
__pixel_localEXT
unknown qualifier
highp
mediump
lowp
casting a negative float to uint is undefined
Zero divided by zero during constant folding generated NaN
Divide by zero during constant folding
Infinity divided by infinity during constant folding generated NaN
Constant folded division overflowed to infinity
Divide by zero error during constant folding
Negative modulus operator operand encountered during constant folding. Results are undefined.
operation result is undefined for the values passed in
instanceIdMod
gl_VertexID
Failed to set pixel unpack state.
Failed to set pixel pack state.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/IOSurfaceSurfaceEAGL.mm
attachToFramebuffer
IOSurfaces with OpenGL ES not supported on iOS Simulator
Failed to initialize IOSurface alpha channel.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/IOSurfaceSurfaceMtl.mm
ValidateAttributes
IOSurface bytes per elements does not match the pbuffer internal format.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/image_util/loadimage_astc.cpp
LoadASTCToRGBA8Inner
Trying to decompress ASTC without having ASTC support built.
ASTC decompression failed: 
Error decompressing program binary data fetched from cache.
Failed to load program binary from cache.
Error compressing binary data.
Error decompressing shader binary data from cache.
GPU.ANGLE.ShaderCache.LoadBinarySuccess
Error compressing shader binary data for insertion into cache.
GPU.ANGLE.ShaderCache.ShaderBinarySizeBytes
originalToModified
modifiedToOriginal
original
modified
flatten
v16@?0@"<MTLCommandBuffer>"8
Invalid ASCII string
Metal backend encountered an error
Metal backend encountered an error: 
[[attribute(
        
ANGLE_
xfbBuffer
.ANGLE_xfbBufferOffsets[
] + (gl_VertexID + (ANGLE_instanceIdMod - ANGLE_baseInstance) * 
.ANGLE_xfbVerticesPerInstance) * 
] = 
ANGLE_vertexOut.
device float* ANGLE_
#if TRANSFORM_FEEDBACK_ENABLED
    {
    }
#endif
OcclusionQueryPool
clearIntFS
clearUIntFS
clearFloatFS
blitIntFS
blitUIntFS
blitFloatFS
copyTextureFloatToUIntFS
readFromBufferToIntTexture
writeFromIntTextureToBuffer
readFromBufferToUIntTexture
writeFromUIntTextureToBuffer
readFromBufferToFloatTexture
writeFromFloatTextureToBuffer
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_render_utils.mm
handleError
clearVS
kNumColorOutputs
blitVS
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
blitDepthStencilFS
blitDepthFS
blitStencilFS
kSourceTexture2Type
blitStencilToBufferCS
kSourceBufferAligned
convertIndexU8ToU16
convertIndexU16
convertIndexU32
kSourceIndexIsU8
kSourceIndexIsU16
kSourceIndexIsU32
genTriFanIndicesFromArray
genLineLoopIndicesFromArray
Index offset is too large
generateTriFanBufferFromElementsArray
genTriFanIndicesFromElements
generateLineLoopBufferFromElementsArray
genLineLoopIndicesFromElements
generateLineLoopLastSegmentFromElementsArray
kCombineWithExistingResult
combineVisibilityResult
generate3DMipmaps
generate2DMipmaps
generate2DArrayMipmaps
generateCubeMipmaps
kCopyFormatType
kCopyTextureType
expandVertexFormatComponentsCS
expandVertexFormatComponentsVS
convertToFloatVertexFormatCS
convertToFloatVertexFormatVS
EnsureSpecializedComputePipelineInitialized
Internal error: 
EnsureComputePipelineInitialized
EnsureSpecializedVertexShaderOnlyPipelineCacheInitialized
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_resources.mm
MakeTexture
Failed to allocate host memory
resize
MakeBufferWithSharedMemOpt
MakeBufferWithResOpt
Render pipeline without vertex shader is invalid.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_state_cache.mm
createRenderPipelineState
createComputePipelineState
Render pipeline requires at least one render target for this device.
ValidateRenderPipelineState
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_utils.mm
Failed to create a scratch index buffer for GL_TRIANGLE_FAN, too many indices required.
TriangleFanBoundCheck
Internal error compiling Metal shader:
CreateMslShader
Apple
Radeon
Intel
Geforce
Quadro
main
.length()
textureVideoWEBGL
gl_FragDepthEXT
webgl_FragColor
webgl_FragData
gl_SecondaryFragColorEXT
webgl_SecondaryFragColor
gl_SecondaryFragDataEXT
webgl_SecondaryFragData
texture2DGradARB
texture2DProjGradARB
textureCubeGradARB
texture3DProj
shadow2DEXT
shadow2DProjEXT
precise 
uintBitsToFloat(
index = 
noncoherent
offset = 
layout(
location = 
binding = 
column_major
row_major
 += 
 -= 
 /= 
 %= 
 *= 
 <<= 
 >>= 
 &= 
 ^= 
 |= 
 << 
 >> 
 == 
 != 
 <= 
 >= 
 || 
 ^^ 
 && 
).length())
) ? (
) : (
case (
discard
return 
#define
#endif
#ifdef
packed
std140
std430
smooth out 
flat out 
noperspective out 
centroid out 
smooth in 
flat in 
noperspective in 
centroid in 
#pragma STDGL invariant(all)
layout (
invocations = 
) in;
max_vertices = 
) out;
layout (early_fragment_tests) in;
layout (local_size_x=
, local_size_y=
, local_size_z=
#if defined(GL_ARB_shader_viewport_layer_array)
#extension GL_ARB_shader_viewport_layer_array : require
#elif defined(GL_NV_viewport_array2)
#extension GL_NV_viewport_array2 : require
#endif
#extension GL_OVR_multiview
layout(num_views=
rgba32f
rgba16f
r32f
rgba32ui
rgba16ui
rgba8ui
r32ui
rgba32i
rgba16i
rgba8i
r32i
rgba8
rgba8_snorm
unknown internal image format
unknown color space conversion standard
points
lines
triangles
lines_adjacency
triangles_adjacency
line_strip
triangle_strip
unknown geometry shader primitive type
(symbol id 
const bool
 (const float)
 (const int)
 (const uint)
 (const yuvCscStandardEXT)
Unknown constant
vector swizzle (
comma
move second child to first child
initialize first child with second child
add second child into first child
subtract second child into first child
multiply second child into first child
matrix mult second child into first child
vector scale second child into first child
matrix scale second child into first child
divide second child into first child
modulo second child into first child
bit-wise shift first child left by second child
bit-wise shift first child right by second child
bit-wise and second child into first child
bit-wise xor second child into first child
bit-wise or second child into first child
direct index
indirect index
direct index for structure
direct index for interface block
subtract
component-wise multiply
divide
modulo
bit-wise shift left
bit-wise shift right
bit-wise and
bit-wise xor
bit-wise or
Compare Equal
Compare Not Equal
Compare Less Than
Compare Greater Than
Compare Less Than or Equal
Compare Greater Than or Equal
vector-scale
vector-times-matrix
matrix-times-vector
matrix-scale
matrix-multiply
logical-or
logical-xor
logical-and
<unknown op>
 (field '
Negate value
Positive sign
negation
bit-wise not
Post-Increment
Post-Decrement
Pre-Increment
Pre-Decrement
Array length
component-wise not
Call a built-in function
 (internal function)
 (symbol id 
Ternary selection
Condition
true case
false case
If test
true case is null
Switch
Default
Case
Function Prototype
parameter: 
Function Definition:
node is still EOpNull!
Call a user-defined function
Call an internal function with raw implementation
Construct
component-wise equal
component-wise not equal
component-wise less than
component-wise greater than
component-wise less than or equal
component-wise greater than or equal
dot product
cross product
Code block
Precise Declaration:
Invariant Declaration:
Declaration
Loop with condition 
not 
tested first
Loop Condition
No loop condition
Loop Body
No loop body
Loop Terminal Expression
Branch: Kill
Branch: Break
Branch: Continue
Branch: Return
Branch: Unknown Branch
 with expression
Vertex
Tessellation control
Tessellation evaluation
Geometry
Fragment
Compute
GL_INVALID_ENUM
GL_VERTEX_SHADER
GL_TESS_CONTROL_SHADER_EXT
GL_TESS_EVALUATION_SHADER_EXT
GL_GEOMETRY_SHADER_EXT
GL_FRAGMENT_SHADER
GL_COMPUTE_SHADER
extension is not supported
extension is disabled
extension is being used
illegal vector field selection
vector field selection out of range
illegal - vector component fields not from the same set
illegal discard when pixel local storage is declared
discard
illegal return from main when pixel local storage is declared
return
value not assignable when pixel local storage is declared
gl_SampleMask
cannot convert from '
' to '
wrong operand type - no operation '
' exists that takes an operand of type 
 (or there is no acceptable conversion)
wrong operand types - no operation '
' exists that takes a left-hand operand of type '
' and a right operand of type '
' (or there is no acceptable conversion)
illegal type for precision qualifier
No precision specified for (float)
No precision specified (int)
No precision specified
 l-value of swizzle cannot have duplicate components
can't modify a readonly variable
 l-value required
can't modify a const
can't modify an attribute
can't modify an input
can't modify a uniform
can't modify a varying
can't modify gl_FragCoord
can't modify gl_FrontFacing
can't modify gl_HelperInvocation
can't modify gl_PointCoord
can't modify gl_NumWorkGroups
can't modify gl_WorkGroupSize
can't modify gl_WorkGroupID
can't modify gl_LocalInvocationID
can't modify gl_GlobalInvocationID
can't modify gl_LocalInvocationIndex
can't modify gl_ViewID_OVR
can't modify work group size variable
can't modify any member in gl_in
can't modify gl_PrimitiveIDIn
can't modify gl_InvocationID
can't modify gl_PrimitiveID in a fragment shader
can't modify gl_Layer in a fragment shader
can't modify gl_SampleID
can't modify gl_SampleMaskIn
can't modify gl_SamplePosition
can't modify gl_ClipDistance in a fragment shader
can't modify gl_CullDistance in a fragment shader
can't modify void
can't modify a variable with type 
l-value required
constant expression required
integer expression required
only allowed at global scope
reserved built-in name
webgl_
_webgl_
identifiers containing two consecutive underscores (__) are reserved as possible future keywords
all identifiers containing two consecutive underscores (__) are reserved - unintented behaviors are possible
constructor does not have any arguments
constructor
cannot convert a variable with type 
cannot convert a variable with writeonly
cannot convert a void
array constructor needs one argument per array element
constructing from a non-dereferenced array
Array constructor argument has an incorrect type
Number of constructor parameters does not match the number of structure fields
Structure constructor arguments do not match structure fields
a struct cannot be used as a constructor argument for this type
constructing matrix from matrix can only take one argument
not enough data provided for construction
too many arguments
illegal use of type 'void'
boolean expression expected
 (structure contains a sampler)
location must only be specified for a single input or output variable
location
invalid layout qualifier: only valid on program inputs and outputs
invalid layout qualifier: only valid on shader inputs, outputs, and uniforms
The std430 layout is supported only for shader storage blocks.
opaque types cannot be output parameters
array size must be a constant integer expression
array size must be non-negative
array size must be greater than zero
array size too large
cannot declare arrays of this qualifier
cannot declare arrays of arrays
vertex shader output cannot be an array of arrays
fragment shader input cannot be an array of arrays
fragment shader output cannot be an array of arrays
cannot declare arrays of structs of this qualifier
structures containing arrays may not be declared constant since they cannot be initialized
variables with qualifier 'const' must be initialized
implicitly sized arrays only allowed for tessellation shaders or geometry shader inputs
If index layout qualifier is specified for a fragment output, location must also be specified.
index
gl_LastFragData
gl_MaxDrawBuffers
redeclaration of gl_LastFragData as an array of arrays
redeclaration of gl_LastFragData with size != gl_MaxDrawBuffers
gl_ClipDistance
gl_MaxClipDistances
redeclaration of gl_ClipDistance as an array of arrays
redeclaration of gl_ClipDistance with size > gl_MaxClipDistances
gl_CullDistance
gl_MaxCullDistances
redeclaration of gl_CullDistance as an array of arrays
redeclaration of gl_CullDistance with size > gl_MaxCullDistances
gl_Position
gl_Position can only be redeclared as vec4
gl_PointSize
gl_PointSize can only be redeclared as float
When EXT_separate_shader_objects is enabled, both gl_Position and gl_PointSize must be redeclared before either is used
redefinition
Shared memory declarations cannot have layout specified
layout
layout qualifier only valid for interface blocks
invalid layout qualifier combination
storage qualifier supported in GLSL ES 3.00 and above only
Can only be highp
atomic counter
location must not be set for atomic_uint
no binding specified
empty array declaration needs to specify a size
cannot be used with a structure
cannot declare buffer variables at global scope(outside a block)
s must be uniform
cannot be used with a yuvCscStandardEXT
internal image format requires a floating image type
internal image format requires an integer image type
internal image format requires an unsigned image type
layout qualifier
No image internal format specified
unrecognized token
Except for images with the r32f, r32i and r32ui format qualifiers, image variables must be qualified readonly and/or writeonly
undefined use of pixel local storage outside a fragment shader
pixel local storage format requires pixelLocalANGLE
pixel local storage format requires ipixelLocalANGLE
pixel local storage format requires upixelLocalANGLE
illegal pixel local storage format
pixel local storage requires a format specifier
qualifier supported in GLSL ES 3.00 and above only
invalid layout qualifier: not supported
invalid layout qualifier: only valid when used with 'in' in a compute shader global layout declaration
invalid layout qualifier: not supported before GLSL ES 3.10, except pixel local storage
invalid layout qualifier: not supported before GLSL ES 3.10
invalid layout qualifier: only valid when used with images or pixel local storage 
invalid layout qualifier: only valid when used with images
invalid layout qualifier: only valid when used with a fragment shader output in ESSL version >= 3.00 and EXT_blend_func_extended is enabled
invalid layout qualifier: only valid when used with pixel local storage
binding
invalid layout qualifier: only valid when used with opaque types or blocks
invalid layout qualifier: only valid when used with atomic counters
offset
image binding greater than gl_MaxImageUnits
sampler binding greater than maximum texture units
uniform block binding greater than MAX_UNIFORM_BUFFER_BINDINGS
shader storage block binding greater than MAX_SHADER_STORAGE_BUFFER_BINDINGS
atomic counter binding greater than gl_MaxAtomicCounterBindings
pixel local storage handles cannot be aggregated in arrays
array
pixel local storage requires a binding index
duplicate pixel local storage binding index
Uniform location out of range
Attribute location out of range
invalid layout qualifier: only valid on program outputs
invalid layout qualifier: only valid when used with 'in' in a fragment shader
early_fragment_tests
'noncoherent' qualifier must be used when GL_EXT_shader_framebuffer_fetch_non_coherent extension is used
invalid layout qualifier: only valid when used with 'gl_LastFragData' or the variable decorated with 'inout' in a fragment shader
gl_InvocationID
tessellation-control per-vertex output l-value must be indexed with gl_InvocationID
Writeonly value cannot be passed for 'in' or 'inout' parameters.
assign
Constant value cannot be passed for 'out' or 'inout' parameters.
Cannot be qualified as invariant.
invariant
invalid layout qualifier: blending equation qualifiers are only permitted on the fragment 'out' qualifier 
blend_support_qualifier
undeclared identifier
variable expected
It is an error to use gl_WorkGroupSize before declaring the local group size
gl_WorkGroupSize
invalid or missing storage qualifier
assigning non-constant to '
global variable initializers must be constant expressions
global variable initializers should be constant expressions (uniforms and globals are allowed in global initializers for legacy compatibility)
 cannot initialize this type of qualifier 
not supported
first-class array
cannot be bool or int
'in' can be only used to specify the local group size
cannot be bool
cannot be array
cannot be matrix
must use 'flat' interpolation here
cannot be an array of structures
cannot be a structure containing an array
cannot be a structure containing a structure
cannot be a structure containing a bool
Local variables can only use the const storage qualifier.
Only allowed with shader storage blocks, variables declared within shader storage blocks and variables declared as image types.
coherent
restrict
volatile
Offset overlapping
Offset must be multiple of 4
Missing a valid input primitive declaration before declaring an unsized array input
Deferred
Geometry shader input variable must be declared as an array
Tessellation interface variables must be declared as an array
If a size is specified for a tessellation control or evaluation user-defined input variable, it must match the maximum patch size (gl_MaxPatchVertices).
If a size is specified for a tessellation control user-defined per-vertex output variable, it must match the the number of vertices in the output patch.
Expected invariant or precise
invariant varying
undeclared identifier declared as invariant or precise
invariant or precise declaration specifies qualifier
invariant or precise declaration specifies precision
invariant or precise declaration specifies layout
'layout'
Requires both binding and offset
precision is not supported in fragment shader
highp
illegal type argument for default precision qualifier
Array size or input primitive declaration doesn't match the size of earlier sized array inputs.
max_vertices can only be declared in 'out' layout in a geometry shader
invalid primitive type for 'in' layout
primitive doesn't match earlier input primitive declaration
invocations contradicts to the earlier declaration
invocations can only be declared in 'in' layout in a geometry shader
invalid primitive type for 'out' layout
primitive doesn't match earlier output primitive declaration
max_vertices contradicts to the earlier declaration
No vertices specified
Duplicated vertices specified
Duplicated primitive type declaration
Duplicated vertex spacing declaration
Duplicated ordering declaration
Duplicated point type declaration
Error during layout qualifier parsing.
Work group size does not match the previous declaration
in type qualifier supported in GLSL ES 3.10 only
No local work group size specified
gl_MaxComputeWorkGroupSize
invalid value: Value must be at least 1 and no greater than 
out type qualifier supported in GLSL ES 3.10 only
Number of views does not match the previous declaration
No num_views specified
num_views greater than the value of GL_MAX_VIEWS_OVR
in type qualifier without variable declaration supported in GLSL ES 3.10 and after
only early_fragment_tests is allowed as layout qualifier when not declaring a variable
out type qualifier without variable declaration is supported in GLSL ES 3.20, or if GL_KHR_blend_equation_advanced is enabled
only blend equations are allowed as layout qualifier when not declaring a variable
out type qualifier supported in GLSL ES 3.10 and after
in type qualifier supported in GLSL ES 3.10 and after
invalid qualifier: global layout can only be set for blocks
layout qualifiers supported in GLSL ES 3.00 and after
function parameter array must be sized at compile time
duplicate function prototype declarations are not allowed
function
local function prototype declarations are not allowed
function does not return a value:
function already has a body
Function parameter type cannot be a structure definition
Name of a built-in function cannot be redeclared as function
built-in functions cannot be redefined
function must have the same return type in all of its declarations
function must have the same parameter qualifiers in all of its declarations
redefinition of a function
function cannot take any parameter(s)
main
main function cannot return a value
no qualifiers allowed for function return
s can't be function return values
structures containing arrays can't be function return values
array constructor supported in GLSL ES 3.00 and above only
constructor can't be a structure definition
cannot construct this type
function parameter array must specify a size
implicitly sized array constructor must have at least one argument
implicitly sized array of arrays constructor argument is not an array
implicitly sized array of arrays constructor argument dimensionality is too low
invalid qualifier: interface blocks must be uniform in version lower than GLSL ES 3.10
invalid qualifier: 'patch out' requires a tessellation control shader
invalid qualifier: 'patch in' requires a tessellation evaluation shader
invalid qualifier: shader IO blocks need shader io block extension
type must be an array
invalid qualifier: interface blocks must be uniform or buffer
invalid qualifier on interface block
unsized arrays are not allowed with interface blocks
array of arrays are not allowed with interface blocks
geometry shader input block array size inconsistent with primitive
array of arrays are not allowed with I/O blocks
geometry shader input blocks must be an array
unsupported type - 
 types are not allowed in interface blocks
invalid qualifier on shader storage block member
invalid qualifier on uniform block member
invalid qualifier on interface block member
invalid layout qualifier: cannot be used here
extraneous layout qualifier: only has an effect on matrix types
array members of interface blocks must specify a size
redefinition of an interface block name
redefinition in an invalid interface block
redefinition of an interface block member name
redefinition of an interface block instance name
Embedded struct definitions are not allowed
struct
Struct nesting
Reference of struct type 
 exceeds maximum allowed nesting level of 
 left of '[' is not of type array, matrix, or vector 
expression
missing input primitive declaration before indexing gl_in.
array indexes for uniform block arrays must be constant integral expressions
array indexes for shader storage block arrays must be constant integral expressions
array indexes for fragment outputs must be constant integral expressions
array index for gl_FragData must be constant zero
array index for samplers must be constant integral expressions
array indexes for image arrays must be constant integral expressions
index expression is negative
array index for gl_FragData must be zero when GL_EXT_draw_buffers is disabled
array index out of range
matrix field selection out of range
cannot apply dot operator to an array
structure has no fields
Internal Error
 no such field in structure
interface block has no fields
 no such field in interface block
 field selection requires structure or vector on left hand side
 field selection requires structure, vector, or interface block on left hand side
Only std140 layout is allowed in WebGL
invalid layout qualifier: location requires an argument
points
lines
lines_adjacency
triangles
triangles_adjacency
line_strip
triangle_strip
invalid layout qualifier
quads
isolines
equal_spacing
fractional_even_spacing
fractional_odd_spacing
point_mode
blend_support_multiply
blend_support_screen
blend_support_overlay
blend_support_darken
blend_support_lighten
blend_support_colordodge
blend_support_colorburn
blend_support_hardlight
blend_support_softlight
blend_support_difference
blend_support_exclusion
blend_support_hsl_hue
blend_support_hsl_saturation
blend_support_hsl_color
blend_support_hsl_luminosity
blend_support_all_equations
out of range: 
 must be positive
out of range: num_views must be positive
out of range: invocations must be in the range of [1, MAX_GEOMETRY_SHADER_INVOCATIONS_OES]
out of range: max_vertices must be in the range of [0, gl_MaxGeometryOutputVertices]
out of range : vertices must be in the range of [1, gl_MaxPatchVertices]
out of range: index layout qualifier can only be 0 or 1
out of range: location must be non-negative
out of range: binding must be non-negative
out of range: offset must be non-negative
local_size_x
local_size_y
local_size_z
num_views
invocations
max_vertices
vertices
storage qualifier isn't supported in compute shaders
inout
storage qualifier isn't supported in non-fragment shaders
invalid qualifier: can be used with either function parameters or the variables for fetching input attachment data
duplicate field name in structure
redefinition of a struct
invalid qualifier on struct member
disallowed type in struct
array members of structs must specify a size
init-expression in a switch statement must be a scalar integer
switch
case labels need to be inside switch statements
case
case label must have a condition
case label must be a scalar integer
case label must be constant
default labels need to be inside switch statements
default
Invalid operation for variables with an opaque type
Invalid operation for variables with writeonly
Invalid operation for structs
Invalid operation for interface blocks
array / non-array mismatch
Invalid operation for arrays
array size mismatch
undefined operation for structs containing arrays
undefined operation for structs containing samplers
dimension mismatch
comparison operator only defined for scalars
sequence operator is not allowed for void, arrays, or structs containing arrays
continue statement only allowed in loops
break statement only allowed in loops and switch statements
non-void function must return a value
discard supported in fragment shaders only
void function cannot return a value
function return is not matching type:
Texture component must be a constant expression
Component must be in the range [0;3]
Texture offsets must be a constant expression
Texture offsets must be an array of 4 elements
Texture offset must be a constant expression
Texture offset value out of valid range
first argument must be an interpolant, or interpolant-array element
The value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable.
'imageStore' cannot be used with images qualified as 'readonly'
'imageLoad' cannot be used with images qualified as 'writeonly'
'imageAtomic' cannot be used with images qualified as 'readonly'
'imageAtomic' cannot be used with images qualified as 'writeonly'
Function call discards the 'readonly' qualifier from image
Function call discards the 'writeonly' qualifier from image
Function call discards the 'coherent' qualifier from image
Function call discards the 'volatile' qualifier from image
length
invalid method
method takes no parameters
length can only be called on arrays
missing input primitive declaration before calling length on gl_in
function name expected
no matching overloaded function found
mismatching ternary operator operand types '
 and '
ternary operator is not allowed for opaque types
ternary operator is not allowed for variables with writeonly
ternary operator is not allowed for structures or arrays
ternary operator is not allowed for interface blocks
ternary operator is not allowed for void
unknown matrix packing
unknown block storage
dimension out of bounds
mediump
lowp
image
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/PbufferSurfaceEAGL.cpp
bindTexImage
PbufferSurfaceEAGL::bindTexImage
VertexInMod
VertexIn
VertexOutMod
VertexOut
FragmentInMod
FragmentIn
FragmentOutMod
FragmentOut
UserUniformsMod
UserUniforms
AngleUniformsMod
AngleUniforms
NonConstGlobalsMod
NonConstGlobals
InvocationVertexGlobalsMod
InvocationVertexGlobals
InvocationFragmentGlobalsMod
InvocationFragmentGlobals
TextureEnvsMod
TextureEnvs
ImagesMod
Images
InstanceIdMod
InstanceId
UniformBufferMod
UniformBuffer
vertexInMod
vertexIn
vertexOutMod
vertexOut
fragmentInMod
fragmentIn
fragmentOutMod
fragmentOut
userUniformsMod
userUniforms
angleUniformsMod
angleUniforms
nonConstGlobalsMod
nonConstGlobals
invocationVertexGlobalsMod
invocationVertexGlobals
invocationFragmentGlobalsMod
invocationFragmentGlobals
textureEnvsMod
textureEnvs
imagesMod
images
instanceIdMod
instanceId
uniformBufferMod
uniformBuffer
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Platform.cpp
ANGLEGetDisplayPlatform
Invalid platform method count: 
, expected 
placeholder
Invalid platform method name: 
currentTime
monotonicallyIncreasingTime
logError
logWarning
logInfo
getTraceCategoryEnabledFlag
addTraceEvent
updateTraceEventDuration
histogramCustomCounts
histogramEnumeration
histogramSparse
histogramBoolean
placeholder1
placeholder2
cacheProgram
placeholder3
postWorkerTask
#version 310 es
void main()
    gl_Position = vec4(mix(vec2(-1), vec2(1), equal(gl_VertexID & ivec2(1, 2), ivec2(0))), 0, 1);
#version 310 es
#extension GL_EXT_shader_pixel_local_storage : require
 PLS{
}pls;
layout(binding=
)uniform readonly 
image2D i
vec4 c
)uniform writeonly 
void main(){
highp ivec2 pixelCoord=ivec2(floor(gl_FragCoord.xy));
pls._
imageLoad(i
,pixelCoord)
imageStore(i
,pixelCoord,
__pixel_local_outEXT
__pixel_local_inEXT
vec4
ivec4
vec4(pls._
,0,0,1)
uvec4(pls._
__LINE__
__FILE__
__VERSION__
GL_ES
Integer overflow on line number
EOF while in a comment
out of dynamic memory in yy_create_buffer()
yyset_lineno called with no buffer
out of dynamic memory in yyensure_buffer_stack()
ANGLEGetDisplayPlatform
ANGLEResetDisplayPlatform
eglBindAPI
eglBindTexImage
eglChooseConfig
eglClientWaitSync
eglClientWaitSyncKHR
eglCopyBuffers
eglCopyMetalSharedEventANGLE
eglCreateContext
eglCreateDeviceANGLE
eglCreateImage
eglCreateImageKHR
eglCreateNativeClientBufferANDROID
eglCreatePbufferFromClientBuffer
eglCreatePbufferSurface
eglCreatePixmapSurface
eglCreatePlatformPixmapSurface
eglCreatePlatformPixmapSurfaceEXT
eglCreatePlatformWindowSurface
eglCreatePlatformWindowSurfaceEXT
eglCreateStreamKHR
eglCreateStreamProducerD3DTextureANGLE
eglCreateSync
eglCreateSyncKHR
eglCreateWindowSurface
eglDebugMessageControlKHR
eglDestroyContext
eglDestroyImage
eglDestroyImageKHR
eglDestroyStreamKHR
eglDestroySurface
eglDestroySync
eglDestroySyncKHR
eglDupNativeFenceFDANDROID
eglExportVkImageANGLE
eglForceGPUSwitchANGLE
eglGetCompositorTimingANDROID
eglGetCompositorTimingSupportedANDROID
eglGetConfigAttrib
eglGetConfigs
eglGetCurrentContext
eglGetCurrentDisplay
eglGetCurrentSurface
eglGetDisplay
eglGetError
eglGetFrameTimestampSupportedANDROID
eglGetFrameTimestampsANDROID
eglGetMscRateANGLE
eglGetNativeClientBufferANDROID
eglGetNextFrameIdANDROID
eglGetPlatformDisplay
eglGetPlatformDisplayEXT
eglGetProcAddress
eglGetSyncAttrib
eglGetSyncAttribKHR
eglGetSyncValuesCHROMIUM
eglHandleGPUSwitchANGLE
eglInitialize
eglLabelObjectKHR
eglLockSurfaceKHR
eglMakeCurrent
eglPostSubBufferNV
eglPrepareSwapBuffersANGLE
eglPresentationTimeANDROID
eglProgramCacheGetAttribANGLE
eglProgramCachePopulateANGLE
eglProgramCacheQueryANGLE
eglProgramCacheResizeANGLE
eglQueryAPI
eglQueryContext
eglQueryDebugKHR
eglQueryDeviceAttribEXT
eglQueryDeviceStringEXT
eglQueryDisplayAttribANGLE
eglQueryDisplayAttribEXT
eglQueryDmaBufFormatsEXT
eglQueryDmaBufModifiersEXT
eglQueryStreamKHR
eglQueryStreamu64KHR
eglQueryString
eglQueryStringiANGLE
eglQuerySurface
eglQuerySurface64KHR
eglQuerySurfacePointerANGLE
eglReacquireHighPowerGPUANGLE
eglReleaseDeviceANGLE
eglReleaseHighPowerGPUANGLE
eglReleaseTexImage
eglReleaseThread
eglSetBlobCacheFuncsANDROID
eglSetDamageRegionKHR
eglSignalSyncKHR
eglStreamAttribKHR
eglStreamConsumerAcquireKHR
eglStreamConsumerGLTextureExternalAttribsNV
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerReleaseKHR
eglStreamPostD3DTextureANGLE
eglSurfaceAttrib
eglSwapBuffers
eglSwapBuffersWithDamageKHR
eglSwapBuffersWithFrameTokenANGLE
eglSwapInterval
eglTerminate
eglUnlockSurfaceKHR
eglWaitClient
eglWaitGL
eglWaitNative
eglWaitSync
eglWaitSyncKHR
eglWaitUntilWorkScheduledANGLE
glAcquireTexturesANGLE
glActiveShaderProgram
glActiveShaderProgramEXT
glActiveTexture
glAlphaFunc
glAlphaFuncx
glAttachShader
glBeginPerfMonitorAMD
glBeginPixelLocalStorageANGLE
glBeginQuery
glBeginQueryEXT
glBeginTransformFeedback
glBindAttribLocation
glBindBuffer
glBindBufferBase
glBindBufferRange
glBindFragDataLocationEXT
glBindFragDataLocationIndexedEXT
glBindFramebuffer
glBindFramebufferOES
glBindImageTexture
glBindProgramPipeline
glBindProgramPipelineEXT
glBindRenderbuffer
glBindRenderbufferOES
glBindSampler
glBindTexture
glBindTransformFeedback
glBindUniformLocationCHROMIUM
glBindVertexArray
glBindVertexArrayOES
glBindVertexBuffer
glBlendBarrier
glBlendBarrierKHR
glBlendColor
glBlendEquation
glBlendEquationSeparate
glBlendEquationSeparatei
glBlendEquationSeparateiEXT
glBlendEquationSeparateiOES
glBlendEquationi
glBlendEquationiEXT
glBlendEquationiOES
glBlendFunc
glBlendFuncSeparate
glBlendFuncSeparatei
glBlendFuncSeparateiEXT
glBlendFuncSeparateiOES
glBlendFunci
glBlendFunciEXT
glBlendFunciOES
glBlitFramebuffer
glBlitFramebufferANGLE
glBlitFramebufferNV
glBufferData
glBufferStorageEXT
glBufferStorageExternalEXT
glBufferStorageMemEXT
glBufferSubData
glCheckFramebufferStatus
glCheckFramebufferStatusOES
glClear
glClearBufferfi
glClearBufferfv
glClearBufferiv
glClearBufferuiv
glClearColor
glClearColorx
glClearDepthf
glClearDepthx
glClearStencil
glClientActiveTexture
glClientWaitSync
glClipControlEXT
glClipPlanef
glClipPlanex
glColor4f
glColor4ub
glColor4x
glColorMask
glColorMaski
glColorMaskiEXT
glColorMaskiOES
glColorPointer
glCompileShader
glCompressedCopyTextureCHROMIUM
glCompressedTexImage2D
glCompressedTexImage2DRobustANGLE
glCompressedTexImage3D
glCompressedTexImage3DOES
glCompressedTexImage3DRobustANGLE
glCompressedTexSubImage2D
glCompressedTexSubImage2DRobustANGLE
glCompressedTexSubImage3D
glCompressedTexSubImage3DOES
glCompressedTexSubImage3DRobustANGLE
glCopyBufferSubData
glCopyImageSubData
glCopyImageSubDataEXT
glCopyImageSubDataOES
glCopySubTexture3DANGLE
glCopySubTextureCHROMIUM
glCopyTexImage2D
glCopyTexSubImage2D
glCopyTexSubImage3D
glCopyTexSubImage3DOES
glCopyTexture3DANGLE
glCopyTextureCHROMIUM
glCoverageModulationCHROMIUM
glCreateMemoryObjectsEXT
glCreateProgram
glCreateShader
glCreateShaderProgramv
glCreateShaderProgramvEXT
glCullFace
glCurrentPaletteMatrixOES
glDebugMessageCallback
glDebugMessageCallbackKHR
glDebugMessageControl
glDebugMessageControlKHR
glDebugMessageInsert
glDebugMessageInsertKHR
glDeleteBuffers
glDeleteFencesNV
glDeleteFramebuffers
glDeleteFramebuffersOES
glDeleteMemoryObjectsEXT
glDeletePerfMonitorsAMD
glDeleteProgram
glDeleteProgramPipelines
glDeleteProgramPipelinesEXT
glDeleteQueries
glDeleteQueriesEXT
glDeleteRenderbuffers
glDeleteRenderbuffersOES
glDeleteSamplers
glDeleteSemaphoresEXT
glDeleteShader
glDeleteSync
glDeleteTextures
glDeleteTransformFeedbacks
glDeleteVertexArrays
glDeleteVertexArraysOES
glDepthFunc
glDepthMask
glDepthRangef
glDepthRangex
glDetachShader
glDisable
glDisableClientState
glDisableExtensionANGLE
glDisableVertexAttribArray
glDisablei
glDisableiEXT
glDisableiOES
glDiscardFramebufferEXT
glDispatchCompute
glDispatchComputeIndirect
glDrawArrays
glDrawArraysIndirect
glDrawArraysInstanced
glDrawArraysInstancedANGLE
glDrawArraysInstancedBaseInstanceANGLE
glDrawArraysInstancedBaseInstanceEXT
glDrawArraysInstancedEXT
glDrawBuffers
glDrawBuffersEXT
glDrawElements
glDrawElementsBaseVertex
glDrawElementsBaseVertexEXT
glDrawElementsBaseVertexOES
glDrawElementsIndirect
glDrawElementsInstanced
glDrawElementsInstancedANGLE
glDrawElementsInstancedBaseInstanceEXT
glDrawElementsInstancedBaseVertex
glDrawElementsInstancedBaseVertexBaseInstanceANGLE
glDrawElementsInstancedBaseVertexBaseInstanceEXT
glDrawElementsInstancedBaseVertexEXT
glDrawElementsInstancedBaseVertexOES
glDrawElementsInstancedEXT
glDrawRangeElements
glDrawRangeElementsBaseVertex
glDrawRangeElementsBaseVertexEXT
glDrawRangeElementsBaseVertexOES
glDrawTexfOES
glDrawTexfvOES
glDrawTexiOES
glDrawTexivOES
glDrawTexsOES
glDrawTexsvOES
glDrawTexxOES
glDrawTexxvOES
glEGLImageTargetRenderbufferStorageOES
glEGLImageTargetTexStorageEXT
glEGLImageTargetTexture2DOES
glEGLImageTargetTextureStorageEXT
glEnable
glEnableClientState
glEnableVertexAttribArray
glEnablei
glEnableiEXT
glEnableiOES
glEndPerfMonitorAMD
glEndPixelLocalStorageANGLE
glEndQuery
glEndQueryEXT
glEndTransformFeedback
glFenceSync
glFinish
glFinishFenceNV
glFlush
glFlushMappedBufferRange
glFlushMappedBufferRangeEXT
glFogf
glFogfv
glFogx
glFogxv
glFramebufferFetchBarrierEXT
glFramebufferMemorylessPixelLocalStorageANGLE
glFramebufferParameteri
glFramebufferParameteriMESA
glFramebufferPixelLocalClearValuefvANGLE
glFramebufferPixelLocalClearValueivANGLE
glFramebufferPixelLocalClearValueuivANGLE
glFramebufferRenderbuffer
glFramebufferRenderbufferOES
glFramebufferTexture
glFramebufferTexture2D
glFramebufferTexture2DMultisampleEXT
glFramebufferTexture2DOES
glFramebufferTexture3DOES
glFramebufferTextureEXT
glFramebufferTextureLayer
glFramebufferTextureMultiviewOVR
glFramebufferTextureOES
glFramebufferTexturePixelLocalStorageANGLE
glFrontFace
glFrustumf
glFrustumx
glGenBuffers
glGenFencesNV
glGenFramebuffers
glGenFramebuffersOES
glGenPerfMonitorsAMD
glGenProgramPipelines
glGenProgramPipelinesEXT
glGenQueries
glGenQueriesEXT
glGenRenderbuffers
glGenRenderbuffersOES
glGenSamplers
glGenSemaphoresEXT
glGenTextures
glGenTransformFeedbacks
glGenVertexArrays
glGenVertexArraysOES
glGenerateMipmap
glGenerateMipmapOES
glGetActiveAttrib
glGetActiveUniform
glGetActiveUniformBlockName
glGetActiveUniformBlockiv
glGetActiveUniformBlockivRobustANGLE
glGetActiveUniformsiv
glGetAttachedShaders
glGetAttribLocation
glGetBooleani_v
glGetBooleani_vRobustANGLE
glGetBooleanv
glGetBooleanvRobustANGLE
glGetBufferParameteri64v
glGetBufferParameteri64vRobustANGLE
glGetBufferParameteriv
glGetBufferParameterivRobustANGLE
glGetBufferPointerv
glGetBufferPointervOES
glGetBufferPointervRobustANGLE
glGetClipPlanef
glGetClipPlanex
glGetCompressedTexImageANGLE
glGetDebugMessageLog
glGetDebugMessageLogKHR
glGetError
glGetFenceivNV
glGetFixedv
glGetFloatv
glGetFloatvRobustANGLE
glGetFragDataIndexEXT
glGetFragDataLocation
glGetFramebufferAttachmentParameteriv
glGetFramebufferAttachmentParameterivOES
glGetFramebufferAttachmentParameterivRobustANGLE
glGetFramebufferParameteriv
glGetFramebufferParameterivMESA
glGetFramebufferParameterivRobustANGLE
glGetFramebufferPixelLocalStorageParameterfvANGLE
glGetFramebufferPixelLocalStorageParameterivANGLE
glGetGraphicsResetStatus
glGetGraphicsResetStatusEXT
glGetInteger64i_v
glGetInteger64i_vRobustANGLE
glGetInteger64v
glGetInteger64vEXT
glGetInteger64vRobustANGLE
glGetIntegeri_v
glGetIntegeri_vRobustANGLE
glGetIntegerv
glGetIntegervRobustANGLE
glGetInternalformativ
glGetInternalformativRobustANGLE
glGetLightfv
glGetLightxv
glGetMaterialfv
glGetMaterialxv
glGetMemoryObjectParameterivEXT
glGetMultisamplefv
glGetMultisamplefvANGLE
glGetMultisamplefvRobustANGLE
glGetObjectLabel
glGetObjectLabelEXT
glGetObjectLabelKHR
glGetObjectPtrLabel
glGetObjectPtrLabelKHR
glGetPerfMonitorCounterDataAMD
glGetPerfMonitorCounterInfoAMD
glGetPerfMonitorCounterStringAMD
glGetPerfMonitorCountersAMD
glGetPerfMonitorGroupStringAMD
glGetPerfMonitorGroupsAMD
glGetPointerv
glGetPointervKHR
glGetPointervRobustANGLERobustANGLE
glGetProgramBinary
glGetProgramBinaryOES
glGetProgramInfoLog
glGetProgramInterfaceiv
glGetProgramInterfaceivRobustANGLE
glGetProgramPipelineInfoLog
glGetProgramPipelineInfoLogEXT
glGetProgramPipelineiv
glGetProgramPipelineivEXT
glGetProgramResourceIndex
glGetProgramResourceLocation
glGetProgramResourceLocationIndexEXT
glGetProgramResourceName
glGetProgramResourceiv
glGetProgramiv
glGetProgramivRobustANGLE
glGetQueryObjecti64vEXT
glGetQueryObjecti64vRobustANGLE
glGetQueryObjectivEXT
glGetQueryObjectivRobustANGLE
glGetQueryObjectui64vEXT
glGetQueryObjectui64vRobustANGLE
glGetQueryObjectuiv
glGetQueryObjectuivEXT
glGetQueryObjectuivRobustANGLE
glGetQueryiv
glGetQueryivEXT
glGetQueryivRobustANGLE
glGetRenderbufferImageANGLE
glGetRenderbufferParameteriv
glGetRenderbufferParameterivOES
glGetRenderbufferParameterivRobustANGLE
glGetSamplerParameterIiv
glGetSamplerParameterIivEXT
glGetSamplerParameterIivOES
glGetSamplerParameterIivRobustANGLE
glGetSamplerParameterIuiv
glGetSamplerParameterIuivEXT
glGetSamplerParameterIuivOES
glGetSamplerParameterIuivRobustANGLE
glGetSamplerParameterfv
glGetSamplerParameterfvRobustANGLE
glGetSamplerParameteriv
glGetSamplerParameterivRobustANGLE
glGetSemaphoreParameterui64vEXT
glGetShaderInfoLog
glGetShaderPrecisionFormat
glGetShaderSource
glGetShaderiv
glGetShaderivRobustANGLE
glGetString
glGetStringi
glGetSynciv
glGetTexEnvfv
glGetTexEnviv
glGetTexEnvxv
glGetTexGenfvOES
glGetTexGenivOES
glGetTexGenxvOES
glGetTexImageANGLE
glGetTexLevelParameterfv
glGetTexLevelParameterfvANGLE
glGetTexLevelParameterfvRobustANGLE
glGetTexLevelParameteriv
glGetTexLevelParameterivANGLE
glGetTexLevelParameterivRobustANGLE
glGetTexParameterIiv
glGetTexParameterIivEXT
glGetTexParameterIivOES
glGetTexParameterIivRobustANGLE
glGetTexParameterIuiv
glGetTexParameterIuivEXT
glGetTexParameterIuivOES
glGetTexParameterIuivRobustANGLE
glGetTexParameterfv
glGetTexParameterfvRobustANGLE
glGetTexParameteriv
glGetTexParameterivRobustANGLE
glGetTexParameterxv
glGetTransformFeedbackVarying
glGetTranslatedShaderSourceANGLE
glGetUniformBlockIndex
glGetUniformIndices
glGetUniformLocation
glGetUniformfv
glGetUniformfvRobustANGLE
glGetUniformiv
glGetUniformivRobustANGLE
glGetUniformuiv
glGetUniformuivRobustANGLE
glGetUnsignedBytei_vEXT
glGetUnsignedBytevEXT
glGetVertexAttribIiv
glGetVertexAttribIivRobustANGLE
glGetVertexAttribIuiv
glGetVertexAttribIuivRobustANGLE
glGetVertexAttribPointerv
glGetVertexAttribPointervRobustANGLE
glGetVertexAttribfv
glGetVertexAttribfvRobustANGLE
glGetVertexAttribiv
glGetVertexAttribivRobustANGLE
glGetnUniformfv
glGetnUniformfvEXT
glGetnUniformfvRobustANGLE
glGetnUniformiv
glGetnUniformivEXT
glGetnUniformivRobustANGLE
glGetnUniformuiv
glGetnUniformuivRobustANGLE
glHint
glImportMemoryFdEXT
glImportMemoryZirconHandleANGLE
glImportSemaphoreFdEXT
glImportSemaphoreZirconHandleANGLE
glInsertEventMarkerEXT
glInvalidateFramebuffer
glInvalidateSubFramebuffer
glInvalidateTextureANGLE
glIsBuffer
glIsEnabled
glIsEnabledi
glIsEnablediEXT
glIsEnablediOES
glIsFenceNV
glIsFramebuffer
glIsFramebufferOES
glIsMemoryObjectEXT
glIsProgram
glIsProgramPipeline
glIsProgramPipelineEXT
glIsQuery
glIsQueryEXT
glIsRenderbuffer
glIsRenderbufferOES
glIsSampler
glIsSemaphoreEXT
glIsShader
glIsSync
glIsTexture
glIsTransformFeedback
glIsVertexArray
glIsVertexArrayOES
glLabelObjectEXT
glLightModelf
glLightModelfv
glLightModelx
glLightModelxv
glLightf
glLightfv
glLightx
glLightxv
glLineWidth
glLineWidthx
glLinkProgram
glLoadIdentity
glLoadMatrixf
glLoadMatrixx
glLoadPaletteFromModelViewMatrixOES
glLogicOp
glLogicOpANGLE
glLoseContextCHROMIUM
glMapBufferOES
glMapBufferRange
glMapBufferRangeEXT
glMaterialf
glMaterialfv
glMaterialx
glMaterialxv
glMatrixIndexPointerOES
glMatrixMode
glMaxShaderCompilerThreadsKHR
glMemoryBarrier
glMemoryBarrierByRegion
glMemoryObjectParameterivEXT
glMinSampleShading
glMinSampleShadingOES
glMultMatrixf
glMultMatrixx
glMultiDrawArraysANGLE
glMultiDrawArraysIndirectEXT
glMultiDrawArraysInstancedANGLE
glMultiDrawArraysInstancedBaseInstanceANGLE
glMultiDrawElementsANGLE
glMultiDrawElementsBaseVertexEXT
glMultiDrawElementsIndirectEXT
glMultiDrawElementsInstancedANGLE
glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE
glMultiTexCoord4f
glMultiTexCoord4x
glNamedBufferStorageExternalEXT
glNormal3f
glNormal3x
glNormalPointer
glObjectLabel
glObjectLabelKHR
glObjectPtrLabel
glObjectPtrLabelKHR
glOrthof
glOrthox
glPatchParameteri
glPatchParameteriEXT
glPauseTransformFeedback
glPixelLocalStorageBarrierANGLE
glPixelStorei
glPointParameterf
glPointParameterfv
glPointParameterx
glPointParameterxv
glPointSize
glPointSizePointerOES
glPointSizex
glPolygonOffset
glPolygonOffsetClampEXT
glPolygonOffsetx
glPopDebugGroup
glPopDebugGroupKHR
glPopGroupMarkerEXT
glPopMatrix
glPrimitiveBoundingBox
glPrimitiveBoundingBoxEXT
glPrimitiveBoundingBoxOES
glProgramBinary
glProgramBinaryOES
glProgramParameteri
glProgramParameteriEXT
glProgramUniform1f
glProgramUniform1fEXT
glProgramUniform1fv
glProgramUniform1fvEXT
glProgramUniform1i
glProgramUniform1iEXT
glProgramUniform1iv
glProgramUniform1ivEXT
glProgramUniform1ui
glProgramUniform1uiEXT
glProgramUniform1uiv
glProgramUniform1uivEXT
glProgramUniform2f
glProgramUniform2fEXT
glProgramUniform2fv
glProgramUniform2fvEXT
glProgramUniform2i
glProgramUniform2iEXT
glProgramUniform2iv
glProgramUniform2ivEXT
glProgramUniform2ui
glProgramUniform2uiEXT
glProgramUniform2uiv
glProgramUniform2uivEXT
glProgramUniform3f
glProgramUniform3fEXT
glProgramUniform3fv
glProgramUniform3fvEXT
glProgramUniform3i
glProgramUniform3iEXT
glProgramUniform3iv
glProgramUniform3ivEXT
glProgramUniform3ui
glProgramUniform3uiEXT
glProgramUniform3uiv
glProgramUniform3uivEXT
glProgramUniform4f
glProgramUniform4fEXT
glProgramUniform4fv
glProgramUniform4fvEXT
glProgramUniform4i
glProgramUniform4iEXT
glProgramUniform4iv
glProgramUniform4ivEXT
glProgramUniform4ui
glProgramUniform4uiEXT
glProgramUniform4uiv
glProgramUniform4uivEXT
glProgramUniformMatrix2fv
glProgramUniformMatrix2fvEXT
glProgramUniformMatrix2x3fv
glProgramUniformMatrix2x3fvEXT
glProgramUniformMatrix2x4fv
glProgramUniformMatrix2x4fvEXT
glProgramUniformMatrix3fv
glProgramUniformMatrix3fvEXT
glProgramUniformMatrix3x2fv
glProgramUniformMatrix3x2fvEXT
glProgramUniformMatrix3x4fv
glProgramUniformMatrix3x4fvEXT
glProgramUniformMatrix4fv
glProgramUniformMatrix4fvEXT
glProgramUniformMatrix4x2fv
glProgramUniformMatrix4x2fvEXT
glProgramUniformMatrix4x3fv
glProgramUniformMatrix4x3fvEXT
glProvokingVertexANGLE
glPushDebugGroup
glPushDebugGroupKHR
glPushGroupMarkerEXT
glPushMatrix
glQueryCounterEXT
glQueryMatrixxOES
glReadBuffer
glReadPixels
glReadPixelsRobustANGLE
glReadnPixels
glReadnPixelsEXT
glReadnPixelsRobustANGLE
glReleaseShaderCompiler
glReleaseTexturesANGLE
glRenderbufferStorage
glRenderbufferStorageMultisample
glRenderbufferStorageMultisampleANGLE
glRenderbufferStorageMultisampleEXT
glRenderbufferStorageOES
glRequestExtensionANGLE
glResumeTransformFeedback
glRotatef
glRotatex
glSampleCoverage
glSampleCoveragex
glSampleMaski
glSampleMaskiANGLE
glSamplerParameterIiv
glSamplerParameterIivEXT
glSamplerParameterIivOES
glSamplerParameterIivRobustANGLE
glSamplerParameterIuiv
glSamplerParameterIuivEXT
glSamplerParameterIuivOES
glSamplerParameterIuivRobustANGLE
glSamplerParameterf
glSamplerParameterfv
glSamplerParameterfvRobustANGLE
glSamplerParameteri
glSamplerParameteriv
glSamplerParameterivRobustANGLE
glScalef
glScalex
glScissor
glSelectPerfMonitorCountersAMD
glSemaphoreParameterui64vEXT
glSetFenceNV
glShadeModel
glShaderBinary
glShaderSource
glShadingRateQCOM
glSignalSemaphoreEXT
glStencilFunc
glStencilFuncSeparate
glStencilMask
glStencilMaskSeparate
glStencilOp
glStencilOpSeparate
glTestFenceNV
glTexBuffer
glTexBufferEXT
glTexBufferOES
glTexBufferRange
glTexBufferRangeEXT
glTexBufferRangeOES
glTexCoordPointer
glTexEnvf
glTexEnvfv
glTexEnvi
glTexEnviv
glTexEnvx
glTexEnvxv
glTexGenfOES
glTexGenfvOES
glTexGeniOES
glTexGenivOES
glTexGenxOES
glTexGenxvOES
glTexImage2D
glTexImage2DExternalANGLE
glTexImage2DRobustANGLE
glTexImage3D
glTexImage3DOES
glTexImage3DRobustANGLE
glTexParameterIiv
glTexParameterIivEXT
glTexParameterIivOES
glTexParameterIivRobustANGLE
glTexParameterIuiv
glTexParameterIuivEXT
glTexParameterIuivOES
glTexParameterIuivRobustANGLE
glTexParameterf
glTexParameterfv
glTexParameterfvRobustANGLE
glTexParameteri
glTexParameteriv
glTexParameterivRobustANGLE
glTexParameterx
glTexParameterxv
glTexStorage1DEXT
glTexStorage2D
glTexStorage2DEXT
glTexStorage2DMultisample
glTexStorage2DMultisampleANGLE
glTexStorage3D
glTexStorage3DEXT
glTexStorage3DMultisample
glTexStorage3DMultisampleOES
glTexStorageMem2DEXT
glTexStorageMem2DMultisampleEXT
glTexStorageMem3DEXT
glTexStorageMem3DMultisampleEXT
glTexStorageMemFlags2DANGLE
glTexStorageMemFlags2DMultisampleANGLE
glTexStorageMemFlags3DANGLE
glTexStorageMemFlags3DMultisampleANGLE
glTexSubImage2D
glTexSubImage2DRobustANGLE
glTexSubImage3D
glTexSubImage3DOES
glTexSubImage3DRobustANGLE
glTransformFeedbackVaryings
glTranslatef
glTranslatex
glUniform1f
glUniform1fv
glUniform1i
glUniform1iv
glUniform1ui
glUniform1uiv
glUniform2f
glUniform2fv
glUniform2i
glUniform2iv
glUniform2ui
glUniform2uiv
glUniform3f
glUniform3fv
glUniform3i
glUniform3iv
glUniform3ui
glUniform3uiv
glUniform4f
glUniform4fv
glUniform4i
glUniform4iv
glUniform4ui
glUniform4uiv
glUniformBlockBinding
glUniformMatrix2fv
glUniformMatrix2x3fv
glUniformMatrix2x4fv
glUniformMatrix3fv
glUniformMatrix3x2fv
glUniformMatrix3x4fv
glUniformMatrix4fv
glUniformMatrix4x2fv
glUniformMatrix4x3fv
glUnmapBuffer
glUnmapBufferOES
glUseProgram
glUseProgramStages
glUseProgramStagesEXT
glValidateProgram
glValidateProgramPipeline
glValidateProgramPipelineEXT
glVertexAttrib1f
glVertexAttrib1fv
glVertexAttrib2f
glVertexAttrib2fv
glVertexAttrib3f
glVertexAttrib3fv
glVertexAttrib4f
glVertexAttrib4fv
glVertexAttribBinding
glVertexAttribDivisor
glVertexAttribDivisorANGLE
glVertexAttribDivisorEXT
glVertexAttribFormat
glVertexAttribI4i
glVertexAttribI4iv
glVertexAttribI4ui
glVertexAttribI4uiv
glVertexAttribIFormat
glVertexAttribIPointer
glVertexAttribPointer
glVertexBindingDivisor
glVertexPointer
glViewport
glWaitSemaphoreEXT
glWaitSync
glWeightPointerOES
Type
Array-ness
Array size
Precision
Structure name
Field number
Field name
Interpolation type
Invariance
Binding layout qualifier
Location layout qualifier
Offset layout qualifier
Instance name qualifier
Format qualifier
Layout qualifier
Matrix Packing
Field location
Field structure name
s of 
' member '
' differ between 
 and 
 shaders.
GPU.ANGLE.ProgramCache.ProgramCacheHitTimeUS
The sum of the number of active image uniforms, active shader storage blocks and active fragment shader outputs exceeds MAX_COMBINED_SHADER_OUTPUT_RESOURCES (
Failed to save linked program to memory program cache.
Invalid program binary format.
Insufficient buffer size
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Program.cpp
saveBinary
Program has not been successfully linked.
Both compute and graphics shaders are attached to the same program.
 shader is not compiled.
 shader version does not match other shader versions.
Work group size is not specified.
No compiled shaders.
The program must contain objects to form both a vertex and fragment shader.
Tessellation control and evaluation shaders must be specified together.
Input primitive type is not specified in the geometry shader.
Output primitive type is not specified in the geometry shader.
'max_vertices' is not specified in the geometry shader.
In Tessellation Control Shader, at least one layout qualifier specifying an output patch vertex count must exist.
The Tessellation Evaluation Shader object in a program must declare a primitive mode in its input layout.
Exceeded maximum uniform location size
Attribute (
) at location 
 is too big to fit
Attribute '
' aliases attribute '
' at location 
Too many attributes (
Saving program binary with transform feedback, which is not supported on this driver.
Failed to allocate enough memory to serialize a program. (
 bytes )
Invalid program binary version.
cannot load program binaries across different angle sh version.
Cannot load program binaries across different ES context versions.
Current driver does not support transform feedback in binary programs.
Capture of array elements is undefined and not supported.
Two transform feedback varyings include the same array element (
Two transform feedback varyings specify the same output variable (
Linked transform feedback stage 
 does not support transform feedback varying.
Transform feedback varying 
 does not exist in the vertex shader.
Struct cannot be captured directly (
Capture of arrays is undefined and not supported.
Cannot capture outbound array element '
Varying '
' is not an array to be captured by element.
 components (
) exceed the maximum separate components (
Transform feedback varying total components (
) exceed the maximum interleaved components (
Samplers of conflicting types refer to the same texture image unit (
Samplers of conflicting formats refer to the same texture image unit (
Location of variable 
 conflicts with another variable.
Could not fit output variable into available locations: 
 combined AtomicCounterBuffers count exceeds limit
 shader AtomicCounterBuffers count exceeds limit
ProgramGL::load
ProgramGL::link
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/ProgramGL.cpp
checkLinkStatus
Program link or binary loading failed: 
Program link or binary loading failed with no info log.
angle_ClipDistanceEnabled
ProgramGL::LinkTask::run
ProgramGL::LinkEventNativeParallel::wait
ProgramGL::LinkEventGL::wait
Multiple uniforms bound to location 
atomic counter count exceeds MAX_COMBINED_ATOMIC_COUNTERS
Name conflicts between uniform block field names: 
Name conflicts between a uniform and an attribute: 
Name conflicts between a uniform and a uniform block field: 
 does not consume all varyings generated by 
 does not generate all varyings consumed by 
 varying 
 does not match any 
 varying
gl_FragCoord
gl_PointCoord
gl_FragCoord can only be declared invariant if and only if gl_Position is declared invariant.
gl_PointCoord can only be declared invariant if and only if gl_PointSize is declared invariant.
If either shader redeclares the built-in arrays gl_ClipDistance[] the array must have the same size in both shaders. 
Output size 
, input size 
If either shader redeclares the built-in arrays gl_CullDistance[] the array must have the same size in both shaders. 
Ambiguous field '
' in blocks '
 shader) and '
 shader) which don't have instance names.
The sum of the number of active uniform blocks exceeds MAX_COMBINED_UNIFORM_BLOCKS (
The sum of the number of active shader storage blocks exceeds MAX_COMBINED_SHADER_STORAGE_BLOCKS (
 shader 
s count exceeds 
texture image unit
image uniform
atomic counter
MAX_TEXTURE_IMAGE_UNITS
MAX_
UNIFORM_VECTORS
UNIFORM_COMPONENTS
TEXTURE_IMAGE_UNITS
IMAGE_UNIFORMS
ATOMIC_COUNTERS
_EXT
uniform block
shader storage block
 count exceeds 
GL_MAX_
UNIFORM_BUFFERS
SHADER_STORAGE_BLOCKS
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ProgramMtl.mm
resizeDefaultUniformBlocksMemory
TRANSFORM_FEEDBACK_ENABLED
TransformFeedback
ANGLEUseSampleCompareGradient
ANGLEUseSampleCompareLod
main0
Internal error compiling shader with Metal backend.
-----
createMslShaderLib
 is not marked separable.
#define ANGLE_tensor metal::array
#pragma clang diagnostic ignored "-Wunused-value"
addressof
cast<>
elem_ref
swizzle_ref
texture1DProj
textureCubeProj
template <typename T>
ANGLE_ALWAYS_INLINE thread T * ANGLE_addressof(thread T &ref)
    return &ref;
template <typename T, int C1, int R1, int C2, int R2, typename Enable = void>
struct ANGLE_castMatrix
    static ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> exec(metal::matrix<T, C2, R2> const m2)
    {
        metal::matrix<T, C1, R1> m1;
        const int MinC = C1 <= C2 ? C1 : C2;
        const int MinR = R1 <= R2 ? R1 : R2;
        for (int c = 0; c < MinC; ++c)
        {
            for (int r = 0; r < MinR; ++r)
            {
                m1[c][r] = m2[c][r];
            }
            for (int r = R2; r < R1; ++r)
            {
                m1[c][r] = c == r ? T(1) : T(0);
            }
        }
        for (int c = C2; c < C1; ++c)
        {
            for (int r = 0; r < R1; ++r)
            {
                m1[c][r] = c == r ? T(1) : T(0);
            }
        }
        return m1;
    }
template <typename T, int C1, int R1, int C2, int R2>
struct ANGLE_castMatrix<T, C1, R1, C2, R2, ANGLE_enable_if_t<(C1 <= C2 && R1 <= R2)>>
    static ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> exec(metal::matrix<T, C2, R2> const m2)
    {
        metal::matrix<T, C1, R1> m1;
        for (size_t c = 0; c < C1; ++c)
        {
            m1[c] = ANGLE_cast<R1>(m2[c]);
        }
        return m1;
    }
template <int C1, int R1, int C2, int R2, typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> ANGLE_cast(metal::matrix<T, C2, R2> const m)
    return ANGLE_castMatrix<T, C1, R1, C2, R2>::exec(m);
template <bool B, typename T = void>
struct ANGLE_enable_if {};
template <typename T>
struct ANGLE_enable_if<true, T>
    using type = T;
template <bool B>
using ANGLE_enable_if_t = typename ANGLE_enable_if<B>::type;
template <typename T, int N1, int N2>
struct ANGLE_castVector {};
template <typename T, int N>
struct ANGLE_castVector<T, N, N>
    static ANGLE_ALWAYS_INLINE metal::vec<T, N> exec(metal::vec<T, N> const v)
    {
        return v;
    }
template <typename T>
struct ANGLE_castVector<T, 2, 3>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 2> exec(metal::vec<T, 3> const v)
    {
        return v.xy;
    }
template <typename T>
struct ANGLE_castVector<T, 2, 4>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 2> exec(metal::vec<T, 4> const v)
    {
        return v.xy;
    }
template <typename T>
struct ANGLE_castVector<T, 3, 4>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 3> exec(metal::vec<T, 4> const v)
    {
        return as_type<metal::vec<T, 3>>(v);
    }
template <int N1, int N2, typename T>
ANGLE_ALWAYS_INLINE metal::vec<T, N1> ANGLE_cast(metal::vec<T, N2> const v)
    return ANGLE_castVector<T, N1, N2>::exec(v);
template <typename T, int N>
struct ANGLE_VectorElemRef
    thread metal::vec<T, N> &mVec;
    T mRef;
    const int mIndex;
    ~ANGLE_VectorElemRef() { mVec[mIndex] = mRef; }
    ANGLE_VectorElemRef(thread metal::vec<T, N> &vec, int index)
        : mVec(vec), mRef(vec[index]), mIndex(index)
    {}
    operator thread T &() { return mRef; }
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_VectorElemRef<T, N> ANGLE_elem_ref(thread metal::vec<T, N> &vec, int index)
    return ANGLE_VectorElemRef<T, N>(vec, index);
template <typename T>
struct ANGLE_flatten_impl
    static ANGLE_ALWAYS_INLINE thread T *exec(thread T &x)
    {
        return &x;
    }
template <typename T, size_t N>
struct ANGLE_flatten_impl<metal::array<T, N>>
    static ANGLE_ALWAYS_INLINE auto exec(thread metal::array<T, N> &arr) -> T
    {
        return ANGLE_flatten_impl<T>::exec(arr[0]);
    }
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE auto ANGLE_flatten(thread metal::array<T, N> &arr) -> T
    return ANGLE_flatten_impl<T>::exec(arr[0]);
template <typename T>
struct ANGLE_InOut
    T mTemp;
    thread T &mDest;
    ~ANGLE_InOut() { mDest = mTemp; }
    ANGLE_InOut(thread T &dest)
        : mTemp(dest), mDest(dest)
    {}
    operator thread T &() { return mTemp; }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_InOut<T> ANGLE_inout(thread T &dest)
    return ANGLE_InOut<T>(dest);
template <typename T>
struct ANGLE_Out
    T mTemp;
    thread T &mDest;
    ~ANGLE_Out() { mDest = mTemp; }
    ANGLE_Out(thread T &dest)
        : mTemp(dest), mDest(dest)
    {}
    operator thread T &() { return mTemp; }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_Out<T> ANGLE_out(thread T &dest)
    return ANGLE_Out<T>(dest);
template <typename T, int VN, int SN>
struct ANGLE_SwizzleRef
    thread metal::vec<T, VN> &mVec;
    metal::vec<T, SN> mRef;
    int mIndices[SN];
    ~ANGLE_SwizzleRef()
    {
        for (int i = 0; i < SN; ++i)
        {
            const int j = mIndices[i];
            mVec[j] = mRef[i];
        }
    }
    ANGLE_SwizzleRef(thread metal::vec<T, VN> &vec, thread const int *indices)
        : mVec(vec)
    {
        for (int i = 0; i < SN; ++i)
        {
            const int j = indices[i];
            mIndices[i] = j;
            mRef[i] = mVec[j];
        }
    }
    operator thread metal::vec<T, SN> &() { return mRef; }
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_VectorElemRef<T, N> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0)
    return ANGLE_VectorElemRef<T, N>(vec, i0);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 2> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1)
    const int is[] = { i0, i1 };
    return ANGLE_SwizzleRef<T, N, 2>(vec, is);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 3> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1, int i2)
    const int is[] = { i0, i1, i2 };
    return ANGLE_SwizzleRef<T, N, 3>(vec, is);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 4> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1, int i2, int i3)
    const int is[] = { i0, i1, i2, i3 };
    return ANGLE_SwizzleRef<T, N, 4>(vec, is);
#define ANGLE_texelFetch(env, ...) ANGLE_texelFetch_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread Texture &texture,
    metal::int2 const coord,
    uint32_t level)
    return texture.read(uint2(coord), level);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread Texture &texture,
    metal::int3 const coord,
    uint32_t level)
    return texture.read(uint3(coord), level);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread metal::texture2d_array<T> &texture,
    metal::int3 const coord,
    uint32_t level)
    return texture.read(uint2(coord.xy), uint32_t(coord.z), level);
template <typename T>
struct ANGLE_TextureEnv
    thread T *texture;
    thread metal::sampler *sampler;
#define ANGLE_texelFetchOffset(env, ...) ANGLE_texelFetchOffset_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread Texture &texture,
    metal::int2 const coord,
    uint32_t level,
    metal::int2 const offset)
    return texture.read(uint2(coord + offset), level);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread Texture &texture,
    metal::int3 const coord,
    uint32_t level,
    metal::int3 const offset)
    return texture.read(uint3(coord + offset), level);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread metal::texture2d_array<T> &texture,
    metal::int3 const coord,
    uint32_t level,
    metal::int2 const offset)
    return texture.read(uint2(coord.xy + offset), uint32_t(coord.z), level);
metal::depth2d<
metal::depthcube<
metal::depth2d_array<
metal::texture2d_array<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias));
#define ANGLE_texture(env, ...) ANGLE_texture_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample_compare(sampler, coord.xy, coord.z);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias)
    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample_compare(sampler, coord.xyz, coord.w);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float compare)
    return texture.sample_compare(sampler, coord.xyz, uint32_t(metal::round(coord.w)), compare);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
#define ANGLE_texture1DLod(env, ...) ANGLE_texture1DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    float const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture1DProj(env, ...) ANGLE_texture1DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.x/coord.y, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.x/coord.w, metal::bias(bias));
#define ANGLE_texture1DProjLod(env, ...) ANGLE_texture1DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord.x/coord.y, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.x/coord.w, metal::level(level));
#define ANGLE_texture2D(env, ...) ANGLE_texture2D_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
#define ANGLE_texture2DGradEXT(env, ...) ANGLE_texture2DGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DGradEXT_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord, metal::gradient2d(dPdx, dPdy));
#define ANGLE_texture2DLod(env, ...) ANGLE_texture2DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture2DLodEXT ANGLE_texture2DLod
#define ANGLE_texture2DProj(env, ...) ANGLE_texture2DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));
#define ANGLE_texture2DProjGradEXT(env, ...) ANGLE_texture2DProjGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjGradEXT_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));
#define ANGLE_texture2DProjLod(env, ...) ANGLE_texture2DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));
#define ANGLE_texture2DProjLodEXT ANGLE_texture2DProjLod
#define ANGLE_texture2DRect(env, ...) ANGLE_texture2DRect_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRect_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
#define ANGLE_texture2DRectProj(env, ...) ANGLE_texture2DRectProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord.xy/coord.z);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample(sampler, coord.xy/coord.w);
#define ANGLE_texture3DLod(env, ...) ANGLE_texture3DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture3DProj(env, ...) ANGLE_texture3DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
#define ANGLE_texture3DProjLod(env, ...) ANGLE_texture3DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
#define ANGLE_textureCube(env, ...) ANGLE_textureCube_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
#define ANGLE_textureCubeGradEXT(env, ...) ANGLE_textureCubeGradEXT_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeGradEXT_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));
#define ANGLE_textureCubeLod(env, ...) ANGLE_textureCubeLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_textureCubeLodEXT ANGLE_textureCubeLod
#define ANGLE_textureCubeProj(env, ...) ANGLE_textureCubeProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
#define ANGLE_textureCubeProjLod(env, ...) ANGLE_textureCubeProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
metal::texturecube<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy)) > coord.z);
    }
#define ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX 0
#define ANGLE_SAMPLE_COMPARE_LOD_INDEX      1
#define ANGLE_RASTERIZATION_DISCARD_INDEX   2
#define ANGLE_COVERAGE_MASK_ENABLED_INDEX   3
#define ANGLE_DEPTH_WRITE_ENABLED_INDEX     4
constant bool ANGLEUseSampleCompareGradient [[function_constant(ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX)]];
constant bool ANGLEUseSampleCompareLod      [[function_constant(ANGLE_SAMPLE_COMPARE_LOD_INDEX)]];
constant bool ANGLERasterizerDisabled       [[function_constant(ANGLE_RASTERIZATION_DISCARD_INDEX)]];
constant bool ANGLECoverageMaskEnabled      [[function_constant(ANGLE_COVERAGE_MASK_ENABLED_INDEX)]];
constant bool ANGLEDepthWriteEnabled        [[function_constant(ANGLE_DEPTH_WRITE_ENABLED_INDEX)]];
#define ANGLE_textureGrad(env, ...) ANGLE_textureGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy)) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xyz, metal::gradientcube(dPdx, dPdy)) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));
template <typename Texture, int N>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::vec<float, N> const coord,
    metal::vec<float, N> const dPdx,
    metal::vec<float, N> const dPdy)
    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy));
template <int N>
struct ANGLE_gradient_traits;
template <>
struct ANGLE_gradient_traits<2> { using type = metal::gradient2d; };
template <>
struct ANGLE_gradient_traits<3> { using type = metal::gradient3d; };
template <int N>
using ANGLE_gradient = typename ANGLE_gradient_traits<N>::type;
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy), offset) > coord.z);
    }
#define ANGLE_textureGradOffset(env, ...) ANGLE_textureGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint32_t(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    metal::int3 const offset)
    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    metal::int3 const offset)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture, int N>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::vec<float, N> const coord,
    metal::vec<float, N> const dPdx,
    metal::vec<float, N> const dPdy,
    metal::vec<int, N> const offset)
    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level)) > coord.z);
    }
#define ANGLE_textureLod(env, ...) ANGLE_textureLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_textureLodOffset(env, ...) ANGLE_textureLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level,
    metal::int2 const offset)
    return texture.sample(sampler, coord, metal::level(level), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    metal::int3 const offset)
    return texture.sample(sampler, coord, metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    int2 const offset)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level), offset) > coord.z);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    metal::int3 const offset)
    return texture.sample(sampler, coord.xyz, uint32_t(metal::round(coord.w)), metal::level(level), offset);
#define ANGLE_textureOffset(env, ...) ANGLE_textureOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::int2 const offset)
    return texture.sample(sampler, coord, offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample(sampler, coord.xy, uint32_t(metal::round(coord.z)), metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int3 const offset)
    return texture.sample(sampler, coord, offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int3 const offset,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset)
    return texture.sample_compare(sampler, coord.xy, coord.z, offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias), offset);
#define ANGLE_textureProj(env, ...) ANGLE_textureProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
metal::texture3d<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy)) > coord.z/coord.w);
    }
#define ANGLE_textureProjGrad(env, ...) ANGLE_textureProjGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    if (ANGLEUseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset) > coord.z/coord.w);
    }
#define ANGLE_textureProjGradOffset(env, ...) ANGLE_textureProjGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    int3 const offset)
    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level)) > coord.z/coord.w);
    }
#define ANGLE_textureProjLod(env, ...) ANGLE_textureProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));
#define ANGLE_textureProjLodOffset(env, ...) ANGLE_textureProjLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int2 const offset)
    if (ANGLEUseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset) > coord.z/coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int3 const offset)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level), offset);
#define ANGLE_textureProjOffset(env, ...) ANGLE_textureProjOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    int2 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    int2 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    int3 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias), offset);
#define ANGLE_textureSize(env, ...) ANGLE_textureSize_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread Texture &texture,
    int level)
    return int2(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::texture3d<T> &texture,
    int level)
    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_depth(uint32_t(level)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::depth2d_array<T> &texture,
    int level)
    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::texture2d_array<T> &texture,
    int level)
    return int3(texture.get_width(uint32_t(level)), texture.get_height(uint32_t(level)), texture.get_array_size());
template <typename T, metal::access Access>
ANGLE_ALWAYS_INLINE auto ANGLE_imageLoad(
    thread const metal::texture2d<T, Access> &texture,
    metal::int2 coord)
    return texture.read(uint2(coord));
template <typename T, metal::access Access>
ANGLE_ALWAYS_INLINE auto ANGLE_imageStore(
    thread const metal::texture2d<T, Access> &texture,
    metal::int2 coord,
    metal::vec<T, 4> value)
    return texture.write(value, uint2(coord));
ANGLE_ALWAYS_INLINE void ANGLE_memoryBarrierImage()
    simdgroup_barrier(metal::mem_flags::mem_texture);
#include <metal_stdlib>
#define ANGLE_ALWAYS_INLINE __attribute__((always_inline))
ANGLE_ALWAYS_INLINE int ANGLE_int_clamp(int value, int minValue, int maxValue)
    return ((value < minValue) ?  minValue : ((value > maxValue) ? maxValue : value));
template <typename T, int N>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::vec<T, N> u, metal::vec<T, N> v)
    return metal::all(u == v);
#include <metal_math>
template <typename T, int C, int R>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::matrix<T, C, R> a, metal::matrix<T, C, R> b)
    for (int c = 0; c < C; ++c)
    {
        if (!ANGLE_equal(a[c], b[c]))
        {
            return false;
        }
    }
    return true;
#if TRANSFORM_FEEDBACK_ENABLED
    #define __VERTEX_OUT(args) void
#else
    #define __VERTEX_OUT(args) args
#endif
ANGLE_ALWAYS_INLINE void ANGLE_writeSampleMask(const uint32_t mask,
                                               thread uint& gl_SampleMask)
    if (ANGLECoverageMaskEnabled)
    {
        gl_SampleMask = as_type<int>(mask);
    }
TextureEnv<
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_radians(T x)
    return static_cast<T>(1.7453292519943295e-2) * x;
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_degrees(T x)
    return static_cast<T>(57.29577951308232) * x;
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_atan(T yOverX)
    return metal::atan(yOverX);
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_atan(T y, T x)
    return metal::atan2(y, x);
template <typename X, typename Y>
ANGLE_ALWAYS_INLINE X ANGLE_mod(X x, Y y)
    return x - y * metal::floor(x / y);
template <typename T, typename Enable = void>
struct ANGLE_refract_impl
    static ANGLE_ALWAYS_INLINE T exec(T i, T n, ANGLE_scalar_of_t<T> eta)
    {
        return metal::refract(i, n, eta);
    }
template <typename T>
struct ANGLE_refract_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T i, T n, T eta)
    {
        auto dotNI = n * i;
        auto k = T(1) - eta * eta * (T(1) - dotNI * dotNI);
        if (k < T(0))
        {
            return T(0);
        }
        else
        {
            return eta * i - (eta * dotNI + metal::sqrt(k)) * n;
        }
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_refract(T i, T n, ANGLE_scalar_of_t<T> eta)
    return ANGLE_refract_impl<T>::exec(i, n, eta);
template <typename T>
struct ANGLE_is_scalar {};
#define ANGLE_DEFINE_SCALAR(scalar) \
    template <> struct ANGLE_is_scalar<scalar> { enum { value = true }; }
ANGLE_DEFINE_SCALAR(bool);
ANGLE_DEFINE_SCALAR(char);
ANGLE_DEFINE_SCALAR(short);
ANGLE_DEFINE_SCALAR(int);
ANGLE_DEFINE_SCALAR(uchar);
ANGLE_DEFINE_SCALAR(ushort);
ANGLE_DEFINE_SCALAR(uint);
ANGLE_DEFINE_SCALAR(half);
ANGLE_DEFINE_SCALAR(float);
template <typename T>
struct ANGLE_is_vector
    enum { value = false };
#define ANGLE_DEFINE_VECTOR(scalar) \
    template <> struct ANGLE_is_vector<metal::scalar ## 2> { enum { value = true }; }; \
    template <> struct ANGLE_is_vector<metal::scalar ## 3> { enum { value = true }; }; \
    template <> struct ANGLE_is_vector<metal::scalar ## 4> { enum { value = true }; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4> { using type = scalar; }
ANGLE_DEFINE_VECTOR(bool);
ANGLE_DEFINE_VECTOR(char);
ANGLE_DEFINE_VECTOR(short);
ANGLE_DEFINE_VECTOR(int);
ANGLE_DEFINE_VECTOR(uchar);
ANGLE_DEFINE_VECTOR(ushort);
ANGLE_DEFINE_VECTOR(uint);
ANGLE_DEFINE_VECTOR(half);
ANGLE_DEFINE_VECTOR(float);
template <typename T>
struct ANGLE_scalar_of
    using type = T;
template <typename T>
using ANGLE_scalar_of_t = typename ANGLE_scalar_of<T>::type;
template <typename T>
struct ANGLE_is_matrix
    enum { value = false };
#define ANGLE_DEFINE_MATRIX(scalar) \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x4> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x4> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x4> { enum { value = true }; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x4> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x4> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x4> { using type = scalar; }
ANGLE_DEFINE_MATRIX(half);
ANGLE_DEFINE_MATRIX(float);
template <typename T, typename Enable = void>
struct ANGLE_distance_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x, T y)
    {
        return metal::distance(x, y);
    }
template <typename T>
struct ANGLE_distance_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x, T y)
    {
        return metal::abs(x - y);
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_distance(T x, T y)
    return ANGLE_distance_impl<T>::exec(x, y);
template <typename T, typename Enable = void>
struct ANGLE_length_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x)
    {
        return metal::length(x);
    }
template <typename T>
struct ANGLE_length_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::abs(x);
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_length(T x)
    return ANGLE_length_impl<T>::exec(x);
template <typename T, typename Enable = void>
struct ANGLE_dot_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x, T y)
    {
        return metal::dot(x, y);
    }
template <typename T>
struct ANGLE_dot_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x, T y)
    {
        return x * y;
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_dot(T x, T y)
    return ANGLE_dot_impl<T>::exec(x, y);
template <typename T, typename Enable = void>
struct ANGLE_normalize_impl
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::fast::normalize(x);
    }
template <typename T>
struct ANGLE_normalize_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return ANGLE_sign(x);
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_normalize(T x)
    return ANGLE_normalize_impl<T>::exec(x);
template <typename T, typename Enable = void>
struct ANGLE_faceforward_impl
    static ANGLE_ALWAYS_INLINE T exec(T n, T i, T nref)
    {
        return metal::faceforward(n, i, nref);
    }
template <typename T>
struct ANGLE_faceforward_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T n, T i, T nref)
    {
        return ANGLE_dot(nref, i) < T(0) ? n : -n;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_faceforward(T n, T i, T nref)
    return ANGLE_faceforward_impl<T>::exec(n, i, nref);
template <typename T, typename Enable = void>
struct ANGLE_reflect_impl
    static ANGLE_ALWAYS_INLINE T exec(T i, T n)
    {
        return metal::reflect(i, n);
    }
template <typename T>
struct ANGLE_reflect_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T i, T n)
    {
        return i - T(2) * ANGLE_dot(n, i) * n;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_reflect(T i, T n)
    return ANGLE_reflect_impl<T>::exec(i, n);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
        if (!ANGLE_equal(u[i], v[i])) return false;
    return true;
template <typename T>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(T u, T v)
    return u == v;
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_equalStructArray(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
    {
        if (ANGLE_equal(u[i], v[i]) == false) 
            return false;
    }
    return true;
template <typename T, int N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::vec<T, N> u, metal::vec<T, N> v)
    return !ANGLE_equal(u, v);
template <typename T>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqualStruct(thread const T &a, thread const T &b)
    return !ANGLE_equal(a, b);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::array<T, N> u, metal::array<T, N> v)
    return !ANGLE_equal(u,v);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqualStructArray(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
    {
        if (ANGLE_notEqualStruct(u[i], v[i]))
            return true;
    }
    return false;
template <typename T, int C, int R>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::matrix<T, C, R> u, metal::matrix<T, C, R> v)
    return !ANGLE_equal(u, v);
#include <metal_geometric>
template <typename T, typename Enable = void>
struct ANGLE_sign_impl
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::sign(x);
    }
template <>
struct ANGLE_sign_impl<int>
    static ANGLE_ALWAYS_INLINE int exec(int x)
    {
        return (0 < x) - (x < 0);
    }
template <int N>
struct ANGLE_sign_impl<metal::vec<int, N>>
    static ANGLE_ALWAYS_INLINE metal::vec<int, N> exec(metal::vec<int, N> x)
    {
        metal::vec<int, N> s;
        for (int i = 0; i < N; ++i)
        {
            s[i] = ANGLE_sign_impl<int>::exec(x[i]);
        }
        return s;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_sign(T x)
    return ANGLE_sign_impl<T>::exec(x);
#include <metal_common>
template <typename T, int N>
ANGLE_ALWAYS_INLINE metal::vec<T,N> ANGLE_mix_bool(metal::vec<T, N> a, metal::vec<T, N> b, metal::vec<bool, N> c)
    return metal::mix(a, b, static_cast<metal::vec<T,N>>(c));
#include <metal_relational>
#include <metal_graphics>
#include <metal_matrix>
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator+(metal::matrix<T, Cols, Rows> m, T x)
    m += x;
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator+=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] += x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator-(metal::matrix<T, Cols, Rows> m, T x)
    m -= x;
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator-=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] -= x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator/(metal::matrix<T, Cols, Rows> a, metal::matrix<T, Cols, Rows> b)
    for (size_t col = 0; col < Cols; ++col)
    {
        a[col] /= b[col];
    }
    return a;
#if __METAL_VERSION__ <= 220
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator/(metal::matrix<T, Cols, Rows> m, T x)
    m /= x;
    return m;
#endif
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator/=(thread metal::matrix<T, Cols, Rows> &a, metal::matrix<T, Cols, Rows> b)
    a = a / b;
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator/=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] /= x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> ANGLE_componentWiseMultiply(metal::matrix<T, Cols, Rows> a, metal::matrix<T, Cols, Rows> b)
    for (size_t col = 0; col < Cols; ++col)
    {
        a[col] *= b[col];
    }
    return a;
template <typename T, int M, int N>
ANGLE_ALWAYS_INLINE metal::matrix<T, N, M> ANGLE_outerProduct(metal::vec<T, M> u, metal::vec<T, N> v)
    metal::matrix<T, N, M> o;
    for (size_t n = 0; n < N; ++n)
    {
        o[n] = u * v[n];
    }
    return o;
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 2, 2> ANGLE_inverse(metal::matrix<T, 2, 2> m)
    metal::matrix<T, 2, 2> adj;
    adj[0][0] =  m[1][1];
    adj[0][1] = -m[0][1];
    adj[1][0] = -m[1][0];
    adj[1][1] =  m[0][0];
    T det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]);
    return adj * (T(1) / det);
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 3, 3> ANGLE_inverse(metal::matrix<T, 3, 3> m)
    T a = m[1][1] * m[2][2] - m[2][1] * m[1][2];
    T b = m[1][0] * m[2][2];
    T c = m[1][2] * m[2][0];
    T d = m[1][0] * m[2][1];
    T det = m[0][0] * (a) -
            m[0][1] * (b - c) +
            m[0][2] * (d - m[1][1] * m[2][0]);
    det = T(1) / det;
    metal::matrix<T, 3, 3> minv;
    minv[0][0] = (a) * det;
    minv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * det;
    minv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * det;
    minv[1][0] = (c - b) * det;
    minv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * det;
    minv[1][2] = (m[1][0] * m[0][2] - m[0][0] * m[1][2]) * det;
    minv[2][0] = (d - m[2][0] * m[1][1]) * det;
    minv[2][1] = (m[2][0] * m[0][1] - m[0][0] * m[2][1]) * det;
    minv[2][2] = (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * det;
    return minv;
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 4, 4> ANGLE_inverse(metal::matrix<T, 4, 4> m)
    T A2323 = m[2][2] * m[3][3] - m[2][3] * m[3][2];
    T A1323 = m[2][1] * m[3][3] - m[2][3] * m[3][1];
    T A1223 = m[2][1] * m[3][2] - m[2][2] * m[3][1];
    T A0323 = m[2][0] * m[3][3] - m[2][3] * m[3][0];
    T A0223 = m[2][0] * m[3][2] - m[2][2] * m[3][0];
    T A0123 = m[2][0] * m[3][1] - m[2][1] * m[3][0];
    T A2313 = m[1][2] * m[3][3] - m[1][3] * m[3][2];
    T A1313 = m[1][1] * m[3][3] - m[1][3] * m[3][1];
    T A1213 = m[1][1] * m[3][2] - m[1][2] * m[3][1];
    T A2312 = m[1][2] * m[2][3] - m[1][3] * m[2][2];
    T A1312 = m[1][1] * m[2][3] - m[1][3] * m[2][1];
    T A1212 = m[1][1] * m[2][2] - m[1][2] * m[2][1];
    T A0313 = m[1][0] * m[3][3] - m[1][3] * m[3][0];
    T A0213 = m[1][0] * m[3][2] - m[1][2] * m[3][0];
    T A0312 = m[1][0] * m[2][3] - m[1][3] * m[2][0];
    T A0212 = m[1][0] * m[2][2] - m[1][2] * m[2][0];
    T A0113 = m[1][0] * m[3][1] - m[1][1] * m[3][0];
    T A0112 = m[1][0] * m[2][1] - m[1][1] * m[2][0];
    T a = m[1][1] * A2323 - m[1][2] * A1323 + m[1][3] * A1223;
    T b = m[1][0] * A2323 - m[1][2] * A0323 + m[1][3] * A0223;
    T c = m[1][0] * A1323 - m[1][1] * A0323 + m[1][3] * A0123;
    T d = m[1][0] * A1223 - m[1][1] * A0223 + m[1][2] * A0123;
    T det = m[0][0] * ( a )
          - m[0][1] * ( b )
          + m[0][2] * ( c )
          - m[0][3] * ( d );
    det = T(1) / det;
    metal::matrix<T, 4, 4> im;
    im[0][0] = det *   ( a );
    im[0][1] = det * - ( m[0][1] * A2323 - m[0][2] * A1323 + m[0][3] * A1223 );
    im[0][2] = det *   ( m[0][1] * A2313 - m[0][2] * A1313 + m[0][3] * A1213 );
    im[0][3] = det * - ( m[0][1] * A2312 - m[0][2] * A1312 + m[0][3] * A1212 );
    im[1][0] = det * - ( b );
    im[1][1] = det *   ( m[0][0] * A2323 - m[0][2] * A0323 + m[0][3] * A0223 );
    im[1][2] = det * - ( m[0][0] * A2313 - m[0][2] * A0313 + m[0][3] * A0213 );
    im[1][3] = det *   ( m[0][0] * A2312 - m[0][2] * A0312 + m[0][3] * A0212 );
    im[2][0] = det *   ( c );
    im[2][1] = det * - ( m[0][0] * A1323 - m[0][1] * A0323 + m[0][3] * A0123 );
    im[2][2] = det *   ( m[0][0] * A1313 - m[0][1] * A0313 + m[0][3] * A0113 );
    im[2][3] = det * - ( m[0][0] * A1312 - m[0][1] * A0312 + m[0][3] * A0112 );
    im[3][0] = det * - ( d );
    im[3][1] = det *   ( m[0][0] * A1223 - m[0][1] * A0223 + m[0][2] * A0123 );
    im[3][2] = det * - ( m[0][0] * A1213 - m[0][1] * A0213 + m[0][2] * A0113 );
    im[3][3] = det *   ( m[0][0] * A1212 - m[0][1] * A0212 + m[0][2] * A0112 );
    return im;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator*=(thread metal::matrix<T, Cols, Rows> &a, metal::matrix<T, Cols, Cols> b)
    a = a * b;
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator++(thread metal::matrix<T, Cols, Rows> &a)
    a += T(1);
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator++(thread metal::matrix<T, Cols, Rows> &a, int)
    auto b = a;
    a += T(1);
    return b;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator--(thread metal::matrix<T, Cols, Rows> &a)
    a -= T(1);
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator--(thread metal::matrix<T, Cols, Rows> &a, int)
    auto b = a;
    a -= T(1);
    return b;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator-(metal::matrix<T, Cols, Rows> m)
    for (size_t col = 0; col < Cols; ++col)
    {
        thread auto &mCol = m[col];
        mCol = -mCol;
    }
    return m;
#include <metal_pack>
ANGLE_ALWAYS_INLINE uint32_t ANGLE_pack_half_2x16(float2 v)
    return as_type<uint32_t>(half2(v));
ANGLE_ALWAYS_INLINE float2 ANGLE_unpack_half_2x16(uint32_t x)
    return float2(as_type<half2>(x));
fixIndexBufferKey
genIndexBuffer
fixIndexBuffer
Cannot have multiple different work group size specifiers
Cannot have multiple different primitive specifiers
Cannot have multiple different invocations specifiers
Cannot have multiple different max_vertices specifiers
Cannot have multiple different vertices specifiers
Cannot have multiple index specifiers
qualifier sequence
unknown geometry shader primitive type
The invariant qualifier specified multiple times.
The precise qualifier specified multiple times.
The precision qualifier specified multiple times.
The layout qualifier specified multiple times.
The layout qualifier and invariant qualifier cannot coexist in the same declaration according to the grammar.
The interpolation qualifier specified multiple times.
 specified multiple times
Output layout location specified multiple times.
The invariant qualifier has to be first in the expression.
Storage qualifiers have to be after interpolation qualifiers.
Precision qualifiers have to be after interpolation qualifiers.
Storage qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after storage qualifiers.
Precision qualifiers have to be after memory qualifiers.
invalid parameter qualifier
Invalid parameter qualifier 
invalid qualifier combination
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/queryconversions.cpp
CastStateValues
Application querying parameter that does not exist.
Unreachable Code.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/QueryGL.cpp
init
QueryMtl=%p
_webgl_struct_
Performance: dynamic indexing of vectors and matrices is emulated and can be slow.
dyn_index_
write_
ivec
bvec
uvec
base
value
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/RenderbufferGL.cpp
setStorage
functions->renderbufferStorage(GL_RENDERBUFFER, renderbufferFormat.internalFormat, width, height)
setStorageMultisample
functions->renderbufferStorageMultisample( GL_RENDERBUFFER, samples, renderbufferFormat.internalFormat, width, height)
functions->renderbufferStorageMultisampleEXT( GL_RENDERBUFFER, samples, renderbufferFormat.internalFormat, width, height)
functions->renderbufferStorageMultisampleIMG( GL_RENDERBUFFER, samples, renderbufferFormat.internalFormat, width, height)
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/RenderBufferMtl.mm
setStorageImpl
Integer overflow.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/renderer_utils.cpp
ComputeStartVertex
LogFeatureStatus
Feature: 
 enabled
 disabled
ANGLE_FEATURE_OVERRIDES_ENABLED
ANGLE_FEATURE_OVERRIDES_DISABLED
debug.angle.feature_overrides_enabled
debug.angle.feature_overrides_disabled
avoid1BitAlphaTextureFormats
Issue with 1-bit alpha framebuffer formats
RGBA4IsNotSupportedForColorRendering
GL_RGBA4 is not color renderable
allowETCFormats
Enable ETC2/EAC on desktop OpenGL
allowAstcFormats
Enable ASTC on desktop OpenGL
doesSRGBClearsOnLinearFramebufferAttachments
Issue clearing framebuffers with linear attachments when GL_FRAMEBUFFER_SRGB is enabled
doWhileGLSLCausesGPUHang
Some GLSL constructs involving do-while loops cause GPU hangs
http://crbug.com/644669
vertexIDDoesNotIncludeBaseVertex
gl_VertexID in GLSL vertex shader doesn't include base vertex value
finishDoesNotCauseQueriesToBeAvailable
glFinish doesn't cause all queries to report available result
alwaysCallUseProgramAfterLink
Always call useProgram after a successful link to avoid a driver bug
http://crbug.com/110263
unpackOverlappingRowsSeparatelyUnpackBuffer
In the case of unpacking from a pixel unpack buffer, unpack overlapping rows row by row
packOverlappingRowsSeparatelyPackBuffer
In the case of packing to a pixel pack buffer, pack overlapping rows row by row
initializeCurrentVertexAttributes
During initialization, assign the current vertex attributes to the spec-mandated defaults
emulateAbsIntFunction
abs(i) where i is an integer returns unexpected result
http://crbug.com/642227
addAndTrueToLoopCondition
Calculation of loop conditions in for and while loop has bug
unpackLastRowSeparatelyForPaddingInclusion
When uploading textures from an unpack buffer, some drivers count an extra row padding
http://anglebug.com/1512
packLastRowSeparatelyForPaddingInclusion
When uploading textures from an pack buffer, some drivers count an extra row padding
emulateIsnanFloat
Using isnan() on highp float will get wrong answer
http://crbug.com/650547
useUnusedBlocksWithStandardOrSharedLayout
Unused std140 or shared uniform blocks will be treated as inactive
removeInvariantAndCentroidForESSL3
Fix spec difference between GLSL 4.1 or lower and ESSL3
rewriteFloatUnaryMinusOperator
Using '-<float>' will get wrong answer
http://crbug.com/308366
emulateAtan2Float
atan(y, x) may return a wrong answer
http://crbug.com/672380
reapplyUBOBindingsAfterUsingBinaryProgram
Some drivers forget about UBO bindings when using program binaries
http://anglebug.com/1637
emulateMaxVertexAttribStride
Some drivers return 0 when MAX_VERTEX_ATTRIB_STRIED queried
http://anglebug.com/1936
dontInitializeUninitializedLocals
Initializing uninitialized locals caused odd behavior in a few WebGL 2 tests
http://anglebug.com/2046
clampPointSize
The point size range reported from the API is inconsistent with the actual behavior
dontUseLoopsToInitializeVariables
For loops used to initialize variables hit native GLSL compiler bugs
http://crbug.com/809422
clampFragDepth
gl_FragDepth is not clamped correctly when rendering to a floating point depth buffer
rewriteRepeatedAssignToSwizzled
Repeated assignment to swizzled values inside a GLSL user-defined function have incorrect results
disableBlendFuncExtended
ARB_blend_func_extended does not pass the tests
http://anglebug.com/1085
unsizedSRGBReadPixelsDoesntTransform
Drivers returning raw sRGB values instead of linearized values when calling glReadPixels on unsized sRGB texture formats
http://crbug.com/550292 http://crbug.com/565179
queryCounterBitsGeneratesErrors
Drivers generate errors when querying the number of bits in timer queries
http://anglebug.com/3027
dontRelinkProgramsInParallel
Relinking a program in parallel is buggy
http://anglebug.com/3045
disableWorkerContexts
Some tests have been seen to fail using worker contexts
http://crbug.com/849576
limitWebglMaxTextureSizeTo4096
Limit webgl max texture size to 4096 to avoid frequent out-of-memory errors
http://crbug.com/927470
limitMaxMSAASamplesTo4
Various rendering bugs have been observed when using higher MSAA counts
http://crbug.com/797243
allowClearForRobustResourceInit
Using glClear for robust resource initialization is buggy on some drivers and leads to texture corruption. Default to data uploads except on MacOS where it is very slow.
https://crbug.com/848952 http://crbug.com/883276
clampArrayAccess
Clamp uniform array access to avoid reading invalid memory.
http://anglebug.com/2978
resetTexImage2DBaseLevel
Reset texture base level before calling glTexImage2D to work around pixel comparison failure.
https://crbug.com/705865
clearToZeroOrOneBroken
Clears when the clear color is all zeros or ones do not work.
https://crbug.com/710443
limitMax3dArrayTextureSizeTo1024
Limit max 3d texture size and max array texture layers to 1024 to avoid system hang
adjustSrcDstRegionForBlitFramebuffer
Many platforms have issues with blitFramebuffer when the parameters are large.
http://crbug.com/830046
clipSrcRegionForBlitFramebuffer
Issues with blitFramebuffer when the parameters don't match the framebuffer size.
RGBDXT1TexturesSampleZeroAlpha
Sampling BLACK texels from RGB DXT1 textures returns transparent black on Mac.
http://anglebug.com/3729
unfoldShortCircuits
Mac incorrectly executes both sides of && and || expressions when they should short-circuit.
http://anglebug.com/482
emulatePrimitiveRestartFixedIndex
When GL_PRIMITIVE_RESTART_FIXED_INDEX is not available, emulate it with GL_PRIMITIVE_RESTART and glPrimitiveRestartIndex.
http://anglebug.com/3997
setPrimitiveRestartFixedIndexForDrawArrays
Some drivers discard vertex data in DrawArrays calls when the fixed primitive restart index is within the number of primitives being drawn.
removeDynamicIndexingOfSwizzledVector
Dynamic indexing of swizzled l-values doesn't work correctly on various platforms.
http://crbug.com/709351
preAddTexelFetchOffsets
Intel Mac drivers mistakenly consider the parameter position of nagative vaule as invalid even if the sum of position and offset is in range, so we need to add workarounds by rewriting texelFetchOffset(sampler, position, lod, offset) into texelFetch(sampler, position + offset, lod).
http://crbug.com/642605
regenerateStructNames
All Mac drivers do not handle struct scopes correctly. This workaround overwrites a structname with a unique prefix.
http://crbug.com/403957
readPixelsUsingImplementationColorReadFormatForNorm16
Quite some OpenGL ES drivers don't implement readPixels for RGBA/UNSIGNED_SHORT from EXT_texture_norm16 correctly
http://anglebug.com/4214
flushBeforeDeleteTextureIfCopiedTo
Some drivers track CopyTex{Sub}Image texture dependencies incorrectly. Flush before glDeleteTextures in this case
http://anglebug.com/4267
Rewrite row major matrices in shaders as column major as a driver bug workaround
http://anglebug.com/2273
Disable OES_draw_buffers_indexed extension.
disableSemaphoreFd
Disable GL_EXT_semaphore_fd extension
https://crbug.com/1046462
disableTimestampQueries
Disable GL_EXT_disjoint_timer_query extension
https://crbug.com/811661
decodeEncodeSRGBForGenerateMipmap
Decode and encode before generateMipmap for srgb format textures.
http://anglebug.com/4646
emulateCopyTexImage2D
Replace CopyTexImage2D with TexImage2D + CopyTexSubImage2D.
emulateCopyTexImage2DFromRenderbuffers
CopyTexImage2D spuriously returns errors on iOS when copying from renderbuffers.
https://anglebug.com/4674
disableGPUSwitchingSupport
Disable GPU switching support (use only the low-power GPU) on older MacBook Pros.
https://crbug.com/1091824
disableNativeParallelCompile
Do not use native KHR_parallel_shader_compile even when available.
http://crbug.com/1094869
emulatePackSkipRowsAndPackSkipPixels
GL_PACK_SKIP_ROWS and GL_PACK_SKIP_PIXELS are ignored in Apple's OpenGL driver.
https://anglebug.com/4849
clampMscRate
Some drivers return bogus values for GetMscRate, so we clamp it to 30Hz
https://crbug.com/1042393
bindTransformFeedbackBufferBeforeBindBufferRange
Bind transform feedback buffers to the generic binding point before calling glBindBufferBase or glBindBufferRange.
https://anglebug.com/5140
disableSyncControlSupport
Speculative fix for issues on Linux/Wayland where exposing GLX_OML_sync_control renders Chrome unusable
https://crbug.com/1137851
keepBufferShadowCopy
Maintain a shadow copy of buffer data when the GL API does not permit reading data back.
setZeroLevelBeforeGenerateMipmap
glGenerateMipmap fails if the zero texture level is not set on some Mac drivers.
promotePackedFormatsTo8BitPerChannel
Packed color formats are buggy on Macs with AMD GPUs
http://anglebug.com/5469
initFragmentOutputVariables
No init gl_FragColor causes context lost
http://crbug.com/1171371
shiftInstancedArrayDataWithOffset
glDrawArraysInstanced is buggy on certain new Mac Intel GPUs
http://crbug.com/1144207
syncVertexArraysToDefault
Only use the default VAO because of missing support or driver bugs
http://anglebug.com/5577
sanitizeAMDGPURendererString
Strip precise kernel and DRM version information from amdgpu renderer strings.
http://crbug.com/1181193
unbindFBOBeforeSwitchingContext
Imagination GL drivers are buggy with context switching.
flushOnFramebufferChange
Switching framebuffers without a flush can lead to crashes on Intel 9th Generation GPU Macs.
http://crbug.com/1181068
disableMultisampledRenderToTexture
Many drivers have bugs when using GL_EXT_multisampled_render_to_texture
http://anglebug.com/2894
uploadTextureDataInChunks
Upload texture data in <120kb chunks to work around Mac driver hangs and crashes.
emulateImmutableCompressedTexture3D
Use non-immutable texture allocation to work around a driver bug.
https://crbug.com/1060012
emulateRGB10
Emulate RGB10 support using RGB10_A2.
https://crbug.com/1300575
alwaysUnbindFramebufferTexture2D
Force unbind framebufferTexture2D before binding renderbuffer to work around driver bug.
https://anglebug.com/5536
disableTextureClampToBorder
Imagination devices generate INVALID_ENUM when setting the texture border color.
https://anglebug.com/7405
passHighpToPackUnormSnormBuiltins
packUnorm4x8 fails on Pixel 4 if it is not passed a highp vec4.
http://anglebug.com/7527
emulateClipDistanceState
Some drivers ignore GL_CLIP_DISTANCEi_EXT state.
supportsFragmentShaderInterlockNV
Backend GL context supports NV_fragment_shader_interlock extension
supportsFragmentShaderOrderingINTEL
Backend GL context supports GL_INTEL_fragment_shader_ordering extension
supportsFragmentShaderInterlockARB
Backend GL context supports ARB_fragment_shader_interlock extension
supportsShaderFramebufferFetchEXT
Backend GL context supports EXT_shader_framebuffer_fetch extension
supportsShaderFramebufferFetchNonCoherentEXT
Backend GL context supports EXT_shader_framebuffer_fetch_non_coherent extension
supportsShaderPixelLocalStorageEXT
Backend GL context supports EXT_shader_pixel_local_storage extension
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/RendererGL.cpp
LogGLDebugMessage
Source: 
Type: 
ID: 
Severity: 
Message: 
extension `GL_ARB_gpu_shader5' unsupported in
extension `GL_EXT_gpu_shader5' unsupported in
Adreno (TM) 418
Adreno (TM) 530
Adreno (TM) 540
GL_EXT_texture_array
GL_EXT_texture_lod_bias
GL_EXT_framebuffer_object
ARB_draw_buffers
GL_ARB_get_program_binary
GL_ARB_sync
GL_ARB_uniform_buffer_object
GL_ARB_transform_feedback2
GL_EXT_framebuffer_multisample
GL_ARB_sampler_objects
GL_ARB_texture_swizzle
GL_EXT_texture_swizzle
GL_ARB_explicit_attrib_location
GL_ARB_framebuffer_no_attachments
GL_ARB_texture_multisample
GL_ARB_vertex_attrib_binding
GL_ARB_shader_storage_buffer_object
GL_ARB_explicit_uniform_location
GL_ARB_texture_gather
GL_ARB_shader_image_load_store
GL_ARB_shader_atomic_counters
GL_ARB_texture_cube_map_array
GL_ARB_pixel_buffer_object
GL_EXT_pixel_buffer_object
GL_ARB_map_buffer_range
GL_EXT_draw_buffers2
GL_ARB_draw_buffers_blend
GL_EXT_framebuffer_blit
GL_ARB_fragment_shader
GL_ARB_shader_texture_lod
GL_ARB_shader_viewport_layer_array
GL_NV_viewport_array2
GL_NV_texture_border_clamp
GL_ARB_instanced_arrays
GL_ARB_draw_instanced
GL_ARB_vertex_array_object
GL_ARB_timer_query
GL_ARB_robustness
GL_ARB_robust_buffer_access_behavior
GL_EXT_framebuffer_sRGB
GL_ARB_framebuffer_sRGB
GL_ARB_invalidate_subdata
GL_ARB_blend_func_extended
GL_ARB_provoking_vertex
GL_EXT_provoking_vertex
GL_ARB_gpu_shader5
GL_ARB_cull_distance
GL_ARB_texture_buffer_object
functions->standard == STANDARD_GL_DESKTOP && isAMD
functions->standard == STANDARD_GL_DESKTOP && isIntel
isIntel && !IsSandyBridge(device) && !IsIvyBridge(device) && !IsHaswell(device)
!isMesa || isIntel && (Is9thGenIntel(device) || IsGeminiLake(device) || IsCoffeeLake(device) || Is11thGenIntel(device) || Is12thGenIntel(device))
IsApple() && isIntel
isIntel && IsApple() && IsSkylake(device) && GetMacOSVersion() < OSVersion(10, 13, 2)
isIntel || isAMD
IsLinux() && functions->standard == STANDARD_GL_DESKTOP && isAMD
(IsApple() && functions->standard == STANDARD_GL_DESKTOP) || (IsLinux() && isAMD)
IsApple() && functions->standard == STANDARD_GL_DESKTOP && GetMacOSVersion() < OSVersion(10, 11, 0)
IsApple() && isIntel && GetMacOSVersion() < OSVersion(10, 12, 0)
IsApple() && isAMD
IsAndroid() && isQualcomm
functions->standard == STANDARD_GL_DESKTOP && isNvidia
isNvidia
IsApple() || isNvidia
functions->isAtMostGL(gl::Version(4, 1)) || (functions->standard == STANDARD_GL_DESKTOP && isAMD)
isAMD || IsAndroid()
IsAndroid() || isNvidia
(IsAndroid() && isQualcomm) || (isIntel && IsApple())
isAMD || isIntel
IsNexus5X(vendor, device)
IsAndroid() || (IsWindows() && isIntel)
(IsWindows() && (isIntel || isAMD)) || (IsLinux() && isNvidia) || IsIOS() || IsAndroid() || IsAndroidEmulator(functions)
IsAndroid() || limitMaxTextureSize
IsAndroid() || (IsApple() && (isIntel || isAMD || isNvidia))
limitMaxTextureSize
IsApple()
IsAndroid() || isAMD || !functions->hasExtension("GL_KHR_robust_buffer_access_behavior")
IsApple() && isIntel && GetMacOSVersion() >= OSVersion(10, 12, 4)
IsApple() && isIntel && GetMacOSVersion() < OSVersion(10, 12, 6)
IsLinux() || (IsAndroid() && isNvidia) || (IsWindows() && isNvidia) || (IsApple() && functions->standard == STANDARD_GL_ES)
IsApple() || (IsLinux() && isAMD)
functions->standard == STANDARD_GL_DESKTOP && functions->isAtLeastGL(gl::Version(3, 1)) && !functions->isAtLeastGL(gl::Version(4, 3))
features->emulatePrimitiveRestartFixedIndex.enabled && IsApple() && isIntel
IsApple() || IsAndroid() || IsWindows()
!isIntel && functions->standard == STANDARD_GL_ES && functions->isAtLeastGLES(gl::Version(3, 1)) && functions->hasGLESExtension("GL_EXT_texture_norm16")
IsWindows() && isAMD
IsLinux() && isAMD && isMesa && mesaVersion < (std::array<int, 3>{19, 3, 5})
(IsLinux() && isVMWare) || (IsAndroid() && isNvidia) || (IsAndroid() && GetAndroidSdkLevel() < 27 && IsAdreno5xxOrOlder(functions)) || (IsAndroid() && IsMaliT8xxOrOlder(functions)) || (IsAndroid() && IsMaliG31OrOlder(functions))
IsApple() && functions->standard == STANDARD_GL_ES && !(isAMD && IsWindows())
isApple
isDualGPUMacWithNVIDIA
isTSANBuild && IsLinux() && isNvidia
IsLinux() && IsWayland()
IsLinux() && isIntel && isMesa && mesaVersion[0] == 20
!CanMapBufferForRead(functions)
IsApple() && hasAMD
IsAdreno42xOr3xx(functions)
IsApple() && IsIntel(vendor) && !IsHaswell(device)
!nativegl::SupportsVertexArrayObjects(functions)
IsLinux() && hasAMD
IsPowerVR(vendor)
IsApple() && Has9thGenIntelGPU(systemInfo)
isAdreno4xxOnAndroidLessThan51 || isAdreno4xxOnAndroid70 || isAdreno5xxOnAndroidLessThan70 || isAdreno5xxOnAndroid71 || isLinuxVivante
isQualcomm
functions->standard == STANDARD_GL_DESKTOP
isNvidia && (IsWindows() || IsLinux())
isImagination
functions->isAtLeastGL(gl::Version(4, 3)) && functions->hasGLExtension("GL_NV_fragment_shader_interlock")
functions->isAtLeastGL(gl::Version(4, 4)) && functions->hasGLExtension("GL_INTEL_fragment_shader_ordering")
functions->isAtLeastGL(gl::Version(4, 5)) && functions->hasGLExtension("GL_ARB_fragment_shader_interlock")
functions->hasGLESExtension("GL_EXT_shader_framebuffer_fetch")
functions->hasGLESExtension("GL_EXT_shader_framebuffer_fetch_non_coherent")
GL_EXT_shader_pixel_local_storage
functions->hasGLESExtension("GL_EXT_shader_pixel_local_storage")
IsPowerVrRogue(functions)
GL_ARB_compute_shader
GL_ARB_occlusion_query2
GL_EXT_occlusion_query_boolean
GL_ARB_internalformat_query2
Unexpected driver error.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/renderergl_utils.cpp
CheckError
GL call 
 generated error 
 in 
Additional GL error 
 generated.
Integer overflow.
ShouldApplyLastRowPaddingWorkaround
GenerateTextureFormatCaps
glGetInternalformativ generated error 
 for format 
. Skipping multisample checks.
CheckSizedInternalFormatTextureRenderability
CheckInternalFormatRenderbufferRenderability
Mesa %d.%d.%d
Adreno (TM) %d
FD%d
PowerVR Rogue
ClearErrors
Preexisting GL error 
 as of 
gl_ClipDistance
counters
atomicCounters
memoryBarrierBuffer
atomicAdd
textureCubeGrad
exp2
dPdx
dPdy
dUVdx
dUVdy
outerProduct
dFdx
dFdy
sign
ANGLECubeMapCoordTransform
ANGLECubeMapCoordTransformImplicit
lastFragmentOut
sampler
floor
beginInvocationInterlockNV
beginFragmentShaderOrderingINTEL
beginInvocationInterlockARB
endInvocationInterlockNV
endInvocationInterlockARB
unpackUnorm4x8
packUnorm4x8
from
transpose
main
GMT_DISABLE_SEPARATE_COMPOUND_EXPRESSIONS
SerializationNotAvailable
VERTEX
FRAGMENT
COMPUTE
GEOMETRY
TESS_CONTROL
TESS_EVALUATION
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Shader.cpp
resolveCompile
Integer overflow when computing the product of local_size_x, 
local_size_y and local_size_z.
The total number of invocations within a work group exceeds 
MAX_COMPUTE_WORK_GROUP_INVOCATIONS.
Exceeded maximum shared memory size
Failed to save compiled shader to memory shader cache.
Failed to allocate enough memory to serialize a shader. (
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/ShaderGL.cpp
checkShader
Shader compilation failed with no info log.
TranslateTaskGL::run
source
TranslateTask::run
<binary blob>
ANGLESurfaceRotation
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/State.cpp
setProgram
Attempted to use a program that was not successfully linked
gpu.angle
egl::Surface::prepareSwap
egl::Surface::swap
egl::Surface::swapWithDamage
egl::Surface::swapWithFrameToken
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Surface.cpp
operator()
Unhandled internal error: 
swapWithDamage implementation missing.
setPresentationTime implementation missing.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/SurfaceMtl.mm
obtainNextDrawable
main
atomicCounter
constant
device
thread
metal::texture1d<float>
metal::texture1d<int>
metal::texture1d<uint32_t>
metal::texture1d_array<float>
metal::texture1d_array<int>
metal::texture1d_array<uint32_t>
metal::texture_buffer<float>
metal::texture_buffer<int>
metal::texture_buffer<uint32_t>
metal::texture2d<float>
metal::texture2d<int>
metal::texture2d<uint32_t>
metal::texture3d<float>
metal::texture3d<int>
metal::texture3d<uint32_t>
metal::texturecube<float>
metal::texturecube<int>
metal::texturecube<uint32_t>
metal::texture2d_array<float>
metal::texture2d_array<int>
metal::texture2d_array<uint32_t>
metal::texture2d_ms<float>
metal::texture2d_ms<int>
metal::texture2d_ms<uint32_t>
metal::texture2d_ms_array<float>
metal::texture2d_ms_array<int>
metal::texture2d_ms_array<uint32_t>
metal::texturecube_array<float>
metal::texturecube_array<int>
metal::texturecube_array<uint32_t>
metal::TODO<float>
metal::TODO<int>
metal::TODO<uint32_t>
metal::depth2d<float>
metal::depth2d<int>
metal::depth2d<uint32_t>
metal::depthcube<float>
metal::depthcube<int>
metal::depthcube<uint32_t>
metal::depth2d_array<float>
metal::depth2d_array<int>
metal::depth2d_array<uint32_t>
metal::depthcube_array<float>
metal::depthcube_array<int>
metal::depthcube_array<uint32_t>
gl_in
angle_BaseInstance
angle_BaseVertex
gl_BaseInstance
gl_BaseVertex
gl_DrawID
gl_FragColor
gl_FragCoord
gl_FragDepth
gl_FrontFacing
gl_GlobalInvocationID
gl_HelperInvocation
gl_InstanceID
gl_InvocationID
gl_LastFragColor
gl_LastFragColorARM
gl_Layer
gl_LocalInvocationID
gl_LocalInvocationIndex
gl_NumSamples
gl_NumWorkGroups
gl_PatchVerticesIn
gl_PointCoord
gl_PointSize
gl_Position
gl_PrimitiveID
gl_PrimitiveIDIn
gl_SampleID
gl_SamplePosition
gl_SecondaryFragColorEXT
gl_TessCoord
gl_VertexID
gl_VertexIndex
gl_ViewID_OVR
gl_ViewportIndex
gl_WorkGroupID
gl_WorkGroupSize
gl_DepthRangeParameters
gl_DepthRange
gl_MaxVertexAttribs
gl_MaxVertexUniformVectors
gl_MaxVertexTextureImageUnits
gl_MaxCombinedTextureImageUnits
gl_MaxTextureImageUnits
gl_MaxFragmentUniformVectors
gl_MaxVaryingVectors
gl_MaxDrawBuffers
gl_MaxDualSourceDrawBuffersEXT
gl_MaxVertexOutputVectors
gl_MaxFragmentInputVectors
gl_MinProgramTexelOffset
gl_MaxProgramTexelOffset
gl_MaxImageUnits
gl_MaxVertexImageUniforms
gl_MaxFragmentImageUniforms
gl_MaxComputeImageUniforms
gl_MaxCombinedImageUniforms
gl_MaxCombinedShaderOutputResources
gl_MaxComputeWorkGroupCount
gl_MaxComputeWorkGroupSize
gl_MaxComputeUniformComponents
gl_MaxComputeTextureImageUnits
gl_MaxComputeAtomicCounters
gl_MaxComputeAtomicCounterBuffers
gl_MaxVertexAtomicCounters
gl_MaxFragmentAtomicCounters
gl_MaxCombinedAtomicCounters
gl_MaxAtomicCounterBindings
gl_MaxVertexAtomicCounterBuffers
gl_MaxFragmentAtomicCounterBuffers
gl_MaxCombinedAtomicCounterBuffers
gl_MaxAtomicCounterBufferSize
gl_MaxGeometryInputComponents
gl_MaxGeometryOutputComponents
gl_MaxGeometryImageUniforms
gl_MaxGeometryTextureImageUnits
gl_MaxGeometryOutputVertices
gl_MaxGeometryTotalOutputComponents
gl_MaxGeometryUniformComponents
gl_MaxGeometryAtomicCounters
gl_MaxGeometryAtomicCounterBuffers
gl_MaxTessControlInputComponents
gl_MaxTessControlOutputComponents
gl_MaxTessControlTextureImageUnits
gl_MaxTessControlUniformComponents
gl_MaxTessControlTotalOutputComponents
gl_MaxTessControlImageUniforms
gl_MaxTessControlAtomicCounters
gl_MaxTessControlAtomicCounterBuffers
gl_MaxTessPatchComponents
gl_MaxPatchVertices
gl_MaxTessGenLevel
gl_MaxTessEvaluationInputComponents
gl_MaxTessEvaluationOutputComponents
gl_MaxTessEvaluationTextureImageUnits
gl_MaxTessEvaluationUniformComponents
gl_MaxTessEvaluationImageUniforms
gl_MaxTessEvaluationAtomicCounters
gl_MaxTessEvaluationAtomicCounterBuffers
gl_MaxSamples
gl_MaxClipDistances
gl_MaxCullDistances
gl_MaxCombinedClipAndCullDistances
gl_FragData
gl_SecondaryFragDataEXT
gl_FragDepthEXT
gl_LastFragData
gl_SampleMaskIn
gl_SampleMask
gl_ClipDistance
gl_PerVertex
gl_in
gl_TessLevelOuter
gl_TessLevelInner
gl_out
gl_BoundingBox
gl_BoundingBoxEXT
gl_BoundingBoxOES
gl_CullDistance
radians(00B
radians(10B
radians(20B
radians(30B
degrees(00B
degrees(10B
degrees(20B
degrees(30B
sin(00B
sin(10B
sin(20B
sin(30B
cos(00B
cos(10B
cos(20B
cos(30B
tan(00B
tan(10B
tan(20B
tan(30B
asin(00B
asin(10B
asin(20B
asin(30B
acos(00B
acos(10B
acos(20B
acos(30B
atan(00B00B
atan(10B10B
atan(20B20B
atan(30B30B
atan(00B
atan(10B
atan(20B
atan(30B
sinh(00B
sinh(10B
sinh(20B
sinh(30B
cosh(00B
cosh(10B
cosh(20B
cosh(30B
tanh(00B
tanh(10B
tanh(20B
tanh(30B
asinh(00B
asinh(10B
asinh(20B
asinh(30B
acosh(00B
acosh(10B
acosh(20B
acosh(30B
atanh(00B
atanh(10B
atanh(20B
atanh(30B
pow(00B00B
pow(10B10B
pow(20B20B
pow(30B30B
exp(00B
exp(10B
exp(20B
exp(30B
log(00B
log(10B
log(20B
log(30B
exp2(00B
exp2(10B
exp2(20B
exp2(30B
log2(00B
log2(10B
log2(20B
log2(30B
sqrt(00B
sqrt(10B
sqrt(20B
sqrt(30B
inversesqrt(00B
inversesqrt(10B
inversesqrt(20B
inversesqrt(30B
abs(00B
abs(10B
abs(20B
abs(30B
abs(00D
abs(10D
abs(20D
abs(30D
sign(00B
sign(10B
sign(20B
sign(30B
sign(00D
sign(10D
sign(20D
sign(30D
floor(00B
floor(10B
floor(20B
floor(30B
trunc(00B
trunc(10B
trunc(20B
trunc(30B
round(00B
round(10B
round(20B
round(30B
roundEven(00B
roundEven(10B
roundEven(20B
roundEven(30B
ceil(00B
ceil(10B
ceil(20B
ceil(30B
fract(00B
fract(10B
fract(20B
fract(30B
mod(00B00B
mod(10B00B
mod(20B00B
mod(30B00B
mod(10B10B
mod(20B20B
mod(30B30B
min(00B00B
min(10B00B
min(20B00B
min(30B00B
min(10B10B
min(20B20B
min(30B30B
min(00D00D
min(10D10D
min(20D20D
min(30D30D
min(10D00D
min(20D00D
min(30D00D
min(00E00E
min(10E10E
min(20E20E
min(30E30E
min(10E00E
min(20E00E
min(30E00E
max(00B00B
max(10B00B
max(20B00B
max(30B00B
max(10B10B
max(20B20B
max(30B30B
max(00D00D
max(10D10D
max(20D20D
max(30D30D
max(10D00D
max(20D00D
max(30D00D
max(00E00E
max(10E10E
max(20E20E
max(30E30E
max(10E00E
max(20E00E
max(30E00E
clamp(00B00B00B
clamp(10B00B00B
clamp(20B00B00B
clamp(30B00B00B
clamp(10B10B10B
clamp(20B20B20B
clamp(30B30B30B
clamp(00D00D00D
clamp(10D00D00D
clamp(20D00D00D
clamp(30D00D00D
clamp(10D10D10D
clamp(20D20D20D
clamp(30D30D30D
clamp(00E00E00E
clamp(10E00E00E
clamp(20E00E00E
clamp(30E00E00E
clamp(10E10E10E
clamp(20E20E20E
clamp(30E30E30E
mix(00B00B00B
mix(10B10B00B
mix(20B20B00B
mix(30B30B00B
mix(10B10B10B
mix(20B20B20B
mix(30B30B30B
mix(00B00B00F
mix(10B10B10F
mix(20B20B20F
mix(30B30B30F
mix(00D00D00F
mix(10D10D10F
mix(20D20D20F
mix(30D30D30F
mix(00E00E00F
mix(10E10E10F
mix(20E20E20F
mix(30E30E30F
mix(00F00F00F
mix(10F10F10F
mix(20F20F20F
mix(30F30F30F
step(00B00B
step(10B10B
step(20B20B
step(30B30B
step(00B10B
step(00B20B
step(00B30B
smoothstep(00B00B00B
smoothstep(10B10B10B
smoothstep(20B20B20B
smoothstep(30B30B30B
smoothstep(00B00B10B
smoothstep(00B00B20B
smoothstep(00B00B30B
modf(00B00B
modf(10B10B
modf(20B20B
modf(30B30B
isnan(00B
isnan(10B
isnan(20B
isnan(30B
isinf(00B
isinf(10B
isinf(20B
isinf(30B
floatBitsToInt(00B
floatBitsToInt(10B
floatBitsToInt(20B
floatBitsToInt(30B
floatBitsToUint(00B
floatBitsToUint(10B
floatBitsToUint(20B
floatBitsToUint(30B
intBitsToFloat(00D
intBitsToFloat(10D
intBitsToFloat(20D
intBitsToFloat(30D
uintBitsToFloat(00E
uintBitsToFloat(10E
uintBitsToFloat(20E
uintBitsToFloat(30E
fma(00B00B00B
fma(10B10B10B
fma(20B20B20B
fma(30B30B30B
frexp(00B00D
frexp(10B10D
frexp(20B20D
frexp(30B30D
ldexp(00B00D
ldexp(10B10D
ldexp(20B20D
ldexp(30B30D
packSnorm2x16(10B
packHalf2x16(10B
unpackSnorm2x16(00E
unpackHalf2x16(00E
packUnorm2x16(10B
unpackUnorm2x16(00E
packUnorm4x8(30B
packSnorm4x8(30B
unpackUnorm4x8(00E
unpackSnorm4x8(00E
length(00B
length(10B
length(20B
length(30B
distance(00B00B
distance(10B10B
distance(20B20B
distance(30B30B
dot(00B00B
dot(10B10B
dot(20B20B
dot(30B30B
cross(20B20B
normalize(00B
normalize(10B
normalize(20B
normalize(30B
faceforward(00B00B00B
faceforward(10B10B10B
faceforward(20B20B20B
faceforward(30B30B30B
reflect(00B00B
reflect(10B10B
reflect(20B20B
reflect(30B30B
refract(00B00B00B
refract(10B10B00B
refract(20B20B00B
refract(30B30B00B
matrixCompMult(50B50B
matrixCompMult(A0BA0B
matrixCompMult(F0BF0B
matrixCompMult(90B90B
matrixCompMult(60B60B
matrixCompMult(D0BD0B
matrixCompMult(70B70B
matrixCompMult(E0BE0B
matrixCompMult(B0BB0B
outerProduct(10B10B
outerProduct(20B20B
outerProduct(30B30B
outerProduct(20B10B
outerProduct(10B20B
outerProduct(30B10B
outerProduct(10B30B
outerProduct(30B20B
outerProduct(20B30B
transpose(50B
transpose(A0B
transpose(F0B
transpose(60B
transpose(90B
transpose(70B
transpose(D0B
transpose(B0B
transpose(E0B
determinant(50B
determinant(A0B
determinant(F0B
inverse(50B
inverse(A0B
inverse(F0B
lessThan(10B10B
lessThan(20B20B
lessThan(30B30B
lessThan(10D10D
lessThan(20D20D
lessThan(30D30D
lessThan(10E10E
lessThan(20E20E
lessThan(30E30E
lessThanEqual(10B10B
lessThanEqual(20B20B
lessThanEqual(30B30B
lessThanEqual(10D10D
lessThanEqual(20D20D
lessThanEqual(30D30D
lessThanEqual(10E10E
lessThanEqual(20E20E
lessThanEqual(30E30E
greaterThan(10B10B
greaterThan(20B20B
greaterThan(30B30B
greaterThan(10D10D
greaterThan(20D20D
greaterThan(30D30D
greaterThan(10E10E
greaterThan(20E20E
greaterThan(30E30E
greaterThanEqual(10B10B
greaterThanEqual(20B20B
greaterThanEqual(30B30B
greaterThanEqual(10D10D
greaterThanEqual(20D20D
greaterThanEqual(30D30D
greaterThanEqual(10E10E
greaterThanEqual(20E20E
greaterThanEqual(30E30E
equal(10B10B
equal(20B20B
equal(30B30B
equal(10D10D
equal(20D20D
equal(30D30D
equal(10E10E
equal(20E20E
equal(30E30E
equal(10F10F
equal(20F20F
equal(30F30F
notEqual(10B10B
notEqual(20B20B
notEqual(30B30B
notEqual(10D10D
notEqual(20D20D
notEqual(30D30D
notEqual(10E10E
notEqual(20E20E
notEqual(30E30E
notEqual(10F10F
notEqual(20F20F
notEqual(30F30F
any(10F
any(20F
any(30F
all(10F
all(20F
all(30F
not(10F
not(20F
not(30F
bitfieldExtract(00D00D00D
bitfieldExtract(10D00D00D
bitfieldExtract(20D00D00D
bitfieldExtract(30D00D00D
bitfieldExtract(00E00D00D
bitfieldExtract(10E00D00D
bitfieldExtract(20E00D00D
bitfieldExtract(30E00D00D
bitfieldInsert(00D00D00D00D
bitfieldInsert(10D10D00D00D
bitfieldInsert(20D20D00D00D
bitfieldInsert(30D30D00D00D
bitfieldInsert(00E00E00D00D
bitfieldInsert(10E10E00D00D
bitfieldInsert(20E20E00D00D
bitfieldInsert(30E30E00D00D
bitfieldReverse(00D
bitfieldReverse(10D
bitfieldReverse(20D
bitfieldReverse(30D
bitfieldReverse(00E
bitfieldReverse(10E
bitfieldReverse(20E
bitfieldReverse(30E
bitCount(00D
bitCount(10D
bitCount(20D
bitCount(30D
bitCount(00E
bitCount(10E
bitCount(20E
bitCount(30E
findLSB(00D
findLSB(10D
findLSB(20D
findLSB(30D
findLSB(00E
findLSB(10E
findLSB(20E
findLSB(30E
findMSB(00D
findMSB(10D
findMSB(20D
findMSB(30D
findMSB(00E
findMSB(10E
findMSB(20E
findMSB(30E
uaddCarry(00E00E00E
uaddCarry(10E10E10E
uaddCarry(20E20E20E
uaddCarry(30E30E30E
usubBorrow(00E00E00E
usubBorrow(10E10E10E
usubBorrow(20E20E20E
usubBorrow(30E30E30E
umulExtended(00E00E00E00E
umulExtended(10E10E10E10E
umulExtended(20E20E20E20E
umulExtended(30E30E30E30E
imulExtended(00D00D00D00D
imulExtended(10D10D10D10D
imulExtended(20D20D20D20D
imulExtended(30D30D30D30D
texture2D(00I10B
texture2DProj(00I20B
texture2DProj(00I30B
textureCube(00K20B
texture3D(00J20B
texture3DProj(00J30B
shadow2DEXT(00d20B
shadow2DProjEXT(00d30B
texture2D(00M10B
texture2DProj(00M20B
texture2DProj(00M30B
texture2DRect(00O10B
texture2DRectProj(00O20B
texture2DRectProj(00O30B
texture2DGradEXT(00I10B10B10B
texture2DProjGradEXT(00I20B10B10B
texture2DProjGradEXT(00I30B10B10B
textureCubeGradEXT(00K20B20B20B
textureVideoWEBGL(00y10B
texture2D(00I10B00B
texture2DProj(00I20B00B
texture2DProj(00I30B00B
textureCube(00K20B00B
texture3D(00J20B00B
texture3DProj(00J30B00B
texture3DLod(00J20B00B
texture3DProjLod(00J30B00B
texture2DLod(00I10B00B
texture2DProjLod(00I20B00B
texture2DProjLod(00I30B00B
textureCubeLod(00K20B00B
texture2DLodEXT(00I10B00B
texture2DProjLodEXT(00I20B00B
texture2DProjLodEXT(00I30B00B
textureCubeLodEXT(00K20B00B
texture(00I10B
texture(00R10B
texture(00X10B
texture(00J20B
texture(00S20B
texture(00Y20B
texture(00K20B
texture(00T20B
texture(00Z20B
texture(00L20B
texture(00U20B
texture(00a20B
texture(00d20B
texture(00e30B
texture(00f30B
texture(00k30B
texture(00s30B
texture(00x30B
texture(00l30B00B
texture(00M10B
texture(00N10B
texture(00O10B
texture(00y10B
textureProj(00I20B
textureProj(00R20B
textureProj(00X20B
textureProj(00I30B
textureProj(00R30B
textureProj(00X30B
textureProj(00J30B
textureProj(00S30B
textureProj(00Y30B
textureProj(00d30B
textureProj(00M20B
textureProj(00M30B
textureProj(00N20B
textureProj(00N30B
textureProj(00O20B
textureProj(00O30B
textureLod(00I10B00B
textureLod(00R10B00B
textureLod(00X10B00B
textureLod(00J20B00B
textureLod(00S20B00B
textureLod(00Y20B00B
textureLod(00K20B00B
textureLod(00T20B00B
textureLod(00Z20B00B
textureLod(00L20B00B
textureLod(00U20B00B
textureLod(00a20B00B
textureLod(00d20B00B
textureLod(00k30B00B
textureLod(00s30B00B
textureLod(00x30B00B
textureSize(00I00D
textureSize(00R00D
textureSize(00X00D
textureSize(00J00D
textureSize(00S00D
textureSize(00Y00D
textureSize(00K00D
textureSize(00T00D
textureSize(00Z00D
textureSize(00L00D
textureSize(00U00D
textureSize(00a00D
textureSize(00d00D
textureSize(00e00D
textureSize(00f00D
textureSize(00k00D
textureSize(00s00D
textureSize(00x00D
textureSize(00l00D
textureSize(00j
textureSize(00r
textureSize(00w
textureSize(00P
textureSize(00V
textureSize(00b
textureSize(00Q
textureSize(00W
textureSize(00c
textureSize(00M00D
textureSize(00N00D
textureProjLod(00I20B00B
textureProjLod(00R20B00B
textureProjLod(00X20B00B
textureProjLod(00I30B00B
textureProjLod(00R30B00B
textureProjLod(00X30B00B
textureProjLod(00J30B00B
textureProjLod(00S30B00B
textureProjLod(00Y30B00B
textureProjLod(00d30B00B
texelFetch(00I10D00D
texelFetch(00R10D00D
texelFetch(00X10D00D
texelFetch(00J20D00D
texelFetch(00S20D00D
texelFetch(00Y20D00D
texelFetch(00L20D00D
texelFetch(00U20D00D
texelFetch(00a20D00D
texelFetch(00j00D
texelFetch(00r00D
texelFetch(00w00D
texelFetch(00P10D00D
texelFetch(00V10D00D
texelFetch(00b10D00D
texelFetch(00Q20D00D
texelFetch(00W20D00D
texelFetch(00c20D00D
texelFetch(00M10D00D
texelFetch(00N10D00D
textureGrad(00I10B10B10B
textureGrad(00R10B10B10B
textureGrad(00X10B10B10B
textureGrad(00J20B20B20B
textureGrad(00S20B20B20B
textureGrad(00Y20B20B20B
textureGrad(00K20B20B20B
textureGrad(00T20B20B20B
textureGrad(00Z20B20B20B
textureGrad(00d20B10B10B
textureGrad(00e30B20B20B
textureGrad(00L20B10B10B
textureGrad(00U20B10B10B
textureGrad(00a20B10B10B
textureGrad(00f30B10B10B
textureGrad(00k30B20B20B
textureGrad(00s30B20B20B
textureGrad(00x30B20B20B
textureProjGrad(00I20B10B10B
textureProjGrad(00R20B10B10B
textureProjGrad(00X20B10B10B
textureProjGrad(00I30B10B10B
textureProjGrad(00R30B10B10B
textureProjGrad(00X30B10B10B
textureProjGrad(00J30B20B20B
textureProjGrad(00S30B20B20B
textureProjGrad(00Y30B20B20B
textureProjGrad(00d30B10B10B
texture(00I10B00B
texture(00R10B00B
texture(00X10B00B
texture(00J20B00B
texture(00S20B00B
texture(00Y20B00B
texture(00K20B00B
texture(00T20B00B
texture(00Z20B00B
texture(00L20B00B
texture(00U20B00B
texture(00a20B00B
textureProj(00I20B00B
textureProj(00R20B00B
textureProj(00X20B00B
textureProj(00I30B00B
textureProj(00R30B00B
textureProj(00X30B00B
textureProj(00J30B00B
textureProj(00S30B00B
textureProj(00Y30B00B
texture(00d20B00B
texture(00e30B00B
textureProj(00d30B00B
texture(00k30B00B
texture(00s30B00B
texture(00x30B00B
texture(00M10B00B
textureProj(00M20B00B
textureProj(00M30B00B
texture(00N10B00B
textureProj(00N20B00B
textureProj(00N30B00B
textureOffset(00I10B10D
textureOffset(00R10B10D
textureOffset(00X10B10D
textureOffset(00J20B20D
textureOffset(00S20B20D
textureOffset(00Y20B20D
textureOffset(00d20B10D
textureOffset(00L20B10D
textureOffset(00U20B10D
textureOffset(00a20B10D
textureProjOffset(00I20B10D
textureProjOffset(00R20B10D
textureProjOffset(00X20B10D
textureProjOffset(00I30B10D
textureProjOffset(00R30B10D
textureProjOffset(00X30B10D
textureProjOffset(00J30B20D
textureProjOffset(00S30B20D
textureProjOffset(00Y30B20D
textureProjOffset(00d30B10D
textureLodOffset(00I10B00B10D
textureLodOffset(00R10B00B10D
textureLodOffset(00X10B00B10D
textureLodOffset(00J20B00B20D
textureLodOffset(00S20B00B20D
textureLodOffset(00Y20B00B20D
textureLodOffset(00d20B00B10D
textureLodOffset(00L20B00B10D
textureLodOffset(00U20B00B10D
textureLodOffset(00a20B00B10D
textureProjLodOffset(00I20B00B10D
textureProjLodOffset(00R20B00B10D
textureProjLodOffset(00X20B00B10D
textureProjLodOffset(00I30B00B10D
textureProjLodOffset(00R30B00B10D
textureProjLodOffset(00X30B00B10D
textureProjLodOffset(00J30B00B20D
textureProjLodOffset(00S30B00B20D
textureProjLodOffset(00Y30B00B20D
textureProjLodOffset(00d30B00B10D
texelFetchOffset(00I10D00D10D
texelFetchOffset(00R10D00D10D
texelFetchOffset(00X10D00D10D
texelFetchOffset(00J20D00D20D
texelFetchOffset(00S20D00D20D
texelFetchOffset(00Y20D00D20D
texelFetchOffset(00L20D00D10D
texelFetchOffset(00U20D00D10D
texelFetchOffset(00a20D00D10D
textureGradOffset(00I10B10B10B10D
textureGradOffset(00R10B10B10B10D
textureGradOffset(00X10B10B10B10D
textureGradOffset(00J20B20B20B20D
textureGradOffset(00S20B20B20B20D
textureGradOffset(00Y20B20B20B20D
textureGradOffset(00d20B10B10B10D
textureGradOffset(00L20B10B10B10D
textureGradOffset(00U20B10B10B10D
textureGradOffset(00a20B10B10B10D
textureGradOffset(00f30B10B10B10D
textureProjGradOffset(00I20B10B10B10D
textureProjGradOffset(00R20B10B10B10D
textureProjGradOffset(00X20B10B10B10D
textureProjGradOffset(00I30B10B10B10D
textureProjGradOffset(00R30B10B10B10D
textureProjGradOffset(00X30B10B10B10D
textureProjGradOffset(00J30B20B20B20D
textureProjGradOffset(00S30B20B20B20D
textureProjGradOffset(00Y30B20B20B20D
textureProjGradOffset(00d30B10B10B10D
textureOffset(00I10B10D00B
textureOffset(00R10B10D00B
textureOffset(00X10B10D00B
textureOffset(00J20B20D00B
textureOffset(00S20B20D00B
textureOffset(00Y20B20D00B
textureOffset(00d20B10D00B
textureOffset(00L20B10D00B
textureOffset(00U20B10D00B
textureOffset(00a20B10D00B
textureProjOffset(00I20B10D00B
textureProjOffset(00R20B10D00B
textureProjOffset(00X20B10D00B
textureProjOffset(00I30B10D00B
textureProjOffset(00R30B10D00B
textureProjOffset(00X30B10D00B
textureProjOffset(00J30B20D00B
textureProjOffset(00S30B20D00B
textureProjOffset(00Y30B20D00B
textureProjOffset(00d30B10D00B
textureGather(00I10B
textureGather(00R10B
textureGather(00X10B
textureGather(00I10B00D
textureGather(00R10B00D
textureGather(00X10B00D
textureGather(00L20B
textureGather(00U20B
textureGather(00a20B
textureGather(00L20B00D
textureGather(00U20B00D
textureGather(00a20B00D
textureGather(00K20B
textureGather(00T20B
textureGather(00Z20B
textureGather(00K20B00D
textureGather(00T20B00D
textureGather(00Z20B00D
textureGather(00k30B
textureGather(00s30B
textureGather(00x30B
textureGather(00k30B00D
textureGather(00s30B00D
textureGather(00x30B00D
textureGather(00l30B00B
textureGather(00d10B
textureGather(00d10B00B
textureGather(00f20B
textureGather(00f20B00B
textureGather(00e20B
textureGather(00e20B00B
textureGatherOffset(00I10B10D
textureGatherOffset(00R10B10D
textureGatherOffset(00X10B10D
textureGatherOffset(00L20B10D
textureGatherOffset(00U20B10D
textureGatherOffset(00a20B10D
textureGatherOffset(00d10B00B10D
textureGatherOffset(00f20B00B10D
textureGatherOffset(00I10B10D00D
textureGatherOffset(00R10B10D00D
textureGatherOffset(00X10B10D00D
textureGatherOffset(00L20B10D00D
textureGatherOffset(00U20B10D00D
textureGatherOffset(00a20B10D00D
textureGatherOffsets(00I10B10Dx4
textureGatherOffsets(00R10B10Dx4
textureGatherOffsets(00X10B10Dx4
textureGatherOffsets(00L20B10Dx4
textureGatherOffsets(00U20B10Dx4
textureGatherOffsets(00a20B10Dx4
textureGatherOffsets(00d10B00B10Dx4
textureGatherOffsets(00f20B00B10Dx4
textureGatherOffsets(00I10B10Dx400D
textureGatherOffsets(00R10B10Dx400D
textureGatherOffsets(00X10B10Dx400D
textureGatherOffsets(00L20B10Dx400D
textureGatherOffsets(00U20B10Dx400D
textureGatherOffsets(00a20B10Dx400D
rgb_2_yuv(20B00H
yuv_2_rgb(20B00H
dFdx(00B
dFdx(10B
dFdx(20B
dFdx(30B
dFdy(00B
dFdy(10B
dFdy(20B
dFdy(30B
fwidth(00B
fwidth(10B
fwidth(20B
fwidth(30B
interpolateAtCentroid(00B
interpolateAtCentroid(10B
interpolateAtCentroid(20B
interpolateAtCentroid(30B
interpolateAtSample(00B00D
interpolateAtSample(10B00D
interpolateAtSample(20B00D
interpolateAtSample(30B00D
interpolateAtOffset(00B10B
interpolateAtOffset(10B10B
interpolateAtOffset(20B10B
interpolateAtOffset(30B10B
atomicCounter(00G
atomicCounterIncrement(00G
atomicCounterDecrement(00G
atomicAdd(00E00E
atomicAdd(00D00D
atomicMin(00E00E
atomicMin(00D00D
atomicMax(00E00E
atomicMax(00D00D
atomicAnd(00E00E
atomicAnd(00D00D
atomicOr(00E00E
atomicOr(00D00D
atomicXor(00E00E
atomicXor(00D00D
atomicExchange(00E00E
atomicExchange(00D00D
atomicCompSwap(00E00E00E
atomicCompSwap(00D00D00D
imageSize(00z
imageSize(01K
imageSize(01V
imageSize(01A
imageSize(01L
imageSize(01W
imageSize(01B
imageSize(01M
imageSize(01X
imageSize(01C
imageSize(01N
imageSize(01Y
imageSize(01H
imageSize(01S
imageSize(01d
imageSize(01J
imageSize(01U
imageSize(01f
imageStore(00z10D30B
imageStore(01K10D30D
imageStore(01V10D30E
imageStore(01A20D30B
imageStore(01L20D30D
imageStore(01W20D30E
imageStore(01B20D30B
imageStore(01M20D30D
imageStore(01X20D30E
imageStore(01C20D30B
imageStore(01N20D30D
imageStore(01Y20D30E
imageStore(01H20D30B
imageStore(01S20D30D
imageStore(01d20D30E
imageStore(01J00D30B
imageStore(01U00D30D
imageStore(01f00D30E
imageLoad(00z10D
imageLoad(01K10D
imageLoad(01V10D
imageLoad(01A20D
imageLoad(01L20D
imageLoad(01W20D
imageLoad(01B20D
imageLoad(01M20D
imageLoad(01X20D
imageLoad(01C20D
imageLoad(01N20D
imageLoad(01Y20D
imageLoad(01H20D
imageLoad(01S20D
imageLoad(01d20D
imageLoad(01J00D
imageLoad(01U00D
imageLoad(01f00D
imageAtomicAdd(00z10D00E
imageAtomicAdd(01K10D00E
imageAtomicAdd(01V10D00E
imageAtomicAdd(01A20D00E
imageAtomicAdd(01L20D00E
imageAtomicAdd(01W20D00E
imageAtomicAdd(01C20D00E
imageAtomicAdd(01N20D00E
imageAtomicAdd(01Y20D00E
imageAtomicAdd(01J00D00E
imageAtomicAdd(01U00D00E
imageAtomicAdd(01f00D00E
imageAtomicAdd(01B20D00E
imageAtomicAdd(01M20D00E
imageAtomicAdd(01X20D00E
imageAtomicAdd(01H20D00E
imageAtomicAdd(01S20D00E
imageAtomicAdd(01d20D00E
imageAtomicAdd(01D00D00E
imageAtomicAdd(01O00D00E
imageAtomicAdd(01Z00D00E
imageAtomicAdd(01E10D00E
imageAtomicAdd(01P10D00E
imageAtomicAdd(01a10D00E
imageAtomicAdd(01I10D00E
imageAtomicAdd(01T10D00E
imageAtomicAdd(01e10D00E
imageAtomicAdd(01F10D00D00E
imageAtomicAdd(01Q10D00D00E
imageAtomicAdd(01b10D00D00E
imageAtomicAdd(01G20D00D00E
imageAtomicAdd(01R20D00D00E
imageAtomicAdd(01c20D00D00E
imageAtomicAdd(00z10D00D
imageAtomicAdd(01K10D00D
imageAtomicAdd(01V10D00D
imageAtomicAdd(01A20D00D
imageAtomicAdd(01L20D00D
imageAtomicAdd(01W20D00D
imageAtomicAdd(01C20D00D
imageAtomicAdd(01N20D00D
imageAtomicAdd(01Y20D00D
imageAtomicAdd(01J00D00D
imageAtomicAdd(01U00D00D
imageAtomicAdd(01f00D00D
imageAtomicAdd(01B20D00D
imageAtomicAdd(01M20D00D
imageAtomicAdd(01X20D00D
imageAtomicAdd(01H20D00D
imageAtomicAdd(01S20D00D
imageAtomicAdd(01d20D00D
imageAtomicAdd(01D00D00D
imageAtomicAdd(01O00D00D
imageAtomicAdd(01Z00D00D
imageAtomicAdd(01E10D00D
imageAtomicAdd(01P10D00D
imageAtomicAdd(01a10D00D
imageAtomicAdd(01I10D00D
imageAtomicAdd(01T10D00D
imageAtomicAdd(01e10D00D
imageAtomicAdd(01F10D00D00D
imageAtomicAdd(01Q10D00D00D
imageAtomicAdd(01b10D00D00D
imageAtomicAdd(01G20D00D00D
imageAtomicAdd(01R20D00D00D
imageAtomicAdd(01c20D00D00D
imageAtomicMin(00z10D00E
imageAtomicMin(01K10D00E
imageAtomicMin(01V10D00E
imageAtomicMin(01A20D00E
imageAtomicMin(01L20D00E
imageAtomicMin(01W20D00E
imageAtomicMin(01C20D00E
imageAtomicMin(01N20D00E
imageAtomicMin(01Y20D00E
imageAtomicMin(01J00D00E
imageAtomicMin(01U00D00E
imageAtomicMin(01f00D00E
imageAtomicMin(01B20D00E
imageAtomicMin(01M20D00E
imageAtomicMin(01X20D00E
imageAtomicMin(01H20D00E
imageAtomicMin(01S20D00E
imageAtomicMin(01d20D00E
imageAtomicMin(01D00D00E
imageAtomicMin(01O00D00E
imageAtomicMin(01Z00D00E
imageAtomicMin(01E10D00E
imageAtomicMin(01P10D00E
imageAtomicMin(01a10D00E
imageAtomicMin(01I10D00E
imageAtomicMin(01T10D00E
imageAtomicMin(01e10D00E
imageAtomicMin(01F10D00D00E
imageAtomicMin(01Q10D00D00E
imageAtomicMin(01b10D00D00E
imageAtomicMin(01G20D00D00E
imageAtomicMin(01R20D00D00E
imageAtomicMin(01c20D00D00E
imageAtomicMin(00z10D00D
imageAtomicMin(01K10D00D
imageAtomicMin(01V10D00D
imageAtomicMin(01A20D00D
imageAtomicMin(01L20D00D
imageAtomicMin(01W20D00D
imageAtomicMin(01C20D00D
imageAtomicMin(01N20D00D
imageAtomicMin(01Y20D00D
imageAtomicMin(01J00D00D
imageAtomicMin(01U00D00D
imageAtomicMin(01f00D00D
imageAtomicMin(01B20D00D
imageAtomicMin(01M20D00D
imageAtomicMin(01X20D00D
imageAtomicMin(01H20D00D
imageAtomicMin(01S20D00D
imageAtomicMin(01d20D00D
imageAtomicMin(01D00D00D
imageAtomicMin(01O00D00D
imageAtomicMin(01Z00D00D
imageAtomicMin(01E10D00D
imageAtomicMin(01P10D00D
imageAtomicMin(01a10D00D
imageAtomicMin(01I10D00D
imageAtomicMin(01T10D00D
imageAtomicMin(01e10D00D
imageAtomicMin(01F10D00D00D
imageAtomicMin(01Q10D00D00D
imageAtomicMin(01b10D00D00D
imageAtomicMin(01G20D00D00D
imageAtomicMin(01R20D00D00D
imageAtomicMin(01c20D00D00D
imageAtomicMax(00z10D00E
imageAtomicMax(01K10D00E
imageAtomicMax(01V10D00E
imageAtomicMax(01A20D00E
imageAtomicMax(01L20D00E
imageAtomicMax(01W20D00E
imageAtomicMax(01C20D00E
imageAtomicMax(01N20D00E
imageAtomicMax(01Y20D00E
imageAtomicMax(01J00D00E
imageAtomicMax(01U00D00E
imageAtomicMax(01f00D00E
imageAtomicMax(01B20D00E
imageAtomicMax(01M20D00E
imageAtomicMax(01X20D00E
imageAtomicMax(01H20D00E
imageAtomicMax(01S20D00E
imageAtomicMax(01d20D00E
imageAtomicMax(01D00D00E
imageAtomicMax(01O00D00E
imageAtomicMax(01Z00D00E
imageAtomicMax(01E10D00E
imageAtomicMax(01P10D00E
imageAtomicMax(01a10D00E
imageAtomicMax(01I10D00E
imageAtomicMax(01T10D00E
imageAtomicMax(01e10D00E
imageAtomicMax(01F10D00D00E
imageAtomicMax(01Q10D00D00E
imageAtomicMax(01b10D00D00E
imageAtomicMax(01G20D00D00E
imageAtomicMax(01R20D00D00E
imageAtomicMax(01c20D00D00E
imageAtomicMax(00z10D00D
imageAtomicMax(01K10D00D
imageAtomicMax(01V10D00D
imageAtomicMax(01A20D00D
imageAtomicMax(01L20D00D
imageAtomicMax(01W20D00D
imageAtomicMax(01C20D00D
imageAtomicMax(01N20D00D
imageAtomicMax(01Y20D00D
imageAtomicMax(01J00D00D
imageAtomicMax(01U00D00D
imageAtomicMax(01f00D00D
imageAtomicMax(01B20D00D
imageAtomicMax(01M20D00D
imageAtomicMax(01X20D00D
imageAtomicMax(01H20D00D
imageAtomicMax(01S20D00D
imageAtomicMax(01d20D00D
imageAtomicMax(01D00D00D
imageAtomicMax(01O00D00D
imageAtomicMax(01Z00D00D
imageAtomicMax(01E10D00D
imageAtomicMax(01P10D00D
imageAtomicMax(01a10D00D
imageAtomicMax(01I10D00D
imageAtomicMax(01T10D00D
imageAtomicMax(01e10D00D
imageAtomicMax(01F10D00D00D
imageAtomicMax(01Q10D00D00D
imageAtomicMax(01b10D00D00D
imageAtomicMax(01G20D00D00D
imageAtomicMax(01R20D00D00D
imageAtomicMax(01c20D00D00D
imageAtomicAnd(00z10D00E
imageAtomicAnd(01K10D00E
imageAtomicAnd(01V10D00E
imageAtomicAnd(01A20D00E
imageAtomicAnd(01L20D00E
imageAtomicAnd(01W20D00E
imageAtomicAnd(01C20D00E
imageAtomicAnd(01N20D00E
imageAtomicAnd(01Y20D00E
imageAtomicAnd(01J00D00E
imageAtomicAnd(01U00D00E
imageAtomicAnd(01f00D00E
imageAtomicAnd(01B20D00E
imageAtomicAnd(01M20D00E
imageAtomicAnd(01X20D00E
imageAtomicAnd(01H20D00E
imageAtomicAnd(01S20D00E
imageAtomicAnd(01d20D00E
imageAtomicAnd(01D00D00E
imageAtomicAnd(01O00D00E
imageAtomicAnd(01Z00D00E
imageAtomicAnd(01E10D00E
imageAtomicAnd(01P10D00E
imageAtomicAnd(01a10D00E
imageAtomicAnd(01I10D00E
imageAtomicAnd(01T10D00E
imageAtomicAnd(01e10D00E
imageAtomicAnd(01F10D00D00E
imageAtomicAnd(01Q10D00D00E
imageAtomicAnd(01b10D00D00E
imageAtomicAnd(01G20D00D00E
imageAtomicAnd(01R20D00D00E
imageAtomicAnd(01c20D00D00E
imageAtomicAnd(00z10D00D
imageAtomicAnd(01K10D00D
imageAtomicAnd(01V10D00D
imageAtomicAnd(01A20D00D
imageAtomicAnd(01L20D00D
imageAtomicAnd(01W20D00D
imageAtomicAnd(01C20D00D
imageAtomicAnd(01N20D00D
imageAtomicAnd(01Y20D00D
imageAtomicAnd(01J00D00D
imageAtomicAnd(01U00D00D
imageAtomicAnd(01f00D00D
imageAtomicAnd(01B20D00D
imageAtomicAnd(01M20D00D
imageAtomicAnd(01X20D00D
imageAtomicAnd(01H20D00D
imageAtomicAnd(01S20D00D
imageAtomicAnd(01d20D00D
imageAtomicAnd(01D00D00D
imageAtomicAnd(01O00D00D
imageAtomicAnd(01Z00D00D
imageAtomicAnd(01E10D00D
imageAtomicAnd(01P10D00D
imageAtomicAnd(01a10D00D
imageAtomicAnd(01I10D00D
imageAtomicAnd(01T10D00D
imageAtomicAnd(01e10D00D
imageAtomicAnd(01F10D00D00D
imageAtomicAnd(01Q10D00D00D
imageAtomicAnd(01b10D00D00D
imageAtomicAnd(01G20D00D00D
imageAtomicAnd(01R20D00D00D
imageAtomicAnd(01c20D00D00D
imageAtomicOr(00z10D00E
imageAtomicOr(01K10D00E
imageAtomicOr(01V10D00E
imageAtomicOr(01A20D00E
imageAtomicOr(01L20D00E
imageAtomicOr(01W20D00E
imageAtomicOr(01C20D00E
imageAtomicOr(01N20D00E
imageAtomicOr(01Y20D00E
imageAtomicOr(01J00D00E
imageAtomicOr(01U00D00E
imageAtomicOr(01f00D00E
imageAtomicOr(01B20D00E
imageAtomicOr(01M20D00E
imageAtomicOr(01X20D00E
imageAtomicOr(01H20D00E
imageAtomicOr(01S20D00E
imageAtomicOr(01d20D00E
imageAtomicOr(01D00D00E
imageAtomicOr(01O00D00E
imageAtomicOr(01Z00D00E
imageAtomicOr(01E10D00E
imageAtomicOr(01P10D00E
imageAtomicOr(01a10D00E
imageAtomicOr(01I10D00E
imageAtomicOr(01T10D00E
imageAtomicOr(01e10D00E
imageAtomicOr(01F10D00D00E
imageAtomicOr(01Q10D00D00E
imageAtomicOr(01b10D00D00E
imageAtomicOr(01G20D00D00E
imageAtomicOr(01R20D00D00E
imageAtomicOr(01c20D00D00E
imageAtomicOr(00z10D00D
imageAtomicOr(01K10D00D
imageAtomicOr(01V10D00D
imageAtomicOr(01A20D00D
imageAtomicOr(01L20D00D
imageAtomicOr(01W20D00D
imageAtomicOr(01C20D00D
imageAtomicOr(01N20D00D
imageAtomicOr(01Y20D00D
imageAtomicOr(01J00D00D
imageAtomicOr(01U00D00D
imageAtomicOr(01f00D00D
imageAtomicOr(01B20D00D
imageAtomicOr(01M20D00D
imageAtomicOr(01X20D00D
imageAtomicOr(01H20D00D
imageAtomicOr(01S20D00D
imageAtomicOr(01d20D00D
imageAtomicOr(01D00D00D
imageAtomicOr(01O00D00D
imageAtomicOr(01Z00D00D
imageAtomicOr(01E10D00D
imageAtomicOr(01P10D00D
imageAtomicOr(01a10D00D
imageAtomicOr(01I10D00D
imageAtomicOr(01T10D00D
imageAtomicOr(01e10D00D
imageAtomicOr(01F10D00D00D
imageAtomicOr(01Q10D00D00D
imageAtomicOr(01b10D00D00D
imageAtomicOr(01G20D00D00D
imageAtomicOr(01R20D00D00D
imageAtomicOr(01c20D00D00D
imageAtomicXor(00z10D00E
imageAtomicXor(01K10D00E
imageAtomicXor(01V10D00E
imageAtomicXor(01A20D00E
imageAtomicXor(01L20D00E
imageAtomicXor(01W20D00E
imageAtomicXor(01C20D00E
imageAtomicXor(01N20D00E
imageAtomicXor(01Y20D00E
imageAtomicXor(01J00D00E
imageAtomicXor(01U00D00E
imageAtomicXor(01f00D00E
imageAtomicXor(01B20D00E
imageAtomicXor(01M20D00E
imageAtomicXor(01X20D00E
imageAtomicXor(01H20D00E
imageAtomicXor(01S20D00E
imageAtomicXor(01d20D00E
imageAtomicXor(01D00D00E
imageAtomicXor(01O00D00E
imageAtomicXor(01Z00D00E
imageAtomicXor(01E10D00E
imageAtomicXor(01P10D00E
imageAtomicXor(01a10D00E
imageAtomicXor(01I10D00E
imageAtomicXor(01T10D00E
imageAtomicXor(01e10D00E
imageAtomicXor(01F10D00D00E
imageAtomicXor(01Q10D00D00E
imageAtomicXor(01b10D00D00E
imageAtomicXor(01G20D00D00E
imageAtomicXor(01R20D00D00E
imageAtomicXor(01c20D00D00E
imageAtomicXor(00z10D00D
imageAtomicXor(01K10D00D
imageAtomicXor(01V10D00D
imageAtomicXor(01A20D00D
imageAtomicXor(01L20D00D
imageAtomicXor(01W20D00D
imageAtomicXor(01C20D00D
imageAtomicXor(01N20D00D
imageAtomicXor(01Y20D00D
imageAtomicXor(01J00D00D
imageAtomicXor(01U00D00D
imageAtomicXor(01f00D00D
imageAtomicXor(01B20D00D
imageAtomicXor(01M20D00D
imageAtomicXor(01X20D00D
imageAtomicXor(01H20D00D
imageAtomicXor(01S20D00D
imageAtomicXor(01d20D00D
imageAtomicXor(01D00D00D
imageAtomicXor(01O00D00D
imageAtomicXor(01Z00D00D
imageAtomicXor(01E10D00D
imageAtomicXor(01P10D00D
imageAtomicXor(01a10D00D
imageAtomicXor(01I10D00D
imageAtomicXor(01T10D00D
imageAtomicXor(01e10D00D
imageAtomicXor(01F10D00D00D
imageAtomicXor(01Q10D00D00D
imageAtomicXor(01b10D00D00D
imageAtomicXor(01G20D00D00D
imageAtomicXor(01R20D00D00D
imageAtomicXor(01c20D00D00D
imageAtomicExchange(00z10D00E
imageAtomicExchange(01K10D00E
imageAtomicExchange(01V10D00E
imageAtomicExchange(01A20D00E
imageAtomicExchange(01L20D00E
imageAtomicExchange(01W20D00E
imageAtomicExchange(01C20D00E
imageAtomicExchange(01N20D00E
imageAtomicExchange(01Y20D00E
imageAtomicExchange(01J00D00E
imageAtomicExchange(01U00D00E
imageAtomicExchange(01f00D00E
imageAtomicExchange(01B20D00E
imageAtomicExchange(01M20D00E
imageAtomicExchange(01X20D00E
imageAtomicExchange(01H20D00E
imageAtomicExchange(01S20D00E
imageAtomicExchange(01d20D00E
imageAtomicExchange(01D00D00E
imageAtomicExchange(01O00D00E
imageAtomicExchange(01Z00D00E
imageAtomicExchange(01E10D00E
imageAtomicExchange(01P10D00E
imageAtomicExchange(01a10D00E
imageAtomicExchange(01I10D00E
imageAtomicExchange(01T10D00E
imageAtomicExchange(01e10D00E
imageAtomicExchange(01F10D00D00E
imageAtomicExchange(01Q10D00D00E
imageAtomicExchange(01b10D00D00E
imageAtomicExchange(01G20D00D00E
imageAtomicExchange(01R20D00D00E
imageAtomicExchange(01c20D00D00E
imageAtomicExchange(00z10D00D
imageAtomicExchange(01K10D00D
imageAtomicExchange(01V10D00D
imageAtomicExchange(01A20D00D
imageAtomicExchange(01L20D00D
imageAtomicExchange(01W20D00D
imageAtomicExchange(01C20D00D
imageAtomicExchange(01N20D00D
imageAtomicExchange(01Y20D00D
imageAtomicExchange(01J00D00D
imageAtomicExchange(01U00D00D
imageAtomicExchange(01f00D00D
imageAtomicExchange(01B20D00D
imageAtomicExchange(01M20D00D
imageAtomicExchange(01X20D00D
imageAtomicExchange(01H20D00D
imageAtomicExchange(01S20D00D
imageAtomicExchange(01d20D00D
imageAtomicExchange(01D00D00D
imageAtomicExchange(01O00D00D
imageAtomicExchange(01Z00D00D
imageAtomicExchange(01E10D00D
imageAtomicExchange(01P10D00D
imageAtomicExchange(01a10D00D
imageAtomicExchange(01I10D00D
imageAtomicExchange(01T10D00D
imageAtomicExchange(01e10D00D
imageAtomicExchange(01F10D00D00D
imageAtomicExchange(01Q10D00D00D
imageAtomicExchange(01b10D00D00D
imageAtomicExchange(01G20D00D00D
imageAtomicExchange(01R20D00D00D
imageAtomicExchange(01c20D00D00D
imageAtomicExchange(00z10D00B
imageAtomicExchange(01K10D00B
imageAtomicExchange(01V10D00B
imageAtomicExchange(01A20D00B
imageAtomicExchange(01L20D00B
imageAtomicExchange(01W20D00B
imageAtomicExchange(01C20D00B
imageAtomicExchange(01N20D00B
imageAtomicExchange(01Y20D00B
imageAtomicExchange(01J00D00B
imageAtomicExchange(01U00D00B
imageAtomicExchange(01f00D00B
imageAtomicExchange(01B20D00B
imageAtomicExchange(01M20D00B
imageAtomicExchange(01X20D00B
imageAtomicExchange(01H20D00B
imageAtomicExchange(01S20D00B
imageAtomicExchange(01d20D00B
imageAtomicExchange(01D00D00B
imageAtomicExchange(01O00D00B
imageAtomicExchange(01Z00D00B
imageAtomicExchange(01E10D00B
imageAtomicExchange(01P10D00B
imageAtomicExchange(01a10D00B
imageAtomicExchange(01I10D00B
imageAtomicExchange(01T10D00B
imageAtomicExchange(01e10D00B
imageAtomicExchange(01F10D00D00B
imageAtomicExchange(01Q10D00D00B
imageAtomicExchange(01b10D00D00B
imageAtomicExchange(01G20D00D00B
imageAtomicExchange(01R20D00D00B
imageAtomicExchange(01c20D00D00B
imageAtomicCompSwap(00z10D00E00E
imageAtomicCompSwap(01K10D00E00E
imageAtomicCompSwap(01V10D00E00E
imageAtomicCompSwap(01A20D00E00E
imageAtomicCompSwap(01L20D00E00E
imageAtomicCompSwap(01W20D00E00E
imageAtomicCompSwap(01C20D00E00E
imageAtomicCompSwap(01N20D00E00E
imageAtomicCompSwap(01Y20D00E00E
imageAtomicCompSwap(01J00D00E00E
imageAtomicCompSwap(01U00D00E00E
imageAtomicCompSwap(01f00D00E00E
imageAtomicCompSwap(01B20D00E00E
imageAtomicCompSwap(01M20D00E00E
imageAtomicCompSwap(01X20D00E00E
imageAtomicCompSwap(01H20D00E00E
imageAtomicCompSwap(01S20D00E00E
imageAtomicCompSwap(01d20D00E00E
imageAtomicCompSwap(01D00D00E00E
imageAtomicCompSwap(01O00D00E00E
imageAtomicCompSwap(01Z00D00E00E
imageAtomicCompSwap(01E10D00E00E
imageAtomicCompSwap(01P10D00E00E
imageAtomicCompSwap(01a10D00E00E
imageAtomicCompSwap(01I10D00E00E
imageAtomicCompSwap(01T10D00E00E
imageAtomicCompSwap(01e10D00E00E
imageAtomicCompSwap(01F10D00D00E00E
imageAtomicCompSwap(01Q10D00D00E00E
imageAtomicCompSwap(01b10D00D00E00E
imageAtomicCompSwap(01G20D00D00E00E
imageAtomicCompSwap(01R20D00D00E00E
imageAtomicCompSwap(01c20D00D00E00E
imageAtomicCompSwap(00z10D00D00D
imageAtomicCompSwap(01K10D00D00D
imageAtomicCompSwap(01V10D00D00D
imageAtomicCompSwap(01A20D00D00D
imageAtomicCompSwap(01L20D00D00D
imageAtomicCompSwap(01W20D00D00D
imageAtomicCompSwap(01C20D00D00D
imageAtomicCompSwap(01N20D00D00D
imageAtomicCompSwap(01Y20D00D00D
imageAtomicCompSwap(01J00D00D00D
imageAtomicCompSwap(01U00D00D00D
imageAtomicCompSwap(01f00D00D00D
imageAtomicCompSwap(01B20D00D00D
imageAtomicCompSwap(01M20D00D00D
imageAtomicCompSwap(01X20D00D00D
imageAtomicCompSwap(01H20D00D00D
imageAtomicCompSwap(01S20D00D00D
imageAtomicCompSwap(01d20D00D00D
imageAtomicCompSwap(01D00D00D00D
imageAtomicCompSwap(01O00D00D00D
imageAtomicCompSwap(01Z00D00D00D
imageAtomicCompSwap(01E10D00D00D
imageAtomicCompSwap(01P10D00D00D
imageAtomicCompSwap(01a10D00D00D
imageAtomicCompSwap(01I10D00D00D
imageAtomicCompSwap(01T10D00D00D
imageAtomicCompSwap(01e10D00D00D
imageAtomicCompSwap(01F10D00D00D00D
imageAtomicCompSwap(01Q10D00D00D00D
imageAtomicCompSwap(01b10D00D00D00D
imageAtomicCompSwap(01G20D00D00D00D
imageAtomicCompSwap(01R20D00D00D00D
imageAtomicCompSwap(01c20D00D00D00D
pixelLocalLoadANGLE(01g
pixelLocalLoadANGLE(01h
pixelLocalLoadANGLE(01i
pixelLocalStoreANGLE(01g30B
pixelLocalStoreANGLE(01h30D
pixelLocalStoreANGLE(01i30E
beginInvocationInterlockNV(
endInvocationInterlockNV(
beginFragmentShaderOrderingINTEL(
beginInvocationInterlockARB(
endInvocationInterlockARB(
memoryBarrier(
memoryBarrierAtomicCounter(
memoryBarrierBuffer(
memoryBarrierImage(
barrier(
memoryBarrierShared(
groupMemoryBarrier(
EmitVertex(
EndPrimitive(
subpassLoad(01j
subpassLoad(01k
subpassLoad(01l
subpassLoad(01m00D
subpassLoad(01n00D
subpassLoad(01o00D
radians
degrees
asin
acos
atan
sinh
cosh
tanh
asinh
acosh
atanh
exp2
log2
sqrt
inversesqrt
sign
floor
trunc
round
roundEven
ceil
fract
clamp
step
smoothstep
modf
isnan
isinf
floatBitsToInt
floatBitsToUint
intBitsToFloat
uintBitsToFloat
frexp
ldexp
packSnorm2x16
packHalf2x16
unpackSnorm2x16
unpackHalf2x16
packUnorm2x16
unpackUnorm2x16
packUnorm4x8
packSnorm4x8
unpackUnorm4x8
unpackSnorm4x8
length
distance
cross
normalize
faceforward
reflect
refract
matrixCompMult
outerProduct
transpose
determinant
inverse
lessThan
lessThanEqual
greaterThan
greaterThanEqual
equal
notEqual
bitfieldExtract
bitfieldInsert
bitfieldReverse
bitCount
findLSB
findMSB
uaddCarry
usubBorrow
umulExtended
imulExtended
texture2D
texture2DProj
textureCube
texture3D
texture3DProj
shadow2DEXT
shadow2DProjEXT
texture2DRect
texture2DRectProj
texture2DGradEXT
texture2DProjGradEXT
textureCubeGradEXT
textureVideoWEBGL
texture3DLod
texture3DProjLod
texture2DLod
texture2DProjLod
textureCubeLod
texture2DLodEXT
texture2DProjLodEXT
textureCubeLodEXT
texture
textureProj
textureLod
textureSize
textureProjLod
texelFetch
textureGrad
textureProjGrad
textureOffset
textureProjOffset
textureLodOffset
textureProjLodOffset
texelFetchOffset
textureGradOffset
textureProjGradOffset
textureGather
textureGatherOffset
textureGatherOffsets
rgb_2_yuv
yuv_2_rgb
dFdx
dFdy
fwidth
interpolateAtCentroid
interpolateAtSample
interpolateAtOffset
atomicCounter
atomicCounterIncrement
atomicCounterDecrement
atomicAdd
atomicMin
atomicMax
atomicAnd
atomicOr
atomicXor
atomicExchange
atomicCompSwap
imageSize
imageStore
imageLoad
imageAtomicAdd
imageAtomicMin
imageAtomicMax
imageAtomicAnd
imageAtomicOr
imageAtomicXor
imageAtomicExchange
imageAtomicCompSwap
pixelLocalLoadANGLE
pixelLocalStoreANGLE
beginInvocationInterlockNV
endInvocationInterlockNV
beginFragmentShaderOrderingINTEL
beginInvocationInterlockARB
endInvocationInterlockARB
memoryBarrier
memoryBarrierAtomicCounter
memoryBarrierBuffer
memoryBarrierImage
barrier
memoryBarrierShared
groupMemoryBarrier
EmitVertex
EndPrimitive
subpassLoad
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/SyncGL.cpp
v24@?0@"<MTLSharedEvent>"8Q16
v8@?0
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/Texture.cpp
onDestroy
Unhandled internal error: 
Error releasing tex image from texture
releaseTexImageInternal
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/TextureGL.cpp
setImageHelper
functions->texImage2D(nativegl::GetTextureBindingTarget(target), static_cast<GLint>(level), texImageFormat.internalFormat, size.width, size.height, 0, texImageFormat.format, texImageFormat.type, pixels)
functions->texImage3D(ToGLenum(target), static_cast<GLint>(level), texImageFormat.internalFormat, size.width, size.height, size.depth, 0, texImageFormat.format, texImageFormat.type, pixels)
functions->texImage2D(nativegl::GetTextureBindingTarget(target), 0, texImageFormat.internalFormat, 1, 1, 0, texImageFormat.format, texImageFormat.type, nullptr)
setSubImageRowByRowWorkaround
Chunking upload of texture data to work around driver hangs.
setSubImagePaddingWorkaround
setCompressedImage
functions->compressedTexImage2D(ToGLenum(target), static_cast<GLint>(level), compressedTexImageFormat.internalFormat, size.width, size.height, 0, static_cast<GLsizei>(imageSize), pixels)
functions->compressedTexImage3D(ToGLenum(target), static_cast<GLint>(level), compressedTexImageFormat.internalFormat, size.width, size.height, size.depth, 0, static_cast<GLsizei>(imageSize), pixels)
copyImage
functions->texImage2D(ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), type, zero->data())
functions->texImage2D( ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), type, nullptr)
functions->copyTexSubImage2D(ToGLenum(target), static_cast<GLint>(level), 0, 0, sourceArea.x, sourceArea.y, sourceArea.width, sourceArea.height)
functions->copyTexImage2D( ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, sourceArea.x, sourceArea.y, sourceArea.width, sourceArea.height, 0)
functions->texStorage2D(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height)
functions->compressedTexImage2D( ToGLenum(type), static_cast<GLint>(level), compressedTexImageFormat.format, levelSize.width, levelSize.height, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage2D(ToGLenum(type), static_cast<GLint>(level), texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->compressedTexImage2D( ToGLenum(face), static_cast<GLint>(level), compressedTexImageFormat.format, levelSize.width, levelSize.height, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage2D( ToGLenum(face), static_cast<GLint>(level), texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->texStorage3D(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, size.depth)
functions->compressedTexImage3D( ToGLenum(type), i, compressedTexImageFormat.format, levelSize.width, levelSize.height, levelSize.depth, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage3D(ToGLenum(type), i, texImageFormat.internalFormat, levelSize.width, levelSize.height, levelSize.depth, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->texStorage2DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, gl::ConvertToGLBoolean(fixedSampleLocations))
functions->texImage2DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, gl::ConvertToGLBoolean(fixedSampleLocations))
functions->texStorage3DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, size.depth, gl::ConvertToGLBoolean(fixedSampleLocations))
setStorageExternalMemory
functions->texStorageMem2DEXT(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, memoryObjectGL->getMemoryObjectID(), offset)
functions->texStorageMem3DEXT(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, size.depth, memoryObjectGL->getMemoryObjectID(), offset)
setImageExternal
generateMipmap
functions->texImage2D( ToGLenum(getType()), effectiveBaseLevel + levelIdx, texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->generateMipmap(ToGLenum(getType()))
initializeContents
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/TextureMtl.mm
ensureTextureCreated
generateMipmapCPU
getAttachmentRenderTarget
setSubImageImpl
setPerSliceSubImage
convertAndSetPerSliceSubImage
copySubImageCPU
copySubTextureCPU
UploadPackedDepthStencilTextureContentsWithStagingBuffer
equal
Failed to allocate host memory
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/TransformFeedbackMtl.mm
getBufferOffsets
// BEGIN: Generated code for built-in function emulation
#if defined(GL_FRAGMENT_PRECISION_HIGH)
#define emu_precision highp
#define emu_precision mediump
#endif
// END: Generated code for built-in function emulation
#extension GL_NV_shader_framebuffer_fetch : 
#extension GL_NV_draw_buffers : 
#ifdef GL_EXT_geometry_shader
#extension GL_EXT_geometry_shader : 
#elif defined GL_OES_geometry_shader
#extension GL_OES_geometry_shader : 
#error "No geometry shader extensions available." // Only generate this if the extension is "required"
#extension GL_EXT_clip_cull_distance : 
#extension GL_EXT_shader_io_blocks : 
#extension GL_EXT_shader_pixel_local_storage : enable
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_EXT_shader_framebuffer_fetch : 
#extension GL_EXT_shader_framebuffer_fetch_non_coherent : 
#extension 
invariant gl_Position;
#define emu_precision
out vec4 webgl_FragColor;
out vec4 webgl_FragData[gl_MaxDrawBuffers];
out vec4 webgl_SecondaryFragColor;
out vec4 webgl_SecondaryFragData[
#extension GL_ARB_shader_texture_lod : 
#extension GL_ARB_draw_buffers : 
#extension GL_ARB_geometry_shader4 : 
#extension GL_ARB_texture_multisample : 
#extension GL_ARB_cull_distance : 
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_gpu_shader5 : enable
#extension GL_ARB_texture_cube_map_array : enable
#extension GL_OES_texture_cube_map_array : enable
#extension GL_EXT_texture_cube_map_array : enable
#extension GL_ARB_texture_buffer_objects : enable
#extension GL_OES_texture_buffer : enable
#extension GL_EXT_texture_buffer : enable
 : enable
 : require
mask
writeSampleMask
gl_FragData_
flippedPointCoord
flippedFragCoord
ClipDistance_
@@XFB-OUT@@
void
float
uint
bool
yuvCscStandardEXT
sampler2D
sampler3D
samplerCube
samplerExternalOES
__samplerExternal2DY2YEXT
sampler2DRect
sampler2DArray
sampler2DMS
sampler2DMSArray
samplerCubeArray
samplerBuffer
isampler2D
isampler3D
isamplerCube
isampler2DArray
isampler2DMS
isampler2DMSArray
isamplerCubeArray
isamplerBuffer
usampler2D
usampler3D
usamplerCube
usampler2DArray
usampler2DMS
usampler2DMSArray
usamplerCubeArray
usamplerBuffer
sampler2DShadow
samplerCubeShadow
sampler2DArrayShadow
samplerCubeArrayShadow
structure
interface block
image2D
iimage2D
uimage2D
image3D
iimage3D
uimage3D
image2DArray
iimage2DArray
uimage2DArray
imageCube
iimageCube
uimageCube
imageCubeArray
iimageCubeArray
uimageCubeArray
imageBuffer
iimageBuffer
uimageBuffer
atomic_uint
samplerVideoWEBGL
pixelLocalANGLE
ipixelLocalANGLE
upixelLocalANGLE
subpassInput
isubpassInput
usubpassInput
subpassInputMS
isubpassInputMS
usubpassInputMS
unknown type
mat2
mat2x3
mat2x4
mat3x2
mat3
mat3x4
mat4x2
mat4x3
mat4
vec2
vec3
vec4
ivec2
ivec3
ivec4
bvec2
bvec3
bvec4
uvec2
uvec3
uvec4
Unknown error.
Window System
Shader Compiler
Third Party
Application
Other
Unknown Source
Error
Deprecated behavior
Undefined behavior
Portability
Performance
Marker
Unknown Type
High
Medium
Notification
Unknown Severity
Not initialized.
Bad access.
Bad allocation.
Bad attribute.
Bad config.
Bad context.
Bad current surface.
Bad display.
Bad match.
Bad native window.
Bad native pixmap.
Bad parameter.
Bad surface.
Context lost.
Bad stream.
Bad state.
Bad device.
Unexpected transformation after AST post-processing
<validateNoMoreTransformations>
Found symbol with undefined precision <validatePrecision>
Found child with two parents
<validateSingleParent>
Found dead code after branch
<validateNoStatementsAfterBranch>
Found reference to undeclared or inconsistenly transformed nameless interface block <validateVariableReferences>
Found reference to inconsistenly transformed nameless interface block field <validateVariableReferences>
Found reference to undeclared or inconsistently transformed variable <validateVariableReferences>
Found inconsistent references to built-in variable <validateVariableReferences>
gl_LastFragData
Incorrect qualifier applied to redeclared built-in <validateQualifiers>
Found swizzle applied to swizzle
<validateNoSwizzleOfSwizzle>
<scalar array>
<vector array>
<matrix array>
Found index node with type that is inconsistent with the array being indexed <validateExpressionTypes>
Found direct index node with a non-constant index
<validateExpressionTypes>
Found node calling built-in without a reference to the built-in function <validateBuiltInOps>
Found node calling built-in with a reference to a different function <validateBuiltInOps>
Found switch selector expression that is not integer
Found switch selector expression that is not scalar
Found function with undefined precision on return value <validatePrecision>
Found function prototype with an invalid qualifier <validateQualifiers>
Found function prototype with an invalid qualifier on opaque parameter <validateQualifiers>
Found function parameter with undefined precision <validatePrecision>
<uniform>
Found redeclaration of struct or interface block with the same name in the same scope <validateStructUsage>
Found reference to struct or interface block with doubly created type <validateStructUsage>
Found reference to struct or interface block with no declaration <validateStructUsage>
Found two declarations of the same function argument <validateVariableReferences>
Found node calling a raw function (deprecated) <validateNoRawFunctionCalls>
<validateNullNodes>
Found nullptr child
Found node calling function without a reference to it
<validateFunctionCall>
Found node calling previously undeclared function <validateFunctionCall>
Found multiple declarations where SeparateDeclarations should have separated them <validateMultiDeclarations>
Found two declarations of the same variable <validateVariableReferences>
Found block field with undefined precision <validatePrecision>
barrier() may not be called at any point after a return statement in the function main().
barrier
barrier() may not be called in potentially divergent flow control.
The array must be sized by the shader either redeclaring it with a size or indexing it only with constant integral expressions
Cull distance functionality is not available
The sum of 'gl_ClipDistance' and 'gl_CullDistance' size is greater than gl_MaxCombinedClipAndCullDistances (
Loop index cannot be statically assigned to within the body of the loop
Index expression must be constant
This type of loop is not allowed
while
Missing init declaration
Invalid init declaration
Invalid type for loop index
Loop index cannot be initialized with non-constant expression
Missing condition
Invalid condition
Expected loop index
Invalid relational operator
Loop index cannot be compared with non-constant expression
Missing expression
Invalid expression
Invalid built-in call
Invalid operator
Loop index cannot be modified by non-constant expression
conflicting output locations with previously defined output '
output array locations would exceed MAX_DRAW_BUFFERS
output location must be < MAX_DRAW_BUFFERS
must explicitly specify all locations when using multiple fragment outputs
not allowed to specify yuv qualifier when using depth or multiple color fragment outputs
default
label statement nested inside control flow
duplicate default label
case label type does not match switch init-expression type
duplicate case label
statement before the first label
switch
no statement between the last label and the end of the switch statement
too complex expressions inside a switch statement
Size of declared variable exceeds implementation-defined limit
' conflicting location with '
display is not initialized.
display had a context loss
No context is current.
image is not valid.
device is EGL_NO_DEVICE.
device is not valid.
sync object is not valid.
Requested GLES version (%lx.%lx) is greater than max supported (%d, %d).
Requested GLES version (%lx.%lx) is greater than max supported 3.1 for WebGL.
Unsupported API.
EGL_ANGLE_surface_orientation is not enabled.
Attribute EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE requires EGL_ANGLE_robust_resource_initialization.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_GGP_STREAM_DESCRIPTOR_ANGLE requires EGL_ANGLE_ggp_stream_descriptor.
Attribute EGL_PROTECTED_CONTEXT_EXT requires extension EGL_EXT_protected_content.
EGL_PROTECTED_CONTENT_EXT must be either EGL_TRUE or EGL_FALSE.
Attribute EGL_SWAP_INTERVAL_ANGLE requires extension EGL_ANGLE_create_surface_swap_interval.
EGL_SWAP_INTERVAL_ANGLE must be within the EGLConfig min and max swap intervals.
<buftype> EGL_IOSURFACE_ANGLE requires the EGL_ANGLE_iosurface_client_buffer extension.
<buffer> must be non null
Attribute EGL_EXTERNAL_SURFACE_ANGLE requires EGL_ANGLE_external_context_and_surface.
<buffer> must be null
Width and Height are not supported for this <buftype>
Width and Height must be positive
Invalid value for EGL_TEXTURE_FORMAT
<buftype> doesn't support rectangle texture targets
Invalid value for EGL_TEXTURE_TARGET
<buftype> doesn't support iosurface plane
<buftype> doesn't support texture type
<buftype> doesn't support texture internal format
<buftype> doesn't support setting GL colorspace
IOSurface usage hint must only contain READ or WRITE
<buftype> doesn't support setting texture offset
invalid GL colorspace
EGL_IOSURFACE requires the texture target to match the config
EGL_IOSURFACE requires the EGL_TEXTURE_RGBA format
Missing required attribute for EGL_IOSURFACE
EGL_NOK_texture_from_pixmap is not enabled.
Unknown attribute: 0x%04lx
Congfig does not suport pixmaps.
If ctx is EGL_NO_CONTEXT, surfaces must be EGL_NO_SURFACE
If ctx is not EGL_NOT_CONTEXT, draw or read must both be EGL_NO_SURFACE, or both not
If ctx is not EGL_NO_CONTEXT, surfaces must not be EGL_NO_SURFACE
read and draw must both be valid surfaces, or both be EGL_NO_SURFACE
'dpy' not a valid EGLDisplay handle
'dpy' not initialized
EGL_IMAGE_PRESERVED must be EGL_TRUE or EGL_FALSE.
EGL_GL_TEXTURE_LEVEL cannot be used without KHR_gl_texture_*_image support.
EGL_GL_TEXTURE_LEVEL cannot be negative.
EGL_GL_TEXTURE_ZOFFSET cannot be used without KHR_gl_texture_3D_image support.
EGL_GL_COLORSPACE cannot be used without EGL_KHR_gl_colorspace support.
EGL_TEXTURE_INTERNAL_FORMAT_ANGLE cannot be used without EGL_ANGLE_image_d3d11_texture or EGL_ANGLE_vulkan_image support.
EGL_D3D11_TEXTURE_PLANE_ANGLE cannot be used without EGL_ANGLE_image_d3d11_texture support.
EGL_D3D11_TEXTURE_ARRAY_SLICE_ANGLE cannot be used without EGL_ANGLE_image_d3d11_texture support.
Parameter cannot be used if target is not EGL_LINUX_DMA_BUF_EXT
Parameter cannot be used without EGL_EXT_image_dma_buf_import support.
Invalid value for EGL_YUV_COLOR_SPACE_HINT_EXT.
Invalid value for EGL_SAMPLE_RANGE_HINT_EXT.
Invalid value for EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT or EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT.
Parameter cannot be used without EGL_EXT_image_dma_buf_import_modifiers support.
Attribute EGL_VULKAN_IMAGE_CREATE_INFO_{HI,LO}_ANGLE require extension EGL_ANGLE_vulkan_image.
invalid attribute: 0x%04lxX
KHR_gl_texture_2D_image not supported.
buffer cannot reference a 2D texture with the name 0.
target is not a 2D texture.
texture has a surface bound to it.
target 2D texture does not have a valid size at specified level.
EGL_PROTECTED_CONTENT_EXT attribute does not match protected state of target.
KHR_gl_texture_cubemap_image not supported.
buffer cannot reference a cubemap texture with the name 0.
target is not a cubemap texture.
target cubemap texture does not have a valid size at specified level and face.
if level is zero and the texture is incomplete, it must have all of its faces specified at level zero.
KHR_gl_texture_3D_image not supported.
buffer cannot reference a 3D texture with the name 0.
target is not a 3D texture.
target 3D texture does not have a valid size at specified level.
target 3D texture does not have enough layers for the specified Z offset at the specified level.
KHR_gl_renderbuffer_image not supported.
EGL_GL_TEXTURE_LEVEL cannot be used in conjunction with a renderbuffer target.
buffer cannot reference a renderbuffer with the name 0.
target is not a renderbuffer.
target renderbuffer cannot be multisampled.
EGL_ANDROID_image_native_buffer not supported.
ctx must be EGL_NO_CONTEXT.
EGL_ANGLE_image_d3d11_texture not supported.
EGL_EXT_image_dma_buf_import not supported.
buffer must be NULL.
Missing required parameter 0x%X for image target EGL_LINUX_DMA_BUF_EXT.
the list of attributes contains EGL_DMA_BUF_PLANE*_MODIFIER_LO_EXT but not EGL_DMA_BUF_PLANE*_MODIFIER_HI_EXT or vice versa.
EGL_ANGLE_metal_texture_client_buffer not supported.
EGL_ANGLE_vulkan_image not supported.
Missing required parameter 0x%X for image target EGL_VULKAN_IMAGE_ANGLE.
invalid target: 0x%X
EGL_GL_TEXTURE_ZOFFSET must be used with a 3D texture target.
EGL_KHR_image not supported.
Device creation extension not active
Invalid attrib_list parameter
D3D11 device creation extension not active
Invalid device_type parameter
Invalid device parameter
Device must have been created using eglCreateDevice
EGL_KHR_wait_sync extension is not available
Server-side waits cannot be performed without GL_OES_EGL_sync support.
flags must be zero
Invalid value parameter
Stream extension not active
Bad stream state
Consumer GLTexture extension not active
Invalid attribute
Stream consumer extension not active
EGL stream consumer external GL extension not enabled
Invalid stream
Invalid stream state
No external texture bound
Current GL context not associated with stream consumer
Invalid stream consumer type
Invalid color buffer type
Invalid plane count
Invalid texture unit
Plane count must be 0 for RGB buffer
Planes cannot be specified
Invalid YUV plane count
Invalid plane specified
Not all planes specified
No external texture bound at one or more specified texture units
Multiple planes bound to same texture object
Stream producer extension not active
Stream not in connecting state
Incompatible stream consumer type
Invalid subresource index
Invalid plane offset
Stream not fully configured
Incompatible stream producer
Texture is null
syncControlCHROMIUM extension not active
syncControlRateANGLE extension not active
numerator is null
denominator is null
ust is null
msc is null
sbc is null
EGL_KHR_swap_buffers_with_damage is not available.
Swap surface cannot be EGL_NO_SURFACE.
n_rects cannot be negative.
n_rects cannot be greater than zero when rects is NULL.
the 'engine' parameter has an unrecognized value
EGL_ANDROID_presentation_time is not available.
Blob cache functions can only be set once in the lifetime of a Display
Blob cache callbacks cannot be null.
num_config cannot be null.
EGL_EXT_platform_base not supported
ValidateCreatePlatformPixmapSurfaceEXT unimplemented.
Extension not supported
Invalid program cache attribute.
Program index out of range.
keysize and binarysize must always be valid pointers.
Invalid program key size.
key and binary must both be null or both non-null.
null pointer in arguments.
binarysize out of valid range.
limit must be non-negative.
Invalid cache resize mode.
Surface cannot be EGL_NO_SURFACE.
Surface does not support EGL_MULTISAMPLE_RESOLVE_BOX.
Invalid multisample resolve type.
Surface does not support EGL_SWAP_BEHAVIOR_PRESERVED.
Invalid swap behaviour.
EGL_WIDTH or EGL_HEIGHT cannot be set without EGL_ANGLE_window_fixed_size support.
EGL_WIDTH or EGL_HEIGHT cannot be set without EGL_FIXED_SIZE_ANGLE being enabled on the surface.
EGL_TIMESTAMPS_ANDROID cannot be used without EGL_ANDROID_get_frame_timestamps support.
Invalid value.
EGL_RENDER_BUFFER must be EGL_BACK_BUFFER or EGL_SINGLE_BUFFER.
Attribute EGL_RENDER_BUFFER requires EGL_KHR_mutable_render_buffer.
EGL_RENDER_BUFFER requires the surface type bit EGL_MUTABLE_RENDER_BUFFER_BIT_KHR.
Invalid surface attribute: 0x%04X
EGL_POST_SUB_BUFFER_SUPPORTED_NV cannot be used without EGL_ANGLE_surface_orientation support.
EGL_FIXED_SIZE_ANGLE cannot be used without EGL_ANGLE_window_fixed_size support.
EGL_SURFACE_ORIENTATION_ANGLE cannot be queried without EGL_ANGLE_surface_orientation support.
EGL_DIRECT_COMPOSITION_ANGLE cannot be used without EGL_ANGLE_direct_composition support.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE cannot be used without EGL_ANGLE_robust_resource_initialization support.
EGL_BUFFER_AGE_EXT cannot be used without EGL_EXT_buffer_age support.
The surface must be current to the current context in order to query buffer age per extension EGL_EXT_buffer_age.
EGL_KHR_lock_surface3 is not supported.
EGL_EXT_protected_content not supported
Attribute EGL_CONTEXT_PRIORITY_LEVEL_IMG requires extension EGL_IMG_context_priority.
Invalid context attribute: 0x%04X
EGL_KHR_debug extension is not available.
message controls must be EGL_TRUE or EGL_FALSE.
Unknown attribute: 0x%04X
EGL_ANDROID_get_frame_timestamps extension is not available.
invalid timing name.
names is NULL.
values is NULL.
numTimestamps must be at least 0.
invalid compositor timing.
compositor timing not supported by surface.
frameId is NULL.
invalid timestamp type.
timestamp collection is not enabled for this surface.
timestamps is NULL.
timestamp not supported by surface.
EGL_ANGLE_feature_control extension is not available.
index is negative.
name is not valid.
index is too big.
NULL buffer.
invalid attribute list.
incorrect channel size requested
invalid usage flag
invalid attribute
incorrect buffer dimensions requested
unsupported format
EGL_ANGLE_metal_shared_event_sync is not available.
EGL_ANDROID_native_fence_sync extension is not available.
EGL_ANGLE_swap_buffers_with_frame_token is not available.
EGL_KHR_reusable_sync extension is not available.
eglSignalSyncKHR invalid mode.
EGL_EXT_device_query not supported.
Invalid surface type
Config does not support EGL_LOCK_SURFACE_BIT
Surface cannot be current to a context for eglLockSurface()
Surface cannot be protected content for eglLockSurface()
Invalid EGL_MAP_PRESERVE_PIXELS_KHR value
Invalid EGL_LOCK_USAGE_HINT_KHR value
Invalid query surface64 attribute
Invalid eglQuerySurface64 attribute
value is NULL.
Surface is not locked
Surface is not locked.
Output VkImage pointer is null.
Output VkImageCreateInfo pointer is null.
surface is not a postable surface
surface is not the current draw surface for the calling thread
surface's swap behavior is not EGL_BUFFER_DESTROYED
damage region has already been set on surface since the most recent frame boundary
EGL_BUFFER_AGE_KHR attribute of surface has not been queried since the most recent frame boundary
EGL_EXT_dma_buf_import_modfier not supported
max_formats should not be negative
if max_formats is positive, formats should not be NULL
max_modifiers should not be negative
if max_modifiers is positive, modifiers should not be NULL
format should be one of the formats advertised by QueryDmaBufFormatsEXT
display is EGL_NO_DISPLAY.
display is not a valid display: 0x%p
when object type is EGL_OBJECT_DISPLAY_KHR, the object must be the same as the display.
unknown object type.
OpenGL profile mask requires an OpenGL context.
Invalid Context attribute.
Attribute EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE requires EGL_ANGLE_create_context_webgl_compatibility.
Attribute EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM requires EGL_CHROMIUM_create_context_bind_generates_resource.
Attribute EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_texture_share_group.
Attribute EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_semaphore_share_group.
Attribute EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE requires EGL_ANGLE_create_context_client_arrays.
Attribute EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE requires EGL_ANGLE_program_cache_control.
Attribute EGL_EXTENSIONS_ENABLED_ANGLE requires EGL_ANGLE_create_context_extensions_enabled.
Attribute EGL_POWER_PREFERENCE_ANGLE requires EGL_ANGLE_power_preference.
Attribute EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE requires EGL_ANGLE_create_context_backwards_compatible.
Attribute EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV requires extension EGL_NV_robustness_video_memory_purge.
Attribute EGL_EXTERNAL_CONTEXT_ANGLE requires EGL_ANGLE_external_context_and_surface.
Attribute EGL_EXTERNAL_CONTEXT_SAVE_STATE_ANGLE requires EGL_ANGLE_external_context_and_surface.
Attribute EGL_CONTEXT_VIRTUALIZATION_GROUP_ANGLE requires extension EGL_ANGLE_context_virtualization.
Attribute EGL_CONTEXT_METAL_OWNERSHIP_IDENTITY_ANGLE requires EGL_ANGLE_metal_create_context_ownership_identity.
Unknown attribute: 0x%04lxX
Invalid OpenGL profile mask.
Attribute must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM must be EGL_TRUE or EGL_FALSE.
EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
All contexts within a share group must be created with the same value of EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE.
EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
All contexts within a share group must be created with the same value of EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE.
EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_EXTENSIONS_ENABLED_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_POWER_PREFERENCE_ANGLE must be either EGL_LOW_POWER_ANGLE or EGL_HIGH_POWER_ANGLE.
EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE must be either EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_PRIORITY_LEVEL_IMG must be one of: EGL_CONTEXT_PRIORITY_LOW_IMG, EGL_CONTEXT_PRIORITY_MEDIUM_IMG, or EGL_CONTEXT_PRIORITY_HIGH_IMG.
EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV must be either EGL_TRUE or EGL_FALSE.
EGL_EXTERNAL_CONTEXT_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_EXTERNAL_CONTEXT_ANGLE doesn't allow creating with sharedContext.
EGL_EXTERNAL_CONTEXT_SAVE_STATE_ANGLE must be either EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_METAL_OWNERSHIP_IDENTITY_ANGLE mustbe non-zero.
EXT_gl_colorspace_display_p3_linear is not available.
EXT_gl_colorspace_display_p3 is not available.
EGL_EXT_gl_colorspace_display_p3_passthrough is not available.
EXT_gl_colorspace_scrgb is not available.
EXT_gl_colorspace_scrgb_linear is not available.
Surface not compatible with OpenGL ES 1.x.
Surface not compatible with OpenGL ES 2.x.
Surface not compatible with OpenGL ES 3.x.
Surface not compatible with Context API.
Surface not compatible with OpenGL Desktop.
Context with no config is not supported.
Color buffer types are not compatible.
Color buffer sizes are not compatible.
Color buffer component types are not compatible.
Depth-stencil buffer types are not compatible.
Surface type is not compatible.
texture must be complete if level is non-zero.
if level is zero and the texture is incomplete, it must have no mip levels specified except zero.
EGL_KHR_fence_sync extension is not available
CreateSync can only be called on the current display
EGL_SYNC_FENCE_KHR cannot be used without GL_OES_EGL_sync support.
EGL_ANGLE_metal_shared_event_sync is not available
EGL_SYNC_METAL_SHARED_EVENT_ANGLE can't be NULL
Invalid type parameter
EGL_SYNC_CONDITION_KHR is not valid for this sync type.
Attempt to initialize readonly parameter
Latency must be positive
Consumer GL extension not enabled
Timeout must be positive
Invalid stream attribute
EGL_EXT_pixel_format_float is not enabled.
EGL_ANDROID_recordable is not enabled.
EGL_ANDROID_framebuffer_target is not enabled.
EGL_ANGLE_iosurface_client_buffer is not enabled.
EGL_KHR_lock_surface3 is not enabled.
EGL_bind_to_texture invalid attribute: 0x%X
EGL_color_buffer_type invalid attribute: 0x%X
EGL_native_renderable invalid attribute: 0x%X
EGL_transparent_type invalid attribute: 0x%X
EGL_RECORDABLE_ANDROID invalid attribute: 0x%X
EGL_COLOR_COMPONENT_TYPE_EXT invalid attribute: 0x%X
EGL_KHR_lock_surface3 invalid attribute: 0x%X
Platform ANGLE extension is not active
Platform Device extension is not active
Platform GBM extension is not active
Platform Wayland extension is not active
Bad platform type.
Invalid automatic trim attribute
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE extension not active.
Invalid D3D11on12 attribute
EGL_ANGLE_experimental_present_path extension not active
Invalid value for EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE
EGL_ANGLE_platform_angle_d3d is not supported
EGL_ANGLE_platform_angle_device_type_egl_angle is not supported
EGL_ANGLE_platform_angle_device_type_swiftshader is not supported
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE attrib
EGL_ANGLE_platform_angle extension not active
EGL_PLATFORM_ANGLE_DEBUG_LAYERS_ENABLED_ANGLE must be EGL_TRUE, EGL_FALSE, or EGL_DONT_CARE.
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_EAGL_ANGLE attrib
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_CGL_ANGLE attrib
EGL_ANGLE_platform_angle_device_id is not supported
Must specify major version if you specify a minor version.
EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_ENABLE_AUTOMATIC_TRIM_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE requires a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE requires a device type of EGL_PLATFORM_ANGLE_DEVICE_TYPE_HARDWARE_ANGLE or EGL_PLATFORM_ANGLE_DEVICE_TYPE_D3D_WARP_ANGLE
EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D_LUID_HIGH_ANGLE and EGL_PLATFORM_ANGLE_D3D_LUID_LOW_ANGLE require a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
If either EGL_PLATFORM_ANGLE_D3D_LUID_HIGH_ANGLE and/or EGL_PLATFORM_ANGLE_D3D_LUID_LOW_ANGLE are specified, at least one must non-zero.
If either EGL_PLATFORM_ANGLE_DEVICE_ID_HIGH_ANGLE and/or EGL_PLATFORM_ANGLE_DEVICE_ID_LOW_ANGLE are specified, at least one must non-zero.
This device type requires a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE or EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE.
This device type requires a platform type of EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE.
EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE currently only supports Vulkan 1.0.
EGL_PLATFORM_ANGLE_EGL_HANDLE_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE.
native_display should be a valid EGL device if platform equals EGL_PLATFORM_DEVICE_EXT
Attribute EGL_POWER_PREFERENCE_ANGLE requires EGL_ANGLE_display_power_preference.
EGL_ANGLE_feature_control is not supported
EGL_FEATURE_OVERRIDES_ENABLED_ANGLE must be a valid pointer
EGL_FEATURE_OVERRIDES_DISABLED_ANGLE must be a valid pointer
Direct3D platform is unsupported.
OpenGL platform is unsupported.
Display type EGL_PLATFORM_ANGLE_TYPE_NULL_ANGLE requires EGL_ANGLE_platform_angle_null.
Vulkan platform is unsupported.
Metal platform is unsupported.
Unknown platform type.
EGL_EXT_device_query extension is not available.
attribute is not valid.
Invalid or unsupported texture target.
A texture must be bound.
Insufficient buffer size.
Enum 0x%04X is currently not supported.
OpenGL ES 3.0 Required.
GLES1-only function.
Invalid pname.
Base level must be at least 0.
Base level must be 0.
Level of detail outside of range.
Enum requires GLES 3.1
Extension is not enabled.
EGL_ANGLE_robust_resource_initialization not enabled.
GL_EXT_protected_textures not enabled.
Protected Texture must match Protected Context
Sampler is not valid
Primcount must be greater than or equal to zero.
Attempting to draw without a program
At least one enabled attribute must have a divisor of zero.
Negative size.
The texture is a non-power-of-two texture.
Internal error: unknown internal format.
Integer overflow.
It is undefined behavior to use a pixel unpack buffer that is bound for transform feedback.
imageSize must be 0 if no texture data is provided.
imageSize is too small.
Stride is over the maximum stride allowed by WebGL.
Offset must be a multiple of the passed in datatype.
Stride must be a multiple of the passed in datatype.
Expected a program name, but found a shader name.
Program object expected.
Expected a shader name, but found a program name.
Shader object expected.
Invalid Attachment Type.
Invalid renderbuffer target.
Renderbuffer width and height cannot be negative and cannot exceed maximum texture size.
Invalid renderbuffer internalformat.
Desired resource size is greater than max renderbuffer size.
Invalid blit filter.
Invalid blit mask.
Only nearest filtering can be used when blitting buffers other than the color buffer.
Read and draw framebuffers must both exist for a blit to succeed.
Blitting to or from a YUV framebuffer is disallowed.
Blit feedback loop: the read and draw framebuffers are the same.
BlitFramebuffer dimensions out of 32-bit integer range.
If the read buffer contains fixed-point or floating-point values, the draw buffer must as well.
If the read buffer contains fixed-point values, the draw buffer must as well.
If the read buffer contains unsigned integer values the draw buffer must as well.
If the read buffer contains signed integer values the draw buffer must as well.
Attempt to blit from a multisampled framebuffer and the bounds or format of the color buffer don't match with the draw framebuffer.
Read and write color attachments cannot be the same image.
Cannot use GL_LINEAR filter when blitting a integer framebuffer.
Attempt to read from a missing color attachment of a complete framebuffer.
Depth/stencil buffer format combination not allowed for blit.
Attempt to blit from a multisampled framebuffer and the bounds don't match with the draw framebuffer.
Read and write depth stencil attachments cannot be the same image.
Attempt to read from a missing depth/stencil attachment of a complete framebuffer.
Attempt to read from a multi-view framebuffer.
Attempt to write to a multi-view framebuffer.
Invalid framebuffer target.
Object cannot be used because it has not been generated.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_WIDTH.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_HEIGHT.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_SAMPLES.
GL_EXT_geometry_shader or GL_OES_geometry_shader extension not enabled.
Framebuffer layer cannot be less than 0 or greater than GL_MAX_FRAMEBUFFER_LAYERS_EXT.
Default framebuffer is bound.
It is invalid to change default FBO's attachments
No Texture is bound to the specified target.
Mismatch between Texture and Context Protected Content state
Texture base level out of range
Texture format does not support mipmap generation.
Texture is not cubemap complete. All cubemaps faces must be defined and be the same size.
Cannot generate mipmaps for a zero-size texture in a WebGL context.
Negative buffer size.
Query extension not enabled.
Invalid query type.
Invalid query Id.
Other query is active.
Query type does not match target.
Query is not active.
Invalid query target.
Query is active.
Context has been lost.
Negative count.
Program not linked.
Invalid uniform location
Only array uniforms may have count > 1.
Sampler uniform value out of range.
Uniform type does not match uniform method.
Index must be less than MAX_DRAW_BUFFERS.
GL_ANGLE_texture_multisample_array not enabled.
Texture buffer extension not available.
Read buffer is GL_NONE.
Read buffer has no attachment.
name is not a valid renderbuffer.
Not a valid texture object name.
Passed in texture type must match the one originally used to define the texture.
Invalid target.
Negative offset.
The specified dimensions are outside of the bounds of the texture.
The texture is not complete.
Invalid region for compressed texture format.
Texture level does not exist.
Texture formats are not compatible
Samples must not be greater than maximum supported value for the format.
Offset overflows texture dimensions.
Border must be 0.
Missing read attachment.
Copying from a YUV framebuffer is disallowed.
The active read framebuffer object has multiview attachments.
Texture is immutable.
Invalid format.
Desired resource size is greater than max texture size.
Feedback loop formed between Framebuffer and active Texture.
There is no current program object specified by UseProgram, there is a current program pipeline object, and that object is empty (no executable code is installed for any stage).
A program object is active for at least one, but not all of the shader stages that were present when the program was linked.
It is a undefined behaviour to render without vertex shader stage or fragment shader stage.
An active buffer is mapped
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/validationES.cpp
ValidateDrawStates
This ANGLE implementation does not support separate front/back stencil writemasks, reference values, or stencil mask values.
Stencil reference and mask values must be the same for front facing and back facing triangles.
GL_BLEND with floating-point color attachments requires the EXT_float_blend extension.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination color factors in the blend function.
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR as color factors is not supported by this implementation.
Red, green and blue color writes must be enabled when writing to YUV framebuffers.
Blending must be disabled when writing to YUV framebuffers.
External texture attached to framebuffer is not YUV.
Advanced blend equation can only be used when only one draw buffer is not NONE
An enabled vertex array has no buffer.
An enabled vertex array has no buffer and no pointer.
Two textures of different types use the same sampler location.
Any command that transfers vertices to the GL requires a vertex shader if the current program uses a tessellation shader.
Tessellation requires both control and evaluation shaders.
Every binding point used in transform feedback mode must have a buffer object bound.
Program and framebuffer YUV output state does not match.
Mismatch between texture format and sampler type (signed/unsigned/float/shadow).
A transform feedback buffer that would be written to is also bound to a non-transform-feedback target, which would cause undefined behavior.
Vertex shader input type does not match the type of the bound vertex attribute.
Active draw buffers with missing fragment shader outputs.
Fragment shader output type does not match the bound framebuffer attachment type.
It is undefined behavior to use a vertex buffer that is bound for transform feedback.
Draw mode must match current transform feedback object's draw mode.
GL_EXT_tessellation_shader extension not enabled.
Invalid draw mode.
Primitive mode is incompatible with the input primitive type of the geometry shader.
When tessellation is active the primitive mode must be GL_PATCHES.
When tessellation is not active the primitive mode must not be GL_PATCHES.
The draw command is unsupported when transform feedback is active and not paused.
It is undefined behavior to use an element array buffer that is bound for transform feedback.
Must have element array buffer bound.
Program doesn't exist.
Negative number of attachments.
Invalid attachment when the default framebuffer is bound.
Index is greater than the maximum supported color attachments
Invalid attachment when a user framebuffer is bound.
EGL image is not valid.
Cannot create a 2D texture from a multisampled EGL image.
EGL image internal format is not supported as a texture.
Image is YUV, target must be TEXTURE_EXTERNAL_OES
The source EGL image is incompatible with the target texture type.
Mismatch between Image and Context Protected Content state
EGL image internal format is not supported as a renderbuffer.
Program binary format is not valid.
Cannot change program binary while program is associated with an active transform feedback object.
No program binary formats supported.
Invalid draw buffer.
Ith value does not match COLOR_ATTACHMENTi or NONE.
The default framebuffer must have exactly one draw buffer.
Only NONE or BACK are valid draw buffers for the default framebuffer
Invalid buffer target.
Can not get pointer for reserved buffer name zero.
Buffer is not mapped.
Negative length.
Attempted to map buffer object zero.
Mapped range does not fit into buffer dimensions.
Invalid access bits.
Length must not be zero.
Buffer is already mapped.
Need to map buffer for either reading or writing.
Invalid access bits when mapping buffer for reading
The explicit flushing bit may only be set if the buffer is mapped for writing.
Attempted to flush buffer object zero.
Attempted to flush a buffer not mapped for explicit flushing.
Flushed range does not fit into buffer mapping dimensions.
More parameters are required than were provided.
Attachment type must be compatible with attachment object.
Invalid parameter name for framebuffer attachment.
Enum requires GLES 3.0
No active compute shader stage in this program.
No active geometry shader stage in this program.
No defined conversion between clear value and attachment format.
dataSize is too small
A buffer must be bound.
GL_BUFFER_MAP_POINTER can only be queried with GetBufferPointerv.
A renderbuffer must be bound.
GL_ANGLE_get_image extension not enabled.
Index must be less than MAX_VERTEX_ATTRIBS.
It is undefined behavior to use a pixel pack buffer that is bound for transform feedback.
The provided parameters overflow with the provided buffer.
Invalid combination of pack parameters for WebGL.
Invalid format and type combination.
Index exceeds active uniform block count.
Internal format is not renderable.
GL_ANGLE_texture_multisample or GLES 3.1 required.
Invalid operation on multisampled framebuffer
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_TEXTURE_UNITS)
Width and height must be less than or equal to GL_MAX_TEXTURE_SIZE.
Samples may not be zero.
SizedInternalformat must be color-renderable, depth-renderable, or stencil-renderable.
Internalformat is one of the unsupported unsized base internalformats.
Zero is bound to target.
The value of TEXTURE_IMMUTABLE_FORMAT for the texture currently bound to target on the active texture unit is true.
Texture dimensions must all be greater than zero.
Index must be less than the value of SAMPLES.
MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS.
Vertex buffer is not big enough for the draw call
Reset status is not valid
Invalid logical operation.
Parameter outside of bounds.
Uniform size does not match uniform method.
The number of views in the active program and draw framebuffer does not match.
There is an active transform feedback object when the number of views in the active draw framebuffer is greater than 1.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
It is undefined behaviour to have a used but unbound uniform buffer.
It is undefined behaviour to use a uniform buffer that is too small.
It is undefined behavior to use an uniform buffer that is bound for transform feedback.
Active fragment shader does not include the layout qualifier matching the blend equation
Invalid wrap mode for texture type.
Texture wrap mode not recognized.
Texture only supports NEAREST and LINEAR filtering.
Texture filter not recognized.
Unknown parameter value.
Invalid enum provided.
GLES1-only function.
GL_OES_point_size_array not enabled.
Invalid client vertex array type.
Invalid stride for built-in vertex attribute.
Size for built-in vertex attribute is outside allowed range.
Invalid type for built-in vertex attribute.
Invalid light.
Light parameter out of range.
Invalid light parameter.
Material parameter out of range.
Invalid material parameter.
Invalid material face.
Invalid light model parameter.
Invalid clip plane.
Invalid fog mode.
Invalid fog density (must be nonnegative).
Invalid fog parameter.
Invalid texture environment mode.
Invalid texture combine mode.
Invalid texture combine source.
Invalid texture combine operand.
Invalid texture environment scale.
Invalid texture environment parameter.
Invalid texture environment target.
Invalid point parameter value (must be non-negative).
Invalid point parameter.
Invalid point size (must be positive).
Both width and height argument of drawn texture must be positive.
Near value cannot be greater than far.
Invalid projection matrix. Left/right, top/bottom, near/far intervals cannot be zero, and near/far cannot be less than zero.
Invalid width.
Invalid matrix mode.
Current matrix stack has only a single matrix.
Current matrix stack is full.
Invalid shading model.
Extension is not enabled.
Invalid framebuffer target.
Mipmap level must be 0 when attaching a texture.
Invalid or unsupported texture target.
Textarget must match the texture target type.
Level of detail outside of range.
Rectangle texture cannot have a compressed format.
Each cubemap face must have equal width and height.
Invalid or unsupported texture target.
A buffer must be bound.
Invalid internal format 0x%04X.
Invalid compressed image size.
Enum 0x%04X is currently not supported.
Invalid texture target and format combination.
Pixel data must be null.
Texture level must be zero.
Passed in texture target and format must match the one originally used to define the texture.
Pixel data cannot be null.
Invalid combination of format, type and internalFormat.
Texture dimensions must all be greater than zero.
Invalid level count.
Texture dimensions must be power-of-two.
Extension is not enabled.
Invalid framebuffer target.
Invalid debug source.
Invalid debug type.
Invalid debug severity.
If count is greater than zero, source and type cannot be GL_DONT_CARE.
Message length is larger than GL_MAX_DEBUG_MESSAGE_LENGTH.
Negative buffer size.
Cannot push more than GL_MAX_DEBUG_GROUP_STACK_DEPTH debug groups.
Cannot pop the default debug group.
Blit extension not available.
Scaling and flipping in BlitFramebufferANGLE not supported by this implementation.
Linear blit not supported in this extension.
Blits are only supported from 2D texture, renderbuffer or default framebuffer attachments in this extension.
Blits are only supported to 2D texture, renderbuffer or default framebuffer attachments in this extension.
Attempting to blit and the read and draw buffer formats don't match. read: 0x%04X draw: 0x%04X
Only whole-buffer blit is supported from a multisampled read buffer in this extension.
Only whole-buffer depth and stencil blits are supported by this extension.
Multisampled depth/stencil blit is not supported by this extension.
Invalid mask bits.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
Integer overflow.
Compressed texture dimensions must exactly match the dimensions of the data passed in.
Invalid buffer target.
Attempted to map buffer object zero.
Invalid access bits.
Buffer is already mapped.
Buffer is bound for transform feedback.
Location cannot be less than 0.
Location must be less than (MAX_VERTEX_UNIFORM_VECTORS + MAX_FRAGMENT_UNIFORM_VECTORS) * 4
Name contains invalid characters.
Attributes that begin with 'gl_' are not allowed.
components is not one of GL_RGB, GL_RGBA, GL_ALPHA or GL_NONE.
Source texture is not a valid texture object.
Invalid source texture level.
Source texture internal format is invalid.
Destination texture is not a valid texture object.
Copy*TextureCHROMIUM from EXTERNAL_OES to integer format requires OES_EGL_image_external_essl3
Invalid destination texture type.
Destination texture cannot be immutable.
Source texture must be a valid texture type.
Negative offset.
Negative size.
The destination level of the destination texture must be defined.
Source texture must level 0 defined.
Source texture must have a compressed internal format.
OpenGL ES 3.1 Required
Invalid shader type.
Invalid buffer usage enum.
Buffer is immutable.
An active buffer is mapped
Buffer is not updatable.
The provided parameters overflow with the provided buffer.
Insufficient buffer size.
Extension is not requestable.
Extension is not disablable.
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_COMBINED_IMAGE_UNITS)
Shader attachment already has a shader.
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid blend equation.
Invalid blend function.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination color factors in the blend function.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/validationES2.cpp
ValidateBlendFuncSeparate
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR as color factors is not supported by this implementation.
Invalid name.
Invalid width.
Near value cannot be greater than far.
Samples must not be greater than maximum supported value for the format.
Cull mode not recognized.
Expected a program name, but found a shader name.
Program object expected.
Shader object expected.
Expected a shader name, but found a program name.
Shader to be detached must be currently attached to the program.
Index must be less than program active uniform count.
Negative maxcount.
webgl_
_webgl_
A program must be bound.
Program not linked.
Compute shader precision not yet implemented.
Invalid or unsupported precision type.
Invalid pname.
param is negative.
Unpack alignment must be 1, 2, 4 or 8.
Invalid shader binary format.
Negative count.
Invalid stencil.
Viewport size cannot be negative.
Cap 0x%04X cannot be enabled or disabled while pixel local storage is active.
Current renderer doesn't support alpha-to-coverage.
ValidateEnable
Mipmap level must be 0 when attaching a texture.
Textarget must match the texture target type.
GL_ANGLE_texture_multisample or GLES 3.1 required.
GL_EXT_YUV_target not enabled.
Invalid Attachment Type.
zoffset is larger than MAX_3D_TEXTURE_SIZE-1
Texture has incompatible target.
OpenGL ES 3.0 Required.
Cannot link program while program is associated with an active transform feedback object.
Cannot change active program while transform feedback is unpaused.
GL_NV_fence is not supported
Invalid fence object.
Fence must be set.
Invalid value for condition.
The current context doesn't support setting a non-zero divisor on the attribute with index zero. Please reorder the attributes in your vertex shader so that attribute zero can have a zero divisor.
ValidateVertexAttribDivisorANGLE
Context does not support GL_ANGLE_texture_rectangle
GL_ANGLE_texture_multisample_array not enabled.
External texture extension not enabled
Vertex array does not exist.
name is not a valid buffer.
name is not a valid vertex array.
name is not a valid query.
name is not a valid transform feedback.
name is not a valid sampler.
name is not a valid framebuffer.
name is not a valid program pipeline.
Invalid identifier.
Label length is larger than GL_MAX_LABEL_LENGTH.
Not a valid sync pointer.
Location name lengths must not be greater than 256 characters.
Location lengths must not be greater than 1024 characters.
Attributes that begin with 'webgl_', or '_webgl_' are not allowed.
Invalid format.
Invalid or unsupported texture target.
Level of detail outside of range.
Desired resource size is greater than max texture size.
Rectangle texture cannot have a compressed format.
Each cubemap face must have equal width and height.
The cubemap depth must be a multiple of 6.
Enum 0x%04X is currently not supported.
No Texture is bound to the specified target.
Texture is immutable.
Compressed data is valid if-and-only-if the texture is compressed.
Invalid compressed image size.
Format must match internal format.
Invalid internal format 0x%04X.
Pixel data cannot be null.
Data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
An active buffer is mapped
Invalid combination of unpack parameters for WebGL.
Invalid copy texture format combination.
Invalid level count.
Texture dimensions must all be greater than zero.
OpenGL ES 3.0 Required.
Negative layer.
Mip level invalid for framebuffer texture attachment.
Layer invalid for framebuffer texture attachment.
Texture is not a three-dimensional, two-dimensional array, two-dimensional multisample array, cube map, or cube map array texture.
Compressed textures cannot be attached to a framebuffer.
Invalid framebuffer target.
Negative size.
Invalid element range.
No active read framebuffer.
Invalid read buffer
Read buffer must be GL_NONE or GL_BACK when reading from the default framebuffer.
Index is greater than the maximum supported color attachments
Not a valid compressed texture format.
Integer overflow.
Invalid buffer binding size.
Invalid boolean value. Must be GL_FALSE or GL_TRUE.
OpenGL ES 3.1 Required
Invalid pname.
drawbuffer
Index must be less than MAX_DRAW_BUFFERS.
Draw buffer must be zero when using depth or stencil.
Source texture is not a valid texture object.
Destination texture is not a valid texture object.
Invalid source texture level.
Invalid source texture height or width.
Destination texture cannot be immutable.
x = y = or z cannot be negative.
Cannot have negative height, width, or depth.
Destination texture too small.
Extension is not enabled.
Implementation format is emulated.
Attempt to delete an active transform feedback.
Invalid primitive mode.
Transform feedback is already active.
Transform feedback has a buffer bound to multiple outputs.
A program must be bound.
The active program has specified no output variables to record.
Every binding point used in transform feedback mode must have a buffer object bound.
EXT/OES_draw_buffers_indexed is not available.
Index must be less than MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
Index must be less than MAX_UNIFORM_BUFFER_BINDINGS.
Index must be less than the number of workgroup dimensions (3).
Enum requires GLES 3.1
Index must be less than MAX_ATOMIC_COUNTER_BUFFER_BINDINGS.
Index must be within [0, MAX_SHADER_STORAGE_BUFFER_BINDINGS).
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS.
Index must be within [0, MAX_IMAGE_UNITS).
A buffer must be bound.
Buffer is bound for transform feedback.
Buffer offset overflow.
The read and write copy regions alias memory.
Index must be within [0, NUM_EXTENSIONS).
Invalid name.
Index must be within [0, NUM_REQUESTABLE_EXTENSIONS_ANGLE).
Samples must not be greater than maximum supported value for the format.
Cannot have negative stride.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Client data cannot be used with a non-default vertex array object.
Negative buffer size.
Context has been lost.
Sync object does not exist.
Negative baseViewIndex.
Texture has incompatible target.
baseViewIndex+numViews cannot be greater than GL_MAX_ARRAY_TEXTURE_LAYERS.
No Transform Feedback object is active.
Negative count.
Count exceeds MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
Index must be less than the transform feedback varying count in the program.
The active Transform Feedback object is not paused.
Transform feedback object that does not exist.
The active Transform Feedback object is paused.
Program not linked.
Index must be less than program active uniform count.
Index must be less than program active uniform block count.
Invalid value for condition.
Invalid value for flags.
Invalid value for timeout.
Sampler is not valid
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_COMBINED_IMAGE_UNITS)
Fragment output color index must be zero or one.
Color number for secondary color greater than or equal to MAX_DUAL_SOURCE_DRAW_BUFFERS
Color number for primary color greater than or equal to MAX_DRAW_BUFFERS
GL_ANGLE_texture_multisample or GLES 3.1 required.
GL_ANGLE_texture_multisample, GL_ANGLE_get_tex_level_parameter or GLES 3.1 required.
Argument <%s> must be less than MAX_COLOR_ATTACHMENTS_WITH_ACTIVE_PIXEL_LOCAL_STORAGE_ANGLE when pixel local storage is active.
Argument <%s> must be less than (MAX_COMBINED_DRAW_BUFFERS_AND_PIXEL_LOCAL_STORAGE_PLANES_ANGLE - ACTIVE_PIXEL_LOCAL_STORAGE_PLANES_ANGLE) when pixel local storage is active.
internalformat is an ETC1 or PVRTC1 format.
internalformat is an ETC2/EAC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an ASTC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an S3TC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an RGTC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is a BPTC format and target is not GL_TEXTURE_2D_ARRAY.
Invalid type.
Format cannot be GL_DEPTH_COMPONENT or GL_DEPTH_STENCIL if target is GL_TEXTURE_3D
Vertex array does not exist.
Index is greater than or equal to the number of TRANSFORM_FEEDBACK_BUFFER indexed binding points.
Offset and size must be multiple of 4.
Target is TRANSFORM_FEEDBACK_BUFFER and transform feedback is currently active.
Offset must be multiple of value of UNIFORM_BUFFER_OFFSET_ALIGNMENT.
offset must be a multiple of 4.
Offset must be multiple of value of SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT.
Texture buffer extension not available.
Offset must be multiple of value of TEXTURE_BUFFER_OFFSET_ALIGNMENT.
GL_ANGLE_copy_texture_3d extension not available.
Index must be less than MAX_VERTEX_ATTRIBS.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
ANGLE_multiview is not available.
numViews cannot be less than 1.
numViews cannot be greater than GL_MAX_VIEWS_ANGLE.
EXT/OES_draw_buffers_indexed or ES 3.1 are required but not available.
OpenGL ES 3.1 Required
Default vertex array object is bound.
Client data cannot be used with a non-default vertex array object.
Draw indirect buffer must be bound.
indirect must be a multiple of the size of uint in basic machine units.
Draw mode must match current transform feedback object's draw mode.
The draw command is unsupported when transform feedback is active and not paused.
The provided parameters overflow with the provided buffer.
Must have element array buffer bound.
Extension is not enabled.
Ith value does not match COLOR_ATTACHMENTi or NONE.
Value must be greater than zero.
Invalid program interface.
Object cannot be used because it has not been generated.
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
Negative offset.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid program resource index.
Negative buffer size.
No active program for the compute shader stage.
num_groups_x cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[0]
num_groups_y cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[1]
num_groups_z cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[2]
Offset must be a multiple of sizeof(uint) in basic machine units.
Dispatch indirect buffer must be bound.
Insufficient buffer size.
Index must be within [0, MAX_IMAGE_UNITS).
Level is negative.
Negative layer.
access is not one of the supported tokens.
format is not one of supported image unit formats.
texture is not the name of an existing texture object.
Texture is not the name of an immutable texture object or a buffer texture.
Program not linked.
Invalid propCount.
Invalid bufSize.
Invalid program resource property.
Not an allowed program resource property for this program interface
Invalid pname.
Active atomic counter resources are not assigned name strings.
MAX_NUM_ACTIVE_VARIABLES requires a buffer or block interface.
Unrecognized shader stage bit.
Program doesn't exist.
Program object was not linked with its PROGRAM_SEPARABLE status set.
Expected a program name, but found a shader name.
Invalid shader type.
Negative count.
Program pipeline does not exist.
Invalid memory barrier bit.
Not a valid texture object name.
Level of detail outside of range.
Texture level must be zero.
GL_EXT_geometry_shader or GL_OES_geometry_shader extension not enabled.
GL_ANGLE_texture_multisample_array not enabled.
Target must be TEXTURE_2D_MULTISAMPLE_ARRAY_OES.
Negative size.
Depth must be less than or equal to MAX_ARRAY_TEXTURE_LAYERS
programInterface must be set to GL_PROGRAM_OUTPUT.
Texture buffer extension not available.
Target must be TEXTURE_BUFFER.
Internal format is not an accepted sized internal format.
If buffer is nonzero, it must match the name of an existing buffer object.
Offset must be multiple of value of TEXTURE_BUFFER_OFFSET_ALIGNMENT.
Texture buffer size must be a positive integer.
A buffer must be bound.
Texture buffer offset + size must be less than or equal to BUFFER_SIZE.
Draw framebuffer is incomplete
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
Invalid enum provided.
Uniform size does not match uniform method.
relativeOffset cannot be greater than MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
Invalid type.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
Draw buffer greater than MAX_DRAW_BUFFERS.
Index must be less than MAX_DRAW_BUFFERS.
OpenGL ES 3.2 Required
index
Enum 0x%04X is currently not supported.
Invalid pointer query.
OpenGL ES 1.x or 3.2 Required
GL_ANGLE_get_image extension not enabled.
Invalid or unsupported texture target.
Level is negative.
Level of detail outside of range.
Texture is compressed, call GetCompressedTexImage instead.
Texture is not compressed, call GetTexImage instead.
Implementation format is emulated.
Invalid renderbuffer target.
Extension is not enabled.
Element value exceeds element range.
Draw mode must match current transform feedback object's draw mode.
The draw command is unsupported when transform feedback is active and not paused.
GL_KHR_blend_equation_advanced extension not enabled.
Invalid provoking vertex.
Invalid memory object.
Invalid memory object parameter.
The memory object is immutable.
Invalid handle type.
name is not a valid buffer.
Not a valid texture object name.
Invalid image layout.
OpenGL ES 3.0 Required.
Texture is not immutable.
Level is larger than texture level count.
Negative layer.
Layer is larger than texture depth.
Attempted to begin pixel local storage with a multisampled framebuffer.
Attempted to begin pixel local storage with GL_DITHER enabled.
Attempted to begin pixel local storage with GL_RASTERIZER_DISCARD enabled.
Attempted to begin pixel local storage with GL_SAMPLE_ALPHA_TO_COVERAGE enabled.
Attempted to begin pixel local storage with GL_SAMPLE_COVERAGE enabled.
Planes must be greater than 0.
Planes must be less than or equal to GL_MAX_PIXEL_LOCAL_STORAGE_PLANES_ANGLE.
Framebuffer cannot have images attached to color attachment points on or after COLOR_ATTACHMENT0 + MAX_COLOR_ATTACHMENTS_WITH_ACTIVE_PIXEL_LOCAL_STORAGE_ANGLE.
Framebuffer cannot have images attached to color attachment points on or after COLOR_ATTACHMENT0 + MAX_COMBINED_DRAW_BUFFERS_AND_PIXEL_LOCAL_STORAGE_PLANES_ANGLE - <n>.
loadops cannot null.
Attempted to enable a pixel local storage plane that is in a deinitialized state.
Mismatched pixel local storage backing texture sizes.
Load Operation GL_LOAD_OP_LOAD_ANGLE is invalid for memoryless planes.
Pixel local storage backing texture dimensions not equal to the rendering area.
Draw framebuffer has no attachments and no enabled, texture-backed pixel local storage planes.
<n> != ACTIVE_PIXEL_LOCAL_STORAGE_PLANES_ANGLE
Enum 0x%04X is currently not supported.
GL_EXT_shader_framebuffer_fetch_non_coherent not enabled.
GL_EXT_tessellation_shader extension not enabled.
Invalid pname.
Value must be greater than zero.
Value must be less than or equal to MAX_PATCH_SIZE.
Create flags must only include bits defined by GL_ANGLE_external_objects_flags
Usage flags must only include bits defined by GL_ANGLE_external_objects_flags
Invalid buffer target.
Size must be greater than 0
Invalid buffer usage flags.
A buffer must be bound.
Buffer is immutable.
Invalid origin enum.
Invalid depth enum.
Offset must be zero for external buffers
Size must not exceed the size of clientbuffer
Negative buffer size.
Negative length.
Attribute list must be NULL or GL_NONE
Texture dimensions must all be greater than zero.
Desired resource size is greater than max texture size.
Invalid perf monitor.
Invalid perf monitor counter group.
Invalid perf monitor counter.
Invalid shading rate.
Plane cannot be less than 0.
Plane must be less than GL_MAX_PIXEL_LOCAL_STORAGE_PLANES_ANGLE.
Invalid pixel local storage internal format.
Invalid pixel local storage texture type.
GL_ANGLE_shader_pixel_local_storage not enabled.
Pixel local storage is not active.
Default framebuffer object name 0 does not support pixel local storage.
Invalid pixel local storage Load Operation: 0x%04X.
Invalid pixel local storage Store Operation: 0x%04X.
Invalid type.
Shader object expected.
Program object expected.
Invalid format.
Could not pack varying 
Note: Additional non-conformant packing restrictions are enforced on D3D9.
Failed to unmap the client data streaming buffer.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/VertexArrayGL.cpp
streamAttributes
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/VertexArrayMtl.mm
updateClientAttribs
convertVertexBufferCPU
convertVertexBufferGPU
Unsupported format conversion
StreamVertexData
thread constructor failed
ANGLE: %s: %s
SwapLayerEAGL
depthAttachment
addCompletedHandler:
enqueue
areRasterOrderGroupsSupported
languageVersion
attributes
mDisplayContext
bounds
pushDebugGroup:
commandBuffer
setBufferIndex:
computeCommandEncoder
setDestinationAlphaBlendFactor:
contentsScale
setPixelFormat:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
setScissorRect:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
setTextureType:
depth
setVisibilityResultMode:offset:
device
texture
UTF8String
display
addSublayer:
fastMathEnabled
arrayLength
layouts
blitCommandEncoder
newCommandQueue
colorAttachments
setArrayLength:
commit
setConstantValue:type:withName:
contents
setNeedsDisplay
copy
setSampleCount:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
setStoreAction:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
setVertexBuffer:offset:atIndex:
depthAttachmentPixelFormat
supportsFamily:
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawableSize
encodeSignalEvent:value:
encodeWaitForEvent:value:
encodedLength
endEncoding
fillBuffer:range:value:
frame
generateMipmapsForTexture:
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
height
init
initWithAPI:
initWithBytesNoCopy:length:encoding:freeWhenDone:
initWithSharedState:withContext:withFunctions:
initialized
insertDebugSignpost:
iosurface
isRasterizationEnabled
length
localizedDescription
mFunctions
mReadFramebuffer
mSwapState
maxTotalThreadsPerThreadgroup
mipmapLevelCount
name
newArgumentEncoderWithBufferIndex:
newBufferWithBytes:length:options:
newBufferWithLength:options:
newComputePipelineStateWithFunction:error:
newDepthStencilStateWithDescriptor:
newFunctionWithName:
newFunctionWithName:constantValues:error:
newLibraryWithData:error:
newLibraryWithSource:options:error:
newRenderPipelineStateWithDescriptor:error:
newSamplerStateWithDescriptor:
newSharedEvent
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
nextDrawable
notifyListener:atValue:block:
objectAtIndexedSubscript:
operatingSystemVersionString
pixelFormat
popDebugGroup
presentDrawable:
presentRenderbuffer:
processInfo
rangeOfString:
readWriteTextureSupport
removeFromSuperlayer
renderCommandEncoderWithDescriptor:
renderPassDescriptor
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
reset
resolveTexture
sampleCount
setAllowsNextDrawableTimeout:
setAlphaBlendOperation:
setAlphaToCoverageEnabled:
setArgumentBuffer:offset:
setBackFaceStencil:
setBlendColorRed:green:blue:alpha:
setBlendingEnabled:
setBuffer:offset:atIndex:
setBytes:length:atIndex:
setClearColor:
setClearDepth:
setClearStencil:
setCompareFunction:
setComputePipelineState:
setContentsScale:
setCullMode:
setCurrentContext:
setDefaultRasterSampleCount:
setDepth:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthCompareFunction:
setDepthFailureOperation:
setDepthPlane:
setDepthStencilPassOperation:
setDepthStencilState:
setDepthWriteEnabled:
setDestinationRGBBlendFactor:
setDevice:
setDrawableSize:
setFastMathEnabled:
setFormat:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBytes:length:atIndex:
setFragmentFunction:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentTexture:atIndex:
setFrame:
setFramebufferOnly:
setFrontFaceStencil:
setFrontFacingWinding:
setHeight:
setLabel:
setLanguageVersion:
setLevel:
setLoadAction:
setMagFilter:
setMaxAnisotropy:
setMinFilter:
setMipFilter:
setMipmapLevelCount:
setObject:atIndexedSubscript:
setOffset:
setPreprocessorMacros:
setPreserveInvariance:
setRAddressMode:
setRasterizationEnabled:
setReadMask:
setRenderPipelineState:
setRenderTargetHeight:
setRenderTargetWidth:
setResolveDepthPlane:
setResolveLevel:
setResolveSlice:
setResolveTexture:
setResourceOptions:
setRgbBlendOperation:
setSAddressMode:
setSlice:
setSourceAlphaBlendFactor:
setSourceRGBBlendFactor:
setStencilAttachmentPixelFormat:
setStencilCompareFunction:
setStencilFailureOperation:
setStencilFrontReferenceValue:backReferenceValue:
setStencilReferenceValue:
setStepFunction:
setStepRate:
setStoreActionOptions:
setStride:
setTAddressMode:
setTexture:
setTexture:atIndex:
setTriangleFillMode:
setUsage:
setVertexBufferOffset:atIndex:
setVertexBytes:length:atIndex:
setVertexDescriptor:
setVertexFunction:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexTexture:atIndex:
setViewport:
setVisibilityResultBuffer:
setWidth:
setWriteMask:
signaledValue
stencilAttachment
stencilAttachmentPixelFormat
storageMode
storeAction
stringWithFormat:
stringWithUTF8String:
supports32BitFloatFiltering
supportsTextureSampleCount:
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
textureType
threadExecutionWidth
usage
useResource:usage:stages:
vertexDescriptor
waitUntilCompleted
waitUntilScheduled
width
@40@0:8^{SharedSwapState=[3{SwapTexture=IIIQ}]{_opaque_pthread_mutex_t=q[56c]}^{SwapTexture}^{SwapTexture}^{SwapTexture}}16@24r^v32
v16@0:8
@"EAGLContext"
^{SharedSwapState=[3{SwapTexture=IIIQ}]{_opaque_pthread_mutex_t=q[56c]}^{SwapTexture}^{SwapTexture}^{SwapTexture}}
