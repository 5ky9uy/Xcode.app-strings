uouarneglppa
?xfuayledlppa
cfuairavlppa
mcpl
xfua2bvrlppa
cfuaptunlppa
0Ecfuavnoclppa
xfuatsidlppa
xmuaxmcmlppa
xmualpsmlppa
xfuaqebnlppa
mcpl)
xeps
xmuamed3lppa
ngualpsslppa
Mb@?
NSt3__117bad_function_callE
NSt3__112bad_weak_ptrE
St9bad_alloc
uouaoipvlppa
uouacoirlppa
xfuagpsdlppa
11CAException
St12length_error
St11logic_error
St9exception
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioIONode.mm
-[AVAudioIONode enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:]
ioUnit != nil
-[AVAudioOutputNode setManualRenderingPCMFormat:maximumFrameCount:]
self.isInManualRenderingMode
-[AVAudioOutputNode manualRenderingFormat]
-[AVAudioOutputNode manualRenderingMaximumFrameCount]
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCCarplayRuntimeAvailability.mm
supportsCarPlayMixableStream
supportsCarPlayAuxStream
isSessionInWirelessSplitterMode
AVOutputContext
Class getAVOutputContextClass()_block_invoke
AVVCCarplayRuntimeAvailability.mm
Unable to find class %s
void *AVFoundationLibrary()
/System/Library/Frameworks/AVFoundation.framework/Contents/MacOS/AVFoundation
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCUtils.mm
RegisterObject_v1v2
UnregisterObject
DeviceClassNumber
torpedo
logRouteChangeDict
null
{ inputs: %@, 
outputs: %@ }
(type=%@, name=%@, UID=%@); 
Unknown
NewDeviceAvailable
OldDeviceUnAvailable
CategoryChange
Override
WakeFromSleep
NoSuitableRouteForCategory
RouteConfigurationChange
%04d-%02d-%02d 
%02d:%02d:%02d.%06d
Gain
Frame Qualities
StartAnchorPoint
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCPluginRecordingEngine.mm
-[AVVCPluginRemoteInputHost initializePlugins]
-[AVVCPluginRemoteInputHost dealloc]
-[AVVCPluginRemoteInputHost invalidatePlugins]
Audio/Plug-Ins/RemoteInput/
-[AVVCPluginRemoteInputHost allBundles:]
-[AVVCPluginRemoteInputHost findDeviceWithIdentifier:]_block_invoke
-[AVVCPluginRemoteInputHost findDeviceWithIdentifier:]
-[AVVCPluginRemoteInputHost findFirstBluetoothDevice]
-[AVVCPluginRemoteInputHost inputPlugin:didPublishDevice:]
-[AVVCPluginRemoteInputHost inputPlugin:didUnpublishDevice:]
-[AVVCPluginRemoteInputHost mockPluginEndpoint]
AVVCPluginRecordingEngine
~AVVCPluginRecordingEngine
getCurrentDeviceFromActivationContext
AVVCPluginRecordingEngine::startRecording
startRecording_block_invoke
AVVCPluginRecordingEngine::stopRecording
stopRecording_block_invoke
AVVCPluginRecordingEngine::destroyRecordEngine
destroyRecordEngine_block_invoke
_asbdForClientSettings
createRecordQueue_block_invoke
v32@?0@"AVAudioBuffer"8@"AVAudioTime"16@"NSDictionary"24
v20@?0I8@"NSDictionary"12
handleRecordInput
Error! No Remote Device Found
Error! No RemoteInputDeviceName property
AVVCTestDevice
TraceMethod
~TraceMethod
(0x0) use_count:0
activation trigger
activation device uid
StartTime
AlertBehavior
No Record Route
ATVRemoteInput
BluetoothDoAP
JarvisRemoteInput
SetSessionActiveTime
SetSessionInactiveTime
BeginHostTime
EndHostTime
DurationMilliSeconds
undifferentiated-count
dsp-count
mic-count
speaker-ref-count
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVoiceController.mm
-[AVVCRecordDeviceInfo initWithRecordingEngine:]
-[AVVCRecordDeviceInfo dealloc]
v24@?0@"AVVCSessionManager"8^@16
-[AVVoiceController(AVVoiceControllerInternal) setSessionNotifications_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) removeSessionNotifications:]
-[AVVoiceController(AVVoiceControllerInternal) hardwareConfigChanged]
-[AVVoiceController(AVVoiceControllerInternal) handleInterruption_v1v2:]
AVAudioSessionRouteChangeCurrentRouteKey
-[AVVoiceController(AVVoiceControllerInternal) handleRouteChange_v1v2:]_block_invoke
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidPublishDevice:withDevice:]
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidUnpublishDevice:withDevice:]
-[AVVoiceController(AVVoiceControllerInternal) beganRecording_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) finishedRecording_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) startpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) interspeechPointDetected]
-[AVVoiceController(AVVoiceControllerInternal) endpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) beganPlaying]
-[AVVoiceController(AVVoiceControllerInternal) finishedPlaying_v1v2]
-[AVVoiceController(AVVoiceControllerInternal) alertPlaybackFinishedOfType_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) notifyStreamInvalidated_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) beginAudioSessionActivate_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) endAudioSessionActivate_v1v2:]
-[AVVoiceController(AVVoiceController_Priv) setStopOnBargeInEnabled:]
-[AVVoiceController(AVVoiceController_Priv) numberOfChannels]
-[AVVoiceController retain]
-[AVVoiceController release]
-[AVVoiceController initWithContext:error:]
-[AVVoiceController prewarmAudioSession]
finalize
-[AVVoiceController dealloc]
-[AVVoiceController releaseAudioSession]
-[AVVoiceController releaseAudioSession:]
-[AVVoiceController enableMiniDucking:]
-[AVVoiceController willAcceptContext:]
-[AVVoiceController IsDeviceAvailableInLocalRoute:error:]
-[AVVoiceController setCurrentContext:error:]
-[AVVoiceController prepareRecordWithSettings:error:]
-[AVVoiceController setAlertSoundFromURL:forType:]
-[AVVoiceController playAlertSoundForType:]
playAlertSoundForType
-[AVVoiceController resetEndpointer]
-[AVVoiceController playRecordStartingAlertAndResetEndpointer]
-[AVVoiceController startRecording]
-[AVVoiceController startRecording:]
-[AVVoiceController startRecordingAtTime:error:]
-[AVVoiceController startRecordingWithSettings:error:]
-[AVVoiceController stopRecording]
-[AVVoiceController preparePlaybackWithSettings:error:]
preparePlaybackWithSettings
-[AVVoiceController preparePlaybackFromURL:error:]
preparePlaybackFromURL
-[AVVoiceController startPlaying]
-[AVVoiceController stopPlaying]
-[AVVoiceController setRecordDelegate:]
-[AVVoiceController setRecordBufferDuration:]
-[AVVoiceController setEndpointerDelegate:]
internal Speex
external
-[AVVoiceController setRecordEndpointMode:]
-[AVVoiceController setRecordStartWaitTime:]
-[AVVoiceController setPlaybackDelegate:]
-[AVVoiceController setPlaybackBufferDuration:]
-[AVVoiceController isRecording]
-[AVVoiceController setAlertVolume:]
-[AVVoiceController setPlaybackVolume:]
-[AVVoiceController setMeteringEnabled:]
-[AVVoiceController setStopOnEndpointEnabled:]
-[AVVoiceController currentRecordDeviceInfo]
-[AVVoiceController initVoiceControllerForClient:withError:]
-[AVVoiceController setContext:error:]
-[AVVoiceController setContext:streamType:error:]
-[AVVoiceController prepareRecordForStream:completion:]
-[AVVoiceController prepareRecordForStream:error:]
-[AVVoiceController startRecordWithSettings:completion:alertCompletion:audioCallback:]
-[AVVoiceController startRecordForStream:error:]
 will skip alert
 will NOT skip alert
-[AVVoiceController configureAlertBehaviorForStream:error:]
-[AVVoiceController stopRecordOnStream:completion:]
-[AVVoiceController stopRecordForStream:error:]
-[AVVoiceController getCurrentStreamState:]
-[AVVoiceController getRecordDeviceInfoForStream:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:error:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:recordMode:error:]
-[AVVoiceController deactivateAudioSessionWithOptions:]
-[AVVoiceController deactivateAudioSessionForStream:withOptions:error:]
-[AVVoiceController setContextForStream:forStream:error:]
-[AVVoiceController playAlert:withOverride:completion:]
-[AVVoiceController playAlertSoundForType:overrideMode:]
-[AVVoiceController setRecordStatusChangeBlock:]
-[AVVoiceController enableSmartRoutingConsiderationForStream:enable:error:]
-[AVVoiceController setAnnounceCallsEnabledForStream:enable:]
-[AVVoiceController getInputChannelInfoForStream:completion:]
-[AVVoiceController setDuckOthersForStream:withSettings:error:]
<fadeIn(%@), fadeOut(%@)>
<duckOthers(%@), duckToLevel(%@) , mixWithOthers(%@)>
<duckOverride(%@), fadeDuration(%@)>
VCLocker
~VCLocker
BlockIfAnotherAVVCIsStillAlive_v1v2
 TIMEDOUT!
GetAVVCSingleInstanceSemaphore_v1v2_block_invoke
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVC_Log.h
~ElapsedTime
AllowNextAVVCToInit
0x%x
Music Device
Music Effect
Format Converter
Effect
Mixer
Panner
Generator
Offline Effect
MIDI Processor
Apple
AVAudioUnitComponentTagsDidChangeNotification
AVAudioUnitComponentImplementation
%d.%d.%d
AudioUnitTags
com.apple.audio.ComponentTagHelper
Request
type
subtype
manufacturer
UserTags
com.apple.audio.units.Components
AudioUnitTypes
InitialInputs
InitialOutputs
Remote Effect
Remote Generator
Remote Instrument
Remote Music Effect
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/QualityDetector.cpp
QualityDetector
checkStatus
setStartTimeoutFrameCount
setInterspeechTimeoutFrameCount
setEndTimeoutFrameCount
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/SpeexEndpointer.mm
-[SpeexEndpointer init]
-[SpeexEndpointer dealloc]
-[SpeexEndpointer configureWithSampleRate:andFrameRate:]
-[SpeexEndpointer configureWithASBD:andFrameRate:]
-[SpeexEndpointer setEndpointMode:]
-[SpeexEndpointer setStartWaitTime:]
-[SpeexEndpointer setInterspeechWaitTime:]
-[SpeexEndpointer setEndWaitTime:]
-[SpeexEndpointer(SpeexEndpointer_Priv) getStatus:count:]
%02X
Int16
Int32
Int8.24
Float32
Float64
, non-inter
, inter
%2d ch, %6.0f Hz, %s%s
%2d ch, %6.0f Hz, 'freq'
%2d ch, %6.0f Hz
%2d ch, %6.0f Hz, %s (0x%08X) 
 big-endian
 little-endian
 signed
 unsigned
integer
float
packed in %d bytes
unpacked in %d bytes
 high-aligned
 low-aligned
, deinterleaved
%d.%d
%s-bit%s%s %s%s%s%s%s
from %d-bit source, 
from UNKNOWN source bit depth, 
%d frames/packet
%d bits/channel, %d bytes/packet, %d frames/packet, %d bytes/frame
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitTimeEffect.mm
-[AVAudioUnitTimeEffect initWithAudioComponentDescription:]
audioComponentDescription.componentType == kAudioUnitType_FormatConverter
Effects
Equalizer
Filter
Dynamics Processor
Reverb
Distortion
Delay
Time Effect
Synthesizer
Sampler
Drums
Guitar
Vocal
Bass
MIDI
Pitch
Imaging
Output
No changes
New tags found, add it to the allTags
AVAudioUnitComponentManagerRegistrationsChangedNotification
CAException
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCRecordingEngine.mm
~AVVCRecordingEngine
reconfigure
setupASBDAndCreateRecorder
audioSession_block_invoke
sessionManager_block_invoke
populateRecordSettings
setStreamState
setRecordErrorStatus
setRecordBufferDuration
getRecordBufferDuration
getPeakPowerForChannel
getAveragePowerForChannel
cacheRecordRoute
setStartRecordCompletionAndAudioCallbackBlocks
setStopRecordCompletionBlock
setDidStopDelegateCompletionBlock
avvcAudioBufferReceived
audioBufferListReceived
if_running_then
ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
ret = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND)
AVFileTypeAIFF
AVFileTypeAIFC
AVFileTypeWAVE
AVFileTypeMPEG4
AVFileTypeAppleM4A
AVFileTypeCoreAudioFormat
AVFileTypeMPEGLayer3
AVFileTypeAC3
AVFileTypeSunAU
AVFileType3GPP
AVFileType3GPP2
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitGenerator.mm
-[AVAudioUnitGenerator initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Generator) || (audioComponentDescription.componentType == kAudioUnitType_RemoteGenerator)
AVVCSessionFactory Work Queue
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCSessionFactory.mm
-[AVVCSessionFactory _wqCreateAuxSessionAndManagerForDeviceUID:clientType:session:manager:error:]
-[AVVCSessionFactory _wqCreatePrimarySessionManagerIfNeeded:clientType:error:]
-[AVVCSessionFactory _wqSessionAndManagerForContext:clientType:session:manager:error:]
-[AVVCSessionFactory _wqSessionAndManagerForContext:clientType:session:manager:error:]_block_invoke
-[AVVCSessionFactory cleanupContext:]_block_invoke
-[AVVCSessionFactory releasePrimarySessionManager]_block_invoke
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/CoreAudioUtility/Source/Utility/CALog.cpp
RegisterScope
warning
note
notice
info
details
minutiae
spew
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSequencerImpl.mm
AVAudioSequencerImpl
NewMusicPlayer(&mPlayer)
NewMusicSequence(&mSequence)
MusicPlayerSetSequence(mPlayer, mSequence)
MusicSequenceSetAUGraph(mSequence, nullptr)
~AVAudioSequencerImpl
CurrentPosition
MusicPlayerGetTime(mPlayer, &theTime)
SetCurrentPosition
MusicPlayerSetTime(mPlayer, currentPosition)
IsPlaying
MusicPlayerIsPlaying(mPlayer, &isPlaying)
GetRate
MusicPlayerGetPlayRateScalar(mPlayer, &theRate)
SetRate
MusicPlayerSetPlayRateScalar(mPlayer, inRate)
HostTimeForBeats
MusicPlayerGetHostTimeForBeats(mPlayer, inBeats, pOutHostTime)
BeatsForHostTime
MusicPlayerGetBeatsForHostTime(mPlayer, inHostTime, pOutBeats)
NumberOfTracks
GetTrackWithIndex
MusicSequenceGetIndTrack(mSequence, inIndex, &theTrack)
GetTempoTrack
MusicSequenceGetTempoTrack(mSequence, &tempoTrack)
GetSecondsForBeats
MusicSequenceGetSecondsForBeats(mSequence, inBeats, &theSeconds)
GetBeatsForSeconds
MusicSequenceGetBeatsForSeconds(mSequence, inSeconds, &theBeats)
~MusicTrackImpl
SetDestinationAudioUnit
MusicTrackSetDestinationAU(mTrack, inUnit.audioUnit, &desc)
SetDestinationMIDIEndpoint
MusicTrackSetDestMIDIEndpoint(mTrack, inEndPoint)
GetDestinationMIDIEndpoint
MusicTrackGetDestMIDIEndpoint(mTrack, &endPoint)
DoSetLengthInBeats
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_TrackLength, &inLength, sizeof(inLength))
DoGetLengthInBeats
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TrackLength, &length, &pLen)
SetLengthInSeconds
MusicTrackGetSequence(mTrack, &seq)
MusicSequenceGetBeatsForSeconds(seq, inLength, &beatLength)
GetLengthInSeconds
MusicSequenceGetSecondsForBeats(seq, DoGetLengthInBeats(), &seconds)
SetOffset
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &inOffset, sizeof(inOffset))
GetOffset
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &offset, &pLen)
SetLoopCount
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, pLen)
GetLoopCount
SetLoopStart
GetLoopStart
SetLoopEnd
GetLoopEnd
EnableLooping
IsLoopingEnabled
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, pLen)
IsMuted
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, &pLen)
Solo
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, pLen)
IsSoloed
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, &pLen)
UseAutomatedParams
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, pLen)
UsesAutomatedParams
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, &pLen)
GetTimeResolution
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TimeResolution, &timeRes, &pLen)
GetIndex
MusicTrackGetSequence(mTrack, &sequence)
MusicSequenceGetTrackIndex(sequence, mTrack, &index)
avas
sequencer_verbose
error %d
RealtimeMessenger.mServiceQueue
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/CoreAudioUtility/Source/Utility/RealtimeMessenger.cpp
PerformAsync
v16@?0^v8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSinkNode.mm
AVAudioSinkNodeImpl
AVAudioSinkNodeImpl::SetOutputFormat(0, format)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioNodeTap.mm
nil != _format
_initialized
AVAudioNodeTap.mm
/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox
AudioFormatGetProperty
AVVCExternalDeviceRecordingEngine
~AVVCExternalDeviceRecordingEngine
prepareRecoding
destroyRecordingEngine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCRecordingEngineMap.mm
AVVCRecordingEngineMap
~AVVCRecordingEngineMap
findEngine
insertEngine
removeEngine
listEngines
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAudioEngineGraph.mm
TraverseGraphNodes
inCurrNode.GetConnection(inDirection, bus, conn)
TraverseGraphNodesBFS
connNode
connNodeFirst
connNodeSecond
TraverseGraphNodesWithLookback
inCurrNode.GetConnection(otherDirection, bus, conn)
InformNodesAboutMixerConnection
inMixerConn.destNode && inMixerConn.destNode->IsMixerNode()
InformNodesAboutMixerDisconnection
UninitializeNode
inGraph.PerformCommand(node, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
InitializeActiveNodesInOutputChain
inGraph.IsNodeInGraph(inNode.NodeImpl())
inGraph.IsValidSourceNode(*startNode)
inGraph.MakeDisconnection(mixerConn.destNode->NodeImpl(), mixerConn.destBus)
InitializeActiveNodesInInputChain
inGraph.GetInputNode() && (&inNode == inGraph.GetInputNode())
false == isInputConnToConverter
inGraph.MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
inGraph.MakeConnection(inputConn)
inGraph.PerformCommand(*inGraph.GetInputNode(), AVAudioEngineGraph::kAUSetInputCallback, &rc, sizeof(rc))
PrepareForConnection
srcNode && inGraph.IsNodeInGraph(srcNode)
destNode && inGraph.IsNodeInGraph(destNode)
srcCurrConn.destNode == NULL || srcCurrConn == inConn
destCurrConn.srcNode == NULL || destCurrConn == inConn
inGraph.PerformCommand(*destNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
PrepareForDisconnection
inGraph.IsNodeInGraph(&inDestNode)
inGraph.PerformCommand(inDestNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
AVAEGraphStateTracker.RunStateQueue
AVAudioEngineGraph.mm
outputNode != nullptr
inputNode != nullptr || outputNode != nullptr
err = PerformCommand(*outputNode, kAUInitialize, NULL, 0)
IsFormatSampleRateAndChannelCountValid(outputHWFormat)
err = _Connect(connNode->NodeImpl(), outputNode->NodeImpl(), 0, 0, format)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainOptimizedTraversal, *GetOutputNode(), isOutputChainActive)
GetOutputNode()->IsInitialized()
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *GetInputNode())
GetInputNode()->IsInitialized()
IsFormatSampleRateAndChannelCountValid(inputHWFormat)
PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
_Uninitialize
(err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0))
(err = MakeConnection(conn, outErr))
(err = PerformCommand(*GetOutputNode(), kAUUninitialize, NULL, 0))
(err = PerformCommand(*GetInputNode(), kAUUninitialize, NULL, 0))
Start
ioNode != NULL
err = PerformCommand(*ioNode, kAUStartIO, NULL, 0)
_Stop
(err = PerformCommand(*ioNode, kAUStopIO, NULL, 0))
nil != inAVNode
inImpl != nil && !IsIONode(inAVNode)
AddIONode
inImpl != nil && IsIONode(inAVNode)
NULL == ioNodeImpl && !IsNodeInGraph(inImpl)
RemoveNode
IsNodeInGraph(inImpl)
!IsRunning() && !graphNode->IsInitialized()
(graphNode->IsNodeState(kAUGraphNodeState_InInputChain) || graphNode->IsNodeState(kAUGraphNodeState_InOutputChain))
!nodeMixerConns.empty() && !hasDirectConnToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus, outErr)
err = MakeDisconnection(currSrcConn.destNode->NodeImpl(), currSrcConn.destBus, outErr)
err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
err = DisconnectInactiveNode(graphNode, true , disjointNodes, outErr)
conn.IsSrcAndDestValid()
graphNode == conn.destNode
err = MakeConnection(conn, outErr)
err = UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
RemoveIONode
(isInputNode && graphNode == GetInputNode()) || (!isInputNode && graphNode == GetOutputNode())
!IsRunning() && !IsInitialized()
err = RemoveNode(inAVNode, outErr)
inAVNode
format.sampleRate == inputHWFormat.sampleRate
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *inputNode)
inSrcAVNode && inDestAVNode
inSrcImpl && inDestImpl
_Connect
IsNodeInGraph(inSrcImpl) && IsNodeInGraph(inDestImpl)
inSrcImpl->NumberOutputs() > 0
inDestImpl->NumberInputs() > 0 || graphNodeDest->CanResizeNumberOfInputs()
!srcNodeMixerConns.empty() && !isSrcNodeConnectedToIONode
!destNodeMixerConns.empty() && !isDestNodeConnectedToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*graphNodeSrc, kAUUninitialize, NULL, 0)
err = MakeDisconnection(inDestImpl, inDestBus)
err = MakeDisconnection(graphNodeSrcCurrConnPoint.node->NodeImpl(), graphNodeSrcCurrConnPoint.bus)
[format isEqual:dstFormat]
inSrcImpl->SetOutputFormat(inSrcBus, dstFormat)
[srcFormat isEqual:format]
inDestImpl->SetInputFormat(inDestBus, srcFormat)
inSrcImpl->SetOutputFormat(inSrcBus, format) && inDestImpl->SetInputFormat(inDestBus, format)
[midiInputImpl->GetOutputFormat(0) isEqual:inSrcImpl->GetOutputFormat(0)]
err = MakeConnection(currentConn)
graphNodeDest != conn.destNode
inSrcAVNode && inDestAVConnectionPoints && inDestAVConnectionPoints.count > 0
IsNodeInGraph(inSrcImpl)
!inSrcNode->IsSplitterNode()
currentConnPoints.size() <= 1
currentConnPoints.size() > 1
avConnPoint
MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*finalSrcNode, kAUUninitialize, NULL, 0)
_DisconnectInput(connPoint.node->NodeImpl(), connPoint.bus)
_Connect(inSrcImpl, [splitter impl], inSrcBus, kAudioUnitElement_Default, format)
RemoveNode(avNode)
PerformCommand(*finalSrcNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
[midiInputImpl->GetOutputFormat(0) isEqual:finalSrcNode->NodeImpl()->GetOutputFormat(0)]
_Connect(finalSrcNode->NodeImpl(), destImpl, srcBus, destBus, format)
UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
inDestAVNode
inDestImpl
_DisconnectInput
IsNodeInGraph(inDestImpl)
!IsRunning()
graphNode != conn.destNode
inSrcAVNode
inSrcImpl
_DisconnectOutput
inImpl
tmpErr = _DisconnectInput(conn.destNode->NodeImpl(), conn.destBus)
inSourceAVNode && inDestAVNodes && inDestAVNodes.count > 0
graphNodeSrc->IsMIDIProcessorNode()
destAVNode
graphNodeDest->IsMusicDevice() || graphNodeDest->IsMusicEffect() || graphNodeDest->IsMIDIProcessorNode()
inSrcImpl->SetOutputFormat(0, newFormat)
PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
err = UpdateGraphAfterReconfig(&disjointNodes, kOutputChainFullTraversal)
PerformCommand(*midiNode, kAUUninitialize, nullptr, 0)
graphNode->IsMIDIProcessorNode()
!graphNode->IsSplitterNode()
!splitterConnPoint.node->IsSplitterNode()
numSplitterConnections == 0 || numSplitterConnections > 1
!connPoint.node->IsSplitterNode()
NodeRenderingStateChanged
GetOutputDeviceLatencyForNode
GraphDescription
RenderToABL
outputNode
InputAvailable
isSink || tap != nullptr
AddPendingConnection
inConn.IsSrcAndDestValid()
RemovePendingConnection
inConn.srcNode || inConn.destNode
MakeConnection
err = MakeDisconnection(inDestImpl, inDestBus, outErr)
err = PerformCommand(*graphNodeDest, kAUMakeConnection, &connection, sizeof(connection))
err = PerformCommand(*graphNodeDest, kAUInitialize, NULL, 0)
err = PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
MakeVirtualConnection
IsNodeInGraph(conn.srcNode) && IsNodeInGraph(conn.destNode)
srcCurrConn.destNode == NULL || srcCurrConn == conn
destCurrConn.srcNode == NULL || destCurrConn == conn
MakeDisconnection
true == graphNodeDest->GetConnection(kUpstream, inDestBus, mixerConn)
DisconnectInactiveNode
false == inNode->IsInitialized()
err = MakeConnection(itInp->srcNode->NodeImpl(), itOut->destNode->NodeImpl(), itInp->srcBus, itOut->destBus, outErr)
UpdateGraphAfterReconfig
conn.srcNode && conn.destNode && conn.destNode->IsMixerNode()
AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainFullTraversal, *conn.srcNode, isChainActive)
MakeConnection(inputConn)
PerformCommand(*inputConn.srcNode, kAUInitialize, NULL, 0)
PerformCommand(*inputConn.destNode, kAUInitialize, NULL, 0)
MakeConnection(conn)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, inTraversalMode, *GetOutputNode(), isChainActive)
LastRenderErrorInChain
startNodeImpl
startNode
(bus%d) %p, {%s} -> 
(bus%d) %p, {%s}
________ %s ________
AVAudioEngineGraph %p: initialized = %d, running = %d, number of nodes = %d
 ******** output chain ********
 ******** input chain ********
 ******** pending connections - output ********
 %s, [%s]
 ******** pending connections - input ********
 ******** other nodes ********
______________________________________
err = MusicSequenceSetAudioGraph(inSequence, _seqGraphImpl)
NodeStateChanged
GetMusicDeviceNode()
RegisterRenderCallback
UnregisterRenderCallback
GetDefaultMusicDevice
outUnit || outDesc
GetOutputAudioUnit
false condition
inGraph.PerformCommand(theNode, AVAudioEngineGraph::kAUSetPropertyMaximumFramesPerSlice, &maxFrames, sizeof(maxFrames))
failed call
realloc failed
GetNumberBuffers
CoreAudioBaseTypes.hpp
GetAudioBufferList().mNumberBuffers == (mStorage.size() - kHeaderSize) / sizeof(AudioBuffer)
inGraph.PerformCommand(midiNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
conn.destNode && conn.destNode->IsMixerNode()
0 == inCurrNode.NumberOfValidConnections(kUpstream)
inNodeUpstream.IsInitialized()
inGraph.MakeDisconnection(inPrevConn->destNode->NodeImpl(), inPrevConn->destBus)
err = PerformCommand(midiInput, kAUInitialize, nullptr, 0)
v16@?0@"NSNotification"8
AVAudioEnvironmentNodeImpl.mm
name
identifier
supportedLanguages
version
voiceSize
gender
voice
ssmlRepresentation
avat
com.apple.avfaudio.devicetest.service
AVAudioDeviceTest.mm
v24@?0@"NSArray"8@"NSError"16
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioConverter.mm
convert
outputBuffer.frameCapacity >= inputBuffer.frameLength
FillComplexProc
impl->_inputBufferReceived
[impl->_inputBufferReceived.format isEqual: impl->_inputFormat]
ioData->mNumberBuffers == abl->mNumberBuffers
AVVC_PROFILE_Prop_PrepareStart
AVVC_PROFILE_Prop_PrepareEnd
AVVC_PROFILE_Prop_GetPropertiesStart
AVVC_PROFILE_Prop_GetPropertiesEnd
AVVC_PROFILE_Prop_SetSessionActiveStart
AVVC_PROFILE_Prop_SetSessionActiveEnd
AVVC_PROFILE_Prop_SetupRecordQueueStart
AVVC_PROFILE_Prop_SetupRecordQueueEnd
AVVC_PROFILE_Prop_StartRecordingStart
AVVC_PROFILE_Prop_StartRecordingEnd
AVVC_PROFILE_Prop_PlayAlertStart
AVVC_PROFILE_Prop_PlayAlertEnd
AVVC_PROFILE_Prop_RecordQueueStart
AVVC_PROFILE_Prop_RecordQueueEnd
AVVC_PROFILE_Prop_FirstBufferReceived
AVVC_PROFILE_Delta_PrepareAPIStartEnd
AVVC_PROFILE_Delta_GetSessionPropStartEnd
AVVC_PROFILE_Delta_SetSessionActiveStartEnd
AVVC_PROFILE_Delta_SetupRecordQueueStartEnd
AVVC_PROFILE_Delta_StartRecordAPIStartEnd
AVVC_PROFILE_Delta_PlayAlertQueueStartEnd
AVVC_PROFILE_Delta_StartRecordAudioQueueStartEnd
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferDelta
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferToDelegateCallDelta
AVVCMM
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCMetricsManager.mm
+[AVVCMetricsManager createSharedManager]
+[AVVCMetricsManager destroySharedManager]
+[AVVCMetricsManager sharedManager]
-[AVVCMetricsManager dealloc]
yyyy-MM-dd'T'HH:mm:ss.SSSSSSSZZZZZ
v32@?0@8@16^B24
-[AVVCMetricsManager measureElapseTimeForMetric:block:]
-[AVVCMetricsManager logProfileMetrics:]
configure
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImplV1.mm
configure_v1
setCurrentContext_v1
getCurrentRecordDeviceInfo_v1
getCurrentRecordSettings_v1
enableMetering_v1
updateMeters_v1
getPeakPowerForChannel_v1
getAveragePowerForChannel_v1
isMeteringEnabled_v1
resetEndpointDetector
prepareRecord
prepareRecord_v1
startRecord
startRecord_v1
secondPassCompletionHostTime
createPlaybackQueue
createPlaybackQueue_v1
AVVoiceController_PlaybackQueue
preparePlaybackQueue
preparePlaybackQueue_v1
startPlaybackQueue
startPlaybackQueue_v1
flushAndStopPlaybackQueue
flushAndStopPlaybackQueue_v1
prepareAudioFile_v1
setupAudioFile
setupAudioFile_v1
handleEOF
handleAudioPlaybackStream
handleFileRead
handleEncodedFileRead
getRecordBufferDuration_v1
setRecordBufferDuration_v1
getStartRecordTime_v1
setStartRecordTime_v1
configureAlertOverrides_v1
VCUnlocker
~VCUnlocker
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.mm
AUGraphNodeBase
nil != _avNode
nullptr != _avNodeImpl
ConnectInput
nullptr != srcNode
AddNode
inNode != nil
DisconnectNode
CreateRecordingTap
nil != callbackBlock
nullptr == Tap()
NodeImpl()->SetOutputFormat(bus, format)
 node %p {%s}, '%s'
 inputs = %d
 (bus%d, en%d) <- (bus%d) %p, {%s}, [%s]
 outputs = %d
 (bus%d, en%d) -> (bus%d) %p, {%s}, [%s]
AUGraphNodeBaseV3
RenderBlock()
i44@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36
DestroyMIDIConnection
midiSrc == MIDIInput()
DeallocateInputBlock
false == AUI().IsRunning()
AllocateInputHandler
v36@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28
AUGraphMIDINodeV3
IsMIDIProcessorNode()
SetTapBlock
GetTapBlock()
i36@?0q8C16q20r*28
AUGraphSourceNodeV3
NodeImpl()->IsAVAudioSourceNode()
InputBlock()
AUGraphSinkNodeV3
NodeImpl()->IsSinkNode()
AllocateRenderBlock
receiverBlock
i52@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36@?<i@?^I^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}Iq^{AudioBufferList=I[1{AudioBuffer=II^v}]}>44
AVAEGraphNode.mm
AUGraphMultiBusNode
IsMixerNode() || IsSplitterNode()
GetConnection
nodeBussesVec.size() >= (inBus + 1)
GetConnectionPoint
GetBusForConnectionPoint
nodeBussesVec.size() == nodeVec.size()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.h
InputMutex
bus < _inMutexes.size()
Drums - Bit Brush
Drums - Buffer Beats
Drums - Lo-Fi
Multi - Broken Speaker
Multi - Cellphone Concert
Multi - Decimated 1
Multi - Decimated 2
Multi - Decimated 3
Multi - Decimated 4
Multi - Distorted Funk
Multi - Distorted Cubed
Multi - Distorted Squared
Multi - Echo 1
Multi - Echo 2
Multi - Echo Tight 1
Multi - Echo Tight 2
Multi - Everything is Broken
Speech - Alien Chatter
Speech - Cosmic Interference
Speech - Golden Pi
Speech - Radio Tower
Speech - Waves
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImplV2.mm
prepareRecordForStream_v2
startRecordForStream_v2
stopRecordOnStream_v2
stopRecordForStream_v2
getCurrentStreamStateForStream_v2
getRecordBufferDurationForStream_v2
configureAlertBehaviorForStream_v2
activateAudioSessionForStream_v2
setAudioSessionActive
deactivateAudioSessionWithOptions_v2
setContextForStream_v2
playAlertWithCompletion_v2
getRecordDeviceInfoForStream_v2
getRecordSettingsForStream_v2
isMeteringEnabledForStream_v2
updateMeterLevelForStream_v2
getPeakPowerForStreamAndChannel_v2
getAveragePowerForStreamAndChannel_v2
playAlertWithOverride_v2
playAlertWithOverride_v2_block_invoke
setAnnounceCallsEnabledForStream
setDuckOthersForStream_v2
setSessionState_v1v2
setStartAlertMode_v1v2
setAlertQueueState_v1v2
setStopAlertMode_v1v2
setStopWithErrorAlertMode_v1v2
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioClock.mm
AVAudioClockImpl
_nodeImpl->AUI().AddV2PropertyListener(kAudioUnitProperty_StreamFormat, StreamFormatListener, this)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVMIDIPlayer/AVMIDIPlayer.mm
-[AVMIDIPlayer dealloc]
-[AVMIDIPlayer prepareToPlay]
MusicPlayerPreroll(impl->mPlayer)
-[AVMIDIPlayer isPlaying]
MusicPlayerIsPlaying(impl->mPlayer, &playing)
-[AVMIDIPlayer rate]
MusicPlayerGetPlayRateScalar(impl->mPlayer, &scalar)
-[AVMIDIPlayer setRate:]
MusicPlayerSetPlayRateScalar(impl->mPlayer, rate)
-[AVMIDIPlayer duration]
MusicSequenceGetSecondsForBeats(impl->mSequence, impl->mLength, &durInSeconds)
-[AVMIDIPlayer currentPosition]
MusicPlayerGetTime(impl->mPlayer, &positionInBeats)
MusicSequenceGetSecondsForBeats(impl->mSequence, positionInBeats, &positionInTime)
-[AVMIDIPlayer setCurrentPosition:]
MusicSequenceGetBeatsForSeconds(impl->mSequence, (Float64) currentPosition, &positionInBeats)
MusicPlayerSetTime(impl->mPlayer, positionInBeats)
avmp
avmidiplayer_verbose
MIDIPlayerImpl
CallbackQueue
~MIDIPlayerImpl
start
MusicPlayerStart(mPlayer)
stop
MusicPlayerStop(mPlayer)
finishLoad
MusicSequenceGetAUGraph(mSequence, &graph)
MusicSequenceGetTrackCount(mSequence, &trackCount)
MusicTrackGetProperty(track, kSequenceTrackProperty_TrackLength, &length, &plength)
MusicSequenceSetUserCallback(mSequence, userCallback, this)
SetUpGraph
AUGraphOpen(inGraph)
AUGraphGetNodeCount (inGraph, &nodeCount)
AUGraphGetIndNode(inGraph, i, &node)
AUGraphNodeInfo(inGraph, node, &desc, &unit)
AudioUnitSetProperty (unit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &numFrames, sizeof(numFrames))
AUGraphInitialize(inGraph)
/9luHerXthRoPoNt/PVkTg
AVAudioUnitMIDIInstrument.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitMIDIInstrument.mm
SendProgramChange
true == SendMIDIEvent(kMIDIMessage_ControlChange, 0, bankMSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_ControlChange, bankSelectLSBParam1, bankLSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_PatchChange, programID, 0, 0, channel)
-[AVAudioUnitMIDIInstrument initWithAudioComponentDescription:]
(description.componentType == kAudioUnitType_MusicDevice) || (description.componentType == kAudioUnitType_RemoteInstrument)
-[AVAudioUnitMIDIInstrument startNote:withVelocity:onChannel:]
_IMPL->StartNote(note, velocity, channel)
-[AVAudioUnitMIDIInstrument stopNote:onChannel:]
_IMPL->StopNote(note, channel)
-[AVAudioUnitMIDIInstrument sendController:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ControlChange, controller, controllerValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendPitchBend:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PitchBend, value&0x7F, value>>7, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressure:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ChannelPressure, pressureValue, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressureForKey:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_KeyPressure, key, pressureValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PatchChange, program, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:bankMSB:bankLSB:onChannel:]
_IMPL->SendProgramChange(program, bankMSB, bankLSB, channel)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:data2:]
_IMPL->SendMIDIEvent(midiStatus, data1, data2, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:]
_IMPL->SendMIDIEvent(midiStatus, data1, 0, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDISysExEvent:]
_IMPL->SendMIDISysexEvent((CFDataRef)midiData)
required condition is false: %s
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVFAudioCore/AVAudioBuffer.mm
-[AVAudioBuffer initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:]
isPCMFormat(fmt)
bufferList != nullptr
bufferList->mNumberBuffers == numBuffers
-[AVAudioBuffer setByteLength:]
length <= _imp->_byteCapacity
<%@@%p: %d/%d bytes>
-[AVAudioPCMBuffer initWithPCMFormat:frameCapacity:]
AVAudioBuffer.mm
_imp->OwnsMemory() && !_imp->_externalABL.has_value()
-[AVAudioPCMBuffer initWithPCMFormat:bufferListNoCopy:deallocator:]
!_imp->OwnsMemory() && _imp->_externalABL.has_value()
-[AVAudioPCMBuffer setFrameLength:]
length <= _imp->_frameCapacity
-[AVAudioCompressedBuffer initWithFormat:packetCapacity:maximumPacketSize:]
!(fmt.IsLinearPCM() || fmt.mFormatID == kAudioFormatALaw || fmt.mFormatID == kAudioFormatULaw)
maximumPacketSize != 0
-[AVAudioCompressedBuffer setPacketCount:]
length <= _imp->_packetCapacity
ExtendedAudioBufferList_CreateWithFormat failed
ExtendedAudioBufferList_Prepare failed
AVAB
cannot convert to CMAudioFormatDescription %d
<AVAudioFormat %p: %s>
mSampleRate
mFormatID
mFormatFlags
mBytesPerPacket
mFramesPerPacket
mBytesPerFrame
mChannelsPerFrame
mBitsPerChannel
channelLayout
magicCookie
Audio files cannot be non-interleaved. Ignoring setting AVLinearPCMIsNonInterleaved YES.
AVAudioSession
data
outputID
inputID
sampleRate
correlationValue
stimulusURL
outputMode
volume
inputProcessingChain
outputProcessingChain
mode
calculateCrossCorrelationPeak
processSequenceAsynchronously
parallelCrossCorrelationCalculation
graphURL
processingStripURL
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSourceNode.mm
AVAudioSourceNodeImpl
SetInputFormat(0, format)
AVVCAudioQueueRecordingEngine
~AVVCAudioQueueRecordingEngine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCAudioQueueRecordingEngine.mm
AudioQueueRecordInputCallback
AudioQueueRecordPropertyListenerProc
QueueIsRunning
Initialize
setHWSampleRate
asbdForClientSettings
createRecordQueue
With
AVVoiceController_RecordQueue
configureRecordConverterFromSettings
createAudioConverter
setupDSPGraph
prepareRecording
startRecording
startRecording:AudioQueueReset
delay
past
immediate
startRecording : AudioQueueStart
stopRecording
mRecordQueue : AudioQueueStop
destroyRecordEngine
queue : AudioQueueStop
destroyRecordEngine: AudioQueueDispose
enableSiriListeningMode
enableMetering
updateMeterLevels
DeinterleaveAudio
handleRecordQueuePropertyListener
handleAudioInput
setSessionIsRecordingFlag
resetAudioEngine
resetAudioEngine:mRecordQueue: AudioQueueReset
UpdateRecordDeviceOnQueue
getRecordRoute
(%p) streamID: %d, use_count:%ld
RecordEncoderInputDataProc
com.apple.speech.voice.Alex
AVSpeechSynthesisIPANotationAttribute
/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle
language
quality
speechString
rate
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
attributedSpeechString
mark
byteSampleOffset
textRange
IPHONE_SIMULATOR_ROOT
CFFIXED_USER_HOME
setDuckOthersOption
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImplV1V2.mm
setDuckOthersOption_v1v2
resetMiniDuckingStateIfPreviouslyEnabled_v1v2
setSessionCategoryModeOptionsAndSampleRateFromMode_v1v2
audioSessionForStreamID
sessionManagerForStreamID
setSessionProperties
setSessionProperties_v1v2
AVVC Rec Queue RunLoop
DispatchQueue
SIMULATOR_ROOT
%s%@
/System/Library/Audio/UISounds/jbl_begin.caf
/System/Library/Audio/UISounds/jbl_confirm.caf
/System/Library/Audio/UISounds/jbl_cancel.caf
Alert
Record
Playback
Session
ControllerImpl
profile_avvc
duck_others
AVVC Client Notification Queue
AVVC ControllerImpl Work Queue
~ControllerImpl
callbackBarrier_v1v2
setNoResumeOnDeactivate_v1v2
setActivationModeAndSessionHWControlFlagsAndOptions_v1v2
getDeviceUIDForHomeOrBluetoothButtonActivation_v1v2
handlePluginDidPublishDevice_v1v2
handlePluginDidUnpublishDevice_v1v2
createRecordingEngine_v1v2
configureAlerts
configureAlerts_v1v2
cleanup
setActivationContext_v1v2
getRecordAndPlaybackRoutes_v1v2
Unknown Playback Route
No Playback Route
checkSession
checkSession_v1v2
AVVCEngine-prepareRecording from checkSession
forceDeactivateSessionAndFixupState_v1v2
B8@?0
deactivateSession_v1v2
AVAudioSessionDeactivate
handleRetrySessionActivationError_v1v2
setSessionActive_v1v2
setSessionActive
unconfigured
AVAudioSessionSetActive
mPlaybackQueue : AudioQueueStop
setSessionActive1
setSessionActive2
getSessionProperties_v1v2
getSessionProperties
getSessionProperties_HWConfig
setupEndpointer_v1v2
getRecordErrorStatus_v1v2
prepareRecordQueue
prepareRecordQueue_v1v2
calculateRecordStartTime_v1v2
configureAlertModeFromModeAndEngine
configureAlertModeFromModeAndEngine_v1v2
handsFree
built-in speaker
Auto
Post-Voice
iMessageGestureToHead
Dictation
Wired/BT ButtonPress
stopRecord
stopRecord_v1v2
waitForAllStopRecordCompletion_v1v2
stopRecordingOnCategoryChange_v1v2
startedRecording
startedRecording_v1v2
doneRecording
doneRecording_v1v2
setAlertURL
playAlert
playAlert_v1v2
createAlertQueue
createAlertQueue_v1v2
AVVoiceController_AlertQueue
primeAlertQueue
primeAlertQueue_v1v2
AudioQueueReset : mAlertQueue
setupAlert
setupAlert_v1v2
startAlertQueue
startAlertQueue_v1v2
mAlertQueue : AudioQueueStart
 but failed
mAlertQueue : AudioQueueStop
destroyAlertQueue
destroyAlertQueue_v1v2
destroyAlertQueue : AudioQueueStop
calculateAlertTimes_v1v2
alertStarted
alertStarted_v1v2
alertFinished
alertFinished_v1v2
AlertAQPropertyListenerProc
AlertAQPropertyListenerProc_v1v2
handleAlertAQPropertyChange
handleAlertAQPropertyChange_v1v2
vibeStartAlertFinished
vibeStartAlertFinished_v1v2
vibeStopAlertFinished
vibeStopAlertFinished_v1v2
VibeAlertCompletionProc
VibeAlertCompletionProc_v1v2
checkForEndpoint_v1v2
HandleDeferredContext_v1v2_block_invoke
HandleConverterError_v1v2
startKeepAliveQueue
stopKeepAliveQueue
handleInterruptStart_v1v2
primary
handleInterruptStop_v1v2
handleRouteChange_v1v2
interrupted
not (yet) active
handleServerDeath_v1v2
handleServerReset_v1v2
destroyPlaybackQueue
destroyPlaybackQueue_v1v2
destroyPlaybackQueue : AudioQueueStop
startedPlaying
donePlaying
PlaybackAQPropertyListenerProc
getEngineTypeAndDeviceIDToUse_v1v2
setContext_v1v2
_createRecordingEngineWithParameters_v1v2
_insertRecordingEngineIntoMap_v1v2
com.apple.avfoundation.avvc
fault_on_streamID_violation
_getCurrentRecordingEngine_v1v2
_lookupEngineForStreamID_v1v2
_lookupEngineForDeviceUUID_v1v2
_invalidateStreamWhenDeviceUnavailable_v1v2
_removeEngineFromMap_v1v2
cleanupDelegateDispatchGroup
ILLEGAL
NotConfigured
Inactive
InteruptedWhileRecording
InteruptedWhilePlaying
Prewarming
Activating
Deactivating
Active
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImpl.h
ExternalDevice
AudioQueue
Plugin
Invalid
Uninitialized
Stopped
Starting
Running
Stopping
stopped
starting
active
stopping
Silent
Haptic
Beep
No Override
Mute
setAlertState_v1v2
QueueIsRunning_v1v2
uninit
primed
started
running
inactive
Illegal
'Unknown'
'Override'
'Wake From Sleep'
'No Suitable Route for Category'
'Configuration Change'
operator()
avvc
avvc_debug
debug_level
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVC_Log.cpp
Initialize_Logging_v1v2
debug_encoding
debug_endpoint
debug_callbacks
debug_locking
debug_state
debug_trace
debug_timing
debug_delegate
debug_playback
debug_deviceselect
/System/Library/Frameworks/CoreMedia.framework/CoreMedia
CMAudioFormatDescriptionGetStreamBasicDescription
CMAudioFormatDescriptionCreate
CMAudioFormatDescriptionGetChannelLayout
CMAudioFormatDescriptionGetMagicCookie
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCSessionManager.mm
-[AVVCSessionManager setupOneTimeSessionSettingsForClient:]
setupOneTimeSessionSettingsForClient
-[AVVCSessionManager setSessionActivationContext:]
setSessionActivationContext
-[AVVCSessionManager shouldEnableMiniDucking:withOptions:]
shouldEnableMiniDucking
-[AVVCSessionManager getHypotheticalRouteAndUpdateStates]
getHypotheticalRouteAndUpdateStates
-[AVVCSessionManager setSessionCategoryModeOptionsForActivationMode:withOptions:]
setSessionCategoryModeOptionsForActivationMode
setSessionCategoryModeOptionsFromActivationMode
-[AVVCSessionManager setSessionAudioHWControlFlagsForActivationMode:withOptions:]
setSessionAudioHWControlFlagsForActivationMode
setSessionAudioHWControlFlagsFromActivationMode
-[AVVCSessionManager setSessionSampleRateForActivationMode:]
setSessionSampleRateForActivationMode
setSessionSampleRateFromActivationMode
-[AVVCSessionManager setSessionBufferSize:]
setSessionBufferSize
-[AVVCSessionManager setDuckOthers:mixWithOthers:error:]
setDuckOthersMixWithOthers
setDuckOthers:mixWithOthers
-[AVVCSessionManager setDuckingFadeOutDuration:fadeInDuration:error:]
setDuckingFadeDuration
-[AVVCSessionManager isSessionOutputInWirelessSplitterMode]
isSessionOutputInWirelessSplitterMode
-[AVVCSessionManager enableSmartRoutingConsideration:]
enableSmartRoutingConsideration
-[AVVCSessionManager isAirplayOneOfTheOutputRoutes:]
-[AVVCSessionManager getInputLatency]
getInputLatency
-[AVVCSessionManager getOutputLatency]
getOutputLatency
-[AVVCSessionManager speechDetectionDeviceSampleRate]
speechDetectionDeviceSampleRate
-[AVVCSessionManager setCategory:mode:options:error:]
setCategory:mode:options
-[AVVCSessionManager setCategory:mode:routeSharingPolicy:options:error:]
setCategory:mode:routeSharingPolicy:options
-[AVVCSessionManager clearInputPreferences:]
clearInputPreferences
-[AVVCSessionManager isSessionInSiriCategoryModeAndOptions:]
-[AVVCSessionManager isSessionInSiriCategory]
isSessionInSiriCategory
-[AVVCSessionManager setAudioHardwareControlFlags:error:]
setAudioHardwareControlFlags
-[AVVCSessionManager reporterID]
reporterID
-[AVVCSessionManager setIAmTheAssistant:error:]
setIAmTheAssistant
-[AVVCSessionManager setPreferredSampleRate:error:]
setPreferredSampleRate:error
-[AVVCSessionManager siriInputSource]
siriInputSource
-[AVVCSessionManager setActivationContext:error:]
setActivationContext
-[AVVCSessionManager setActive:withOptions:error:]
setActive
-[AVVCSessionManager getOpaqueSessionID]
getOpaqueSessionID
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
-[AVVCSessionManager setRecordingFromRemoteInput:error:]
setRecordingFromRemoteInput
-[AVVCSessionManager inputNumberOfChannels]
inputNumberOfChannels
BTDetails_SupportsDoAP
BTDetails_SupportsSoftwareVolume
dump_input
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCAudioCapturer.mm
~AVVCAudioCapturer
/tmp/Assistant/AVVCCapture/
AVVCAudioCapturer_AudioDiagnostics
~AVVCAudioCapturer_AudioDiagnostics
setup
logCaptures
dispose
/usr/local/lib/libAudioDiagnostics.dylib
NewAudioCapturerImpl
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioFile.mm
-[AVAudioFile writeFromBuffer:error:]
buffer != nil
_imp->CheckClientFormatSet()
ExtAudioFileWrite(_imp->_extAudioFile, buffer.frameLength, buffer.audioBufferList)
-[AVAudioFile readIntoBuffer:frameCount:error:]
frames <= buffer.frameCapacity
buffer.frameCapacity != 0
ExtAudioFileRead(_imp->_extAudioFile, &ioFrames, buffer.mutableAudioBufferList)
-[AVAudioFile length]
ExtAudioFileGetProperty(_imp->_extAudioFile, kExtAudioFileProperty_FileLengthFrames, &propSize, &length)
-[AVAudioFile framePosition]
ExtAudioFileTell(_imp->_extAudioFile, &pos)
-[AVAudioFile setFramePosition:]
ExtAudioFileSeek(_imp->_extAudioFile, pos)
AVAudioFileImpl
fileURL != nil
ExtAudioFileOpenURL((CFURLRef)fileURL, &_extAudioFile)
_initCommonReading
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_FileDataFormat, &propSize, &fileASBD)
SetFormats(format, interleaved, fileASBD, avacl)
ReadMagicCookie
_fileFormat
_processingFormat
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &fileID)
ExtAudioFileCreateWithURL((CFURLRef)fileURL, fileType, &fileASBD, NULL, kAudioFileFlags_EraseFile, &_extAudioFile)
ExtAudioFileGetProperty(openFileImpl->_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &openAudioFileID)
ExtAudioFileWrapAudioFileID(openAudioFileID, false, &_extAudioFile)
CheckClientFormatSet()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioNode.mm
-[AVAudioNode installTapOnBus:bufferSize:format:block:]
tapBlock
NULL != engine
-[AVAudioNode removeTapOnBus:]
-[AVAudioNode destinationForMixer:bus:]
mixer
-[AVAudioMixingDestination destinationForMixer:bus:]
GetMixingDestination
inMixerAVNode
WillDisconnectFromMixer
mixingDest
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioNodeImpl.h
AVAE_CheckNodeHasEngine
_engine != nil
aupreset
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitSampler.mm
-[AVAudioUnitSampler loadInstrumentAtURL:error:]
error
-[AVAudioUnitSampler loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:]
-[AVAudioUnitSampler loadAudioFilesAtURLs:error:]
AVAudioIOUnit
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioIONodeImpl.mm
AUI().AddV2PropertyListener(propID, IOUnitPropertyListener, this)
v8@?0
_GetHWFormat
hwFormat
SetOutputFormat
_isInput
IsFormatSampleRateAndChannelCountValid(format)
IsFormatSampleRateAndChannelCountValid(hwFormat)
format.sampleRate == hwFormat.sampleRate
SetInputFormat
!_isInput
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSequencer.mm
-[AVAudioSequencer(AVAudioSequencer_Player) prepareToPlay]
impl->PrepareToPlay()
-[AVAudioSequencer(AVAudioSequencer_Player) startAndReturnError:]
impl->Start()
-[AVAudioSequencer(AVAudioSequencer_Player) stop]
impl->Stop()
-[AVAudioSequencer loadFromURL:options:error:]
impl->LoadFromFile((CFURLRef)fileURL, (UInt32)options)
-[AVAudioSequencer loadFromData:options:error:]
impl->LoadFromData((CFDataRef)data, (UInt32)options)
-[AVAudioSequencer writeToURL:SMPTEResolution:replaceExisting:error:]
impl->WriteToFile((CFURLRef)fileURL, (SInt32)resolution, replace)
-[AVAudioSequencer dataWithSMPTEResolution:error:]
impl->WriteToData(&outData, (SInt32)SMPTEResolution)
-[AVMusicTrack setNumberOfLoops:]
numberOfLoops != 0
%.6f s
%ld fr (/%.f Hz)
%.6f rs
<AVAudioTime %p: %s %s %s>
/System/Library/Frameworks/AudioToolbox.framework/libAudioDSP.dylib
GetAudioDSPManager
AVAudioUnitDSPGraph.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitEffect.mm
-[AVAudioUnitEffect initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Effect) || (audioComponentDescription.componentType == kAudioUnitType_MusicEffect) || (audioComponentDescription.componentType == kAudioUnitType_Panner) || (audioComponentDescription.componentType == kAudioUnitType_RemoteEffect) || (audioComponentDescription.componentType == kAudioUnitType_RemoteMusicEffect)
v16@?0q8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioPlayerNode.mm
-[AVAudioPlayerNode scheduleBuffer:atTime:options:completionCallbackType:completionHandler:]
when == nil || when.sampleTimeValid || when.hostTimeValid
-[AVAudioPlayerNode scheduleFile:atTime:completionCallbackType:completionHandler:]
file != nil
-[AVAudioPlayerNode scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:]
stream != nil
startFrame >= 0
numberFrames > 0
-[AVAudioPlayerNode nodeTimeForPlayerTime:]
playerTime == nil || playerTime.sampleTimeValid || playerTime.hostTimeValid
-[AVAudioPlayerNode playerTimeForNodeTime:]
nodeTime == nil || nodeTime.sampleTimeValid || nodeTime.hostTimeValid
AVAudioPlayerNodeImpl.CompletionHandlerQueue
CommandQueue
StartImpl
AVAudioPlayerNode.mm
_engine->IsRunning()
player started when in a disconnected state
player did not see an IO cycle.
nearFutureTime.sampleTimeValid
when.hostTimeValid
inTimeFull.sampleTimeValid
avpln
avpln_verbose
ScheduleBuffer
_outputFormat.channelCount == buffer.format.channelCount
HandleCompletionOfCommand
completionHandler != nil
bufferFromFileInfo.has_value()
CallCompletionHandler
completionHandler
SignalEndOfRender
completionHandlerWrapperPtr && completionHandlerWrapperPtr->Block()
ResolveToPlayerSampleTime
playerTime && playerTime.sampleTimeValid
has_borealis_xpc
AVVoiceTriggerClient init
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVoiceTriggerClient.mm
-[AVVoiceTriggerClient init]
dealloc
-[AVVoiceTriggerClient dealloc]
-[AVVoiceTriggerClient callServerCrashedBlock]
-[AVVoiceTriggerClient callServerResetBlock]
handleMediaServerReset:
voiceTriggerPastDataFramesAvailableCompletion
getInputChannelInfoCompletion
voiceTriggerPastDataFramesAvailable
v24@?0Q8@"NSError"16
-[AVVoiceTriggerClient voiceTriggerPastDataFramesAvailable]
enableVoiceTriggerListening:
v16@?0@"NSError"8
-[AVVoiceTriggerClient enableVoiceTriggerListening:]
enableVoiceTriggerListening:completionBlock:
-[AVVoiceTriggerClient enableVoiceTriggerListening:completionBlock:]
Enable
Disable
enableSpeakerStateListening:completionBlock:
-[AVVoiceTriggerClient enableSpeakerStateListening:]
speakerStateActiveCompletionBlock:
speakerStateActive
v20@?0B8@"NSError"12
-[AVVoiceTriggerClient speakerStateActive]
speakerStateMutedCompletionBlock:
speakerStateMuted
-[AVVoiceTriggerClient speakerStateMuted]
hasBargeInSupportCompletionBlock:
hasBargeInSupport
-[AVVoiceTriggerClient hasBargeInSupport]
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:completionBlock:
listeningEnabledCompletionBlock:
siriClientRunningCountCompletionBlock:
com.apple.coreaudio.avfaudio.workloop(
com.apple.coreaudio.avfaudio
%s %s %s
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnit.mm
+[AVAudioUnit instantiateWithComponentDescription:options:completionHandler:]
comp != NULL
v20@?0^{OpaqueAudioComponentInstance=}8i16
AVAudioEngineConfigurationChangeNotification
com.apple.avfaudio
avae
avae_verbose
AVAudioEngine.mm
engine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioEngine.mm
AttachNode
node != nil
!IsInternalNode(node)
nil == owningEngine || GetEngine() == owningEngine
nodeimpl->HasEngineImpl()
DetachNode
!nodeimpl->HasEngineImpl()
GetIOUnit
!IsInManualRenderingMode()
GetOutputNode
_outputNode != nil
GetInputNode
_inputNode != nil
UpdateOutputNode
[_outputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_outputNode)
UpdateInputNode
[_inputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_inputNode)
UpdateIONodesForVP
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:false forceIOUnitReset:true]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:true forceIOUnitReset:true]
Connect
node1 != nil && node2 != nil
node1 != node2
[_nodes containsObject: node1] && [_nodes containsObject: node2]
ConnectMultipleOutputs
nil != sourceNode && nil != destNodes && [destNodes count] > 0
[_nodes containsObject: sourceNode]
object && [object isKindOfClass: [AVAudioConnectionPoint class]]
[_nodes containsObject: connPoint.node]
sourceNode != connPoint.node
DisconnectInput
[_nodes containsObject: node]
_graph->DisconnectInput(node, bus)
DisconnectOutput
_graph->DisconnectOutput(node, bus)
DisconnectAllInputs
_graph->DisconnectAllInputs(node)
DisconnectAllOutputs
_graph->DisconnectAllOutputs(node)
ConnectMIDI
node1 != nil && node2 != nil && node1 != node2
object && [object isKindOfClass: [AVAudioNode class]]
DisconnectMIDI
sourceNode != nil && destNode != nil
sourceNode != nil && destNodes != nil && destNodes.count > 0
_graph->DisconnectMIDI(sourceNode, destNodes)
DisconnectAllMIDIInputs
_graph->DisconnectAllMIDIInputs(node)
DisconnectAllMIDIOutputs
_graph->DisconnectAllMIDIOutputs(node)
GetInputConnectionPointForNode
node != nil && [_nodes containsObject: node]
GetOutputConnectionPointsForNode
Uninitialize
_graph->Uninitialize(outErr)
Pause
_graph->Stop(outErr)
CheckCanPerformIO
canPerformIO
q28@?0I8^{AudioBufferList=I[1{AudioBuffer=II^v}]}12^i20
CreateGraphNode
_graph->AddNode(inNode)
DestroyGraphNode
_graph->RemoveNode(inNode, outErr)
InstallTapOnNode
_graph->InstallTapOnNode(inNode, bus, bufferSize, format, tapBlock)
RemoveTapOnNode
_graph->RemoveTapOnNode(inNode, bus)
SetSequence
_graph->SetSequence(inSequence)
 node: 
 (bus: 
AVFormatIDKey
AVSampleRateKey
AVNumberOfChannelsKey
AVLinearPCMBitDepthKey
AVLinearPCMIsBigEndianKey
AVLinearPCMIsFloatKey
AVLinearPCMIsNonInterleaved
AVAudioFileTypeKey
AVEncoderQualityKey
AVEncoderQualityForVBRKey
AVEncoderBitRateStrategyKey
AVEncoderBitRateKey
AVEncoderBitRatePerChannelKey
AVEncoderBitDepthHintKey
AVSampleRateConverterAlgorithmKey
AVSampleRateConverterQualityKey
AVChannelLayoutKey
AVAudioBitRateStrategy_Constant
AVAudioBitRateStrategy_LongTermAverage
AVAudioBitRateStrategy_VariableConstrained
AVAudioBitRateStrategy_Variable
AVSampleRateConverterAlgorithm_Normal
AVSampleRateConverterAlgorithm_Mastering
AVSampleRateConverterAlgorithm_MinimumPhase
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AUInterface.mm
AddRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &inRenderCallback, sizeof(inRenderCallback))
RemoveRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &rcb, sizeof(rcb))
AUInterfaceBaseV3
comp != nullptr
AudioComponentInstanceNew(comp, &_auv2)
_auv2 != nullptr
_auv3 == nil
_auv3 != nil
nil != midiEventBlock
SetFormat
[[busArray objectAtIndexedSubscript:(NSUInteger)element] setFormat:format error:&nsErr]
SetNumberInputs
[[auv3() inputBusses] setBusCount:(NSUInteger)numberInputs error:&nsErr]
SetNumberOutputs
[[auv3() outputBusses] setBusCount:(NSUInteger)numberOutputs error:&nsErr]
SendMIDIEvent
nil != ScheduleMIDIEventBlock()
nullptr != midiBytes
AddRenderObserver
inRenderCallback.inputProc
v32@?0I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}12I20q24
AVAEInternal.h
true
false
%s: returned %s, error %@
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
%25s:%-5d required condition is false: [%s:%d:%s: (%s)]
%s:%d:%s: CarPlay API not available
%s:%d:%s: AVOutputContext API not available
%s:%d:%s: supportsMultipleBTDevices: %d
%s:%d:%s: Wireless Output Devices: %@
%s:%d:%s: AVOutputDevice %p supports BT sharing: %d
%s:%d:%s: RegisterObject: registering %p
%s:%d:%s: UnregisterObject: unregistering %p
 ASSERTION FAILED: unregistering a nonexistent object!
%s:%d:%s: CurrentRoute: %@
%s:%d:%s: PreviousRoute: %@
%s:%d:%s: RouteChangeReason: %s
%s:%d:%s: *** InitializePlugins *** %p 
%s:%d:%s: Plugin Bundle URL: %@
%s:%d:%s: initialized plugin class %@
%s:%d:%s: Unable to create the plugin bundle
%s:%d:%s: dealloc : releasing all plugins *** %p
%s:%d:%s: invalidatePlugins : invalidating all plugins *** %p
%s:%d:%s: calling invalidate on plugin instance %p
%s:%d:%s: Searching plugin path %@
%s:%d:%s: Error enumerating the remote input bundles at %@: %@
%s:%d:%s: plugin(%p) - device(%p) - id: %@
%s:%d:%s: Device(%p). Identifier: %@
%s:%d:%s: Cannot find Remote Input device %@
%s:%d:%s: findDeviceWithIdentifier: found the device %@
%s:%d:%s: Device(%p). Identifier: %@ (num devices = %d)
%s:%d:%s: self(%p) controller(%p) plugin(%p), did publish device(%p) with id(%@)
%s:%d:%s: ERROR: Received didPublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%s:%d:%s: WARNING: Not forwarding didPublish event to AVVC parent because it does not exist, or is deallocating.
%s:%d:%s: self(%p) controller(%p) plugin(%p), did UNpublish device(%p) with id(%@)
%s:%d:%s: ERROR: Received didUNpublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%s:%d:%s: WARNING: Not forwarding didUNpublish event to AVVC parent because it does not exist, or is deallocating.
%s:%d:%s: self(%p) controller(%p)
%s:%d:%s: couldn't find mock plugin
%s:%d:%s: mock plugin endpoint (%@)
%s:%d:%s: AVVCPluginRecordingEngine()
%s:%d:%s: ~AVVCPluginRecordingEngine()
%s:%d:%s: finding the first device for activation mode (%{audio:4CC}d)  : %p
%s:%d:%s: device identifier shouldn't be NULL... 
%s:%d:%s: device identifier : %@
%s:%d:%s: setHWSampleRate() streamID(%lu) sr(%.2f) upSamp(%d)
%s:%d:%s: session state (%s), rec-engine [%@], rec-engine type (%s), stream state (%s), alert state (%s)
%s:%d:%s: (self %p)startRecord : using activeDevice: %p
%s:%d:%s: #### calling startRecordingWithCompletionBlock on device (%p) ####
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING
%s:%d:%s: startedRecording: nil recording engine. Bailing
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING-PAUSED
%s:%d:%s: startRecordingWithCompletionBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: returned error(%d) : %@. Setting the audioInputBlock to nil.
%s:%d:%s: startRecordQueue:  No device found, err : %d
%s:%d:%s: AVVCPluginRecordingEngine::stopRecording: mRecordIsStopping set to true
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: doneRecording: nil recording engine. Bailing
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: stopRecording:  No device found error :%d
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Entering --->
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine: about to call stopRecordingCompletionBlock - previous stop completion block didn't happen
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine -- stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine - stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  calling doneRecording manually
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  skipping doneRecording as we are deallocating
%s:%d:%s: destroyRecordEngine: device found, err : %d
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Exiting <---
%s:%d:%s: AVVCPluginRecordingEngine::createRecordQueue : no matching device found, error : %d
%s:%d:%s: supported Formats[%d] : %@ 
%s:%d:%s: Using Format[0] : %@ 
%s:%d:%s: No Format specified.. Error
%s:%d:%s: clientRequestedSR was:%.2f, setting to %.2f
%s:%d:%s: clientRequestedSR was not specified, setting to %.2f
%s:%d:%s: AVVCPluginRecordingEngine(%p)::createRecordQueue -->
%s:%d:%s: createRecordQueue : using device %p
%s:%d:%s: createRecordQueue : setting format on active device(%p), format:%@
%s:%d:%s: Record queue state does not match queue (previously assertion failure)
%s:%d:%s: audioInputBlock (lpcm) called with frameLength : %d
%s:%d:%s: audioInputBlock (opus / speex) called with packetcount : %d
%s:%d:%s: audioInputBlock called with an unsupported audio format ID (%lu).
%s:%d:%s: audioInputBlock called
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: timeStamp : %f
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: Nil VoiceActivity NSData
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: inGain : %f
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: No Gain Value
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: No frame qualities.
%s:%d:%s: handleRecordInput: nil recording engine. Bailing
%s:%d:%s: statusChangeBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%s:%d:%s: In AVVCPluginRecordingEngine::handleRecordInput: %u frames, hostTime : %lld, sampletime : %f
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput: record internally stopped, so throwing away buffer. StreamState(%s). RecordCancelled(%d)
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput - recordState is active, but getting nil buffer
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (opus). bufferLength : %d, packetCount : %d, packetDesc.startOffset %lld, packetDesc.mVariableFramesInPacket %u, packetDesc.DataByteSize = %u
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (opus): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%s:%d:%s: Setting up client buffer
%s:%d:%s: Copying BT audio buffer, size %u
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (speex): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput - Unsupported formatID: %u
%s:%d:%s: Exiting AVVCPluginRecordingEngine::handleRecordInput
%s:%d:%s: AVVCPluginRecordingEngine::getRecordRoute : no matching device found, error : %d
%s:%d:%s: active device doesn't support remoteInputDeviceName property
%s:%d:%s: >> %s
%s:%d:%s: << %s
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine[%@]. self(%p)
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine: recordDeviceName(%@)
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine: remoteDeviceUUID(%@)
%s:%d:%s: AVVCRecordDeviceInfo initWithVoiceController: remoteDeviceCategory(%d)
%s:%d:%s: AVVCRecordDeviceInfo dealloc. self(%p)
%s:%d:%s: setSessionNotifications: setting up notifications for %s session(%p)
%s:%d:%s: removeSessionNotifications: removing all notifications for %s session(%p)
%s:%d:%s: #### hardwareConfigChanged: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
 ASSERTION FAILED: handleInterruption_v1v2: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleInterruption_v1v2: %s session (%p), %@
 ASSERTION FAILED: handleRouteChange_v1v2: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleRouteChange_v1v2: %s session (%p)
 ASSERTION FAILED: handleMediaServerDeath: called with NULL impl!
 ASSERTION FAILED: handleMediaServerReset: called with NULL impl!
%s:%d:%s: Error! handlePluginDidPublishDevice: ControllerImpl is NULL
%s:%d:%s: Error! handlePluginDidUNpublishDevice: ControllerImpl is NULL
%s:%d:%s: #### beganRecording: (success = %d status = %d streamID = %llu) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartRecording: variants
%s:%d:%s: finishedRecording -> called after AVVC object destroyed -- ignoring call and possibly leaking ControllerImpl
%s:%d:%s: finishedRecording -> called after dealloc -- ignoring call
%s:%d:%s: #### AVVoiceController: Recording finished (success = %d status = %d streamID = %llu) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopRecording:forReason:
%s:%d:%s: startpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### startpointDetected: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectStartpoint:
%s:%d:%s: interspeechPointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### interspeechPointDetected: time %.2f seconds ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectEndpoint:ofType:
%s:%d:%s: endpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### endpointDetected: time %.2f seconds ####
%s:%d:%s: #### beganPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartPlaying:successfully:
%s:%d:%s: finishedPlaying -> called after AVVC object destroyed -- ignoring call and possibly leaking ControllerImpl
%s:%d:%s: #### finishedPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopPlaying:forReason:
%s:%d:%s: Calling alert playback finished delegate. Settings { Type: %d, Mode: %d, alertEndTime: %llu }
%s:%d:%s: Calling alert playback finished delegate. Type: %d
%s:%d:%s: Notifying streamHandle(%lu) invalidated
%s:%d:%s: streamHandle(%lu) invalidated but no record delegate, or notify selector not supported
%s:%d:%s: Calling record delegate's voiceControllerWillSetAudioSessionActive. Going active? : %d
%s:%d:%s: Calling record delegate's voiceControllerDidSetAudioSessionActive. Going active? : %d
%s:%d:%s: setStopOnBargeInEnabled: barge-in previously detected -- stopping playback
%s:%d:%s: prepareRecordWithSettings should be called first before asking for number of channels
%s:%d:%s: [enforce 1 avvc] retain AVVC(%p), count-before-retain(%d)
%s:%d:%s: [enforce 1 avvc] release AVVC(%p), count-before-release(%d)
%s:%d:%s: [enforce 1 avvc] #### AVVoiceController: initWithContext: [self == %p]. with context:%{audio:4CC}d %@
%s:%d:%s: initWithContext: ControllerImpl() failed with error: %ld
%s:%d:%s: initWithContext: calling setSessionProperties
%s:%d:%s: AVVoiceController: initWithContext failure
%s:%d:%s: #### initWithContext finished [self = %p] ####
%s:%d:%s: #### AVVoiceController: prewarmAudioSession: ####
%s:%d:%s: [enforce 1 avvc] #### AVVoiceController: dealloc [self == %p] ####
%s:%d:%s: #### AVVoiceController: exiting dealloc ####
%s:%d:%s: #### AVVoiceController: releaseAudioSession: [self = %p] ####
%s:%d:%s: #### AVVoiceController: releaseAudioSession:options [self = %p] ####
%s:%d:%s: #### AVVoiceController: enableMiniDucking: %d
%s:%d:%s: #### AVVoiceController: willAcceptContext: with context:%{audio:4CC}d %@
%s:%d:%s: ### unimplemented in this platform
%s:%d:%s: #### AVVoiceController[self = %p]: setCurrentContext: with context:%{audio:4CC}d %@
%s:%d:%s: #### setCurrentContext:error finished [self = %p]####
%s:%d:%s: #### AVVoiceController[self = %p]: prepareRecordWithSettings: %@ 
%s:%d:%s: prepareRecordWithSettings failed with internal error %s
%s:%d:%s: #### prepareRecordWithSettings finished ####
%s:%d:%s: #### AVVoiceController: setAlertSoundFromURL: forType: %d ####
%s:%d:%s: setAlertSoundFromURL:forType: Illegal alertType
%s:%d:%s: call to playAlertSoundForType blocked because mediaserverd is dead
%s:%d:%s: #### AVVoiceController: playAlertSoundForType: %d [self = %p]####
%s:%d:%s: playAlertSoundForType: Session check failed: %s
%s:%d:%s: playAlertSoundForType: Illegal alertType
%s:%d:%s: #### AVVoiceController: resetEndpointer ####
%s:%d:%s: #### AVVoiceController: playRecordStartingAlertAndResetEndpointer ####
%s:%d:%s: #### AVVoiceController::playRecordStartingAlertAndResetEndpointer current Context  %@ ####
%s:%d:%s: #### AVVoiceController: startRecording [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecording:(NSError **) [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecordingAtTime:error : %d [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecordingAtTime:error [self = %p]####
%s:%d:%s: #### AVVoiceController:[self = %p] startRecordingWithSettings:error %@
%s:%d:%s: AVVoiceController: startRecordingWithSettings: Ignoring old style alert behavior
%s:%d:%s: #### AVVoiceController:[self = %p] startRecordingWithSettings:error = %d
%s:%d:%s: #### AVVoiceController: stopRecording ####
%s:%d:%s: #### AVVoiceController: preparePlaybackWithSettings %@ 
%s:%d:%s: preparePlaybackWithSettings: Can't perform this action while playback is active
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: #### AVVoiceController: preparePlaybackFromURL: %@ ####
%s:%d:%s: preparePlaybackFromURL: audio is already playing
%s:%d:%s: #### AVVoiceController: startPlaying ####
%s:%d:%s: Attempt to play audio without configuring format
%s:%d:%s: startPlaying: called while already playing -- stopping previous play
%s:%d:%s: #### AVVoiceController: stopPlaying ####
%s:%d:%s: #### AVVoiceController: setRecordDelegate: %p ####
%s:%d:%s: #### AVVoiceController: setRecordBufferDuration: %f ####
%s:%d:%s: #### AVVoiceController: setEndpointerDelegate ####
%s:%d:%s: #### setEndpointerDelegate: using %s endpointer ####
%s:%d:%s: #### AVVoiceController: setRecordEndpointMode: %d ####
%s:%d:%s: #### AVVoiceController: recordStartWaitTime: %f ####
%s:%d:%s: setPlaybackDelegate: Cannot set while playback is active
%s:%d:%s: #### AVVoiceController: setPlaybackBufferDuration: %f ####
%s:%d:%s: setPlaybackBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: isRecording: rec-engine type: %s, stream state: %s
%s:%d:%s: #### AVVoiceController: setAlertVolume: %f ####
%s:%d:%s: #### AVVoiceController: setPlaybackVolume: %f ####
%s:%d:%s: #### AVVoiceController: setMeteringEnabled: %d ####
%s:%d:%s: setStopOnEndpointEnabled: endpoint previously detected -- stopping capture
%s:%d:%s: #### AVVoiceController: currentRecordDeviceInfo. self(%p) ####
%s:%d:%s: [enforce 1 avvc] #### AVVoiceController: initWithError (V2): [self == %p]
%s:%d:%s: initWithError: Failed to create ControllerImpl or configureAlerts - error (%ld)
%s:%d:%s: #### AVVoiceController[self = %p]: setContext: activationMode(%@), deviceUID(%@)
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%s:%d:%s: #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: startRecordWithSettings: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d)
%s:%d:%s: #### AVVoiceController[self = %p]: startRecordForStream: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d,%s)
%s:%d:%s: #### AVVoiceController[self = %p]: configureAlertBehaviorForStream: streamHandle(%lu), AlertsOverride(%d,%d,%d)
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: stopRecordOnStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: stopRecordForStream: streamHandle(%lu)
%s unexpected error (%d) returned from stopRecordForStream
%s:%d:%s: #### AVVoiceController[self = %p]: getCurrentStreamState: streamHandle(%lu). State(%s)
%s:%d:%s: #### AVVoiceController[self = %p]: getRecordDeviceInfoForStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d), switchRecordMode(%d). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: deactivateAudioSessionWithOptions(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: deactivateAudioSessionForStream:(%d) withOptions(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: setContextForStream: activationMode(%@), deviceUID(%@). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: playAlert alertType(%d). overrideMode(%d)
%s:%d:%s: #### AVVoiceController[self = %p]: playAlertSoundForStream: alertType(%d) overrideMode(%d)
%s:%d:%s: playAlertSoundForStream failed with error : %d
%s:%d:%s: #### AVVoiceController[self = %p]: setRecordStatusChangeBlock
%s:%d:%s: #### AVVoiceController[self = %p]: enableSmartRoutingConsideration: streamHandle(%lu), enable : %d
%s:%d:%s: #### AVVoiceController[self = %p]: setAnnounceCallsEnabledForStream: streamHandle(%lu), enable : %d
%s:%d:%s: #### AVVoiceController[self = %p]: getInputChannelInfoForStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: setDuckOthersForStream: streamHandle(%lu), duckSettings(%@)
%s:%d:%s: about to lock %s
%s:%d:%s: about to unlock %s
%s:%d:%s: [enforce 1 avvc] before wait controller(%p), %@
%s:%d:%s: [enforce 1 avvc] after wait%s controller(%p), %@
%s:%d:%s: [enforce 1 avvc] Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously
[enforce 1 avvc] %s Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously. Controller(%p)
%s:%d:%s: [enforce 1 avvc] created gsAVVCSingleInstanceSemaphore %@
%s:%d:%s: %s : %s : start: %s end: %s duration %.2f ms
%s:%d:%s: %s : start: %s end: %s duration %.2f ms
%s:%d:%s: [enforce 1 avvc] before signal avvc(%p), %@
%s:%d:%s: [enforce 1 avvc] after signal avvc(%p), %@
%s:%d:%s: QualityDetector: Start thresh: %u Start Timeout: %u End thresh: %u  End Timeout: %u
%s:%d:%s: QualityDetector: NONE => ACTIVE
%s:%d:%s: QualityDetector: NoSpeech; End Counter %u / %u
%s:%d:%s: QualityDetector: NONE => ENDED (TIMEOUT AT START)
%s:%d:%s: QualityDetector: Active; End Counter %u / %u
%s:%d:%s: QualityDetector: Active; Watching for end point (current frame quality: %u)
%s:%d:%s: QualityDetector: ACTIVE => ENDED
%s:%d:%s: QualityDetector: ACTIVE => ENDING
%s:%d:%s: QualityDetector: Speech Ending; End Counter %u / %u
%s:%d:%s: QualityDetector: ENDING => ACTIVE
%s:%d:%s: QualityDetector: ENDING => ENDED
 ASSERTION FAILED: inPastFrameCount <= mFrameHistoryLength
%s:%d:%s: QualityDetector: Start Timeout: %u frames
%s:%d:%s: QualityDetector: Interspeech Timeout: %u frames
%s:%d:%s: QualityDetector: End Timeout: %u frames
%s:%d:%s: SpeexEndpointer init:
%s:%d:%s: SpeexEndpointer dealloc:
%s:%d:%s: SpeexEndpointer configureWithSampleRate:
%s:%d:%s: SpeexEndpointer configureWithSampleRate:andFrameRate: illegal frame rate!
%s:%d:%s: SpeexEndpointer configureWithASBD:andFrameRate
%s:%d:%s: SpeexEndpointer setEndpointMode: %d
%s:%d:%s: SpeexEndpointer setStartWaitTime: %f
%s:%d:%s: SpeexEndpointer setInterspeechWaitTime: %f
%s:%d:%s: SpeexEndpointer setEndWaitTime: %f
 ASSERTION FAILED: getStatus called before object was configured!
%s:%d:%s: SpeexEndpointer getStatus: Raw Speex qlty frame %d/%d: %.2f rnng avrg: %.2f, med: %.2f, cls: %d
%s:%d:%s: #### SpeexEndpointer: Detected start point ####
%s:%d:%s: #### SpeexEndpointer: Detected soft end point ####
%s:%d:%s: #### SpeexEndpointer: Detected hard end point ####
 PackednessIsSignificant only applies for PCM
 CAMutex::CAMutex: Could not init the mutex
 CAMutex::Lock: Could not lock the mutex
 CAMutex::Unlock: Could not unlock the mutex
 CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own
 CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)
 CAPThread::SetPriority: failed to set the fixed-priority policy, Error: 0x%X
 CAPThread::SetPriority: failed to set the precedence policy, Error: 0x%X
 CAPThread::SetTimeConstraints: thread_policy_set failed, Error: %d (%s)
 CAPThread::Start: can't start because the thread is already running
 CAPThread::Start: Thread attributes could not be created.
 CAPThread::Start: A thread could not be created in the detached state.
 CAPThread::Start: Could not create a thread.
%s:%d:%s: Trigger clean up of context(%s, %@)
%s:%d:%s: AVVCRecordingEngine():~AVVCRecordingEngine() called
%s:%d:%s: reconfigure for streamID(%lu) failed to destroy engine (%d)
%s:%d:%s: reconfigure for streamID(%lu) failed to prepareRecording (%d)
%s:%d:%s: Settings are nil, rebuilding queue
%s:%d:%s: prepareRecord: NEW FORMAT: %s
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %d
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %{audio:4CC}d
%s:%d:%s: Formats differ, rebuilding queue
%s:%d:%s: prepareRecord: CURRENT FORMAT: %s
%s:%d:%s: destroying engine because of record error: %d
%s:%d:%s: Cached session pointer (%p) for engine(%d, %p)
%s:%d:%s: Cached session manager pointer (%p) for engine(%d, %p)
%s:%d:%s: AudioQueueGetProperty kAudioConverterSampleRateConverterQuality failed: %d
%s:%d:%s: AudioQueueGetProperty kAudioConverterPropertyBitDepthHint failed: %d
%s:%d:%s: AudioQueueGetProperty property size of kAudioQueueProperty_ChannelLayout failed: %d OR property size is 0
%s:%d:%s: AudioQueueGetProperty returned %d for kAudioQueueProperty_ChannelLayout property size
%s:%d:%s: AudioQueueGetProperty kAudioQueueProperty_ChannelLayout failed: %d
%s:%d:%s: AudioQueueGetProperty returned (%p) for kAudioQueueProperty_ChannelLayout bytes
%s:%d:%s: setStreamState (%s => %s)
%s:%d:%s: setRecordErrorStatus: %ld
%s:%d:%s: setRecordBufferDuration: Attempting to setRecordBufferDuration while record is active. Stream State(%s)
%s:%d:%s: setRecordBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: setRecordBufferDuration: rebuilding queue
%s:%d:%s: setRecordBufferDuration: Failed at prepareRecording (reconfig) : %d
%s:%d:%s: setRecordBufferDuration: duration now %.3f
%s:%d:%s: getRecordBufferDuration: choice 1 mRecordBasePacketsPerSecond (%lu)
%s:%d:%s: getRecordBufferDuration: choice 2 mRecordBasePacketsPerSecond (%lu)
%s:%d:%s: getRecordBufferDuration: returning %.3f seconds
%s:%d:%s: getPeakPowerForChannel on stream(%llu): returning %f for channel %d
%s:%d:%s: getAveragePowerForChannel on stream(%llu): returning %f for channel %d
%s:%d:%s: AVVCRecordingEngine::cacheRecordRoute : %@
%s:%d:%s: setStartRecordCompletionAndAudioCallbackBlocks: startCompletionBlock(%p). audioCallbackBlock(%p)
%s:%d:%s: setStopRecordCompletionBlock: stopCompletionBlock(%p).
%s:%d:%s: setDidStopDelegateCompletionBlock: didStopCompletionBlock(%p).
%s:%d:%s: calling (v2) voiceControllerLPCMAudioCallback:forStream:buffer:
%s:%d:%s: calling (v2) voiceControllerAudioCallback:forStream:buffer:
%s:%d:%s: Calling audioCallbackBlock for streamID(%lu) with mAudioDataByteSize: %u
%s:%d:%s: calling lpcmRecordBufferReceived:buffer
%s:%d:%s: calling voiceControllerRecordBufferAvailable:buffer
%s:%d:%s: myBuffer->mAudioData : %p, myBuffer->mAudioDataByteSize : %d
%s:%d:%s: Ignoring action, since streamState is already %s
 ca_verify_noerr: [%s, %d]
%s:%d:%s: _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing session manager(%p) audioSession(%p) for context(%s, %@)
%s:%d:%s: _wqCreateAuxSessionAndManagerForDeviceUID: setActivationContext returned error(%d)
%s:%d:%s: _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing sessionManager(%p)
%s:%d:%s: Created aux session (%p) and session manager (%p) and setup onetime settings for context(%s, %@)
%s:%d:%s: Created primary session manager (%p) and setup onetime settings for context(%s, %@)
%s:%d:%s: _wqSessionForContext: activationDeviceUID must be specified for this mode
%s:%d:%s: First time primary session (%p) retrieved. Context(%s, %@)
%s:%d:%s: retrieved session (%p) and sessionManager (%p) for context(%s, %@)
%s:%d:%s: Clean up context(%s, %@), about to release session(%p) and manager(%p)
%s:%d:%s: Unexpected error cleaning up context: %@
%s:%d:%s: Unexpected missing session when cleaning up context
%s:%d:%s: Can't cleanup because devID is missing in context(%s, %@)
%s:%d:%s: Nothing to clean up for context(%s, %@)
%s:%d:%s: Releasing primary session manager (%p)
%s:%d:%s: ERROR: subscope bits are set in scope: 0x%lx
%s:%d:%s: ---> this = %p
%s:%d:%s: <---
%s:%d:%s: Track's sequence was NULL
%s:%d:%s: Underlying track already destroyed
%s:%d:%s: start -> %.2f [end %.2f]
%s:%d:%s: end -> %.2f [start %.2f]
%s:%d:%s: %sabling looping [%.2f - %.2f]
%25s:%-5d [%s:%d:%s: (%s): error %d
%s:%d:%s: RealtimeMessenger: trying to enqueue duplicate invocation on message %p
%25s:%-5d Error fetching from ring buffer, this = %p, err = %d
%s:%d:%s: AVVCRecordingEngineMap::AVVCRecordingEngineMap() Created new Engine Map
%s:%d:%s: AVVCRecordingEngineMap::~AVVCRecordingEngineMap() Destroyed Engine Map
%s:%d:%s: No recording engine found for stream(%lu)
%s:%d:%s: No matching engine found for nil deviceUUID
%s:%d:%s: Iterating through EngineMap. AVVCStreamHandle(%lu). AVVCRecordEngine[%@]. DeviceUID(%@). EngineType(%s)
%s:%d:%s: Found matching engine of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: No matching plugin engine found for deviceUUID: %@
%s:%d:%s: Added engine[%@] for stream(%llu) to the map of size %ld
%s:%d:%s: Removing engine[%@] for stream(%llu) from the map
%s:%d:%s: Engine for streamID(%llu) not found
%s:%d:%s: Empty Engine Map
%s:%d:%s: Engine[%@] Type:(%s) stream(%llu)
%25s:%-5d AVAudioEngine: left running idle for %.f s
%25s:%-5d AVAudioEngine (auto shutdown mode): left running idle for %.f s, stopping!
%25s:%-5d AVAudioEngine (auto shutdown mode): starting IO dynamically
%25s:%-5d AVAudioEngine (auto shutdown mode): could not dynamically start the audio hardware, err = %s
%25s:%-5d graph@%p: couldn't initialize node@%p {%s}, error %d
%25s:%-5d Can't retrieve source node to play sequence because there is no output node!
%25s:%-5d manual rendering mode, setting output type = external speakers
%25s:%-5d setting output type = headphones
%25s:%-5d setting output type = built-in speakers
%25s:%-5d setting output type = external speakers
%25s:%-5d multiple outputs active, setting output type = external speakers
%25s:%-5d Error creating XPC connection to %@
%25s:%-5d %@
%25s:%-5d Interruption Handler: connection got interrupted
%25s:%-5d Invalidation Handler: client exited
%25s:%-5d starting sequence on client side
%25s:%-5d Issuing sandbox %s for path %s
%25s:%-5d failed to extend the service's sandbox
%25s:%-5d result data %@ output %li input %li sample rate %f
%25s:%-5d finishing sequence on client side
%s:%d:%s: AVVCMetricsManager: createSharedManager: referenceCount after incrementing = %llu
%s:%d:%s: AVVCMetricsManager: destroySharedManager : referenceCount after decrementing = %llu
%s:%d:%s: AVVCMetricsManager: sharedInstance is nil !!!!
%s:%d:%s: AVVCMetricsManager: dealloc
%s:%d:%s: Measuring Elapsed Time for %@ : %f ms
%s:%d:%s: Logging PROFILE METRIC : %@
%s:%d:%s: configure: session not configured -- calling setSessionProperties
%s:%d:%s: Overwriting an already-deferred context
%s:%d:%s: setCurrentContext:error: record is active -- deferring the context change
%s:%d:%s: setActivationContext in setCurrentContext failed! %d
%s:%d:%s: createRecordingEngine in setCurrentContext failed! %d
%s:%d:%s: getCurrentRecordDeviceInfo: Current Recording Engine is nil!
%s:%d:%s: getCurrentRecordDeviceInfo: mCurrentRecordDeviceInfo already exists. Deleting old and creating new.
%s:%d:%s: recordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%s:%d:%s: getCurrentRecordSettings: Error, current recording engine is nil!
%s:%d:%s: enableMetering: Current recording engine is nil!
%s:%d:%s: updateMeters: Error, current recording engine is nil!
%s:%d:%s: getPeakPowerForChannel: Error, current recording engine is nil!
%s:%d:%s: isMeteringEnabled: Error, current recording engine is nil!
%s:%d:%s: prepareRecord: Can't perform this action while record is starting or active
%s:%d:%s: prepareRecord: home/uibp/btbp/vehb button activation : after rechecking which engine to use [%@]
%s:%d:%s: createRecordingEngine in prepareRecord_v1 failed : %d
%s:%d:%s: prepareRecord: recording engine is not selected, %{audio:4CC}d
%s:%d:%s: startListen: Current recording engine is nil! Bailing!
%s:%d:%s: SECOND PASS-Start Record Delta %f ms
%s:%d:%s: Attempt to start recording without calling prepareRecordWithSettings:
%s:%d:%s: startRecord: already starting or active -- no-op
%s:%d:%s: startRecord: failed to play record-start alert. status = %d
%s:%d:%s: startRecord: returning failed record status %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue: output queue format:
%s:%d:%s: %s
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %d
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %{audio:4CC}d
%s:%d:%s: createPlaybackQueue: bufferByteSize %u
packetsPerSecond %g
packetSizeUpperBound %u
%s:%d:%s: createPlaybackQueue: bufferByteSize adjusted to %u
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %d
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %{audio:4CC}d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: enqueued buffer %p mNumPlayBuffersEnqueued %d
%s:%d:%s: preparePlaybackQueue: mNumPlayBuffersEnqueued %d  numFramesPrepared %u  sr %g
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %d
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: numFramesPrepared %u  mNumPlayBuffersEnqueued %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %{audio:4CC}d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %{audio:4CC}d
%s:%d:%s: setupAudioFile: audio format from file:
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %d
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %{audio:4CC}d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %{audio:4CC}d
%s:%d:%s: handleAudioPlaybackStream: %d buffers now in queue.  Calling client.
%s:%d:%s: handleAudioPlaybackStream: Client filled buffer %p, size %d bytes
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: >>handleEncodedFileRead requesting: pkt pos %qd, %d packets, %d bytes. bytes capacity: %d  buffer: %p
%s:%d:%s: <<handleEncodedFileRead got %d packets, %d bytes, status %d
%s:%d:%s: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters: trim leading: %d, trim trailing: %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: getRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%s:%d:%s: setRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%s:%d:%s: getStartRecordTime: Error, current recording engine is nil!
%s:%d:%s: setStartRecordTime: Error, current recording engine is nil!
%s:%d:%s: setStartRecordTime: %llu
%s:%d:%s: configureAlertOverrides: Session is active. configureAlertModeFromModeAndEngine now. Current recording engine [%@], activation mode (%@)
%s:%d:%s: unlocker about to unlock %s
 ASSERTION FAILED: Unlocker attempted to unlock a mutex not owned by the current thread!
%s:%d:%s: unlocker about to relock %s
%25s:%-5d Error setting manual rendering mode input PCM format on input node! %s
%s:%d:%s: prepareRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: ! DEPRECATED ! prepareRecordForStream: Found engine[%@] of type(%s) for streamID(%lu), with activation mode(%@)
%s:%d:%s: prepareRecordForStream: Failed to setRecordBufferDuration
%s:%d:%s: prepareRecordForStream: Error in prepareRecording: %d
%s:%d:%s: prepareRecordForStream: Error in enableMetering: %d
%s:%d:%s: prepareRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: prepareRecordForStream: Found engine[%@] of type(%s) for streamID(%lu), with activation mode(%@)
%s:%d:%s: prepareRecordForStream: Failed to setRecordBufferDuration : %d
%s:%d:%s: startRecordForStream streamID(%lu)
%s:%d:%s: startRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: startRecordForStream: Attempt to start stream(%ld) without calling prepare.
%s:%d:%s: startRecordForStream: Attempt to start stream(%ld) while stream is already %s. No-op.
%s:%d:%s: ERROR in startRecordForStream, failed at playAlert: %d
%s:%d:%s: startRecordForStream: Error in startRecording for stream(%lu): %d
%s:%d:%s: startRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: session (%p) and session mananger (%p) used for engine (%p) with context(%s, %@)
%s:%d:%s: startRecordForStream: Skipping alert playback and continuing to startRecord
%s:%d:%s: stopRecordOnStream streamID(%lu)
%s:%d:%s: stopRecordOnStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: stopRecordOnStream: Attempt to stop on an %s stream.
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is already %s. No-op.
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is about to start. Observe this case. NotifyStartBeforeStop? Not doing anything here at the moment.
%s:%d:%s: stopRecordOnStream: Error stopping record engine: %d
%s:%d:%s: stopRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: stopRecordForStream: Attempt to stop on an %s stream.
%s:%d:%s: stopRecord: an error : %d  occurred while recording and we need to synthesize doneRecording
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is about to start. NotifyStartBeforeStop
%s:%d:%s: stopRecord: record state == kRecordStarting but object being destroyed -- just stop queue
%s:%d:%s: stopRecord: record state == kRecordStarting -- we will need to send a start notify prior to stop
%s:%d:%s: stopRecord: record was just starting -- calling doneRecording ourselves -- watch this case
%s:%d:%s: getCurrentStreamState: Cannot find recording engine for streamID(%lu).
%s:%d:%s: getRecordBufferDurationForStream: Cannot find recording engine for streamID(%lu).
%s:%d:%s: configureAlertBehaviorForStream streamID(%lu)
%s:%d:%s: activateAudioSessionForStream ERROR: Cannot find recording engine for streamID(%lu). Bailing.
%s:%d:%s: About to activate audio session for stream(%lu). Current context: %@
%s:%d:%s: Announce option set for %s activation mode
%s:%d:%s: activateAudioSessionForStream for stream(%lu). isPrewarm(%d). CurrentState(%s).
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionActivationContext: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionBufferSize: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed checkSession at setAudioSessionActive. SessionState(%s). OSStatus(%d).
%s:%d:%s: deactivateAudioSessionWithOptions called on platform without AudioSession. No-op.
%s:%d:%s: ERROR: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: setContextForStream: Error! Incoming engine with streamID(%llu) and activation mode (%d) is different from engine that was used to activate the session, streamID(%llu) amd activation mode (%@)
%s:%d:%s: setContextForStream: Announce option set for %s activation mode
%s:%d:%s: setContextForStream ERROR: Failed at setSessionActivationContext: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%s:%d:%s: setContextForStream: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%s:%d:%s: setContextForStream : Session re-activation failed with error : %d
%s:%d:%s: setContextForStream: session re-activated -- calling getSessionProperties
%s:%d:%s: playAlertWithCompletion: called when session inactive--do nothing and return error
%s:%d:%s: playAlertWithCompletion: Illegal alertType
%s:%d:%s: getRecordDeviceInfoForStream: Nil recording engine for streamID(%llu)
%s:%d:%s: StreamID(%llu). RecordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%s:%d:%s: getRecordSettingsForStream: Nil recording engine
%s:%d:%s: isMeteringEnabledForStream_v2: Nil recording engine
%s:%d:%s: getRecordSettingsForStream: Error updating meter levels: %d
%s:%d:%s: playAlertWithOverride: called when session inactive--do nothing and return error
%s:%d:%s: Current Playback Route %@
%s:%d:%s: playAlertWithOverride: calling AudioServicesPlaySystemSoundWithOptions with sound ID %d
%s:%d:%s: playAlertWithOverride: Finished playing the alert beep
%s:%d:%s: setAnnounceCallsEnabledForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: setDuckOthersForStream_v2: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: session state(streamID %d) => %s
%s:%d:%s: setStartAlertMode: %s
%s:%d:%s: alert queue state => %s
%s:%d:%s: setStopAlertMode: %s
%s:%d:%s: setStopWithErrorAlertMode: %s
%s:%d:%s: ---> self = %p
%25s:%-5d Unable to start playing the note %d
%25s:%-5d Unable to stop playing the note %d
%25s:%-5d Unable to send midi event status(%d), channel(%d), param1(%d), param2(%d)
%25s:%-5d format has zero bytes per frame
%25s:%-5d buffer byte capacity cannot be represented by an uint32_t
%25s:%-5d the number of buffers is 0
%25s:%-5d the number of buffers (%u) does not match the format's number of channel streams (%u)
%25s:%-5d mBuffers[0].mDataByteSize (%u) should be non-zero
%25s:%-5d mBuffers[%u].mDataByteSize (%u) does not match the previous mBuffers[%u].mDataByteSize (%u)
%25s:%-5d mBuffers[%d].mNumberChannels (%u) does not match the format's number of interleaved channels (%u)
%25s:%-5d mBuffers[%u].mData is null
%s:%d:%s: AudioQueueRecordInputCallback called 
%s:%d:%s: AudioQueueRecordPropertyListenerProc called 
 ASSERTION FAILED: Rec AQ listener proc called with NULL impl!
%s:%d:%s: AudioQueueRecordPropertyListenerProc: AVVoiceController[self = %p] ControllerImpl(%p) Engine[%@] Queue(%p) Property(%d)
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %d
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %{audio:4CC}d
%s:%d:%s: Error getting input hardware sample rate
%s:%d:%s: clientRequestedSR was:%.2f, setting to 16000.00
%s:%d:%s: clientRequestedSR was:%.2f
%s:%d:%s: clientRequestedSR was not specified, setting to 16000.00
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %d
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %{audio:4CC}d
%s:%d:%s: Record engine state does not match queue (previously assertion failure)
%s:%d:%s: Record Queue Format: %s
%s:%d:%s: Creating queue with flags 0x%x. %s runloops
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %{audio:4CC}d
%s:%d:%s: FAILED createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %{audio:4CC}d
%s:%d:%s: AQGetProperty - kAudioQueueDeviceProperty_NumberChannels returned : %u
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %{audio:4CC}d
%s:%d:%s: createRecordQueue: createAudioConverter error: %d. Destroying record queue.
%s:%d:%s: AudioConverter is not created.. reason: requested channels is 1 or requested interleaved audio or non-lpcm is requested
%s:%d:%s: FrameCapacity: %d. Buffer duration: %f s
%s:%d:%s: createRecordQueue: creating %u queue buffers %u bytes each
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: Creating AVAudioPCMBuffer with frameCapacity: %d. Buffer duration: %f s
%s:%d:%s: Unexpected Format found.. 
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %{audio:4CC}d
%s:%d:%s: createAudioConverter: INITIAL AUDIOCONVERTER OUTPUT FORMAT:
%s:%d:%s: inASBD : %s
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %{audio:4CC}d
%s:%d:%s: createAudioConverter: initial frames per buffer = dur %.2f * sr %.2f = %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: corrupted values??? framesPerBuffer = %u, mRecordBufferDuration = %f
 ASSERTION FAILURE: mFramesPerPacket cannot be zero!
%s:%d:%s: createAudioConverter: setting audio converter format to %u frames per packet
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: %u atomic blocks per second
%s:%d:%s: kAudioConverterCurrentOutputStreamDescription ASBD's are different !! 
%s:%d:%s: createAudioConverter: encoded audio needs minimum of %u bytes per output buffer
%s:%d:%s: createAudioConverter: AudioConverterGetProperty(kAudioConverterPropertyMinimumOutputBufferSize) returned status %d
%s:%d:%s: createAudioConverter: final framesPerBuffer: %u
%s:%d:%s: createAudioConverter: mConvertPacketCount: %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: outputSizePerPacket: %u
%s:%d:%s: createAudioConverter: mConvertAudioCapacity %u bytes
%s:%d:%s: FINAL RECORD FORMAT:
%s:%d:%s: AVVC - Cannot use DSP Graph. 
%s:%d:%s: prepareRecord: retrieving voice trigger info
%s:%d:%s: prepareRecord: AudioQueueGetProperty(BorealisTriggerInfo) returned '%s'
%s:%d:%s: Device is built in device (%@)- update channel count
%s:%d:%s: AudioQueue startRecording: record state already started or stopping -- no-op
 ASSERTION FAILED: some buffers already enqueued!
%s:%d:%s: startRecordQueue: enqueing %d buffers
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: #### Starting record queue immediately ####
%s:%d:%s: #### Starting record queue at time %llu ####
%s:%d:%s: AVVC starting record queue%s at time (%s) %lld (hosttime)
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: stopRecordQueue: mRecordIsStopping set to true
%s:%d:%s: stopRecordQueue: AudioQueueStop%s err(%s)
%s:%d:%s: Calling destroyRecordEngine
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to true
%s:%d:%s: destroyRecordEngine: about to call AudioQueueStop(..., true)
%s:%d:%s: AVVC stopped record queue%s (%d)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine:  calling doneRecording by hand
%s:%d:%s: destroyRecordEngine:  skipping doneRecording call because we are deallocating
 ASSERTION FAILED: queue was running when destroyed but not asked to stop
%s:%d:%s: destroyRecordEngine: about to call AudioQueueDispose(..., true)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to false
%s:%d:%s: destroyRecordEngine: about to destroy audio converter
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %{audio:4CC}d
%s:%d:%s: Deleting old DSPGraph...
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %{audio:4CC}d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %{audio:4CC}d
%s:%d:%s: AVVCAudioQueueRecordingEngine: Record queue does not exist to enable metering. Caching, and will enable during prepare
%s:%d:%s: AVVCAudioQueueRecordingEngine: Enable Metering?: %d
%s:%d:%s: AVVCAudioQueueRecordingEngine::updateMeterLevels: not fetching meter levels because one of them is untrue! mMeteringEnabled(%d), mRecordQueue(%d), mRecordMeters(%d)
%s:%d:%s: AVVCAudioQueueRecordingEngine::updateMeterLevels: Error! In fetching meter levels. Sending 'no signal'. Error(%d)
%s:%d:%s: nChannel:%d, startChannel:%d, mClientAudioBufferList->mBuffers[nChannel+startChannel].mData : %p
%s:%d:%s: AudioConverterConvertComplexBuffer failed with error : %d
%s:%d:%s: handleRecordAQPropertyChange: queue already destroyed -- noop
%s:%d:%s: handleRecordQueuePropertyListener (%p): Stream State: %s. AQ Running: %d
%s:%d:%s: Record Listener: RUNNING
%s:%d:%s: Record Listener: RUNNING-PAUSED
%s:%d:%s: Record Listener: STOPPED
%s:%d:%s: Record Listener: Converter error: %s
%s:%d:%s: (%p) - First callback from AQ -  inStartTime: ht %lld st %lld, Now : ht %lld, tempRecordStartTime : %lld. AQ difference: %0.6f ms
%s:%d:%s: handleRecordAQInput: sample time: %f, host time %llu, %llu frames (%d bytes), %d buffers enqueued
%s:%d:%s: handleRecordAQInput: throwing away zero-length buffer
%s:%d:%s: handleRecordAQInput: record internally stopped, so throwing away buffer
%s:%d:%s: handleRecordAQInput: AVAudioEngine renderOffline returned SUCCESS
%s:%d:%s: handleRecordAQInput: Error in AVAudioEngine renderOffline : %@
%s:%d:%s: handleRecordAQInput: encoder input: packetsAvailable: %u
%s:%d:%s: handleRecordAQInput: encoder input buffer %p: %u bytes, %u packets
%s:%d:%s: handleRecordAQInput: handing to converter: encoder output buffer: %u bytes, ioOutputDataPackets = %u
%s:%d:%s: handleRecordAQInput: err %s, got from converter %u encoded packets, %u bytes.  totalOutputByteSize = %u
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %{audio:4CC}d
%s:%d:%s: handleRecordAQInput: sending %u bytes of encoded data (addr %p) to client with %u packet descs @time %llu
%s:%d:%s: Re-enqueuing buffer %p (data ptr %p), size %u
 ASSERTION FAILED: AQ enqueue error while actively recording
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: Exiting handleRecordAQInput (%d buffers enqueued)
%s:%d:%s: setSessionIsRecordingFlag: Failed at enableSiriListeningMode(%u) with error: %d
%s:%d:%s: doneRecording: resetting record queue
%s:%d:%s: UpdateRecordDeviceOnQueue : AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice) - %@
%s:%d:%s: UpdateRecordDeviceOnQueue: AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice - %d)
%s:%d:%s: AVVCAudioQueueRecordingEngine::getRecordRoute : Cached record route is nil!
 ChangeNumberChannels only works for uncompressed formats
%s:%d:%s: RecordEncoderInputDataProc: ENTRY: *ioNumberDataPackets passed in: %u, packets remaining: %u, bytes already consumed: %u
%s:%d:%s: RecordEncoderInputDataProc: End of stream -- handing back zero size buffer
%s:%d:%s: RecordEncoderInputDataProc: Handing back ioData buffer %p of size %u
 ASSERTION FAILED: packetsRead <= packetsAvailable!
%s:%d:%s: RecordEncoderInputDataProc: EXIT: *ioNumberDataPackets passed back out: %u, status: %s
Could not load AXSpeechImplementation: %@
%s:%d:%s: setDuckOthersOption: %d. session state => %s
%s:%d:%s: Error (prev Assertion Failure): Calling setDuckOthersOption on an unconfigured session
%s:%d:%s: setDuckOthersOption: done : error : %d
%s:%d:%s: Resetting miniducking
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: iMessage -- setting P&R category, clearing preferred input, etc.
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %{audio:4CC}d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode carplaySupportsMixableSiri: %d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: category, mode and options are the same..
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: (%ld) mode. Options to set: %ld
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %{audio:4CC}d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: forcing %.2f audio for car audio
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: SR changes from %f to %f
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: SR remains at %f
%s:%d:%s: audioSessionForStreamID(%d) couldn't find engine, returning nil
%s:%d:%s: ASSERTION FAILED: calling setSessionProperties on a configured session. Crashing process!.
%s:%d:%s: setSessionProperties: done
%s:%d:%s: QueueRunLoop started
%s:%d:%s: Failed to start queue's run loop thread
%s:%d:%s: Profiling AVVC NOW.
%s:%d:%s: Setting duck-others AudioSession option for CarPlay
%s:%d:%s: ControllerImpl::Entering Dealloc
%s:%d:%s: QueueRunLoop stopped
%s:%d:%s: ControllerImpl::Exiting Dealloc
%s:%d:%s: waiting for any in-flight AudioQueue property change message on run loop...
%s:%d:%s: CallbackBarrier: 9 second timeout!
%s:%d:%s: received all AudioQueue property change messages on run loop.
%s:%d:%s: setNoResumeOnDeactivate(TRUE): will not notify others on deactivation
%s:%d:%s: setNoResumeOnDeactivate(FALSE): will notify others on deactivation
%s:%d:%s: setActivationMode: voice activation
%s:%d:%s: setActivationMode: post-voice activation
%s:%d:%s: setActivationMode: iMessage nudge
%s:%d:%s: setActivationMode: iMessage gesture to head
%s:%d:%s: setActivationMode: ATVRemoteSiri
%s:%d:%s: setActivationMode: standard value (%s)
%s:%d:%s: setActivationMode: Cannot revert from mode %s to mode %s while audio session is active
%s:%d:%s: setActivationModeAndSessionHWControlFlagsAndOptions: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%s:%d:%s: setActivationMode: will not take control of hardware for appletv upon activation
%s:%d:%s: setActivationMode: will not take control of hardware upon activation for AirPlay output
%s:%d:%s: setActivationMode: setting volume required hardware control flag for 'voic' activation mode (ouput is not Airplay)
%s:%d:%s: ERROR: setActivationMode : Failed at setAudioHardwareControlFlags: %s
%s:%d:%s: setActivationMode: (hdvc / btdt / cpvc / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%s:%d:%s: setActivationMode: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%s:%d:%s: setActivationMode: enabling all 4 hw control flags
%s:%d:%s: ERROR: Failed at setAudioHardwareControlFlags: %s
%s:%d:%s: setActivationMode: Mode already set to %s. No change in AudioSession flags or options
%s:%d:%s: getDeviceUIDForHomeOrBluetoothButtonActivation : %d, siriRemoteID(%@)
%s:%d:%s: handlePluginDidPublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%s:%d:%s: handlePluginDidUnpublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%s:%d:%s: Context is nil. can't decide what recording engine need to be created
%s:%d:%s: switching to %{audio:4CC}d mode - keeping the same recording engine [%@]
%s:%d:%s: ** !!! Invalid engine type creation !!! 
%s:%d:%s: current recording engine - %@. type: %s
%s:%d:%s: setActivationContext setting audio session activation context to: %@
%s:%d:%s: setActivationContext: HACK: ignore switch away from RemoteSiri
%s:%d:%s: setActivationContext: 'live' switch out of VoiceActivated -- reset session properties
%s:%d:%s: setActivationContext: switching in/out of CarAudio -- reset session properties
%s:%d:%s: setActivationContext: switching out of iMessage -- reset session properties
%s:%d:%s: ERROR: setActivationContext: AVAudioSession setActivationContext err %s, session id:0x%x
%s:%d:%s: setActivationContext: done setting audio session activation context
%s:%d:%s: setActivationContext: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %d
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %{audio:4CC}d
%s:%d:%s: setActivationContext: session re-activated -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is active and mode changed -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is inactive -- route change notification or setSessionActive should generate a call to getSessionProperties
%s:%d:%s: getRecordAndPlaybackRoutes: Nil recordingEngine!
%s:%d:%s: getRecordAndPlaybackRoutes: Nil currentRoute!
%s:%d:%s: getRecordAndPlaybackRoutes: Nil port type!
%s:%d:%s: getRecordAndPlaybackRoutes: AQ engine couldnt find routes since VSPD is not present!
%s:%d:%s: getRecordAndPlaybackRoutes: New Record Route %@
%s:%d:%s: getRecordAndPlaybackRoutes: New Playback Route: %@
%s:%d:%s: getRecordAndPlaybackRoutes: Nil route returned!
%s:%d:%s: getRecordAndPlaybackRoutes: No routes returned!
%s:%d:%s: %s: audio session is inactive or had been interrupted
%s:%d:%s: %s: rebuilding alert queue
%s:%d:%s: %s: calling prepare instead of create record queue
%s:%d:%s: %s - setSessionActive(false): session state already %s -- forcing deactivation
%s:%d:%s: deactivate session (%p) (session mananger (%p))
%s:%d:%s: ERROR: %s setActive:FALSE withOptions: err %s
%s:%d:%s: #### AVVoiceController: %s - error ####
%s:%d:%s: #### AVVoiceController: %s - error AVAudioSessionErrorCodeMediaServicesFailed ####
%s:%d:%s: setSessionActive(false): Deactivating session due to error: %d
%s:%d:%s: ERROR: setSessionActive: setActive: FALSE - err = %s, session id:0x%x
%s:%d:%s: setSessionActive: We have to wait for the session to be (re-)initialized
%s:%d:%s: setSessionActive: (re-)init done!
%s:%d:%s: setSessionActive: waiting...
%s:%d:%s: ERROR: setSessionActive: Timed out waiting for mediaserverd err %d
%s:%d:%s: #### AVVoiceController: Activating session ####
%s:%d:%s: setSessionActive: setActive: TRUE for prewarming did not succeed
%s:%d:%s: setSessionActive: setActive: TRUE for prewarming did not succeed and returned err: %d
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE for prewarming err %d
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE for prewarming err %{audio:4CC}d
%s:%d:%s: setSessionActive: Activating : session options : %d
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE - err = %s, session id:0x%x
%s:%d:%s: setSessionActive(true): AVAudioSession:setActive has returned
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested - returned error : %d
%s:%d:%s: setSessionActive(true): Route change when we went active: %s -- getting properties
%s:%d:%s: #### AVVoiceController: Deactivating session with notify ####
%s:%d:%s: setSessionActive(false): stopping playback queue
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %d
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): destroying record queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): in process of being destroyed -- kill the alert queue
%s:%d:%s: setSessionActive(false): resetting alert queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): alert state %s -- deactivating session asynchronously (NOT HERE) check alertFinished
%s:%d:%s: setSessionActive(true): session state already %s -- no-op
%s:%d:%s: getSessionProperties: unexpected 0.0 value for output latency
%s:%d:%s: getSessionProperties: working around bad input latency value for now
%s:%d:%s: getSessionProperties: input HW latency: %g output HW latency: %g
%s:%d:%s: getSessionProperties: input HW sampling rate %lf
%s:%d:%s: getSessionProperties: plugin mode - resetting to default HW sampling rate %lf
%s:%d:%s: getSessionProperties: Error getting input hardware sample rate
%s:%d:%s: getSessionProperties: Done.  Input HW sampling rate set to %lf - error (%d)
%s:%d:%s: setupEndpointer: configuring SR and wait times
%s:%d:%s: getRecordErrorStatus: Current recording engine is nil!
%s:%d:%s: Error! prepareRecordQueue: Nil recording engine! Bailing.
%s:%d:%s: calculateRecordStartTime: Error, current recording engine is nil!
%s:%d:%s: WARNING: startRecordingAtTime:error was used without 'silent' start alert
%s:%d:%s: calculateRecordStartTime: queue plus HW delay time: %f seconds
%s:%d:%s: calculateRecordStartTime: host time for start of record: %.3f seconds
%s:%d:%s: this is %lld ticks beyond alert end (%.6f seconds in the future)
%s:%d:%s: configureAlertModeFromModeAndEngine: Nil recording engine. Abandon ship!
%s:%d:%s: configureAlertModeFromModeAndEngine: Wired headset output - disable ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: record start time was set -- check for ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: ZLL query - back frames: %u
%s:%d:%s: configureAlertModeFromModeAndEngine: CarPlay supports ZLL. recordStartTime : %llu
%s:%d:%s: ZLL query result %d, backFramesAvailable: %u. Clearing start record time
%s:%d:%s: configureAlertModeFromModeAndEngine: record start time not set
%s:%d:%s: configureAlertModeFromModeAndEngine: HomeButtonPress/UIButtonPress
%s:%d:%s: configureAlertModeFromModeAndEngine: %s
%s:%d:%s: configureAlertModeFromModeAndEngine: no vibrator support and no ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: Built-In/BT/CarPlay Voice Activation
%s:%d:%s: configureAlertModeFromModeAndEngine: VoiceTriggerTraining
%s:%d:%s: configureAlertModeFromModeAndEngine: iMessage
%s:%d:%s: configureAlertModeFromModeAndEngine: default
%s:%d:%s: configureAlertModeFromModeAndEngine: [final alert modes, overrides] : Start[%s, %s], Stop[%s, %s], StopWError[%s, %s])
%s:%d:%s: Stop record when stream state is %s
%s:%d:%s: stopRecord: already stopping or inactive -- no-op
%s:%d:%s: stopRecord: stopping queue at time %llu
%s:%d:%s: !!!! stopRecord: Recording engine is null -- this should not happen
%s:%d:%s: stopRecord: Error stopping record engine: %d
%s:%d:%s: waitForAllStopRecordCompletion_v1v2: wait for all didStops to be delivered to the client
%s:%d:%s: Engine Map does not exist
%s:%d:%s: Error! startedRecording: Nil recording engine! Bailing.
%s:%d:%s: startedRecording: calling startRecordCompletionBlock. Error: %@
%s:%d:%s: performSelectorOnMainThread: beganRecording:
%s:%d:%s: calling synchronously: beganRecording:
%s:%d:%s: Error! doneRecording: Nil recording engine! Bailing.
%s:%d:%s: doneRecording: resetting mRecordIsStopping and mRecordIsPrimed
%s:%d:%s: doneRecording: calling startRecordCompletionBlock (notify start before stop). Error: %@
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls performSelectorOnMainThread: beganRecording:
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls beganRecording: synchronously
%s:%d:%s: doneRecording: calling stopRecordCompletionBlock. Error: %@
%s:%d:%s: doneRecording: calling recordStatusChangeBlock (unexpected didStop). Error: %@
%s:%d:%s: performSelectorOnMainThread: finishedRecording
%s:%d:%s: calling finishedRecording synchronously
%s:%d:%s: playAlert: alertType = %d, primeFirst=true
%s:%d:%s: playAlert: using SSS to play haptic (or silence)
%s:%d:%s: playAlert: alert %d already in progress -- stop it now
%s:%d:%s: playAlert: silent start - fake a SS completion callback
%s:%d:%s: playAlert: non-blocking SSS alert for Siri startup
%s:%d:%s: playAlert: silent stop - fake a SS completion callback
%s:%d:%s: playAlert: calling AudioServicesPlaySystemSoundWithOptions with sound ID %u and flags %x
%s:%d:%s: playAlert: using alert queue to play beep
%s:%d:%s: playAlert: alert playback failed -- attempting to re-prime
%s:%d:%s: playAlert: Some Error occured! Not calling startAlertQueue() : %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %{audio:4CC}d
 ASSERTION FAILED: re-entrant request for different alert type
%s:%d:%s: primeAlertQueue: alert queue state '%s'.  reentrant or multi-threaded call -- returning
%s:%d:%s: primeAlertQueue: queue is NULL -- returning
%s:%d:%s: primeAlertQueue: type %d (current is %d)
%s:%d:%s: primeAlertQueue: sync-stopping active alert queue
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %{audio:4CC}d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: silent/haptic alert: not queueing a buffer
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: done. current is now %d
%s:%d:%s: primeAlertQueue: no-op
%s:%d:%s: setupAlert: NULL alert URL
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: setupAlert: Failed to load alert '%s'
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %{audio:4CC}d
%s:%d:%s: setupAlert: resetting alert queue
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %{audio:4CC}d
 ASSERTION FAILED: no alert buffer is enqueued!
%s:%d:%s: startAlertQueue: calling AudioQueueStart
%s:%d:%s: AVVC started alert queue%s (%d)
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %{audio:4CC}d
 ASSERTION FAILED: alert queue NULL but state != Uninitialized
%s:%d:%s: detected unfinished alert, queue up alertFinished
%s:%d:%s: destroyAlertQueue: calling AudioQueueStop
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %{audio:4CC}d
%s:%d:%s: destroyAlertQueue: removing queue listener
%s:%d:%s: destroyAlertQueue: calling AudioQueueDispose
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: calculateAlertTimes: alert queue already stopped -- using current time as end time
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %d
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %{audio:4CC}d
%s:%d:%s: alertStarted: record state != kRecordStarting -- noop
%s:%d:%s: alertStarted: not playing start alert -- noop
%s:%d:%s: alertFinished
%s:%d:%s: alertFinished: state = %s mRecordState: %s -- not priming alert
%s:%d:%s: alertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: Alert Listener: impl or queue is NULL or object is being destroyed -- noop
%s:%d:%s: Alert Listener: in the middle of priming alert queue:  Doing nothing.  [THIS IS NEW BEHAVIOR]
%s:%d:%s: Alert Listener: mAlertQueueState = %s
%s:%d:%s: Alert Listener: RUNNING = %d
%s:%d:%s: Alert Listener: session was interrupted!  Doing nothing here
%s:%d:%s: Alert Listener: state already kAlertQueueRunning.  Doing nothing here
%s:%d:%s: Alert Listener: Session is inactive, alertFinishedPlayback already synthesized in deactivateSession.
%s:%d:%s: Alert Listener: queue reports stopped on first IsRunning prop notification -- treat this like a regular start
%s:%d:%s: Alert Listener: unhandled inID %s
%s:%d:%s: vibeStartAlertFinished: record state != kRecordStarting -- noop
%s:%d:%s: vibeStopAlertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: VibeAlertCompletionProc: SSID %u done
%s:%d:%s: VibeAlertCompletionProc -> called after object destroyed -- ignoring call
%s:%d:%s: VibeAlertCompletionProc: object being destroyed -- bailing out
%s:%d:%s: VibeAlertCompletionProc: notified for other ssID %d -- no-op
%s:%d:%s: checkForEndpoint entered: inBuffer %p
%s:%d:%s: performSelectorOnMainThread: startpointDetected
%s:%d:%s: calling startpointDetected synchronously
%s:%d:%s: performSelectorOnMainThread: interspeechPointDetected
%s:%d:%s: calling interspeechPointDetected synchronously 
%s:%d:%s: #### AVVoiceController: Detected end point but NO START POINT ####
%s:%d:%s: checkForEndpoint: auto-stopping record
%s:%d:%s: performSelectorOnMainThread: endpointDetected
%s:%d:%s: calling endpointDetected synchronously
%s:%d:%s: checkForEndpoint exiting
%s:%d:%s: Record Listener: handling deferred context change
%s:%d:%s:     Reporting encoder error %s via delegate
%s:%d:%s:     performSelectorOnMainThread: encodeError
%s:%d:%s:     calling encodeError synchronously
%s:%d:%s:     No delegate method found -- dropping error
%s:%d:%s: AVVoiceController -> Interruption beginning for %s session (%p)
%s:%d:%s:   We think our session was not active.  Make sure it isn't. deactivating session with options : %d
%s:%d:%s: deactivating session returned  : %d - error - %@
%s:%d:%s:   Playback was active
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackWasStarted = %d mPlaybackRunning= %d
%s:%d:%s: performSelectorOnMainThread: beginPlaybackInterruption
%s:%d:%s: calling beginPlaybackInterruption synchronously
%s:%d:%s: performSelectorOnMainThread: finishedPlaying
%s:%d:%s: calling finishedPlaying synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate is nil or does not respond to voiceControllerBeginPlaybackInterruption:
%s:%d:%s:   Record was active
%s:%d:%s:   sending notification with interruptor name
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruptionWithContext:
%s:%d:%s: calling beginRecordInterruptionWithContext synchronously
%s:%d:%s:   sending notification
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruption
%s:%d:%s: calling beginRecordInterruption synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate does not respond to voiceControllerBeginRecordInterruption:
%s:%d:%s:   Nothing active
%s:%d:%s: AVVoiceController -> Interruption ending for %s session (%p)
%s:%d:%s:   Interrupt for aux session unexpected
%s:%d:%s:   No longer reactivating audio session on interrupt end
%s:%d:%s:   destroying playback queue on resume (whether we were playing or not)
%s:%d:%s:   Was interrupted during playback
%s:%d:%s: performSelectorOnMainThread: endPlaybackInterruption
%s:%d:%s: calling endPlaybackInterruption synchronously
%s:%d:%s:   Was interrupted during recording -- stopping queue on resume
 Record should never be active when interrupt is ending!
%s:%d:%s: performSelectorOnMainThread: endRecordInterruption
%s:%d:%s: calling endRecordInterruption synchronously
%s:%d:%s:   We were never interrupted to begin with!
%s:%d:%s: AVVoiceController -> Route Change for %s session (%p)
%s:%d:%s:   Route change for aux session unexpected
%s:%d:%s: Route change reason : [%d] = %s
%s:%d:%s: Route really changed -- Re-checking properties
%s:%d:%s: Route really changed but session not-yet-active/interrupted -- set flag to check properties when we are active
%s:%d:%s: New route Category is not ours!
%s:%d:%s: We were waiting for a route change -- Re-checking properties
%s:%d:%s: Route change reason: category change - ignoring
%s:%d:%s: Category change came in while we were %s -- ignoring
%s:%d:%s: Route change reason: route configuration change - ignoring
%s:%d:%s: Route change reason was NULL
%s:%d:%s: AVVoiceController -> Server died!
%s:%d:%s: ControllerImpl::handleServerDeath: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerDeath: session is not configured
%s:%d:%s: ControllerImpl::handleServerDeath: Destroying internal state for later rebuild
%s:%d:%s: AVVoiceController -> Server reset after death
%s:%d:%s: ControllerImpl::handleServerReset: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerReset: restoring activation context and resetting session properties
%s:%d:%s: mPlaybackRunning is true
%s:%d:%s: performSelectorOnMainThread: beganPlaying
%s:%d:%s: calling beganPlaying synchronously
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackRunning= %d
 ASSERTION FAILED: PB AQ listener proc called with nullptr impl!
%s:%d:%s: Playback Listener: RUNNING = %d
%s:%d:%s: performSelectorOnMainThread: decodeError
%s:%d:%s: calling decodeError synchronously
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: %@ requested. ignoring the device id and use built in device - %@. 
%s:%d:%s: setContext: ERROR! No recording engine associated with device for post/auto activation context
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with nil deviceUUID
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with deviceUUID - %@. 
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: Ambigous activation (%@) requested with deviceUUID - %@. EngineType : %d
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: returned error - %d for activation mode(%@)
%s:%d:%s: Found matching engine[%@] of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: setContext: Engine lookup returned nil!
%s:%d:%s: _createRecordingEngineWithParameters : Fatal Error! Invalid engine type!
%s:%d:%s: setContext: Created new (%s) engine[%@] for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: Stopping recording here and destroying engine
%s Likely ambiguous AVVC V2 use case detected. Must pass streamID here! (or V1 engine map integrity problem). numMapEngs(%lu) v1PluginEngInvalid(%d) v1AudioQueueEngInvalid(%d) v1ValidCase(%d) v2AmbiguousCase(%d)
%s:%d:%s: ASSERTION FAILURE [!streamIDViolation is false]: Likely ambiguous AVVC V2 use case detected. Must pass streamID here! (or V1 engine map integrity problem)
%s:%d:%s: ASSERTION FAILURE [eng != nullptr is false]: V1 engine map integrity problem. Couldn't find engine in map.
%s:%d:%s: _invalidateStreamWhenDeviceUnavailable_v1v2()
%s:%d:%s: VSPD is not present, removing engine associated with BuiltInStream
%s:%d:%s: removeEngineFromMapWithStreamID: engine[%@] stream(%llu) 
%s:%d:%s: Stopping recording here, engine's remote device has been disconnected.
%s:%d:%s: Engine for streamID(%llu) not found.
%s:%d:%s: DelegateDispatchGroup wait timed out after %f seconds
%s:%d:%s: alert state => %s
%s:%d:%s: Interrupting recording on engine[%@] with streamID(%llu)
%s:%d:%s: Stopping the recording on stream(%lu) due to a category change
%s:%d:%s: NOTE: AVVC Details logging is turned on by default for development
%s:%d:%s: debug_encoding on
%s:%d:%s: debug_endpoint on
%s:%d:%s: debug_callbacks on
%s:%d:%s: debug_locking on
%s:%d:%s: debug_state on
%s:%d:%s: debug_trace on
%s:%d:%s: debug_timing on
%s:%d:%s: debug_delegate on
%s:%d:%s: debug_playback on
%s:%d:%s: debug_deviceselect on
%s:%d:%s: debug_level = %d
%s:%d:%s: resetting debug_level to Notify to allow scoped logging
%s:%d:%s: debug priority: %u scopes: 0x%llx
%s:%d:%s: logAndReturnIfAudioSessionIsNotAvailable-%s returning : %d
%s:%d:%s: ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeOptions failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setIAmTheAssistant failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setAllowHapticsAndSystemSoundsDuringRecording failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeRouteSharingPolicyOptions failed with error: %@
%s:%d:%s: AVVCSessionManager::setSessionActivationContext : passed 'nil' dictionary, creating empty one.
%s:%d:%s: ERROR: AVVCSessionManager::setActivationContext of sessionID(0x%x) failed with error: %@
%s:%d:%s: shouldEnableMiniDucking on AppleTV. Not available for now
%s:%d:%s: enableMiniDucking: Called on HomePod like device, no-op
%s:%d:%s: shouldEnableMiniDucking: No change, no-op
%s:%d:%s: shouldEnableMiniDucking: Announce calls enabled. Will not set session properties while disabling miniDucking
%s:%d:%s: getHypotheticalRouteAndUpdateStates: pickedRoute from AudioSession: %@
%s:%d:%s: setupSessionInterruptionOrDuckingBehavior: isSomeOtherAudioPlaying: %d
%s:%d:%s: getHypotheticalRouteAndUpdateStates : shouldDuckOthers(%d), sessionNeedsVolumeControl(%d)
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions on 'audioOS'. Duck others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions on older watchOS. Interrupt others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: (wireless splitter mode). Interrupt others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: iMessage -- setting P&R category, clearing preferred input, etc.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: Carplay Supports Mixable Siri
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: announce mode for %s context - duck others
%s:%d:%s: AVVCSessionManager : category, mode and options are the same (Current activation: %d, Previous activation: %d). No-op
%s:%d:%s: AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x. (Current activation: %d, Previous activation: %d)
%s:%d:%s: ERROR: AVVCSessionManager : setCategoryModeRouteSharingPolicyOptions failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::clearInputPreferences failed with error: %@
%s:%d:%s: setSessionAudioHWControlFlags: Take Audio HW control on tvOS
%s:%d:%s: setSessionAudioHWControlFlags: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (HomePod) : %@
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags on older watch hardware: will never take control of HW on activation
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: wireless splitter mode, no volume control, yes routing control.
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (wireless splitter) : %@
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: disable mini-ducking. Set all HW control flags
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (disable mini-ducking) : %@
%s:%d:%s: AVVCSessionManager::setAudioHardwareControlFlags: announce mode for %s context - don't set HW control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: will not take control of hardware upon activation for AirPlay output (voic/rais)
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: setting volume/routing required hardware control flag for 'voic' activation mode (output is not Airplay)
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : set all hw control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: default mode - set all HW control flags
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: forcing 22050k audio for car audio
%s:%d:%s: ERROR: AVVCSessionManager::setPreferredSampleRate for VehicleButtonPress : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: SR changes from %f to %f
%s:%d:%s: ERROR: AVVCSessionManager::setPreferredSampleRate to %f : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: SR remains at %f
%s:%d:%s: ERROR: AVVCSessionManager::setSessionBufferSize failed: %@
%s:%d:%s: AVVCSessionManager::setSessionBufferSize: Current size: %d
%s:%d:%s: AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x
%s:%d:%s: Error in setDuckOthers:mixWithOthers %d, %@
%s:%d:%s: Error in setDuckingFadeDuration %d, %@
%s:%d:%s: ERROR: AVVCSessionManager::enableSmartRoutingConsideration failed: %@
%s:%d:%s: Output Port[%d / %d] : %@
%s:%d:%s: isSessionInSiriCategoryModeAndOptions: about to set Play&Record category, speech recognition/assistant mode. Current category: %@, mode: %@, options: 0x%x
%s:%d:%s: setRecordingFromRemoteInput: %d
%s:%d:%s: Error setting recording from remote input %d, %@
%s:%d:%s: ~AVVCAudioCapturer(): destroyed
%s:%d:%s: AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%s:%d:%s: ~AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%s:%d:%s: ~AVVCAudioCapturer_AudioDiagnostics(): destroyed
%s:%d:%s: Dumping Audio for stream(%lu) at %s
%s:%d:%s: Error setting up audio captures
%s:%d:%s: AVVCAudioCapturer:logCapture: logging lpcm audio
%s:%d:%s: AVVCAudioCapturer:logCapture: logging non-lpcm audio
%s:%d:%s: Error while logging audio: %d
%s:%d:%s: mCapturer is reset to NULL
%25s:%-5d Error: Unable to call RegisterAudioUnits_Internal from libAudioDSP.dylib.
%25s:%-5d unable to get property kAUDSPGraphProperty_GraphTextFilePath %i
%25s:%-5d unable to get property kAUDSPGraphProperty_AUStrip %i
%25s:%-5d Player@%p: Engine is in the middle of a config change, cannot play yet!
%25s:%-5d Player@%p: Engine could not start the audio hardware dynamically, cannot play!
%25s:%-5d Player@%p: Engine config changed when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: IOUnit stopped when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: Engine returned render error: %ld, node: %p {%s}, cannot play!
%s:%d:%s: AVVoiceTriggerClient init %@
%s:%d:%s: AVVoiceTriggerClient dealloc %@
%s:%d:%s: server crashed
%s:%d:%s: server reset
%s:%d:%s: server timeout
%s:%d:%s: enableVoiceTriggerListening: %s
 CAGuard::CAGuard: Could not init the cond var
 CAGuard::Wait: A thread has to have locked a guard before it can wait
 CAGuard::Wait: Could not wait for a signal
 CAGuard::WaitFor: A thread has to have locked a guard be for it can wait
 CAGuard::WaitFor: Wait got an error
 CAGuard::Notify: failed
 CAGuard::NotifyAll: failed
%25s:%-5d Engine@%p: could not initialize, error = %d
%25s:%-5d Engine#%p: error: couldn't connect mixer to output node!
%25s:%-5d Engine@%p: connect node1: %p (from bus: %lu) -> node2: %p (to bus: %lu), format: %s
%25s:%-5d Engine@%p: connect node: %p (from bus: %lu) ->%s, format: %s
%25s:%-5d Engine@%p: disconnect input bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect output bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect all inputs on node: %p
%25s:%-5d Engine@%p: disconnect all outputs on node: %p
%25s:%-5d Engine@%p: connect MIDI node: %p -> node: %p, format: %s
%25s:%-5d Engine@%p: connect MIDI node: %p -> %s, format: %s
%25s:%-5d Engine@%p: disconnect MIDI node: %p from node: %p
%25s:%-5d Engine@%p: disconnect MIDI node: %p from nodes: %s
%25s:%-5d Engine@%p: disconnect MIDI inputs on node: %p
%25s:%-5d Engine@%p: disconnect MIDI outputs on node: %p
%25s:%-5d Engine@%p: initialize
%25s:%-5d Engine@%p: uninitialize
%25s:%-5d Engine@%p: start
%25s:%-5d Engine@%p: pause
%25s:%-5d Engine@%p: stop
%25s:%-5d Engine@%p: could not disable manual rendering mode
%25s:%-5d Engine@%p: iounit configuration changed > posting notification
%25s:%-5d Engine@%p: iounit configuration changed < posted notification
%25s:%-5d Engine@%p: iounit configuration changed > setting flag
%25s:%-5d Engine@%p: iounit configuration changed > stopping the engine
%25s:%-5d Engine@%p: iounit stopped unexpectedly > pausing the engine
%25s:%-5d Engine@%p: install tap on node %p, bus%lu, bufferSize %d, format: %s
%25s:%-5d Engine@%p: remove tap from node %p, bus%lu
%25s:%-5d [%s:%d:%s: (%s)] returned %s, error %@
softlink:r:path:/System/Library/Frameworks/AVFoundation.framework/AVFoundation
AVAudioIONode
AVAudioOutputNode
AVAudioInputNode
AVAudioMixing
AVAudioStereoMixing
NSObject
AVAudio3DMixing
AVAudioConnectionPoint
AVAudioRemoteInputPlugin
AVAudioRemoteInputPlugin_PrivateTest
AVVCPluginRemoteInputHost
AVAudioRemoteInputPluginDelegate
AVVCRecordDeviceInfo
AVVoiceControllerInternal
AVVoiceController_Priv
AVVoiceController
AVVCContextSettings
AVVCPrepareRecordSettings
AVVCConfigureAlertBehaviorSettings
AVVCStartRecordSettings
AVVCAlertInformation
AVVCDuckFadeDuration
AVVCDuckOverride
AVVCDuckSettings
AVAudioUnitComponent
SpeexEndpointer
Endpointer
SpeexEndpointer_Priv
AVAudioUnitTimeEffect
AVAudioUnitComponentManager
AVAudioUnitDelay
VoiceVerificationEndpointer
AVAudioUnitVarispeed
AVAudioUnitReverb
AVAudioUnitTimePitch
AudioPlayerImpl
AVAudioPlayerPriv
AVAudioPlayer
AVAudioUnitGenerator
AVVCSessionFactory
AVAudioRecorder
AVAudioSessionParticipant
AVAudioSinkNode
AVAudioChannelLayout
NSSecureCoding
NSCoding
AVSpeechSynthesisProviderVoice
NSCopying
AVSpeechSynthesisProviderRequest
AVSpeechSynthesisProviderAudioUnit
AVAudioDeviceTestServiceProtocol
AVAudioDeviceTest
AVAudioConverter
Encoding
AVVCMetricsManager
AVAudioUnitDistortion
AVAudioMixerNode
AVAudioClock
AVMIDIPlayer
AVMIDIPlayerPriv
AVAudioUnitMIDIInstrument
AVAudioBuffer
NSMutableCopying
AVAudioPCMBuffer
AVAudioCompressedBuffer
AVAudioUnitSplitter
AVAudioUnitEQFilterParameters
AVAudioUnitEQ
AVAudioFormat
AVAudioDeviceTestResult
AVAudioDeviceTestSequence
AVAudioDeviceTestProcessingChain
AVAudioSourceNode
AVSpeechSynthesisVoice
AVSpeechUtterance
AVSpeechSynthesizer
AVSpeechSynthesisMarker
AVVCAudioBuffer
AVVCAudioBufferPriv
AVAudioEnvironmentDistanceAttenuationParameters
AVAudioEnvironmentReverbParameters
AVAudioEnvironmentNode
AVVCSessionManager
AVAudioFile
AVAudioNode
AVAudioMixingDestination
AVAudioUnitSampler
AVAudioSequencer_Player
AVAudioSequencer
AVMusicTrack
AVAudioTime
AVAudioUnitDSPGraph
AVAudioUnitEffect
AVAudioPlayerNode
AVVoiceTriggerClient
AVAudioUnit
AVAudioEngine
initWithImpl:
implementation
isVoiceProcessingEnabled
engine
isInManualRenderingMode
manualRenderingMode
resetImpl:
initWithIOUnit:isInput:
presentationLatency
audioUnit
didAttachToEngine:
didDetachFromEngine:error:
setVoiceProcessingEnabled:error:
enableManualRenderingMode:isInput:
enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:
Td,R,N
T^{OpaqueAudioComponentInstance=},R,N
voiceProcessingEnabled
TB,R,N,GisVoiceProcessingEnabled
manualRenderingFormat
isEqual:
manualRenderingMaximumFrameCount
outputFormatForBus:
setManualRenderingPCMFormat:maximumFrameCount:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
setPan:
Tf,N
renderingAlgorithm
setRenderingAlgorithm:
sourceMode
setSourceMode:
pointSourceInHeadMode
setPointSourceInHeadMode:
rate
setRate:
reverbBlend
setReverbBlend:
obstruction
setObstruction:
occlusion
setOcclusion:
position
setPosition:
Tq,N
T{AVAudio3DPoint=fff},N
destinationForMixer:bus:
volume
setVolume:
setManualRenderingInputPCMFormat:inputBlock:
isVoiceProcessingBypassed
setVoiceProcessingBypassed:
isVoiceProcessingAGCEnabled
setVoiceProcessingAGCEnabled:
isVoiceProcessingInputMuted
setVoiceProcessingInputMuted:
voiceProcessingBypassed
TB,N,GisVoiceProcessingBypassed
voiceProcessingAGCEnabled
TB,N,GisVoiceProcessingAGCEnabled
voiceProcessingInputMuted
TB,N,GisVoiceProcessingInputMuted
Tf,D,N
raise:format:arguments:
sharedAVSystemController
attributeForKey:
boolValue
sharedSystemAudioContext
supportsMultipleBluetoothOutputDevices
outputDevices
countByEnumeratingWithState:objects:count:
supportsBluetoothSharing
currentHandler
stringWithUTF8String:
handleFailureInFunction:file:lineNumber:description:
init
dealloc
node
initWithNode:bus:
connectionPointWithNode:bus:
_node
_bus
_reserved
T@"AVAudioNode",R,W,N,V_node
TQ,R,N,V_bus
objectForKey:
unsignedIntegerValue
doubleValue
speechDetectionDeviceSampleRate
inputNumberOfChannels
count
dictionaryWithDictionary:
stringWithFormat:
lowercaseString
regularExpressionWithPattern:options:error:
length
firstMatchInString:options:range:
range
substringWithRange:
whitespaceAndNewlineCharacterSet
stringByTrimmingCharactersInSet:
stringWithCString:encoding:
isEqualToString:
inputs
objectAtIndex:
portType
copy
stringByAppendingFormat:
outputs
portName
stringByAppendingString:
intValue
allBundles:
absoluteString
bundleWithURL:
principalClass
initWithPluginDelegate:
invalidate
devices
T@"NSArray",R,N
addObject:
defaultManager
URLsForDirectory:inDomains:
array
URLByAppendingPathComponent:
checkResourceIsReachableAndReturnError:
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
addObjectsFromArray:
deviceIdentifier
deviceCategory
impl
handlePluginDidPublishDevice:withDevice:
handlePluginDidUnpublishDevice:withDevice:
mockPluginEndpoint
inputPlugin:didPublishDevice:
inputPlugin:didUnpublishDevice:
initializePlugins
invalidatePlugins
findDeviceWithIdentifier:
findFirstBluetoothDevice
setParentVoiceController:
mPlugins
mMotherController
sessionState
code
setAudioInputBlock:
setStatusChangeBlock:
startRecordingWithSettings:withCompletionBlock:
numberWithUnsignedLongLong:
numberWithInteger:
dictionaryWithObjectsAndKeys:
startRecordingWithCompletionBlock:
stopRecordingWithCompletionBlock:
supportedFormats
objectAtIndexedSubscript:
streamDescription
initWithStreamDescription:
setFormat:
format
audioInputBlock
frameLength
packetCount
audioTimeStamp
getBytes:range:
packetDescriptions
data
stringWithString:
remoteInputDeviceName
initWithString:
initWithUUIDString:
initWithRecordingEngine:
recordRoute
isRemoteDevice
remoteProductIdentifier
remoteDeviceUID
remoteDeviceCategory
isUpsamplingSourceAudio
remoteDeviceUIDString
_isRemoteDevice
_isUpsamplingSourceAudio
_remoteDeviceCategory
_recordRoute
_remoteProductIdentifier
_remoteDeviceUID
_remoteDeviceUIDString
T@"NSString",R,N,V_recordRoute
TB,R,V_isRemoteDevice
T@"NSString",R,N,V_remoteProductIdentifier
T@"NSUUID",R,N,V_remoteDeviceUID
TI,R,N,V_remoteDeviceCategory
TB,R,N,V_isUpsamplingSourceAudio
T@"NSString",R,N,V_remoteDeviceUIDString
setSessionNotifications_v1v2:
sharedInstance
setSessionWasCreatedBlock:
removeSessionNotifications:
setSessionWillBeDestroyedBlock:
isPrimary
audioSession
setupSessionNotifications:
voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
userInfo
object
unsignedLongValue
initWithDictionary:
currentRoute
setObject:forKey:
voiceControllerMediaServicesWereLost:
voiceControllerMediaServicesWereReset:
pointerValue
voiceControllerDidStartRecording:forStream:successfully:error:
initWithDomain:code:userInfo:
voiceControllerDidStartRecording:successfully:error:
voiceControllerDidStartRecording:successfully:
voiceControllerDidStopRecording:forStream:forReason:
voiceControllerDidStopRecording:forReason:
voiceControllerDidDetectStartpoint:
voiceControllerDidDetectEndpoint:ofType:atTime:
voiceControllerDidDetectEndpoint:ofType:
voiceControllerEncoderErrorDidOccur:error:
voiceControllerDidStartPlaying:successfully:
initWithAudioQueueBuffer:channels:timeStamp:
voiceControllerPlaybackBufferAvailable:buffer:
voiceControllerDidStopPlaying:forReason:
voiceControllerDecoderErrorDidOccur:error:
initWithAlertType:mode:endTime:
voiceControllerDidFinishAlertPlayback:withSettings:error:
voiceControllerDidFinishAlertPlayback:ofType:error:
voiceControllerStreamInvalidated:forStream:
voiceControllerBeginRecordInterruption:
voiceControllerBeginRecordInterruption:withContext:
voiceControllerEndRecordInterruption:
voiceControllerBeginPlaybackInterruption:
voiceControllerEndPlaybackInterruption:
voiceControllerWillSetAudioSessionActive:willActivate:
voiceControllerDidSetAudioSessionActive:isActivated:
sessionSetup_v1v2
sessionCleanup_v1v2
hardwareConfigChanged
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
beganRecording_v1v2:
finishedRecording_v1v2:
startpointDetected
interspeechPointDetected
endpointDetected
encodeError
beganPlaying
playbackBufferReceived:
finishedPlaying_v1v2
decodeError
alertPlaybackFinishedOfType_v1v2:
notifyStreamInvalidated_v1v2:
beginRecordInterruption_v1v2
beginRecordInterruptionWithContext_v1v2:
endRecordInterruption_v1v2
beginPlaybackInterruption_v1v2
endPlaybackInterruption_v1v2
beginAudioSessionActivate_v1v2:
endAudioSessionActivate_v1v2:
isAPIAvailable
sendRemoteConnectionMessage:
playbackRoute
lastRecordStartTime
voiceTriggerInfo
isBargeInDetectEnabled
setBargeInDetectEnabled:
isStopOnBargeInEnabled
setStopOnBargeInEnabled:
isSynchronousCallbackEnabled
setSynchronousCallbackEnabled:
pcmRecordBufferFormat
setDuckOthersOption:
duckOthersOption
numberOfChannels
bargeInDetectEnabled
TB,GisBargeInDetectEnabled
stopOnBargeInEnabled
TB,GisStopOnBargeInEnabled
T@"NSDictionary",R
synchronousCallbackEnabled
TB,GisSynchronousCallbackEnabled
T@"AVAudioFormat",R
TB,SsetDuckOthersOption:
unsignedIntValue
errorWithDomain:code:userInfo:
finalize
playAlertSoundForType:
setupAlertBehavior_v1:
doStartRecordingAtTime_v1:behavior:
unsignedLongLongValue
reset
getStatus:count:
setEndpointMode:
setStartWaitTime:
setInterspeechWaitTime:
setEndWaitTime:
isRecording
initVoiceControllerForClient:withError:
activationMode
activationDeviceUID
streamID
recordBufferDuration
avAudioSettings
startHostTime
startAlert
stopAlert
stopOnErrorAlert
skipAlert
initWithContext:error:
prewarmAudioSession
releaseAudioSession
releaseAudioSession:
enableMiniDucking:
willAcceptContext:
IsDeviceAvailableInLocalRoute:error:
setCurrentContext:error:
prepareRecordWithSettings:error:
setAlertSoundFromURL:forType:
resetEndpointer
playRecordStartingAlertAndResetEndpointer
startRecording
startRecording:
startRecordingAtTime:error:
startRecordingWithSettings:error:
stopRecording
preparePlaybackWithSettings:error:
preparePlaybackFromURL:error:
startPlaying
stopPlaying
recordDelegate
setRecordDelegate:
recordSettings
getRecordBufferDuration
setRecordBufferDuration:
endpointerDelegate
setEndpointerDelegate:
recordEndpointMode
setRecordEndpointMode:
recordStartWaitTime
setRecordStartWaitTime:
recordInterspeechWaitTime
setRecordInterspeechWaitTime:
recordEndWaitTime
setRecordEndWaitTime:
playbackDelegate
setPlaybackDelegate:
playbackSettings
getPlaybackBufferDuration
setPlaybackBufferDuration:
isPlaying
setAlertVolume:
alertVolume
getAlertStartTime
setPlaybackVolume:
playbackVolume
isMeteringEnabled
setMeteringEnabled:
updateMeters
peakPowerForChannel:
averagePowerForChannel:
isStopOnEndpointEnabled
setStopOnEndpointEnabled:
metrics
currentRecordDeviceInfo
initWithError:
setContext:error:
setContext:streamType:error:
prepareRecordForStream:completion:
prepareRecordForStream:error:
startRecordWithSettings:completion:alertCompletion:audioCallback:
startRecordForStream:error:
configureAlertBehaviorForStream:error:
stopRecordOnStream:completion:
stopRecordForStream:error:
getCurrentStreamState:
getRecordDeviceInfoForStream:
activateAudioSessionForStream:isPrewarm:error:
activateAudioSessionForStream:isPrewarm:recordMode:error:
deactivateAudioSessionWithOptions:
deactivateAudioSessionForStream:withOptions:error:
getCurrentSessionState
getCurrentSessionStateForStream:
setContextForStream:forStream:error:
playAlert:withOverride:completion:
playAlertSoundForType:overrideMode:
getRecordBufferDurationForStream:
getRecordSettingsForStream:
isMeteringEnabledForStream:
updateMeterForStream:
getPeakPowerForStream:forChannel:
getAveragePowerForStream:forChannel:
setRecordStatusChangeBlock:
enableSmartRoutingConsiderationForStream:enable:error:
setAnnounceCallsEnabledForStream:enable:
getInputChannelInfoForStream:completion:
setDuckOthersForStream:withSettings:error:
alertStartTime
_impl
_alertStartTime
recording
TB,R,GisRecording
T@"<Endpointer>",&
T@"<AVVoiceControllerRecordDelegate>",D
meteringEnabled
TB,GisMeteringEnabled
playing
TB,R,GisPlaying
T@"<AVVoiceControllerPlaybackDelegate>",D
stopOnEndpointEnabled
TB,GisStopOnEndpointEnabled
TQ,R,V_alertStartTime
allocWithZone:
announceCallsEnabled
initWithMode:deviceUID:
copyWithZone:
setActivationMode:
setActivationDeviceUID:
setAnnounceCallsEnabled:
_announceCallsEnabled
_activationMode
_activationDeviceUID
Tq,N,V_activationMode
T@"NSString",&,N,V_activationDeviceUID
TB,N,V_announceCallsEnabled
initWithStreamID:settings:bufferDuration:
setStreamID:
setAvAudioSettings:
_meteringEnabled
_streamID
_avAudioSettings
_recordBufferDuration
TQ,N,V_streamID
T@"NSDictionary",&,N,V_avAudioSettings
Td,N,V_recordBufferDuration
TB,N,V_meteringEnabled
initWithStreamID:
setStartAlert:
setStopAlert:
setStopOnErrorAlert:
_startAlert
_stopAlert
_stopOnErrorAlert
Tq,N,V_startAlert
Tq,N,V_stopAlert
Tq,N,V_stopOnErrorAlert
initWithStreamID:atStartHostTime:
setStartHostTime:
setSkipAlert:
startAnchorPoint
setStartAnchorPoint:
_skipAlert
_startAnchorPoint
_startHostTime
TQ,N,V_startHostTime
TB,N,V_skipAlert
TI,N,V_startAnchorPoint
type
setType:
mode
setMode:
alertEndTime
setAlertEndTime:
_type
_mode
_alertEndTime
Ti,N,V_type
Tq,N,V_mode
TQ,N,V_alertEndTime
initWithFadeIn:fadeOut:
fadeIn
setFadeIn:
fadeOut
setFadeOut:
_fadeIn
_fadeOut
T@"NSNumber",&,N,V_fadeIn
T@"NSNumber",&,N,V_fadeOut
initWithDuckOthers:duckToLevel:mixWithOthers:
duckOthers
setDuckOthers:
duckToLevel
setDuckToLevel:
mixWithOthers
setMixWithOthers:
_duckOthers
_duckToLevel
_mixWithOthers
T@"NSNumber",&,N,V_duckOthers
T@"NSNumber",&,N,V_duckToLevel
T@"NSNumber",&,N,V_mixWithOthers
duckOverride
setDuckOverride:
fadeDuration
setFadeDuration:
_duckOverride
_fadeDuration
T@"AVVCDuckOverride",&,N,V_duckOverride
T@"AVVCDuckFadeDuration",&,N,V_fadeDuration
rangeOfString:
substringToIndex:
whitespaceCharacterSet
substringFromIndex:
removeAllObjects
localizedStringForKey:value:table:
mutableCopy
GetTypeName:
typeName
URLWithString:
arrayWithArray:
setWithArray:
isSubsetOfSet:
allObjects
defaultCenter
postNotificationName:object:
dictionary
configurationDictionary
containsObject:
audioComponentDescription
initWithComponentDescription:
initWithComponentDescription:withAVAUManagerImpl:
localeChanged
audioComponent
name
localizedTypeName
manufacturerName
versionString
iconURL
userTagNames
setUserTagNames:
allTagNames
componentURL
availableArchitectures
version
hasCustomView
passesAUVal
isSandboxSafe
hasMIDIInput
hasMIDIOutput
supportsNumberInputChannels:outputChannels:
isComponentDescriptionMatch:
T@"NSString",R,N
TQ,R,N
T@"NSURL",R,N
sandboxSafe
TB,R,N,GisSandboxSafe
TB,R,N
T^{OpaqueAudioComponent=},R,N
T@"NSArray",C
T{AudioComponentDescription=IIIII},R,N
T@"NSDictionary",R,N
getStatus:
endpointMode
startWaitTime
interspeechWaitTime
endWaitTime
configureWithSampleRate:andFrameRate:
configureWithASBD:andFrameRate:
mStartWaitTime
mInterspeechWaitTime
mEndWaitTime
mEndpointMode
mFrameRate
mLastStatus
initWithAudioComponentDescription:
bypass
setBypass:
TB,N
removeObjectsInArray:
unionSet:
arrayWithObjects:count:
bundleWithIdentifier:
sharedAudioUnitComponentManager
localeChanged:
addObserver:selector:name:object:
registrationsChanged:
filteredArrayUsingPredicate:
privateAllocInitSingleton
tagNames
standardLocalizedTagNames
componentsMatchingPredicate:
componentsPassingTest:
componentsMatchingDescription:
removeObject:
setValue:forParam:
valueForParam:
setWetDryMix:
setDelayTime:
setFeedback:
setLowPassCutoff:
wetDryMix
delayTime
feedback
lowPassCutoff
Td,N
cleanupContext:
sessionForContext:clientType:error:
sessionManagerForContext:clientType:error:
initWithUnsignedInteger:
initWithDouble:
initWithCapacity:
mutableBytes
initWithObjects:forKeys:count:
clientRequestsRecording
voiceControllerLPCMAudioCallback:forStream:buffer:
voiceControllerAudioCallback:forStream:buffer:
voiceControllerLPCMRecordBufferAvailable:buffer:
voiceControllerRecordBufferAvailable:buffer:
audioBufferList
loadFactoryPreset:
setPitch:
setOverlap:
pitch
overlap
_delegate
_data
_url
_actualSettings
_format
_playRetain
_channelAssignments
_audioSession
_sessionListenerWasSet
_endInterruptionFlags
_localPlayer
_gcd
stop
delegate
audioPlayerDidFinishPlaying:successfully:
audioPlayerDecodeErrorDidOccur:error:
removeObserver:name:object:
valueForKey:
audioPlayerBeginInterruption:
audioPlayerEndInterruption:withOptions:
audioPlayerEndInterruption:withFlags:
audioPlayerEndInterruption:
initBase
finishedPlaying:
decodeError:
privRemoveSessionListener
handleInterruption:
beginInterruption
endInterruptionWithFlags:
endInterruption
initWithData:fileTypeHint:error:
initWithContentsOfURL:fileTypeHint:error:
owningPortUID
channelNumber
opaqueSessionID
initWithData:error:
initWithContentsOfURL:error:
prepareToPlay
play
playAtTime:
pause
setDelegate:
settings
duration
setVolume:fadeDuration:
setEnableRate:
enableRate
currentTime
deviceCurrentTime
setCurrentTime:
setNumberOfLoops:
numberOfLoops
channelAssignments
setChannelAssignments:
setAudioSession:
mixToUplink
setMixToUplink:
currentDevice
setCurrentDevice:
_currentDevice
Td,R
T@"NSString",C,V_currentDevice
T@"<AVAudioPlayerDelegate>",W
T@"NSURL",R
T@"NSData",R
T@"NSArray",C,N
performSelectorOnMainThread:withObject:waitUntilDone:
initWithUnsignedInt:
initWithBool:
initWithLength:
initWithSettings:
compare:
UTF8String
auxiliarySession
objectForKeyedSubscript:
initWithObjectsAndKeys:
setActivationContext:error:
initWithSession:
setupOneTimeSessionSettingsForClient:
setObject:forKeyedSubscript:
_wqCreateAuxSessionAndManagerForDeviceUID:clientType:session:manager:error:
_wqCreatePrimarySessionManagerIfNeeded:clientType:error:
sessionForContext:clientType:completion:
_wqSessionAndManagerForContext:clientType:session:manager:error:
allValues
sessionForContext:completion:
sessionForContext:error:
sessionManagerForContext:clientType:completion:
auxSessionManagers
releasePrimarySessionManager
workQueue
setWorkQueue:
sessionManagerMap
setSessionManagerMap:
primarySessionManager
setPrimarySessionManager:
sessionWasCreatedBlock
sessionWillBeDestroyedBlock
_workQueue
_sessionManagerMap
_primarySessionManager
_sessionWasCreatedBlock
_sessionWillBeDestroyedBlock
T@"NSObject<OS_dispatch_queue>",&,N,V_workQueue
T@"NSMutableDictionary",&,N,V_sessionManagerMap
T@"AVVCSessionManager",&,N,V_primarySessionManager
T@?,C,N,V_sessionWasCreatedBlock
T@?,C,N,V_sessionWillBeDestroyedBlock
audioRecorderDidFinishRecording:successfully:
privRemoveSessionPropertyListeners
privCommonCleanup
initWithURL:settings:error:
baseInit
path
pathExtension
finishedRecording
removeItemAtPath:error:
audioRecorderBeginInterruption:
audioRecorderEndInterruption:withOptions:
audioRecorderEndInterruption:withFlags:
audioRecorderEndInterruption:
setActive:error:
endInterruptionWithFlags
T@"AVAudioSession",&
initWithURL:format:error:
prepareToRecord
record
recordAtTime:
recordForDuration:
recordAtTime:forDuration:
deleteRecording
setProcessToTap:
processToTap
instantaneousMetering
setInstantaneousMetering:
Ti,N
T@"<AVAudioRecorderDelegate>",W
bytes
setMusicSequence:
channelCount
pullInputBlockFromReceiverBlock:
initWithReceiverBlock:
isInterleaved
initWithPCMFormat:frameCapacity:
frameCapacity
setFrameLength:
mutableAudioBufferList
sampleRate
timeWithAudioTimeStamp:sampleRate:
initWithLayout:
layout
layoutTag
initWithLayoutTag:
layoutSize
encodeBytes:length:
decodeBytesWithReturnedLength:
failWithError:
layoutWithLayoutTag:
layoutWithLayout:
supportsSecureCoding
encodeWithCoder:
initWithCoder:
TB,R
_layoutTag
_layout
TI,R,N
Tr^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]},R,N
initStandardFormatWithSampleRate:channels:
arrayWithObjects:
arrayWithObject:
initWithEnvironment:
addObserverForName:object:queue:usingBlock:
removeObserver:
firstObject
isHeadphones
encodeObject:forKey:
identifier
supportedLanguages
voiceSize
encodeInt64:forKey:
gender
encodeInteger:forKey:
decodeObjectOfClass:forKey:
setName:
setIdentifier:
setWithObjects:
decodeObjectOfClasses:forKey:
setSupportedLanguages:
longLongValue
setVoiceSize:
setVersion:
integerValue
setGender:
setAge:
initialize
didUpdateSpeechVoices
initWithName:identifier:supportedLanguages:
_name
_identifier
_supportedLanguages
_voiceSize
_version
_gender
_age
T@"NSString",&,N,V_name
T@"NSString",&,N,V_identifier
T@"NSArray",&,N,V_supportedLanguages
Tq,N,V_voiceSize
T@"NSString",&,N,V_version
Tq,N,V_gender
Tq,N,V_age
voice
ssmlRepresentation
setVoice:
setSsmlRepresentation:
initWithSSMLRepresentation:voice:
_ssmlRepresentation
_voice
T@"NSString",&,N,V_ssmlRepresentation
T@"AVSpeechSynthesisProviderVoice",&,N,V_voice
synthesizeSpeechRequest:
cancelSpeechRequest
speechVoices
setSpeechVoices:
speechSynthesisOutputMetadataBlock
setSpeechSynthesisOutputMetadataBlock:
_speechVoices
_speechSynthesisOutputMetadataBlock
T@"NSArray",&,N,V_speechVoices
T@?,C,N,V_speechSynthesisOutputMetadataBlock
initWithListenerEndpoint:
setConnection:
initWithServiceName:
connection
passExtensionToken:
startWithSequence:completion:
cancel
interfaceWithProtocol:
setRemoteObjectInterface:
remoteObjectInterface
setClasses:forSelector:argumentIndex:ofReply:
localizedDescription
remoteObjectProxyWithErrorHandler:
setServiceDelegateAsync:
synchronousRemoteObjectProxyWithErrorHandler:
setServiceDelegateSync:
setInterruptionHandler:
setInvalidationHandler:
resume
initWithXPCEndPoint:
stimulusURL
fileSystemRepresentation
serviceDelegateSync
processSequenceAsynchronously
serviceDelegateAsync
outputID
inputID
setProcessSequenceAsynchronously:
.cxx_destruct
_processSequenceAsynchronously
_connection
_serviceDelegateAsync
_serviceDelegateSync
T@"NSXPCConnection",&,V_connection
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateAsync
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateSync
TB,V_processSequenceAsynchronously
channelLayout
magicCookie
setMagicCookie:
initFromFormat:toFormat:
inputFormat
outputFormat
dither
downmix
setDither:
setDownmix:
sampleRateConverterQuality
setSampleRateConverterQuality:
sampleRateConverterAlgorithm
setSampleRateConverterAlgorithm:
channelMap
setChannelMap:
maximumOutputPacketSize
primeMethod
setPrimeMethod:
primeInfo
setPrimeInfo:
convertToBuffer:fromBuffer:error:
convertToBuffer:error:withInputFromBlock:
T@"AVAudioFormat",R,N
T@"NSArray",&,N
T@"NSData",&,N
T@"NSString",&,N
T{AVAudioConverterPrimeInfo=II},N
bitRate
setBitRate:
bitRateStrategy
setBitRateStrategy:
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
Tq,R,N
initWithBytes:length:
initWithObjects:count:
byteCapacity
setByteLength:
packetCapacity
setPacketCount:
numberWithDouble:
getLock
setPublicMetrics:
publicMetrics
dictionaryWithObjects:forKeys:count:
setAvvcProfilingInfoDictionary:
setVoiceTriggerStartHostTime:
setCallToStartRecordHostTime:
localTimeZone
setTimeZone:
setDateFormat:
stringFromDate:
avvcProfilingInfoDictionary
timeIntervalSinceDate:
getStringDate:
enumerateKeysAndObjectsUsingBlock:
date
createSharedManager
destroySharedManager
sharedManager
retrieveMetrics
resetProfileMetrics
retrieveProfileMetrics
measureElapseTimeForMetric:block:
setAudioIssueDetectorFormat:numFrames:
audioIssueDetectorAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetAudioIssueDetector
setADAMFormat:numFrames:
adamAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetADAM
logProfileMetrics:
voiceTriggerStartHostTime
callToStartRecordHostTime
_voiceTriggerStartHostTime
_callToStartRecordHostTime
_publicMetrics
_avvcProfilingInfoDictionary
T@"NSMutableDictionary",&,V_publicMetrics
T@"NSMutableDictionary",&,V_avvcProfilingInfoDictionary
TQ,N,V_voiceTriggerStartHostTime
TQ,N,V_callToStartRecordHostTime
setSessionBufferSize:
renderBlock
FillOutAUPreset:
setPreGain:
preGain
setSessionActivationContext:
setSessionCategoryModeOptionsForActivationMode:withOptions:
setSessionSampleRateForActivationMode:
setSessionAudioHWControlFlagsForActivationMode:withOptions:
setClientRequestsRecording:
getSessionActivationOptions
setActive:withOptions:error:
enableSmartRoutingConsideration:
setDuckOthers:mixWithOthers:error:
setDuckingFadeOutDuration:fadeInDuration:error:
setSessionState:
setOutputVolume:
outputVolume
setInputVolume:bus:
setInputPan:bus:
inputConnected:
nextAvailableInputBus
initWithNode:
currentAudioTimeStamp
currentIONumberFrames
awaitIOCycle:
T@"AVAudioTime",R,N
destroyBase
initWithContentsOfURL:soundBankURL:error:
initWithData:soundBankURL:error:
hostTimeForBeats:
beatsForHostTime:
play:
currentPosition
setCurrentPosition:
TB,R,N,GisPlaying
startNote:withVelocity:onChannel:
stopNote:onChannel:
sendController:withValue:onChannel:
sendPitchBend:onChannel:
sendPressure:onChannel:
sendPressureForKey:withValue:onChannel:
sendProgramChange:onChannel:
sendProgramChange:bankMSB:bankLSB:onChannel:
sendMIDIEvent:data1:data2:
sendMIDIEvent:data1:
sendMIDISysExEvent:
byteLength
mutableCopyWithZone:
initWithFormat:byteCapacity:
initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:
_deallocator
Tr^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
T^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
_initChannelPtrs
appendDataFromBuffer:channel:
calculatePower:
floatChannelData
stride
calculatePower:forFloatData:stride:frameLength:
numberWithFloat:
int16ChannelData
int32ChannelData
initWithPCMFormat:bufferListNoCopy:deallocator:
appendDataFromBuffer:
splitIntoSingleChannelBuffers
averagePowerPerChannel
peakPowerPerChannel
TI,N
T^^f,R,N
T^^s,R,N
T^^i,R,N
initWithFormat:packetCapacity:maximumPacketSize:
initWithFormat:packetCapacity:
maximumPacketSize
T^v,R,N
TI,R,D,N
TI,D,N
T^{AudioStreamPacketDescription=qII},R,N
setFilterType:
filterType
setFrequency:
frequency
setBandwidth:
bandwidth
setGain:
gain
initWithNumberOfBands:
bands
globalGain
setGlobalGain:
initWithStreamDescription:channelLayout:
settingsFromASBD:channelLayout:
numberWithUnsignedInteger:
setValue:forKey:
dataWithBytes:length:
encodeDouble:forKey:
decodeDoubleForKey:
decodeIntegerForKey:
formatWithInvalidSampleRateAndChannelCount
initStandardFormatWithSampleRate:channelLayout:
initWithCommonFormat:sampleRate:channels:interleaved:
initWithCommonFormat:sampleRate:interleaved:channelLayout:
initWithCMAudioFormatDescription:
formatDescription
isStandard
commonFormat
_asbd
_commonFormat
standard
TB,R,N,GisStandard
interleaved
TB,R,N,GisInterleaved
Tr^{AudioStreamBasicDescription=dIIIIIIII},R,N
T@"AVAudioChannelLayout",R,N
Tr^{opaqueCMFormatDescription=},R,N
initWithData:inputID:outputID:sampleRate:correlationValue:
setInputID:
setOutputID:
setSampleRate:
correlationValue
setCorrelationValue:
_inputID
_outputID
_sampleRate
_correlationValue
Tq,N,V_outputID
Tq,N,V_inputID
Td,N,V_sampleRate
Td,N,V_correlationValue
T@"NSData",R,N,V_data
encodeFloat:forKey:
encodeBool:forKey:
decodeFloatForKey:
decodeBoolForKey:
setStimulusURL:
inputProcessingChain
setInputProcessingChain:
outputProcessingChain
setOutputProcessingChain:
outputMode
setOutputMode:
priority
setPriority:
calculateCrossCorrelationPeak
setCalculateCrossCorrelationPeak:
parallelCrossCorrelationCalculation
setParallelCrossCorrelationCalculation:
_calculateCrossCorrelationPeak
_parallelCrossCorrelationCalculation
_volume
_stimulusURL
_inputProcessingChain
_outputProcessingChain
_outputMode
_priority
Tf,N,V_volume
T@"NSURL",&,N,V_stimulusURL
T@"AVAudioDeviceTestProcessingChain",&,N,V_inputProcessingChain
T@"AVAudioDeviceTestProcessingChain",&,N,V_outputProcessingChain
Tq,N,V_outputMode
Tq,N,V_priority
T@"NSString",&,V_mode
TB,V_calculateCrossCorrelationPeak
TB,V_parallelCrossCorrelationCalculation
graphURL
setGraphURL:
processingStripURL
setProcessingStripURL:
_graphURL
_processingStripURL
T@"NSURL",&,N,V_graphURL
T@"NSURL",&,N,V_processingStripURL
pullInputBlockFromRenderBlock:
initWithRenderBlock:
initWithFormat:renderBlock:
stringByReplacingOccurrencesOfString:withString:
startAndReturnError:
reason
fileURLWithPath:
dictionaryWithContentsOfURL:error:
enableManualRenderingMode:format:maximumFrameCount:error:
inputNode
attachNode:
connect:to:format:
outputNode
detachNode:
renderOffline:toBuffer:error:
bundleWithPath:
isLoaded
loadAndReturnError:
language
quality
setLanguage:
setQuality:
currentLanguageCode
voiceWithLanguage:
voiceWithIdentifier:
audioFileSettings
_audioFileSettings
T@"NSString",C,D,N
T@"NSString",&,D,N
Tq,D,N
T@"NSDictionary",R,N,V_audioFileSettings
speechString
attributedSpeechString
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
setSpeechString:
setAttributedSpeechString:
floatValue
setPitchMultiplier:
setPreUtteranceDelay:
setPostUtteranceDelay:
speechUtteranceWithString:
speechUtteranceWithAttributedString:
speechUtteranceWithSSMLRepresentation:
initWithAttributedString:
initWithSSMLRepresentation:
prefersAssistiveTechnologySettings
setPrefersAssistiveTechnologySettings:
_prefersAssistiveTechnologySettings
_rate
_pitchMultiplier
_speechString
_attributedSpeechString
_preUtteranceDelay
_postUtteranceDelay
T@"NSString",&,N,V_speechString
T@"NSAttributedString",&,N,V_attributedSpeechString
T@"AVSpeechSynthesisVoice",&,N,V_voice
Tf,N,V_rate
Tf,N,V_pitchMultiplier
TB,N,V_prefersAssistiveTechnologySettings
Td,N,V_preUtteranceDelay
Td,N,V_postUtteranceDelay
speakUtterance:
writeUtterance:toBufferCallback:
writeUtterance:toBufferCallback:toMarkerCallback:
stopSpeakingAtBoundary:
pauseSpeakingAtBoundary:
continueSpeaking
isSpeaking
isPaused
outputChannels
setOutputChannels:
usesApplicationAudioSession
setUsesApplicationAudioSession:
mixToTelephonyUplink
setMixToTelephonyUplink:
_speaking
_paused
_usesApplicationAudioSession
_mixToTelephonyUplink
_outputChannels
T@"<AVSpeechSynthesizerDelegate>",W,N,V_delegate
speaking
TB,R,N,GisSpeaking,V_speaking
paused
TB,R,N,GisPaused,V_paused
T@"NSArray",&,N,V_outputChannels
TB,N,V_usesApplicationAudioSession
TB,N,V_mixToTelephonyUplink
mark
byteSampleOffset
textRange
valueWithRange:
setMark:
setByteSampleOffset:
rangeValue
setTextRange:
initWithMarkerType:forTextRange:atByteSampleOffset:
_mark
_byteSampleOffset
_textRange
TQ,N,V_mark
TQ,N,V_byteSampleOffset
T{_NSRange=QQ},N,V_textRange
channels
bytesCapacity
bytesDataSize
setBytesDataSize:
packetDescriptionCapacity
packetDescriptionCount
setPacketDescriptions:count:
timeStamp
remoteVoiceActivityRMS
remoteVoiceActivityVAD
remoteVoiceActivityAvailable
upsamplingSourceAudio
Ti,R
T^v,R
T^{AudioStreamPacketDescription=qII},R
T^{AudioStreamBasicDescription=dIIIIIIII},R
TC,R
setDistanceAttenuationModel:
distanceAttenuationModel
setMaximumDistance:
maximumDistance
setReferenceDistance:
referenceDistance
setRolloffFactor:
rolloffFactor
setEnable:
enable
setLevel:
level
filterParameters
loadFactoryReverbPreset:
T@"AVAudioUnitEQFilterParameters",R,N
setOutputType:
outputType
applicableRenderingAlgorithms
setListenerPosition:
listenerPosition
setListenerVectorOrientation:
listenerVectorOrientation
setListenerAngularOrientation:
listenerAngularOrientation
distanceAttenuationParameters
reverbParameters
T{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}},N
T{AVAudio3DAngularOrientation=fff},N
T@"AVAudioEnvironmentDistanceAttenuationParameters",R,N
T@"AVAudioEnvironmentReverbParameters",R,N
changeDuckOthersOption:
shouldEnableMiniDucking:withOptions:
isMiniDuckingEnabled
setCategory:mode:routeSharingPolicy:options:error:
setIAmTheAssistant:error:
clearInputPreferences:
isSessionInSiriCategoryModeAndOptions:
setPreferredSampleRate:error:
setSessionActivationOptions:
setAudioHardwareControlFlags:error:
sessionCurrentOutputRoutes
isAirplayOneOfTheOutputRoutes:
getSiriInputSource:withIdentifier:
getOpaqueSessionID
outputLatency
inputLatency
voiceTriggerPastDataFramesAvailable
valueWithPointer:
voiceControllerEndInterruption:
category
initWithSuiteName:
boolForKey:
siriRemoteInputIdentifier
isSessionOutputInWirelessSplitterMode
setCategory:withOptions:error:
setAllowHapticsAndSystemSoundsDuringRecording:error:
pickedRoute
isOtherAudioPlaying
getHypotheticalRouteAndUpdateStates
categoryOptions
setPreferredIOBufferFrameSize:error:
preferredIOBufferFrameSize
setEligibleForBTSmartRoutingConsideration:error:
setCategory:mode:options:error:
reporterID
siriInputSource
activeSessionDisplayIDs
componentsJoinedByString:
setRecordingFromRemoteInput:error:
getInputLatency
getOutputLatency
isSessionInSiriCategory
sessionCurrentInputRoutes
getActiveSessionDisplayIDsAsString
mShouldDuckOthers
mIsMiniDuckingEnabled
mShouldEnableMiniDucking
mShouldDisableMiniDucking
mSessionNeedsVolumeControl
mSessionNeedsRoutingControl
mSessionOutputIsWirelessSplitter
mIsOtherAudioPlaying
mRouteHasDoAPSupport
mOutputSupportsSWVolume
mDeviceIsIOSAccessory
mDeviceIsOlderWatch
mSessionActivationOptions
mPreviousActivationMode
_isPrimary
_clientRequestsRecording
_sessionState
_inputLatency
_outputLatency
T@"AVAudioSession",&,N,V_audioSession
Ti,N,V_sessionState
TB,R,N,V_isPrimary
TB,N,V_clientRequestsRecording
Td,R,N,V_inputLatency
Td,R,N,V_outputLatency
initForReading:commonFormat:interleaved:error:
initForReadingFromExtAudioFile:commonFormat:interleaved:error:
initForWriting:settings:commonFormat:interleaved:error:
readIntoBuffer:frameCount:error:
initForReading:error:
initForReadingFromExtAudioFile:error:
initForWriting:settings:error:
initSecondaryReader:format:error:
readIntoBuffer:error:
writeFromBuffer:error:
fileFormat
processingFormat
framePosition
setFramePosition:
setOutputFormat:forBus:
inputFormatForBus:
setInputFormat:forBus:
nameForInputBus:
nameForOutputBus:
clock
lastRenderTime
latency
outputPresentationLatency
numberOfInputs
numberOfOutputs
setNumberOfInputs:
setNumberOfOutputs:
installTapOnBus:bufferSize:format:block:
removeTapOnBus:
AUAudioUnit
T@"AVAudioEngine",R,N
T@"AUAudioUnit",R,N
connectionPoint
T@"AVAudioConnectionPoint",R,N
parameterTree
caseInsensitiveCompare:
overallGain
setOverallGain:
loadInstrumentAtURL:error:
loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:
loadAudioFilesAtURLs:error:
stereoPan
masterGain
globalTuning
setStereoPan:
setMasterGain:
setGlobalTuning:
currentPositionInSeconds
setCurrentPositionInSeconds:
currentPositionInBeats
setCurrentPositionInBeats:
hostTimeForBeats:error:
beatsForHostTime:error:
cleanTracks
setTempoTrack:
setTrackArray:
trackArray
setupTrackArray
numberOfTracks
setupTracks
tempoTrack
initWithAudioEngine:
loadFromURL:options:error:
loadFromData:options:error:
writeToURL:SMPTEResolution:replaceExisting:error:
dataWithSMPTEResolution:error:
tracks
getTempoTrack
secondsForBeats:
beatsForSeconds:
T@"AVMusicTrack",R,N
index
track
setDestinationAudioUnit:
destinationAudioUnit
setDestinationMIDIEndpoint:
destinationMIDIEndpoint
loopRange
setLoopRange:
isLoopingEnabled
setLoopingEnabled:
offsetTime
setOffsetTime:
isMuted
setMuted:
isSoloed
setSoloed:
usesAutomatedParameters
setUsesAutomatedParameters:
lengthInBeats
setLengthInBeats:
lengthInSeconds
setLengthInSeconds:
timeResolution
T@"AVAudioUnit",&,N
T{_AVBeatRange=dd},N
loopingEnabled
TB,N,GisLoopingEnabled
muted
TB,N,GisMuted
soloed
TB,N,GisSoloed
initWithHostTime:
initWithSampleTime:atRate:
initWithHostTime:sampleTime:atRate:
initWithAudioTimeStamp:sampleRate:
secondsForHostTime:
timeWithHostTime:
timeWithSampleTime:atRate:
timeWithHostTime:sampleTime:atRate:
hostTimeForSeconds:
isHostTimeValid
isSampleTimeValid
hostTime
sampleTime
extrapolateTimeFromAnchor:
_ats
hostTimeValid
TB,R,N,GisHostTimeValid
sampleTimeValid
TB,R,N,GisSampleTimeValid
T{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II},R,N
loadAudioDSPManager
relativePath
loadDSPGraphAtURL:error:
loadAudioUnitProcessingStripAtURL:error:
dspGraphURL
auProcessingStripURL
scheduleBuffer:atTime:options:completionHandler:
scheduleBuffer:atTime:options:completionCallbackType:completionHandler:
callLegacyCompletionHandlerForType:legacyHandler:
scheduleFile:atTime:completionCallbackType:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:
scheduleBuffer:completionHandler:
scheduleBuffer:completionCallbackType:completionHandler:
scheduleFile:atTime:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionHandler:
prepareWithFrameCount:
nodeTimeForPlayerTime:
playerTimeForNodeTime:
initWithKeyOptions:valueOptions:capacity:
anyObject
voiceTriggerPastDataFramesAvailableCompletion:
enableVoiceTriggerListening:completionBlock:
enableSpeakerStateListening:completionBlock:
speakerStateActiveCompletionBlock:
speakerStateMutedCompletionBlock:
hasBargeInSupportCompletionBlock:
updateVoiceTriggerConfiguration:completionBlock:
callServerCrashedBlock
handleMediaServerDeath:
callServerResetBlock
handleMediaServerReset:
voiceTriggerServerConnection
getInputChannelInfoCompletion:
enableVoiceTriggerListening:
setListeningProperty:completionBlock:
enableSpeakerStateListening:
speakerStateActive
speakerStateMuted
hasBargeInSupport
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:
listeningEnabledCompletionBlock:
siriClientsRecordingCompletionBlock:
setAggressiveECMode:completionBlock:
voiceTriggerNotification:
speakerStateChangedNotification:
speakerMuteStateChangedNotification:
siriClientRecordStateChangedNotification:recordingCount:
voiceTriggerBlock
setVoiceTriggerBlock:
speakerStateChangedBlock
setSpeakerStateChangedBlock:
speakerMuteStateChangedBlock
setSpeakerMuteStateChangedBlock:
siriClientRecordStateChangedBlock
setSiriClientRecordStateChangedBlock:
serverCrashedBlock
setServerCrashedBlock:
serverResetBlock
setServerResetBlock:
_voiceTriggerBlock
_speakerStateChangedBlock
_speakerMuteStateChangedBlock
_siriClientRecordStateChangedBlock
_serverCrashedBlock
_serverResetBlock
T@?,C,N,V_voiceTriggerBlock
T@?,C,N,V_speakerStateChangedBlock
T@?,C,N,V_speakerMuteStateChangedBlock
T@?,C,N,V_siriClientRecordStateChangedBlock
T@?,C,N,V_serverCrashedBlock
T@?,C,N,V_serverResetBlock
dictionaryWithContentsOfURL:
componentsSeparatedByString:
instantiateWithComponentDescription:options:completionHandler:
loadAudioUnitPresetAtURL:error:
T@"AUAudioUnit",R,D,N
mainMixerNode
connect:to:fromBus:toBus:format:
connect:toConnectionPoints:fromBus:format:
disconnectNodeInput:bus:
disconnectNodeOutput:bus:
disconnectNodeInput:
disconnectNodeOutput:
prepare
inputConnectionPointForNode:inputBus:
outputConnectionPointsForNode:outputBus:
musicSequence
isRunning
isAutoShutdownEnabled
setAutoShutdownEnabled:
manualRenderingSampleTime
disableManualRenderingMode
manualRenderingBlock
connectMIDI:to:format:block:
connectMIDI:toNodes:format:block:
disconnectMIDI:from:
disconnectMIDI:fromNodes:
disconnectMIDIInput:
disconnectMIDIOutput:
attachedNodes
T^{OpaqueMusicSequence=},N
T@"AVAudioOutputNode",R,N
T@"AVAudioInputNode",R,N
T@"AVAudioMixerNode",R,N
running
TB,R,N,GisRunning
autoShutdownEnabled
TB,N,GisAutoShutdownEnabled
T@"NSSet",R,C
T@?,R,N
auAudioUnitForAudioUnit:
isMusicDeviceOrEffect
scheduleMIDIEventBlock
removeRenderObserver:
invalidateAudioUnit
allocateRenderResourcesAndReturnError:
deallocateRenderResources
inputBusses
outputBusses
setFormat:error:
setEnabled:
isEnabled
setBusCount:error:
parameterWithID:scope:element:
parameterWithAddress:
setValue:
value
maximumFramesToRender
setMaximumFramesToRender:
isRenderingOffline
setRenderingOffline:
tokenByAddingRenderObserver:
setMIDIOutputEventBlock:
setInputEnabled:
setOutputEnabled:
startHardwareAndReturnError:
stopHardware
setOutputProvider:
setInputHandler:
canPerformInput
canPerformOutput
@28@0:8^v16B24
d16@0:8
^{OpaqueAudioComponentInstance=}16@0:8
v24@0:8@16
v32@0:8@16^@24
B16@0:8
q16@0:8
B28@0:8B16^@20
B28@0:8q16B24
B32@0:8^v16B24B28
B28@0:8@16I24
@16@0:8
I16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
f16@0:8
v20@0:8f16
v24@0:8q16
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@32@0:8@16Q24
@"AVAudioMixingDestination"32@0:8@"AVAudioNode"16Q24
B32@0:8@16@?24
v20@0:8B16
v16@0:8
@"AVAudioNode"
@24@0:8@16
@24@0:8@"<AVAudioRemoteInputPluginDelegate>"16
@"NSArray"16@0:8
@"NSXPCListenerEndpoint"16@0:8
v32@0:8@16@24
v32@0:8@"<AVAudioRemoteInputPlugin>"16@"<AVAudioRemoteInputDevice>"24
@24@0:8^@16
@"NSMutableArray<AVAudioRemoteInputPlugin>"
@"AVVoiceController"
@32@0:8{shared_ptr<AVVCRecordingEngine>=^{AVVCRecordingEngine}^{__shared_weak_count}}16
@"NSString"
@"NSUUID"
{shared_ptr<ControllerImpl>=^{ControllerImpl}^{__shared_weak_count}}16@0:8
v24@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCCB}16
v20@0:8i16
v24@0:8Q16
@32@0:8@16^@24
B32@0:8@16^@24
B28@0:8@16i24
B20@0:8i16
i32@0:8Q16@24
B24@0:8^@16
B32@0:8Q16^@24
B24@0:8d16
i16@0:8
v24@0:8d16
f24@0:8Q16
@32@0:8q16^@24
Q32@0:8@16^@24
Q40@0:8@16^q24^@32
v32@0:8@16@?24
v48@0:8@16@?24@?32@?40
v32@0:8Q16@?24
q24@0:8Q16
@24@0:8Q16
B36@0:8Q16B24^@28
B40@0:8Q16B24B28^@32
v40@0:8Q16Q24^@32
B40@0:8@16Q24^@32
v36@0:8i16q20@?28
B28@0:8i16q20
d24@0:8Q16
B24@0:8Q16
f32@0:8Q16Q24
v24@0:8@?16
B28@0:8Q16B24
B40@0:8Q16@24^@32
@32@0:8q16@24
@24@0:8^{_NSZone=}16
@40@0:8Q16@24d32
@"NSDictionary"
@32@0:8Q16Q24
v20@0:8I16
@36@0:8i16q20Q28
@32@0:8@16@24
@"NSNumber"
@40@0:8@16@24@32
@"AVVCDuckOverride"
@"AVVCDuckFadeDuration"
@36@0:8{AudioComponentDescription=IIIII}16
@44@0:8{AudioComponentDescription=IIIII}16^{AVAudioUnitComponentManagerImpl=^^?@@@{mutex={_opaque_pthread_mutex_t=q[56c]}}}36
^{OpaqueAudioComponent=}16@0:8
{AudioComponentDescription=IIIII}16@0:8
B32@0:8q16q24
@20@0:8I16
B36@0:8{AudioComponentDescription=IIIII}16
i24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
B28@0:8d16I24
B28@0:8^{AudioStreamBasicDescription=dIIIIIIII}16I24
i28@0:8^f16I24
@24@0:8@?16
@"<AVAudioPlayerDelegate>"
@"NSData"
@"NSURL"
@"AVAudioFormat"
@"NSArray"
@"AVAudioSession"
^{AVAudioPlayerCpp=^{__CFData}^{__CFURL}^{__CFDictionary}I{AudioStreamBasicDescription=dIIIIIIII}{AudioStreamBasicDescription=dIIIIIIII}IQ*I^{AudioFormatListItem}I^{OpaqueAudioFileID}I^{OpaqueAudioQueue}qqqddddIdi{AudioFilePacketTableInfo=qii}qqiiBBBBIBBBBdddddd^{__CFString}I^{AudioQueueLevelMeterState}[3^{AudioQueueBuffer}]^{AudioQueueBuffer}i[3I]BBBBB^{AudioQueueBuffer}IBBBBqiII^v^?I@I^{AudioQueueChannelAssignment}}
@"NSObject<OS_dispatch_queue>"
@40@0:8@16@24^@32
v28@0:8f16d20
v56@0:8@16q24^@32^@40^@48
@40@0:8@16q24^@32
v40@0:8@16q24@?32
@?16@0:8
@"NSMutableDictionary"
@"AVVCSessionManager"
@"AVAudioSession"16@0:8
v24@0:8@"AVAudioSession"16
^{AudioRecorderImpl=@@@@@@I{AudioStreamBasicDescription=dIIIIIIII}^{OpaqueAudioFileID}^{OpaqueAudioQueue}qqqdddQ*BBBBBBBB^{AudioQueueLevelMeterState}[4^{AudioQueueBuffer}]^{AudioQueueBuffer}BQBi@}16@0:8
B32@0:8d16d24
@?24@0:8@?16
@24@0:8r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16@0:8
^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}
@"AVSpeechSynthesisProviderVoice"
v24@0:8@"NSString"16
v32@0:8@"AVAudioDeviceTestSequence"16@?<v@?@"NSArray"@"NSError">24
@"NSXPCConnection"
@"<AVAudioDeviceTestServiceProtocol>"
{AVAudioConverterPrimeInfo=II}16@0:8
v24@0:8{AVAudioConverterPrimeInfo=II}16
B40@0:8@16@24^@32
q40@0:8@16^@24@?32
^v16@0:8
i60@0:8{CAStreamBasicDescription=dIIIIIIII}16I56
i56@0:8{AudioBufferList=I[1{AudioBuffer=II^v}]}16I40r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}44B52
{AUPreset=i^{__CFString}}24@0:8q16
v28@0:8f16Q20
@24@0:8^v16
{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16@0:8
@24@0:8^I16
Q24@0:8d16
^{MIDIPlayerImpl=^{OpaqueAUGraph}^{OpaqueMusicPlayer}^{OpaqueMusicSequence}d@?@}16@0:8
v28@0:8C16C20C24
v24@0:8C16C20
v24@0:8S16C20
v32@0:8C16C20C24C28
@28@0:8@16I24
@44@0:8@16I24r^{AudioBufferList=I[1{AudioBuffer=II^v}]}28@?36
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
@40@0:8@16r^{AudioBufferList=I[1{AudioBuffer=II^v}]}24@?32
^^f16@0:8
^^i16@0:8
^^s16@0:8
B32@0:8@16q24
f44@0:8Q16^f24q32I40
@36@0:8@16I24q28
^{AudioStreamPacketDescription=qII}16@0:8
@24@0:8^{AVAudioUnitEQFilterParametersImpl=^^?^{AVAudioNodeImplBase}}16
@32@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16@24
@24@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16
@28@0:8d16I24
@32@0:8d16@24
@40@0:8Q16d24I32B36
@44@0:8Q16d24B32@36
@24@0:8^{opaqueCMFormatDescription=}16
r^{opaqueCMFormatDescription=}16@0:8
r^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
{AudioStreamBasicDescription="mSampleRate"d"mFormatID"I"mFormatFlags"I"mBytesPerPacket"I"mFramesPerPacket"I"mBytesPerFrame"I"mChannelsPerFrame"I"mBitsPerChannel"I"mReserved"I}
@"AVAudioChannelLayout"
@56@0:8@16q24q32d40d48
@"AVAudioDeviceTestProcessingChain"
@32@0:8@16@?24
@"AVSpeechSynthesisVoice"
@"NSAttributedString"
v40@0:8@16@?24@?32
B24@0:8q16
@"<AVSpeechSynthesizerDelegate>"
@48@0:8Q16{_NSRange=QQ}24Q40
{_NSRange=QQ}16@0:8
v32@0:8{_NSRange=QQ}16
{_NSRange="location"Q"length"Q}
v28@0:8r^{AudioStreamPacketDescription=qII}16i24
^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
C16@0:8
@36@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCCB}16i24Q28
v40@0:8{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16
{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16@0:8
v28@0:8{AVAudio3DAngularOrientation=fff}16
{AVAudio3DAngularOrientation=fff}16@0:8
i24@0:8q16
i24@0:8@16
v28@0:8B16Q20
i32@0:8q16Q24
i20@0:8i16
i20@0:8B16
B48@0:8@16@24Q32^@40
B56@0:8@16@24Q32Q40^@48
B20@0:8I16
B32@0:8d16^@24
B32@0:8^Q16^@24
B36@0:8B16Q20^@28
@44@0:8@16Q24B32^@36
@32@0:8^{OpaqueExtAudioFile=}16^@24
@44@0:8^{OpaqueExtAudioFile=}16Q24B32^@36
@52@0:8@16@24Q32B40^@44
B36@0:8@16I24^@28
B24@0:8^v16
B32@0:8@16Q24
v44@0:8Q16I24@28@?36
@24@0:8^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16
^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16@0:8
B44@0:8@16C24C28C32^@36
Q32@0:8d16^@24
d32@0:8Q16^@24
@24@0:8^{AVAudioSequencerImpl=^{OpaqueMusicPlayer}^{OpaqueMusicSequence}@@@@}16
B44@0:8@16q24B32^@36
d24@0:8d16
@24@0:8^{MusicTrackImpl=^{OpaqueMusicTrack}@BI}16
^{OpaqueMusicTrack=}16@0:8
{_AVBeatRange=dd}16@0:8
v32@0:8{_AVBeatRange=dd}16
@32@0:8q16d24
@40@0:8Q16q24d32
@32@0:8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16d24
{AudioTimeStamp="mSampleTime"d"mHostTime"Q"mRateScalar"d"mWordClockTime"Q"mSMPTETime"{SMPTETime="mSubframes"s"mSubframeDivisor"s"mCounter"I"mType"I"mFlags"I"mHours"s"mMinutes"s"mSeconds"s"mFrames"s}"mFlags"I"mReserved"I}
v32@0:8q16@?24
v48@0:8@16@24Q32@?40
v56@0:8@16@24Q32q40@?48
v40@0:8@16@24@?32
v48@0:8@16@24q32@?40
v52@0:8@16q24I32@36@?44
v60@0:8@16q24I32@36q44@?52
v28@0:8B16@?20
v48@0:8{AudioComponentDescription=IIIII}16I36@?40
B24@0:8f16I20
f20@0:8I16
v56@0:8@16@24Q32Q40@48
v40@0:8@16@24@32
v48@0:8@16@24Q32@40
v32@0:8@16Q24
v24@0:8^{OpaqueMusicSequence=}16
^{OpaqueMusicSequence=}16@0:8
B44@0:8q16@24I32^@36
q36@0:8I16@20^@28
v48@0:8@16@24@32@?40
uouarneglppa
?xfuayledlppa
cfuairavlppa
mcpl
xfua2bvrlppa
cfuaptunlppa
cfuavnoclppa
xfuatsidlppa
xmuaxmcmlppa
xmualpsmlppa
xfuaqebnlppa
mcpl)
xeps
xmuamed3lppa
ngualpsslppa
yE> 
@mcpl
HD-C
Mb@?
Aumuapmas
!$'*-0369B<?
258;
&),/
cfil
NSt3__117bad_function_callE
NSt3__112bad_weak_ptrE
St9bad_alloc
uouaoipvlppa
uouacoirlppa
xfuagpsdlppa
11CAException
St12length_error
St11logic_error
St9exception
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioIONode.mm
-[AVAudioIONode enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:]
ioUnit != nil
-[AVAudioOutputNode setManualRenderingPCMFormat:maximumFrameCount:]
self.isInManualRenderingMode
-[AVAudioOutputNode manualRenderingFormat]
-[AVAudioOutputNode manualRenderingMaximumFrameCount]
required condition is false: %s
com.apple.coreaudio.avfaudio
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCCarplayRuntimeAvailability.mm
supportsCarPlayMixableStream
supportsCarPlayAuxStream
isSessionInWirelessSplitterMode
AVOutputContext
Class getAVOutputContextClass()_block_invoke
AVVCCarplayRuntimeAvailability.mm
Unable to find class %s
void *AVFoundationLibrary()
/System/Library/Frameworks/AVFoundation.framework/Contents/MacOS/AVFoundation
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCUtils.mm
RegisterObject_v1v2
UnregisterObject
DeviceClassNumber
torpedo
logRouteChangeDict
AVAudioSessionRouteChangeCurrentRouteKey
null
{ inputs: %@, 
outputs: %@ }
(type=%@, name=%@, UID=%@); 
Unknown
NewDeviceAvailable
OldDeviceUnAvailable
CategoryChange
Override
WakeFromSleep
NoSuitableRouteForCategory
RouteConfigurationChange
%04d-%02d-%02d 
%02d:%02d:%02d.%06d
Gain
Frame Qualities
StartTime
StartAnchorPoint
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCPluginRecordingEngine.mm
-[AVVCPluginRemoteInputHost initializePlugins]
-[AVVCPluginRemoteInputHost dealloc]
-[AVVCPluginRemoteInputHost invalidatePlugins]
Audio/Plug-Ins/RemoteInput/
-[AVVCPluginRemoteInputHost allBundles:]
-[AVVCPluginRemoteInputHost findDeviceWithIdentifier:]_block_invoke
-[AVVCPluginRemoteInputHost findDeviceWithIdentifier:]
-[AVVCPluginRemoteInputHost findFirstBluetoothDevice]
-[AVVCPluginRemoteInputHost inputPlugin:didPublishDevice:]
-[AVVCPluginRemoteInputHost inputPlugin:didUnpublishDevice:]
-[AVVCPluginRemoteInputHost mockPluginEndpoint]
AVVCPluginRecordingEngine
~AVVCPluginRecordingEngine
getCurrentDeviceFromActivationContext
AVVCPluginRecordingEngine::startRecording
startRecording_block_invoke
AVVCPluginRecordingEngine::stopRecording
stopRecording_block_invoke
AVVCPluginRecordingEngine::destroyRecordEngine
destroyRecordEngine_block_invoke
_asbdForClientSettings
createRecordQueue_block_invoke
v32@?0@"AVAudioBuffer"8@"AVAudioTime"16@"NSDictionary"24
v20@?0I8@"NSDictionary"12
handleRecordInput
Error! No Remote Device Found
Error! No RemoteInputDeviceName property
AVVCTestDevice
TraceMethod
~TraceMethod
(0x0) use_count:0
(%p) streamID: %d, use_count:%ld
activation trigger
activation device uid
AlertBehavior
No Record Route
ATVRemoteInput
BluetoothDoAP
JarvisRemoteInput
SetSessionActiveTime
SetSessionInactiveTime
BeginHostTime
EndHostTime
DurationMilliSeconds
undifferentiated-count
dsp-count
mic-count
speaker-ref-count
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVoiceController.mm
-[AVVCRecordDeviceInfo initWithRecordingEngine:]
-[AVVCRecordDeviceInfo dealloc]
v24@?0@"AVVCSessionManager"8^@16
-[AVVoiceController(AVVoiceControllerInternal) setSessionNotifications_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) removeSessionNotifications:]
-[AVVoiceController(AVVoiceControllerInternal) hardwareConfigChanged]
-[AVVoiceController(AVVoiceControllerInternal) handleInterruption_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) handleRouteChange_v1v2:]_block_invoke
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidPublishDevice:withDevice:]
-[AVVoiceController(AVVoiceControllerInternal) handlePluginDidUnpublishDevice:withDevice:]
-[AVVoiceController(AVVoiceControllerInternal) beganRecording_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) finishedRecording_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) startpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) interspeechPointDetected]
-[AVVoiceController(AVVoiceControllerInternal) endpointDetected]
-[AVVoiceController(AVVoiceControllerInternal) beganPlaying]
-[AVVoiceController(AVVoiceControllerInternal) finishedPlaying_v1v2]
-[AVVoiceController(AVVoiceControllerInternal) alertPlaybackFinishedOfType_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) notifyStreamInvalidated_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) beginAudioSessionActivate_v1v2:]
-[AVVoiceController(AVVoiceControllerInternal) endAudioSessionActivate_v1v2:]
-[AVVoiceController(AVVoiceController_Priv) setStopOnBargeInEnabled:]
-[AVVoiceController(AVVoiceController_Priv) numberOfChannels]
-[AVVoiceController retain]
-[AVVoiceController release]
-[AVVoiceController initWithContext:error:]
-[AVVoiceController prewarmAudioSession]
finalize
-[AVVoiceController dealloc]
-[AVVoiceController releaseAudioSession]
-[AVVoiceController releaseAudioSession:]
-[AVVoiceController enableMiniDucking:]
-[AVVoiceController willAcceptContext:]
-[AVVoiceController IsDeviceAvailableInLocalRoute:error:]
-[AVVoiceController setCurrentContext:error:]
-[AVVoiceController prepareRecordWithSettings:error:]
-[AVVoiceController setAlertSoundFromURL:forType:]
-[AVVoiceController playAlertSoundForType:]
playAlertSoundForType
-[AVVoiceController resetEndpointer]
-[AVVoiceController playRecordStartingAlertAndResetEndpointer]
-[AVVoiceController startRecording]
-[AVVoiceController startRecording:]
-[AVVoiceController startRecordingAtTime:error:]
-[AVVoiceController startRecordingWithSettings:error:]
-[AVVoiceController stopRecording]
-[AVVoiceController preparePlaybackWithSettings:error:]
preparePlaybackWithSettings
-[AVVoiceController preparePlaybackFromURL:error:]
preparePlaybackFromURL
-[AVVoiceController startPlaying]
-[AVVoiceController stopPlaying]
-[AVVoiceController setRecordDelegate:]
-[AVVoiceController setRecordBufferDuration:]
-[AVVoiceController setEndpointerDelegate:]
internal Speex
external
-[AVVoiceController setRecordEndpointMode:]
-[AVVoiceController setRecordStartWaitTime:]
-[AVVoiceController setPlaybackDelegate:]
-[AVVoiceController setPlaybackBufferDuration:]
-[AVVoiceController isRecording]
-[AVVoiceController setAlertVolume:]
-[AVVoiceController setPlaybackVolume:]
-[AVVoiceController setMeteringEnabled:]
-[AVVoiceController setStopOnEndpointEnabled:]
-[AVVoiceController currentRecordDeviceInfo]
-[AVVoiceController initVoiceControllerForClient:withError:]
-[AVVoiceController setContext:error:]
-[AVVoiceController setContext:streamType:error:]
-[AVVoiceController prepareRecordForStream:completion:]
-[AVVoiceController prepareRecordForStream:error:]
-[AVVoiceController startRecordWithSettings:completion:alertCompletion:audioCallback:]
-[AVVoiceController startRecordForStream:error:]
 will skip alert
 will NOT skip alert
-[AVVoiceController configureAlertBehaviorForStream:error:]
-[AVVoiceController stopRecordOnStream:completion:]
-[AVVoiceController stopRecordForStream:error:]
-[AVVoiceController getCurrentStreamState:]
-[AVVoiceController getRecordDeviceInfoForStream:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:error:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:recordMode:error:]
-[AVVoiceController deactivateAudioSessionWithOptions:]
-[AVVoiceController deactivateAudioSessionForStream:withOptions:error:]
-[AVVoiceController setContextForStream:forStream:error:]
-[AVVoiceController playAlert:withOverride:completion:]
-[AVVoiceController playAlertSoundForType:overrideMode:]
-[AVVoiceController setRecordStatusChangeBlock:]
-[AVVoiceController enableSmartRoutingConsiderationForStream:enable:error:]
-[AVVoiceController setAnnounceCallsEnabledForStream:enable:]
-[AVVoiceController getInputChannelInfoForStream:completion:]
-[AVVoiceController setDuckOthersForStream:withSettings:error:]
<fadeIn(%@), fadeOut(%@)>
<duckOthers(%@), duckToLevel(%@) , mixWithOthers(%@)>
<duckOverride(%@), fadeDuration(%@)>
VCLocker
~VCLocker
BlockIfAnotherAVVCIsStillAlive_v1v2
 TIMEDOUT!
GetAVVCSingleInstanceSemaphore_v1v2_block_invoke
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVC_Log.h
~ElapsedTime
AllowNextAVVCToInit
0x%x
Output
Music Device
Music Effect
Format Converter
Effect
Mixer
Panner
Generator
Offline Effect
MIDI Processor
Apple
AVAudioUnitComponentTagsDidChangeNotification
AVAudioUnitComponentImplementation
%d.%d.%d
AudioUnitTags
com.apple.audio.ComponentTagHelper
Request
type
subtype
manufacturer
version
UserTags
com.apple.audio.units.Components
AudioUnitTypes
InitialInputs
InitialOutputs
Remote Effect
Remote Generator
Remote Instrument
Remote Music Effect
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/QualityDetector.cpp
QualityDetector
checkStatus
setStartTimeoutFrameCount
setInterspeechTimeoutFrameCount
setEndTimeoutFrameCount
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/SpeexEndpointer.mm
-[SpeexEndpointer init]
-[SpeexEndpointer dealloc]
-[SpeexEndpointer configureWithSampleRate:andFrameRate:]
-[SpeexEndpointer configureWithASBD:andFrameRate:]
-[SpeexEndpointer setEndpointMode:]
-[SpeexEndpointer setStartWaitTime:]
-[SpeexEndpointer setInterspeechWaitTime:]
-[SpeexEndpointer setEndWaitTime:]
-[SpeexEndpointer(SpeexEndpointer_Priv) getStatus:count:]
%02X
Int16
Int32
Int8.24
Float32
Float64
, non-inter
, inter
%2d ch, %6.0f Hz, %s%s
%2d ch, %6.0f Hz, 'freq'
%2d ch, %6.0f Hz
%2d ch, %6.0f Hz, %s (0x%08X) 
 big-endian
 little-endian
 signed
 unsigned
integer
float
packed in %d bytes
unpacked in %d bytes
 high-aligned
 low-aligned
, deinterleaved
%d.%d
%s-bit%s%s %s%s%s%s%s
from %d-bit source, 
from UNKNOWN source bit depth, 
%d frames/packet
%d bits/channel, %d bytes/packet, %d frames/packet, %d bytes/frame
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitTimeEffect.mm
-[AVAudioUnitTimeEffect initWithAudioComponentDescription:]
audioComponentDescription.componentType == kAudioUnitType_FormatConverter
Effects
Equalizer
Filter
Dynamics Processor
Reverb
Distortion
Delay
Time Effect
Synthesizer
Sampler
Drums
Guitar
Vocal
Bass
MIDI
Pitch
Imaging
No changes
New tags found, add it to the allTags
AVAudioUnitComponentManagerRegistrationsChangedNotification
CAException
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCRecordingEngine.mm
~AVVCRecordingEngine
reconfigure
setupASBDAndCreateRecorder
audioSession_block_invoke
sessionManager_block_invoke
populateRecordSettings
setStreamState
setRecordErrorStatus
setRecordBufferDuration
getRecordBufferDuration
getPeakPowerForChannel
getAveragePowerForChannel
cacheRecordRoute
setStartRecordCompletionAndAudioCallbackBlocks
setStopRecordCompletionBlock
setDidStopDelegateCompletionBlock
avvcAudioBufferReceived
audioBufferListReceived
if_running_then
ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
ret = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND)
AVFileTypeAIFF
AVFileTypeAIFC
AVFileTypeWAVE
AVFileTypeMPEG4
AVFileTypeAppleM4A
AVFileTypeCoreAudioFormat
AVFileTypeMPEGLayer3
AVFileTypeAC3
AVFileTypeSunAU
AVFileType3GPP
AVFileType3GPP2
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitGenerator.mm
-[AVAudioUnitGenerator initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Generator) || (audioComponentDescription.componentType == kAudioUnitType_RemoteGenerator)
AVVCSessionFactory Work Queue
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCSessionFactory.mm
-[AVVCSessionFactory _wqCreateAuxSessionAndManagerForDeviceUID:clientType:session:manager:error:]
-[AVVCSessionFactory _wqCreatePrimarySessionManagerIfNeeded:clientType:error:]
-[AVVCSessionFactory _wqSessionAndManagerForContext:clientType:session:manager:error:]
-[AVVCSessionFactory _wqSessionAndManagerForContext:clientType:session:manager:error:]_block_invoke
-[AVVCSessionFactory cleanupContext:]_block_invoke
-[AVVCSessionFactory releasePrimarySessionManager]_block_invoke
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/CoreAudioUtility/Source/Utility/CALog.cpp
RegisterScope
warning
note
notice
info
details
minutiae
spew
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSequencerImpl.mm
AVAudioSequencerImpl
NewMusicPlayer(&mPlayer)
NewMusicSequence(&mSequence)
MusicPlayerSetSequence(mPlayer, mSequence)
MusicSequenceSetAUGraph(mSequence, nullptr)
~AVAudioSequencerImpl
CurrentPosition
MusicPlayerGetTime(mPlayer, &theTime)
SetCurrentPosition
MusicPlayerSetTime(mPlayer, currentPosition)
IsPlaying
MusicPlayerIsPlaying(mPlayer, &isPlaying)
GetRate
MusicPlayerGetPlayRateScalar(mPlayer, &theRate)
SetRate
MusicPlayerSetPlayRateScalar(mPlayer, inRate)
HostTimeForBeats
MusicPlayerGetHostTimeForBeats(mPlayer, inBeats, pOutHostTime)
BeatsForHostTime
MusicPlayerGetBeatsForHostTime(mPlayer, inHostTime, pOutBeats)
NumberOfTracks
GetTrackWithIndex
MusicSequenceGetIndTrack(mSequence, inIndex, &theTrack)
GetTempoTrack
MusicSequenceGetTempoTrack(mSequence, &tempoTrack)
GetSecondsForBeats
MusicSequenceGetSecondsForBeats(mSequence, inBeats, &theSeconds)
GetBeatsForSeconds
MusicSequenceGetBeatsForSeconds(mSequence, inSeconds, &theBeats)
~MusicTrackImpl
SetDestinationAudioUnit
MusicTrackSetDestinationAU(mTrack, inUnit.audioUnit, &desc)
SetDestinationMIDIEndpoint
MusicTrackSetDestMIDIEndpoint(mTrack, inEndPoint)
GetDestinationMIDIEndpoint
MusicTrackGetDestMIDIEndpoint(mTrack, &endPoint)
DoSetLengthInBeats
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_TrackLength, &inLength, sizeof(inLength))
DoGetLengthInBeats
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TrackLength, &length, &pLen)
SetLengthInSeconds
MusicTrackGetSequence(mTrack, &seq)
MusicSequenceGetBeatsForSeconds(seq, inLength, &beatLength)
GetLengthInSeconds
MusicSequenceGetSecondsForBeats(seq, DoGetLengthInBeats(), &seconds)
SetOffset
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &inOffset, sizeof(inOffset))
GetOffset
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &offset, &pLen)
SetLoopCount
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, pLen)
GetLoopCount
SetLoopStart
GetLoopStart
SetLoopEnd
GetLoopEnd
EnableLooping
IsLoopingEnabled
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, pLen)
IsMuted
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, &pLen)
Solo
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, pLen)
IsSoloed
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, &pLen)
UseAutomatedParams
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, pLen)
UsesAutomatedParams
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, &pLen)
GetTimeResolution
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TimeResolution, &timeRes, &pLen)
GetIndex
MusicTrackGetSequence(mTrack, &sequence)
MusicSequenceGetTrackIndex(sequence, mTrack, &index)
avas
sequencer_verbose
error %d
RealtimeMessenger.mServiceQueue
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/CoreAudioUtility/Source/Utility/RealtimeMessenger.cpp
PerformAsync
v16@?0^v8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSinkNode.mm
AVAudioSinkNodeImpl
AVAudioSinkNodeImpl::SetOutputFormat(0, format)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioNodeTap.mm
nil != _format
_initialized
AVAudioNodeTap.mm
/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox
AudioFormatGetProperty
AVVCExternalDeviceRecordingEngine
~AVVCExternalDeviceRecordingEngine
prepareRecoding
destroyRecordingEngine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCRecordingEngineMap.mm
AVVCRecordingEngineMap
~AVVCRecordingEngineMap
findEngine
insertEngine
removeEngine
listEngines
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAudioEngineGraph.mm
TraverseGraphNodes
inCurrNode.GetConnection(inDirection, bus, conn)
TraverseGraphNodesBFS
connNode
connNodeFirst
connNodeSecond
TraverseGraphNodesWithLookback
inCurrNode.GetConnection(otherDirection, bus, conn)
InformNodesAboutMixerConnection
inMixerConn.destNode && inMixerConn.destNode->IsMixerNode()
InformNodesAboutMixerDisconnection
UninitializeNode
inGraph.PerformCommand(node, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
InitializeActiveNodesInOutputChain
inGraph.IsNodeInGraph(inNode.NodeImpl())
inGraph.IsValidSourceNode(*startNode)
inGraph.MakeDisconnection(mixerConn.destNode->NodeImpl(), mixerConn.destBus)
InitializeActiveNodesInInputChain
inGraph.GetInputNode() && (&inNode == inGraph.GetInputNode())
false == isInputConnToConverter
inGraph.MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
inGraph.MakeConnection(inputConn)
inGraph.PerformCommand(*inGraph.GetInputNode(), AVAudioEngineGraph::kAUSetInputCallback, &rc, sizeof(rc))
PrepareForConnection
srcNode && inGraph.IsNodeInGraph(srcNode)
destNode && inGraph.IsNodeInGraph(destNode)
srcCurrConn.destNode == NULL || srcCurrConn == inConn
destCurrConn.srcNode == NULL || destCurrConn == inConn
inGraph.PerformCommand(*destNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
PrepareForDisconnection
inGraph.IsNodeInGraph(&inDestNode)
inGraph.PerformCommand(inDestNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
AVAEGraphStateTracker.RunStateQueue
AVAudioEngineGraph.mm
outputNode != nullptr
inputNode != nullptr || outputNode != nullptr
err = PerformCommand(*outputNode, kAUInitialize, NULL, 0)
IsFormatSampleRateAndChannelCountValid(outputHWFormat)
err = _Connect(connNode->NodeImpl(), outputNode->NodeImpl(), 0, 0, format)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainOptimizedTraversal, *GetOutputNode(), isOutputChainActive)
GetOutputNode()->IsInitialized()
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *GetInputNode())
GetInputNode()->IsInitialized()
IsFormatSampleRateAndChannelCountValid(inputHWFormat)
PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
_Uninitialize
(err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0))
(err = MakeConnection(conn, outErr))
(err = PerformCommand(*GetOutputNode(), kAUUninitialize, NULL, 0))
(err = PerformCommand(*GetInputNode(), kAUUninitialize, NULL, 0))
Start
ioNode != NULL
err = PerformCommand(*ioNode, kAUStartIO, NULL, 0)
_Stop
(err = PerformCommand(*ioNode, kAUStopIO, NULL, 0))
nil != inAVNode
inImpl != nil && !IsIONode(inAVNode)
AddIONode
inImpl != nil && IsIONode(inAVNode)
NULL == ioNodeImpl && !IsNodeInGraph(inImpl)
RemoveNode
IsNodeInGraph(inImpl)
!IsRunning() && !graphNode->IsInitialized()
(graphNode->IsNodeState(kAUGraphNodeState_InInputChain) || graphNode->IsNodeState(kAUGraphNodeState_InOutputChain))
!nodeMixerConns.empty() && !hasDirectConnToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus, outErr)
err = MakeDisconnection(currSrcConn.destNode->NodeImpl(), currSrcConn.destBus, outErr)
err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
err = DisconnectInactiveNode(graphNode, true , disjointNodes, outErr)
conn.IsSrcAndDestValid()
graphNode == conn.destNode
err = MakeConnection(conn, outErr)
err = UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
RemoveIONode
(isInputNode && graphNode == GetInputNode()) || (!isInputNode && graphNode == GetOutputNode())
!IsRunning() && !IsInitialized()
err = RemoveNode(inAVNode, outErr)
inAVNode
format.sampleRate == inputHWFormat.sampleRate
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *inputNode)
inSrcAVNode && inDestAVNode
inSrcImpl && inDestImpl
_Connect
IsNodeInGraph(inSrcImpl) && IsNodeInGraph(inDestImpl)
inSrcImpl->NumberOutputs() > 0
inDestImpl->NumberInputs() > 0 || graphNodeDest->CanResizeNumberOfInputs()
!srcNodeMixerConns.empty() && !isSrcNodeConnectedToIONode
!destNodeMixerConns.empty() && !isDestNodeConnectedToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*graphNodeSrc, kAUUninitialize, NULL, 0)
err = MakeDisconnection(inDestImpl, inDestBus)
err = MakeDisconnection(graphNodeSrcCurrConnPoint.node->NodeImpl(), graphNodeSrcCurrConnPoint.bus)
[format isEqual:dstFormat]
inSrcImpl->SetOutputFormat(inSrcBus, dstFormat)
[srcFormat isEqual:format]
inDestImpl->SetInputFormat(inDestBus, srcFormat)
inSrcImpl->SetOutputFormat(inSrcBus, format) && inDestImpl->SetInputFormat(inDestBus, format)
[midiInputImpl->GetOutputFormat(0) isEqual:inSrcImpl->GetOutputFormat(0)]
err = MakeConnection(currentConn)
graphNodeDest != conn.destNode
inSrcAVNode && inDestAVConnectionPoints && inDestAVConnectionPoints.count > 0
IsNodeInGraph(inSrcImpl)
!inSrcNode->IsSplitterNode()
currentConnPoints.size() <= 1
currentConnPoints.size() > 1
avConnPoint
MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*finalSrcNode, kAUUninitialize, NULL, 0)
_DisconnectInput(connPoint.node->NodeImpl(), connPoint.bus)
_Connect(inSrcImpl, [splitter impl], inSrcBus, kAudioUnitElement_Default, format)
RemoveNode(avNode)
PerformCommand(*finalSrcNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
[midiInputImpl->GetOutputFormat(0) isEqual:finalSrcNode->NodeImpl()->GetOutputFormat(0)]
_Connect(finalSrcNode->NodeImpl(), destImpl, srcBus, destBus, format)
UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
inDestAVNode
inDestImpl
_DisconnectInput
IsNodeInGraph(inDestImpl)
!IsRunning()
graphNode != conn.destNode
inSrcAVNode
inSrcImpl
_DisconnectOutput
inImpl
tmpErr = _DisconnectInput(conn.destNode->NodeImpl(), conn.destBus)
inSourceAVNode && inDestAVNodes && inDestAVNodes.count > 0
graphNodeSrc->IsMIDIProcessorNode()
destAVNode
graphNodeDest->IsMusicDevice() || graphNodeDest->IsMusicEffect() || graphNodeDest->IsMIDIProcessorNode()
inSrcImpl->SetOutputFormat(0, newFormat)
PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
err = UpdateGraphAfterReconfig(&disjointNodes, kOutputChainFullTraversal)
PerformCommand(*midiNode, kAUUninitialize, nullptr, 0)
graphNode->IsMIDIProcessorNode()
!graphNode->IsSplitterNode()
!splitterConnPoint.node->IsSplitterNode()
numSplitterConnections == 0 || numSplitterConnections > 1
!connPoint.node->IsSplitterNode()
NodeRenderingStateChanged
GetOutputDeviceLatencyForNode
GraphDescription
RenderToABL
outputNode
InputAvailable
isSink || tap != nullptr
AddPendingConnection
inConn.IsSrcAndDestValid()
RemovePendingConnection
inConn.srcNode || inConn.destNode
MakeConnection
err = MakeDisconnection(inDestImpl, inDestBus, outErr)
err = PerformCommand(*graphNodeDest, kAUMakeConnection, &connection, sizeof(connection))
err = PerformCommand(*graphNodeDest, kAUInitialize, NULL, 0)
err = PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
MakeVirtualConnection
IsNodeInGraph(conn.srcNode) && IsNodeInGraph(conn.destNode)
srcCurrConn.destNode == NULL || srcCurrConn == conn
destCurrConn.srcNode == NULL || destCurrConn == conn
MakeDisconnection
true == graphNodeDest->GetConnection(kUpstream, inDestBus, mixerConn)
DisconnectInactiveNode
false == inNode->IsInitialized()
err = MakeConnection(itInp->srcNode->NodeImpl(), itOut->destNode->NodeImpl(), itInp->srcBus, itOut->destBus, outErr)
UpdateGraphAfterReconfig
conn.srcNode && conn.destNode && conn.destNode->IsMixerNode()
AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainFullTraversal, *conn.srcNode, isChainActive)
MakeConnection(inputConn)
PerformCommand(*inputConn.srcNode, kAUInitialize, NULL, 0)
PerformCommand(*inputConn.destNode, kAUInitialize, NULL, 0)
MakeConnection(conn)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, inTraversalMode, *GetOutputNode(), isChainActive)
LastRenderErrorInChain
startNodeImpl
startNode
(bus%d) %p, {%s} -> 
(bus%d) %p, {%s}
________ %s ________
AVAudioEngineGraph %p: initialized = %d, running = %d, number of nodes = %d
 ******** output chain ********
 ******** input chain ********
 ******** pending connections - output ********
 %s, [%s]
 ******** pending connections - input ********
 ******** other nodes ********
______________________________________
err = MusicSequenceSetAudioGraph(inSequence, _seqGraphImpl)
NodeStateChanged
GetMusicDeviceNode()
RegisterRenderCallback
UnregisterRenderCallback
GetDefaultMusicDevice
outUnit || outDesc
GetOutputAudioUnit
false condition
inGraph.PerformCommand(theNode, AVAudioEngineGraph::kAUSetPropertyMaximumFramesPerSlice, &maxFrames, sizeof(maxFrames))
failed call
realloc failed
GetNumberBuffers
CoreAudioBaseTypes.hpp
GetAudioBufferList().mNumberBuffers == (mStorage.size() - kHeaderSize) / sizeof(AudioBuffer)
inGraph.PerformCommand(midiNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
conn.destNode && conn.destNode->IsMixerNode()
0 == inCurrNode.NumberOfValidConnections(kUpstream)
inNodeUpstream.IsInitialized()
inGraph.MakeDisconnection(inPrevConn->destNode->NodeImpl(), inPrevConn->destBus)
err = PerformCommand(midiInput, kAUInitialize, nullptr, 0)
v16@?0@"NSNotification"8
AVAudioEnvironmentNodeImpl.mm
name
identifier
supportedLanguages
voiceSize
gender
voice
ssmlRepresentation
avat
com.apple.avfaudio.devicetest.service
AVAudioDeviceTest.mm
v24@?0@"NSArray"8@"NSError"16
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioConverter.mm
convert
outputBuffer.frameCapacity >= inputBuffer.frameLength
FillComplexProc
impl->_inputBufferReceived
[impl->_inputBufferReceived.format isEqual: impl->_inputFormat]
ioData->mNumberBuffers == abl->mNumberBuffers
AVVC_PROFILE_Prop_PrepareStart
AVVC_PROFILE_Prop_PrepareEnd
AVVC_PROFILE_Prop_GetPropertiesStart
AVVC_PROFILE_Prop_GetPropertiesEnd
AVVC_PROFILE_Prop_SetSessionActiveStart
AVVC_PROFILE_Prop_SetSessionActiveEnd
AVVC_PROFILE_Prop_SetupRecordQueueStart
AVVC_PROFILE_Prop_SetupRecordQueueEnd
AVVC_PROFILE_Prop_StartRecordingStart
AVVC_PROFILE_Prop_StartRecordingEnd
AVVC_PROFILE_Prop_PlayAlertStart
AVVC_PROFILE_Prop_PlayAlertEnd
AVVC_PROFILE_Prop_RecordQueueStart
AVVC_PROFILE_Prop_RecordQueueEnd
AVVC_PROFILE_Prop_FirstBufferReceived
AVVC_PROFILE_Delta_PrepareAPIStartEnd
AVVC_PROFILE_Delta_GetSessionPropStartEnd
AVVC_PROFILE_Delta_SetSessionActiveStartEnd
AVVC_PROFILE_Delta_SetupRecordQueueStartEnd
AVVC_PROFILE_Delta_StartRecordAPIStartEnd
AVVC_PROFILE_Delta_PlayAlertQueueStartEnd
AVVC_PROFILE_Delta_StartRecordAudioQueueStartEnd
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferDelta
AVVC_PROFILE_Delta_RecordAudioQueueFirstBufferToDelegateCallDelta
AVVCMM
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCMetricsManager.mm
+[AVVCMetricsManager createSharedManager]
+[AVVCMetricsManager destroySharedManager]
+[AVVCMetricsManager sharedManager]
-[AVVCMetricsManager dealloc]
yyyy-MM-dd'T'HH:mm:ss.SSSSSSSZZZZZ
v32@?0@8@16^B24
-[AVVCMetricsManager measureElapseTimeForMetric:block:]
-[AVVCMetricsManager logProfileMetrics:]
configure
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImplV1.mm
configure_v1
setCurrentContext_v1
getCurrentRecordDeviceInfo_v1
getCurrentRecordSettings_v1
enableMetering_v1
updateMeters_v1
getPeakPowerForChannel_v1
getAveragePowerForChannel_v1
isMeteringEnabled_v1
resetEndpointDetector
prepareRecord
prepareRecord_v1
startRecord
startRecord_v1
secondPassCompletionHostTime
createPlaybackQueue
createPlaybackQueue_v1
AVVoiceController_PlaybackQueue
preparePlaybackQueue
preparePlaybackQueue_v1
startPlaybackQueue
startPlaybackQueue_v1
flushAndStopPlaybackQueue
flushAndStopPlaybackQueue_v1
prepareAudioFile_v1
setupAudioFile
setupAudioFile_v1
handleEOF
handleAudioPlaybackStream
handleFileRead
handleEncodedFileRead
getRecordBufferDuration_v1
setRecordBufferDuration_v1
getStartRecordTime_v1
setStartRecordTime_v1
configureAlertOverrides_v1
VCUnlocker
~VCUnlocker
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.mm
AUGraphNodeBase
nil != _avNode
nullptr != _avNodeImpl
ConnectInput
nullptr != srcNode
AddNode
inNode != nil
DisconnectNode
CreateRecordingTap
nil != callbackBlock
nullptr == Tap()
NodeImpl()->SetOutputFormat(bus, format)
 node %p {%s}, '%s'
 inputs = %d
 (bus%d, en%d) <- (bus%d) %p, {%s}, [%s]
 outputs = %d
 (bus%d, en%d) -> (bus%d) %p, {%s}, [%s]
AUGraphNodeBaseV3
RenderBlock()
i44@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36
DestroyMIDIConnection
midiSrc == MIDIInput()
DeallocateInputBlock
false == AUI().IsRunning()
AllocateInputHandler
v36@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28
AUGraphMIDINodeV3
IsMIDIProcessorNode()
SetTapBlock
GetTapBlock()
i36@?0q8C16q20r*28
AUGraphSourceNodeV3
NodeImpl()->IsAVAudioSourceNode()
InputBlock()
AUGraphSinkNodeV3
NodeImpl()->IsSinkNode()
AllocateRenderBlock
receiverBlock
i52@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36@?<i@?^I^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}Iq^{AudioBufferList=I[1{AudioBuffer=II^v}]}>44
AVAEGraphNode.mm
AUGraphMultiBusNode
IsMixerNode() || IsSplitterNode()
GetConnection
nodeBussesVec.size() >= (inBus + 1)
GetConnectionPoint
GetBusForConnectionPoint
nodeBussesVec.size() == nodeVec.size()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.h
InputMutex
bus < _inMutexes.size()
Drums - Bit Brush
Drums - Buffer Beats
Drums - Lo-Fi
Multi - Broken Speaker
Multi - Cellphone Concert
Multi - Decimated 1
Multi - Decimated 2
Multi - Decimated 3
Multi - Decimated 4
Multi - Distorted Funk
Multi - Distorted Cubed
Multi - Distorted Squared
Multi - Echo 1
Multi - Echo 2
Multi - Echo Tight 1
Multi - Echo Tight 2
Multi - Everything is Broken
Speech - Alien Chatter
Speech - Cosmic Interference
Speech - Golden Pi
Speech - Radio Tower
Speech - Waves
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImplV2.mm
prepareRecordForStream_v2
startRecordForStream_v2
stopRecordOnStream_v2
stopRecordForStream_v2
getCurrentStreamStateForStream_v2
getRecordBufferDurationForStream_v2
configureAlertBehaviorForStream_v2
activateAudioSessionForStream_v2
setAudioSessionActive
deactivateAudioSessionWithOptions_v2
setContextForStream_v2
playAlertWithCompletion_v2
getRecordDeviceInfoForStream_v2
getRecordSettingsForStream_v2
isMeteringEnabledForStream_v2
updateMeterLevelForStream_v2
getPeakPowerForStreamAndChannel_v2
getAveragePowerForStreamAndChannel_v2
playAlertWithOverride_v2
playAlertWithOverride_v2_block_invoke
setAnnounceCallsEnabledForStream
setDuckOthersForStream_v2
setSessionState_v1v2
setStartAlertMode_v1v2
setAlertQueueState_v1v2
setStopAlertMode_v1v2
setStopWithErrorAlertMode_v1v2
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioClock.mm
AVAudioClockImpl
_nodeImpl->AUI().AddV2PropertyListener(kAudioUnitProperty_StreamFormat, StreamFormatListener, this)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVMIDIPlayer/AVMIDIPlayer.mm
-[AVMIDIPlayer dealloc]
-[AVMIDIPlayer prepareToPlay]
MusicPlayerPreroll(impl->mPlayer)
-[AVMIDIPlayer isPlaying]
MusicPlayerIsPlaying(impl->mPlayer, &playing)
-[AVMIDIPlayer rate]
MusicPlayerGetPlayRateScalar(impl->mPlayer, &scalar)
-[AVMIDIPlayer setRate:]
MusicPlayerSetPlayRateScalar(impl->mPlayer, rate)
-[AVMIDIPlayer duration]
MusicSequenceGetSecondsForBeats(impl->mSequence, impl->mLength, &durInSeconds)
-[AVMIDIPlayer currentPosition]
MusicPlayerGetTime(impl->mPlayer, &positionInBeats)
MusicSequenceGetSecondsForBeats(impl->mSequence, positionInBeats, &positionInTime)
-[AVMIDIPlayer setCurrentPosition:]
MusicSequenceGetBeatsForSeconds(impl->mSequence, (Float64) currentPosition, &positionInBeats)
MusicPlayerSetTime(impl->mPlayer, positionInBeats)
avmp
avmidiplayer_verbose
MIDIPlayerImpl
CallbackQueue
~MIDIPlayerImpl
start
MusicPlayerStart(mPlayer)
stop
MusicPlayerStop(mPlayer)
finishLoad
MusicSequenceGetAUGraph(mSequence, &graph)
MusicSequenceGetTrackCount(mSequence, &trackCount)
MusicTrackGetProperty(track, kSequenceTrackProperty_TrackLength, &length, &plength)
MusicSequenceSetUserCallback(mSequence, userCallback, this)
SetUpGraph
AUGraphOpen(inGraph)
AUGraphGetNodeCount (inGraph, &nodeCount)
AUGraphGetIndNode(inGraph, i, &node)
AUGraphNodeInfo(inGraph, node, &desc, &unit)
AudioUnitSetProperty (unit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &numFrames, sizeof(numFrames))
AUGraphInitialize(inGraph)
/9luHerXthRoPoNt/PVkTg
AVAudioUnitMIDIInstrument.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitMIDIInstrument.mm
SendProgramChange
true == SendMIDIEvent(kMIDIMessage_ControlChange, 0, bankMSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_ControlChange, bankSelectLSBParam1, bankLSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_PatchChange, programID, 0, 0, channel)
-[AVAudioUnitMIDIInstrument initWithAudioComponentDescription:]
(description.componentType == kAudioUnitType_MusicDevice) || (description.componentType == kAudioUnitType_RemoteInstrument)
-[AVAudioUnitMIDIInstrument startNote:withVelocity:onChannel:]
_IMPL->StartNote(note, velocity, channel)
-[AVAudioUnitMIDIInstrument stopNote:onChannel:]
_IMPL->StopNote(note, channel)
-[AVAudioUnitMIDIInstrument sendController:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ControlChange, controller, controllerValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendPitchBend:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PitchBend, value&0x7F, value>>7, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressure:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ChannelPressure, pressureValue, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressureForKey:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_KeyPressure, key, pressureValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PatchChange, program, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:bankMSB:bankLSB:onChannel:]
_IMPL->SendProgramChange(program, bankMSB, bankLSB, channel)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:data2:]
_IMPL->SendMIDIEvent(midiStatus, data1, data2, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:]
_IMPL->SendMIDIEvent(midiStatus, data1, 0, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDISysExEvent:]
_IMPL->SendMIDISysexEvent((CFDataRef)midiData)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVFAudioCore/AVAudioBuffer.mm
-[AVAudioBuffer initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:]
isPCMFormat(fmt)
bufferList != nullptr
bufferList->mNumberBuffers == numBuffers
-[AVAudioBuffer setByteLength:]
length <= _imp->_byteCapacity
<%@@%p: %d/%d bytes>
-[AVAudioPCMBuffer initWithPCMFormat:frameCapacity:]
AVAudioBuffer.mm
_imp->OwnsMemory() && !_imp->_externalABL.has_value()
-[AVAudioPCMBuffer initWithPCMFormat:bufferListNoCopy:deallocator:]
!_imp->OwnsMemory() && _imp->_externalABL.has_value()
-[AVAudioPCMBuffer setFrameLength:]
length <= _imp->_frameCapacity
-[AVAudioCompressedBuffer initWithFormat:packetCapacity:maximumPacketSize:]
!(fmt.IsLinearPCM() || fmt.mFormatID == kAudioFormatALaw || fmt.mFormatID == kAudioFormatULaw)
maximumPacketSize != 0
-[AVAudioCompressedBuffer setPacketCount:]
length <= _imp->_packetCapacity
ExtendedAudioBufferList_CreateWithFormat failed
ExtendedAudioBufferList_Prepare failed
AVAB
cannot convert to CMAudioFormatDescription %d
<AVAudioFormat %p: %s>
mSampleRate
mFormatID
mFormatFlags
mBytesPerPacket
mFramesPerPacket
mBytesPerFrame
mChannelsPerFrame
mBitsPerChannel
channelLayout
magicCookie
Audio files cannot be non-interleaved. Ignoring setting AVLinearPCMIsNonInterleaved YES.
AVAudioSession
data
outputID
inputID
sampleRate
correlationValue
stimulusURL
outputMode
volume
inputProcessingChain
outputProcessingChain
mode
calculateCrossCorrelationPeak
processSequenceAsynchronously
parallelCrossCorrelationCalculation
graphURL
processingStripURL
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSourceNode.mm
AVAudioSourceNodeImpl
SetInputFormat(0, format)
AVVCAudioQueueRecordingEngine
~AVVCAudioQueueRecordingEngine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCAudioQueueRecordingEngine.mm
AudioQueueRecordInputCallback
AudioQueueRecordPropertyListenerProc
QueueIsRunning
Initialize
setHWSampleRate
asbdForClientSettings
createRecordQueue
With
AVVoiceController_RecordQueue
configureRecordConverterFromSettings
createAudioConverter
setupDSPGraph
prepareRecording
startRecording
startRecording:AudioQueueReset
delay
past
immediate
startRecording : AudioQueueStart
stopRecording
mRecordQueue : AudioQueueStop
destroyRecordEngine
queue : AudioQueueStop
destroyRecordEngine: AudioQueueDispose
enableSiriListeningMode
enableMetering
updateMeterLevels
DeinterleaveAudio
handleRecordQueuePropertyListener
handleAudioInput
setSessionIsRecordingFlag
resetAudioEngine
resetAudioEngine:mRecordQueue: AudioQueueReset
UpdateRecordDeviceOnQueue
getRecordRoute
RecordEncoderInputDataProc
com.apple.speech.voice.Alex
AVSpeechSynthesisIPANotationAttribute
/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle
language
quality
speechString
rate
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
attributedSpeechString
mark
byteSampleOffset
textRange
IPHONE_SIMULATOR_ROOT
CFFIXED_USER_HOME
setDuckOthersOption
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImplV1V2.mm
setDuckOthersOption_v1v2
resetMiniDuckingStateIfPreviouslyEnabled_v1v2
setSessionCategoryModeOptionsAndSampleRateFromMode_v1v2
audioSessionForStreamID
sessionManagerForStreamID
setSessionProperties
setSessionProperties_v1v2
AVVC Rec Queue RunLoop
DispatchQueue
SIMULATOR_ROOT
%s%@
/System/Library/Audio/UISounds/jbl_begin.caf
/System/Library/Audio/UISounds/jbl_confirm.caf
/System/Library/Audio/UISounds/jbl_cancel.caf
Alert
Record
Playback
Session
ControllerImpl
profile_avvc
duck_others
AVVC Client Notification Queue
AVVC ControllerImpl Work Queue
~ControllerImpl
callbackBarrier_v1v2
setNoResumeOnDeactivate_v1v2
setActivationModeAndSessionHWControlFlagsAndOptions_v1v2
getDeviceUIDForHomeOrBluetoothButtonActivation_v1v2
handlePluginDidPublishDevice_v1v2
handlePluginDidUnpublishDevice_v1v2
createRecordingEngine_v1v2
configureAlerts
configureAlerts_v1v2
cleanup
setActivationContext_v1v2
getRecordAndPlaybackRoutes_v1v2
Unknown Playback Route
No Playback Route
checkSession
checkSession_v1v2
AVVCEngine-prepareRecording from checkSession
forceDeactivateSessionAndFixupState_v1v2
B8@?0
deactivateSession_v1v2
AVAudioSessionDeactivate
handleRetrySessionActivationError_v1v2
setSessionActive_v1v2
setSessionActive
unconfigured
AVAudioSessionSetActive
mPlaybackQueue : AudioQueueStop
setSessionActive1
setSessionActive2
getSessionProperties_v1v2
getSessionProperties
getSessionProperties_HWConfig
setupEndpointer_v1v2
getRecordErrorStatus_v1v2
prepareRecordQueue
prepareRecordQueue_v1v2
calculateRecordStartTime_v1v2
configureAlertModeFromModeAndEngine
configureAlertModeFromModeAndEngine_v1v2
handsFree
built-in speaker
Auto
Post-Voice
iMessageGestureToHead
Dictation
Wired/BT ButtonPress
stopRecord
stopRecord_v1v2
waitForAllStopRecordCompletion_v1v2
stopRecordingOnCategoryChange_v1v2
startedRecording
startedRecording_v1v2
doneRecording
doneRecording_v1v2
setAlertURL
playAlert
playAlert_v1v2
createAlertQueue
createAlertQueue_v1v2
AVVoiceController_AlertQueue
primeAlertQueue
primeAlertQueue_v1v2
AudioQueueReset : mAlertQueue
setupAlert
setupAlert_v1v2
startAlertQueue
startAlertQueue_v1v2
mAlertQueue : AudioQueueStart
 but failed
mAlertQueue : AudioQueueStop
destroyAlertQueue
destroyAlertQueue_v1v2
destroyAlertQueue : AudioQueueStop
calculateAlertTimes_v1v2
alertStarted
alertStarted_v1v2
alertFinished
alertFinished_v1v2
AlertAQPropertyListenerProc
AlertAQPropertyListenerProc_v1v2
handleAlertAQPropertyChange
handleAlertAQPropertyChange_v1v2
vibeStartAlertFinished
vibeStartAlertFinished_v1v2
vibeStopAlertFinished
vibeStopAlertFinished_v1v2
VibeAlertCompletionProc
VibeAlertCompletionProc_v1v2
checkForEndpoint_v1v2
HandleDeferredContext_v1v2_block_invoke
HandleConverterError_v1v2
startKeepAliveQueue
stopKeepAliveQueue
handleInterruptStart_v1v2
primary
handleInterruptStop_v1v2
handleRouteChange_v1v2
interrupted
not (yet) active
handleServerDeath_v1v2
handleServerReset_v1v2
destroyPlaybackQueue
destroyPlaybackQueue_v1v2
destroyPlaybackQueue : AudioQueueStop
startedPlaying
donePlaying
PlaybackAQPropertyListenerProc
getEngineTypeAndDeviceIDToUse_v1v2
setContext_v1v2
_createRecordingEngineWithParameters_v1v2
_insertRecordingEngineIntoMap_v1v2
com.apple.avfoundation.avvc
fault_on_streamID_violation
_getCurrentRecordingEngine_v1v2
_lookupEngineForStreamID_v1v2
_lookupEngineForDeviceUUID_v1v2
_invalidateStreamWhenDeviceUnavailable_v1v2
_removeEngineFromMap_v1v2
cleanupDelegateDispatchGroup
ILLEGAL
NotConfigured
Inactive
InteruptedWhileRecording
InteruptedWhilePlaying
Prewarming
Activating
Deactivating
Active
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/ControllerImpl.h
ExternalDevice
AudioQueue
Plugin
Invalid
Uninitialized
Stopped
Starting
Running
Stopping
stopped
starting
active
stopping
Silent
Haptic
Beep
No Override
Mute
setAlertState_v1v2
QueueIsRunning_v1v2
uninit
primed
started
running
inactive
Illegal
'Unknown'
'Override'
'Wake From Sleep'
'No Suitable Route for Category'
'Configuration Change'
operator()
avvc
avvc_debug
debug_level
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVC_Log.cpp
Initialize_Logging_v1v2
debug_encoding
debug_endpoint
debug_callbacks
debug_locking
debug_state
debug_trace
debug_timing
debug_delegate
debug_playback
debug_deviceselect
/System/Library/Frameworks/CoreMedia.framework/CoreMedia
CMAudioFormatDescriptionGetStreamBasicDescription
CMAudioFormatDescriptionCreate
CMAudioFormatDescriptionGetChannelLayout
CMAudioFormatDescriptionGetMagicCookie
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCSessionManager.mm
-[AVVCSessionManager setupOneTimeSessionSettingsForClient:]
setupOneTimeSessionSettingsForClient
-[AVVCSessionManager setSessionActivationContext:]
setSessionActivationContext
-[AVVCSessionManager shouldEnableMiniDucking:withOptions:]
shouldEnableMiniDucking
-[AVVCSessionManager getHypotheticalRouteAndUpdateStates]
getHypotheticalRouteAndUpdateStates
-[AVVCSessionManager setSessionCategoryModeOptionsForActivationMode:withOptions:]
setSessionCategoryModeOptionsForActivationMode
setSessionCategoryModeOptionsFromActivationMode
-[AVVCSessionManager setSessionAudioHWControlFlagsForActivationMode:withOptions:]
setSessionAudioHWControlFlagsForActivationMode
setSessionAudioHWControlFlagsFromActivationMode
-[AVVCSessionManager setSessionSampleRateForActivationMode:]
setSessionSampleRateForActivationMode
setSessionSampleRateFromActivationMode
-[AVVCSessionManager setSessionBufferSize:]
setSessionBufferSize
-[AVVCSessionManager setDuckOthers:mixWithOthers:error:]
setDuckOthersMixWithOthers
setDuckOthers:mixWithOthers
-[AVVCSessionManager setDuckingFadeOutDuration:fadeInDuration:error:]
setDuckingFadeDuration
-[AVVCSessionManager isSessionOutputInWirelessSplitterMode]
isSessionOutputInWirelessSplitterMode
-[AVVCSessionManager enableSmartRoutingConsideration:]
enableSmartRoutingConsideration
-[AVVCSessionManager isAirplayOneOfTheOutputRoutes:]
-[AVVCSessionManager getInputLatency]
getInputLatency
-[AVVCSessionManager getOutputLatency]
getOutputLatency
-[AVVCSessionManager speechDetectionDeviceSampleRate]
speechDetectionDeviceSampleRate
-[AVVCSessionManager setCategory:mode:options:error:]
setCategory:mode:options
-[AVVCSessionManager setCategory:mode:routeSharingPolicy:options:error:]
setCategory:mode:routeSharingPolicy:options
-[AVVCSessionManager clearInputPreferences:]
clearInputPreferences
-[AVVCSessionManager isSessionInSiriCategoryModeAndOptions:]
-[AVVCSessionManager isSessionInSiriCategory]
isSessionInSiriCategory
-[AVVCSessionManager setAudioHardwareControlFlags:error:]
setAudioHardwareControlFlags
-[AVVCSessionManager reporterID]
reporterID
-[AVVCSessionManager setIAmTheAssistant:error:]
setIAmTheAssistant
-[AVVCSessionManager setPreferredSampleRate:error:]
setPreferredSampleRate:error
-[AVVCSessionManager siriInputSource]
siriInputSource
-[AVVCSessionManager setActivationContext:error:]
setActivationContext
-[AVVCSessionManager setActive:withOptions:error:]
setActive
-[AVVCSessionManager getOpaqueSessionID]
getOpaqueSessionID
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
-[AVVCSessionManager setRecordingFromRemoteInput:error:]
setRecordingFromRemoteInput
-[AVVCSessionManager inputNumberOfChannels]
inputNumberOfChannels
BTDetails_SupportsDoAP
BTDetails_SupportsSoftwareVolume
dump_input
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVCAudioCapturer.mm
~AVVCAudioCapturer
/tmp/Assistant/AVVCCapture/
AVVCAudioCapturer_AudioDiagnostics
~AVVCAudioCapturer_AudioDiagnostics
setup
logCaptures
dispose
/usr/local/lib/libAudioDiagnostics.dylib
NewAudioCapturerImpl
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioFile.mm
-[AVAudioFile writeFromBuffer:error:]
buffer != nil
_imp->CheckClientFormatSet()
ExtAudioFileWrite(_imp->_extAudioFile, buffer.frameLength, buffer.audioBufferList)
-[AVAudioFile readIntoBuffer:frameCount:error:]
frames <= buffer.frameCapacity
buffer.frameCapacity != 0
ExtAudioFileRead(_imp->_extAudioFile, &ioFrames, buffer.mutableAudioBufferList)
-[AVAudioFile length]
ExtAudioFileGetProperty(_imp->_extAudioFile, kExtAudioFileProperty_FileLengthFrames, &propSize, &length)
-[AVAudioFile framePosition]
ExtAudioFileTell(_imp->_extAudioFile, &pos)
-[AVAudioFile setFramePosition:]
ExtAudioFileSeek(_imp->_extAudioFile, pos)
AVAudioFileImpl
fileURL != nil
ExtAudioFileOpenURL((CFURLRef)fileURL, &_extAudioFile)
_initCommonReading
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_FileDataFormat, &propSize, &fileASBD)
SetFormats(format, interleaved, fileASBD, avacl)
ReadMagicCookie
_fileFormat
_processingFormat
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &fileID)
ExtAudioFileCreateWithURL((CFURLRef)fileURL, fileType, &fileASBD, NULL, kAudioFileFlags_EraseFile, &_extAudioFile)
ExtAudioFileGetProperty(openFileImpl->_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &openAudioFileID)
ExtAudioFileWrapAudioFileID(openAudioFileID, false, &_extAudioFile)
CheckClientFormatSet()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioNode.mm
-[AVAudioNode installTapOnBus:bufferSize:format:block:]
tapBlock
NULL != engine
-[AVAudioNode removeTapOnBus:]
-[AVAudioNode destinationForMixer:bus:]
mixer
-[AVAudioMixingDestination destinationForMixer:bus:]
GetMixingDestination
inMixerAVNode
WillDisconnectFromMixer
mixingDest
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioNodeImpl.h
AVAE_CheckNodeHasEngine
_engine != nil
aupreset
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitSampler.mm
-[AVAudioUnitSampler loadInstrumentAtURL:error:]
error
-[AVAudioUnitSampler loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:]
-[AVAudioUnitSampler loadAudioFilesAtURLs:error:]
AVAudioIOUnit
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioIONodeImpl.mm
AUI().AddV2PropertyListener(propID, IOUnitPropertyListener, this)
v8@?0
_GetHWFormat
hwFormat
SetOutputFormat
_isInput
IsFormatSampleRateAndChannelCountValid(format)
IsFormatSampleRateAndChannelCountValid(hwFormat)
format.sampleRate == hwFormat.sampleRate
SetInputFormat
!_isInput
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioSequencer.mm
-[AVAudioSequencer(AVAudioSequencer_Player) prepareToPlay]
impl->PrepareToPlay()
-[AVAudioSequencer(AVAudioSequencer_Player) startAndReturnError:]
impl->Start()
-[AVAudioSequencer(AVAudioSequencer_Player) stop]
impl->Stop()
-[AVAudioSequencer loadFromURL:options:error:]
impl->LoadFromFile((CFURLRef)fileURL, (UInt32)options)
-[AVAudioSequencer loadFromData:options:error:]
impl->LoadFromData((CFDataRef)data, (UInt32)options)
-[AVAudioSequencer writeToURL:SMPTEResolution:replaceExisting:error:]
impl->WriteToFile((CFURLRef)fileURL, (SInt32)resolution, replace)
-[AVAudioSequencer dataWithSMPTEResolution:error:]
impl->WriteToData(&outData, (SInt32)SMPTEResolution)
-[AVMusicTrack setNumberOfLoops:]
numberOfLoops != 0
%.6f s
%ld fr (/%.f Hz)
%.6f rs
<AVAudioTime %p: %s %s %s>
/System/Library/Frameworks/AudioToolbox.framework/libAudioDSP.dylib
GetAudioDSPManager
AVAudioUnitDSPGraph.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnitEffect.mm
-[AVAudioUnitEffect initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Effect) || (audioComponentDescription.componentType == kAudioUnitType_MusicEffect) || (audioComponentDescription.componentType == kAudioUnitType_Panner) || (audioComponentDescription.componentType == kAudioUnitType_RemoteEffect) || (audioComponentDescription.componentType == kAudioUnitType_RemoteMusicEffect)
v16@?0q8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioPlayerNode.mm
-[AVAudioPlayerNode scheduleBuffer:atTime:options:completionCallbackType:completionHandler:]
when == nil || when.sampleTimeValid || when.hostTimeValid
-[AVAudioPlayerNode scheduleFile:atTime:completionCallbackType:completionHandler:]
file != nil
-[AVAudioPlayerNode scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:]
stream != nil
startFrame >= 0
numberFrames > 0
-[AVAudioPlayerNode nodeTimeForPlayerTime:]
playerTime == nil || playerTime.sampleTimeValid || playerTime.hostTimeValid
-[AVAudioPlayerNode playerTimeForNodeTime:]
nodeTime == nil || nodeTime.sampleTimeValid || nodeTime.hostTimeValid
AVAudioPlayerNodeImpl.CompletionHandlerQueue
CommandQueue
StartImpl
AVAudioPlayerNode.mm
_engine->IsRunning()
player started when in a disconnected state
player did not see an IO cycle.
nearFutureTime.sampleTimeValid
when.hostTimeValid
inTimeFull.sampleTimeValid
avpln
avpln_verbose
ScheduleBuffer
_outputFormat.channelCount == buffer.format.channelCount
HandleCompletionOfCommand
completionHandler != nil
bufferFromFileInfo.has_value()
CallCompletionHandler
completionHandler
SignalEndOfRender
completionHandlerWrapperPtr && completionHandlerWrapperPtr->Block()
ResolveToPlayerSampleTime
playerTime && playerTime.sampleTimeValid
has_borealis_xpc
AVVoiceTriggerClient init
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVVoiceController/AVVoiceTriggerClient.mm
-[AVVoiceTriggerClient init]
dealloc
-[AVVoiceTriggerClient dealloc]
-[AVVoiceTriggerClient callServerCrashedBlock]
-[AVVoiceTriggerClient callServerResetBlock]
handleMediaServerReset:
voiceTriggerPastDataFramesAvailableCompletion
getInputChannelInfoCompletion
voiceTriggerPastDataFramesAvailable
v24@?0Q8@"NSError"16
-[AVVoiceTriggerClient voiceTriggerPastDataFramesAvailable]
enableVoiceTriggerListening:
v16@?0@"NSError"8
-[AVVoiceTriggerClient enableVoiceTriggerListening:]
enableVoiceTriggerListening:completionBlock:
-[AVVoiceTriggerClient enableVoiceTriggerListening:completionBlock:]
Enable
Disable
enableSpeakerStateListening:completionBlock:
-[AVVoiceTriggerClient enableSpeakerStateListening:]
speakerStateActiveCompletionBlock:
speakerStateActive
v20@?0B8@"NSError"12
-[AVVoiceTriggerClient speakerStateActive]
speakerStateMutedCompletionBlock:
speakerStateMuted
-[AVVoiceTriggerClient speakerStateMuted]
hasBargeInSupportCompletionBlock:
hasBargeInSupport
-[AVVoiceTriggerClient hasBargeInSupport]
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:completionBlock:
listeningEnabledCompletionBlock:
siriClientRunningCountCompletionBlock:
com.apple.coreaudio.avfaudio.workloop(
%s %s %s
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioUnit.mm
+[AVAudioUnit instantiateWithComponentDescription:options:completionHandler:]
comp != NULL
v20@?0^{OpaqueAudioComponentInstance=}8i16
AVAudioEngineConfigurationChangeNotification
com.apple.avfaudio
avae
avae_verbose
AVAudioEngine.mm
engine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AVAudioEngine.mm
AttachNode
node != nil
!IsInternalNode(node)
nil == owningEngine || GetEngine() == owningEngine
nodeimpl->HasEngineImpl()
DetachNode
!nodeimpl->HasEngineImpl()
GetIOUnit
!IsInManualRenderingMode()
GetOutputNode
_outputNode != nil
GetInputNode
_inputNode != nil
UpdateOutputNode
[_outputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_outputNode)
UpdateInputNode
[_inputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_inputNode)
UpdateIONodesForVP
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:false forceIOUnitReset:true]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:true forceIOUnitReset:true]
Connect
node1 != nil && node2 != nil
node1 != node2
[_nodes containsObject: node1] && [_nodes containsObject: node2]
ConnectMultipleOutputs
nil != sourceNode && nil != destNodes && [destNodes count] > 0
[_nodes containsObject: sourceNode]
object && [object isKindOfClass: [AVAudioConnectionPoint class]]
[_nodes containsObject: connPoint.node]
sourceNode != connPoint.node
DisconnectInput
[_nodes containsObject: node]
_graph->DisconnectInput(node, bus)
DisconnectOutput
_graph->DisconnectOutput(node, bus)
DisconnectAllInputs
_graph->DisconnectAllInputs(node)
DisconnectAllOutputs
_graph->DisconnectAllOutputs(node)
ConnectMIDI
node1 != nil && node2 != nil && node1 != node2
object && [object isKindOfClass: [AVAudioNode class]]
DisconnectMIDI
sourceNode != nil && destNode != nil
sourceNode != nil && destNodes != nil && destNodes.count > 0
_graph->DisconnectMIDI(sourceNode, destNodes)
DisconnectAllMIDIInputs
_graph->DisconnectAllMIDIInputs(node)
DisconnectAllMIDIOutputs
_graph->DisconnectAllMIDIOutputs(node)
GetInputConnectionPointForNode
node != nil && [_nodes containsObject: node]
GetOutputConnectionPointsForNode
Uninitialize
_graph->Uninitialize(outErr)
Pause
_graph->Stop(outErr)
CheckCanPerformIO
canPerformIO
q28@?0I8^{AudioBufferList=I[1{AudioBuffer=II^v}]}12^i20
CreateGraphNode
_graph->AddNode(inNode)
DestroyGraphNode
_graph->RemoveNode(inNode, outErr)
InstallTapOnNode
_graph->InstallTapOnNode(inNode, bus, bufferSize, format, tapBlock)
RemoveTapOnNode
_graph->RemoveTapOnNode(inNode, bus)
SetSequence
_graph->SetSequence(inSequence)
 node: 
 (bus: 
AVFormatIDKey
AVSampleRateKey
AVNumberOfChannelsKey
AVLinearPCMBitDepthKey
AVLinearPCMIsBigEndianKey
AVLinearPCMIsFloatKey
AVLinearPCMIsNonInterleaved
AVAudioFileTypeKey
AVEncoderQualityKey
AVEncoderQualityForVBRKey
AVEncoderBitRateStrategyKey
AVEncoderBitRateKey
AVEncoderBitRatePerChannelKey
AVEncoderBitDepthHintKey
AVSampleRateConverterAlgorithmKey
AVSampleRateConverterQualityKey
AVChannelLayoutKey
AVAudioBitRateStrategy_Constant
AVAudioBitRateStrategy_LongTermAverage
AVAudioBitRateStrategy_VariableConstrained
AVAudioBitRateStrategy_Variable
AVSampleRateConverterAlgorithm_Normal
AVSampleRateConverterAlgorithm_Mastering
AVSampleRateConverterAlgorithm_MinimumPhase
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/AVFAudio-522.70/Source/AVFAudio/AVAudioEngine/AUInterface.mm
AddRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &inRenderCallback, sizeof(inRenderCallback))
RemoveRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &rcb, sizeof(rcb))
AUInterfaceBaseV3
comp != nullptr
AudioComponentInstanceNew(comp, &_auv2)
_auv2 != nullptr
_auv3 == nil
_auv3 != nil
nil != midiEventBlock
SetFormat
[[busArray objectAtIndexedSubscript:(NSUInteger)element] setFormat:format error:&nsErr]
SetNumberInputs
[[auv3() inputBusses] setBusCount:(NSUInteger)numberInputs error:&nsErr]
SetNumberOutputs
[[auv3() outputBusses] setBusCount:(NSUInteger)numberOutputs error:&nsErr]
SendMIDIEvent
nil != ScheduleMIDIEventBlock()
nullptr != midiBytes
AddRenderObserver
inRenderCallback.inputProc
v32@?0I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}12I20q24
AVAEInternal.h
true
false
%s: returned %s, error %@
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
%25s:%-5d required condition is false: [%s:%d:%s: (%s)]
%s:%d:%s: CarPlay API not available
%s:%d:%s: AVOutputContext API not available
%s:%d:%s: supportsMultipleBTDevices: %d
%s:%d:%s: Wireless Output Devices: %@
%s:%d:%s: AVOutputDevice %p supports BT sharing: %d
%s:%d:%s: RegisterObject: registering %p
%s:%d:%s: UnregisterObject: unregistering %p
 ASSERTION FAILED: unregistering a nonexistent object!
%s:%d:%s: CurrentRoute: %@
%s:%d:%s: PreviousRoute: %@
%s:%d:%s: RouteChangeReason: %s
%s:%d:%s: *** InitializePlugins *** %p 
%s:%d:%s: Plugin Bundle URL: %@
%s:%d:%s: initialized plugin class %@
%s:%d:%s: Unable to create the plugin bundle
%s:%d:%s: dealloc : releasing all plugins *** %p
%s:%d:%s: invalidatePlugins : invalidating all plugins *** %p
%s:%d:%s: calling invalidate on plugin instance %p
%s:%d:%s: Searching plugin path %@
%s:%d:%s: Error enumerating the remote input bundles at %@: %@
%s:%d:%s: plugin(%p) - device(%p) - id: %@
%s:%d:%s: Device(%p). Identifier: %@
%s:%d:%s: Cannot find Remote Input device %@
%s:%d:%s: findDeviceWithIdentifier: found the device %@
%s:%d:%s: Device(%p). Identifier: %@ (num devices = %d)
%s:%d:%s: self(%p) controller(%p) plugin(%p), did publish device(%p) with id(%@)
%s:%d:%s: ERROR: Received didPublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%s:%d:%s: WARNING: Not forwarding didPublish event to AVVC parent because it does not exist, or is deallocating.
%s:%d:%s: self(%p) controller(%p) plugin(%p), did UNpublish device(%p) with id(%@)
%s:%d:%s: ERROR: Received didUNpublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%s:%d:%s: WARNING: Not forwarding didUNpublish event to AVVC parent because it does not exist, or is deallocating.
%s:%d:%s: self(%p) controller(%p)
%s:%d:%s: couldn't find mock plugin
%s:%d:%s: mock plugin endpoint (%@)
%s:%d:%s: AVVCPluginRecordingEngine()
%s:%d:%s: ~AVVCPluginRecordingEngine()
%s:%d:%s: finding the first device for activation mode (%{audio:4CC}d)  : %p
%s:%d:%s: device identifier shouldn't be NULL... 
%s:%d:%s: device identifier : %@
%s:%d:%s: setHWSampleRate() streamID(%lu) sr(%.2f) upSamp(%d)
%s:%d:%s: session state (%s), rec-engine [%@], rec-engine type (%s), stream state (%s), alert state (%s)
%s:%d:%s: (self %p)startRecord : using activeDevice: %p
%s:%d:%s: #### calling startRecordingWithCompletionBlock on device (%p) ####
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING
%s:%d:%s: startedRecording: nil recording engine. Bailing
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING-PAUSED
%s:%d:%s: startRecordingWithCompletionBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%s:%d:%s: AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: returned error(%d) : %@. Setting the audioInputBlock to nil.
%s:%d:%s: startRecordQueue:  No device found, err : %d
%s:%d:%s: AVVCPluginRecordingEngine::stopRecording: mRecordIsStopping set to true
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: doneRecording: nil recording engine. Bailing
%s:%d:%s: AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: stopRecording:  No device found error :%d
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Entering --->
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine: about to call stopRecordingCompletionBlock - previous stop completion block didn't happen
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine -- stopRecordingWithCompletionBlock: STOPPED
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine - stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  calling doneRecording manually
%s:%d:%s: AVVCPluginRecordingEngine::destroyRecordEngine:  skipping doneRecording as we are deallocating
%s:%d:%s: destroyRecordEngine: device found, err : %d
%s:%d:%s: (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Exiting <---
%s:%d:%s: AVVCPluginRecordingEngine::createRecordQueue : no matching device found, error : %d
%s:%d:%s: supported Formats[%d] : %@ 
%s:%d:%s: Using Format[0] : %@ 
%s:%d:%s: No Format specified.. Error
%s:%d:%s: clientRequestedSR was:%.2f, setting to %.2f
%s:%d:%s: clientRequestedSR was not specified, setting to %.2f
%s:%d:%s: AVVCPluginRecordingEngine(%p)::createRecordQueue -->
%s:%d:%s: createRecordQueue : using device %p
%s:%d:%s: createRecordQueue : setting format on active device(%p), format:%@
%s:%d:%s: Record queue state does not match queue (previously assertion failure)
%s:%d:%s: audioInputBlock (lpcm) called with frameLength : %d
%s:%d:%s: audioInputBlock (opus / speex) called with packetcount : %d
%s:%d:%s: audioInputBlock called with an unsupported audio format ID (%lu).
%s:%d:%s: audioInputBlock called
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: timeStamp : %f
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: Nil VoiceActivity NSData
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: inGain : %f
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: No Gain Value
%s:%d:%s: AVVCPluginRecordingEngine::audioInputBlock: No frame qualities.
%s:%d:%s: handleRecordInput: nil recording engine. Bailing
%s:%d:%s: statusChangeBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%s:%d:%s: In AVVCPluginRecordingEngine::handleRecordInput: %u frames, hostTime : %lld, sampletime : %f
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput: record internally stopped, so throwing away buffer. StreamState(%s). RecordCancelled(%d)
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput - recordState is active, but getting nil buffer
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (opus). bufferLength : %d, packetCount : %d, packetDesc.startOffset %lld, packetDesc.mVariableFramesInPacket %u, packetDesc.DataByteSize = %u
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (opus): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%s:%d:%s: Setting up client buffer
%s:%d:%s: Copying BT audio buffer, size %u
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput (speex): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%s:%d:%s: AVVCPluginRecordingEngine::handleRecordInput - Unsupported formatID: %u
%s:%d:%s: Exiting AVVCPluginRecordingEngine::handleRecordInput
%s:%d:%s: AVVCPluginRecordingEngine::getRecordRoute : no matching device found, error : %d
%s:%d:%s: active device doesn't support remoteInputDeviceName property
%s:%d:%s: >> %s
%s:%d:%s: << %s
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine[%@]. self(%p)
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine: recordDeviceName(%@)
%s:%d:%s: AVVCRecordDeviceInfo initWithRecordingEngine: remoteDeviceUUID(%@)
%s:%d:%s: AVVCRecordDeviceInfo initWithVoiceController: remoteDeviceCategory(%d)
%s:%d:%s: AVVCRecordDeviceInfo dealloc. self(%p)
%s:%d:%s: setSessionNotifications: setting up notifications for %s session(%p)
%s:%d:%s: removeSessionNotifications: removing all notifications for %s session(%p)
%s:%d:%s: #### hardwareConfigChanged: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
 ASSERTION FAILED: handleInterruption_v1v2: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleInterruption_v1v2: %s session (%p), %@
 ASSERTION FAILED: handleRouteChange_v1v2: called with NULL impl!
%s:%d:%s: #### AVVoiceController handleRouteChange_v1v2: %s session (%p)
 ASSERTION FAILED: handleMediaServerDeath: called with NULL impl!
 ASSERTION FAILED: handleMediaServerReset: called with NULL impl!
%s:%d:%s: Error! handlePluginDidPublishDevice: ControllerImpl is NULL
%s:%d:%s: Error! handlePluginDidUNpublishDevice: ControllerImpl is NULL
%s:%d:%s: #### beganRecording: (success = %d status = %d streamID = %llu) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartRecording: variants
%s:%d:%s: finishedRecording -> called after AVVC object destroyed -- ignoring call and possibly leaking ControllerImpl
%s:%d:%s: finishedRecording -> called after dealloc -- ignoring call
%s:%d:%s: #### AVVoiceController: Recording finished (success = %d status = %d streamID = %llu) ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopRecording:forReason:
%s:%d:%s: startpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### startpointDetected: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectStartpoint:
%s:%d:%s: interspeechPointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### interspeechPointDetected: time %.2f seconds ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidDetectEndpoint:ofType:
%s:%d:%s: endpointDetected -> called after object destroyed -- ignoring call
%s:%d:%s: #### endpointDetected: time %.2f seconds ####
%s:%d:%s: #### beganPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStartPlaying:successfully:
%s:%d:%s: finishedPlaying -> called after AVVC object destroyed -- ignoring call and possibly leaking ControllerImpl
%s:%d:%s: #### finishedPlaying: ####
%s:%d:%s: WARNING: delegate is nil or does not respond to voiceControllerDidStopPlaying:forReason:
%s:%d:%s: Calling alert playback finished delegate. Settings { Type: %d, Mode: %d, alertEndTime: %llu }
%s:%d:%s: Calling alert playback finished delegate. Type: %d
%s:%d:%s: Notifying streamHandle(%lu) invalidated
%s:%d:%s: streamHandle(%lu) invalidated but no record delegate, or notify selector not supported
%s:%d:%s: Calling record delegate's voiceControllerWillSetAudioSessionActive. Going active? : %d
%s:%d:%s: Calling record delegate's voiceControllerDidSetAudioSessionActive. Going active? : %d
%s:%d:%s: setStopOnBargeInEnabled: barge-in previously detected -- stopping playback
%s:%d:%s: prepareRecordWithSettings should be called first before asking for number of channels
%s:%d:%s: [enforce 1 avvc] retain AVVC(%p), count-before-retain(%d)
%s:%d:%s: [enforce 1 avvc] release AVVC(%p), count-before-release(%d)
%s:%d:%s: [enforce 1 avvc] #### AVVoiceController: initWithContext: [self == %p]. with context:%{audio:4CC}d %@
%s:%d:%s: initWithContext: ControllerImpl() failed with error: %ld
%s:%d:%s: initWithContext: calling setSessionProperties
%s:%d:%s: AVVoiceController: initWithContext failure
%s:%d:%s: #### initWithContext finished [self = %p] ####
%s:%d:%s: #### AVVoiceController: prewarmAudioSession: ####
%s:%d:%s: [enforce 1 avvc] #### AVVoiceController: dealloc [self == %p] ####
%s:%d:%s: #### AVVoiceController: exiting dealloc ####
%s:%d:%s: #### AVVoiceController: releaseAudioSession: [self = %p] ####
%s:%d:%s: #### AVVoiceController: releaseAudioSession:options [self = %p] ####
%s:%d:%s: #### AVVoiceController: enableMiniDucking: %d
%s:%d:%s: #### AVVoiceController: willAcceptContext: with context:%{audio:4CC}d %@
%s:%d:%s: ### unimplemented in this platform
%s:%d:%s: #### AVVoiceController[self = %p]: setCurrentContext: with context:%{audio:4CC}d %@
%s:%d:%s: #### setCurrentContext:error finished [self = %p]####
%s:%d:%s: #### AVVoiceController[self = %p]: prepareRecordWithSettings: %@ 
%s:%d:%s: prepareRecordWithSettings failed with internal error %s
%s:%d:%s: #### prepareRecordWithSettings finished ####
%s:%d:%s: #### AVVoiceController: setAlertSoundFromURL: forType: %d ####
%s:%d:%s: setAlertSoundFromURL:forType: Illegal alertType
%s:%d:%s: call to playAlertSoundForType blocked because mediaserverd is dead
%s:%d:%s: #### AVVoiceController: playAlertSoundForType: %d [self = %p]####
%s:%d:%s: playAlertSoundForType: Session check failed: %s
%s:%d:%s: playAlertSoundForType: Illegal alertType
%s:%d:%s: #### AVVoiceController: resetEndpointer ####
%s:%d:%s: #### AVVoiceController: playRecordStartingAlertAndResetEndpointer ####
%s:%d:%s: #### AVVoiceController::playRecordStartingAlertAndResetEndpointer current Context  %@ ####
%s:%d:%s: #### AVVoiceController: startRecording [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecording:(NSError **) [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecordingAtTime:error : %d [self = %p]####
%s:%d:%s: #### AVVoiceController: startRecordingAtTime:error [self = %p]####
%s:%d:%s: #### AVVoiceController:[self = %p] startRecordingWithSettings:error %@
%s:%d:%s: AVVoiceController: startRecordingWithSettings: Ignoring old style alert behavior
%s:%d:%s: #### AVVoiceController:[self = %p] startRecordingWithSettings:error = %d
%s:%d:%s: #### AVVoiceController: stopRecording ####
%s:%d:%s: #### AVVoiceController: preparePlaybackWithSettings %@ 
%s:%d:%s: preparePlaybackWithSettings: Can't perform this action while playback is active
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackWithSettings: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: #### AVVoiceController: preparePlaybackFromURL: %@ ####
%s:%d:%s: preparePlaybackFromURL: audio is already playing
%s:%d:%s: #### AVVoiceController: startPlaying ####
%s:%d:%s: Attempt to play audio without configuring format
%s:%d:%s: startPlaying: called while already playing -- stopping previous play
%s:%d:%s: #### AVVoiceController: stopPlaying ####
%s:%d:%s: #### AVVoiceController: setRecordDelegate: %p ####
%s:%d:%s: #### AVVoiceController: setRecordBufferDuration: %f ####
%s:%d:%s: #### AVVoiceController: setEndpointerDelegate ####
%s:%d:%s: #### setEndpointerDelegate: using %s endpointer ####
%s:%d:%s: #### AVVoiceController: setRecordEndpointMode: %d ####
%s:%d:%s: #### AVVoiceController: recordStartWaitTime: %f ####
%s:%d:%s: setPlaybackDelegate: Cannot set while playback is active
%s:%d:%s: #### AVVoiceController: setPlaybackBufferDuration: %f ####
%s:%d:%s: setPlaybackBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: isRecording: rec-engine type: %s, stream state: %s
%s:%d:%s: #### AVVoiceController: setAlertVolume: %f ####
%s:%d:%s: #### AVVoiceController: setPlaybackVolume: %f ####
%s:%d:%s: #### AVVoiceController: setMeteringEnabled: %d ####
%s:%d:%s: setStopOnEndpointEnabled: endpoint previously detected -- stopping capture
%s:%d:%s: #### AVVoiceController: currentRecordDeviceInfo. self(%p) ####
%s:%d:%s: [enforce 1 avvc] #### AVVoiceController: initWithError (V2): [self == %p]
%s:%d:%s: initWithError: Failed to create ControllerImpl or configureAlerts - error (%ld)
%s:%d:%s: #### AVVoiceController[self = %p]: setContext: activationMode(%@), deviceUID(%@)
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%s:%d:%s: #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: startRecordWithSettings: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d)
%s:%d:%s: #### AVVoiceController[self = %p]: startRecordForStream: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d,%s)
%s:%d:%s: #### AVVoiceController[self = %p]: configureAlertBehaviorForStream: streamHandle(%lu), AlertsOverride(%d,%d,%d)
%s:%d:%s: !! DEPRECATED !! #### AVVoiceController[self = %p]: stopRecordOnStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: stopRecordForStream: streamHandle(%lu)
%s unexpected error (%d) returned from stopRecordForStream
%s:%d:%s: #### AVVoiceController[self = %p]: getCurrentStreamState: streamHandle(%lu). State(%s)
%s:%d:%s: #### AVVoiceController[self = %p]: getRecordDeviceInfoForStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d), switchRecordMode(%d). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: deactivateAudioSessionWithOptions(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: deactivateAudioSessionForStream:(%d) withOptions(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: setContextForStream: activationMode(%@), deviceUID(%@). streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: playAlert alertType(%d). overrideMode(%d)
%s:%d:%s: #### AVVoiceController[self = %p]: playAlertSoundForStream: alertType(%d) overrideMode(%d)
%s:%d:%s: playAlertSoundForStream failed with error : %d
%s:%d:%s: #### AVVoiceController[self = %p]: setRecordStatusChangeBlock
%s:%d:%s: #### AVVoiceController[self = %p]: enableSmartRoutingConsideration: streamHandle(%lu), enable : %d
%s:%d:%s: #### AVVoiceController[self = %p]: setAnnounceCallsEnabledForStream: streamHandle(%lu), enable : %d
%s:%d:%s: #### AVVoiceController[self = %p]: getInputChannelInfoForStream: streamHandle(%lu)
%s:%d:%s: #### AVVoiceController[self = %p]: setDuckOthersForStream: streamHandle(%lu), duckSettings(%@)
%s:%d:%s: about to lock %s
%s:%d:%s: about to unlock %s
%s:%d:%s: [enforce 1 avvc] before wait controller(%p), %@
%s:%d:%s: [enforce 1 avvc] after wait%s controller(%p), %@
%s:%d:%s: [enforce 1 avvc] Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously
[enforce 1 avvc] %s Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously. Controller(%p)
%s:%d:%s: [enforce 1 avvc] created gsAVVCSingleInstanceSemaphore %@
%s:%d:%s: %s : %s : start: %s end: %s duration %.2f ms
%s:%d:%s: %s : start: %s end: %s duration %.2f ms
%s:%d:%s: [enforce 1 avvc] before signal avvc(%p), %@
%s:%d:%s: [enforce 1 avvc] after signal avvc(%p), %@
%s:%d:%s: QualityDetector: Start thresh: %u Start Timeout: %u End thresh: %u  End Timeout: %u
%s:%d:%s: QualityDetector: NONE => ACTIVE
%s:%d:%s: QualityDetector: NoSpeech; End Counter %u / %u
%s:%d:%s: QualityDetector: NONE => ENDED (TIMEOUT AT START)
%s:%d:%s: QualityDetector: Active; End Counter %u / %u
%s:%d:%s: QualityDetector: Active; Watching for end point (current frame quality: %u)
%s:%d:%s: QualityDetector: ACTIVE => ENDED
%s:%d:%s: QualityDetector: ACTIVE => ENDING
%s:%d:%s: QualityDetector: Speech Ending; End Counter %u / %u
%s:%d:%s: QualityDetector: ENDING => ACTIVE
%s:%d:%s: QualityDetector: ENDING => ENDED
 ASSERTION FAILED: inPastFrameCount <= mFrameHistoryLength
%s:%d:%s: QualityDetector: Start Timeout: %u frames
%s:%d:%s: QualityDetector: Interspeech Timeout: %u frames
%s:%d:%s: QualityDetector: End Timeout: %u frames
%s:%d:%s: SpeexEndpointer init:
%s:%d:%s: SpeexEndpointer dealloc:
%s:%d:%s: SpeexEndpointer configureWithSampleRate:
%s:%d:%s: SpeexEndpointer configureWithSampleRate:andFrameRate: illegal frame rate!
%s:%d:%s: SpeexEndpointer configureWithASBD:andFrameRate
%s:%d:%s: SpeexEndpointer setEndpointMode: %d
%s:%d:%s: SpeexEndpointer setStartWaitTime: %f
%s:%d:%s: SpeexEndpointer setInterspeechWaitTime: %f
%s:%d:%s: SpeexEndpointer setEndWaitTime: %f
 ASSERTION FAILED: getStatus called before object was configured!
%s:%d:%s: SpeexEndpointer getStatus: Raw Speex qlty frame %d/%d: %.2f rnng avrg: %.2f, med: %.2f, cls: %d
%s:%d:%s: #### SpeexEndpointer: Detected start point ####
%s:%d:%s: #### SpeexEndpointer: Detected soft end point ####
%s:%d:%s: #### SpeexEndpointer: Detected hard end point ####
 PackednessIsSignificant only applies for PCM
 CAMutex::CAMutex: Could not init the mutex
 CAMutex::Lock: Could not lock the mutex
 CAMutex::Unlock: Could not unlock the mutex
 CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own
 CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)
 CAPThread::SetPriority: failed to set the fixed-priority policy, Error: 0x%X
 CAPThread::SetPriority: failed to set the precedence policy, Error: 0x%X
 CAPThread::SetTimeConstraints: thread_policy_set failed, Error: %d (%s)
 CAPThread::Start: can't start because the thread is already running
 CAPThread::Start: Thread attributes could not be created.
 CAPThread::Start: A thread could not be created in the detached state.
 CAPThread::Start: Could not create a thread.
%s:%d:%s: Trigger clean up of context(%s, %@)
%s:%d:%s: AVVCRecordingEngine():~AVVCRecordingEngine() called
%s:%d:%s: reconfigure for streamID(%lu) failed to destroy engine (%d)
%s:%d:%s: reconfigure for streamID(%lu) failed to prepareRecording (%d)
%s:%d:%s: Settings are nil, rebuilding queue
%s:%d:%s: prepareRecord: NEW FORMAT: %s
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %d
%s:%d:%s: ERROR: prepareRecord: createRecordQueue err %{audio:4CC}d
%s:%d:%s: Formats differ, rebuilding queue
%s:%d:%s: prepareRecord: CURRENT FORMAT: %s
%s:%d:%s: destroying engine because of record error: %d
%s:%d:%s: Cached session pointer (%p) for engine(%d, %p)
%s:%d:%s: Cached session manager pointer (%p) for engine(%d, %p)
%s:%d:%s: AudioQueueGetProperty kAudioConverterSampleRateConverterQuality failed: %d
%s:%d:%s: AudioQueueGetProperty kAudioConverterPropertyBitDepthHint failed: %d
%s:%d:%s: AudioQueueGetProperty property size of kAudioQueueProperty_ChannelLayout failed: %d OR property size is 0
%s:%d:%s: AudioQueueGetProperty returned %d for kAudioQueueProperty_ChannelLayout property size
%s:%d:%s: AudioQueueGetProperty kAudioQueueProperty_ChannelLayout failed: %d
%s:%d:%s: AudioQueueGetProperty returned (%p) for kAudioQueueProperty_ChannelLayout bytes
%s:%d:%s: setStreamState (%s => %s)
%s:%d:%s: setRecordErrorStatus: %ld
%s:%d:%s: setRecordBufferDuration: Attempting to setRecordBufferDuration while record is active. Stream State(%s)
%s:%d:%s: setRecordBufferDuration: specified buffer duration too small -- setting to minimum allowed
%s:%d:%s: setRecordBufferDuration: rebuilding queue
%s:%d:%s: setRecordBufferDuration: Failed at prepareRecording (reconfig) : %d
%s:%d:%s: setRecordBufferDuration: duration now %.3f
%s:%d:%s: getRecordBufferDuration: choice 1 mRecordBasePacketsPerSecond (%lu)
%s:%d:%s: getRecordBufferDuration: choice 2 mRecordBasePacketsPerSecond (%lu)
%s:%d:%s: getRecordBufferDuration: returning %.3f seconds
%s:%d:%s: getPeakPowerForChannel on stream(%llu): returning %f for channel %d
%s:%d:%s: getAveragePowerForChannel on stream(%llu): returning %f for channel %d
%s:%d:%s: AVVCRecordingEngine::cacheRecordRoute : %@
%s:%d:%s: setStartRecordCompletionAndAudioCallbackBlocks: startCompletionBlock(%p). audioCallbackBlock(%p)
%s:%d:%s: setStopRecordCompletionBlock: stopCompletionBlock(%p).
%s:%d:%s: setDidStopDelegateCompletionBlock: didStopCompletionBlock(%p).
%s:%d:%s: calling (v2) voiceControllerLPCMAudioCallback:forStream:buffer:
%s:%d:%s: calling (v2) voiceControllerAudioCallback:forStream:buffer:
%s:%d:%s: Calling audioCallbackBlock for streamID(%lu) with mAudioDataByteSize: %u
%s:%d:%s: calling lpcmRecordBufferReceived:buffer
%s:%d:%s: calling voiceControllerRecordBufferAvailable:buffer
%s:%d:%s: myBuffer->mAudioData : %p, myBuffer->mAudioDataByteSize : %d
%s:%d:%s: Ignoring action, since streamState is already %s
 ca_verify_noerr: [%s, %d]
%s:%d:%s: _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing session manager(%p) audioSession(%p) for context(%s, %@)
%s:%d:%s: _wqCreateAuxSessionAndManagerForDeviceUID: setActivationContext returned error(%d)
%s:%d:%s: _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing sessionManager(%p)
%s:%d:%s: Created aux session (%p) and session manager (%p) and setup onetime settings for context(%s, %@)
%s:%d:%s: Created primary session manager (%p) and setup onetime settings for context(%s, %@)
%s:%d:%s: _wqSessionForContext: activationDeviceUID must be specified for this mode
%s:%d:%s: First time primary session (%p) retrieved. Context(%s, %@)
%s:%d:%s: retrieved session (%p) and sessionManager (%p) for context(%s, %@)
%s:%d:%s: Clean up context(%s, %@), about to release session(%p) and manager(%p)
%s:%d:%s: Unexpected error cleaning up context: %@
%s:%d:%s: Unexpected missing session when cleaning up context
%s:%d:%s: Can't cleanup because devID is missing in context(%s, %@)
%s:%d:%s: Nothing to clean up for context(%s, %@)
%s:%d:%s: Releasing primary session manager (%p)
%s:%d:%s: ERROR: subscope bits are set in scope: 0x%lx
%s:%d:%s: ---> this = %p
%s:%d:%s: <---
%s:%d:%s: Track's sequence was NULL
%s:%d:%s: Underlying track already destroyed
%s:%d:%s: start -> %.2f [end %.2f]
%s:%d:%s: end -> %.2f [start %.2f]
%s:%d:%s: %sabling looping [%.2f - %.2f]
%25s:%-5d [%s:%d:%s: (%s): error %d
%s:%d:%s: RealtimeMessenger: trying to enqueue duplicate invocation on message %p
%25s:%-5d Error fetching from ring buffer, this = %p, err = %d
%s:%d:%s: AVVCRecordingEngineMap::AVVCRecordingEngineMap() Created new Engine Map
%s:%d:%s: AVVCRecordingEngineMap::~AVVCRecordingEngineMap() Destroyed Engine Map
%s:%d:%s: No recording engine found for stream(%lu)
%s:%d:%s: No matching engine found for nil deviceUUID
%s:%d:%s: Iterating through EngineMap. AVVCStreamHandle(%lu). AVVCRecordEngine[%@]. DeviceUID(%@). EngineType(%s)
%s:%d:%s: Found matching engine of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: No matching plugin engine found for deviceUUID: %@
%s:%d:%s: Added engine[%@] for stream(%llu) to the map of size %ld
%s:%d:%s: Removing engine[%@] for stream(%llu) from the map
%s:%d:%s: Engine for streamID(%llu) not found
%s:%d:%s: Empty Engine Map
%s:%d:%s: Engine[%@] Type:(%s) stream(%llu)
%25s:%-5d AVAudioEngine: left running idle for %.f s
%25s:%-5d AVAudioEngine (auto shutdown mode): left running idle for %.f s, stopping!
%25s:%-5d AVAudioEngine (auto shutdown mode): starting IO dynamically
%25s:%-5d AVAudioEngine (auto shutdown mode): could not dynamically start the audio hardware, err = %s
%25s:%-5d graph@%p: couldn't initialize node@%p {%s}, error %d
%25s:%-5d Can't retrieve source node to play sequence because there is no output node!
%25s:%-5d manual rendering mode, setting output type = external speakers
%25s:%-5d setting output type = headphones
%25s:%-5d setting output type = built-in speakers
%25s:%-5d setting output type = external speakers
%25s:%-5d multiple outputs active, setting output type = external speakers
%25s:%-5d Error creating XPC connection to %@
%25s:%-5d %@
%25s:%-5d Interruption Handler: connection got interrupted
%25s:%-5d Invalidation Handler: client exited
%25s:%-5d starting sequence on client side
%25s:%-5d Issuing sandbox %s for path %s
%25s:%-5d failed to extend the service's sandbox
%25s:%-5d result data %@ output %li input %li sample rate %f
%25s:%-5d finishing sequence on client side
%s:%d:%s: AVVCMetricsManager: createSharedManager: referenceCount after incrementing = %llu
%s:%d:%s: AVVCMetricsManager: destroySharedManager : referenceCount after decrementing = %llu
%s:%d:%s: AVVCMetricsManager: sharedInstance is nil !!!!
%s:%d:%s: AVVCMetricsManager: dealloc
%s:%d:%s: Measuring Elapsed Time for %@ : %f ms
%s:%d:%s: Logging PROFILE METRIC : %@
%s:%d:%s: configure: session not configured -- calling setSessionProperties
%s:%d:%s: Overwriting an already-deferred context
%s:%d:%s: setCurrentContext:error: record is active -- deferring the context change
%s:%d:%s: setActivationContext in setCurrentContext failed! %d
%s:%d:%s: createRecordingEngine in setCurrentContext failed! %d
%s:%d:%s: getCurrentRecordDeviceInfo: Current Recording Engine is nil!
%s:%d:%s: getCurrentRecordDeviceInfo: mCurrentRecordDeviceInfo already exists. Deleting old and creating new.
%s:%d:%s: recordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%s:%d:%s: getCurrentRecordSettings: Error, current recording engine is nil!
%s:%d:%s: enableMetering: Current recording engine is nil!
%s:%d:%s: updateMeters: Error, current recording engine is nil!
%s:%d:%s: getPeakPowerForChannel: Error, current recording engine is nil!
%s:%d:%s: isMeteringEnabled: Error, current recording engine is nil!
%s:%d:%s: prepareRecord: Can't perform this action while record is starting or active
%s:%d:%s: prepareRecord: home/uibp/btbp/vehb button activation : after rechecking which engine to use [%@]
%s:%d:%s: createRecordingEngine in prepareRecord_v1 failed : %d
%s:%d:%s: prepareRecord: recording engine is not selected, %{audio:4CC}d
%s:%d:%s: startListen: Current recording engine is nil! Bailing!
%s:%d:%s: SECOND PASS-Start Record Delta %f ms
%s:%d:%s: Attempt to start recording without calling prepareRecordWithSettings:
%s:%d:%s: startRecord: already starting or active -- no-op
%s:%d:%s: startRecord: failed to play record-start alert. status = %d
%s:%d:%s: startRecord: returning failed record status %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createPlaybackQueue: output queue format:
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %d
%s:%d:%s: ERROR: get kAudioFilePropertyPacketSizeUpperBound err %{audio:4CC}d
%s:%d:%s: createPlaybackQueue: bufferByteSize %u
packetsPerSecond %g
packetSizeUpperBound %u
%s:%d:%s: createPlaybackQueue: bufferByteSize adjusted to %u
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %d
%s:%d:%s: ERROR: set kAudioQueueProperty_MagicCookie err %{audio:4CC}d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createPlaybackQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %d
%s:%d:%s: ERROR: preparePlaybackQueue: createPlaybackQueue err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: enqueued buffer %p mNumPlayBuffersEnqueued %d
%s:%d:%s: preparePlaybackQueue: mNumPlayBuffersEnqueued %d  numFramesPrepared %u  sr %g
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %d
%s:%d:%s: ERROR: preparePlaybackQueue: AudioQueuePrime err %{audio:4CC}d
%s:%d:%s: preparePlaybackQueue: numFramesPrepared %u  mNumPlayBuffersEnqueued %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %d
%s:%d:%s: ERROR: set kAudioQueueParam_Volume err %{audio:4CC}d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startPlaybackQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %d
%s:%d:%s: ERROR: prepareAudioFile: AudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %d
%s:%d:%s: ERROR: prepareAudioFile: setupAudioFile err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %d
%s:%d:%s: ERROR: get kAudioFilePropertyDataFormat err %{audio:4CC}d
%s:%d:%s: setupAudioFile: audio format from file:
%s:%d:%s: %s
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %d
%s:%d:%s: ERROR: get kAudioFilePropertyMagicCookieData err %{audio:4CC}d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: info kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %d
%s:%d:%s: ERROR: get kAudioFilePropertyFormatList err %{audio:4CC}d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %d
%s:%d:%s: ERROR: get kAudioFormatProperty_FirstPlayableFormatFromList err %{audio:4CC}d
%s:%d:%s: handleAudioPlaybackStream: %d buffers now in queue.  Calling client.
%s:%d:%s: handleAudioPlaybackStream: Client filled buffer %p, size %d bytes
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleAudioPlaybackStream: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %d
%s:%d:%s: ERROR: handleFileRead: AudioFileReadPacketData err %{audio:4CC}d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleFileRead: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: >>handleEncodedFileRead requesting: pkt pos %qd, %d packets, %d bytes. bytes capacity: %d  buffer: %p
%s:%d:%s: <<handleEncodedFileRead got %d packets, %d bytes, status %d
%s:%d:%s: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters: trim leading: %d, trim trailing: %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %d
%s:%d:%s: ERROR: handleEncodedFileRead: AudioQueueEnqueueBufferWithParameters err %{audio:4CC}d
%s:%d:%s: getRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%s:%d:%s: setRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%s:%d:%s: getStartRecordTime: Error, current recording engine is nil!
%s:%d:%s: setStartRecordTime: Error, current recording engine is nil!
%s:%d:%s: setStartRecordTime: %llu
%s:%d:%s: configureAlertOverrides: Session is active. configureAlertModeFromModeAndEngine now. Current recording engine [%@], activation mode (%@)
%s:%d:%s: unlocker about to unlock %s
 ASSERTION FAILED: Unlocker attempted to unlock a mutex not owned by the current thread!
%s:%d:%s: unlocker about to relock %s
%25s:%-5d Error setting manual rendering mode input PCM format on input node! %s
%s:%d:%s: prepareRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: ! DEPRECATED ! prepareRecordForStream: Found engine[%@] of type(%s) for streamID(%lu), with activation mode(%@)
%s:%d:%s: prepareRecordForStream: Failed to setRecordBufferDuration
%s:%d:%s: prepareRecordForStream: Error in prepareRecording: %d
%s:%d:%s: prepareRecordForStream: Error in enableMetering: %d
%s:%d:%s: prepareRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: prepareRecordForStream: Found engine[%@] of type(%s) for streamID(%lu), with activation mode(%@)
%s:%d:%s: prepareRecordForStream: Failed to setRecordBufferDuration : %d
%s:%d:%s: startRecordForStream streamID(%lu)
%s:%d:%s: startRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: startRecordForStream: Attempt to start stream(%ld) without calling prepare.
%s:%d:%s: startRecordForStream: Attempt to start stream(%ld) while stream is already %s. No-op.
%s:%d:%s: ERROR in startRecordForStream, failed at playAlert: %d
%s:%d:%s: startRecordForStream: Error in startRecording for stream(%lu): %d
%s:%d:%s: startRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: session (%p) and session mananger (%p) used for engine (%p) with context(%s, %@)
%s:%d:%s: startRecordForStream: Skipping alert playback and continuing to startRecord
%s:%d:%s: stopRecordOnStream streamID(%lu)
%s:%d:%s: stopRecordOnStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: stopRecordOnStream: Attempt to stop on an %s stream.
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is already %s. No-op.
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is about to start. Observe this case. NotifyStartBeforeStop? Not doing anything here at the moment.
%s:%d:%s: stopRecordOnStream: Error stopping record engine: %d
%s:%d:%s: stopRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%s:%d:%s: stopRecordForStream: Attempt to stop on an %s stream.
%s:%d:%s: stopRecord: an error : %d  occurred while recording and we need to synthesize doneRecording
%s:%d:%s: stopRecordOnStream: Attempt to stop while stream is about to start. NotifyStartBeforeStop
%s:%d:%s: stopRecord: record state == kRecordStarting but object being destroyed -- just stop queue
%s:%d:%s: stopRecord: record state == kRecordStarting -- we will need to send a start notify prior to stop
%s:%d:%s: stopRecord: record was just starting -- calling doneRecording ourselves -- watch this case
%s:%d:%s: getCurrentStreamState: Cannot find recording engine for streamID(%lu).
%s:%d:%s: getRecordBufferDurationForStream: Cannot find recording engine for streamID(%lu).
%s:%d:%s: configureAlertBehaviorForStream streamID(%lu)
%s:%d:%s: activateAudioSessionForStream ERROR: Cannot find recording engine for streamID(%lu). Bailing.
%s:%d:%s: About to activate audio session for stream(%lu). Current context: %@
%s:%d:%s: Announce option set for %s activation mode
%s:%d:%s: activateAudioSessionForStream for stream(%lu). isPrewarm(%d). CurrentState(%s).
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionActivationContext: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionBufferSize: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%s:%d:%s: activateAudioSessionForStream ERROR: Failed checkSession at setAudioSessionActive. SessionState(%s). OSStatus(%d).
%s:%d:%s: deactivateAudioSessionWithOptions called on platform without AudioSession. No-op.
%s:%d:%s: ERROR: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: setContextForStream: Error! Incoming engine with streamID(%llu) and activation mode (%d) is different from engine that was used to activate the session, streamID(%llu) amd activation mode (%@)
%s:%d:%s: setContextForStream: Announce option set for %s activation mode
%s:%d:%s: setContextForStream ERROR: Failed at setSessionActivationContext: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%s:%d:%s: setContextForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%s:%d:%s: setContextForStream: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%s:%d:%s: setContextForStream : Session re-activation failed with error : %d
%s:%d:%s: setContextForStream: session re-activated -- calling getSessionProperties
%s:%d:%s: playAlertWithCompletion: called when session inactive--do nothing and return error
%s:%d:%s: playAlertWithCompletion: Illegal alertType
%s:%d:%s: getRecordDeviceInfoForStream: Nil recording engine for streamID(%llu)
%s:%d:%s: StreamID(%llu). RecordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%s:%d:%s: getRecordSettingsForStream: Nil recording engine
%s:%d:%s: isMeteringEnabledForStream_v2: Nil recording engine
%s:%d:%s: getRecordSettingsForStream: Error updating meter levels: %d
%s:%d:%s: playAlertWithOverride: called when session inactive--do nothing and return error
%s:%d:%s: Current Playback Route %@
%s:%d:%s: playAlertWithOverride: calling AudioServicesPlaySystemSoundWithOptions with sound ID %d
%s:%d:%s: playAlertWithOverride: Finished playing the alert beep
%s:%d:%s: setAnnounceCallsEnabledForStream: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: setDuckOthersForStream_v2: Cannot find recording engine for streamID(%lu). Returning.
%s:%d:%s: session state(streamID %d) => %s
%s:%d:%s: setStartAlertMode: %s
%s:%d:%s: alert queue state => %s
%s:%d:%s: setStopAlertMode: %s
%s:%d:%s: setStopWithErrorAlertMode: %s
%s:%d:%s: ---> self = %p
%25s:%-5d Unable to start playing the note %d
%25s:%-5d Unable to stop playing the note %d
%25s:%-5d Unable to send midi event status(%d), channel(%d), param1(%d), param2(%d)
%25s:%-5d format has zero bytes per frame
%25s:%-5d buffer byte capacity cannot be represented by an uint32_t
%25s:%-5d the number of buffers is 0
%25s:%-5d the number of buffers (%u) does not match the format's number of channel streams (%u)
%25s:%-5d mBuffers[0].mDataByteSize (%u) should be non-zero
%25s:%-5d mBuffers[%u].mDataByteSize (%u) does not match the previous mBuffers[%u].mDataByteSize (%u)
%25s:%-5d mBuffers[%d].mNumberChannels (%u) does not match the format's number of interleaved channels (%u)
%25s:%-5d mBuffers[%u].mData is null
%s:%d:%s: AudioQueueRecordInputCallback called 
%s:%d:%s: AudioQueueRecordPropertyListenerProc called 
 ASSERTION FAILED: Rec AQ listener proc called with NULL impl!
%s:%d:%s: AudioQueueRecordPropertyListenerProc: AVVoiceController[self = %p] ControllerImpl(%p) Engine[%@] Queue(%p) Property(%d)
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %d
%s:%d:%s: ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %{audio:4CC}d
%s:%d:%s: Error getting input hardware sample rate
%s:%d:%s: clientRequestedSR was:%.2f, setting to 16000.00
%s:%d:%s: clientRequestedSR was:%.2f
%s:%d:%s: clientRequestedSR was not specified, setting to 16000.00
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %d
%s:%d:%s: ERROR: setupRecordQueue: asbdFromSettings err %{audio:4CC}d
%s:%d:%s: Record engine state does not match queue (previously assertion failure)
%s:%d:%s: Record Queue Format: %s
%s:%d:%s: Creating queue with flags 0x%x. %s runloops
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueNewInput err %{audio:4CC}d
%s:%d:%s: FAILED createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %{audio:4CC}d
%s:%d:%s: AQGetProperty - kAudioQueueDeviceProperty_NumberChannels returned : %u
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %{audio:4CC}d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %{audio:4CC}d
%s:%d:%s: createRecordQueue: createAudioConverter error: %d. Destroying record queue.
%s:%d:%s: AudioConverter is not created.. reason: requested channels is 1 or requested interleaved audio or non-lpcm is requested
%s:%d:%s: FrameCapacity: %d. Buffer duration: %f s
%s:%d:%s: createRecordQueue: creating %u queue buffers %u bytes each
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: createRecordQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: Creating AVAudioPCMBuffer with frameCapacity: %d. Buffer duration: %f s
%s:%d:%s: Unexpected Format found.. 
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %{audio:4CC}d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %d
%s:%d:%s: ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %{audio:4CC}d
%s:%d:%s: createAudioConverter: INITIAL AUDIOCONVERTER OUTPUT FORMAT:
%s:%d:%s: inASBD : %s
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterNew err %{audio:4CC}d
%s:%d:%s: createAudioConverter: initial frames per buffer = dur %.2f * sr %.2f = %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: corrupted values??? framesPerBuffer = %u, mRecordBufferDuration = %f
 ASSERTION FAILURE: mFramesPerPacket cannot be zero!
%s:%d:%s: createAudioConverter: setting audio converter format to %u frames per packet
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: %u atomic blocks per second
%s:%d:%s: kAudioConverterCurrentOutputStreamDescription ASBD's are different !! 
%s:%d:%s: createAudioConverter: encoded audio needs minimum of %u bytes per output buffer
%s:%d:%s: createAudioConverter: AudioConverterGetProperty(kAudioConverterPropertyMinimumOutputBufferSize) returned status %d
%s:%d:%s: createAudioConverter: final framesPerBuffer: %u
%s:%d:%s: createAudioConverter: mConvertPacketCount: %u
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %d
%s:%d:%s: ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %{audio:4CC}d
%s:%d:%s: createAudioConverter: outputSizePerPacket: %u
%s:%d:%s: createAudioConverter: mConvertAudioCapacity %u bytes
%s:%d:%s: FINAL RECORD FORMAT:
%s:%d:%s: AVVC - Cannot use DSP Graph. 
%s:%d:%s: prepareRecord: retrieving voice trigger info
%s:%d:%s: prepareRecord: AudioQueueGetProperty(BorealisTriggerInfo) returned '%s'
%s:%d:%s: Device is built in device (%@)- update channel count
%s:%d:%s: AudioQueue startRecording: record state already started or stopping -- no-op
 ASSERTION FAILED: some buffers already enqueued!
%s:%d:%s: startRecordQueue: enqueing %d buffers
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: #### Starting record queue immediately ####
%s:%d:%s: #### Starting record queue at time %llu ####
%s:%d:%s: AVVC starting record queue%s at time (%s) %lld (hosttime)
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startRecordQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: stopRecordQueue: mRecordIsStopping set to true
%s:%d:%s: stopRecordQueue: AudioQueueStop%s err(%s)
%s:%d:%s: Calling destroyRecordEngine
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to true
%s:%d:%s: destroyRecordEngine: about to call AudioQueueStop(..., true)
%s:%d:%s: AVVC stopped record queue%s (%d)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueStop err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine:  calling doneRecording by hand
%s:%d:%s: destroyRecordEngine:  skipping doneRecording call because we are deallocating
 ASSERTION FAILED: queue was running when destroyed but not asked to stop
%s:%d:%s: destroyRecordEngine: about to call AudioQueueDispose(..., true)
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: destroyRecordEngine: mRecordIsStopping set to false
%s:%d:%s: destroyRecordEngine: about to destroy audio converter
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %d
%s:%d:%s: ERROR: destroyRecordEngine: AudioConverterDispose err %{audio:4CC}d
%s:%d:%s: Deleting old DSPGraph...
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %{audio:4CC}d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %d
%s:%d:%s: ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %{audio:4CC}d
%s:%d:%s: AVVCAudioQueueRecordingEngine: Record queue does not exist to enable metering. Caching, and will enable during prepare
%s:%d:%s: AVVCAudioQueueRecordingEngine: Enable Metering?: %d
%s:%d:%s: AVVCAudioQueueRecordingEngine::updateMeterLevels: not fetching meter levels because one of them is untrue! mMeteringEnabled(%d), mRecordQueue(%d), mRecordMeters(%d)
%s:%d:%s: AVVCAudioQueueRecordingEngine::updateMeterLevels: Error! In fetching meter levels. Sending 'no signal'. Error(%d)
%s:%d:%s: nChannel:%d, startChannel:%d, mClientAudioBufferList->mBuffers[nChannel+startChannel].mData : %p
%s:%d:%s: AudioConverterConvertComplexBuffer failed with error : %d
%s:%d:%s: handleRecordAQPropertyChange: queue already destroyed -- noop
%s:%d:%s: handleRecordQueuePropertyListener (%p): Stream State: %s. AQ Running: %d
%s:%d:%s: Record Listener: RUNNING
%s:%d:%s: Record Listener: RUNNING-PAUSED
%s:%d:%s: Record Listener: STOPPED
%s:%d:%s: Record Listener: Converter error: %s
%s:%d:%s: (%p) - First callback from AQ -  inStartTime: ht %lld st %lld, Now : ht %lld, tempRecordStartTime : %lld. AQ difference: %0.6f ms
%s:%d:%s: handleRecordAQInput: sample time: %f, host time %llu, %llu frames (%d bytes), %d buffers enqueued
%s:%d:%s: handleRecordAQInput: throwing away zero-length buffer
%s:%d:%s: handleRecordAQInput: record internally stopped, so throwing away buffer
%s:%d:%s: handleRecordAQInput: AVAudioEngine renderOffline returned SUCCESS
%s:%d:%s: handleRecordAQInput: Error in AVAudioEngine renderOffline : %@
%s:%d:%s: handleRecordAQInput: encoder input: packetsAvailable: %u
%s:%d:%s: handleRecordAQInput: encoder input buffer %p: %u bytes, %u packets
%s:%d:%s: handleRecordAQInput: handing to converter: encoder output buffer: %u bytes, ioOutputDataPackets = %u
%s:%d:%s: handleRecordAQInput: err %s, got from converter %u encoded packets, %u bytes.  totalOutputByteSize = %u
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %{audio:4CC}d
%s:%d:%s: handleRecordAQInput: sending %u bytes of encoded data (addr %p) to client with %u packet descs @time %llu
%s:%d:%s: Re-enqueuing buffer %p (data ptr %p), size %u
 ASSERTION FAILED: AQ enqueue error while actively recording
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: Exiting handleRecordAQInput (%d buffers enqueued)
%s:%d:%s: setSessionIsRecordingFlag: Failed at enableSiriListeningMode(%u) with error: %d
%s:%d:%s: doneRecording: resetting record queue
%s:%d:%s: UpdateRecordDeviceOnQueue : AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice) - %@
%s:%d:%s: UpdateRecordDeviceOnQueue: AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice - %d)
%s:%d:%s: AVVCAudioQueueRecordingEngine::getRecordRoute : Cached record route is nil!
 ChangeNumberChannels only works for uncompressed formats
%s:%d:%s: RecordEncoderInputDataProc: ENTRY: *ioNumberDataPackets passed in: %u, packets remaining: %u, bytes already consumed: %u
%s:%d:%s: RecordEncoderInputDataProc: End of stream -- handing back zero size buffer
%s:%d:%s: RecordEncoderInputDataProc: Handing back ioData buffer %p of size %u
 ASSERTION FAILED: packetsRead <= packetsAvailable!
%s:%d:%s: RecordEncoderInputDataProc: EXIT: *ioNumberDataPackets passed back out: %u, status: %s
Could not load AXSpeechImplementation: %@
%s:%d:%s: setDuckOthersOption: %d. session state => %s
%s:%d:%s: Error (prev Assertion Failure): Calling setDuckOthersOption on an unconfigured session
%s:%d:%s: setDuckOthersOption: done : error : %d
%s:%d:%s: Resetting miniducking
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: iMessage -- setting P&R category, clearing preferred input, etc.
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %{audio:4CC}d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode carplaySupportsMixableSiri: %d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: category, mode and options are the same..
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: (%ld) mode. Options to set: %ld
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %{audio:4CC}d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: forcing %.2f audio for car audio
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %d
%s:%d:%s: ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %{audio:4CC}d
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: SR changes from %f to %f
%s:%d:%s: setSessionCategoryModeOptionsAndSampleRateFromMode: SR remains at %f
%s:%d:%s: audioSessionForStreamID(%d) couldn't find engine, returning nil
%s:%d:%s: ASSERTION FAILED: calling setSessionProperties on a configured session. Crashing process!.
%s:%d:%s: setSessionProperties: done
%s:%d:%s: QueueRunLoop started
%s:%d:%s: Failed to start queue's run loop thread
%s:%d:%s: Profiling AVVC NOW.
%s:%d:%s: Setting duck-others AudioSession option for CarPlay
%s:%d:%s: ControllerImpl::Entering Dealloc
%s:%d:%s: QueueRunLoop stopped
%s:%d:%s: ControllerImpl::Exiting Dealloc
%s:%d:%s: waiting for any in-flight AudioQueue property change message on run loop...
%s:%d:%s: CallbackBarrier: 9 second timeout!
%s:%d:%s: received all AudioQueue property change messages on run loop.
%s:%d:%s: setNoResumeOnDeactivate(TRUE): will not notify others on deactivation
%s:%d:%s: setNoResumeOnDeactivate(FALSE): will notify others on deactivation
%s:%d:%s: setActivationMode: voice activation
%s:%d:%s: setActivationMode: post-voice activation
%s:%d:%s: setActivationMode: iMessage nudge
%s:%d:%s: setActivationMode: iMessage gesture to head
%s:%d:%s: setActivationMode: ATVRemoteSiri
%s:%d:%s: setActivationMode: standard value (%s)
%s:%d:%s: setActivationMode: Cannot revert from mode %s to mode %s while audio session is active
%s:%d:%s: setActivationModeAndSessionHWControlFlagsAndOptions: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%s:%d:%s: setActivationMode: will not take control of hardware for appletv upon activation
%s:%d:%s: setActivationMode: will not take control of hardware upon activation for AirPlay output
%s:%d:%s: setActivationMode: setting volume required hardware control flag for 'voic' activation mode (ouput is not Airplay)
%s:%d:%s: ERROR: setActivationMode : Failed at setAudioHardwareControlFlags: %s
%s:%d:%s: setActivationMode: (hdvc / btdt / cpvc / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%s:%d:%s: setActivationMode: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%s:%d:%s: setActivationMode: enabling all 4 hw control flags
%s:%d:%s: ERROR: Failed at setAudioHardwareControlFlags: %s
%s:%d:%s: setActivationMode: Mode already set to %s. No change in AudioSession flags or options
%s:%d:%s: getDeviceUIDForHomeOrBluetoothButtonActivation : %d, siriRemoteID(%@)
%s:%d:%s: handlePluginDidPublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%s:%d:%s: handlePluginDidUnpublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%s:%d:%s: Context is nil. can't decide what recording engine need to be created
%s:%d:%s: switching to %{audio:4CC}d mode - keeping the same recording engine [%@]
%s:%d:%s: ** !!! Invalid engine type creation !!! 
%s:%d:%s: current recording engine - %@. type: %s
%s:%d:%s: setActivationContext setting audio session activation context to: %@
%s:%d:%s: setActivationContext: HACK: ignore switch away from RemoteSiri
%s:%d:%s: setActivationContext: 'live' switch out of VoiceActivated -- reset session properties
%s:%d:%s: setActivationContext: switching in/out of CarAudio -- reset session properties
%s:%d:%s: setActivationContext: switching out of iMessage -- reset session properties
%s:%d:%s: ERROR: setActivationContext: AVAudioSession setActivationContext err %s, session id:0x%x
%s:%d:%s: setActivationContext: done setting audio session activation context
%s:%d:%s: setActivationContext: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %d
%s:%d:%s: ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %{audio:4CC}d
%s:%d:%s: setActivationContext: session re-activated -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is active and mode changed -- calling getSessionProperties
%s:%d:%s: setActivationContext: session is inactive -- route change notification or setSessionActive should generate a call to getSessionProperties
%s:%d:%s: getRecordAndPlaybackRoutes: Nil recordingEngine!
%s:%d:%s: getRecordAndPlaybackRoutes: Nil currentRoute!
%s:%d:%s: getRecordAndPlaybackRoutes: Nil port type!
%s:%d:%s: getRecordAndPlaybackRoutes: AQ engine couldnt find routes since VSPD is not present!
%s:%d:%s: getRecordAndPlaybackRoutes: New Record Route %@
%s:%d:%s: getRecordAndPlaybackRoutes: New Playback Route: %@
%s:%d:%s: getRecordAndPlaybackRoutes: Nil route returned!
%s:%d:%s: getRecordAndPlaybackRoutes: No routes returned!
%s:%d:%s: %s: audio session is inactive or had been interrupted
%s:%d:%s: %s: rebuilding alert queue
%s:%d:%s: %s: calling prepare instead of create record queue
%s:%d:%s: %s - setSessionActive(false): session state already %s -- forcing deactivation
%s:%d:%s: deactivate session (%p) (session mananger (%p))
%s:%d:%s: ERROR: %s setActive:FALSE withOptions: err %s
%s:%d:%s: #### AVVoiceController: %s - error ####
%s:%d:%s: #### AVVoiceController: %s - error AVAudioSessionErrorCodeMediaServicesFailed ####
%s:%d:%s: setSessionActive(false): Deactivating session due to error: %d
%s:%d:%s: ERROR: setSessionActive: setActive: FALSE - err = %s, session id:0x%x
%s:%d:%s: setSessionActive: We have to wait for the session to be (re-)initialized
%s:%d:%s: setSessionActive: (re-)init done!
%s:%d:%s: setSessionActive: waiting...
%s:%d:%s: ERROR: setSessionActive: Timed out waiting for mediaserverd err %d
%s:%d:%s: #### AVVoiceController: Activating session ####
%s:%d:%s: setSessionActive: setActive: TRUE for prewarming did not succeed
%s:%d:%s: setSessionActive: setActive: TRUE for prewarming did not succeed and returned err: %d
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE for prewarming err %d
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE for prewarming err %{audio:4CC}d
%s:%d:%s: setSessionActive: Activating : session options : %d
%s:%d:%s: ERROR: setSessionActive: setActive: TRUE - err = %s, session id:0x%x
%s:%d:%s: setSessionActive(true): AVAudioSession:setActive has returned
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested
%s:%d:%s: setSessionActive(true): force of getSessionProperties requested - returned error : %d
%s:%d:%s: setSessionActive(true): Route change when we went active: %s -- getting properties
%s:%d:%s: #### AVVoiceController: Deactivating session with notify ####
%s:%d:%s: setSessionActive(false): stopping playback queue
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %d
%s:%d:%s: ERROR: setSessionActive(false): AudioQueueStop err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): destroying record queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring destroyRecordQueue err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): in process of being destroyed -- kill the alert queue
%s:%d:%s: setSessionActive(false): resetting alert queue
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: setSessionActive(false): ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: setSessionActive(false): alert state %s -- deactivating session asynchronously (NOT HERE) check alertFinished
%s:%d:%s: setSessionActive(true): session state already %s -- no-op
%s:%d:%s: getSessionProperties: unexpected 0.0 value for output latency
%s:%d:%s: getSessionProperties: working around bad input latency value for now
%s:%d:%s: getSessionProperties: input HW latency: %g output HW latency: %g
%s:%d:%s: getSessionProperties: input HW sampling rate %lf
%s:%d:%s: getSessionProperties: plugin mode - resetting to default HW sampling rate %lf
%s:%d:%s: getSessionProperties: Error getting input hardware sample rate
%s:%d:%s: getSessionProperties: Done.  Input HW sampling rate set to %lf - error (%d)
%s:%d:%s: setupEndpointer: configuring SR and wait times
%s:%d:%s: getRecordErrorStatus: Current recording engine is nil!
%s:%d:%s: Error! prepareRecordQueue: Nil recording engine! Bailing.
%s:%d:%s: calculateRecordStartTime: Error, current recording engine is nil!
%s:%d:%s: WARNING: startRecordingAtTime:error was used without 'silent' start alert
%s:%d:%s: calculateRecordStartTime: queue plus HW delay time: %f seconds
%s:%d:%s: calculateRecordStartTime: host time for start of record: %.3f seconds
%s:%d:%s: this is %lld ticks beyond alert end (%.6f seconds in the future)
%s:%d:%s: configureAlertModeFromModeAndEngine: Nil recording engine. Abandon ship!
%s:%d:%s: configureAlertModeFromModeAndEngine: Wired headset output - disable ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: record start time was set -- check for ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: ZLL query - back frames: %u
%s:%d:%s: configureAlertModeFromModeAndEngine: CarPlay supports ZLL. recordStartTime : %llu
%s:%d:%s: ZLL query result %d, backFramesAvailable: %u. Clearing start record time
%s:%d:%s: configureAlertModeFromModeAndEngine: record start time not set
%s:%d:%s: configureAlertModeFromModeAndEngine: HomeButtonPress/UIButtonPress
%s:%d:%s: configureAlertModeFromModeAndEngine: %s
%s:%d:%s: configureAlertModeFromModeAndEngine: no vibrator support and no ZLL
%s:%d:%s: configureAlertModeFromModeAndEngine: Built-In/BT/CarPlay Voice Activation
%s:%d:%s: configureAlertModeFromModeAndEngine: VoiceTriggerTraining
%s:%d:%s: configureAlertModeFromModeAndEngine: iMessage
%s:%d:%s: configureAlertModeFromModeAndEngine: default
%s:%d:%s: configureAlertModeFromModeAndEngine: [final alert modes, overrides] : Start[%s, %s], Stop[%s, %s], StopWError[%s, %s])
%s:%d:%s: Stop record when stream state is %s
%s:%d:%s: stopRecord: already stopping or inactive -- no-op
%s:%d:%s: stopRecord: stopping queue at time %llu
%s:%d:%s: !!!! stopRecord: Recording engine is null -- this should not happen
%s:%d:%s: stopRecord: Error stopping record engine: %d
%s:%d:%s: waitForAllStopRecordCompletion_v1v2: wait for all didStops to be delivered to the client
%s:%d:%s: Engine Map does not exist
%s:%d:%s: Error! startedRecording: Nil recording engine! Bailing.
%s:%d:%s: startedRecording: calling startRecordCompletionBlock. Error: %@
%s:%d:%s: performSelectorOnMainThread: beganRecording:
%s:%d:%s: calling synchronously: beganRecording:
%s:%d:%s: Error! doneRecording: Nil recording engine! Bailing.
%s:%d:%s: doneRecording: resetting mRecordIsStopping and mRecordIsPrimed
%s:%d:%s: doneRecording: calling startRecordCompletionBlock (notify start before stop). Error: %@
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls performSelectorOnMainThread: beganRecording:
%s:%d:%s: Special case: stop requested before start finished, so doneRecording calls beganRecording: synchronously
%s:%d:%s: doneRecording: calling stopRecordCompletionBlock. Error: %@
%s:%d:%s: doneRecording: calling recordStatusChangeBlock (unexpected didStop). Error: %@
%s:%d:%s: performSelectorOnMainThread: finishedRecording
%s:%d:%s: calling finishedRecording synchronously
%s:%d:%s: playAlert: alertType = %d, primeFirst=true
%s:%d:%s: playAlert: using SSS to play haptic (or silence)
%s:%d:%s: playAlert: alert %d already in progress -- stop it now
%s:%d:%s: playAlert: silent start - fake a SS completion callback
%s:%d:%s: playAlert: non-blocking SSS alert for Siri startup
%s:%d:%s: playAlert: silent stop - fake a SS completion callback
%s:%d:%s: playAlert: calling AudioServicesPlaySystemSoundWithOptions with sound ID %u and flags %x
%s:%d:%s: playAlert: using alert queue to play beep
%s:%d:%s: playAlert: alert playback failed -- attempting to re-prime
%s:%d:%s: playAlert: Some Error occured! Not calling startAlertQueue() : %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueNewOutput err %{audio:4CC}d
%s:%d:%s: FAILED createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %d
%s:%d:%s: ERROR: createAlertQueue: AudioQueueAddPropertyListener err %{audio:4CC}d
 ASSERTION FAILED: re-entrant request for different alert type
%s:%d:%s: primeAlertQueue: alert queue state '%s'.  reentrant or multi-threaded call -- returning
%s:%d:%s: primeAlertQueue: queue is NULL -- returning
%s:%d:%s: primeAlertQueue: type %d (current is %d)
%s:%d:%s: primeAlertQueue: sync-stopping active alert queue
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueStop err %{audio:4CC}d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %d
%s:%d:%s: ERROR: primeAlertQueue: ignoring AudioQueueReset err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: silent/haptic alert: not queueing a buffer
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %d
%s:%d:%s: ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%s:%d:%s: primeAlertQueue: done. current is now %d
%s:%d:%s: primeAlertQueue: no-op
%s:%d:%s: setupAlert: NULL alert URL
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileOpenURL err %{audio:4CC}d
%s:%d:%s: setupAlert: Failed to load alert '%s'
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileGetProperty err %{audio:4CC}d
%s:%d:%s: setupAlert: resetting alert queue
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %d
%s:%d:%s: ERROR: setupAlert: AudioQueueAllocateBuffer err %{audio:4CC}d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %d
%s:%d:%s: ERROR: setupAlert: ExtAudioFileRead err %{audio:4CC}d
 ASSERTION FAILED: no alert buffer is enqueued!
%s:%d:%s: startAlertQueue: calling AudioQueueStart
%s:%d:%s: AVVC started alert queue%s (%d)
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStart err %{audio:4CC}d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %d
%s:%d:%s: ERROR: startAlertQueue: AudioQueueStop(async) err %{audio:4CC}d
 ASSERTION FAILED: alert queue NULL but state != Uninitialized
%s:%d:%s: detected unfinished alert, queue up alertFinished
%s:%d:%s: destroyAlertQueue: calling AudioQueueStop
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueStop() err %{audio:4CC}d
%s:%d:%s: destroyAlertQueue: removing queue listener
%s:%d:%s: destroyAlertQueue: calling AudioQueueDispose
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %d
%s:%d:%s: ERROR: destroyAlertQueue: AudioQueueDispose err %{audio:4CC}d
%s:%d:%s: calculateAlertTimes: alert queue already stopped -- using current time as end time
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %d
%s:%d:%s: ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %{audio:4CC}d
%s:%d:%s: alertStarted: record state != kRecordStarting -- noop
%s:%d:%s: alertStarted: not playing start alert -- noop
%s:%d:%s: alertFinished
%s:%d:%s: alertFinished: state = %s mRecordState: %s -- not priming alert
%s:%d:%s: alertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: alertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: Alert Listener: impl or queue is NULL or object is being destroyed -- noop
%s:%d:%s: Alert Listener: in the middle of priming alert queue:  Doing nothing.  [THIS IS NEW BEHAVIOR]
%s:%d:%s: Alert Listener: mAlertQueueState = %s
%s:%d:%s: Alert Listener: RUNNING = %d
%s:%d:%s: Alert Listener: session was interrupted!  Doing nothing here
%s:%d:%s: Alert Listener: state already kAlertQueueRunning.  Doing nothing here
%s:%d:%s: Alert Listener: Session is inactive, alertFinishedPlayback already synthesized in deactivateSession.
%s:%d:%s: Alert Listener: queue reports stopped on first IsRunning prop notification -- treat this like a regular start
%s:%d:%s: Alert Listener: unhandled inID %s
%s:%d:%s: vibeStartAlertFinished: record state != kRecordStarting -- noop
%s:%d:%s: vibeStopAlertFinished: deactivating session -- finishing the job
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %d
%s:%d:%s: ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%s:%d:%s: VibeAlertCompletionProc: SSID %u done
%s:%d:%s: VibeAlertCompletionProc -> called after object destroyed -- ignoring call
%s:%d:%s: VibeAlertCompletionProc: object being destroyed -- bailing out
%s:%d:%s: VibeAlertCompletionProc: notified for other ssID %d -- no-op
%s:%d:%s: checkForEndpoint entered: inBuffer %p
%s:%d:%s: performSelectorOnMainThread: startpointDetected
%s:%d:%s: calling startpointDetected synchronously
%s:%d:%s: performSelectorOnMainThread: interspeechPointDetected
%s:%d:%s: calling interspeechPointDetected synchronously 
%s:%d:%s: #### AVVoiceController: Detected end point but NO START POINT ####
%s:%d:%s: checkForEndpoint: auto-stopping record
%s:%d:%s: performSelectorOnMainThread: endpointDetected
%s:%d:%s: calling endpointDetected synchronously
%s:%d:%s: checkForEndpoint exiting
%s:%d:%s: Record Listener: handling deferred context change
%s:%d:%s:     Reporting encoder error %s via delegate
%s:%d:%s:     performSelectorOnMainThread: encodeError
%s:%d:%s:     calling encodeError synchronously
%s:%d:%s:     No delegate method found -- dropping error
%s:%d:%s: AVVoiceController -> Interruption beginning for %s session (%p)
%s:%d:%s:   We think our session was not active.  Make sure it isn't. deactivating session with options : %d
%s:%d:%s: deactivating session returned  : %d - error - %@
%s:%d:%s:   Playback was active
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackWasStarted = %d mPlaybackRunning= %d
%s:%d:%s: performSelectorOnMainThread: beginPlaybackInterruption
%s:%d:%s: calling beginPlaybackInterruption synchronously
%s:%d:%s: performSelectorOnMainThread: finishedPlaying
%s:%d:%s: calling finishedPlaying synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate is nil or does not respond to voiceControllerBeginPlaybackInterruption:
%s:%d:%s:   Record was active
%s:%d:%s:   sending notification with interruptor name
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruptionWithContext:
%s:%d:%s: calling beginRecordInterruptionWithContext synchronously
%s:%d:%s:   sending notification
%s:%d:%s: performSelectorOnMainThread: beginRecordInterruption
%s:%d:%s: calling beginRecordInterruption synchronously
%s:%d:%s: handleInterruptStart: WARNING: delegate does not respond to voiceControllerBeginRecordInterruption:
%s:%d:%s:   Nothing active
%s:%d:%s: AVVoiceController -> Interruption ending for %s session (%p)
%s:%d:%s:   Interrupt for aux session unexpected
%s:%d:%s:   No longer reactivating audio session on interrupt end
%s:%d:%s:   destroying playback queue on resume (whether we were playing or not)
%s:%d:%s:   Was interrupted during playback
%s:%d:%s: performSelectorOnMainThread: endPlaybackInterruption
%s:%d:%s: calling endPlaybackInterruption synchronously
%s:%d:%s:   Was interrupted during recording -- stopping queue on resume
 Record should never be active when interrupt is ending!
%s:%d:%s: performSelectorOnMainThread: endRecordInterruption
%s:%d:%s: calling endRecordInterruption synchronously
%s:%d:%s:   We were never interrupted to begin with!
%s:%d:%s: AVVoiceController -> Route Change for %s session (%p)
%s:%d:%s:   Route change for aux session unexpected
%s:%d:%s: Route change reason : [%d] = %s
%s:%d:%s: Route really changed -- Re-checking properties
%s:%d:%s: Route really changed but session not-yet-active/interrupted -- set flag to check properties when we are active
%s:%d:%s: New route Category is not ours!
%s:%d:%s: We were waiting for a route change -- Re-checking properties
%s:%d:%s: Route change reason: category change - ignoring
%s:%d:%s: Category change came in while we were %s -- ignoring
%s:%d:%s: Route change reason: route configuration change - ignoring
%s:%d:%s: Route change reason was NULL
%s:%d:%s: AVVoiceController -> Server died!
%s:%d:%s: ControllerImpl::handleServerDeath: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerDeath: session is not configured
%s:%d:%s: ControllerImpl::handleServerDeath: Destroying internal state for later rebuild
%s:%d:%s: AVVoiceController -> Server reset after death
%s:%d:%s: ControllerImpl::handleServerReset: object being destroyed -- bailing out
%s:%d:%s: ControllerImpl::handleServerReset: restoring activation context and resetting session properties
%s:%d:%s: mPlaybackRunning is true
%s:%d:%s: performSelectorOnMainThread: beganPlaying
%s:%d:%s: calling beganPlaying synchronously
%s:%d:%s: mPlaybackIsPrimed = %d mPlaybackRunning= %d
 ASSERTION FAILED: PB AQ listener proc called with nullptr impl!
%s:%d:%s: Playback Listener: RUNNING = %d
%s:%d:%s: performSelectorOnMainThread: decodeError
%s:%d:%s: calling decodeError synchronously
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: %@ requested. ignoring the device id and use built in device - %@. 
%s:%d:%s: setContext: ERROR! No recording engine associated with device for post/auto activation context
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with nil deviceUUID
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with deviceUUID - %@. 
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: Ambigous activation (%@) requested with deviceUUID - %@. EngineType : %d
%s:%d:%s: setContext:getEngineTypeAndDeviceIDToUse: returned error - %d for activation mode(%@)
%s:%d:%s: Found matching engine[%@] of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: setContext: Engine lookup returned nil!
%s:%d:%s: _createRecordingEngineWithParameters : Fatal Error! Invalid engine type!
%s:%d:%s: setContext: Created new (%s) engine[%@] for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%s:%d:%s: Stopping recording here and destroying engine
%s Likely ambiguous AVVC V2 use case detected. Must pass streamID here! (or V1 engine map integrity problem). numMapEngs(%lu) v1PluginEngInvalid(%d) v1AudioQueueEngInvalid(%d) v1ValidCase(%d) v2AmbiguousCase(%d)
%s:%d:%s: ASSERTION FAILURE [!streamIDViolation is false]: Likely ambiguous AVVC V2 use case detected. Must pass streamID here! (or V1 engine map integrity problem)
%s:%d:%s: ASSERTION FAILURE [eng != nullptr is false]: V1 engine map integrity problem. Couldn't find engine in map.
%s:%d:%s: _invalidateStreamWhenDeviceUnavailable_v1v2()
%s:%d:%s: VSPD is not present, removing engine associated with BuiltInStream
%s:%d:%s: removeEngineFromMapWithStreamID: engine[%@] stream(%llu) 
%s:%d:%s: Stopping recording here, engine's remote device has been disconnected.
%s:%d:%s: Engine for streamID(%llu) not found.
%s:%d:%s: DelegateDispatchGroup wait timed out after %f seconds
%s:%d:%s: alert state => %s
%s:%d:%s: Interrupting recording on engine[%@] with streamID(%llu)
%s:%d:%s: Stopping the recording on stream(%lu) due to a category change
%s:%d:%s: NOTE: AVVC Details logging is turned on by default for development
%s:%d:%s: debug_encoding on
%s:%d:%s: debug_endpoint on
%s:%d:%s: debug_callbacks on
%s:%d:%s: debug_locking on
%s:%d:%s: debug_state on
%s:%d:%s: debug_trace on
%s:%d:%s: debug_timing on
%s:%d:%s: debug_delegate on
%s:%d:%s: debug_playback on
%s:%d:%s: debug_deviceselect on
%s:%d:%s: debug_level = %d
%s:%d:%s: resetting debug_level to Notify to allow scoped logging
%s:%d:%s: debug priority: %u scopes: 0x%llx
%s:%d:%s: logAndReturnIfAudioSessionIsNotAvailable-%s returning : %d
%s:%d:%s: ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeOptions failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setIAmTheAssistant failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setAllowHapticsAndSystemSoundsDuringRecording failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeRouteSharingPolicyOptions failed with error: %@
%s:%d:%s: AVVCSessionManager::setSessionActivationContext : passed 'nil' dictionary, creating empty one.
%s:%d:%s: ERROR: AVVCSessionManager::setActivationContext of sessionID(0x%x) failed with error: %@
%s:%d:%s: shouldEnableMiniDucking on AppleTV. Not available for now
%s:%d:%s: enableMiniDucking: Called on HomePod like device, no-op
%s:%d:%s: shouldEnableMiniDucking: No change, no-op
%s:%d:%s: shouldEnableMiniDucking: Announce calls enabled. Will not set session properties while disabling miniDucking
%s:%d:%s: getHypotheticalRouteAndUpdateStates: pickedRoute from AudioSession: %@
%s:%d:%s: setupSessionInterruptionOrDuckingBehavior: isSomeOtherAudioPlaying: %d
%s:%d:%s: getHypotheticalRouteAndUpdateStates : shouldDuckOthers(%d), sessionNeedsVolumeControl(%d)
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions on 'audioOS'. Duck others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions on older watchOS. Interrupt others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: (wireless splitter mode). Interrupt others.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: iMessage -- setting P&R category, clearing preferred input, etc.
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: Carplay Supports Mixable Siri
%s:%d:%s: AVVCSessionManager::setSessionCategoryModeOptions: announce mode for %s context - duck others
%s:%d:%s: AVVCSessionManager : category, mode and options are the same (Current activation: %d, Previous activation: %d). No-op
%s:%d:%s: AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x. (Current activation: %d, Previous activation: %d)
%s:%d:%s: ERROR: AVVCSessionManager : setCategoryModeRouteSharingPolicyOptions failed with error: %@
%s:%d:%s: ERROR: AVVCSessionManager::clearInputPreferences failed with error: %@
%s:%d:%s: setSessionAudioHWControlFlags: Take Audio HW control on tvOS
%s:%d:%s: setSessionAudioHWControlFlags: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (HomePod) : %@
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags on older watch hardware: will never take control of HW on activation
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: wireless splitter mode, no volume control, yes routing control.
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (wireless splitter) : %@
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: disable mini-ducking. Set all HW control flags
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags (disable mini-ducking) : %@
%s:%d:%s: AVVCSessionManager::setAudioHardwareControlFlags: announce mode for %s context - don't set HW control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: will not take control of hardware upon activation for AirPlay output (voic/rais)
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: setting volume/routing required hardware control flag for 'voic' activation mode (output is not Airplay)
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : set all hw control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%s:%d:%s: AVVCSessionManager::setSessionAudioHWControlFlags: default mode - set all HW control flags
%s:%d:%s: ERROR: AVVCSessionManager::setAudioHardwareControlFlags : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: forcing 22050k audio for car audio
%s:%d:%s: ERROR: AVVCSessionManager::setPreferredSampleRate for VehicleButtonPress : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: SR changes from %f to %f
%s:%d:%s: ERROR: AVVCSessionManager::setPreferredSampleRate to %f : %@
%s:%d:%s: setSessionSampleRateFromActivationMode: SR remains at %f
%s:%d:%s: ERROR: AVVCSessionManager::setSessionBufferSize failed: %@
%s:%d:%s: AVVCSessionManager::setSessionBufferSize: Current size: %d
%s:%d:%s: AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x
%s:%d:%s: Error in setDuckOthers:mixWithOthers %d, %@
%s:%d:%s: Error in setDuckingFadeDuration %d, %@
%s:%d:%s: ERROR: AVVCSessionManager::enableSmartRoutingConsideration failed: %@
%s:%d:%s: Output Port[%d / %d] : %@
%s:%d:%s: isSessionInSiriCategoryModeAndOptions: about to set Play&Record category, speech recognition/assistant mode. Current category: %@, mode: %@, options: 0x%x
%s:%d:%s: setRecordingFromRemoteInput: %d
%s:%d:%s: Error setting recording from remote input %d, %@
%s:%d:%s: ~AVVCAudioCapturer(): destroyed
%s:%d:%s: AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%s:%d:%s: ~AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%s:%d:%s: ~AVVCAudioCapturer_AudioDiagnostics(): destroyed
%s:%d:%s: Dumping Audio for stream(%lu) at %s
%s:%d:%s: Error setting up audio captures
%s:%d:%s: AVVCAudioCapturer:logCapture: logging lpcm audio
%s:%d:%s: AVVCAudioCapturer:logCapture: logging non-lpcm audio
%s:%d:%s: Error while logging audio: %d
%s:%d:%s: mCapturer is reset to NULL
%25s:%-5d Error: Unable to call RegisterAudioUnits_Internal from libAudioDSP.dylib.
%25s:%-5d unable to get property kAUDSPGraphProperty_GraphTextFilePath %i
%25s:%-5d unable to get property kAUDSPGraphProperty_AUStrip %i
%25s:%-5d Player@%p: Engine is in the middle of a config change, cannot play yet!
%25s:%-5d Player@%p: Engine could not start the audio hardware dynamically, cannot play!
%25s:%-5d Player@%p: Engine config changed when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: IOUnit stopped when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: Engine returned render error: %ld, node: %p {%s}, cannot play!
%s:%d:%s: AVVoiceTriggerClient init %@
%s:%d:%s: AVVoiceTriggerClient dealloc %@
%s:%d:%s: server crashed
%s:%d:%s: server reset
%s:%d:%s: server timeout
%s:%d:%s: enableVoiceTriggerListening: %s
 CAGuard::CAGuard: Could not init the cond var
 CAGuard::Wait: A thread has to have locked a guard before it can wait
 CAGuard::Wait: Could not wait for a signal
 CAGuard::WaitFor: A thread has to have locked a guard be for it can wait
 CAGuard::WaitFor: Wait got an error
 CAGuard::Notify: failed
 CAGuard::NotifyAll: failed
%25s:%-5d Engine@%p: could not initialize, error = %d
%25s:%-5d Engine#%p: error: couldn't connect mixer to output node!
%25s:%-5d Engine@%p: connect node1: %p (from bus: %lu) -> node2: %p (to bus: %lu), format: %s
%25s:%-5d Engine@%p: connect node: %p (from bus: %lu) ->%s, format: %s
%25s:%-5d Engine@%p: disconnect input bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect output bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect all inputs on node: %p
%25s:%-5d Engine@%p: disconnect all outputs on node: %p
%25s:%-5d Engine@%p: connect MIDI node: %p -> node: %p, format: %s
%25s:%-5d Engine@%p: connect MIDI node: %p -> %s, format: %s
%25s:%-5d Engine@%p: disconnect MIDI node: %p from node: %p
%25s:%-5d Engine@%p: disconnect MIDI node: %p from nodes: %s
%25s:%-5d Engine@%p: disconnect MIDI inputs on node: %p
%25s:%-5d Engine@%p: disconnect MIDI outputs on node: %p
%25s:%-5d Engine@%p: initialize
%25s:%-5d Engine@%p: uninitialize
%25s:%-5d Engine@%p: start
%25s:%-5d Engine@%p: pause
%25s:%-5d Engine@%p: stop
%25s:%-5d Engine@%p: could not disable manual rendering mode
%25s:%-5d Engine@%p: iounit configuration changed > posting notification
%25s:%-5d Engine@%p: iounit configuration changed < posted notification
%25s:%-5d Engine@%p: iounit configuration changed > setting flag
%25s:%-5d Engine@%p: iounit configuration changed > stopping the engine
%25s:%-5d Engine@%p: iounit stopped unexpectedly > pausing the engine
%25s:%-5d Engine@%p: install tap on node %p, bus%lu, bufferSize %d, format: %s
%25s:%-5d Engine@%p: remove tap from node %p, bus%lu
%25s:%-5d [%s:%d:%s: (%s)] returned %s, error %@
softlink:r:path:/System/Library/Frameworks/AVFoundation.framework/AVFoundation
AVAudioIONode
AVAudioOutputNode
AVAudioInputNode
AVAudioMixing
AVAudioStereoMixing
NSObject
AVAudio3DMixing
AVAudioConnectionPoint
AVAudioRemoteInputPlugin
AVAudioRemoteInputPlugin_PrivateTest
AVVCPluginRemoteInputHost
AVAudioRemoteInputPluginDelegate
AVVCRecordDeviceInfo
AVVoiceControllerInternal
AVVoiceController_Priv
AVVoiceController
AVVCContextSettings
AVVCPrepareRecordSettings
AVVCConfigureAlertBehaviorSettings
AVVCStartRecordSettings
AVVCAlertInformation
AVVCDuckFadeDuration
AVVCDuckOverride
AVVCDuckSettings
AVAudioUnitComponent
SpeexEndpointer
Endpointer
SpeexEndpointer_Priv
AVAudioUnitTimeEffect
AVAudioUnitComponentManager
AVAudioUnitDelay
VoiceVerificationEndpointer
AVAudioUnitVarispeed
AVAudioUnitReverb
AVAudioUnitTimePitch
AudioPlayerImpl
AVAudioPlayerPriv
AVAudioPlayer
AVAudioUnitGenerator
AVVCSessionFactory
AVAudioRecorder
AVAudioSessionParticipant
AVAudioSinkNode
AVAudioChannelLayout
NSSecureCoding
NSCoding
AVSpeechSynthesisProviderVoice
NSCopying
AVSpeechSynthesisProviderRequest
AVSpeechSynthesisProviderAudioUnit
AVAudioDeviceTestServiceProtocol
AVAudioDeviceTest
AVAudioConverter
Encoding
AVVCMetricsManager
AVAudioUnitDistortion
AVAudioMixerNode
AVAudioClock
AVMIDIPlayer
AVMIDIPlayerPriv
AVAudioUnitMIDIInstrument
AVAudioBuffer
NSMutableCopying
AVAudioPCMBuffer
AVAudioCompressedBuffer
AVAudioUnitSplitter
AVAudioUnitEQFilterParameters
AVAudioUnitEQ
AVAudioFormat
AVAudioDeviceTestResult
AVAudioDeviceTestSequence
AVAudioDeviceTestProcessingChain
AVAudioSourceNode
AVSpeechSynthesisVoice
AVSpeechUtterance
AVSpeechSynthesizer
AVSpeechSynthesisMarker
AVVCAudioBuffer
AVVCAudioBufferPriv
AVAudioEnvironmentDistanceAttenuationParameters
AVAudioEnvironmentReverbParameters
AVAudioEnvironmentNode
AVVCSessionManager
AVAudioFile
AVAudioNode
AVAudioMixingDestination
AVAudioUnitSampler
AVAudioSequencer_Player
AVAudioSequencer
AVMusicTrack
AVAudioTime
AVAudioUnitDSPGraph
AVAudioUnitEffect
AVAudioPlayerNode
AVVoiceTriggerClient
AVAudioUnit
AVAudioEngine
initWithImpl:
implementation
isVoiceProcessingEnabled
engine
isInManualRenderingMode
manualRenderingMode
resetImpl:
initWithIOUnit:isInput:
presentationLatency
audioUnit
didAttachToEngine:
didDetachFromEngine:error:
setVoiceProcessingEnabled:error:
enableManualRenderingMode:isInput:
enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:
Td,R,N
T^{OpaqueAudioComponentInstance=},R,N
voiceProcessingEnabled
TB,R,N,GisVoiceProcessingEnabled
manualRenderingFormat
isEqual:
manualRenderingMaximumFrameCount
outputFormatForBus:
setManualRenderingPCMFormat:maximumFrameCount:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
setPan:
Tf,N
renderingAlgorithm
setRenderingAlgorithm:
sourceMode
setSourceMode:
pointSourceInHeadMode
setPointSourceInHeadMode:
rate
setRate:
reverbBlend
setReverbBlend:
obstruction
setObstruction:
occlusion
setOcclusion:
position
setPosition:
Tq,N
T{AVAudio3DPoint=fff},N
destinationForMixer:bus:
volume
setVolume:
setManualRenderingInputPCMFormat:inputBlock:
isVoiceProcessingBypassed
setVoiceProcessingBypassed:
isVoiceProcessingAGCEnabled
setVoiceProcessingAGCEnabled:
isVoiceProcessingInputMuted
setVoiceProcessingInputMuted:
voiceProcessingBypassed
TB,N,GisVoiceProcessingBypassed
voiceProcessingAGCEnabled
TB,N,GisVoiceProcessingAGCEnabled
voiceProcessingInputMuted
TB,N,GisVoiceProcessingInputMuted
Tf,D,N
raise:format:arguments:
sharedAVSystemController
attributeForKey:
boolValue
sharedSystemAudioContext
supportsMultipleBluetoothOutputDevices
outputDevices
countByEnumeratingWithState:objects:count:
supportsBluetoothSharing
currentHandler
stringWithUTF8String:
handleFailureInFunction:file:lineNumber:description:
init
dealloc
node
initWithNode:bus:
connectionPointWithNode:bus:
_node
_bus
_reserved
T@"AVAudioNode",R,W,N,V_node
TQ,R,N,V_bus
objectForKey:
unsignedIntegerValue
doubleValue
speechDetectionDeviceSampleRate
inputNumberOfChannels
count
dictionaryWithDictionary:
stringWithFormat:
lowercaseString
regularExpressionWithPattern:options:error:
length
firstMatchInString:options:range:
range
substringWithRange:
whitespaceAndNewlineCharacterSet
stringByTrimmingCharactersInSet:
stringWithCString:encoding:
isEqualToString:
inputs
objectAtIndex:
portType
copy
stringByAppendingFormat:
outputs
portName
stringByAppendingString:
intValue
allBundles:
absoluteString
bundleWithURL:
principalClass
initWithPluginDelegate:
invalidate
devices
T@"NSArray",R,N
addObject:
defaultManager
URLsForDirectory:inDomains:
array
URLByAppendingPathComponent:
checkResourceIsReachableAndReturnError:
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
addObjectsFromArray:
deviceIdentifier
deviceCategory
impl
handlePluginDidPublishDevice:withDevice:
handlePluginDidUnpublishDevice:withDevice:
mockPluginEndpoint
inputPlugin:didPublishDevice:
inputPlugin:didUnpublishDevice:
initializePlugins
invalidatePlugins
findDeviceWithIdentifier:
findFirstBluetoothDevice
setParentVoiceController:
mPlugins
mMotherController
sessionState
code
setAudioInputBlock:
setStatusChangeBlock:
startRecordingWithSettings:withCompletionBlock:
numberWithUnsignedLongLong:
numberWithInteger:
dictionaryWithObjectsAndKeys:
startRecordingWithCompletionBlock:
stopRecordingWithCompletionBlock:
supportedFormats
objectAtIndexedSubscript:
streamDescription
initWithStreamDescription:
setFormat:
format
audioInputBlock
frameLength
packetCount
audioTimeStamp
getBytes:range:
packetDescriptions
data
stringWithString:
remoteInputDeviceName
initWithString:
initWithUUIDString:
initWithRecordingEngine:
recordRoute
isRemoteDevice
remoteProductIdentifier
remoteDeviceUID
remoteDeviceCategory
isUpsamplingSourceAudio
remoteDeviceUIDString
_isRemoteDevice
_isUpsamplingSourceAudio
_remoteDeviceCategory
_recordRoute
_remoteProductIdentifier
_remoteDeviceUID
_remoteDeviceUIDString
T@"NSString",R,N,V_recordRoute
TB,R,V_isRemoteDevice
T@"NSString",R,N,V_remoteProductIdentifier
T@"NSUUID",R,N,V_remoteDeviceUID
TI,R,N,V_remoteDeviceCategory
TB,R,N,V_isUpsamplingSourceAudio
T@"NSString",R,N,V_remoteDeviceUIDString
setSessionNotifications_v1v2:
sharedInstance
setSessionWasCreatedBlock:
removeSessionNotifications:
setSessionWillBeDestroyedBlock:
isPrimary
audioSession
setupSessionNotifications:
voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
voiceControllerPlaybackHardwareConfigurationDidChange:toConfiguration:
userInfo
object
unsignedLongValue
initWithDictionary:
currentRoute
setObject:forKey:
voiceControllerMediaServicesWereLost:
voiceControllerMediaServicesWereReset:
pointerValue
voiceControllerDidStartRecording:forStream:successfully:error:
initWithDomain:code:userInfo:
voiceControllerDidStartRecording:successfully:error:
voiceControllerDidStartRecording:successfully:
voiceControllerDidStopRecording:forStream:forReason:
voiceControllerDidStopRecording:forReason:
voiceControllerDidDetectStartpoint:
voiceControllerDidDetectEndpoint:ofType:atTime:
voiceControllerDidDetectEndpoint:ofType:
voiceControllerEncoderErrorDidOccur:error:
voiceControllerDidStartPlaying:successfully:
initWithAudioQueueBuffer:channels:timeStamp:
voiceControllerPlaybackBufferAvailable:buffer:
voiceControllerDidStopPlaying:forReason:
voiceControllerDecoderErrorDidOccur:error:
initWithAlertType:mode:endTime:
voiceControllerDidFinishAlertPlayback:withSettings:error:
voiceControllerDidFinishAlertPlayback:ofType:error:
voiceControllerStreamInvalidated:forStream:
voiceControllerBeginRecordInterruption:
voiceControllerBeginRecordInterruption:withContext:
voiceControllerEndRecordInterruption:
voiceControllerBeginPlaybackInterruption:
voiceControllerEndPlaybackInterruption:
voiceControllerWillSetAudioSessionActive:willActivate:
voiceControllerDidSetAudioSessionActive:isActivated:
sessionSetup_v1v2
sessionCleanup_v1v2
hardwareConfigChanged
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
beganRecording_v1v2:
finishedRecording_v1v2:
startpointDetected
interspeechPointDetected
endpointDetected
encodeError
beganPlaying
playbackBufferReceived:
finishedPlaying_v1v2
decodeError
alertPlaybackFinishedOfType_v1v2:
notifyStreamInvalidated_v1v2:
beginRecordInterruption_v1v2
beginRecordInterruptionWithContext_v1v2:
endRecordInterruption_v1v2
beginPlaybackInterruption_v1v2
endPlaybackInterruption_v1v2
beginAudioSessionActivate_v1v2:
endAudioSessionActivate_v1v2:
isAPIAvailable
sendRemoteConnectionMessage:
playbackRoute
lastRecordStartTime
voiceTriggerInfo
isBargeInDetectEnabled
setBargeInDetectEnabled:
isStopOnBargeInEnabled
setStopOnBargeInEnabled:
isSynchronousCallbackEnabled
setSynchronousCallbackEnabled:
pcmRecordBufferFormat
setDuckOthersOption:
duckOthersOption
numberOfChannels
bargeInDetectEnabled
TB,GisBargeInDetectEnabled
stopOnBargeInEnabled
TB,GisStopOnBargeInEnabled
T@"NSDictionary",R
synchronousCallbackEnabled
TB,GisSynchronousCallbackEnabled
T@"AVAudioFormat",R
TB,SsetDuckOthersOption:
unsignedIntValue
errorWithDomain:code:userInfo:
finalize
playAlertSoundForType:
setupAlertBehavior_v1:
doStartRecordingAtTime_v1:behavior:
unsignedLongLongValue
reset
getStatus:count:
setEndpointMode:
setStartWaitTime:
setInterspeechWaitTime:
setEndWaitTime:
isRecording
initVoiceControllerForClient:withError:
activationMode
activationDeviceUID
streamID
recordBufferDuration
avAudioSettings
startHostTime
startAlert
stopAlert
stopOnErrorAlert
skipAlert
initWithContext:error:
prewarmAudioSession
releaseAudioSession
releaseAudioSession:
enableMiniDucking:
willAcceptContext:
IsDeviceAvailableInLocalRoute:error:
setCurrentContext:error:
prepareRecordWithSettings:error:
setAlertSoundFromURL:forType:
resetEndpointer
playRecordStartingAlertAndResetEndpointer
startRecording
startRecording:
startRecordingAtTime:error:
startRecordingWithSettings:error:
stopRecording
preparePlaybackWithSettings:error:
preparePlaybackFromURL:error:
startPlaying
stopPlaying
recordDelegate
setRecordDelegate:
recordSettings
getRecordBufferDuration
setRecordBufferDuration:
endpointerDelegate
setEndpointerDelegate:
recordEndpointMode
setRecordEndpointMode:
recordStartWaitTime
setRecordStartWaitTime:
recordInterspeechWaitTime
setRecordInterspeechWaitTime:
recordEndWaitTime
setRecordEndWaitTime:
playbackDelegate
setPlaybackDelegate:
playbackSettings
getPlaybackBufferDuration
setPlaybackBufferDuration:
isPlaying
setAlertVolume:
alertVolume
getAlertStartTime
setPlaybackVolume:
playbackVolume
isMeteringEnabled
setMeteringEnabled:
updateMeters
peakPowerForChannel:
averagePowerForChannel:
isStopOnEndpointEnabled
setStopOnEndpointEnabled:
metrics
currentRecordDeviceInfo
initWithError:
setContext:error:
setContext:streamType:error:
prepareRecordForStream:completion:
prepareRecordForStream:error:
startRecordWithSettings:completion:alertCompletion:audioCallback:
startRecordForStream:error:
configureAlertBehaviorForStream:error:
stopRecordOnStream:completion:
stopRecordForStream:error:
getCurrentStreamState:
getRecordDeviceInfoForStream:
activateAudioSessionForStream:isPrewarm:error:
activateAudioSessionForStream:isPrewarm:recordMode:error:
deactivateAudioSessionWithOptions:
deactivateAudioSessionForStream:withOptions:error:
getCurrentSessionState
getCurrentSessionStateForStream:
setContextForStream:forStream:error:
playAlert:withOverride:completion:
playAlertSoundForType:overrideMode:
getRecordBufferDurationForStream:
getRecordSettingsForStream:
isMeteringEnabledForStream:
updateMeterForStream:
getPeakPowerForStream:forChannel:
getAveragePowerForStream:forChannel:
setRecordStatusChangeBlock:
enableSmartRoutingConsiderationForStream:enable:error:
setAnnounceCallsEnabledForStream:enable:
getInputChannelInfoForStream:completion:
setDuckOthersForStream:withSettings:error:
alertStartTime
_impl
_alertStartTime
recording
TB,R,GisRecording
T@"<Endpointer>",&
T@"<AVVoiceControllerRecordDelegate>",D
meteringEnabled
TB,GisMeteringEnabled
playing
TB,R,GisPlaying
T@"<AVVoiceControllerPlaybackDelegate>",D
stopOnEndpointEnabled
TB,GisStopOnEndpointEnabled
TQ,R,V_alertStartTime
allocWithZone:
announceCallsEnabled
initWithMode:deviceUID:
copyWithZone:
setActivationMode:
setActivationDeviceUID:
setAnnounceCallsEnabled:
_announceCallsEnabled
_activationMode
_activationDeviceUID
Tq,N,V_activationMode
T@"NSString",&,N,V_activationDeviceUID
TB,N,V_announceCallsEnabled
initWithStreamID:settings:bufferDuration:
setStreamID:
setAvAudioSettings:
_meteringEnabled
_streamID
_avAudioSettings
_recordBufferDuration
TQ,N,V_streamID
T@"NSDictionary",&,N,V_avAudioSettings
Td,N,V_recordBufferDuration
TB,N,V_meteringEnabled
initWithStreamID:
setStartAlert:
setStopAlert:
setStopOnErrorAlert:
_startAlert
_stopAlert
_stopOnErrorAlert
Tq,N,V_startAlert
Tq,N,V_stopAlert
Tq,N,V_stopOnErrorAlert
initWithStreamID:atStartHostTime:
setStartHostTime:
setSkipAlert:
startAnchorPoint
setStartAnchorPoint:
_skipAlert
_startAnchorPoint
_startHostTime
TQ,N,V_startHostTime
TB,N,V_skipAlert
TI,N,V_startAnchorPoint
type
setType:
mode
setMode:
alertEndTime
setAlertEndTime:
_type
_mode
_alertEndTime
Ti,N,V_type
Tq,N,V_mode
TQ,N,V_alertEndTime
initWithFadeIn:fadeOut:
fadeIn
setFadeIn:
fadeOut
setFadeOut:
_fadeIn
_fadeOut
T@"NSNumber",&,N,V_fadeIn
T@"NSNumber",&,N,V_fadeOut
initWithDuckOthers:duckToLevel:mixWithOthers:
duckOthers
setDuckOthers:
duckToLevel
setDuckToLevel:
mixWithOthers
setMixWithOthers:
_duckOthers
_duckToLevel
_mixWithOthers
T@"NSNumber",&,N,V_duckOthers
T@"NSNumber",&,N,V_duckToLevel
T@"NSNumber",&,N,V_mixWithOthers
duckOverride
setDuckOverride:
fadeDuration
setFadeDuration:
_duckOverride
_fadeDuration
T@"AVVCDuckOverride",&,N,V_duckOverride
T@"AVVCDuckFadeDuration",&,N,V_fadeDuration
rangeOfString:
substringToIndex:
whitespaceCharacterSet
substringFromIndex:
removeAllObjects
localizedStringForKey:value:table:
mutableCopy
GetTypeName:
typeName
URLWithString:
arrayWithArray:
setWithArray:
isSubsetOfSet:
allObjects
defaultCenter
postNotificationName:object:
dictionary
configurationDictionary
containsObject:
audioComponentDescription
initWithComponentDescription:
initWithComponentDescription:withAVAUManagerImpl:
localeChanged
audioComponent
name
localizedTypeName
manufacturerName
versionString
iconURL
userTagNames
setUserTagNames:
allTagNames
componentURL
availableArchitectures
version
hasCustomView
passesAUVal
isSandboxSafe
hasMIDIInput
hasMIDIOutput
supportsNumberInputChannels:outputChannels:
isComponentDescriptionMatch:
T@"NSString",R,N
TQ,R,N
T@"NSURL",R,N
sandboxSafe
TB,R,N,GisSandboxSafe
TB,R,N
T^{OpaqueAudioComponent=},R,N
T@"NSArray",C
T{AudioComponentDescription=IIIII},R,N
T@"NSDictionary",R,N
getStatus:
endpointMode
startWaitTime
interspeechWaitTime
endWaitTime
configureWithSampleRate:andFrameRate:
configureWithASBD:andFrameRate:
mStartWaitTime
mInterspeechWaitTime
mEndWaitTime
mEndpointMode
mFrameRate
mLastStatus
initWithAudioComponentDescription:
bypass
setBypass:
TB,N
removeObjectsInArray:
unionSet:
arrayWithObjects:count:
bundleWithIdentifier:
sharedAudioUnitComponentManager
localeChanged:
addObserver:selector:name:object:
registrationsChanged:
filteredArrayUsingPredicate:
privateAllocInitSingleton
tagNames
standardLocalizedTagNames
componentsMatchingPredicate:
componentsPassingTest:
componentsMatchingDescription:
removeObject:
setValue:forParam:
valueForParam:
setWetDryMix:
setDelayTime:
setFeedback:
setLowPassCutoff:
wetDryMix
delayTime
feedback
lowPassCutoff
Td,N
cleanupContext:
sessionForContext:clientType:error:
sessionManagerForContext:clientType:error:
initWithUnsignedInteger:
initWithDouble:
initWithCapacity:
mutableBytes
initWithObjects:forKeys:count:
clientRequestsRecording
voiceControllerLPCMAudioCallback:forStream:buffer:
voiceControllerAudioCallback:forStream:buffer:
voiceControllerLPCMRecordBufferAvailable:buffer:
voiceControllerRecordBufferAvailable:buffer:
audioBufferList
loadFactoryPreset:
setPitch:
setOverlap:
pitch
overlap
_delegate
_data
_url
_actualSettings
_format
_playRetain
_channelAssignments
_audioSession
_sessionListenerWasSet
_endInterruptionFlags
_localPlayer
_gcd
stop
delegate
audioPlayerDidFinishPlaying:successfully:
audioPlayerDecodeErrorDidOccur:error:
removeObserver:name:object:
valueForKey:
audioPlayerBeginInterruption:
audioPlayerEndInterruption:withOptions:
audioPlayerEndInterruption:withFlags:
audioPlayerEndInterruption:
initBase
finishedPlaying:
decodeError:
privRemoveSessionListener
handleInterruption:
beginInterruption
endInterruptionWithFlags:
endInterruption
initWithData:fileTypeHint:error:
initWithContentsOfURL:fileTypeHint:error:
owningPortUID
channelNumber
opaqueSessionID
initWithData:error:
initWithContentsOfURL:error:
prepareToPlay
play
playAtTime:
pause
setDelegate:
settings
duration
setVolume:fadeDuration:
setEnableRate:
enableRate
currentTime
deviceCurrentTime
setCurrentTime:
setNumberOfLoops:
numberOfLoops
channelAssignments
setChannelAssignments:
setAudioSession:
mixToUplink
setMixToUplink:
currentDevice
setCurrentDevice:
_currentDevice
Td,R
T@"NSString",C,V_currentDevice
T@"<AVAudioPlayerDelegate>",W
T@"NSURL",R
T@"NSData",R
T@"NSArray",C,N
performSelectorOnMainThread:withObject:waitUntilDone:
initWithUnsignedInt:
initWithBool:
initWithLength:
initWithSettings:
compare:
UTF8String
auxiliarySession
objectForKeyedSubscript:
initWithObjectsAndKeys:
setActivationContext:error:
initWithSession:
setupOneTimeSessionSettingsForClient:
setObject:forKeyedSubscript:
_wqCreateAuxSessionAndManagerForDeviceUID:clientType:session:manager:error:
_wqCreatePrimarySessionManagerIfNeeded:clientType:error:
sessionForContext:clientType:completion:
_wqSessionAndManagerForContext:clientType:session:manager:error:
allValues
sessionForContext:completion:
sessionForContext:error:
sessionManagerForContext:clientType:completion:
auxSessionManagers
releasePrimarySessionManager
workQueue
setWorkQueue:
sessionManagerMap
setSessionManagerMap:
primarySessionManager
setPrimarySessionManager:
sessionWasCreatedBlock
sessionWillBeDestroyedBlock
_workQueue
_sessionManagerMap
_primarySessionManager
_sessionWasCreatedBlock
_sessionWillBeDestroyedBlock
T@"NSObject<OS_dispatch_queue>",&,N,V_workQueue
T@"NSMutableDictionary",&,N,V_sessionManagerMap
T@"AVVCSessionManager",&,N,V_primarySessionManager
T@?,C,N,V_sessionWasCreatedBlock
T@?,C,N,V_sessionWillBeDestroyedBlock
audioRecorderDidFinishRecording:successfully:
privRemoveSessionPropertyListeners
privCommonCleanup
initWithURL:settings:error:
baseInit
path
pathExtension
finishedRecording
removeItemAtPath:error:
audioRecorderBeginInterruption:
audioRecorderEndInterruption:withOptions:
audioRecorderEndInterruption:withFlags:
audioRecorderEndInterruption:
setActive:error:
endInterruptionWithFlags
T@"AVAudioSession",&
initWithURL:format:error:
prepareToRecord
record
recordAtTime:
recordForDuration:
recordAtTime:forDuration:
deleteRecording
setProcessToTap:
processToTap
instantaneousMetering
setInstantaneousMetering:
Ti,N
T@"<AVAudioRecorderDelegate>",W
bytes
setMusicSequence:
channelCount
pullInputBlockFromReceiverBlock:
initWithReceiverBlock:
isInterleaved
initWithPCMFormat:frameCapacity:
frameCapacity
setFrameLength:
mutableAudioBufferList
sampleRate
timeWithAudioTimeStamp:sampleRate:
initWithLayout:
layout
layoutTag
initWithLayoutTag:
layoutSize
encodeBytes:length:
decodeBytesWithReturnedLength:
failWithError:
layoutWithLayoutTag:
layoutWithLayout:
supportsSecureCoding
encodeWithCoder:
initWithCoder:
TB,R
_layoutTag
_layout
TI,R,N
Tr^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]},R,N
initStandardFormatWithSampleRate:channels:
arrayWithObjects:
arrayWithObject:
initWithEnvironment:
addObserverForName:object:queue:usingBlock:
removeObserver:
firstObject
isHeadphones
encodeObject:forKey:
identifier
supportedLanguages
voiceSize
encodeInt64:forKey:
gender
encodeInteger:forKey:
decodeObjectOfClass:forKey:
setName:
setIdentifier:
setWithObjects:
decodeObjectOfClasses:forKey:
setSupportedLanguages:
longLongValue
setVoiceSize:
setVersion:
integerValue
setGender:
setAge:
initialize
didUpdateSpeechVoices
initWithName:identifier:supportedLanguages:
_name
_identifier
_supportedLanguages
_voiceSize
_version
_gender
_age
T@"NSString",&,N,V_name
T@"NSString",&,N,V_identifier
T@"NSArray",&,N,V_supportedLanguages
Tq,N,V_voiceSize
T@"NSString",&,N,V_version
Tq,N,V_gender
Tq,N,V_age
voice
ssmlRepresentation
setVoice:
setSsmlRepresentation:
initWithSSMLRepresentation:voice:
_ssmlRepresentation
_voice
T@"NSString",&,N,V_ssmlRepresentation
T@"AVSpeechSynthesisProviderVoice",&,N,V_voice
synthesizeSpeechRequest:
cancelSpeechRequest
speechVoices
setSpeechVoices:
speechSynthesisOutputMetadataBlock
setSpeechSynthesisOutputMetadataBlock:
_speechVoices
_speechSynthesisOutputMetadataBlock
T@"NSArray",&,N,V_speechVoices
T@?,C,N,V_speechSynthesisOutputMetadataBlock
initWithListenerEndpoint:
setConnection:
initWithServiceName:
connection
passExtensionToken:
startWithSequence:completion:
cancel
interfaceWithProtocol:
setRemoteObjectInterface:
remoteObjectInterface
setClasses:forSelector:argumentIndex:ofReply:
localizedDescription
remoteObjectProxyWithErrorHandler:
setServiceDelegateAsync:
synchronousRemoteObjectProxyWithErrorHandler:
setServiceDelegateSync:
setInterruptionHandler:
setInvalidationHandler:
resume
initWithXPCEndPoint:
stimulusURL
fileSystemRepresentation
serviceDelegateSync
processSequenceAsynchronously
serviceDelegateAsync
outputID
inputID
setProcessSequenceAsynchronously:
.cxx_destruct
_processSequenceAsynchronously
_connection
_serviceDelegateAsync
_serviceDelegateSync
T@"NSXPCConnection",&,V_connection
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateAsync
T@"<AVAudioDeviceTestServiceProtocol>",&,V_serviceDelegateSync
TB,V_processSequenceAsynchronously
channelLayout
magicCookie
setMagicCookie:
initFromFormat:toFormat:
inputFormat
outputFormat
dither
downmix
setDither:
setDownmix:
sampleRateConverterQuality
setSampleRateConverterQuality:
sampleRateConverterAlgorithm
setSampleRateConverterAlgorithm:
channelMap
setChannelMap:
maximumOutputPacketSize
primeMethod
setPrimeMethod:
primeInfo
setPrimeInfo:
convertToBuffer:fromBuffer:error:
convertToBuffer:error:withInputFromBlock:
T@"AVAudioFormat",R,N
T@"NSArray",&,N
T@"NSData",&,N
T@"NSString",&,N
T{AVAudioConverterPrimeInfo=II},N
bitRate
setBitRate:
bitRateStrategy
setBitRateStrategy:
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
Tq,R,N
initWithBytes:length:
initWithObjects:count:
byteCapacity
setByteLength:
packetCapacity
setPacketCount:
numberWithDouble:
getLock
setPublicMetrics:
publicMetrics
dictionaryWithObjects:forKeys:count:
setAvvcProfilingInfoDictionary:
setVoiceTriggerStartHostTime:
setCallToStartRecordHostTime:
localTimeZone
setTimeZone:
setDateFormat:
stringFromDate:
avvcProfilingInfoDictionary
timeIntervalSinceDate:
getStringDate:
enumerateKeysAndObjectsUsingBlock:
date
createSharedManager
destroySharedManager
sharedManager
retrieveMetrics
resetProfileMetrics
retrieveProfileMetrics
measureElapseTimeForMetric:block:
setAudioIssueDetectorFormat:numFrames:
audioIssueDetectorAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetAudioIssueDetector
setADAMFormat:numFrames:
adamAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetADAM
logProfileMetrics:
voiceTriggerStartHostTime
callToStartRecordHostTime
_voiceTriggerStartHostTime
_callToStartRecordHostTime
_publicMetrics
_avvcProfilingInfoDictionary
T@"NSMutableDictionary",&,V_publicMetrics
T@"NSMutableDictionary",&,V_avvcProfilingInfoDictionary
TQ,N,V_voiceTriggerStartHostTime
TQ,N,V_callToStartRecordHostTime
setSessionBufferSize:
renderBlock
FillOutAUPreset:
setPreGain:
preGain
setSessionActivationContext:
setSessionCategoryModeOptionsForActivationMode:withOptions:
setSessionSampleRateForActivationMode:
setSessionAudioHWControlFlagsForActivationMode:withOptions:
setClientRequestsRecording:
getSessionActivationOptions
setActive:withOptions:error:
enableSmartRoutingConsideration:
setDuckOthers:mixWithOthers:error:
setDuckingFadeOutDuration:fadeInDuration:error:
setSessionState:
setOutputVolume:
outputVolume
setInputVolume:bus:
setInputPan:bus:
inputConnected:
nextAvailableInputBus
initWithNode:
currentAudioTimeStamp
currentIONumberFrames
awaitIOCycle:
T@"AVAudioTime",R,N
destroyBase
initWithContentsOfURL:soundBankURL:error:
initWithData:soundBankURL:error:
hostTimeForBeats:
beatsForHostTime:
play:
currentPosition
setCurrentPosition:
TB,R,N,GisPlaying
startNote:withVelocity:onChannel:
stopNote:onChannel:
sendController:withValue:onChannel:
sendPitchBend:onChannel:
sendPressure:onChannel:
sendPressureForKey:withValue:onChannel:
sendProgramChange:onChannel:
sendProgramChange:bankMSB:bankLSB:onChannel:
sendMIDIEvent:data1:data2:
sendMIDIEvent:data1:
sendMIDISysExEvent:
byteLength
mutableCopyWithZone:
initWithFormat:byteCapacity:
initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:
_deallocator
Tr^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
T^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
_initChannelPtrs
appendDataFromBuffer:channel:
calculatePower:
floatChannelData
stride
calculatePower:forFloatData:stride:frameLength:
numberWithFloat:
int16ChannelData
int32ChannelData
initWithPCMFormat:bufferListNoCopy:deallocator:
appendDataFromBuffer:
splitIntoSingleChannelBuffers
averagePowerPerChannel
peakPowerPerChannel
TI,N
T^^f,R,N
T^^s,R,N
T^^i,R,N
initWithFormat:packetCapacity:maximumPacketSize:
initWithFormat:packetCapacity:
maximumPacketSize
T^v,R,N
TI,R,D,N
TI,D,N
T^{AudioStreamPacketDescription=qII},R,N
setFilterType:
filterType
setFrequency:
frequency
setBandwidth:
bandwidth
setGain:
gain
initWithNumberOfBands:
bands
globalGain
setGlobalGain:
initWithStreamDescription:channelLayout:
settingsFromASBD:channelLayout:
numberWithUnsignedInteger:
setValue:forKey:
dataWithBytes:length:
encodeDouble:forKey:
decodeDoubleForKey:
decodeIntegerForKey:
formatWithInvalidSampleRateAndChannelCount
initStandardFormatWithSampleRate:channelLayout:
initWithCommonFormat:sampleRate:channels:interleaved:
initWithCommonFormat:sampleRate:interleaved:channelLayout:
initWithCMAudioFormatDescription:
formatDescription
isStandard
commonFormat
_asbd
_commonFormat
standard
TB,R,N,GisStandard
interleaved
TB,R,N,GisInterleaved
Tr^{AudioStreamBasicDescription=dIIIIIIII},R,N
T@"AVAudioChannelLayout",R,N
Tr^{opaqueCMFormatDescription=},R,N
initWithData:inputID:outputID:sampleRate:correlationValue:
setInputID:
setOutputID:
setSampleRate:
correlationValue
setCorrelationValue:
_inputID
_outputID
_sampleRate
_correlationValue
Tq,N,V_outputID
Tq,N,V_inputID
Td,N,V_sampleRate
Td,N,V_correlationValue
T@"NSData",R,N,V_data
encodeFloat:forKey:
encodeBool:forKey:
decodeFloatForKey:
decodeBoolForKey:
setStimulusURL:
inputProcessingChain
setInputProcessingChain:
outputProcessingChain
setOutputProcessingChain:
outputMode
setOutputMode:
priority
setPriority:
calculateCrossCorrelationPeak
setCalculateCrossCorrelationPeak:
parallelCrossCorrelationCalculation
setParallelCrossCorrelationCalculation:
_calculateCrossCorrelationPeak
_parallelCrossCorrelationCalculation
_volume
_stimulusURL
_inputProcessingChain
_outputProcessingChain
_outputMode
_priority
Tf,N,V_volume
T@"NSURL",&,N,V_stimulusURL
T@"AVAudioDeviceTestProcessingChain",&,N,V_inputProcessingChain
T@"AVAudioDeviceTestProcessingChain",&,N,V_outputProcessingChain
Tq,N,V_outputMode
Tq,N,V_priority
T@"NSString",&,V_mode
TB,V_calculateCrossCorrelationPeak
TB,V_parallelCrossCorrelationCalculation
graphURL
setGraphURL:
processingStripURL
setProcessingStripURL:
_graphURL
_processingStripURL
T@"NSURL",&,N,V_graphURL
T@"NSURL",&,N,V_processingStripURL
pullInputBlockFromRenderBlock:
initWithRenderBlock:
initWithFormat:renderBlock:
stringByReplacingOccurrencesOfString:withString:
startAndReturnError:
reason
fileURLWithPath:
dictionaryWithContentsOfURL:error:
enableManualRenderingMode:format:maximumFrameCount:error:
inputNode
attachNode:
connect:to:format:
outputNode
detachNode:
renderOffline:toBuffer:error:
bundleWithPath:
isLoaded
loadAndReturnError:
language
quality
setLanguage:
setQuality:
currentLanguageCode
voiceWithLanguage:
voiceWithIdentifier:
audioFileSettings
_audioFileSettings
T@"NSString",C,D,N
T@"NSString",&,D,N
Tq,D,N
T@"NSDictionary",R,N,V_audioFileSettings
speechString
attributedSpeechString
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
setSpeechString:
setAttributedSpeechString:
floatValue
setPitchMultiplier:
setPreUtteranceDelay:
setPostUtteranceDelay:
speechUtteranceWithString:
speechUtteranceWithAttributedString:
speechUtteranceWithSSMLRepresentation:
initWithAttributedString:
initWithSSMLRepresentation:
prefersAssistiveTechnologySettings
setPrefersAssistiveTechnologySettings:
_prefersAssistiveTechnologySettings
_rate
_pitchMultiplier
_speechString
_attributedSpeechString
_preUtteranceDelay
_postUtteranceDelay
T@"NSString",&,N,V_speechString
T@"NSAttributedString",&,N,V_attributedSpeechString
T@"AVSpeechSynthesisVoice",&,N,V_voice
Tf,N,V_rate
Tf,N,V_pitchMultiplier
TB,N,V_prefersAssistiveTechnologySettings
Td,N,V_preUtteranceDelay
Td,N,V_postUtteranceDelay
speakUtterance:
writeUtterance:toBufferCallback:
writeUtterance:toBufferCallback:toMarkerCallback:
stopSpeakingAtBoundary:
pauseSpeakingAtBoundary:
continueSpeaking
isSpeaking
isPaused
outputChannels
setOutputChannels:
usesApplicationAudioSession
setUsesApplicationAudioSession:
mixToTelephonyUplink
setMixToTelephonyUplink:
_speaking
_paused
_usesApplicationAudioSession
_mixToTelephonyUplink
_outputChannels
T@"<AVSpeechSynthesizerDelegate>",W,N,V_delegate
speaking
TB,R,N,GisSpeaking,V_speaking
paused
TB,R,N,GisPaused,V_paused
T@"NSArray",&,N,V_outputChannels
TB,N,V_usesApplicationAudioSession
TB,N,V_mixToTelephonyUplink
mark
byteSampleOffset
textRange
valueWithRange:
setMark:
setByteSampleOffset:
rangeValue
setTextRange:
initWithMarkerType:forTextRange:atByteSampleOffset:
_mark
_byteSampleOffset
_textRange
TQ,N,V_mark
TQ,N,V_byteSampleOffset
T{_NSRange=QQ},N,V_textRange
channels
bytesCapacity
bytesDataSize
setBytesDataSize:
packetDescriptionCapacity
packetDescriptionCount
setPacketDescriptions:count:
timeStamp
remoteVoiceActivityRMS
remoteVoiceActivityVAD
remoteVoiceActivityAvailable
upsamplingSourceAudio
Ti,R
T^v,R
T^{AudioStreamPacketDescription=qII},R
T^{AudioStreamBasicDescription=dIIIIIIII},R
TC,R
setDistanceAttenuationModel:
distanceAttenuationModel
setMaximumDistance:
maximumDistance
setReferenceDistance:
referenceDistance
setRolloffFactor:
rolloffFactor
setEnable:
enable
setLevel:
level
filterParameters
loadFactoryReverbPreset:
T@"AVAudioUnitEQFilterParameters",R,N
setOutputType:
outputType
applicableRenderingAlgorithms
setListenerPosition:
listenerPosition
setListenerVectorOrientation:
listenerVectorOrientation
setListenerAngularOrientation:
listenerAngularOrientation
distanceAttenuationParameters
reverbParameters
T{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}},N
T{AVAudio3DAngularOrientation=fff},N
T@"AVAudioEnvironmentDistanceAttenuationParameters",R,N
T@"AVAudioEnvironmentReverbParameters",R,N
changeDuckOthersOption:
shouldEnableMiniDucking:withOptions:
isMiniDuckingEnabled
setCategory:mode:routeSharingPolicy:options:error:
setIAmTheAssistant:error:
clearInputPreferences:
isSessionInSiriCategoryModeAndOptions:
setPreferredSampleRate:error:
setSessionActivationOptions:
setAudioHardwareControlFlags:error:
sessionCurrentOutputRoutes
isAirplayOneOfTheOutputRoutes:
getSiriInputSource:withIdentifier:
getOpaqueSessionID
outputLatency
inputLatency
voiceTriggerPastDataFramesAvailable
valueWithPointer:
voiceControllerEndInterruption:
category
initWithSuiteName:
boolForKey:
siriRemoteInputIdentifier
isSessionOutputInWirelessSplitterMode
setCategory:withOptions:error:
setAllowHapticsAndSystemSoundsDuringRecording:error:
pickedRoute
isOtherAudioPlaying
getHypotheticalRouteAndUpdateStates
categoryOptions
setPreferredIOBufferFrameSize:error:
preferredIOBufferFrameSize
setEligibleForBTSmartRoutingConsideration:error:
setCategory:mode:options:error:
reporterID
siriInputSource
activeSessionDisplayIDs
componentsJoinedByString:
setRecordingFromRemoteInput:error:
getInputLatency
getOutputLatency
isSessionInSiriCategory
sessionCurrentInputRoutes
getActiveSessionDisplayIDsAsString
mShouldDuckOthers
mIsMiniDuckingEnabled
mShouldEnableMiniDucking
mShouldDisableMiniDucking
mSessionNeedsVolumeControl
mSessionNeedsRoutingControl
mSessionOutputIsWirelessSplitter
mIsOtherAudioPlaying
mRouteHasDoAPSupport
mOutputSupportsSWVolume
mDeviceIsIOSAccessory
mDeviceIsOlderWatch
mSessionActivationOptions
mPreviousActivationMode
_isPrimary
_clientRequestsRecording
_sessionState
_inputLatency
_outputLatency
T@"AVAudioSession",&,N,V_audioSession
Ti,N,V_sessionState
TB,R,N,V_isPrimary
TB,N,V_clientRequestsRecording
Td,R,N,V_inputLatency
Td,R,N,V_outputLatency
initForReading:commonFormat:interleaved:error:
initForReadingFromExtAudioFile:commonFormat:interleaved:error:
initForWriting:settings:commonFormat:interleaved:error:
readIntoBuffer:frameCount:error:
initForReading:error:
initForReadingFromExtAudioFile:error:
initForWriting:settings:error:
initSecondaryReader:format:error:
readIntoBuffer:error:
writeFromBuffer:error:
fileFormat
processingFormat
framePosition
setFramePosition:
setOutputFormat:forBus:
inputFormatForBus:
setInputFormat:forBus:
nameForInputBus:
nameForOutputBus:
clock
lastRenderTime
latency
outputPresentationLatency
numberOfInputs
numberOfOutputs
setNumberOfInputs:
setNumberOfOutputs:
installTapOnBus:bufferSize:format:block:
removeTapOnBus:
AUAudioUnit
T@"AVAudioEngine",R,N
T@"AUAudioUnit",R,N
connectionPoint
T@"AVAudioConnectionPoint",R,N
parameterTree
caseInsensitiveCompare:
overallGain
setOverallGain:
loadInstrumentAtURL:error:
loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:
loadAudioFilesAtURLs:error:
stereoPan
masterGain
globalTuning
setStereoPan:
setMasterGain:
setGlobalTuning:
currentPositionInSeconds
setCurrentPositionInSeconds:
currentPositionInBeats
setCurrentPositionInBeats:
hostTimeForBeats:error:
beatsForHostTime:error:
cleanTracks
setTempoTrack:
setTrackArray:
trackArray
setupTrackArray
numberOfTracks
setupTracks
tempoTrack
initWithAudioEngine:
loadFromURL:options:error:
loadFromData:options:error:
writeToURL:SMPTEResolution:replaceExisting:error:
dataWithSMPTEResolution:error:
tracks
getTempoTrack
secondsForBeats:
beatsForSeconds:
T@"AVMusicTrack",R,N
index
track
setDestinationAudioUnit:
destinationAudioUnit
setDestinationMIDIEndpoint:
destinationMIDIEndpoint
loopRange
setLoopRange:
isLoopingEnabled
setLoopingEnabled:
offsetTime
setOffsetTime:
isMuted
setMuted:
isSoloed
setSoloed:
usesAutomatedParameters
setUsesAutomatedParameters:
lengthInBeats
setLengthInBeats:
lengthInSeconds
setLengthInSeconds:
timeResolution
T@"AVAudioUnit",&,N
T{_AVBeatRange=dd},N
loopingEnabled
TB,N,GisLoopingEnabled
muted
TB,N,GisMuted
soloed
TB,N,GisSoloed
initWithHostTime:
initWithSampleTime:atRate:
initWithHostTime:sampleTime:atRate:
initWithAudioTimeStamp:sampleRate:
secondsForHostTime:
timeWithHostTime:
timeWithSampleTime:atRate:
timeWithHostTime:sampleTime:atRate:
hostTimeForSeconds:
isHostTimeValid
isSampleTimeValid
hostTime
sampleTime
extrapolateTimeFromAnchor:
_ats
hostTimeValid
TB,R,N,GisHostTimeValid
sampleTimeValid
TB,R,N,GisSampleTimeValid
T{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II},R,N
loadAudioDSPManager
relativePath
loadDSPGraphAtURL:error:
loadAudioUnitProcessingStripAtURL:error:
dspGraphURL
auProcessingStripURL
scheduleBuffer:atTime:options:completionHandler:
scheduleBuffer:atTime:options:completionCallbackType:completionHandler:
callLegacyCompletionHandlerForType:legacyHandler:
scheduleFile:atTime:completionCallbackType:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:
scheduleBuffer:completionHandler:
scheduleBuffer:completionCallbackType:completionHandler:
scheduleFile:atTime:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionHandler:
prepareWithFrameCount:
nodeTimeForPlayerTime:
playerTimeForNodeTime:
initWithKeyOptions:valueOptions:capacity:
anyObject
voiceTriggerPastDataFramesAvailableCompletion:
enableVoiceTriggerListening:completionBlock:
enableSpeakerStateListening:completionBlock:
speakerStateActiveCompletionBlock:
speakerStateMutedCompletionBlock:
hasBargeInSupportCompletionBlock:
updateVoiceTriggerConfiguration:completionBlock:
callServerCrashedBlock
handleMediaServerDeath:
callServerResetBlock
handleMediaServerReset:
voiceTriggerServerConnection
getInputChannelInfoCompletion:
enableVoiceTriggerListening:
setListeningProperty:completionBlock:
enableSpeakerStateListening:
speakerStateActive
speakerStateMuted
hasBargeInSupport
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:
listeningEnabledCompletionBlock:
siriClientsRecordingCompletionBlock:
setAggressiveECMode:completionBlock:
voiceTriggerNotification:
speakerStateChangedNotification:
speakerMuteStateChangedNotification:
siriClientRecordStateChangedNotification:recordingCount:
voiceTriggerBlock
setVoiceTriggerBlock:
speakerStateChangedBlock
setSpeakerStateChangedBlock:
speakerMuteStateChangedBlock
setSpeakerMuteStateChangedBlock:
siriClientRecordStateChangedBlock
setSiriClientRecordStateChangedBlock:
serverCrashedBlock
setServerCrashedBlock:
serverResetBlock
setServerResetBlock:
_voiceTriggerBlock
_speakerStateChangedBlock
_speakerMuteStateChangedBlock
_siriClientRecordStateChangedBlock
_serverCrashedBlock
_serverResetBlock
T@?,C,N,V_voiceTriggerBlock
T@?,C,N,V_speakerStateChangedBlock
T@?,C,N,V_speakerMuteStateChangedBlock
T@?,C,N,V_siriClientRecordStateChangedBlock
T@?,C,N,V_serverCrashedBlock
T@?,C,N,V_serverResetBlock
dictionaryWithContentsOfURL:
componentsSeparatedByString:
instantiateWithComponentDescription:options:completionHandler:
loadAudioUnitPresetAtURL:error:
T@"AUAudioUnit",R,D,N
mainMixerNode
connect:to:fromBus:toBus:format:
connect:toConnectionPoints:fromBus:format:
disconnectNodeInput:bus:
disconnectNodeOutput:bus:
disconnectNodeInput:
disconnectNodeOutput:
prepare
inputConnectionPointForNode:inputBus:
outputConnectionPointsForNode:outputBus:
musicSequence
isRunning
isAutoShutdownEnabled
setAutoShutdownEnabled:
manualRenderingSampleTime
disableManualRenderingMode
manualRenderingBlock
connectMIDI:to:format:block:
connectMIDI:toNodes:format:block:
disconnectMIDI:from:
disconnectMIDI:fromNodes:
disconnectMIDIInput:
disconnectMIDIOutput:
attachedNodes
T^{OpaqueMusicSequence=},N
T@"AVAudioOutputNode",R,N
T@"AVAudioInputNode",R,N
T@"AVAudioMixerNode",R,N
running
TB,R,N,GisRunning
autoShutdownEnabled
TB,N,GisAutoShutdownEnabled
T@"NSSet",R,C
T@?,R,N
auAudioUnitForAudioUnit:
isMusicDeviceOrEffect
scheduleMIDIEventBlock
removeRenderObserver:
invalidateAudioUnit
allocateRenderResourcesAndReturnError:
deallocateRenderResources
inputBusses
outputBusses
setFormat:error:
setEnabled:
isEnabled
setBusCount:error:
parameterWithID:scope:element:
parameterWithAddress:
setValue:
value
maximumFramesToRender
setMaximumFramesToRender:
isRenderingOffline
setRenderingOffline:
tokenByAddingRenderObserver:
setMIDIOutputEventBlock:
setInputEnabled:
setOutputEnabled:
startHardwareAndReturnError:
stopHardware
setOutputProvider:
setInputHandler:
canPerformInput
canPerformOutput
@28@0:8^v16B24
d16@0:8
^{OpaqueAudioComponentInstance=}16@0:8
v24@0:8@16
v32@0:8@16^@24
B16@0:8
q16@0:8
B28@0:8B16^@20
B28@0:8q16B24
B32@0:8^v16B24B28
B28@0:8@16I24
@16@0:8
I16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
f16@0:8
v20@0:8f16
v24@0:8q16
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@32@0:8@16Q24
@"AVAudioMixingDestination"32@0:8@"AVAudioNode"16Q24
B32@0:8@16@?24
v20@0:8B16
v16@0:8
@"AVAudioNode"
@24@0:8@16
@24@0:8@"<AVAudioRemoteInputPluginDelegate>"16
@"NSArray"16@0:8
@"NSXPCListenerEndpoint"16@0:8
v32@0:8@16@24
v32@0:8@"<AVAudioRemoteInputPlugin>"16@"<AVAudioRemoteInputDevice>"24
@24@0:8^@16
@"NSMutableArray<AVAudioRemoteInputPlugin>"
@"AVVoiceController"
@32@0:8{shared_ptr<AVVCRecordingEngine>=^{AVVCRecordingEngine}^{__shared_weak_count}}16
@"NSString"
@"NSUUID"
{shared_ptr<ControllerImpl>=^{ControllerImpl}^{__shared_weak_count}}16@0:8
v24@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCCB}16
v20@0:8i16
v24@0:8Q16
@32@0:8@16^@24
B32@0:8@16^@24
B28@0:8@16i24
B20@0:8i16
i32@0:8Q16@24
B24@0:8^@16
B32@0:8Q16^@24
B24@0:8d16
i16@0:8
v24@0:8d16
f24@0:8Q16
@32@0:8q16^@24
Q32@0:8@16^@24
Q40@0:8@16^q24^@32
v32@0:8@16@?24
v48@0:8@16@?24@?32@?40
v32@0:8Q16@?24
q24@0:8Q16
@24@0:8Q16
B36@0:8Q16B24^@28
B40@0:8Q16B24B28^@32
v40@0:8Q16Q24^@32
B40@0:8@16Q24^@32
v36@0:8i16q20@?28
B28@0:8i16q20
d24@0:8Q16
B24@0:8Q16
f32@0:8Q16Q24
v24@0:8@?16
B28@0:8Q16B24
B40@0:8Q16@24^@32
@32@0:8q16@24
@24@0:8^{_NSZone=}16
@40@0:8Q16@24d32
@"NSDictionary"
@32@0:8Q16Q24
v20@0:8I16
@36@0:8i16q20Q28
@32@0:8@16@24
@"NSNumber"
@40@0:8@16@24@32
@"AVVCDuckOverride"
@"AVVCDuckFadeDuration"
@36@0:8{AudioComponentDescription=IIIII}16
@44@0:8{AudioComponentDescription=IIIII}16^{AVAudioUnitComponentManagerImpl=^^?@@@{mutex={_opaque_pthread_mutex_t=q[56c]}}}36
^{OpaqueAudioComponent=}16@0:8
{AudioComponentDescription=IIIII}16@0:8
B32@0:8q16q24
@20@0:8I16
B36@0:8{AudioComponentDescription=IIIII}16
i24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
B28@0:8d16I24
B28@0:8^{AudioStreamBasicDescription=dIIIIIIII}16I24
i28@0:8^f16I24
@24@0:8@?16
@"<AVAudioPlayerDelegate>"
@"NSData"
@"NSURL"
@"AVAudioFormat"
@"NSArray"
@"AVAudioSession"
^{AVAudioPlayerCpp=^{__CFData}^{__CFURL}^{__CFDictionary}I{AudioStreamBasicDescription=dIIIIIIII}{AudioStreamBasicDescription=dIIIIIIII}IQ*I^{AudioFormatListItem}I^{OpaqueAudioFileID}I^{OpaqueAudioQueue}qqqddddIdi{AudioFilePacketTableInfo=qii}qqiiBBBBIBBBBdddddd^{__CFString}I^{AudioQueueLevelMeterState}[3^{AudioQueueBuffer}]^{AudioQueueBuffer}i[3I]BBBBB^{AudioQueueBuffer}IBBBBqiII^v^?I@I^{AudioQueueChannelAssignment}}
@"NSObject<OS_dispatch_queue>"
@40@0:8@16@24^@32
v28@0:8f16d20
v56@0:8@16q24^@32^@40^@48
@40@0:8@16q24^@32
v40@0:8@16q24@?32
@?16@0:8
@"NSMutableDictionary"
@"AVVCSessionManager"
@"AVAudioSession"16@0:8
v24@0:8@"AVAudioSession"16
^{AudioRecorderImpl=@@@@@@I{AudioStreamBasicDescription=dIIIIIIII}^{OpaqueAudioFileID}^{OpaqueAudioQueue}qqqdddQ*BBBBBBBB^{AudioQueueLevelMeterState}[4^{AudioQueueBuffer}]^{AudioQueueBuffer}BQBi@}16@0:8
B32@0:8d16d24
@?24@0:8@?16
@24@0:8r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16@0:8
^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}
@"AVSpeechSynthesisProviderVoice"
v24@0:8@"NSString"16
v32@0:8@"AVAudioDeviceTestSequence"16@?<v@?@"NSArray"@"NSError">24
@"NSXPCConnection"
@"<AVAudioDeviceTestServiceProtocol>"
{AVAudioConverterPrimeInfo=II}16@0:8
v24@0:8{AVAudioConverterPrimeInfo=II}16
B40@0:8@16@24^@32
q40@0:8@16^@24@?32
^v16@0:8
i60@0:8{CAStreamBasicDescription=dIIIIIIII}16I56
i56@0:8{AudioBufferList=I[1{AudioBuffer=II^v}]}16I40r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}44B52
{AUPreset=i^{__CFString}}24@0:8q16
v28@0:8f16Q20
@24@0:8^v16
{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16@0:8
@24@0:8^I16
Q24@0:8d16
^{MIDIPlayerImpl=^{OpaqueAUGraph}^{OpaqueMusicPlayer}^{OpaqueMusicSequence}d@?@}16@0:8
v28@0:8C16C20C24
v24@0:8C16C20
v24@0:8S16C20
v32@0:8C16C20C24C28
@28@0:8@16I24
@44@0:8@16I24r^{AudioBufferList=I[1{AudioBuffer=II^v}]}28@?36
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
@40@0:8@16r^{AudioBufferList=I[1{AudioBuffer=II^v}]}24@?32
^^f16@0:8
^^i16@0:8
^^s16@0:8
B32@0:8@16q24
f44@0:8Q16^f24q32I40
@36@0:8@16I24q28
^{AudioStreamPacketDescription=qII}16@0:8
@24@0:8^{AVAudioUnitEQFilterParametersImpl=^^?^{AVAudioNodeImplBase}}16
@32@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16@24
@24@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16
@28@0:8d16I24
@32@0:8d16@24
@40@0:8Q16d24I32B36
@44@0:8Q16d24B32@36
@24@0:8^{opaqueCMFormatDescription=}16
r^{opaqueCMFormatDescription=}16@0:8
r^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
{AudioStreamBasicDescription="mSampleRate"d"mFormatID"I"mFormatFlags"I"mBytesPerPacket"I"mFramesPerPacket"I"mBytesPerFrame"I"mChannelsPerFrame"I"mBitsPerChannel"I"mReserved"I}
@"AVAudioChannelLayout"
@56@0:8@16q24q32d40d48
@"AVAudioDeviceTestProcessingChain"
@32@0:8@16@?24
@"AVSpeechSynthesisVoice"
@"NSAttributedString"
v40@0:8@16@?24@?32
B24@0:8q16
@"<AVSpeechSynthesizerDelegate>"
@48@0:8Q16{_NSRange=QQ}24Q40
{_NSRange=QQ}16@0:8
v32@0:8{_NSRange=QQ}16
{_NSRange="location"Q"length"Q}
v28@0:8r^{AudioStreamPacketDescription=qII}16i24
^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
C16@0:8
@36@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCCB}16i24Q28
v40@0:8{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16
{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16@0:8
v28@0:8{AVAudio3DAngularOrientation=fff}16
{AVAudio3DAngularOrientation=fff}16@0:8
i24@0:8q16
i24@0:8@16
v28@0:8B16Q20
i32@0:8q16Q24
i20@0:8i16
i20@0:8B16
B48@0:8@16@24Q32^@40
B56@0:8@16@24Q32Q40^@48
B20@0:8I16
B32@0:8d16^@24
B32@0:8^Q16^@24
B36@0:8B16Q20^@28
@44@0:8@16Q24B32^@36
@32@0:8^{OpaqueExtAudioFile=}16^@24
@44@0:8^{OpaqueExtAudioFile=}16Q24B32^@36
@52@0:8@16@24Q32B40^@44
B36@0:8@16I24^@28
B24@0:8^v16
B32@0:8@16Q24
v44@0:8Q16I24@28@?36
@24@0:8^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16
^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16@0:8
B44@0:8@16C24C28C32^@36
Q32@0:8d16^@24
d32@0:8Q16^@24
@24@0:8^{AVAudioSequencerImpl=^{OpaqueMusicPlayer}^{OpaqueMusicSequence}@@@@}16
B44@0:8@16q24B32^@36
d24@0:8d16
@24@0:8^{MusicTrackImpl=^{OpaqueMusicTrack}@BI}16
^{OpaqueMusicTrack=}16@0:8
{_AVBeatRange=dd}16@0:8
v32@0:8{_AVBeatRange=dd}16
@32@0:8q16d24
@40@0:8Q16q24d32
@32@0:8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16d24
{AudioTimeStamp="mSampleTime"d"mHostTime"Q"mRateScalar"d"mWordClockTime"Q"mSMPTETime"{SMPTETime="mSubframes"s"mSubframeDivisor"s"mCounter"I"mType"I"mFlags"I"mHours"s"mMinutes"s"mSeconds"s"mFrames"s}"mFlags"I"mReserved"I}
v32@0:8q16@?24
v48@0:8@16@24Q32@?40
v56@0:8@16@24Q32q40@?48
v40@0:8@16@24@?32
v48@0:8@16@24q32@?40
v52@0:8@16q24I32@36@?44
v60@0:8@16q24I32@36q44@?52
v28@0:8B16@?20
v48@0:8{AudioComponentDescription=IIIII}16I36@?40
B24@0:8f16I20
f20@0:8I16
v56@0:8@16@24Q32Q40@48
v40@0:8@16@24@32
v48@0:8@16@24Q32@40
v32@0:8@16Q24
v24@0:8^{OpaqueMusicSequence=}16
^{OpaqueMusicSequence=}16@0:8
B44@0:8q16@24I32^@36
q36@0:8I16@20^@28
v48@0:8@16@24@32@?40
