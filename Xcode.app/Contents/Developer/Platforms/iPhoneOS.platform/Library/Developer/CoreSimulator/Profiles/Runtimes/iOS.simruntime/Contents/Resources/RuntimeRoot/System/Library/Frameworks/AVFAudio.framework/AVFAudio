uouarneglppa
?mcpl
?xfuayledlppa
cfuairavlppa
xfua2bvrlppa
cfuaptunlppa
cfuavnoclppa
^@xfuatsidlppa
xmuaxmcmlppa
xmualpsmlppa
xfuaqebnlppa
mcpl)
xeps
xfuagpsdlppa
xmuamed3lppa
ngualpsslppa
Mb@?
St18bad_variant_access
NSt3__117bad_function_callE
NSt3__112bad_weak_ptrE
St9bad_alloc
uouaoipvlppa
uouacoirlppa
xfuagpsdlppa
11CAException
St12length_error
St11logic_error
St9exception
CAException
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioIONode.mm
-[AVAudioIONode enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:]
ioUnit != nil
-[AVAudioOutputNode setManualRenderingPCMFormat:maximumFrameCount:]
self.isInManualRenderingMode
-[AVAudioOutputNode manualRenderingFormat]
-[AVAudioOutputNode manualRenderingMaximumFrameCount]
AVVCCarplayRuntimeAvailability.mm
AVOutputContext
Class getAVOutputContextClass()_block_invoke
Unable to find class %s
void *AVFoundationLibrary()
AVAudioSessionRouteChangeCurrentRouteKey
AVVCUtils.mm
AcousticID
%@%d
DeviceClassNumber
torpedo
microphone
com.apple.audio.AVFAudio
null
{ inputs: %@, 
outputs: %@ }
(type=%@, name=%@, UID=%@); 
Unknown
NewDeviceAvailable
OldDeviceUnAvailable
CategoryChange
Override
WakeFromSleep
NoSuitableRouteForCategory
RouteConfigurationChange
enable_serialization
 NOT
makeSynchronous
%04d-%02d-%02d 
%02d:%02d:%02d.%06d
Gain
Frame Qualities
StartTime
StartAnchorPoint
AVVCPluginRecordingEngine.mm
AVVCPluginRecordingEngine::startRecording
AVVCPluginRecordingEngine::stopRecording
AVVCPluginRecordingEngine::destroyRecordEngine
v32@?0@"AVAudioBuffer"8@"AVAudioTime"16@"NSDictionary"24
v20@?0I8@"NSDictionary"12
(0x0) use_count:0
activation trigger
activation device uid
AlertBehavior
No Record Route
ATVRemoteInput
BluetoothDoAP
JarvisRemoteInput
ExternalDeviceInput
SetSessionActiveTime
SetSessionInactiveTime
BeginHostTime
EndHostTime
DurationMilliSeconds
undifferentiated-count
dsp-count
mic-count
speaker-ref-count
AVVoiceController.mm
v24@?0@"AVVCSessionManager"8^@16
notify server death
notify server reset
-[AVVoiceController initWithContext:error:]
-[AVVoiceController prewarmAudioSession]
finalize
-[AVVoiceController teardownWithError:]
-[AVVoiceController dealloc]
-[AVVoiceController releaseAudioSession]
-[AVVoiceController releaseAudioSession:]
-[AVVoiceController setCurrentContext:error:]
-[AVVoiceController prepareRecordWithSettings:error:]
playAlertSoundForType
-[AVVoiceController startRecording]
-[AVVoiceController startRecording:]
-[AVVoiceController startRecordingAtTime:error:]
-[AVVoiceController startRecordingWithSettings:error:]
-[AVVoiceController stopRecording]
set record delegate
setRecordEndpointMode
setRecordStartWaitTime
setRecordInterspeechWaitTime
setRecordEndWaitTime
-[AVVoiceController initVoiceControllerForClient:withError:]
-[AVVoiceController setContext:completion:]
-[AVVoiceController setContext:error:]
-[AVVoiceController setContext:streamType:error:]
-[AVVoiceController prepareRecordForStream:completion:]
-[AVVoiceController prepareRecordForStream:error:]
-[AVVoiceController startRecordWithSettings:completion:alertCompletion:audioCallback:]
-[AVVoiceController startRecordForStream:completion:]
 will skip alert
 will NOT skip alert
-[AVVoiceController startRecordForStream:error:]
-[AVVoiceController configureAlertBehaviorForStream:completion:]
-[AVVoiceController configureAlertBehaviorForStream:error:]
-[AVVoiceController stopRecordForStream:completion:]
-[AVVoiceController stopRecordForStream:error:]
-[AVVoiceController getRecordDeviceInfoForStream:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:error:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:recordMode:error:]
-[AVVoiceController deactivateAudioSessionWithOptions:]
-[AVVoiceController deactivateAudioSessionForStream:withOptions:completion:]
-[AVVoiceController deactivateAudioSessionForStream:withOptions:error:]
-[AVVoiceController setContextForStream:forStream:error:]
-[AVVoiceController playAlert:withOverride:completion:]
-[AVVoiceController playAlertSoundForType:overrideMode:]
-[AVVoiceController setDuckOthersForStream:withSettings:error:]
<fadeIn(%@), fadeOut(%@)>
<duckOthers(%@), duckToLevel(%@), isBlur(%d) mixWithOthers(%@)>
<duckOverride(%@), fadeDuration(%@)>
0x%x
 TIMEDOUT!
BlockIfAnotherAVVCIsStillAlive_v1v2
AVVC_Log.h
Output
Music Device
Music Effect
Format Converter
Effect
Mixer
Generator
Offline Effect
MIDI Processor
Apple
AVAudioUnitComponentTagsDidChangeNotification
AVAudioUnitComponentImplementation
%d.%d.%d
HasCustomView
IconURL
AudioUnitTags
com.apple.audio.ComponentTagHelper
Request
type
subtype
manufacturer
version
UserTags
com.apple.audio.units.Components
AudioUnitTypes
v20@?0I8^{__CFDictionary=}12
InitialInputs
InitialOutputs
Remote Effect
Remote Generator
Remote Instrument
Remote Music Effect
QualityDetector.cpp
SpeexEndpointer.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitTimeEffect.mm
-[AVAudioUnitTimeEffect initWithAudioComponentDescription:]
audioComponentDescription.componentType == kAudioUnitType_FormatConverter
Effects
Equalizer
Filter
Dynamics Processor
Reverb
Distortion
Delay
Time Effect
Synthesizer
Sampler
Drums
Guitar
Vocal
Bass
MIDI
Pitch
Panner
Imaging
No changes
New tags found, add it to the allTags
AVAudioUnitComponentManagerRegistrationsChangedNotification
AVVCRecordingEngine Work Queue
AVVCRecordingEngine.mm
populateRecordSettings
setRecordBufferDuration
startedRecording
doneRecording
Unknown Playback Route
getSessionProperties
getSessionProperties_HWConfig
Float32
Int16
Fixed8.24
Float64
Int32
, interleaved
, deinterleaved
%2u ch, %6.0f Hz, %s%s
%2u ch, %6.0f Hz, 'freq'
%2u ch, %6.0f Hz
%2u ch, %6.0f Hz, %s (0x%08X) 
 big-endian
 little-endian
 signed
 unsigned
integer
float
%spacked in %u bytes
 high-aligned
 low-aligned
%u.%u
%s-bit%s%s %s%s%s%s%s
from %u-bit source, 
from UNKNOWN source bit depth, 
%u frames/packet
%u bits/channel, %u bytes/packet, %u frames/packet, %u bytes/frame
ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
ret = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND)
AVFileTypeAIFF
AVFileTypeAIFC
AVFileTypeWAVE
AVFileTypeMPEG4
AVFileTypeAppleM4A
AVFileTypeCoreAudioFormat
AVFileTypeMPEGLayer3
AVFileTypeAC3
AVFileTypeSunAU
AVFileType3GPP
AVFileType3GPP2
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitGenerator.mm
-[AVAudioUnitGenerator initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Generator) || (audioComponentDescription.componentType == kAudioUnitType_RemoteGenerator)
AVVCSessionFactory.mm
AVVCSessionFactory Work Queue
AVAudioSequencerImpl.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSequencerImpl.mm
AVAudioSequencerImpl
NewMusicPlayer(&mPlayer)
NewMusicSequence(&mSequence)
MusicPlayerSetSequence(mPlayer, mSequence)
MusicSequenceSetAUGraph(mSequence, nullptr)
CurrentPosition
MusicPlayerGetTime(mPlayer, &theTime)
SetCurrentPosition
MusicPlayerSetTime(mPlayer, currentPosition)
IsPlaying
MusicPlayerIsPlaying(mPlayer, &isPlaying)
GetRate
MusicPlayerGetPlayRateScalar(mPlayer, &theRate)
SetRate
MusicPlayerSetPlayRateScalar(mPlayer, inRate)
HostTimeForBeats
MusicPlayerGetHostTimeForBeats(mPlayer, inBeats, pOutHostTime)
BeatsForHostTime
MusicPlayerGetBeatsForHostTime(mPlayer, inHostTime, pOutBeats)
NumberOfTracks
CreateTrack
MusicSequenceNewTrack(mSequence, &theTrack)
GetTrackWithIndex
MusicSequenceGetIndTrack(mSequence, inIndex, &theTrack)
GetTempoTrack
MusicSequenceGetTempoTrack(mSequence, &tempoTrack)
GetSecondsForBeats
MusicSequenceGetSecondsForBeats(mSequence, inBeats, &theSeconds)
GetBeatsForSeconds
MusicSequenceGetBeatsForSeconds(mSequence, inSeconds, &theBeats)
Reverse
MusicSequenceReverse(mSequence)
InstallUserCallback
MusicSequenceSetUserCallback(mSequence, (mUserCallbackBlock) ? UserCallback : nullptr, this)
MusicTrackImpl
MusicTrackGetProperty(inTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
SetDestinationAudioUnit
MusicTrackSetDestinationAU(mTrack, inUnit.audioUnit, &desc)
SetDestinationMIDIEndpoint
MusicTrackSetDestMIDIEndpoint(mTrack, inEndPoint)
GetDestinationMIDIEndpoint
MusicTrackGetDestMIDIEndpoint(mTrack, &endPoint)
DoSetLengthInBeats
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_TrackLength, &inLength, sizeof(inLength))
DoGetLengthInBeats
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TrackLength, &length, &pLen)
SetLengthInSeconds
MusicTrackGetSequence(mTrack, &seq)
MusicSequenceGetBeatsForSeconds(seq, inLength, &beatLength)
GetLengthInSeconds
MusicSequenceGetSecondsForBeats(seq, DoGetLengthInBeats(), &seconds)
SetOffset
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &inOffset, sizeof(inOffset))
GetOffset
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &offset, &pLen)
SetLoopCount
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, pLen)
GetLoopCount
SetLoopStart
GetLoopStart
SetLoopEnd
GetLoopEnd
EnableLooping
IsLoopingEnabled
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, pLen)
IsMuted
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, &pLen)
Solo
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, pLen)
IsSoloed
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, &pLen)
UseAutomatedParams
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, pLen)
UsesAutomatedParams
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, &pLen)
GetTimeResolution
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TimeResolution, &timeRes, &pLen)
GetIndex
MusicTrackGetSequence(mTrack, &sequence)
MusicSequenceGetTrackIndex(sequence, mTrack, &index)
MoveEvents
MusicTrackMoveEvents(mTrack, inStartBeat, inEndBeat, inToBeat)
ClearEvents
MusicTrackClear(mTrack, inStartBeat, inEndBeat)
CutEvents
MusicTrackCut(mTrack, inStartBeat, inEndBeat)
CopyInsertEvents
MusicTrackCopyInsert(inSourceTrack, inSourceStartBeat, inSourceEndBeat, mTrack, inInsertBeat)
CopyMergeEvents
MusicTrackMerge(inSourceTrack, inSourceStartBeat, inSourceEndBeat, mTrack, inInsertBeat)
AddEvent
MusicTrackNewMIDINoteEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewMIDIChannelEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewMIDIRawDataEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewExtendedNoteEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewParameterEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewMetaEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewUserEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewAUPresetEvent(mTrack, inTimeStamp, &inEvent)
AddExtendedTempoEvent
MusicTrackNewExtendedTempoEvent(mTrack, inTimeStamp, inTempo)
NewEventIterator
NewMusicEventIterator(mTrack, &theIterator)
Seek
MusicEventIteratorSeek(mIter, inTimeStamp)
NextEvent
result == noErr || result == kAudioToolboxErr_EndOfTrack
PreviousEvent
result == noErr || result == kAudioToolboxErr_StartOfTrack
SetEventInfo
MusicEventIteratorSetEventInfo(mIter, inEventType, inEventData)
SetEventTime
MusicEventIteratorSetEventTime(mIter, inTimeStamp)
DeleteEvent
MusicEventIteratorDeleteEvent(mIter)
HasPreviousEvent
MusicEventIteratorHasPreviousEvent(mIter, &has)
HasNextEvent
MusicEventIteratorHasNextEvent(mIter, &has)
HasCurrentEvent
MusicEventIteratorHasCurrentEvent(mIter, &has)
avas
com.apple.coreaudio.avfaudio
CallbackMessenger Worker Thread
RealtimeMessenger.mServiceQueue
RealtimeMessenger.cpp
v16@?0^v8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSinkNode.mm
AVAudioSinkNodeImpl
AVAudioSinkNodeImpl::SetOutputFormat(0, format)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioNodeTap.mm
nil != _format
_initialized
AVAudioNodeTap.mm
/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox
AudioFormatGetProperty
AVVCExternalDeviceRecordingEngine
~AVVCExternalDeviceRecordingEngine
prepareRecoding
destroyRecordingEngine
setSessionIsRecordingFlag
AVVCRecordingEngineMap.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAudioEngineGraph.mm
TraverseGraphNodes
inCurrNode.GetConnection(inDirection, bus, conn)
TraverseGraphNodesBFS
connNode
connNodeFirst
connNodeSecond
TraverseGraphNodesWithLookback
inCurrNode.GetConnection(otherDirection, bus, conn)
InformNodesAboutMixerConnection
inMixerConn.destNode && inMixerConn.destNode->IsMixerNode()
InformNodesAboutMixerDisconnection
UninitializeNode
inGraph.PerformCommand(node, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
InitializeActiveNodesInOutputChain
inGraph.IsNodeInGraph(inNode.NodeImpl())
inGraph.IsValidSourceNode(*startNode)
inGraph.MakeDisconnection(mixerConn.destNode->NodeImpl(), mixerConn.destBus)
InitializeActiveNodesInInputChain
inGraph.GetInputNode() && (&inNode == inGraph.GetInputNode())
false == isInputConnToConverter
inGraph.MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
inGraph.MakeConnection(inputConn)
inGraph.PerformCommand(*inGraph.GetInputNode(), AVAudioEngineGraph::kAUSetInputCallback, &rc, sizeof(rc))
PrepareForConnection
srcNode && inGraph.IsNodeInGraph(srcNode)
destNode && inGraph.IsNodeInGraph(destNode)
srcCurrConn.destNode == NULL || srcCurrConn == inConn
destCurrConn.srcNode == NULL || destCurrConn == inConn
inGraph.PerformCommand(*destNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
PrepareForDisconnection
inGraph.IsNodeInGraph(&inDestNode)
inGraph.PerformCommand(inDestNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
AVAEGraphStateTracker.RunStateQueue
AVAudioEngineGraph.mm
outputNode != nullptr
inputNode != nullptr || outputNode != nullptr
err = PerformCommand(*outputNode, kAUInitialize, NULL, 0)
IsFormatSampleRateAndChannelCountValid(outputHWFormat)
err = _Connect(connNode->NodeImpl(), outputNode->NodeImpl(), 0, 0, format)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainOptimizedTraversal, *GetOutputNode(), isOutputChainActive)
GetOutputNode()->IsInitialized()
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *GetInputNode())
GetInputNode()->IsInitialized()
IsFormatSampleRateAndChannelCountValid(inputHWFormat)
PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
_Uninitialize
(err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0))
(err = MakeConnection(conn, outErr))
(err = PerformCommand(*GetOutputNode(), kAUUninitialize, NULL, 0))
(err = PerformCommand(*GetInputNode(), kAUUninitialize, NULL, 0))
Start
ioNode != NULL
err = PerformCommand(*ioNode, kAUStartIO, NULL, 0)
_Stop
(err = PerformCommand(*ioNode, kAUStopIO, NULL, 0))
nil != inAVNode
inImpl != nil && !IsIONode(inAVNode)
AddIONode
inImpl != nil && IsIONode(inAVNode)
NULL == ioNodeImpl && !IsNodeInGraph(inImpl)
RemoveNode
IsNodeInGraph(inImpl)
!IsRunning() && !graphNode->IsInitialized()
(graphNode->IsNodeState(kAUGraphNodeState_InInputChain) || graphNode->IsNodeState(kAUGraphNodeState_InOutputChain))
!nodeMixerConns.empty() && !hasDirectConnToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus, outErr)
err = MakeDisconnection(currSrcConn.destNode->NodeImpl(), currSrcConn.destBus, outErr)
err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
err = DisconnectInactiveNode(graphNode, true , disjointNodes, outErr)
conn.IsSrcAndDestValid()
graphNode == conn.destNode
err = MakeConnection(conn, outErr)
err = UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
RemoveIONode
(isInputNode && graphNode == GetInputNode()) || (!isInputNode && graphNode == GetOutputNode())
!IsRunning() && !IsInitialized()
err = RemoveNode(inAVNode, outErr)
inAVNode
format.sampleRate == inputHWFormat.sampleRate
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *inputNode)
inSrcAVNode && inDestAVNode
inSrcImpl && inDestImpl
_Connect
IsNodeInGraph(inSrcImpl) && IsNodeInGraph(inDestImpl)
inSrcImpl->NumberOutputs() > 0
inDestImpl->NumberInputs() > 0 || graphNodeDest->CanResizeNumberOfInputs()
!srcNodeMixerConns.empty() && !isSrcNodeConnectedToIONode
!destNodeMixerConns.empty() && !isDestNodeConnectedToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*graphNodeSrc, kAUUninitialize, NULL, 0)
err = MakeDisconnection(inDestImpl, inDestBus)
err = MakeDisconnection(graphNodeSrcCurrConnPoint.node->NodeImpl(), graphNodeSrcCurrConnPoint.bus)
[format isEqual:dstFormat]
inSrcImpl->SetOutputFormat(inSrcBus, dstFormat)
[srcFormat isEqual:format]
inDestImpl->SetInputFormat(inDestBus, srcFormat)
inSrcImpl->SetOutputFormat(inSrcBus, format) && inDestImpl->SetInputFormat(inDestBus, format)
[midiInputImpl->GetOutputFormat(0) isEqual:inSrcImpl->GetOutputFormat(0)]
err = MakeConnection(currentConn)
graphNodeDest != conn.destNode
inSrcAVNode && inDestAVConnectionPoints && inDestAVConnectionPoints.count > 0
IsNodeInGraph(inSrcImpl)
!inSrcNode->IsSplitterNode()
currentConnPoints.size() <= 1
currentConnPoints.size() > 1
avConnPoint
MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*finalSrcNode, kAUUninitialize, NULL, 0)
_DisconnectInput(connPoint.node->NodeImpl(), connPoint.bus)
_Connect(inSrcImpl, [splitter impl], inSrcBus, kAudioUnitElement_Default, format)
RemoveNode(avNode)
PerformCommand(*finalSrcNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
[midiInputImpl->GetOutputFormat(0) isEqual:finalSrcNode->NodeImpl()->GetOutputFormat(0)]
_Connect(finalSrcNode->NodeImpl(), destImpl, srcBus, destBus, format)
UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
inDestAVNode
inDestImpl
_DisconnectInput
IsNodeInGraph(inDestImpl)
!IsRunning()
graphNode != conn.destNode
inSrcAVNode
inSrcImpl
_DisconnectOutput
inImpl
tmpErr = _DisconnectInput(conn.destNode->NodeImpl(), conn.destBus)
inSourceAVNode && inDestAVNodes && inDestAVNodes.count > 0
graphNodeSrc->IsMIDIProcessorNode()
destAVNode
graphNodeDest->IsMusicDevice() || graphNodeDest->IsMusicEffect() || graphNodeDest->IsMIDIProcessorNode()
inSrcImpl->SetOutputFormat(0, newFormat)
PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
err = UpdateGraphAfterReconfig(&disjointNodes, kOutputChainFullTraversal)
PerformCommand(*midiNode, kAUUninitialize, nullptr, 0)
graphNode->IsMIDIProcessorNode()
!graphNode->IsSplitterNode()
!splitterConnPoint.node->IsSplitterNode()
numSplitterConnections == 0 || numSplitterConnections > 1
!connPoint.node->IsSplitterNode()
NodeRenderingStateChanged
GetOutputDeviceLatencyForNode
GraphDescription
RenderToABL
outputNode
InputAvailable
isSink || tap != nullptr
AddPendingConnection
inConn.IsSrcAndDestValid()
RemovePendingConnection
inConn.srcNode || inConn.destNode
MakeConnection
err = MakeDisconnection(inDestImpl, inDestBus, outErr)
err = PerformCommand(*graphNodeDest, kAUMakeConnection, &connection, sizeof(connection))
err = PerformCommand(*graphNodeDest, kAUInitialize, NULL, 0)
err = PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
MakeVirtualConnection
IsNodeInGraph(conn.srcNode) && IsNodeInGraph(conn.destNode)
srcCurrConn.destNode == NULL || srcCurrConn == conn
destCurrConn.srcNode == NULL || destCurrConn == conn
MakeDisconnection
true == graphNodeDest->GetConnection(kUpstream, inDestBus, mixerConn)
DisconnectInactiveNode
false == inNode->IsInitialized()
err = MakeConnection(itInp->srcNode->NodeImpl(), itOut->destNode->NodeImpl(), itInp->srcBus, itOut->destBus, outErr)
UpdateGraphAfterReconfig
conn.srcNode && conn.destNode && conn.destNode->IsMixerNode()
AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainFullTraversal, *conn.srcNode, isChainActive)
MakeConnection(inputConn)
PerformCommand(*inputConn.srcNode, kAUInitialize, NULL, 0)
PerformCommand(*inputConn.destNode, kAUInitialize, NULL, 0)
MakeConnection(conn)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, inTraversalMode, *GetOutputNode(), isChainActive)
LastRenderErrorInChain
startNode
(bus%d) %p, {%s} -> 
(bus%d) %p, {%s}
________ %s ________
AVAudioEngineGraph %p: initialized = %d, running = %d, number of nodes = %d
 ******** output chain ********
 ******** input chain ********
 ******** pending connections - output ********
 %s, [%s]
 ******** pending connections - input ********
 ******** other nodes ********
______________________________________
err = MusicSequenceSetAudioGraph(inSequence, _seqGraphImpl)
NodeStateChanged
GetMusicDeviceNode()
RegisterRenderCallback
UnregisterRenderCallback
GetDefaultMusicDevice
outUnit || outDesc
GetOutputAudioUnit
false condition
operator()
inGraph.PerformCommand(theNode, AVAudioEngineGraph::kAUSetPropertyMaximumFramesPerSlice, &maxFrames, sizeof(maxFrames))
failed call
v16@?0@?<v@?>8
realloc failed
GetNumberBuffers
CoreAudioBaseTypes.hpp
GetAudioBufferList().mNumberBuffers == (mStorage.size() - kHeaderSize) / sizeof(AudioBuffer)
inGraph.PerformCommand(midiNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
conn.destNode && conn.destNode->IsMixerNode()
0 == inCurrNode.NumberOfValidConnections(kUpstream)
inNodeUpstream.IsInitialized()
inGraph.MakeDisconnection(inPrevConn->destNode->NodeImpl(), inPrevConn->destBus)
err = PerformCommand(midiInput, kAUInitialize, nullptr, 0)
v16@?0@"NSNotification"8
AVAudioEnvironmentNodeImpl.mm
identifier
primaryLanguages
supportedLanguages
voiceSize
gender
ssmlRepresentation
avat
com.apple.avfaudio.devicetest.service
AVAudioDeviceTest.mm
v24@?0@"NSArray"8@"NSError"16
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioConverter.mm
convert
outputBuffer.frameCapacity >= inputBuffer.frameLength
required condition is false: %s
FillComplexProc
impl->_inputBufferReceived
[impl->_inputBufferReceived.format isEqual: impl->_inputFormat]
ioData->mNumberBuffers == abl->mNumberBuffers
AVVCMM
AVVCMetricsManager.mm
profile_avvc
yyyy-MM-dd'T'HH:mm:ss.SSSSSSSZZZZZ
com.apple.avfoundation.avvc
configure
ControllerImplV1.mm
getCurrentRecordDeviceInfo_v1
getCurrentRecordSettings_v1
enableMetering_v1
updateMeters_v1
getPeakPowerForChannel_v1
getAveragePowerForChannel_v1
isMeteringEnabled_v1
resetEndpointDetector
prepareRecord
prepareRecord_v1
startRecord
startRecord_v1
secondPassCompletionHostTime
setupAudioCaptureFile_v1
getRecordQueueFormat
getRecordBufferDuration_v1
setRecordBufferDuration_v1
getStartRecordTime_v1
setStartRecordTime_v1
configureAlertOverrides_v1
(%p) streamID: %d, use_count:%ld
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.mm
AUGraphNodeBase
nil != _avNode
nullptr != _avNodeImpl
ConnectInput
nullptr != srcNode
AddNode
inNode != nil
DisconnectNode
CreateRecordingTap
nil != callbackBlock
nullptr == Tap()
NodeImpl()->SetOutputFormat(bus, format)
 node %p {%s}, '%s'
 inputs = %d
 (bus%d, en%d) <- (bus%d) %p, {%s}, [%s]
 outputs = %d
 (bus%d, en%d) -> (bus%d) %p, {%s}, [%s]
AUGraphNodeBaseV3
RenderBlock()
i44@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36
CreateMIDIConnection
midiSrc != nullptr
DestroyMIDIConnection
midiSrc == MIDIInput()
DeallocateInputBlock
false == AUI().IsRunning()
AllocateInputHandler
v36@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28
AUGraphMIDINodeV3
IsMIDIProcessorNode()
SetTapBlock
GetTapBlock()
SetTapBlockEventList
GetTapBlockEventList()
AUI().GetHostMIDIProtocol() > 0
i28@?0q8C16r^{MIDIEventList=iI[1{MIDIEventPacket=QI[64I]}]}20
AUGraphSourceNodeV3
NodeImpl()->IsAVAudioSourceNode()
InputBlock()
AUGraphSinkNodeV3
NodeImpl()->IsSinkNode()
AllocateRenderBlock
receiverBlock
i52@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36@?<i@?^I^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}Iq^{AudioBufferList=I[1{AudioBuffer=II^v}]}>44
AVAEGraphNode.mm
AUGraphMultiBusNode
IsMixerNode() || IsSplitterNode()
GetConnection
nodeBussesVec.size() >= (inBus + 1)
GetConnectionPoint
GetBusForConnectionPoint
nodeBussesVec.size() == nodeVec.size()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.h
InputMutex
bus < _inMutexes.size()
Drums - Bit Brush
Drums - Buffer Beats
Drums - Lo-Fi
Multi - Broken Speaker
Multi - Cellphone Concert
Multi - Decimated 1
Multi - Decimated 2
Multi - Decimated 3
Multi - Decimated 4
Multi - Distorted Funk
Multi - Distorted Cubed
Multi - Distorted Squared
Multi - Echo 1
Multi - Echo 2
Multi - Echo Tight 1
Multi - Echo Tight 2
Multi - Everything is Broken
Speech - Alien Chatter
Speech - Cosmic Interference
Speech - Golden Pi
Speech - Radio Tower
Speech - Waves
ControllerImplV2.mm
v28@?0Q8B16@"NSError"20
prepareRecordForStream_v2
startRecordForStream_v2
stopRecordForStream_v2
getCurrentStreamStateForStream_v2
v32@?0Q8d16@"NSError"24
getRecordBufferDurationForStream_v2
configureAlertBehaviorForStream_v2
getSessionState_v2
activateAudioSessionForStream_v2
setContextForStream_v2
v28@?0i8q12@"NSError"20
playAlertWithOverride_v2
v32@?0Q8@"AVVCRecordDeviceInfo"16@"NSError"24
getRecordDeviceInfoForStream_v2
v32@?0Q8@"NSDictionary"16@"NSError"24
getRecordSettingsForStream_v2
isMeteringEnabledForStream_v2
updateMeterLevelForStream_v2
v28@?0Q8f16@"NSError"20
getPeakPowerForStreamAndChannel_v2
getAveragePowerForStreamAndChannel_v2
setAnnounceCallsEnabledForStream
setDuckOthersForStream_v2
isDuckingSupportedOnPickedRouteForStream_v2
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioClock.mm
AVAudioClockImpl
_nodeImpl->AUI().AddV2PropertyListener(kAudioUnitProperty_StreamFormat, StreamFormatListener, this)
AVMIDIPlayer.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVMIDIPlayer/AVMIDIPlayer.mm
-[AVMIDIPlayer prepareToPlay]
MusicPlayerPreroll(impl->mPlayer)
-[AVMIDIPlayer isPlaying]
MusicPlayerIsPlaying(impl->mPlayer, &playing)
-[AVMIDIPlayer rate]
MusicPlayerGetPlayRateScalar(impl->mPlayer, &scalar)
-[AVMIDIPlayer setRate:]
MusicPlayerSetPlayRateScalar(impl->mPlayer, rate)
-[AVMIDIPlayer duration]
MusicSequenceGetSecondsForBeats(impl->mSequence, impl->mLength, &durInSeconds)
-[AVMIDIPlayer currentPosition]
MusicPlayerGetTime(impl->mPlayer, &positionInBeats)
MusicSequenceGetSecondsForBeats(impl->mSequence, positionInBeats, &positionInTime)
-[AVMIDIPlayer setCurrentPosition:]
MusicSequenceGetBeatsForSeconds(impl->mSequence, (Float64) currentPosition, &positionInBeats)
MusicPlayerSetTime(impl->mPlayer, positionInBeats)
avmp
CallbackQueue
start
MusicPlayerStart(mPlayer)
stop
MusicPlayerStop(mPlayer)
finishLoad
MusicSequenceGetAUGraph(mSequence, &graph)
MusicSequenceGetTrackCount(mSequence, &trackCount)
MusicTrackGetProperty(track, kSequenceTrackProperty_TrackLength, &length, &plength)
MusicSequenceSetUserCallback(mSequence, userCallback, this)
SetUpGraph
AUGraphOpen(inGraph)
AUGraphGetNodeCount (inGraph, &nodeCount)
AUGraphGetIndNode(inGraph, i, &node)
AUGraphNodeInfo(inGraph, node, &desc, &unit)
AudioUnitSetProperty (unit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &numFrames, sizeof(numFrames))
AUGraphInitialize(inGraph)
AVVCTestDevice
AVVCRouteManager.mm
Error! No Remote Device Found
Error! No RemoteInputDeviceName property
No Playback Route
/9luHerXthRoPoNt/PVkTg
AVAudioUnitMIDIInstrument.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitMIDIInstrument.mm
SendProgramChange
true == SendMIDIEvent(kMIDIMessage_ControlChange, 0, bankMSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_ControlChange, bankSelectLSBParam1, bankLSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_PatchChange, programID, 0, 0, channel)
-[AVAudioUnitMIDIInstrument initWithAudioComponentDescription:]
(description.componentType == kAudioUnitType_MusicDevice) || (description.componentType == kAudioUnitType_RemoteInstrument)
-[AVAudioUnitMIDIInstrument startNote:withVelocity:onChannel:]
_IMPL->StartNote(note, velocity, channel)
-[AVAudioUnitMIDIInstrument stopNote:onChannel:]
_IMPL->StopNote(note, channel)
-[AVAudioUnitMIDIInstrument sendController:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ControlChange, controller, controllerValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendPitchBend:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PitchBend, value&0x7F, value>>7, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressure:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ChannelPressure, pressureValue, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressureForKey:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_KeyPressure, key, pressureValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PatchChange, program, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:bankMSB:bankLSB:onChannel:]
_IMPL->SendProgramChange(program, bankMSB, bankLSB, channel)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:data2:]
_IMPL->SendMIDIEvent(midiStatus, data1, data2, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:]
_IMPL->SendMIDIEvent(midiStatus, data1, 0, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDISysExEvent:]
_IMPL->SendMIDISysexEvent((CFDataRef)midiData)
-[AVAudioUnitMIDIInstrument sendMIDIEventList:]
_IMPL->SendMIDIEventList(eventList, 0, 0)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVFAudioCore/AVAudioBuffer.mm
-[AVAudioBuffer initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:]
isPCMFormat(fmt)
bufferList != nullptr
bufferList->mNumberBuffers == numBuffers
-[AVAudioBuffer setByteLength:]
length <= _imp->_byteCapacity
<%@@%p: %d/%d bytes>
-[AVAudioPCMBuffer initWithPCMFormat:frameCapacity:]
AVAudioBuffer.mm
_imp->OwnsMemory() && !_imp->_externalABL.has_value()
-[AVAudioPCMBuffer initWithPCMFormat:bufferListNoCopy:deallocator:]
!_imp->OwnsMemory() && _imp->_externalABL.has_value()
-[AVAudioPCMBuffer setFrameLength:]
length <= _imp->_frameCapacity
-[AVAudioCompressedBuffer initWithFormat:packetCapacity:maximumPacketSize:]
!(fmt.IsLinearPCM() || fmt.mFormatID == kAudioFormatALaw || fmt.mFormatID == kAudioFormatULaw)
maximumPacketSize != 0
-[AVAudioCompressedBuffer setPacketCount:]
length <= _imp->_packetCapacity
ExtendedAudioBufferList_CreateWithFormat failed
ExtendedAudioBufferList_Prepare failed
AVAB
cannot convert to CMAudioFormatDescription %d
<AVAudioFormat %p: %s>
mSampleRate
mFormatID
mFormatFlags
mBytesPerPacket
mFramesPerPacket
mBytesPerFrame
mChannelsPerFrame
mBitsPerChannel
channelLayout
magicCookie
Audio files cannot be non-interleaved. Ignoring setting AVLinearPCMIsNonInterleaved YES.
AVAudioSession
data
outputID
inputID
sampleRate
correlationValue
stimulusURL
outputMode
inputProcessingChain
outputProcessingChain
mode
calculateCrossCorrelationPeak
processSequenceAsynchronously
parallelCrossCorrelationCalculation
numberOfChannels
micBufferNumbers
requiresBluetoothOutput
graphURL
processingStripURL
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSourceNode.mm
AVAudioSourceNodeImpl
SetInputFormat(0, format)
AVVoiceController_RecordQueue
/System/Library/Audio/Tunings/<UPPERCASE_MODEL>/AVVC/<LOWERCASE_MODEL>_mic_voice_recognition.dspg
/System/Library/Audio/Tunings/<UPPERCASE_MODEL>/AVVC/<LOWERCASE_MODEL>_mic_voice_recognition.austrip
/System/Library/Audio/Tunings/<UPPERCASE_MODEL>/AVVC/<LOWERCASE_MODEL>_mic_voice_recognition.propstrip
<UPPERCASE_MODEL>
<LOWERCASE_MODEL>
AVVCAudioQueueRecordingEngine
~AVVCAudioQueueRecordingEngine
AVVCAudioQueueRecordingEngine.mm
AudioQueueRecordPropertyListenerProc
Initialize
createRecordQueue
With
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}12@?0I8
prepareRecording
startRecording
startRecording:AudioQueueReset
future
past
immediate
startRecording : AudioQueueStart
stopRecording
mRecordQueue : AudioQueueStop
destroyRecordEngine
queue : AudioQueueStop
destroyRecordEngine: AudioQueueDispose
enableSiriListeningMode
enableMetering
DeinterleaveAudio
handleRecordQueuePropertyListener
Capture
Capture-DSPOut
resetAudioEngine
resetAudioEngine:mRecordQueue: AudioQueueReset
com.apple.speech.synthesis.voice.Alex
AVSpeechSynthesisIPANotationAttribute
/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle
language
name
quality
voice
speechString
rate
pitchMultiplier
volume
preUtteranceDelay
postUtteranceDelay
attributedSpeechString
mark
byteSampleOffset
textRange
IPHONE_SIMULATOR_ROOT
CFFIXED_USER_HOME
AVVoiceController_AlertQueue
/System/Library/Audio/UISounds/jbl_begin.caf
/System/Library/Audio/UISounds/jbl_confirm.caf
/System/Library/Audio/UISounds/jbl_cancel.caf
setDuckOthersOption
ControllerImplV1V2.mm
setSessionProperties
AVVC Rec Queue RunLoop
DispatchQueue
SIMULATOR_ROOT
%s%@
Alert
Record
Playback
Session
duck_others
AVVC Client Notification Queue
AVVC ControllerImpl Work Queue
~ControllerImpl
setActivationModeAndSessionHWControlFlagsAndOptions_v1v2
deactivateSessionForListening
unconfigured
beginAudioSessionActivate_v1v2
deactivateSessionForListening_v1v2_block_invoke
deactivateSessionForListening:AudioQueueReset
deactivateSessionForListening1
deactivateSessionForListening2
v16@?0@"NSObject<OS_dispatch_semaphore>"8
deactivateSessionForListening_v1v2
createRecordingEngine_v1v2
configureAlerts
configureAlerts_v1v2
cleanup
v20@?0@"NSString"8i16
getPlaybackRoute_v1v2
v28@?0@"NSString"8@"NSString"16i24
getRecordAndPlaybackRoutes_v1v2
setActivationContext_v1v2
checkSession
checkSession_v1
AVVCEngine-prepareRecording from checkSession
deactivateSession_v1v2
AVAudioSessionDeactivate
endAudioSessionActivate_v1v2
setSessionActive_v1v2
setSessionActive
setSessionActive1
setSessionActive2
set endpointer delegate
endpointer reset
internal Speex
external
setupEndpointer_v1v2
setup endpointer
v12@?0i8
setRecordErrorStatus_v1v2
calculateRecordStartTime_v1v2
configureAlertModeFromModeAndEngine
handsFree
built-in speaker
Auto
Post-Voice
iMessageGestureToHead
Dictation
Wired/BT ButtonPress
configureAlertModeFromModeAndEngine_v1v2
stopRecord
stopRecord_v1v2
getRecordElapsedTime_v1v2
setAlertURL
playAlert
playAlert_v1v2
createAlertQueue
primeAlertQueue
primeAlertQueue_v1v2
AudioQueueReset : mAlertQueue
setupAlert
setupAlert_v1v2
startAlertQueue
startAlertQueue_v1v2
mAlertQueue : AudioQueueStart
 but failed
mAlertQueue : AudioQueueStop
destroyAlertQueue
destroyAlertQueue_v1v2
destroyAlertQueue : AudioQueueStop
calculateAlertTimes_v1v2
alertStarted
alertStarted_v1v2
alertFinished
notifyAlertFinished_v1v2
AlertAQPropertyListenerProc
handleAlertAQPropertyChange
vibeStartAlertFinished
vibeStartAlertFinished_v1v2
vibeStopAlertFinished
vibeStopAlertFinished_v1v2
VibeAlertCompletionProc
haptic alertPlaybackFinishedOfType_v1v2
startpointDetected
interspeechPointDetected
endpointDetected
startKeepAliveQueue
stopKeepAliveQueue
primary
handleInterruptStart_v1v2
beginRecordInterruptionWithContext
handleInterruptStop_v1v2
endRecordInterruption
handleRouteChange_v1v2
interrupted
not (yet) active
handleServerDeath_v1v2
handleServerReset_v1v2
RegisterAudioUnits_Internal
getCurrentRecordingEngineStreamState_v1v2
getCurrentRecordEngineType_v1v2
v24@?0{shared_ptr<AVVCRecordingEngine>=^{AVVCRecordingEngine}^{__shared_weak_count}}8
v32@?0Q8q16@"NSError"24
setContext_v1v2
v32@?0Q8@"AVVCAudioBuffer"16B24B28
beganRecording
v36@?0Q8B16q20@"NSError"28
finishedRecording
encodeError
v20@?0Q8I16
B28@?0^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}8^f16I24
i12@?0B8
streamInvalidated
v16@?0Q8
hardwareConfigChanged
beginAudioSessionActivate
v12@?0B8
endAudioSessionActivate
fault_on_streamID_violation
_getCurrentRecordingEngine_v1v2
notifyStreamInvalidated_v1v2
ControllerImpl.h
ExternalDevice
AudioQueue
Plugin
Invalid
Uninitialized
Prepared
Stopped
Starting
Running
Stopping
stopped
starting
active
stopping
Silent
Haptic
Beep
No Override
Mute
uninit
primed
started
running
inactive
getAlertQueueFromRunLoop
implSP->getAudioQueueRunLoop()->IsCurrentThread() && "This code must run only on the AQ runloop thread"
Illegal
'Unknown'
'Override'
'Wake From Sleep'
'No Suitable Route for Category'
'Configuration Change'
avvc
debug_level
AVVC_Log.cpp
debug_encoding
debug_endpoint
debug_callbacks
debug_locking
debug_state
debug_trace
debug_timing
debug_delegate
debug_playback
debug_deviceselect
/System/Library/Frameworks/CoreMedia.framework/CoreMedia
CMAudioFormatDescriptionGetStreamBasicDescription
CMAudioFormatDescriptionCreate
CMAudioFormatDescriptionGetChannelLayout
CMAudioFormatDescriptionGetMagicCookie
VirtualAudio
siri_ducking_for_speaker
BTDetails_SupportsDoAP
BTDetails_SupportsSoftwareVolume
SoftwareVolumeEnabled
AVVCSessionManager.mm
setupOneTimeSessionSettingsForClient
-[AVVCSessionManager setupOneTimeSessionSettingsForClient:]
setSessionActivationContext
-[AVVCSessionManager setSessionActivationContext:]
-[AVVCSessionManager shouldEnableMiniDucking:withOptions:]
shouldEnableMiniDucking
-[AVVCSessionManager getHypotheticalRouteAndUpdateStates]
getHypotheticalRouteAndUpdateStates
setSessionCategoryModeOptionsForActivationMode
-[AVVCSessionManager setSessionCategoryModeOptionsForActivationMode:withOptions:]
setSessionCategoryModeOptionsFromActivationMode
setSessionAudioHWControlFlagsForActivationMode
-[AVVCSessionManager setSessionAudioHWControlFlagsForActivationMode:withOptions:]
setSessionAudioHWControlFlagsFromActivationMode
setSessionSampleRateForActivationMode
-[AVVCSessionManager setSessionSampleRateForActivationMode:]
setSessionSampleRateFromActivationMode
setSessionBufferSize
-[AVVCSessionManager setSessionBufferSize:]
-[AVVCSessionManager setDuckOthers:mixWithOthers:error:]
setDuckOthersMixWithOthers
setDuckOthers:mixWithOthers
-[AVVCSessionManager setDuckingFadeOutDuration:fadeInDuration:error:]
setDuckingFadeDuration
-[AVVCSessionManager isSessionOutputInWirelessSplitterMode]
isSessionOutputInWirelessSplitterMode
enableSmartRoutingConsideration
-[AVVCSessionManager enableSmartRoutingConsideration:]
activateAudioSessionWithPrewarm
prewarmAudioSession
activateAudioSession
-[AVVCSessionManager activateAudioSessionWithPrewarm:error:]
AVAudioSessionSetActive
B8@?0
deactivateAudioSessionWithOptions
setEnableBTTriangleMode
inputLatency
outputLatency
speechDetectionDeviceSampleRate
setCategory:mode:options
setCategory:mode:routeSharingPolicy:options
clearInputPreferences
isSessionInSiriCategory
setAudioHardwareControlFlags
-[AVVCSessionManager reporterID]
reporterID
setIAmTheAssistant
setPreferredSampleRate:error
siriInputSource
setActivationContext
setActive
getOpaqueSessionID
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
setRecordingFromRemoteInput
inputNumberOfChannels
setDuckToLevelDB
setDuckToLevelScalar
isSWVolumeSupportedOnPickedRoute
ILLEGAL
NotConfigured
Inactive
InteruptedWhileRecording
InteruptedWhilePlaying
Prewarming
Activating
Deactivating
Active
dump_input
AVVCAudioCapturer.mm
/tmp/Assistant/AVVCCapture/
/usr/local/lib/libAudioDiagnostics.dylib
NewAudioCapturerImpl
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioFile.mm
-[AVAudioFile writeFromBuffer:error:]
buffer != nil
_imp->CheckClientFormatSet()
ExtAudioFileWrite(_imp->_extAudioFile, buffer.frameLength, buffer.audioBufferList)
-[AVAudioFile readIntoBuffer:frameCount:error:]
frames <= buffer.frameCapacity
buffer.frameCapacity != 0
ExtAudioFileRead(_imp->_extAudioFile, &ioFrames, buffer.mutableAudioBufferList)
-[AVAudioFile length]
ExtAudioFileGetProperty(_imp->_extAudioFile, kExtAudioFileProperty_FileLengthFrames, &propSize, &length)
-[AVAudioFile framePosition]
ExtAudioFileTell(_imp->_extAudioFile, &pos)
-[AVAudioFile setFramePosition:]
ExtAudioFileSeek(_imp->_extAudioFile, pos)
AVAudioFileImpl
fileURL != nil
ExtAudioFileOpenURL((CFURLRef)fileURL, &_extAudioFile)
_initCommonReading
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_FileDataFormat, &propSize, &fileASBD)
SetFormats(format, interleaved, fileASBD, avacl)
ReadMagicCookie
_fileFormat
_processingFormat
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &fileID)
ExtAudioFileCreateWithURL((CFURLRef)fileURL, fileType, &fileASBD, NULL, kAudioFileFlags_EraseFile, &_extAudioFile)
AudioConverterSetProperty(converter, kAudioCodecPropertyBitRateControlMode, sizeof(UInt32), &value)
GetAudioConverter
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioConverter, &size, &converter)
setVBRQuality
AudioConverterSetProperty(converter, kAudioCodecPropertySoundQualityForVBR, sizeof(UInt32), &audioQuality)
setBitRate
AudioConverterSetProperty(converter, kAudioConverterEncodeBitRate, sizeof(UInt32), &bitRate)
AudioConverterSetProperty(converter, kAudioConverterEncodeBitRate, sizeof(UInt32), &bitRatePerChannel)
ExtAudioFileGetProperty(openFileImpl->_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &openAudioFileID)
ExtAudioFileWrapAudioFileID(openAudioFileID, false, &_extAudioFile)
CheckClientFormatSet()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioNode.mm
-[AVAudioNode installTapOnBus:bufferSize:format:block:]
tapBlock
NULL != engine
-[AVAudioNode removeTapOnBus:]
-[AVAudioNode destinationForMixer:bus:]
mixer
-[AVAudioMixingDestination destinationForMixer:bus:]
GetMixingDestination
inMixerAVNode
WillDisconnectFromMixer
mixingDest
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioNodeImpl.h
AVAE_CheckNodeHasEngine
_engine != nil
aupreset
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitSampler.mm
-[AVAudioUnitSampler loadInstrumentAtURL:error:]
error
-[AVAudioUnitSampler loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:]
-[AVAudioUnitSampler loadAudioFilesAtURLs:error:]
AVAudioIOUnit
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioIONodeImpl.mm
AUI().AddV2PropertyListener(propID, IOUnitPropertyListener, this)
_GetHWFormat
hwFormat
SetOutputFormat
_isInput
IsFormatSampleRateAndChannelCountValid(format)
IsFormatSampleRateAndChannelCountValid(hwFormat)
format.sampleRate == hwFormat.sampleRate
SetInputFormat
!_isInput
error %d
Audio/Plug-Ins/RemoteInput/
AVVCPluginRemoteInputHost.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSequencer.mm
-[AVAudioSequencer(AVAudioSequencer_Player) prepareToPlay]
impl->PrepareToPlay()
-[AVAudioSequencer(AVAudioSequencer_Player) startAndReturnError:]
impl->Start()
-[AVAudioSequencer(AVAudioSequencer_Player) stop]
impl->Stop()
-[AVAudioSequencer loadFromURL:options:error:]
impl->LoadFromFile((__bridge CFURLRef)fileURL, (UInt32)options)
-[AVAudioSequencer loadFromData:options:error:]
impl->LoadFromData((__bridge CFDataRef)data, (UInt32)options)
-[AVAudioSequencer writeToURL:SMPTEResolution:replaceExisting:error:]
impl->WriteToFile((__bridge CFURLRef)fileURL, (SInt32)resolution, replace)
-[AVAudioSequencer dataWithSMPTEResolution:error:]
impl->WriteToData(&outData, (SInt32)SMPTEResolution)
-[AVMusicTrack setNumberOfLoops:]
numberOfLoops != 0
AVMusicEvent was not of any known class
AVAudioSequencer.mm
Should never get a NULL event type
album
approximate duration in seconds
artist
channel layout
comments
composer
copyright
encoding application
genre
ISRC
key signature
lyricist
nominal bit rate
recorded date
source bit depth
source encoder
subtitle
tempo
time signature
title
track number
year
%.6f s
%ld fr (/%.f Hz)
%.6f rs
<AVAudioTime %p: %s %s %s>
/System/Library/Frameworks/AudioToolbox.framework/libAudioDSP.dylib
GetAudioDSPManager
AVAudioUnitDSPGraph.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitEffect.mm
-[AVAudioUnitEffect initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Effect) || (audioComponentDescription.componentType == kAudioUnitType_MusicEffect) || (audioComponentDescription.componentType == kAudioUnitType_Panner) || (audioComponentDescription.componentType == kAudioUnitType_RemoteEffect) || (audioComponentDescription.componentType == kAudioUnitType_RemoteMusicEffect)
v16@?0q8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioPlayerNode.mm
-[AVAudioPlayerNode scheduleBuffer:atTime:options:completionCallbackType:completionHandler:]
when == nil || when.sampleTimeValid || when.hostTimeValid
-[AVAudioPlayerNode scheduleFile:atTime:completionCallbackType:completionHandler:]
file != nil
-[AVAudioPlayerNode scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:]
stream != nil
startFrame >= 0
numberFrames > 0
-[AVAudioPlayerNode nodeTimeForPlayerTime:]
playerTime == nil || playerTime.sampleTimeValid || playerTime.hostTimeValid
-[AVAudioPlayerNode playerTimeForNodeTime:]
nodeTime == nil || nodeTime.sampleTimeValid || nodeTime.hostTimeValid
AVAudioPlayerNodeImpl.CompletionHandlerQueue
CommandQueue
v8@?0
StartImpl
AVAudioPlayerNode.mm
_engine->IsRunning()
player started when in a disconnected state
player did not see an IO cycle.
nearFutureTime.sampleTimeValid
when.hostTimeValid
inTimeFull.sampleTimeValid
avpln
avpln_verbose
ScheduleBuffer
_outputFormat.channelCount == buffer.format.channelCount
HandleCompletionOfCommand
completionHandler != nil
bufferFromFileInfo.has_value()
CallCompletionHandler
completionHandler
SignalEndOfRender
completionHandlerWrapperPtr && completionHandlerWrapperPtr->Block()
ResolveToPlayerSampleTime
playerTime && playerTime.sampleTimeValid
has_borealis_xpc
AVVoiceTriggerClient init
AVVoiceTriggerClient.mm
dealloc
handleMediaServerReset:
voiceTriggerPastDataFramesAvailableCompletion
getInputChannelInfoCompletion
voiceTriggerPastDataFramesAvailable
v24@?0Q8@"NSError"16
enableVoiceTriggerListening:
v16@?0@"NSError"8
enableVoiceTriggerListening:completionBlock:
Enable
Disable
enableSpeakerStateListening:completionBlock:
speakerStateActiveCompletionBlock:
speakerStateActive
v20@?0B8@"NSError"12
speakerStateMutedCompletionBlock:
speakerStateMuted
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:completionBlock:
listeningEnabledCompletionBlock:
siriClientRunningCountCompletionBlock:
com.apple.coreaudio.avfaudio.workloop(
%s %s %s
v20@?0^{OpaqueAudioComponentInstance=}8i16
AVAudioEngineConfigurationChangeNotification
com.apple.avfaudio
avae
avae_verbose
AVAudioEngine.mm
engine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioEngine.mm
AttachNode
node != nil
!IsInternalNode(node)
nil == owningEngine || GetEngine() == owningEngine
nodeimpl->HasEngineImpl()
DetachNode
!nodeimpl->HasEngineImpl()
GetIOUnit
!IsInManualRenderingMode()
GetOutputNode
_outputNode != nil
GetInputNode
_inputNode != nil
UpdateOutputNode
[_outputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_outputNode)
UpdateInputNode
[_inputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_inputNode)
UpdateIONodesForVP
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:false forceIOUnitReset:true]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:true forceIOUnitReset:true]
Connect
node1 != nil && node2 != nil
node1 != node2
[_nodes containsObject: node1] && [_nodes containsObject: node2]
ConnectMultipleOutputs
nil != sourceNode && nil != destNodes && [destNodes count] > 0
[_nodes containsObject: sourceNode]
object && [object isKindOfClass: [AVAudioConnectionPoint class]]
[_nodes containsObject: connPoint.node]
sourceNode != connPoint.node
DisconnectInput
[_nodes containsObject: node]
_graph->DisconnectInput(node, bus)
DisconnectOutput
_graph->DisconnectOutput(node, bus)
DisconnectAllInputs
_graph->DisconnectAllInputs(node)
DisconnectAllOutputs
_graph->DisconnectAllOutputs(node)
ConnectMIDI
node1 != nil && node2 != nil && node1 != node2
object && [object isKindOfClass: [AVAudioNode class]]
DisconnectMIDI
sourceNode != nil && destNode != nil
sourceNode != nil && destNodes != nil && destNodes.count > 0
_graph->DisconnectMIDI(sourceNode, destNodes)
DisconnectAllMIDIInputs
DisconnectAllMIDIOutputs
GetInputConnectionPointForNode
node != nil && [_nodes containsObject: node]
GetOutputConnectionPointsForNode
Uninitialize
_graph->Uninitialize(outErr)
Pause
_graph->Stop(outErr)
CheckCanPerformIO
canPerformIO
q28@?0I8^{AudioBufferList=I[1{AudioBuffer=II^v}]}12^i20
CreateGraphNode
_graph->AddNode(inNode)
DestroyGraphNode
_graph->RemoveNode(inNode, outErr)
InstallTapOnNode
_graph->InstallTapOnNode(inNode, bus, bufferSize, format, tapBlock)
RemoveTapOnNode
_graph->RemoveTapOnNode(inNode, bus)
SetSequence
_graph->SetSequence(inSequence)
 node: 
 (bus: 
AVFormatIDKey
AVSampleRateKey
AVNumberOfChannelsKey
AVLinearPCMBitDepthKey
AVLinearPCMIsBigEndianKey
AVLinearPCMIsFloatKey
AVLinearPCMIsNonInterleaved
AVAudioFileTypeKey
AVEncoderQualityKey
AVEncoderQualityForVBRKey
AVEncoderBitRateStrategyKey
AVEncoderBitRateKey
AVEncoderBitRatePerChannelKey
AVEncoderBitDepthHintKey
AVSampleRateConverterAlgorithmKey
AVSampleRateConverterQualityKey
AVChannelLayoutKey
AVAudioBitRateStrategy_Constant
AVAudioBitRateStrategy_LongTermAverage
AVAudioBitRateStrategy_VariableConstrained
AVAudioBitRateStrategy_Variable
AVSampleRateConverterAlgorithm_Normal
AVSampleRateConverterAlgorithm_Mastering
AVSampleRateConverterAlgorithm_MinimumPhase
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AUInterface.mm
AddRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &inRenderCallback, sizeof(inRenderCallback))
RemoveRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &rcb, sizeof(rcb))
AUInterfaceBaseV3
comp != nullptr
AudioComponentInstanceNew(comp, &_auv2)
_auv2 != nullptr
_auv3 == nil
_auv3 != nil
nil != midiEventBlock
nil != midiEventListBlock
SetFormat
[[busArray objectAtIndexedSubscript:(NSUInteger)element] setFormat:format error:&nsErr]
SetNumberInputs
[[auv3() inputBusses] setBusCount:(NSUInteger)numberInputs error:&nsErr]
SetNumberOutputs
[[auv3() outputBusses] setBusCount:(NSUInteger)numberOutputs error:&nsErr]
SendMIDIEvent
nil != ScheduleMIDIEventBlock()
nullptr != midiBytes
SendMIDIEventList
nil != ScheduleMIDIEventListBlock()
nullptr != eventList
AddRenderObserver
inRenderCallback.inputProc
v32@?0I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}12I20q24
AVAEInternal.h
true
false
%s: returned %s, error %@
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
%25s:%-5d CarPlay API not available
%25s:%-5d AVOutputContext API not available
%25s:%-5d supportsMultipleBTDevices: %d
%25s:%-5d Wireless Output Devices: %@
%25s:%-5d AVOutputDevice %p supports BT sharing: %d
%25s:%-5d RegisterObject: registering %p
%25s:%-5d UnregisterObject: unregistering %p
 ASSERTION FAILED: unregistering a nonexistent object!
%25s:%-5d Acoustic ID returned %d. Lets try the older method to load DSP graph
%25s:%-5d Unexpected product 0x%x will not load DSP graph
%25s:%-5d Product 0x%x, numChannels unchanged at: %u
%25s:%-5d CurrentRoute: %@
%25s:%-5d PreviousRoute: %@
%25s:%-5d RouteChangeReason: %s
%25s:%-5d AVVC Serialization is%s enabled
%25s:%-5d runloop block timeout!
%25s:%-5d waiting for any in-flight AudioQueue property change message on run loop...
%25s:%-5d CallbackBarrier: 9 second timeout!
%25s:%-5d received all AudioQueue property change messages on run loop.
%25s:%-5d API timeout
%s API timeout. Called from %s
%25s:%-5d AVVCPluginRecordingEngine()
%25s:%-5d ~AVVCPluginRecordingEngine()
%25s:%-5d finding the first device for activation mode (%{audio:4CC}d)  : %p
%25s:%-5d device identifier shouldn't be NULL... 
%25s:%-5d device identifier : %@
%25s:%-5d setHWSampleRate() streamID(%lu) sr(%.2f) upSamp(%d)
%25s:%-5d session state (%s), rec-engine [%@], rec-engine type (%s), stream state (%s)
%25s:%-5d (self %p)startRecord : using activeDevice: %p
%25s:%-5d #### calling startRecordingWithCompletionBlock on device (%p) ####
%25s:%-5d startedRecording: nil object encountered (eng: %p). Bailing
%25s:%-5d AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING
%25s:%-5d AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING-PAUSED
%25s:%-5d startRecordingWithCompletionBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%25s:%-5d AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: returned error(%d) : %@. Setting the audioInputBlock to nil.
%25s:%-5d startRecordQueue:  No device found, err : %d
%25s:%-5d AVVCPluginRecordingEngine::stopRecording: mRecordIsStopping set to true
%25s:%-5d stopRecording: nil object encountered (eng: %p). Bailing
%25s:%-5d AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: STOPPED
%25s:%-5d AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%25s:%-5d stopRecording:  No device found error :%d
%25s:%-5d (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Entering --->
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine: about to call stopRecordingCompletionBlock - previous stop completion block didn't happen
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine -- stopRecordingWithCompletionBlock: STOPPED
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine - stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine:  calling doneRecording manually
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine:  skipping doneRecording as we are deallocating
%25s:%-5d destroyRecordEngine: device found, err : %d
%25s:%-5d (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Exiting <---
%25s:%-5d AVVCPluginRecordingEngine::createRecordQueue : no matching device found, error : %d
%25s:%-5d supported Formats[%d] : %@ 
%25s:%-5d Using Format[0] : %@ 
%25s:%-5d No Format specified.. Error
%25s:%-5d clientRequestedSR was:%.2f, setting to %.2f
%25s:%-5d clientRequestedSR was not specified, setting to %.2f
%25s:%-5d AVVCPluginRecordingEngine(%p)::createRecordQueue -->
%25s:%-5d createRecordQueue : using device %p
%25s:%-5d createRecordQueue : setting format on active device(%p), format:%@
%25s:%-5d Record queue state does not match queue (previously assertion failure)
%25s:%-5d audioInputBlock: nil object encountered (eng: %p). Bailing
%25s:%-5d audioInputBlock (lpcm) called with frameLength : %d
%25s:%-5d audioInputBlock (opus / speex) called with packetcount : %d
%25s:%-5d audioInputBlock called with an unsupported audio format ID (%lu).
%25s:%-5d audioInputBlock called
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: timeStamp : %f
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: Nil VoiceActivity NSData
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: inGain : %f
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: No Gain Value
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: No frame qualities.
%25s:%-5d statusChangeBlock: nil object encountered (eng: %p). Bailing
%25s:%-5d statusChangeBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil. strong_this(%p)
%25s:%-5d In AVVCPluginRecordingEngine::handleRecordInput: %u frames, hostTime : %lld, sampletime : %f
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput: record internally stopped, so throwing away buffer. StreamState(%s). RecordCancelled(%d)
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput - recordState is active, but getting nil buffer
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput (opus). bufferLength : %d, packetCount : %d, packetDesc.startOffset %lld, packetDesc.mVariableFramesInPacket %u, packetDesc.DataByteSize = %u
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput (opus): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%25s:%-5d Setting up client buffer
%25s:%-5d Copying BT audio buffer, size %u
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput (speex): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput - Unsupported formatID: %u
%25s:%-5d Exiting AVVCPluginRecordingEngine::handleRecordInput
%25s:%-5d >> %s
%25s:%-5d << %s
%25s:%-5d AVVCRecordDeviceInfo initWithRecordingEngine[%@]. self(%p)
%25s:%-5d AVVCRecordDeviceInfo initWithRecordingEngine: recordDeviceName(%@)
%25s:%-5d AVVCRecordDeviceInfo initWithRecordingEngine: remoteDeviceUUID(%@)
%25s:%-5d AVVCRecordDeviceInfo initWithVoiceController: remoteDeviceCategory(%d)
%25s:%-5d AVVCRecordDeviceInfo dealloc. self(%p)
%25s:%-5d setSessionNotifications: setting up notifications for %s session(%p)
%25s:%-5d removeSessionNotifications: removing all notifications for %s session(%p)
%25s:%-5d #### hardwareConfigChanged: ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
 ASSERTION FAILED: handleInterruption_v1v2: called with NULL impl!
%25s:%-5d #### AVVoiceController handleInterruption_v1v2: %s session (%p), %@
 ASSERTION FAILED: handleRouteChange_v1v2: called with NULL impl!
%25s:%-5d #### AVVoiceController handleRouteChange_v1v2: %s session (%p)
 ASSERTION FAILED: handleMediaServerDeath: called with NULL impl!
 ASSERTION FAILED: handleMediaServerReset: called with NULL impl!
%25s:%-5d Error! handlePluginDidPublishDevice: ControllerImpl is NULL
%25s:%-5d Error! handlePluginDidUNpublishDevice: ControllerImpl is NULL
%25s:%-5d #### beganRecording: (success = %d status = %d streamID = %llu) ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidStartRecording: variants
%25s:%-5d finishedRecording -> called after AVVC object destroyed -- ignoring call and possibly leaking ControllerImpl
%25s:%-5d finishedRecording -> called after dealloc -- ignoring call
%25s:%-5d #### AVVoiceController: Recording finished (success = %d status = %d streamID = %llu) ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidStopRecording:forReason:
%25s:%-5d startpointDetected -> called after object destroyed -- ignoring call
%25s:%-5d #### startpointDetected: ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidDetectStartpoint:
%25s:%-5d interspeechPointDetected -> called after object destroyed -- ignoring call
%25s:%-5d #### interspeechPointDetected: time %.2f seconds ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidDetectEndpoint:ofType:
%25s:%-5d endpointDetected -> called after object destroyed -- ignoring call
%25s:%-5d #### endpointDetected: time %.2f seconds ####
%25s:%-5d     Reporting encoder error %s via delegate
%25s:%-5d encodeError detected but no record delegate, or notify selector not supported
%25s:%-5d Calling alert playback finished delegate. Settings { Type: %d, Mode: %d, alertEndTime: %llu }
%25s:%-5d Calling alert playback finished delegate. Type: %d
%25s:%-5d Notifying streamHandle(%lu) invalidated
%25s:%-5d streamHandle(%lu) invalidated but no record delegate, or notify selector not supported
%25s:%-5d handleInterruptStart: notifying with context: %@
%25s:%-5d handleInterruptStart: notifying without context
%25s:%-5d handleInterruptStart: WARNING: delegate does not respond to voiceControllerBeginRecordInterruption:
%25s:%-5d handleInterruptStop: notifying
%25s:%-5d Calling record delegate's voiceControllerWillSetAudioSessionActive. Going active? : %d
%25s:%-5d Calling record delegate's voiceControllerDidSetAudioSessionActive. Going active? : %d
%25s:%-5d ### Record route ###
%25s:%-5d ### Playback route ###
%25s:%-5d Playback route: %@
%25s:%-5d setStopOnBargeInEnabled: barge-in previously detected -- stopping playback
%25s:%-5d prepareRecordWithSettings should be called first before asking for number of channels
%25s:%-5d [enforce 1 avvc] #### AVVoiceController: initWithContext: [self == %p]. with context:%{audio:4CC}d %@
%25s:%-5d initWithContext: ControllerImpl() failed with error: %ld
%25s:%-5d initWithContext: calling setSessionProperties
%25s:%-5d AVVoiceController: initWithContext failure
%25s:%-5d #### initWithContext finished [self = %p] ####
%25s:%-5d #### AVVoiceController: prewarmAudioSession: ####
%25s:%-5d self == %p
%25s:%-5d beginning teardown. self == %p
%25s:%-5d [enforce 1 avvc] #### AVVoiceController: dealloc [self == %p] ####
%25s:%-5d In dealloc without prior teardownWithError: call. Controller(%p)
In dealloc without prior teardownWithError: call. Controller(%p)
%25s:%-5d Problem tearing down. Error : %@
%25s:%-5d #### AVVoiceController: exiting dealloc ####
%25s:%-5d #### AVVoiceController: releaseAudioSession: [self = %p] ####
%25s:%-5d #### AVVoiceController: releaseAudioSession:options [self = %p] ####
%25s:%-5d #### AVVoiceController: enableMiniDucking: %d
%25s:%-5d #### AVVoiceController: willAcceptContext: with context:%{audio:4CC}d %@
%25s:%-5d ### unimplemented in this platform
%25s:%-5d #### AVVoiceController[self = %p]: setCurrentContext: with context:%{audio:4CC}d %@
%25s:%-5d #### setCurrentContext:error finished [self = %p]####
%25s:%-5d #### AVVoiceController[self = %p]: prepareRecordWithSettings: %@ 
%25s:%-5d prepareRecordWithSettings failed with internal error %s
%25s:%-5d #### prepareRecordWithSettings finished ####
%25s:%-5d #### AVVoiceController: setAlertSoundFromURL: %@ forType: %d ####
%25s:%-5d setAlertSoundFromURL:forType: Illegal alertType
%25s:%-5d call to playAlertSoundForType blocked because mediaserverd is dead
%25s:%-5d #### AVVoiceController: playAlertSoundForType: %d [self = %p]####
%25s:%-5d playAlertSoundForType: Session check failed: %s
%25s:%-5d playAlertSoundForType: Illegal alertType
%25s:%-5d #### AVVoiceController: resetEndpointer ####
%25s:%-5d #### AVVoiceController: playRecordStartingAlertAndResetEndpointer ####
%25s:%-5d #### AVVoiceController::playRecordStartingAlertAndResetEndpointer current Context  %@ ####
%25s:%-5d #### AVVoiceController: startRecording [self = %p]####
%25s:%-5d #### AVVoiceController: startRecording:(NSError **) [self = %p]####
%25s:%-5d #### AVVoiceController: startRecordingAtTime:error : %d [self = %p]####
%25s:%-5d #### AVVoiceController: startRecordingAtTime:error [self = %p]####
%25s:%-5d #### AVVoiceController:[self = %p] startRecordingWithSettings:error %@
%25s:%-5d AVVoiceController: startRecordingWithSettings: Ignoring old style alert behavior
%25s:%-5d #### AVVoiceController:[self = %p] startRecordingWithSettings:error = %d
%25s:%-5d #### AVVoiceController: stopRecording ####
%25s:%-5d #### AVVoiceController: setRecordDelegate: %p ####
%25s:%-5d #### AVVoiceController: setRecordBufferDuration: %f ####
%25s:%-5d #### AVVoiceController: setEndpointerDelegate ####
%25s:%-5d #### AVVoiceController: setRecordEndpointMode: %d ####
%25s:%-5d #### AVVoiceController: recordStartWaitTime: %f ####
%25s:%-5d isRecording: rec-engine type: %s, stream state: %s
%25s:%-5d #### AVVoiceController: setAlertVolume: %f ####
%25s:%-5d #### AVVoiceController: setMeteringEnabled: %d ####
%25s:%-5d setStopOnEndpointEnabled: endpoint previously detected -- stopping capture
%25s:%-5d #### AVVoiceController: currentRecordDeviceInfo. self(%p) ####
%25s:%-5d [enforce 1 avvc] #### AVVoiceController: initWithError (V2): [self == %p]
%25s:%-5d initWithError: Failed to create ControllerImpl or configureAlerts - error (%ld)
%25s:%-5d #### AVVoiceController[self = %p]: setContext:streamType:completion: activationMode(%@), deviceUID(%@)
%25s:%-5d #### AVVoiceController[self = %p]: setContext: activationMode(%@), deviceUID(%@)
%25s:%-5d !! DEPRECATED !! #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%25s:%-5d #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%25s:%-5d !! DEPRECATED !! #### AVVoiceController[self = %p]: startRecordWithSettings:completion:alertCompletion:audioCallback: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d)
%25s:%-5d #### AVVoiceController[self = %p]: startRecordForStream:completion: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d,%s)
%25s:%-5d #### AVVoiceController[self = %p]: startRecordForStream: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d,%s)
%25s:%-5d #### AVVoiceController[self = %p]: configureAlertBehaviorForStream:completion: streamHandle(%lu), AlertsOverride(%d,%d,%d)
%25s:%-5d #### AVVoiceController[self = %p]: configureAlertBehaviorForStream: streamHandle(%lu), AlertsOverride(%d,%d,%d)
%25s:%-5d !! DEPRECATED !! #### AVVoiceController[self = %p]: stopRecordForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: stopRecordForStream: streamHandle(%lu)
%s unexpected error (%d) returned from stopRecordForStream for streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: getCurrentStreamState: streamHandle(%lu). State(%s)
%25s:%-5d #### AVVoiceController[self = %p]: getRecordDeviceInfoForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d). streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d), switchRecordMode(%d). streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: deactivateAudioSessionWithOptions(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: deactivateAudioSessionForStream:(%d) withOptions(%lu) completion:
%25s:%-5d #### AVVoiceController[self = %p]: deactivateAudioSessionForStream:(%d) withOptions(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: setContextForStream: activationMode(%@), deviceUID(%@). streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: playAlert alertType(%d). overrideMode(%d)
%25s:%-5d #### AVVoiceController[self = %p]: playAlertSoundForStream: alertType(%d) overrideMode(%d)
%25s:%-5d playAlertSoundForStream failed with error : %d
%25s:%-5d #### AVVoiceController[self = %p]: setRecordStatusChangeBlock
%25s:%-5d #### AVVoiceController[self = %p]: enableSmartRoutingConsideration: streamHandle(%lu), enable : %d
%25s:%-5d #### AVVoiceController[self = %p]: setAnnounceCallsEnabledForStream: streamHandle(%lu), enable : %d
%25s:%-5d #### AVVoiceController[self = %p]: getInputChannelInfoForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: setDuckOthersForStream: streamHandle(%lu), duckSettings(%@)
%25s:%-5d #### AVVoiceController[self = %p]: isDuckingSupportedOnPickedRouteForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: enableTriangleModeForStream: streamHandle(%lu), opt value : %d
%25s:%-5d [enforce 1 avvc] before wait controller(%p), %@
%25s:%-5d [enforce 1 avvc] after wait%s controller(%p), %@
%25s:%-5d [enforce 1 avvc] Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously
[enforce 1 avvc] %s Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously. Controller(%p)
%25s:%-5d [enforce 1 avvc] created gsAVVCSingleInstanceSemaphore %@
%25s:%-5d %s : %s : start: %s end: %s duration %.2f ms
%25s:%-5d %s : start: %s end: %s duration %.2f ms
%25s:%-5d about to lock %s
%25s:%-5d about to unlock %s
%25s:%-5d [enforce 1 avvc] before signal avvc(%p), %@
%25s:%-5d [enforce 1 avvc] after signal avvc(%p), %@
%25s:%-5d QualityDetector: Start thresh: %u Start Timeout: %u End thresh: %u  End Timeout: %u
%25s:%-5d QualityDetector: NONE => ACTIVE
%25s:%-5d QualityDetector: NoSpeech; End Counter %u / %u
%25s:%-5d QualityDetector: NONE => ENDED (TIMEOUT AT START)
%25s:%-5d QualityDetector: Active; End Counter %u / %u
%25s:%-5d QualityDetector: Active; Watching for end point (current frame quality: %u)
%25s:%-5d QualityDetector: ACTIVE => ENDED
%25s:%-5d QualityDetector: ACTIVE => ENDING
%25s:%-5d QualityDetector: Speech Ending; End Counter %u / %u
%25s:%-5d QualityDetector: ENDING => ACTIVE
%25s:%-5d QualityDetector: ENDING => ENDED
 ASSERTION FAILED: inPastFrameCount <= mFrameHistoryLength
%25s:%-5d QualityDetector: Start Timeout: %u frames
%25s:%-5d QualityDetector: Interspeech Timeout: %u frames
%25s:%-5d QualityDetector: End Timeout: %u frames
%25s:%-5d SpeexEndpointer init:
%25s:%-5d SpeexEndpointer dealloc:
%25s:%-5d SpeexEndpointer configureWithSampleRate:
%25s:%-5d SpeexEndpointer configureWithSampleRate:andFrameRate: illegal frame rate!
%25s:%-5d SpeexEndpointer configureWithASBD:andFrameRate
%25s:%-5d SpeexEndpointer setEndpointMode: %d
%25s:%-5d SpeexEndpointer setStartWaitTime: %f
%25s:%-5d SpeexEndpointer setInterspeechWaitTime: %f
%25s:%-5d SpeexEndpointer setEndWaitTime: %f
 ASSERTION FAILED: getStatus called before object was configured!
%25s:%-5d SpeexEndpointer getStatus: Raw Speex qlty frame %d/%d: %.2f rnng avrg: %.2f, med: %.2f, cls: %d
%25s:%-5d #### SpeexEndpointer: Detected start point ####
%25s:%-5d #### SpeexEndpointer: Detected soft end point ####
%25s:%-5d #### SpeexEndpointer: Detected hard end point ####
 CAMutex::CAMutex: Could not init the mutex
 CAMutex::Lock: Could not lock the mutex
 CAMutex::Unlock: Could not unlock the mutex
 CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own
 CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)
 CAPThread::SetPriority: failed to set the fixed-priority policy, Error: 0x%X
 CAPThread::SetPriority: failed to set the precedence policy, Error: 0x%X
 CAPThread::SetTimeConstraints: thread_policy_set failed, Error: %d (%s)
 CAPThread::Start: can't start because the thread is already running
 CAPThread::Start: Thread attributes could not be created.
 CAPThread::Start: A thread could not be created in the detached state.
 CAPThread::Start: Could not create a thread.
%25s:%-5d Trigger clean up of context(%s, %@)
%25s:%-5d AVVCRecordingEngine():~AVVCRecordingEngine() called
%25s:%-5d reconfigure for streamID(%lu) failed to destroy engine (%d)
%25s:%-5d reconfigure for streamID(%lu) failed to prepareRecording (%d)
%25s:%-5d Settings are nil, rebuilding queue
%25s:%-5d prepareRecord: NEW FORMAT: %s
%25s:%-5d ERROR: prepareRecord: createRecordQueue err %d
%25s:%-5d ERROR: prepareRecord: createRecordQueue err %{audio:4CC}d
%25s:%-5d Formats differ, rebuilding queue
%25s:%-5d prepareRecord: CURRENT FORMAT: %s
%25s:%-5d destroying engine because of record error: %d
%25s:%-5d Cached session pointer (%p) for engine(%d, %p)
%25s:%-5d Cached session manager pointer (%p) for engine(%d, %p)
%25s:%-5d AudioQueueGetProperty kAudioConverterSampleRateConverterQuality failed: %d
%25s:%-5d AudioQueueGetProperty kAudioConverterPropertyBitDepthHint failed: %d
%25s:%-5d AudioQueueGetProperty property size of kAudioQueueProperty_ChannelLayout failed: %d OR property size is 0
%25s:%-5d AudioQueueGetProperty returned %d for kAudioQueueProperty_ChannelLayout property size
%25s:%-5d AudioQueueGetProperty kAudioQueueProperty_ChannelLayout failed: %d
%25s:%-5d AudioQueueGetProperty returned (%p) for kAudioQueueProperty_ChannelLayout bytes
%25s:%-5d setStreamState (%s => %s)
%25s:%-5d setRecordErrorStatus: %ld
%25s:%-5d setRecordBufferDuration: Attempting to setRecordBufferDuration while record is active. Stream State(%s)
%25s:%-5d setRecordBufferDuration: specified buffer duration too small -- setting to minimum allowed
%25s:%-5d setRecordBufferDuration: rebuilding queue
%25s:%-5d setRecordBufferDuration: Failed at prepareRecording (reconfig) : %d
%25s:%-5d setRecordBufferDuration: duration now %.3f
%25s:%-5d getRecordBufferDuration: choice 1 mRecordBasePacketsPerSecond (%lu)
%25s:%-5d getRecordBufferDuration: choice 2 mRecordBasePacketsPerSecond (%lu)
%25s:%-5d getRecordBufferDuration: returning %.3f seconds
%25s:%-5d getPeakPowerForChannel on stream(%llu): returning %f for channel %d
%25s:%-5d getAveragePowerForChannel on stream(%llu): returning %f for channel %d
%25s:%-5d AVVCRecordingEngine::cacheRecordRoute : %@
%25s:%-5d setStartRecordCompletionAndAudioCallbackBlocks: startCompletionBlock(%p). audioCallbackBlock(%p)
%25s:%-5d setStopRecordCompletionBlock: stopCompletionBlock(%p).
%25s:%-5d setDidStopDelegateCompletionBlock: didStopCompletionBlock(%p).
%25s:%-5d setEncoderErrorBlock: encoderErrorBlock(%p).
%25s:%-5d setDeferredContextBlock: deferredContextBlock(%p).
%25s:%-5d setSetupEndpointerBlock: setupEndpointerBlock(%p).
%25s:%-5d setCheckForEndpointBlock: checkForEndpointBlock(%p).
%25s:%-5d setStopRecordWithRecordLockBlock: stopRecordWithRecordLockBlock(%p).
%25s:%-5d setDestroyRecordEngineWithRecordLockBlock: destroyRecordEngineWithRecordLockBlock(%p).
%25s:%-5d setReconfigureWithRecordLockBlock: reconfigureWithRecordLockBlock(%p).
%25s:%-5d setStreamInvalidatedBlock: streamInvalidatedBlock(%p).
%25s:%-5d setHardwareConfigChangedBlock: hardwareConfigChangedBlock(%p).
%25s:%-5d setBeginSessionActivateBlock: beginSessionActivateBlock(%p).
%25s:%-5d setEndSessionActivateBlock: endSessionActivateBlock(%p).
%25s:%-5d Reset completion blocks to nil for engine[%@]
%25s:%-5d myBuffer->mAudioData : %p, myBuffer->mAudioDataByteSize : %d
%25s:%-5d Ignoring action, since streamState is already %s
%25s:%-5d stopRecord: record state == kRecordStarting but object being destroyed -- just stop queue
%25s:%-5d doneRecording: resetting mRecordIsStopping and mRecordIsPrimed
%25s:%-5d doneRecording: calling startRecordCompletionBlock(%p) (notify start before stop). Error: %@
%25s:%-5d calling completion block(%p)
%25s:%-5d stopRecordWithRecordLockBlock is nil !
%25s:%-5d destroyRecordEngineWithRecordLockBlock is nil !
mImplInDealloc is true unexpectedly!
%25s:%-5d updateRecordAndPlaybackRoutes: built in route !
%25s:%-5d updateRecordAndPlaybackRoutes: Nil currentRoute!
%25s:%-5d New Record Route  : %@
%25s:%-5d New Playback Route: %@
%25s:%-5d getSessionProperties: unexpected 0.0 value for output latency
%25s:%-5d getSessionProperties: working around bad input latency value for now
%25s:%-5d getSessionProperties: input HW latency: %g output HW latency: %g
%25s:%-5d getSessionProperties: input HW sampling rate %lf
%25s:%-5d getSessionProperties: plugin mode - resetting to default HW sampling rate %lf
%25s:%-5d getSessionProperties: Error getting input hardware sample rate
%25s:%-5d setSessionActive: Error! Attemtping to activate a session that is not configured
%25s:%-5d #### AVVoiceController: %s session ####
%25s:%-5d setSessionActive(true): AVAudioSession:setActive has returned
%25s:%-5d setSessionActive(true): force of getSessionProperties requested
%25s:%-5d setSessionActive(true): force of getSessionProperties requested - returned error : %d
%25s:%-5d setSessionActive(true): Route change when we went active: %@ -- getting properties
%25s:%-5d setSessionActive(false): Deactivating session due to error: %d
%25s:%-5d setSessionActive(true): session state already %s -- no-op
 ca_verify_noerr: [%s, %d]
 timeout
%25s:%-5d Created AVVCSessionFactory (%p)
%25s:%-5d _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing session manager(%p) audioSession(%p) for context(%s, %@)
%25s:%-5d _wqCreateAuxSessionAndManagerForDeviceUID: setActivationContext returned error(%d)
%25s:%-5d _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing sessionManager(%p)
%25s:%-5d Created aux session (%p) and session manager (%p) and setup onetime settings for context(%s, %@)
%25s:%-5d Created primary session manager (%p) and setup onetime settings for context(%s, %@)
%25s:%-5d _wqSessionForContext: activationDeviceUID must be specified for this mode
%25s:%-5d First time primary session (%p) retrieved. Context(%s, %@)
%25s:%-5d retrieved session (%p) and sessionManager (%p) for context(%s, %@)
%25s:%-5d Clean up context(%s, %@), about to release session(%p) and manager(%p)
%25s:%-5d Unexpected error cleaning up context: %@
%25s:%-5d Unexpected missing session when cleaning up context
%25s:%-5d Can't cleanup because devID is missing in context(%s, %@)
%25s:%-5d Nothing to clean up for context(%s, %@)
%25s:%-5d Releasing primary session manager (%p)
%25s:%-5d ---> this = %p
%25s:%-5d <---
%25s:%-5d Track's sequence was NULL
%25s:%-5d Underlying track already destroyed
%25s:%-5d start -> %.2f [end %.2f]
%25s:%-5d end -> %.2f [start %.2f]
%25s:%-5d %sabling looping [%.2f - %.2f]
%25s:%-5d RealtimeMessenger: trying to enqueue duplicate invocation on message %p
%25s:%-5d Error fetching from ring buffer, this = %p, err = %d
%25s:%-5d AVVCRecordingEngineMap::AVVCRecordingEngineMap() Created new Engine Map
%25s:%-5d AVVCRecordingEngineMap::~AVVCRecordingEngineMap() Destroyed Engine Map
%25s:%-5d No recording engine found for stream(%lu)
%25s:%-5d No matching engine found for nil deviceUUID
%25s:%-5d Iterating through EngineMap. AVVCStreamHandle(%lu). AVVCRecordEngine[%@]. DeviceUID(%@). EngineType(%s)
%25s:%-5d Found matching engine of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d No matching plugin engine found for deviceUUID: %@
%25s:%-5d Added engine[%@] for stream(%llu) to the map of size %ld
%25s:%-5d Removing engine[%@] for stream(%llu) from the map
%25s:%-5d Engine for streamID(%llu) not found
%25s:%-5d EngineDispatchGroup wait timed out!
%25s:%-5d Empty Engine Map
%25s:%-5d Engine[%@] type(%s) stream(%llu) deviceUID(%@)
%25s:%-5d AVAudioEngine: left running idle for %.f s
%25s:%-5d AVAudioEngine (auto shutdown mode): left running idle for %.f s, stopping!
%25s:%-5d AVAudioEngine (auto shutdown mode): starting IO dynamically
%25s:%-5d AVAudioEngine (auto shutdown mode): could not dynamically start the audio hardware, err = %s
%25s:%-5d graph@%p: couldn't initialize node@%p {%s}, error %d
%25s:%-5d Can't retrieve source node to play sequence because there is no output node!
%25s:%-5d [%s:%d:%s: (%s): error %d
%25s:%-5d manual rendering mode, setting output type = external speakers
%25s:%-5d setting output type = headphones
%25s:%-5d setting output type = built-in speakers
%25s:%-5d setting output type = external speakers
%25s:%-5d multiple outputs active, setting output type = external speakers
%25s:%-5d Error creating XPC connection to %@
%25s:%-5d %@
%25s:%-5d Interruption Handler: connection got interrupted
%25s:%-5d Invalidation Handler: client exited
%25s:%-5d starting sequence on client side
%25s:%-5d Issuing sandbox %s for path %s
%25s:%-5d failed to extend the service's sandbox
%25s:%-5d result data %@ output %li input %li sample rate %f
%25s:%-5d finishing sequence on client side
%25s:%-5d playback on client side
%25s:%-5d Issuing sandbox %s for path %@
%25s:%-5d starting recording on client side
%25s:%-5d stopping recording on client side
%25s:%-5d AVVCMetricsManager: createSharedManager: referenceCount after incrementing = %llu
%25s:%-5d AVVCMetricsManager: destroySharedManager : referenceCount after decrementing = %llu
%25s:%-5d AVVCMetricsManager: sharedInstance is nil !!!!
%25s:%-5d Profiling AVVC NOW.
%25s:%-5d AVVCMetricsManager: dealloc
%25s:%-5d Measuring Elapsed Time for %@ : %f ms
%25s:%-5d configure: session not configured -- calling setSessionProperties
%25s:%-5d Overwriting an already-deferred context
%25s:%-5d setCurrentContext:error: record is active -- deferring the context change
%25s:%-5d setActivationContext in setCurrentContext failed! %d
%25s:%-5d createRecordingEngine in setCurrentContext failed! %d
%25s:%-5d getCurrentRecordDeviceInfo: Current Recording Engine is nil!
%25s:%-5d getCurrentRecordDeviceInfo: mCurrentRecordDeviceInfo already exists. Deleting old and creating new.
%25s:%-5d recordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%25s:%-5d getCurrentRecordSettings: Error, current recording engine is nil!
%25s:%-5d enableMetering: Current recording engine is nil!
%25s:%-5d updateMeters: Error, current recording engine is nil!
%25s:%-5d getPeakPowerForChannel: Error, current recording engine is nil!
%25s:%-5d isMeteringEnabled: Error, current recording engine is nil!
%25s:%-5d prepareRecord: Can't perform this action while record is starting or active
%25s:%-5d prepareRecord: home/uibp/btbp/vehb button activation : after rechecking which engine to use [%@]
%25s:%-5d createRecordingEngine in prepareRecord_v1 failed : %d
%25s:%-5d Nil Recording Engine! Couldnt get session properties
%25s:%-5d prepareRecord: recording engine is not selected, %{audio:4CC}d
%25s:%-5d startListen: Current recording engine is nil! Bailing!
%25s:%-5d SECOND PASS-Start Record Delta %f ms
%25s:%-5d Attempt to start recording without calling prepareRecordWithSettings:
%25s:%-5d startRecord: already starting or active -- no-op
%25s:%-5d startRecord: failed to play record-start alert. status = %d
%25s:%-5d startRecord: returning failed record status %d
%25s:%-5d getRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%25s:%-5d setRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%25s:%-5d getStartRecordTime: Error, current recording engine is nil!
%25s:%-5d setStartRecordTime: Error, current recording engine is nil!
%25s:%-5d setStartRecordTime: %llu
%25s:%-5d configureAlertOverrides: Session is active. configureAlertModeFromModeAndEngine now. Current recording engine [%@], activation mode (%@)
%25s:%-5d Error setting manual rendering mode input PCM format on input node! %s
%25s:%-5d prepareRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d prepareRecordForStream: Found engine[%@] of type(%s) for streamID(%lu), with activation mode(%@)
%25s:%-5d prepareRecordForStream: Failed to setRecordBufferDuration
%25s:%-5d prepareRecordForStream: Error in prepareRecording: %d
%25s:%-5d prepareRecordForStream: Error in enableMetering: %d
%25s:%-5d startRecordForStream streamID(%lu)
%25s:%-5d startRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d startRecordForStream: Attempt to start stream(%ld) without calling prepare.
%25s:%-5d startRecordForStream: Attempt to start stream(%ld) while stream is already %s. No-op.
%25s:%-5d ERROR in startRecordForStream, failed at playAlert: %d
%25s:%-5d startRecordForStream: Error in startRecording for stream(%lu): %d
%25s:%-5d session (%p) and session mananger (%p) used for engine (%p) with context(%s, %@)
%25s:%-5d startRecordForStream: Skipping alert playback and continuing to startRecord
%25s:%-5d stopRecordForStream streamID(%lu)
%25s:%-5d stopRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%25s:%-5d stopRecordForStream: Attempt to stop on an %s stream.
%25s:%-5d stopRecordForStream: Attempt to stop while stream is already %s. No-op.
%25s:%-5d stopRecordForStream: an error : %d  occurred while recording and we need to synthesize doneRecording
%25s:%-5d stopRecordForStream: Attempt to stop while stream is about to start. NotifyStartBeforeStop
%25s:%-5d stopRecordForStream: record state == kRecordStarting but object being destroyed -- just stop queue
%25s:%-5d stopRecordForStream: record state == kRecordStarting -- we will need to send a start notify prior to stop
%25s:%-5d stopRecordForStream: record was just starting -- calling doneRecording ourselves -- watch this case
%25s:%-5d stopRecordForStream: Error stopping record engine: %d
%25s:%-5d getCurrentStreamState: Cannot find recording engine for streamID(%lu).
%25s:%-5d getRecordBufferDurationForStream_v2: Nil recording engine
%25s:%-5d configureAlertBehaviorForStream completion streamID(%lu)
%25s:%-5d startRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%25s:%-5d ERROR: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d checkSession_v2: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d KeepAliveQueue will NOT be started since output is NOT hands free
%25s:%-5d activateAudioSessionForStream ERROR: Cannot find recording engine for streamID(%lu). Bailing.
%25s:%-5d Announce option set for %s activation mode
%25s:%-5d About to activate audio session for stream(%lu). Current context: %@
%25s:%-5d activateAudioSessionForStream for stream(%lu). isPrewarm(%d). CurrentState(%s).
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionActivationContext: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionBufferSize: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed checkSession at setAudioSessionActive OSStatus(%d).
%25s:%-5d setContextForStream: Error! Incoming engine with streamID(%llu) is different from engine that was used to activate the session, streamID(%llu)
%25s:%-5d setContextForStream: Announce option set for %s activation mode
%25s:%-5d setContextForStream ERROR: Failed at setSessionActivationContext: %d
%25s:%-5d setContextForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%25s:%-5d setContextForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%25s:%-5d setContextForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%25s:%-5d setContextForStream: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%25s:%-5d setContextForStream : Session re-activation failed with error : %d
%25s:%-5d setContextForStream: session re-activated -- calling getSessionProperties
%25s:%-5d playAlertWithCompletion: called when session inactive--do nothing and return error
%25s:%-5d Current Playback Route %@
%25s:%-5d playAlertWithOverride: calling AudioServicesPlaySystemSoundWithOptions with sound ID %d
%25s:%-5d playAlertWithOverride: Finished playing the alert beep
%25s:%-5d playAlertWithCompletion: Illegal alertType
%25s:%-5d getRecordDeviceInfoForStream: Nil recording engine for streamID(%llu)
%25s:%-5d StreamID(%llu). RecordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%25s:%-5d getRecordSettingsForStream_v2: Nil recording engine
%25s:%-5d isMeteringEnabledForStream_v2: Nil recording engine
%25s:%-5d updateMeterLevelForStream_v2: Nil recording engine
%25s:%-5d updateMeterLevelForStream_v2: Error updating meter levels: %d
%25s:%-5d getRecordSettingsForStream: Nil recording engine
%25s:%-5d getAveragePowerForStreamAndChannel_v2: Nil recording engine
%25s:%-5d enableSmartRoutingConsideration: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d setAnnounceCallsEnabledForStream: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d setDuckOthersForStream_v2: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d isDuckingSupportedOnPickedRouteForStream: Nil recording engine
%25s:%-5d enableTriangleModeForStream_v2: Nil recording engine
%25s:%-5d unlocker about to unlock %s
 ASSERTION FAILED: Unlocker attempted to unlock a mutex not owned by the current thread!
%25s:%-5d unlocker about to relock %s
%25s:%-5d setStartAlertMode: %s
%25s:%-5d alert queue state => %s
%25s:%-5d setStopAlertMode: %s
%25s:%-5d setStopWithErrorAlertMode: %s
%25s:%-5d ---> self = %p
%25s:%-5d AVVCPluginRecordingEngine::getRecordRoute : no matching device found, error : %d
%25s:%-5d active device doesn't support remoteInputDeviceName property
%25s:%-5d Nil port type!
%25s:%-5d No input routes. AQ engine couldnt find routes since VSPD is not present!
%25s:%-5d Nil output port!
%25s:%-5d No output routes returned!
%25s:%-5d Unable to start playing the note %d
%25s:%-5d Unable to stop playing the note %d
%25s:%-5d Unable to send midi event status(%d), channel(%d), param1(%d), param2(%d)
%25s:%-5d Unable to send midi event list %p, offset = %d, cable = %d
%25s:%-5d format has zero bytes per frame
%25s:%-5d buffer byte capacity cannot be represented by an uint32_t
%25s:%-5d the number of buffers is 0
%25s:%-5d the number of buffers (%u) does not match the format's number of channel streams (%u)
%25s:%-5d mBuffers[0].mDataByteSize (%u) should be non-zero
%25s:%-5d mBuffers[%u].mDataByteSize (%u) does not match the previous mBuffers[%u].mDataByteSize (%u)
%25s:%-5d mBuffers[%d].mNumberChannels (%u) does not match the format's number of interleaved channels (%u)
%25s:%-5d mBuffers[%u].mData is null
%25s:%-5d AudioQueueRecordInputCallback called 
%25s:%-5d AudioQueueRecordPropertyListenerProc called 
%25s:%-5d AudioQueueRecordPropertyListenerProc: Engine[%@] Queue(%p) Property(%d)
%25s:%-5d ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %d
%25s:%-5d ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %{audio:4CC}d
%25s:%-5d Error getting input hardware sample rate
%25s:%-5d clientRequestedSR was:%.2f, setting to 16000.00
%25s:%-5d clientRequestedSR was:%.2f
%25s:%-5d clientRequestedSR was not specified, setting to 16000.00
%25s:%-5d ERROR: setupRecordQueue: asbdFromSettings err %d
%25s:%-5d ERROR: setupRecordQueue: asbdFromSettings err %{audio:4CC}d
%25s:%-5d Record engine state does not match queue (previously assertion failure)
%25s:%-5d Record Queue Format: %s
%25s:%-5d Creating queue with flags 0x%x. %s runloops
%25s:%-5d ERROR: createRecordQueue: AudioQueueNewInput err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueNewInput err %{audio:4CC}d
%25s:%-5d FAILED createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %{audio:4CC}d
%25s:%-5d ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %{audio:4CC}d
%25s:%-5d AQGetProperty - kAudioQueueDeviceProperty_NumberChannels returned : %u
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %{audio:4CC}d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %{audio:4CC}d
%25s:%-5d createRecordQueue: createAudioConverter error: %d. Destroying record queue.
%25s:%-5d AudioConverter is not created.. reason: requested channels is 1 or requested interleaved audio or non-lpcm is requested
%25s:%-5d FrameCapacity: %d. Buffer duration: %f s
%25s:%-5d createRecordQueue: creating %u queue buffers %u bytes each
%25s:%-5d ERROR: createRecordQueue: AudioQueueAllocateBuffer err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%25s:%-5d Creating AVAudioPCMBuffer with frameCapacity: %d. Buffer duration: %f s
%25s:%-5d Unexpected Format found.. 
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %{audio:4CC}d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %{audio:4CC}d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %{audio:4CC}d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %{audio:4CC}d
%25s:%-5d createAudioConverter: INITIAL AUDIOCONVERTER OUTPUT FORMAT:
%25s:%-5d %s
%25s:%-5d inASBD : %s
%25s:%-5d ERROR: createAudioConverter: AudioConverterNew err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterNew err %{audio:4CC}d
%25s:%-5d createAudioConverter: initial frames per buffer = dur %.2f * sr %.2f = %u
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %{audio:4CC}d
%25s:%-5d createAudioConverter: corrupted values??? framesPerBuffer = %u, mRecordBufferDuration = %f
 ASSERTION FAILURE: mFramesPerPacket cannot be zero!
%25s:%-5d createAudioConverter: setting audio converter format to %u frames per packet
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %{audio:4CC}d
%25s:%-5d createAudioConverter: %u atomic blocks per second
%25s:%-5d kAudioConverterCurrentOutputStreamDescription ASBD's are different !! 
%25s:%-5d createAudioConverter: encoded audio needs minimum of %u bytes per output buffer
%25s:%-5d createAudioConverter: AudioConverterGetProperty(kAudioConverterPropertyMinimumOutputBufferSize) returned status %d
%25s:%-5d createAudioConverter: final framesPerBuffer: %u
%25s:%-5d createAudioConverter: mConvertPacketCount: %u
%25s:%-5d ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %{audio:4CC}d
%25s:%-5d createAudioConverter: outputSizePerPacket: %u
%25s:%-5d createAudioConverter: mConvertAudioCapacity %u bytes
%25s:%-5d FINAL RECORD FORMAT:
%25s:%-5d AVVC - Cannot use DSP Graph. 
%25s:%-5d AVVC - Graph is already setup. Starting and stopping the engine/dsp
%25s:%-5d AVVC - failed to restart AVAudioEngine: %@
%25s:%-5d AVVC - Setting up DSPGraph
%25s:%-5d Exception thrown while attempting to initialize AUDSPGraph: %s
%25s:%-5d Failed to instantiate AUDSPGraph
%25s:%-5d Failed to setup DSPGraph text file: %d
%25s:%-5d dspGraphFilepath: %@
%25s:%-5d Failed to read contents of DSPGraph AUStrip file: %@
%25s:%-5d Failed to setup DSPGraph AUStrip file: %d
%25s:%-5d AVVC: AVAudioEngine EnableManualRenderingMode Offline
%25s:%-5d AVVC: Failed to EnableManualRenderingMode on AVAudioEngine: %@
%25s:%-5d AVVC: AVAudioEngine SetManualRenderingInputPCMFormat
%25s:%-5d AVVC: AVAudioEngine input rendering block call with numFrames: %d
%25s:%-5d AVVC: failed to set AVAudioEngine input rendering block
%25s:%-5d AVVC: Making AVAudioEngine node connections
%25s:%-5d mRecordASBD = %s
%25s:%-5d numFrames = %d
%25s:%-5d AVAE input format = %s
%25s:%-5d AVAE output format = %s
%25s:%-5d DSPGraph input format = %s
%25s:%-5d DSPGraph output format = %s
%25s:%-5d AVVC: Starting AVAudioEngine with desc = %s
%25s:%-5d AVVC: Failed to start AVAudioEngine: %@
%25s:%-5d Done setting up DSPGraph
%25s:%-5d Device is built in device (%@)- update channel count
%25s:%-5d AudioQueue startRecording: record state already started or stopping -- no-op
 ASSERTION FAILED: some buffers already enqueued!
%25s:%-5d startRecordQueue: enqueing %d buffers
%25s:%-5d ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %d
%25s:%-5d ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%25s:%-5d #### Starting record queue immediately ####
%25s:%-5d #### Starting record queue at time %llu ####
%25s:%-5d AVVC starting record queue%s at (%s) hosttime (%lld) 
%25s:%-5d ERROR: startRecordQueue: AudioQueueStart err %d
%25s:%-5d ERROR: startRecordQueue: AudioQueueStart err %{audio:4CC}d
%25s:%-5d stopRecordQueue: mRecordIsStopping set to true
%25s:%-5d stopRecordQueue: AudioQueueStop%s err(%s)
%25s:%-5d Calling destroyRecordEngine
%25s:%-5d destroyRecordEngine: mRecordIsStopping set to true
%25s:%-5d destroyRecordEngine: about to call AudioQueueStop(..., true)
%25s:%-5d AVVC stopped record queue%s (%d)
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueStop err %d
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueStop err %{audio:4CC}d
%25s:%-5d destroyRecordEngine:  calling doneRecording by hand
%25s:%-5d destroyRecordEngine:  skipping doneRecording call because we are deallocating
 ASSERTION FAILED: queue was running when destroyed but not asked to stop
%25s:%-5d destroyRecordEngine: about to call AudioQueueDispose(..., true)
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueDispose err %d
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueDispose err %{audio:4CC}d
%25s:%-5d destroyRecordEngine: mRecordIsStopping set to false
%25s:%-5d destroyRecordEngine: about to destroy audio converter
%25s:%-5d ERROR: destroyRecordEngine: AudioConverterDispose err %d
%25s:%-5d ERROR: destroyRecordEngine: AudioConverterDispose err %{audio:4CC}d
%25s:%-5d Deleting old DSPGraph...
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %d
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %{audio:4CC}d
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %d
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %{audio:4CC}d
%25s:%-5d AVVCAudioQueueRecordingEngine: Record queue does not exist to enable metering. Caching, and will enable during prepare
%25s:%-5d AVVCAudioQueueRecordingEngine: Enable Metering?: %d
%25s:%-5d AVVCAudioQueueRecordingEngine::updateMeterLevels: not fetching meter levels because one of them is untrue! mMeteringEnabled(%d), mRecordQueue(%d), mRecordMeters(%d)
%25s:%-5d AVVCAudioQueueRecordingEngine::updateMeterLevels: Error! In fetching meter levels. Sending 'no signal'. Error(%d)
%25s:%-5d nChannel:%d, startChannel:%d, mClientAudioBufferList->mBuffers[nChannel+startChannel].mData : %p
%25s:%-5d AudioConverterConvertComplexBuffer failed with error : %d
%25s:%-5d handleRecordAQPropertyChange: queue already destroyed -- noop
%25s:%-5d handleRecordQueuePropertyListener (%p): Stream State: %s. AQ Running: %d
%25s:%-5d Record Listener: RUNNING
%25s:%-5d Record Listener: RUNNING-PAUSED
%25s:%-5d Record Listener: STOPPED
%25s:%-5d Record Listener: Converter error: %s
%25s:%-5d (%p) - First callback from AQ -  inStartTime: ht %lld st %lld, Now: ht %lld, SiriRequestedStartTime: ht %lld. Now-SiriRequestedStartTime: %0.6f ms. AQ difference: %0.6f ms
%25s:%-5d handleRecordAQInput: sample time: %f, host time %llu, %llu frames (%d bytes), %d buffers enqueued
%25s:%-5d handleRecordAQInput: record internally stopped, so throwing away buffer
%25s:%-5d handleRecordAQInput: throwing away zero-length buffer
%25s:%-5d handleRecordAQInput: AVAudioEngine renderOffline returned SUCCESS
%25s:%-5d handleRecordAQInput: Error in AVAudioEngine renderOffline : %@
%25s:%-5d handleRecordAQInput: encoder input: packetsAvailable: %u
%25s:%-5d handleRecordAQInput: encoder input buffer %p: %u bytes, %u packets
%25s:%-5d handleRecordAQInput: handing to converter: encoder output buffer: %u bytes, ioOutputDataPackets = %u
%25s:%-5d handleRecordAQInput: err %s, got from converter %u encoded packets, %u bytes.  totalOutputByteSize = %u
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %d
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %{audio:4CC}d
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %d
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %{audio:4CC}d
%25s:%-5d handleRecordAQInput: sending %u bytes of encoded data (addr %p) to client with %u packet descs @time %llu
%25s:%-5d Re-enqueuing buffer %p (data ptr %p), size %u
 ASSERTION FAILED: AQ enqueue error while actively recording
%25s:%-5d ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %d
%25s:%-5d ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %{audio:4CC}d
%25s:%-5d Exiting handleRecordAQInput (%d buffers enqueued)
%25s:%-5d setSessionIsRecordingFlag: Failed at enableSiriListeningMode(%u) with error: %d
%25s:%-5d doneRecording: resetting record queue
%25s:%-5d UpdateRecordDeviceOnQueue : AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice) - %@
%25s:%-5d UpdateRecordDeviceOnQueue: AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice - %d)
%25s:%-5d AVVCAudioQueueRecordingEngine::getRecordRoute : Cached record route is nil!
%25s:%-5d RecordEncoderInputDataProc: ENTRY: *ioNumberDataPackets passed in: %u, packets remaining: %u, bytes already consumed: %u
%25s:%-5d RecordEncoderInputDataProc: End of stream -- handing back zero size buffer
%25s:%-5d RecordEncoderInputDataProc: Handing back ioData buffer %p of size %u
 ASSERTION FAILED: packetsRead <= packetsAvailable!
%25s:%-5d RecordEncoderInputDataProc: EXIT: *ioNumberDataPackets passed back out: %u, status: %s
Could not load AXSpeechImplementation: %@
%25s:%-5d setDuckOthersOption: %d. session state => %s
%25s:%-5d Error (prev Assertion Failure): Calling setDuckOthersOption on an unconfigured session
%25s:%-5d setDuckOthersOption: done : error : %d
%25s:%-5d Resetting miniducking
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: iMessage -- setting P&R category, clearing preferred input, etc.
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %{audio:4CC}d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %{audio:4CC}d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode carplaySupportsMixableSiri: %d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: category, mode and options are the same..
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: (%ld) mode. Options to set: %ld
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %{audio:4CC}d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %{audio:4CC}d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: forcing %.2f audio for car audio
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %{audio:4CC}d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: SR changes from %f to %f
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: SR remains at %f
%25s:%-5d audioSessionForStreamID(%d) couldn't find engine, returning nil
%25s:%-5d ASSERTION FAILED: calling setSessionProperties on a configured session. Crashing process!.
%25s:%-5d setSessionProperties: done
%25s:%-5d mIsUsingV2API(%d)
%25s:%-5d QueueRunLoop started
%25s:%-5d Failed to start queue's run loop thread
%25s:%-5d Setting duck-others AudioSession option for CarPlay
%25s:%-5d ControllerImpl::Entering Dealloc
%25s:%-5d QueueRunLoop stopped
%25s:%-5d ControllerImpl::Exiting Dealloc
%25s:%-5d setNoResumeOnDeactivate(TRUE): will not notify others on deactivation
%25s:%-5d setNoResumeOnDeactivate(FALSE): will notify others on deactivation
%25s:%-5d setActivationMode: voice activation
%25s:%-5d setActivationMode: post-voice activation
%25s:%-5d setActivationMode: iMessage nudge
%25s:%-5d setActivationMode: iMessage gesture to head
%25s:%-5d setActivationMode: ATVRemoteSiri
%25s:%-5d setActivationMode: standard value (%s)
%25s:%-5d setActivationMode: Cannot revert from mode %s to mode %s while audio session is active
%25s:%-5d setActivationModeAndSessionHWControlFlagsAndOptions: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%25s:%-5d setActivationMode: will not take control of hardware for appletv upon activation
%25s:%-5d setActivationMode: will not take control of hardware upon activation for AirPlay output
%25s:%-5d setActivationMode: setting volume required hardware control flag for 'voic' activation mode (ouput is not Airplay)
%25s:%-5d ERROR: setActivationMode : Failed at setAudioHardwareControlFlags: %s
%25s:%-5d setActivationMode: (hdvc / btdt / cpvc / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%25s:%-5d setActivationMode: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%25s:%-5d setActivationMode: enabling all 4 hw control flags
%25s:%-5d ERROR: Failed at setAudioHardwareControlFlags: %s
%25s:%-5d setActivationMode: Mode already set to %s. No change in AudioSession flags or options
%25s:%-5d deactivateSessionForListening_v1v2() returned error(%@)
%25s:%-5d StreamID(%lu) is not associated with primary session, noop
%25s:%-5d deactivateSessionForListening: Error! Attemtping to deactivate a session that is not configured.
%25s:%-5d #### AVVoiceController: Deactivating session with notify ####
%25s:%-5d deactivateSessionForListening: in process of being destroyed -- kill the alert queue
%25s:%-5d deactivateSessionForListening: resetting alert queue
%25s:%-5d ERROR: setSessionActive(false): ignoring AudioQueueReset err %d
%25s:%-5d ERROR: setSessionActive(false): ignoring AudioQueueReset err %{audio:4CC}d
%25s:%-5d deactivateSessionForListening: alert state %s -- deactivating session in alertFinished
%25s:%-5d getDeviceUIDForHomeOrBluetoothButtonActivation : siriInputSource(%@), siriRemoteID(%@)
%25s:%-5d handlePluginDidPublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%25s:%-5d handlePluginDidUnpublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%25s:%-5d Context is nil. can't decide what recording engine need to be created
%25s:%-5d switching to %{audio:4CC}d mode - keeping the same recording engine [%@]
%25s:%-5d ** !!! Invalid engine type creation !!! 
%25s:%-5d current recording engine - %@. type: %s
%25s:%-5d getRecordAndPlaybackRoutes_v1v2: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d setActivationContext setting audio session activation context to: %@
%25s:%-5d setActivationContext: HACK: ignore switch away from RemoteSiri
%25s:%-5d setActivationContext: 'live' switch out of VoiceActivated -- reset session properties
%25s:%-5d setActivationContext: switching in/out of CarAudio -- reset session properties
%25s:%-5d setActivationContext: switching out of iMessage -- reset session properties
%25s:%-5d ERROR: setActivationContext: AVAudioSession setActivationContext err %s, session id:0x%x
%25s:%-5d setActivationContext: done setting audio session activation context
%25s:%-5d setActivationContext: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%25s:%-5d ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %d
%25s:%-5d ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %{audio:4CC}d
%25s:%-5d setActivationContext: session re-activated -- calling getSessionProperties
%25s:%-5d setActivationContext: session is active and mode changed -- calling getSessionProperties
%25s:%-5d setActivationContext: session is inactive -- route change notification or setSessionActive should generate a call to getSessionProperties
%25s:%-5d %s: audio session is inactive or had been interrupted
%25s:%-5d %s: rebuilding alert queue
%25s:%-5d %s: calling prepare instead of create record queue
%25s:%-5d %s - setSessionActive(false): session state already %s -- forcing deactivation
%25s:%-5d deactivate session (%p) (session mananger (%p))
%25s:%-5d ERROR: %s setActive:FALSE withOptions: err %s
%25s:%-5d #### AVVoiceController: %s - error ####
%25s:%-5d #### AVVoiceController: %s - error AVAudioSessionErrorCodeMediaServicesFailed ####
%25s:%-5d ERROR: setSessionActive: setActive: FALSE - err = %s, session id:0x%x
%25s:%-5d setSessionActive: We have to wait for the session to be (re-)initialized
%25s:%-5d setSessionActive: (re-)init done!
%25s:%-5d setSessionActive: waiting...
%25s:%-5d ERROR: setSessionActive: Timed out waiting for mediaserverd err %d
%25s:%-5d #### AVVoiceController: Activating session ####
%25s:%-5d setSessionActive: setActive: TRUE for prewarming did not succeed
%25s:%-5d setSessionActive: setActive: TRUE for prewarming did not succeed and returned err: %d
%25s:%-5d ERROR: setSessionActive: setActive: TRUE for prewarming err %d
%25s:%-5d ERROR: setSessionActive: setActive: TRUE for prewarming err %{audio:4CC}d
%25s:%-5d setSessionActive: Activating : session options : %d
%25s:%-5d ERROR: setSessionActive: setActive: TRUE - err = %s, session id:0x%x
%25s:%-5d setSessionActive(true): Route change when we went active: %s -- getting properties
%25s:%-5d setSessionActive(false): destroying record queue
%25s:%-5d ERROR: setSessionActive(false): ignoring destroyRecordQueue err %d
%25s:%-5d ERROR: setSessionActive(false): ignoring destroyRecordQueue err %{audio:4CC}d
%25s:%-5d setSessionActive(false): in process of being destroyed -- kill the alert queue
%25s:%-5d setSessionActive(false): resetting alert queue
%25s:%-5d setSessionActive(false): alert state %s -- deactivating session asynchronously (NOT HERE) check alertFinished
%25s:%-5d #### setEndpointerDelegate: using %s endpointer ####
%25s:%-5d setupEndpointer: configuring SR and wait times
%25s:%-5d calculateRecordStartTime: Error, current recording engine is nil!
%25s:%-5d WARNING: startRecordingAtTime:error was used without 'silent' start alert
%25s:%-5d calculateRecordStartTime: queue plus HW delay time: %f seconds
%25s:%-5d calculateRecordStartTime: host time for start of record: %.3f seconds
%25s:%-5d this is %lld ticks beyond alert end (%.6f seconds in the future)
%25s:%-5d configureAlertModeFromModeAndEngine: Nil recording engine. Abandon ship!
%25s:%-5d configureAlertModeFromModeAndEngine: Wired headset output - disable ZLL
%25s:%-5d configureAlertModeFromModeAndEngine: record start time was set -- check for ZLL
%25s:%-5d configureAlertModeFromModeAndEngine: ZLL query - back frames: %u
%25s:%-5d configureAlertModeFromModeAndEngine: CarPlay supports ZLL. recordStartTime : %llu
%25s:%-5d ZLL query result %d, backFramesAvailable: %u. Clearing start record time
%25s:%-5d configureAlertModeFromModeAndEngine: record start time not set
%25s:%-5d configureAlertModeFromModeAndEngine: HomeButtonPress/UIButtonPress
%25s:%-5d configureAlertModeFromModeAndEngine: %s
%25s:%-5d configureAlertModeFromModeAndEngine: no vibrator support and no ZLL
%25s:%-5d configureAlertModeFromModeAndEngine: Built-In/BT/CarPlay Voice Activation
%25s:%-5d configureAlertModeFromModeAndEngine: VoiceTriggerTraining
%25s:%-5d configureAlertModeFromModeAndEngine: iMessage
%25s:%-5d configureAlertModeFromModeAndEngine: default
%25s:%-5d configureAlertModeFromModeAndEngine: [final alert modes, overrides] : Start[%s, %s], Stop[%s, %s], StopWError[%s, %s])
%25s:%-5d stopRecordWithRecordLock returned error : %d
%25s:%-5d attempt to stop recording but no current eng for streamID(%lu)
%25s:%-5d waitForAllStopRecordCompletion_v1v2: wait for all didStops to be delivered to the client
%25s:%-5d Engine Map does not exist
%25s:%-5d playAlert: alertType = %d, primeFirst=true
%25s:%-5d playAlert: using SSS to play haptic (or silence)
%25s:%-5d playAlert: alert %d already in progress -- stop it now
%25s:%-5d playAlert: silent start - fake a SS completion callback
%25s:%-5d playAlert: non-blocking SSS alert for Siri startup
%25s:%-5d playAlert: silent stop - fake a SS completion callback
%25s:%-5d playAlert: calling AudioServicesPlaySystemSoundWithOptions with sound ID %u and flags %x
%25s:%-5d playAlert: using alert queue to play beep
%25s:%-5d playAlert: alert playback failed -- attempting to re-prime
%25s:%-5d playAlert: Some Error occured! Not calling startAlertQueue() : %d
%25s:%-5d ERROR: createAlertQueue: AudioQueueNewOutput err %d
%25s:%-5d ERROR: createAlertQueue: AudioQueueNewOutput err %{audio:4CC}d
%25s:%-5d FAILED createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d ERROR: createAlertQueue: AudioQueueAddPropertyListener err %d
%25s:%-5d ERROR: createAlertQueue: AudioQueueAddPropertyListener err %{audio:4CC}d
 ASSERTION FAILED: re-entrant request for different alert type
%25s:%-5d primeAlertQueue: alert queue state '%s'.  reentrant or multi-threaded call -- returning
%25s:%-5d primeAlertQueue: queue is NULL -- returning
%25s:%-5d primeAlertQueue: type %d (current is %d)
%25s:%-5d primeAlertQueue: sync-stopping active alert queue
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueStop err %d
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueStop err %{audio:4CC}d
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueReset err %d
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueReset err %{audio:4CC}d
%25s:%-5d primeAlertQueue: silent/haptic alert: not queueing a buffer
%25s:%-5d ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %d
%25s:%-5d ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%25s:%-5d primeAlertQueue: done. current is now %d
%25s:%-5d primeAlertQueue: no-op
%25s:%-5d setupAlert: NULL alert URL
%25s:%-5d ERROR: setupAlert: ExtAudioFileOpenURL err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileOpenURL err %{audio:4CC}d
%25s:%-5d setupAlert: Failed to load alert '%s'
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %{audio:4CC}d
%25s:%-5d ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %{audio:4CC}d
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty err %{audio:4CC}d
%25s:%-5d setupAlert: resetting alert queue
%25s:%-5d ERROR: setupAlert: AudioQueueAllocateBuffer err %d
%25s:%-5d ERROR: setupAlert: AudioQueueAllocateBuffer err %{audio:4CC}d
%25s:%-5d ERROR: setupAlert: ExtAudioFileRead err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileRead err %{audio:4CC}d
%25s:%-5d getRecordErrorStatus: Current recording engine is nil!
 ASSERTION FAILED: no alert buffer is enqueued!
%25s:%-5d startAlertQueue: calling AudioQueueStart
%25s:%-5d AVVC started alert queue%s (%d)
%25s:%-5d ERROR: startAlertQueue: AudioQueueStart err %d
%25s:%-5d ERROR: startAlertQueue: AudioQueueStart err %{audio:4CC}d
%25s:%-5d ERROR: startAlertQueue: AudioQueueStop(async) err %d
%25s:%-5d ERROR: startAlertQueue: AudioQueueStop(async) err %{audio:4CC}d
 ASSERTION FAILED: alert queue NULL but state != Uninitialized
%25s:%-5d detected unfinished alert, queue up alertFinished
%25s:%-5d destroyAlertQueue: calling AudioQueueStop
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueStop() err %d
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueStop() err %{audio:4CC}d
%25s:%-5d destroyAlertQueue: removing queue listener
%25s:%-5d destroyAlertQueue: calling AudioQueueDispose
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueDispose err %d
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueDispose err %{audio:4CC}d
%25s:%-5d calculateAlertTimes: alert queue already stopped -- using current time as end time
%25s:%-5d ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %d
%25s:%-5d ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %{audio:4CC}d
%25s:%-5d alertStarted: record state != kRecordStarting -- noop
%25s:%-5d alertStarted: not playing start alert -- noop
%25s:%-5d alertFinished
%25s:%-5d alertFinished: state = %s mRecordState: %s -- not priming alert
%25s:%-5d alertFinished: deactivating session -- finishing the job
%25s:%-5d ERROR: alertFinished: setActive:FALSE withOptions: err %d
%25s:%-5d ERROR: alertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%25s:%-5d Alert Listener: impl or queue is NULL or object is being destroyed -- noop
%25s:%-5d Alert Listener: in the middle of priming alert queue:  Doing nothing.  [THIS IS NEW BEHAVIOR]
%25s:%-5d Alert Listener: mAlertQueueState = %s
%25s:%-5d Alert Listener: RUNNING = %d
%25s:%-5d Alert Listener: session was interrupted!  Doing nothing here
%25s:%-5d Alert Listener: state already kAlertQueueRunning.  Doing nothing here
%25s:%-5d Alert Listener: Session is inactive, alertFinishedPlayback already synthesized in deactivateSession.
%25s:%-5d Alert Listener: queue reports stopped on first IsRunning prop notification -- treat this like a regular start
%25s:%-5d Alert Listener: unhandled inID %s
%25s:%-5d vibeStartAlertFinished: Could not find engine for streamID(%lu)
%25s:%-5d vibeStartAlertFinished: record state != kRecordStarting -- noop
%25s:%-5d vibeStopAlertFinished: deactivating session -- finishing the job
%25s:%-5d ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %d
%25s:%-5d ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%25s:%-5d VibeAlertCompletionProc: SSID %u done
%25s:%-5d VibeAlertCompletionProc -> called after object destroyed -- ignoring call
%25s:%-5d VibeAlertCompletionProc: object being destroyed -- bailing out
%25s:%-5d VibeAlertCompletionProc: notified for other ssID %d -- no-op
%25s:%-5d checkForEndpoint entered: inBuffer %p
%25s:%-5d calling startpointDetected synchronously
%25s:%-5d calling interspeechPointDetected synchronously 
%25s:%-5d #### AVVoiceController: Detected end point but NO START POINT ####
%25s:%-5d checkForEndpoint: auto-stopping record
%25s:%-5d calling endpointDetected synchronously
%25s:%-5d checkForEndpoint exiting
%25s:%-5d Record Listener: handling deferred context change
%25s:%-5d AVVoiceController -> Interruption beginning for %s session (%p) info: %@
%25s:%-5d   We think our session was not active.  Make sure it isn't. deactivating session with options : %d
%25s:%-5d deactivating session returned  : %d - error - %@
%25s:%-5d   Record was active
%25s:%-5d   Nothing active
%25s:%-5d AVVoiceController -> Interruption ending for %s session (%p) info: %@
%25s:%-5d   Interrupt for aux session unexpected
%25s:%-5d   No longer reactivating audio session on interrupt end
%25s:%-5d   Was interrupted during recording -- stopping queue on resume
 Record should never be active when interrupt is ending!
%25s:%-5d   We were never interrupted to begin with!
%25s:%-5d AVVoiceController -> Route Change for %s session (%p)
%25s:%-5d   Route change for aux session unexpected
%25s:%-5d Route change reason : [%d] = %s
%25s:%-5d Route really changed -- Re-checking properties
%25s:%-5d Route really changed but session not-yet-active/interrupted -- set flag to check properties when we are active
%25s:%-5d New route Category is not ours!
%25s:%-5d We were waiting for a route change -- Re-checking properties
%25s:%-5d Route change reason: category change - ignoring
%25s:%-5d Nil Engine! Could not get session properties
%25s:%-5d Category change came in while we were %s -- ignoring
%25s:%-5d Route change reason: route configuration change - ignoring
%25s:%-5d Route change reason was NULL
%25s:%-5d AVVoiceController -> Server died!
%25s:%-5d ControllerImpl::handleServerDeath: object being destroyed -- bailing out
%25s:%-5d ControllerImpl::handleServerDeath: session is not configured
%25s:%-5d ControllerImpl::handleServerDeath: Destroying internal state for later rebuild
%25s:%-5d AVVoiceController -> Server reset after death
%25s:%-5d ControllerImpl::handleServerReset: object being destroyed -- bailing out
%25s:%-5d ControllerImpl::handleServerReset: restoring activation context and resetting session properties
%25s:%-5d Fail! Unable to load RegisterAudioUnits_Internal from libAudioDSP.dylib.
%25s:%-5d Calling RegisterAudioUnits_Internal from libAudioDSP.dylib
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: %@ requested. ignoring the device id and use built in device - %@. 
%25s:%-5d setContext: ERROR! No recording engine associated with device for post/auto activation context
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Darwin activation (%@) requested with nil deviceUUID
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with nil deviceUUID
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with deviceUUID - %@. 
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Ambigous activation (%@) requested with deviceUUID - %@. EngineType : %d
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: returned error - %d for activation mode(%@)
%25s:%-5d setContext: Engine lookup returned nil!
%25s:%-5d Found matching engine[%@] of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d _createRecordingEngineWithParameters : Fatal Error! Invalid engine type!
%25s:%-5d setContext: Reusing (%s) engine[%@] for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d setContext: Created new (%s) engine[%@] for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d nil object encountered (avvc: %p, impl: %p). Bailing
%25s:%-5d calling (v2) voiceControllerLPCMAudioCallback:forStream:buffer:
%25s:%-5d calling (v2) voiceControllerAudioCallback:forStream:buffer:
%25s:%-5d calling lpcmRecordBufferReceived:buffer
%25s:%-5d calling voiceControllerRecordBufferAvailable:buffer
%25s:%-5d Configured completion blocks for engine[%@]
%s Likely ambiguous AVVC V2 use case detected. Must pass streamID here: %s ! (or V1 engine map integrity problem). numMapEngs(%lu) v1PluginEngInvalid(%d) v1AudioQueueEngInvalid(%d) v1ValidCase(%d) v2AmbiguousCase(%d)
%25s:%-5d ASSERTION FAILURE [!streamIDViolation is false]: Likely ambiguous AVVC V2 use case detected. Must pass streamID here %s ! (or V1 engine map integrity problem)
%25s:%-5d ASSERTION FAILURE [eng != nullptr is false]: V1 engine map integrity problem. Couldn't find engine in map.
%25s:%-5d _invalidateStreamWhenDeviceUnavailable_v1v2()
%25s:%-5d VSPD is not present, removing engine associated with BuiltInStream
%25s:%-5d Engine for streamID(%llu) not found.
%25s:%-5d removeEngineFromMapWithStreamID: engine[%@] stream(%llu) 
%25s:%-5d Stopping recording here, engine's remote device has been disconnected.
%25s:%-5d DelegateDispatchGroup wait timed out after %f seconds
%25s:%-5d dispatch_async(mClientNotificationQueue) %s
%25s:%-5d calling %s synchronously
%25s:%-5d dispatch_sync(mClientNotificationQueue) %s
%25s:%-5d before barrier
%25s:%-5d mWorkQueue barrier
%25s:%-5d mClientNotificationQueue barrier
%25s:%-5d mDispatchQueue barrier
%25s:%-5d after barrier
%25s:%-5d after resume
%25s:%-5d session state(streamID %d) => %s
%25s:%-5d alert state => %s
%25s:%-5d Interrupting recording on engine[%@] with streamID(%llu)
%25s:%-5d Stopping the recording on stream(%lu) due to a category change
%25s:%-5d NOTE: AVVC Details logging is turned on by default for development
%25s:%-5d debug_encoding on
%25s:%-5d debug_endpoint on
%25s:%-5d debug_callbacks on
%25s:%-5d debug_locking on
%25s:%-5d debug_state on
%25s:%-5d debug_trace on
%25s:%-5d debug_timing on
%25s:%-5d debug_delegate on
%25s:%-5d debug_playback on
%25s:%-5d debug_deviceselect on
%25s:%-5d debug_level = %d
%25s:%-5d resetting debug_level to Notify to allow scoped logging
%25s:%-5d debug priority: %u scopes: 0x%llx
%25s:%-5d logAndReturnIfAudioSessionIsNotAvailable-%s returning : %d
%25s:%-5d ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeOptions failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setIAmTheAssistant failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setAllowHapticsAndSystemSoundsDuringRecording failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeRouteSharingPolicyOptions failed with error: %@
%25s:%-5d AVVCSessionManager::setSessionActivationContext : passed 'nil' dictionary, creating empty one.
%25s:%-5d ERROR: AVVCSessionManager::setActivationContext of sessionID(0x%x) failed with error: %@
%25s:%-5d shouldEnableMiniDucking on AppleTV. Not available for now
%25s:%-5d enableMiniDucking: Called on HomePod like device, no-op
%25s:%-5d shouldEnableMiniDucking: No change, no-op
%25s:%-5d shouldEnableMiniDucking: Announce calls enabled. Will not set session properties while disabling miniDucking
%25s:%-5d pickedRoute from AudioSession: %@
%25s:%-5d isSomeOtherAudioPlaying: %d
%25s:%-5d Non-BT route OutputSupportsVolume: %d
%25s:%-5d shouldDuckOthers(%d), sessionNeedsVolumeControl(%d)
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions on 'audioOS'. Duck others.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions on older watchOS. Interrupt others.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: (wireless splitter mode). Interrupt others.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: ATV Activation  -- setting Playback category and Duck/Mix Options.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: iMessage -- setting P&R category, clearing preferred input, etc.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: Carplay Supports Mixable Siri
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: announce mode for %s context - duck others
%25s:%-5d AVVCSessionManager : category, mode and options are the same (Current activation: %d, Previous activation: %d). No-op
%25s:%-5d AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x. (Current activation: %d, Previous activation: %d)
%25s:%-5d ERROR: AVVCSessionManager : setCategoryModeRouteSharingPolicyOptions failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::clearInputPreferences failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (ATV + Plugin) : %@
%25s:%-5d setSessionAudioHWControlFlags: Take Audio HW control on tvOS
%25s:%-5d setSessionAudioHWControlFlags: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (HomePod) : %@
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags on older watch hardware: will never take control of HW on activation
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: wireless splitter mode, no volume control, yes routing control.
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (wireless splitter) : %@
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: disable mini-ducking. Set all HW control flags
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (disable mini-ducking) : %@
%25s:%-5d AVVCSessionManager::setAudioHardwareControlFlags: announce mode for %s context - don't set HW control flags
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: will not take control of hardware upon activation for AirPlay output (voic/rais)
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: setting volume/routing required hardware control flag for 'voic' activation mode (output is not Airplay)
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : set all hw control flags
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: default mode - set all HW control flags
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags : %@
%25s:%-5d setSessionSampleRateFromActivationMode: forcing 22050k audio for car audio
%25s:%-5d ERROR: AVVCSessionManager::setPreferredSampleRate for VehicleButtonPress : %@
%25s:%-5d setSessionSampleRateFromActivationMode: SR changes from %f to %f
%25s:%-5d ERROR: AVVCSessionManager::setPreferredSampleRate to %f : %@
%25s:%-5d setSessionSampleRateFromActivationMode: SR remains at %f
%25s:%-5d ERROR: AVVCSessionManager::setSessionBufferSize failed: %@
%25s:%-5d AVVCSessionManager::setSessionBufferSize: Current size: %d
%25s:%-5d AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x
%25s:%-5d Error in setDuckOthers:mixWithOthers %d, %@
%25s:%-5d AVVCSessionManager: category mode and options are same. No op
%25s:%-5d Error in setDuckingFadeDuration %d, %@
%25s:%-5d ERROR: AVVCSessionManager::enableSmartRoutingConsideration failed: %@
%25s:%-5d Output Port[%d / %d] : %@
%25s:%-5d %@: session options : %d
%25s:%-5d %@ succeeded error: %s, session id:0x%x
%25s:%-5d %@ failed with error: %s, session id:0x%x
%25s:%-5d deactivateAudioSession: session options : %d
%25s:%-5d deactivateAudioSession succeeded error: %s, session id:0x%x
%25s:%-5d deactivateAudioSession failed with error: %s, session id:0x%x
%25s:%-5d session(%p) state %s => %s
%25s:%-5d isSessionInSiriCategoryModeAndOptions: about to set Play&Record category, speech recognition/assistant mode. Current category: %@, mode: %@, options: 0x%x
%25s:%-5d setRecordingFromRemoteInput: %d
%25s:%-5d Error setting recording from remote input %d, %@
%25s:%-5d isSWVolumeSupportedOnPickedRoute: Picked Route is nil
%25s:%-5d isSWVolumeSupportedOnPickedRoute: %d
%25s:%-5d ~AVVCAudioCapturer(): destroyed
%25s:%-5d AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%25s:%-5d ~AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%25s:%-5d ~AVVCAudioCapturer_AudioDiagnostics(): destroyed
%25s:%-5d Dumping Audio for stream(%lu) at %s
%25s:%-5d Error setting up audio captures
%25s:%-5d AVVCAudioCapturer:logCapture: logging lpcm audio
%25s:%-5d AVVCAudioCapturer:logCapture: logging non-lpcm audio
%25s:%-5d Error while logging audio: %d
%25s:%-5d mCapturer is reset to NULL
%25s:%-5d *** InitializePlugins *** %p 
%25s:%-5d Plugin Bundle URL: %@
%25s:%-5d initialized plugin class %@
%25s:%-5d Unable to create the plugin bundle
%25s:%-5d dealloc : releasing all plugins *** %p
%25s:%-5d invalidatePlugins : invalidating all plugins *** %p
%25s:%-5d calling invalidate on plugin instance %p
%25s:%-5d Searching plugin path %@
%25s:%-5d Error enumerating the remote input bundles at %@: %@
%25s:%-5d plugin(%p) - device(%p) - id: %@
%25s:%-5d Device(%p). Identifier: %@
%25s:%-5d Cannot find Remote Input device %@
%25s:%-5d findDeviceWithIdentifier: found the device %@
%25s:%-5d Device(%p). Identifier: %@ (num devices = %d)
%25s:%-5d self(%p) controller(%p) plugin(%p), did publish device(%p) with id(%@)
%25s:%-5d ERROR: Received didPublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%25s:%-5d WARNING: Not forwarding didPublish event to AVVC parent because it does not exist, or is deallocating.
%25s:%-5d self(%p) controller(%p) plugin(%p), did UNpublish device(%p) with id(%@)
%25s:%-5d ERROR: Received didUNpublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%25s:%-5d WARNING: Not forwarding didUNpublish event to AVVC parent because it does not exist, or is deallocating.
%25s:%-5d self(%p) controller(%p)
%25s:%-5d couldn't find mock plugin
%25s:%-5d mock plugin endpoint (%@)
%25s:%-5d Error: Unable to call RegisterAudioUnits_Internal from libAudioDSP.dylib.
%25s:%-5d unable to get property kAUDSPGraphProperty_GraphTextFilePath %i
%25s:%-5d unable to get property kAUDSPGraphProperty_AUStrip %i
%25s:%-5d Player@%p: Engine is in the middle of a config change, cannot play yet!
%25s:%-5d Player@%p: Engine could not start the audio hardware dynamically, cannot play!
%25s:%-5d Player@%p: Engine config changed when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: IOUnit stopped when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: Engine returned render error: %ld, node: %p {%s}, cannot play!
%25s:%-5d AVVoiceTriggerClient init %@
%25s:%-5d AVVoiceTriggerClient dealloc %@
%25s:%-5d server crashed
%25s:%-5d server reset
%25s:%-5d server timeout
%25s:%-5d enableVoiceTriggerListening: %s
 CAGuard::CAGuard: Could not init the cond var
 CAGuard::Wait: A thread has to have locked a guard before it can wait
 CAGuard::Wait: Could not wait for a signal
 CAGuard::WaitFor: A thread has to have locked a guard be for it can wait
 CAGuard::WaitFor: Wait got an error
 CAGuard::Notify: failed
 CAGuard::NotifyAll: failed
%25s:%-5d Engine@%p: could not initialize, error = %d
%25s:%-5d Engine#%p: error: couldn't connect mixer to output node!
%25s:%-5d Engine@%p: connect node1: %p (from bus: %lu) -> node2: %p (to bus: %lu), format: %s
%25s:%-5d Engine@%p: connect node: %p (from bus: %lu) ->%s, format: %s
%25s:%-5d Engine@%p: disconnect input bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect output bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect all inputs on node: %p
%25s:%-5d Engine@%p: disconnect all outputs on node: %p
%25s:%-5d Engine@%p: connect MIDI node: %p -> node: %p, format: %s
%25s:%-5d Engine@%p: connect MIDI node: %p -> %s, format: %s
%25s:%-5d Engine@%p: disconnect MIDI node: %p from node: %p
%25s:%-5d Engine@%p: disconnect MIDI node: %p from nodes: %s
%25s:%-5d Engine@%p: disconnect MIDI inputs on node: %p
%25s:%-5d Engine@%p: disconnect MIDI outputs on node: %p
%25s:%-5d Engine@%p: initialize
%25s:%-5d Engine@%p: uninitialize
%25s:%-5d Engine@%p: start
%25s:%-5d Engine@%p: pause
%25s:%-5d Engine@%p: stop
%25s:%-5d Engine@%p: could not disable manual rendering mode
%25s:%-5d Engine@%p: iounit configuration changed > posting notification
%25s:%-5d Engine@%p: iounit configuration changed < posted notification
%25s:%-5d Engine@%p: iounit configuration changed > setting flag
%25s:%-5d Engine@%p: iounit configuration changed > stopping the engine
%25s:%-5d Engine@%p: iounit stopped unexpectedly > pausing the engine
%25s:%-5d Engine@%p: install tap on node %p, bus%lu, bufferSize %d, format: %s
%25s:%-5d Engine@%p: remove tap from node %p, bus%lu
%25s:%-5d required condition is false: [%s:%d:%s: (%s)]
%25s:%-5d [%s:%d:%s: (%s)] returned %s, error %@
softlink:r:path:/System/Library/Frameworks/AVFoundation.framework/AVFoundation
AVAudioIONode
AVAudioOutputNode
AVAudioInputNode
AVAudioMixing
AVAudioStereoMixing
NSObject
AVAudio3DMixing
AVAudioConnectionPoint
AVVCRecordDeviceInfo
AVVoiceControllerInternal
AVVoiceController_Priv
AVVoiceController
AVAudioRemoteInputPlugin_PrivateTest
AVVCContextSettings
AVVCPrepareRecordSettings
AVVCConfigureAlertBehaviorSettings
AVVCStartRecordSettings
AVVCAlertInformation
AVVCDuckFadeDuration
AVVCDuckOverride
AVVCDuckSettings
AVAudioUnitComponent
SpeexEndpointer
Endpointer
SpeexEndpointer_Priv
AVAudioUnitTimeEffect
AVAudioUnitComponentManager
AVAudioUnitDelay
VoiceVerificationEndpointer
AVAudioUnitVarispeed
AVAudioUnitReverb
AVAudioUnitTimePitch
AudioPlayerImpl
AVAudioPlayerPriv
AVAudioPlayer
AVAudioUnitGenerator
AVVCSessionFactory
AVAudioRecorder
AVAudioSessionParticipant
AVAudioSinkNode
AVAudioChannelLayout
NSSecureCoding
NSCoding
AVSpeechSynthesisProviderVoice
NSCopying
AVSpeechSynthesisProviderRequest
AVSpeechSynthesisProviderAudioUnit
AVAudioDeviceTestServiceProtocol
AVAudioDeviceTest
AVAudioConverter
Encoding
AVVCMetricsManager
AVAudioUnitDistortion
AVAudioMixerNode
AVAudioClock
AVMIDIPlayer
AVMIDIPlayerPriv
AVAudioUnitMIDIInstrument
AVAudioBuffer
NSMutableCopying
AVAudioPCMBuffer
AVAudioCompressedBuffer
AVAudioUnitSplitter
AVAudioUnitEQFilterParameters
AVAudioUnitEQ
AVAudioFormat
AVAudioDeviceTestResult
AVAudioDeviceTestSequence
AVAudioDeviceTestProcessingChain
AVAudioSourceNode
AVSpeechSynthesisVoice
AVSpeechUtterance
AVSpeechSynthesizer
AVSpeechSynthesisMarker
AVVCAudioBuffer
AVVCAudioBufferPriv
AVAudioEnvironmentDistanceAttenuationParameters
AVAudioEnvironmentReverbParameters
AVAudioEnvironmentNode
AVVCSessionManager
AVMusicEvent
AVMIDINoteEvent
AVMIDIChannelEvent
AVMIDIControlChangeEvent
AVMIDIPolyPressureEvent
AVMIDIProgramChangeEvent
AVMIDIChannelPressureEvent
AVMIDIPitchBendEvent
AVMIDISysexEvent
AVMIDIMetaEvent
AVMusicUserEvent
AVExtendedNoteOnEvent
AVParameterEvent
AVAUPresetEvent
AVExtendedTempoEvent
AVAudioFile
AVAudioNode
AVAudioMixingDestination
AVAudioUnitSampler
AVAudioRemoteInputPlugin
AVVCPluginRemoteInputHost
AVAudioRemoteInputPluginDelegate
AVAudioSequencer_Player
AVAudioSequencer
AVMusicTrack
AVMusicTrackEditor
AVMusicTrackEventIterator
AVAudioTime
AVAudioUnitDSPGraph
AVAudioUnitEffect
AVAudioPlayerNode
AVVoiceTriggerClient
AVAudioUnit
AVAudioEngine
initWithImpl:
implementation
isVoiceProcessingEnabled
engine
isInManualRenderingMode
manualRenderingMode
resetImpl:
initWithIOUnit:isInput:
presentationLatency
audioUnit
didAttachToEngine:
didDetachFromEngine:error:
setVoiceProcessingEnabled:error:
enableManualRenderingMode:isInput:
enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:
Td,R,N
T^{OpaqueAudioComponentInstance=},R,N
voiceProcessingEnabled
TB,R,N,GisVoiceProcessingEnabled
manualRenderingFormat
isEqual:
manualRenderingMaximumFrameCount
outputFormatForBus:
setManualRenderingPCMFormat:maximumFrameCount:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
setPan:
Tf,N
renderingAlgorithm
setRenderingAlgorithm:
sourceMode
setSourceMode:
pointSourceInHeadMode
setPointSourceInHeadMode:
rate
setRate:
reverbBlend
setReverbBlend:
obstruction
setObstruction:
occlusion
setOcclusion:
position
setPosition:
Tq,N
T{AVAudio3DPoint=fff},N
destinationForMixer:bus:
volume
setVolume:
setManualRenderingInputPCMFormat:inputBlock:
isVoiceProcessingBypassed
setVoiceProcessingBypassed:
isVoiceProcessingAGCEnabled
setVoiceProcessingAGCEnabled:
isVoiceProcessingInputMuted
setVoiceProcessingInputMuted:
voiceProcessingBypassed
TB,N,GisVoiceProcessingBypassed
voiceProcessingAGCEnabled
TB,N,GisVoiceProcessingAGCEnabled
voiceProcessingInputMuted
TB,N,GisVoiceProcessingInputMuted
Tf,D,N
raise:format:arguments:
sharedAVSystemController
attributeForKey:
boolValue
sharedSystemAudioContext
supportsMultipleBluetoothOutputDevices
outputDevices
countByEnumeratingWithState:objects:count:
supportsBluetoothSharing
currentHandler
stringWithUTF8String:
handleFailureInFunction:file:lineNumber:description:
init
dealloc
node
initWithNode:bus:
connectionPointWithNode:bus:
_node
_bus
_reserved
T@"AVAudioNode",R,W,N,V_node
TQ,R,N,V_bus
objectForKey:
unsignedIntegerValue
doubleValue
speechDetectionDeviceSampleRate
inputNumberOfChannels
count
dictionaryWithDictionary:
stringWithFormat:
lowercaseString
regularExpressionWithPattern:options:error:
length
firstMatchInString:options:range:
range
substringWithRange:
whitespaceAndNewlineCharacterSet
stringByTrimmingCharactersInSet:
stringWithCString:encoding:
inputs
objectAtIndex:
portType
copy
stringByAppendingFormat:
outputs
portName
stringByAppendingString:
intValue
initWithSuiteName:
boolForKey:
findFirstBluetoothDevice
findDeviceWithIdentifier:
sessionState
code
setAudioInputBlock:
setStatusChangeBlock:
startRecordingWithSettings:withCompletionBlock:
numberWithUnsignedLongLong:
numberWithInteger:
dictionaryWithObjectsAndKeys:
startRecordingWithCompletionBlock:
stopRecordingWithCompletionBlock:
supportedFormats
objectAtIndexedSubscript:
streamDescription
initWithStreamDescription:
setFormat:
format
audioInputBlock
frameLength
packetCount
audioTimeStamp
getBytes:range:
packetDescriptions
data
stringWithString:
initWithString:
initWithUUIDString:
initWithRecordingEngine:
recordRoute
isRemoteDevice
remoteProductIdentifier
remoteDeviceUID
remoteDeviceCategory
isUpsamplingSourceAudio
remoteDeviceUIDString
.cxx_destruct
_isRemoteDevice
_isUpsamplingSourceAudio
_remoteDeviceCategory
_recordRoute
_remoteProductIdentifier
_remoteDeviceUID
_remoteDeviceUIDString
T@"NSString",R,N,V_recordRoute
TB,R,V_isRemoteDevice
T@"NSString",R,N,V_remoteProductIdentifier
T@"NSUUID",R,N,V_remoteDeviceUID
TI,R,N,V_remoteDeviceCategory
TB,R,N,V_isUpsamplingSourceAudio
T@"NSString",R,N,V_remoteDeviceUIDString
setSessionNotifications_v1v2:
sharedInstance
setSessionWasCreatedBlock:
removeSessionNotifications:
setSessionWillBeDestroyedBlock:
impl
isPrimary
audioSession
setupSessionNotifications:
voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
userInfo
object
unsignedLongValue
initWithDictionary:
currentRoute
setObject:forKey:
voiceControllerMediaServicesWereLost:
voiceControllerMediaServicesWereReset:
voiceControllerDidStartRecording:forStream:successfully:error:
initWithDomain:code:userInfo:
voiceControllerDidStartRecording:successfully:error:
voiceControllerDidStartRecording:successfully:
voiceControllerDidStopRecording:forStream:forReason:
voiceControllerDidStopRecording:forReason:
voiceControllerDidDetectStartpoint:
voiceControllerDidDetectEndpoint:ofType:atTime:
voiceControllerDidDetectEndpoint:ofType:
voiceControllerEncoderErrorDidOccur:error:
initWithAlertType:mode:endTime:
voiceControllerDidFinishAlertPlayback:withSettings:error:
voiceControllerDidFinishAlertPlayback:ofType:error:
voiceControllerStreamInvalidated:forStream:
voiceControllerBeginRecordInterruption:withContext:
voiceControllerBeginRecordInterruption:
voiceControllerEndRecordInterruption:
voiceControllerWillSetAudioSessionActive:willActivate:
voiceControllerDidSetAudioSessionActive:isActivated:
sessionSetup_v1v2
sessionCleanup_v1v2
hardwareConfigChanged:
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
handlePluginDidPublishDevice:withDevice:
handlePluginDidUnpublishDevice:withDevice:
beganRecording_v1v2:status:
finishedRecording_v1v2:status:
startpointDetected
interspeechPointDetected
endpointDetected
encodeError:
alertPlaybackFinishedOfType_v1v2:
notifyStreamInvalidated_v1v2:
beginRecordInterruptionWithContext_v1v2:
endRecordInterruption_v1v2
beginAudioSessionActivate_v1v2:
endAudioSessionActivate_v1v2:
isAPIAvailable
sendRemoteConnectionMessage:
playbackRoute
lastRecordStartTime
voiceTriggerInfo
isBargeInDetectEnabled
setBargeInDetectEnabled:
isStopOnBargeInEnabled
setStopOnBargeInEnabled:
isSynchronousCallbackEnabled
setSynchronousCallbackEnabled:
pcmRecordBufferFormat
setDuckOthersOption:
duckOthersOption
numberOfChannels
bargeInDetectEnabled
TB,GisBargeInDetectEnabled
stopOnBargeInEnabled
TB,GisStopOnBargeInEnabled
T@"NSDictionary",R
synchronousCallbackEnabled
TB,GisSynchronousCallbackEnabled
T@"AVAudioFormat",R
TB,SsetDuckOthersOption:
unsignedIntValue
errorWithDomain:code:userInfo:
finalize
setRecordDelegate:
_teardownWithError:
absoluteString
playAlertSoundForType:
setupAlertBehavior_v1:
doStartRecordingAtTime_v1:behavior:
unsignedLongLongValue
setEndpointMode:
setStartWaitTime:
setInterspeechWaitTime:
setEndWaitTime:
isRecording
initVoiceControllerForClient:withError:
setParentVoiceController:
activationMode
activationDeviceUID
streamID
recordBufferDuration
avAudioSettings
startHostTime
startAlert
stopAlert
stopOnErrorAlert
skipAlert
mockPluginEndpoint
initWithContext:error:
prewarmAudioSession
teardownWithError:
releaseAudioSession
releaseAudioSession:
enableMiniDucking:
willAcceptContext:
IsDeviceAvailableInLocalRoute:error:
setCurrentContext:error:
prepareRecordWithSettings:error:
setAlertSoundFromURL:forType:
resetEndpointer
playRecordStartingAlertAndResetEndpointer
startRecording
startRecording:
startRecordingAtTime:error:
startRecordingWithSettings:error:
stopRecording
recordDelegate
recordSettings
getRecordBufferDuration
setRecordBufferDuration:
endpointerDelegate
setEndpointerDelegate:
recordEndpointMode
setRecordEndpointMode:
recordStartWaitTime
setRecordStartWaitTime:
recordInterspeechWaitTime
setRecordInterspeechWaitTime:
recordEndWaitTime
setRecordEndWaitTime:
setAlertVolume:
alertVolume
getAlertStartTime
isMeteringEnabled
setMeteringEnabled:
updateMeters
peakPowerForChannel:
averagePowerForChannel:
isStopOnEndpointEnabled
setStopOnEndpointEnabled:
metrics
currentRecordDeviceInfo
initWithError:
setContext:completion:
setContext:error:
setContext:streamType:error:
prepareRecordForStream:completion:
prepareRecordForStream:error:
startRecordWithSettings:completion:alertCompletion:audioCallback:
startRecordForStream:completion:
startRecordForStream:error:
configureAlertBehaviorForStream:completion:
configureAlertBehaviorForStream:error:
stopRecordForStream:completion:
stopRecordForStream:error:
getCurrentStreamState:
getRecordDeviceInfoForStream:
activateAudioSessionForStream:isPrewarm:error:
activateAudioSessionForStream:isPrewarm:recordMode:error:
deactivateAudioSessionWithOptions:
deactivateAudioSessionForStream:withOptions:completion:
deactivateAudioSessionForStream:withOptions:error:
getCurrentSessionState
getCurrentSessionStateForStream:
setContextForStream:forStream:error:
playAlert:withOverride:completion:
playAlertSoundForType:overrideMode:
getRecordBufferDurationForStream:
getRecordSettingsForStream:
isMeteringEnabledForStream:
updateMeterForStream:
getPeakPowerForStream:forChannel:
getAveragePowerForStream:forChannel:
setRecordStatusChangeBlock:
enableSmartRoutingConsiderationForStream:enable:error:
setAnnounceCallsEnabledForStream:enable:
getInputChannelInfoForStream:completion:
setDuckOthersForStream:withSettings:error:
isDuckingSupportedOnPickedRouteForStream:error:
enableTriangleModeForStream:enable:withCompletion:
alertStartTime
_impl
_alertStartTime
recording
TB,R,GisRecording
T@"<Endpointer>",&
T@"<AVVoiceControllerRecordDelegate>",D
meteringEnabled
TB,GisMeteringEnabled
stopOnEndpointEnabled
TB,GisStopOnEndpointEnabled
TQ,R,V_alertStartTime
allocWithZone:
announceCallsEnabled
initWithMode:deviceUID:
copyWithZone:
setActivationMode:
setActivationDeviceUID:
setAnnounceCallsEnabled:
_announceCallsEnabled
_activationMode
_activationDeviceUID
Tq,N,V_activationMode
T@"NSString",&,N,V_activationDeviceUID
TB,N,V_announceCallsEnabled
initWithStreamID:settings:bufferDuration:
setStreamID:
setAvAudioSettings:
_meteringEnabled
_streamID
_avAudioSettings
_recordBufferDuration
TQ,N,V_streamID
T@"NSDictionary",&,N,V_avAudioSettings
Td,N,V_recordBufferDuration
TB,N,V_meteringEnabled
initWithStreamID:
setStartAlert:
setStopAlert:
setStopOnErrorAlert:
_startAlert
_stopAlert
_stopOnErrorAlert
Tq,N,V_startAlert
Tq,N,V_stopAlert
Tq,N,V_stopOnErrorAlert
initWithStreamID:atStartHostTime:
setStartHostTime:
setSkipAlert:
startAnchorPoint
setStartAnchorPoint:
_skipAlert
_startAnchorPoint
_startHostTime
TQ,N,V_startHostTime
TB,N,V_skipAlert
TI,N,V_startAnchorPoint
type
setType:
mode
setMode:
alertEndTime
setAlertEndTime:
_type
_mode
_alertEndTime
Ti,N,V_type
Tq,N,V_mode
TQ,N,V_alertEndTime
initWithFadeIn:fadeOut:
fadeIn
setFadeIn:
fadeOut
setFadeOut:
_fadeIn
_fadeOut
T@"NSNumber",&,N,V_fadeIn
T@"NSNumber",&,N,V_fadeOut
initWithDuckOthers:duckToLevel:mixWithOthers:
duckOthers
setDuckOthers:
duckToLevel
setDuckToLevel:
isBlur
setIsBlur:
mixWithOthers
setMixWithOthers:
_isBlur
_duckOthers
_duckToLevel
_mixWithOthers
T@"NSNumber",&,N,V_duckOthers
T@"NSNumber",&,N,V_duckToLevel
TB,N,V_isBlur
T@"NSNumber",&,N,V_mixWithOthers
duckOverride
setDuckOverride:
fadeDuration
setFadeDuration:
_duckOverride
_fadeDuration
T@"AVVCDuckOverride",&,N,V_duckOverride
T@"AVVCDuckFadeDuration",&,N,V_fadeDuration
rangeOfString:
substringToIndex:
whitespaceCharacterSet
substringFromIndex:
removeAllObjects
bundleWithURL:
localizedStringForKey:value:table:
addObject:
addObjectsFromArray:
mutableCopy
GetTypeName:
typeName
URLWithString:
arrayWithArray:
setWithArray:
isSubsetOfSet:
allObjects
defaultCenter
postNotificationName:object:
array
dictionary
configurationDictionary
containsObject:
audioComponentDescription
initWithComponentDescription:
initWithComponentDescription:withAVAUManagerImpl:
localeChanged
audioComponent
name
localizedTypeName
manufacturerName
versionString
iconURL
icon
userTagNames
setUserTagNames:
allTagNames
componentURL
availableArchitectures
version
hasCustomView
passesAUVal
isSandboxSafe
hasMIDIInput
hasMIDIOutput
validateWithResults:inCompletionHandler:
supportsNumberInputChannels:outputChannels:
isComponentDescriptionMatch:
T@"NSString",R,N
TQ,R,N
T@"NSURL",R,N
T@"NSArray",R,N
sandboxSafe
TB,R,N,GisSandboxSafe
TB,R,N
T^{OpaqueAudioComponent=},R,N
T@"NSArray",C
T{AudioComponentDescription=IIIII},R,N
T@"UIImage",R,N
T@"NSDictionary",R,N
getStatus:
reset
endpointMode
startWaitTime
interspeechWaitTime
endWaitTime
configureWithSampleRate:andFrameRate:
configureWithASBD:andFrameRate:
mStartWaitTime
mInterspeechWaitTime
mEndWaitTime
mEndpointMode
mFrameRate
mLastStatus
getStatus:count:
initWithAudioComponentDescription:
bypass
setBypass:
TB,N
removeObjectsInArray:
unionSet:
arrayWithObjects:count:
bundleWithIdentifier:
sharedAudioUnitComponentManager
localeChanged:
addObserver:selector:name:object:
registrationsChanged:
filteredArrayUsingPredicate:
privateAllocInitSingleton
tagNames
standardLocalizedTagNames
componentsMatchingPredicate:
componentsPassingTest:
componentsMatchingDescription:
removeObject:
setValue:forParam:
valueForParam:
setWetDryMix:
setDelayTime:
setFeedback:
setLowPassCutoff:
wetDryMix
delayTime
feedback
lowPassCutoff
Td,N
cleanupContext:
sessionForContext:clientType:error:
sessionManagerForContext:clientType:error:
initWithUnsignedInteger:
initWithDouble:
initWithCapacity:
mutableBytes
initWithObjects:forKeys:count:
clientRequestsRecording
initWithAudioQueueBuffer:channels:timeStamp:
audioBufferList
setPlaybackRoute:
outputLatency
inputLatency
activateAudioSessionWithPrewarm:error:
forceGetSessionProperties
setForceGetSessionProperties:
isEqualToString:
deactivateAudioSessionWithOptions:error:
loadFactoryPreset:
setPitch:
setOverlap:
pitch
overlap
_delegate
_data
_url
_actualSettings
_format
_playRetain
_channelAssignments
_audioSession
_sessionListenerWasSet
_endInterruptionFlags
_localPlayer
_gcd
stop
delegate
audioPlayerDidFinishPlaying:successfully:
audioPlayerDecodeErrorDidOccur:error:
removeObserver:name:object:
valueForKey:
audioPlayerBeginInterruption:
audioPlayerEndInterruption:withOptions:
audioPlayerEndInterruption:withFlags:
audioPlayerEndInterruption:
initBase
finishedPlaying:
decodeError:
privRemoveSessionListener
handleInterruption:
beginInterruption
endInterruptionWithFlags:
endInterruption
initWithData:fileTypeHint:error:
initWithContentsOfURL:fileTypeHint:error:
owningPortUID
channelNumber
opaqueSessionID
initWithData:error:
initWithContentsOfURL:error:
prepareToPlay
play
playAtTime:
pause
isPlaying
setDelegate:
settings
duration
setVolume:fadeDuration:
setEnableRate:
enableRate
currentTime
deviceCurrentTime
setCurrentTime:
setNumberOfLoops:
numberOfLoops
channelAssignments
setChannelAssignments:
setAudioSession:
mixToUplink
setMixToUplink:
currentDevice
setCurrentDevice:
_currentDevice
playing
TB,R,GisPlaying
Td,R
T@"NSString",C,V_currentDevice
T@"<AVAudioPlayerDelegate>",W
T@"NSURL",R
T@"NSData",R
T@"NSArray",C,N
performSelectorOnMainThread:withObject:waitUntilDone:
initWithUnsignedInt:
initWithBool:
initWithLength:
initWithSettings:
compare:
UTF8String
auxiliarySession
objectForKeyedSubscript:
initWithObjectsAndKeys:
setActivationContext:error:
initWithSession:
setupOneTimeSessionSettingsForClient:
setObject:forKeyedSubscript:
_wqCreateAuxSessionAndManagerForDeviceUID:clientType:session:manager:error:
_wqCreatePrimarySessionManagerIfNeeded:clientType:error:
sessionForContext:clientType:completion:
_wqSessionAndManagerForContext:clientType:session:manager:error:
sessionManagerMap
sessionWillBeDestroyedBlock
allValues
primarySessionManager
setPrimarySessionManager:
sessionForContext:completion:
sessionForContext:error:
sessionManagerForContext:clientType:completion:
auxSessionManagers
releasePrimarySessionManager
workQueue
setWorkQueue:
setSessionManagerMap:
sessionWasCreatedBlock
_workQueue
_sessionManagerMap
_primarySessionManager
_sessionWasCreatedBlock
_sessionWillBeDestroyedBlock
T@"NSObject<OS_dispatch_queue>",&,N,V_workQueue
T@"NSMutableDictionary",&,N,V_sessionManagerMap
T@"AVVCSessionManager",&,N,V_primarySessionManager
T@?,C,N,V_sessionWasCreatedBlock
T@?,C,N,V_sessionWillBeDestroyedBlock
audioRecorderDidFinishRecording:successfully:
privRemoveSessionPropertyListeners
privCommonCleanup
initWithURL:settings:error:
baseInit
path
pathExtension
finishedRecording
defaultManager
removeItemAtPath:error:
audioRecorderBeginInterruption:
audioRecorderEndInterruption:withOptions:
audioRecorderEndInterruption:withFlags:
audioRecorderEndInterruption:
setActive:error:
endInterruptionWithFlags
T@"AVAudioSession",&
initWithURL:format:error:
prepareToRecord
record
recordAtTime:
recordForDuration:
recordAtTime:forDuration:
deleteRecording
setProcessToTap:
processToTap
instantaneousMetering
setInstantaneousMetering:
Ti,N
T@"<AVAudioRecorderDelegate>",W
bytes
setMusicSequence:
dataWithBytes:length:
channelCount
pullInputBlockFromReceiverBlock:
initWithReceiverBlock:
isInterleaved
initWithPCMFormat:frameCapacity:
frameCapacity
setFrameLength:
mutableAudioBufferList
sampleRate
timeWithAudioTimeStamp:sampleRate:
initWithLayout:
layout
layoutTag
initWithLayoutTag:
layoutSize
encodeBytes:length:
decodeBytesWithReturnedLength:
failWithError:
layoutWithLayoutTag:
layoutWithLayout:
supportsSecureCoding
encodeWithCoder:
initWithCoder:
TB,R
_layoutTag
_layout
TI,R,N
Tr^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]},R,N
initStandardFormatWithSampleRate:channels:
arrayWithObjects:
arrayWithObject:
initWithEnvironment:
addObserverForName:object:queue:usingBlock:
removeObserver:
firstObject
isHeadphones
encodeObject:forKey:
identifier
primaryLanguages
supportedLanguages
voiceSize
encodeInt64:forKey:
gender
encodeInteger:forKey:
decodeObjectOfClass:forKey:
setName:
setIdentifier:
setWithObjects:
decodeObjectOfClasses:forKey:
setSupportedLanguages:
longLongValue
setVoiceSize:
setVersion:
integerValue
setGender:
setAge:
initialize
updateSpeechVoices
initWithName:identifier:primaryLanguages:supportedLanguages:
_name
_identifier
_primaryLanguages
_supportedLanguages
_voiceSize
_version
_gender
_age
T@"NSString",&,N,V_name
T@"NSString",&,N,V_identifier
T@"NSArray",&,N,V_supportedLanguages
T@"NSArray",R,N,V_primaryLanguages
Tq,N,V_voiceSize
T@"NSString",&,N,V_version
Tq,N,V_gender
Tq,N,V_age
voice
ssmlRepresentation
setVoice:
setSsmlRepresentation:
initWithSSMLRepresentation:voice:
_ssmlRepresentation
_voice
T@"NSString",&,N,V_ssmlRepresentation
T@"AVSpeechSynthesisProviderVoice",&,N,V_voice
synthesizeSpeechRequest:
cancelSpeechRequest
speechVoices
setSpeechVoices:
speechSynthesisOutputMetadataBlock
setSpeechSynthesisOutputMetadataBlock:
_speechVoices
_speechSynthesisOutputMetadataBlock
T@"NSArray",&,N,V_speechVoices
T@?,C,N,V_speechSynthesisOutputMetadataBlock
initWithListenerEndpoint:
setConnection:
initWithServiceName:
connection
passExtensionToken:
startWithSequence:completion:
playback:filePath:completion:
startRecording:filePath:completion:
stopRecording:
cancel
interfaceWithProtocol:
setRemoteObjectInterface:
remoteObjectInterface
setClasses:forSelector:argumentIndex:ofReply:
localizedDescription
remoteObjectProxyWithErrorHandler:
setServiceDelegateAsync:
synchronousRemoteObjectProxyWithErrorHandler:
setServiceDelegateSync:
setInterruptionHandler:
setInvalidationHandler:
resume
initWithXPCEndPoint:
stimulusURL
fileSystemRepresentation
serviceDelegateSync
processSequenceAsynchronously
serviceDelegateAsync
outputID
inputID
invalidate
setProcessSequenceAsynchronously:
_processSequenceAsynchronously
_connection
_serviceDelegateAsync
_serviceDelegateSync
T@"NSXPCConnection",&,N,V_connection
T@"<AVAudioDeviceTestServiceProtocol>",&,N,V_serviceDelegateAsync
T@"<AVAudioDeviceTestServiceProtocol>",&,N,V_serviceDelegateSync
TB,V_processSequenceAsynchronously
channelLayout
magicCookie
setMagicCookie:
initFromFormat:toFormat:
inputFormat
outputFormat
dither
downmix
setDither:
setDownmix:
sampleRateConverterQuality
setSampleRateConverterQuality:
sampleRateConverterAlgorithm
setSampleRateConverterAlgorithm:
channelMap
setChannelMap:
maximumOutputPacketSize
primeMethod
setPrimeMethod:
primeInfo
setPrimeInfo:
convertToBuffer:fromBuffer:error:
convertToBuffer:error:withInputFromBlock:
T@"AVAudioFormat",R,N
T@"NSArray",&,N
T@"NSData",&,N
T@"NSString",&,N
T{AVAudioConverterPrimeInfo=II},N
bitRate
setBitRate:
bitRateStrategy
setBitRateStrategy:
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
Tq,R,N
initWithBytes:length:
initWithObjects:count:
byteCapacity
setByteLength:
packetCapacity
setPacketCount:
numberWithDouble:
getLock
setPublicMetrics:
publicMetrics
dictionaryWithObjects:forKeys:count:
setAvvcProfilingInfoDictionary:
setVoiceTriggerStartHostTime:
setCallToStartRecordHostTime:
localTimeZone
setTimeZone:
setDateFormat:
stringFromDate:
avvcProfilingInfoDictionary
createSharedManager
destroySharedManager
sharedManager
retrieveMetrics
getStringDate:
resetProfileMetrics
retrieveProfileMetrics
measureElapseTimeForMetric:block:
setAudioIssueDetectorFormat:numFrames:
audioIssueDetectorAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetAudioIssueDetector
setADAMFormat:numFrames:
adamAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetADAM
logProfileMetrics:
voiceTriggerStartHostTime
callToStartRecordHostTime
mProfileAVVC
_voiceTriggerStartHostTime
_callToStartRecordHostTime
_publicMetrics
_avvcProfilingInfoDictionary
T@"NSMutableDictionary",&,V_publicMetrics
T@"NSMutableDictionary",&,V_avvcProfilingInfoDictionary
TQ,N,V_voiceTriggerStartHostTime
TQ,N,V_callToStartRecordHostTime
setSessionBufferSize:
renderBlock
FillOutAUPreset:
setPreGain:
preGain
getAVVCSessionState
setSessionActivationContext:
setSessionCategoryModeOptionsForActivationMode:withOptions:
setSessionSampleRateForActivationMode:
setSessionAudioHWControlFlagsForActivationMode:withOptions:
setSessionState:
setClientRequestsRecording:
isSessionActive
getSessionActivationOptions
setActive:withOptions:error:
enableSmartRoutingConsideration:
setDuckOthers:mixWithOthers:error:
setDuckToLevelDB:error:
setDuckToLevelScalar:error:
setDuckingFadeOutDuration:fadeInDuration:error:
isSWVolumeSupportedOnPickedRoute
setEnableBTTriangleMode:error:
setOutputVolume:
outputVolume
setInputVolume:bus:
setInputPan:bus:
inputConnected:
nextAvailableInputBus
initWithNode:
currentAudioTimeStamp
currentIONumberFrames
awaitIOCycle:
T@"AVAudioTime",R,N
destroyBase
initWithContentsOfURL:soundBankURL:error:
initWithData:soundBankURL:error:
hostTimeForBeats:
beatsForHostTime:
play:
currentPosition
setCurrentPosition:
TB,R,N,GisPlaying
remoteInputDeviceName
deviceCategory
startNote:withVelocity:onChannel:
stopNote:onChannel:
sendController:withValue:onChannel:
sendPitchBend:onChannel:
sendPressure:onChannel:
sendPressureForKey:withValue:onChannel:
sendProgramChange:onChannel:
sendProgramChange:bankMSB:bankLSB:onChannel:
sendMIDIEvent:data1:data2:
sendMIDIEvent:data1:
sendMIDISysExEvent:
sendMIDIEventList:
byteLength
mutableCopyWithZone:
initWithFormat:byteCapacity:
initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:
_deallocator
Tr^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
T^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
_initChannelPtrs
appendDataFromBuffer:channel:
calculatePower:
floatChannelData
stride
calculatePower:forFloatData:stride:frameLength:
numberWithFloat:
int16ChannelData
int32ChannelData
initWithPCMFormat:bufferListNoCopy:deallocator:
appendDataFromBuffer:
splitIntoSingleChannelBuffers
averagePowerPerChannel
peakPowerPerChannel
TI,N
T^^f,R,N
T^^s,R,N
T^^i,R,N
initWithFormat:packetCapacity:maximumPacketSize:
initWithFormat:packetCapacity:
maximumPacketSize
T^v,R,N
TI,R,D,N
TI,D,N
T^{AudioStreamPacketDescription=qII},R,N
setFilterType:
filterType
setFrequency:
frequency
setBandwidth:
bandwidth
setGain:
gain
initWithNumberOfBands:
bands
globalGain
setGlobalGain:
initWithStreamDescription:channelLayout:
settingsFromASBD:channelLayout:
numberWithUnsignedInteger:
setValue:forKey:
encodeDouble:forKey:
decodeDoubleForKey:
decodeIntegerForKey:
formatWithInvalidSampleRateAndChannelCount
initStandardFormatWithSampleRate:channelLayout:
initWithCommonFormat:sampleRate:channels:interleaved:
initWithCommonFormat:sampleRate:interleaved:channelLayout:
initWithCMAudioFormatDescription:
formatDescription
isStandard
commonFormat
_asbd
_commonFormat
standard
TB,R,N,GisStandard
interleaved
TB,R,N,GisInterleaved
Tr^{AudioStreamBasicDescription=dIIIIIIII},R,N
T@"AVAudioChannelLayout",R,N
Tr^{opaqueCMFormatDescription=},R,N
initWithData:inputID:outputID:sampleRate:correlationValue:
setInputID:
setOutputID:
setSampleRate:
correlationValue
setCorrelationValue:
_inputID
_outputID
_sampleRate
_correlationValue
Tq,N,V_outputID
Tq,N,V_inputID
Td,N,V_sampleRate
Td,N,V_correlationValue
T@"NSData",R,N,V_data
encodeFloat:forKey:
encodeBool:forKey:
decodeFloatForKey:
decodeBoolForKey:
setStimulusURL:
inputProcessingChain
setInputProcessingChain:
outputProcessingChain
setOutputProcessingChain:
outputMode
setOutputMode:
priority
setPriority:
calculateCrossCorrelationPeak
setCalculateCrossCorrelationPeak:
parallelCrossCorrelationCalculation
setParallelCrossCorrelationCalculation:
setNumberOfChannels:
micBufferNumbers
setMicBufferNumbers:
requiresBluetoothOutput
setRequiresBluetoothOutput:
microphone
setMicrophone:
_calculateCrossCorrelationPeak
_parallelCrossCorrelationCalculation
_requiresBluetoothOutput
_volume
_stimulusURL
_inputProcessingChain
_outputProcessingChain
_outputMode
_priority
_numberOfChannels
_micBufferNumbers
_microphone
Tf,N,V_volume
T@"NSURL",&,N,V_stimulusURL
T@"AVAudioDeviceTestProcessingChain",&,N,V_inputProcessingChain
T@"AVAudioDeviceTestProcessingChain",&,N,V_outputProcessingChain
Tq,N,V_outputMode
Tq,N,V_priority
T@"NSString",&,V_mode
TB,V_calculateCrossCorrelationPeak
TB,V_parallelCrossCorrelationCalculation
Tq,N,V_numberOfChannels
T@"NSArray",&,N,V_micBufferNumbers
TB,V_requiresBluetoothOutput
T@"NSString",&,N,V_microphone
graphURL
setGraphURL:
processingStripURL
setProcessingStripURL:
_graphURL
_processingStripURL
T@"NSURL",&,N,V_graphURL
T@"NSURL",&,N,V_processingStripURL
pullInputBlockFromRenderBlock:
initWithRenderBlock:
initWithFormat:renderBlock:
stringByReplacingOccurrencesOfString:withString:
startAndReturnError:
reason
fileURLWithPath:
dictionaryWithContentsOfURL:error:
enableManualRenderingMode:format:maximumFrameCount:error:
inputNode
attachNode:
connect:to:format:
outputNode
detachNode:
renderOffline:toBuffer:error:
bundleWithPath:
isLoaded
loadAndReturnError:
principalClass
language
quality
setLanguage:
setQuality:
currentLanguageCode
voiceWithLanguage:
voiceWithIdentifier:
audioFileSettings
_audioFileSettings
T@"NSString",C,D,N
T@"NSString",&,D,N
Tq,D,N
T@"NSDictionary",R,N,V_audioFileSettings
speechString
attributedSpeechString
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
setSpeechString:
setAttributedSpeechString:
floatValue
setPitchMultiplier:
setPreUtteranceDelay:
setPostUtteranceDelay:
speechUtteranceWithString:
speechUtteranceWithAttributedString:
speechUtteranceWithSSMLRepresentation:
initWithAttributedString:
initWithSSMLRepresentation:
prefersAssistiveTechnologySettings
setPrefersAssistiveTechnologySettings:
_prefersAssistiveTechnologySettings
_rate
_pitchMultiplier
_speechString
_attributedSpeechString
_preUtteranceDelay
_postUtteranceDelay
T@"NSString",&,N,V_speechString
T@"NSAttributedString",&,N,V_attributedSpeechString
T@"AVSpeechSynthesisVoice",&,N,V_voice
Tf,N,V_rate
Tf,N,V_pitchMultiplier
TB,N,V_prefersAssistiveTechnologySettings
Td,N,V_preUtteranceDelay
Td,N,V_postUtteranceDelay
speakUtterance:
writeUtterance:toBufferCallback:
writeUtterance:toBufferCallback:toMarkerCallback:
stopSpeakingAtBoundary:
pauseSpeakingAtBoundary:
continueSpeaking
isSpeaking
isPaused
outputChannels
setOutputChannels:
usesApplicationAudioSession
setUsesApplicationAudioSession:
mixToTelephonyUplink
setMixToTelephonyUplink:
_speaking
_paused
_usesApplicationAudioSession
_mixToTelephonyUplink
_outputChannels
T@"<AVSpeechSynthesizerDelegate>",W,N,V_delegate
speaking
TB,R,N,GisSpeaking,V_speaking
paused
TB,R,N,GisPaused,V_paused
T@"NSArray",&,N,V_outputChannels
TB,N,V_usesApplicationAudioSession
TB,N,V_mixToTelephonyUplink
mark
byteSampleOffset
textRange
valueWithRange:
setMark:
setByteSampleOffset:
rangeValue
setTextRange:
initWithMarkerType:forTextRange:atByteSampleOffset:
initWithMarkerType:name:forTextRange:atByteSampleOffset:
_mark
_byteSampleOffset
_textRange
Tq,N,V_mark
TQ,N,V_byteSampleOffset
T{_NSRange=QQ},N,V_textRange
channels
bytesCapacity
bytesDataSize
setBytesDataSize:
packetDescriptionCapacity
packetDescriptionCount
setPacketDescriptions:count:
timeStamp
remoteVoiceActivityRMS
remoteVoiceActivityVAD
remoteVoiceActivityAvailable
upsamplingSourceAudio
Ti,R
T^v,R
T^{AudioStreamPacketDescription=qII},R
T^{AudioStreamBasicDescription=dIIIIIIII},R
TC,R
setDistanceAttenuationModel:
distanceAttenuationModel
setMaximumDistance:
maximumDistance
setReferenceDistance:
referenceDistance
setRolloffFactor:
rolloffFactor
setEnable:
enable
setLevel:
level
filterParameters
loadFactoryReverbPreset:
T@"AVAudioUnitEQFilterParameters",R,N
setOutputType:
outputType
applicableRenderingAlgorithms
setListenerPosition:
listenerPosition
setListenerVectorOrientation:
listenerVectorOrientation
setListenerAngularOrientation:
listenerAngularOrientation
distanceAttenuationParameters
reverbParameters
T{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}},N
T{AVAudio3DAngularOrientation=fff},N
T@"AVAudioEnvironmentDistanceAttenuationParameters",R,N
T@"AVAudioEnvironmentReverbParameters",R,N
changeDuckOthersOption:
shouldEnableMiniDucking:withOptions:
isMiniDuckingEnabled
setCategory:mode:routeSharingPolicy:options:error:
setIAmTheAssistant:error:
clearInputPreferences:
isSessionInSiriCategoryModeAndOptions:
setPreferredSampleRate:error:
invalidatePlugins
setSessionActivationOptions:
setAudioHardwareControlFlags:error:
sessionCurrentOutputRoutes
isAirplayOneOfTheOutputRoutes:
getSiriInputSource:withIdentifier:
deviceIdentifier
getOpaqueSessionID
voiceTriggerPastDataFramesAvailable
deviceGain
category
voiceControllerLPCMAudioCallback:forStream:buffer:
voiceControllerAudioCallback:forStream:buffer:
voiceControllerLPCMRecordBufferAvailable:buffer:
voiceControllerRecordBufferAvailable:buffer:
siriRemoteInputIdentifier
isSessionOutputInWirelessSplitterMode
setCategory:withOptions:error:
setAllowHapticsAndSystemSoundsDuringRecording:error:
setSessionStateWithoutLock:
pickedRoute
isOtherAudioPlaying
getHypotheticalRouteAndUpdateStates
categoryOptions
setPreferredIOBufferFrameSize:error:
preferredIOBufferFrameSize
setEligibleForBTSmartRoutingConsideration:error:
setEligibleForBTTriangleConsideration:error:
setCategory:mode:options:error:
siriInputSource
activeSessionDisplayIDs
componentsJoinedByString:
setRecordingFromRemoteInput:error:
getClientRequestsRecording
setDeviceGain:
getDeviceGain
getPlaybackRoute
getForceGetSessionProperties
isSessionInSiriCategory
reporterID
sessionCurrentInputRoutes
getActiveSessionDisplayIDsAsString
.cxx_construct
mShouldDuckOthers
mIsMiniDuckingEnabled
mShouldEnableMiniDucking
mShouldDisableMiniDucking
mSessionNeedsVolumeControl
mSessionNeedsRoutingControl
mSessionOutputIsWirelessSplitter
mIsOtherAudioPlaying
mRouteHasDoAPSupport
mOutputSupportsSWVolume
mDeviceIsIOSAccessory
mDeviceIsOlderWatch
mSessionActivationOptions
mPreviousActivationMode
mSessionManagerLock
_isPrimary
_clientRequestsRecording
_forceGetSessionProperties
_sessionState
_deviceGain
_reporterID
_inputLatency
_outputLatency
_playbackRoute
T@"AVAudioSession",&,N,V_audioSession
Ti,N,V_sessionState
TB,R,N,V_isPrimary
TB,N,V_clientRequestsRecording
Tf,N,V_deviceGain
T@"NSString",&,N,V_playbackRoute
TB,N,V_forceGetSessionProperties
Td,R,N,V_inputLatency
Td,R,N,V_outputLatency
Tq,R,V_reporterID
processInfo
processIdentifier
message
initWithChannel:key:velocity:duration:
channel
setChannel:
setKey:
velocity
setVelocity:
setDuration:
initWithMessage:
isEqualTo:
_msg
T^{MIDINoteMessage=CCCCf},R
initWithChannel:status:data1:data2:
data1
setData1:
data2
setData2:
T^{MIDIChannelMessage=CCCC},R
initWithChannel:messageType:value:
messageType
value
Tq,R
TI,R
initWithChannel:key:pressure:
pressure
setPressure:
initWithChannel:programNumber:
programNumber
setProgramNumber:
initWithChannel:pressure:
initWithChannel:value:
setValue:
appendBytes:length:
appendData:
initWithData:
sizeInBytes
initWithMIDIRawData:
rawData
_sysexData
T^{MIDIRawData=I[1C]},R
initWithType:data:
initWithMetaEvent:
metaEvent
_event
T^{MIDIMetaEvent=CCCCI[1C]},R,V_event
initWithUserData:
userData
_userData
T^{MusicEventUserData=I[1C]},R
initWithMIDINote:velocity:instrumentID:groupID:duration:
initWithMIDINote:velocity:groupID:duration:
midiNote
setMidiNote:
instrumentID
setInstrumentID:
groupID
setGroupID:
initWithNoteOnEvent:
event
T^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}},R,V_event
initWithParameterID:scope:element:value:
parameterID
setParameterID:
scope
setScope:
element
setElement:
initWithParameterEvent:
T^{ParameterEvent=IIIf},R
initWithScope:element:dictionary:
presetDictionary
initWithAUPresetEvent:
T^{AUPresetEvent=II^v},R
T@"NSDictionary",R,C
initWithTempo:
tempo
setTempo:
_bpm
Td,V_bpm
initForReading:commonFormat:interleaved:error:
initForReadingFromExtAudioFile:commonFormat:interleaved:error:
initForWriting:settings:commonFormat:interleaved:error:
readIntoBuffer:frameCount:error:
initForReading:error:
initForReadingFromExtAudioFile:error:
initForWriting:settings:error:
initSecondaryReader:format:error:
readIntoBuffer:error:
writeFromBuffer:error:
fileFormat
processingFormat
framePosition
setFramePosition:
setOutputFormat:forBus:
inputFormatForBus:
setInputFormat:forBus:
nameForInputBus:
nameForOutputBus:
clock
lastRenderTime
latency
outputPresentationLatency
numberOfInputs
numberOfOutputs
setNumberOfInputs:
setNumberOfOutputs:
installTapOnBus:bufferSize:format:block:
removeTapOnBus:
AUAudioUnit
T@"AVAudioEngine",R,N
T@"AUAudioUnit",R,N
connectionPoint
T@"AVAudioConnectionPoint",R,N
parameterTree
caseInsensitiveCompare:
overallGain
setOverallGain:
loadInstrumentAtURL:error:
loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:
loadAudioFilesAtURLs:error:
stereoPan
masterGain
globalTuning
setStereoPan:
setMasterGain:
setGlobalTuning:
allBundles:
initWithPluginDelegate:
devices
URLsForDirectory:inDomains:
URLByAppendingPathComponent:
checkResourceIsReachableAndReturnError:
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
inputPlugin:didPublishDevice:
inputPlugin:didUnpublishDevice:
mMotherController
setMMotherController:
mPlugins
_mMotherController
T@"AVVoiceController",W,N,V_mMotherController
currentPositionInSeconds
setCurrentPositionInSeconds:
currentPositionInBeats
setCurrentPositionInBeats:
hostTimeForBeats:error:
beatsForHostTime:error:
setTempoTrack:
cleanTracks
setTrackArray:
trackArray
setupTrackArray
numberOfTracks
setupTracks
tempoTrack
index
removeObjectAtIndex:
initWithAudioEngine:
loadFromURL:options:error:
loadFromData:options:error:
writeToURL:SMPTEResolution:replaceExisting:error:
dataWithSMPTEResolution:error:
createAndAppendTrack
tracks
getTempoTrack
removeTrack:
secondsForBeats:
beatsForSeconds:
reverseEvents
setUserCallback:
T@"AVMusicTrack",R,N
track
setDestinationAudioUnit:
destinationAudioUnit
setDestinationMIDIEndpoint:
destinationMIDIEndpoint
loopRange
setLoopRange:
isLoopingEnabled
setLoopingEnabled:
offsetTime
setOffsetTime:
isMuted
setMuted:
isSoloed
setSoloed:
usesAutomatedParameters
setUsesAutomatedParameters:
lengthInBeats
setLengthInBeats:
lengthInSeconds
setLengthInSeconds:
timeResolution
T@"AVAudioUnit",&,N
T{_AVBeatRange=dd},N
loopingEnabled
TB,N,GisLoopingEnabled
muted
TB,N,GisMuted
soloed
TB,N,GisSoloed
doAddMIDINoteEvent:atBeat:
doAddMIDIChannelEvent:atBeat:
doAddMIDISysexEvent:atBeat:
doAddMIDIMetaEvent:atBeat:
doAddUserEvent:atBeat:
doAddExtendedNoteOnEvent:atBeat:
doAddParameterEvent:atBeat:
doAddAUPresetEvent:atBeat:
doAddExtendedTempoEvent:atBeat:
createEventIterator
seek:
hasCurrentEvent
getEventInfo:outEventType:eventData:dataSize:
handleFailureInMethod:object:file:lineNumber:description:
deleteEvent
setEventTime:
setEventInfo:data:
nextEvent
addEvent:atBeat:
moveEventsInRange:byAmount:
clearEventsInRange:
cutEventsInRange:
copyEventsInRange:fromTrack:insertAtBeat:
copyAndMergeEventsInRange:fromTrack:mergeAtBeat:
enumerateEventsInRange:usingBlock:
previousEvent
hasPreviousEvent
hasNextEvent
initWithHostTime:
initWithSampleTime:atRate:
initWithHostTime:sampleTime:atRate:
initWithAudioTimeStamp:sampleRate:
secondsForHostTime:
timeWithHostTime:
timeWithSampleTime:atRate:
timeWithHostTime:sampleTime:atRate:
hostTimeForSeconds:
isHostTimeValid
isSampleTimeValid
hostTime
sampleTime
extrapolateTimeFromAnchor:
_ats
hostTimeValid
TB,R,N,GisHostTimeValid
sampleTimeValid
TB,R,N,GisSampleTimeValid
T{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II},R,N
loadAudioDSPManager
relativePath
loadDSPGraphAtURL:error:
loadAudioUnitProcessingStripAtURL:error:
dspGraphURL
auProcessingStripURL
scheduleBuffer:atTime:options:completionHandler:
scheduleBuffer:atTime:options:completionCallbackType:completionHandler:
callLegacyCompletionHandlerForType:legacyHandler:
scheduleFile:atTime:completionCallbackType:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:
scheduleBuffer:completionHandler:
scheduleBuffer:completionCallbackType:completionHandler:
scheduleFile:atTime:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionHandler:
prepareWithFrameCount:
nodeTimeForPlayerTime:
playerTimeForNodeTime:
initWithKeyOptions:valueOptions:capacity:
anyObject
voiceTriggerPastDataFramesAvailableCompletion:
enableVoiceTriggerListening:completionBlock:
enableSpeakerStateListening:completionBlock:
speakerStateActiveCompletionBlock:
speakerStateMutedCompletionBlock:
updateVoiceTriggerConfiguration:completionBlock:
supportsDuckingOnSpeakerOutput
callServerCrashedBlock
handleMediaServerDeath:
callServerResetBlock
handleMediaServerReset:
voiceTriggerServerConnection
getInputChannelInfoCompletion:
enableVoiceTriggerListening:
setListeningProperty:completionBlock:
enableSpeakerStateListening:
speakerStateActive
speakerStateMuted
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:
listeningEnabledCompletionBlock:
siriClientsRecordingCompletionBlock:
setAggressiveECMode:completionBlock:
voiceTriggerNotification:
speakerStateChangedNotification:
speakerMuteStateChangedNotification:
siriClientRecordStateChangedNotification:recordingCount:
voiceTriggerBlock
setVoiceTriggerBlock:
speakerStateChangedBlock
setSpeakerStateChangedBlock:
speakerMuteStateChangedBlock
setSpeakerMuteStateChangedBlock:
siriClientRecordStateChangedBlock
setSiriClientRecordStateChangedBlock:
serverCrashedBlock
setServerCrashedBlock:
serverResetBlock
setServerResetBlock:
_voiceTriggerBlock
_speakerStateChangedBlock
_speakerMuteStateChangedBlock
_siriClientRecordStateChangedBlock
_serverCrashedBlock
_serverResetBlock
T@?,C,N,V_voiceTriggerBlock
T@?,C,N,V_speakerStateChangedBlock
T@?,C,N,V_speakerMuteStateChangedBlock
T@?,C,N,V_siriClientRecordStateChangedBlock
T@?,C,N,V_serverCrashedBlock
T@?,C,N,V_serverResetBlock
dictionaryWithContentsOfURL:
componentsSeparatedByString:
instantiateWithComponentDescription:options:completionHandler:
loadAudioUnitPresetAtURL:error:
T@"AUAudioUnit",R,D,N
mainMixerNode
connect:to:fromBus:toBus:format:
connect:toConnectionPoints:fromBus:format:
disconnectNodeInput:bus:
disconnectNodeOutput:bus:
disconnectNodeInput:
disconnectNodeOutput:
prepare
inputConnectionPointForNode:inputBus:
outputConnectionPointsForNode:outputBus:
musicSequence
isRunning
isAutoShutdownEnabled
setAutoShutdownEnabled:
manualRenderingSampleTime
disableManualRenderingMode
manualRenderingBlock
connectMIDI:to:format:block:
connectMIDI:toNodes:format:block:
connectMIDI:to:format:eventListBlock:
connectMIDI:toNodes:format:eventListBlock:
disconnectMIDI:from:
disconnectMIDI:fromNodes:
disconnectMIDIInput:
disconnectMIDIOutput:
attachedNodes
T^{OpaqueMusicSequence=},N
T@"AVAudioOutputNode",R,N
T@"AVAudioInputNode",R,N
T@"AVAudioMixerNode",R,N
running
TB,R,N,GisRunning
autoShutdownEnabled
TB,N,GisAutoShutdownEnabled
T@"NSSet",R,C
T@?,R,N
auAudioUnitForAudioUnit:
isMusicDeviceOrEffect
scheduleMIDIEventBlock
scheduleMIDIEventListBlock
removeRenderObserver:
invalidateAudioUnit
allocateRenderResourcesAndReturnError:
deallocateRenderResources
inputBusses
outputBusses
setFormat:error:
setEnabled:
isEnabled
setBusCount:error:
parameterWithID:scope:element:
parameterWithAddress:
maximumFramesToRender
setMaximumFramesToRender:
isRenderingOffline
setRenderingOffline:
tokenByAddingRenderObserver:
setMIDIOutputEventListBlock:
setHostMIDIProtocol:
hostMIDIProtocol
setInputEnabled:
setOutputEnabled:
startHardwareAndReturnError:
stopHardware
setOutputProvider:
setInputHandler:
canPerformInput
canPerformOutput
@28@0:8^v16B24
d16@0:8
^{OpaqueAudioComponentInstance=}16@0:8
v24@0:8@16
v32@0:8@16^@24
B16@0:8
q16@0:8
B28@0:8B16^@20
B28@0:8q16B24
B32@0:8^v16B24B28
B28@0:8@16I24
@16@0:8
I16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
f16@0:8
v20@0:8f16
v24@0:8q16
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@32@0:8@16Q24
@"AVAudioMixingDestination"32@0:8@"AVAudioNode"16Q24
B32@0:8@16@?24
v20@0:8B16
v16@0:8
@"AVAudioNode"
@32@0:8{shared_ptr<AVVCRecordingEngine>=^{AVVCRecordingEngine}^{__shared_weak_count}}16
@"NSString"
@"NSUUID"
{shared_ptr<ControllerImpl>=^{ControllerImpl}^{__shared_weak_count}}16@0:8
v20@0:8i16
v32@0:8@16@24
v28@0:8Q16i24
v24@0:8Q16
@"NSXPCListenerEndpoint"16@0:8
@32@0:8@16^@24
v24@0:8^@16
B32@0:8@16^@24
B28@0:8@16i24
B20@0:8i16
i32@0:8Q16@24
B24@0:8^@16
B32@0:8Q16^@24
B24@0:8d16
i16@0:8
v24@0:8d16
f24@0:8Q16
@24@0:8^@16
@32@0:8q16^@24
v32@0:8@16@?24
Q32@0:8@16^@24
Q40@0:8@16^q24^@32
v48@0:8@16@?24@?32@?40
v32@0:8Q16@?24
q24@0:8Q16
@24@0:8Q16
B36@0:8Q16B24^@28
B40@0:8Q16B24B28^@32
v40@0:8Q16Q24@?32
v40@0:8Q16Q24^@32
B40@0:8@16Q24^@32
v36@0:8i16q20@?28
B28@0:8i16q20
d24@0:8Q16
B24@0:8Q16
f32@0:8Q16Q24
v24@0:8@?16
B28@0:8Q16B24
B40@0:8Q16@24^@32
v36@0:8Q16B24@?28
@32@0:8q16@24
@24@0:8^{_NSZone=}16
@40@0:8Q16@24d32
@"NSDictionary"
@32@0:8Q16Q24
v20@0:8I16
@36@0:8i16q20Q28
@32@0:8@16@24
@"NSNumber"
@40@0:8@16@24@32
@"AVVCDuckOverride"
@"AVVCDuckFadeDuration"
@36@0:8{AudioComponentDescription=IIIII}16
@44@0:8{AudioComponentDescription=IIIII}16^{AVAudioUnitComponentManagerImpl=^^?@@@{mutex={_opaque_pthread_mutex_t=q[56c]}}}36
^{OpaqueAudioComponent=}16@0:8
{AudioComponentDescription=IIIII}16@0:8
B32@0:8q16q24
@20@0:8I16
B36@0:8{AudioComponentDescription=IIIII}16
i24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
B28@0:8d16I24
B28@0:8^{AudioStreamBasicDescription=dIIIIIIII}16I24
^{Impl=^v^{Averager}}
i28@0:8^f16I24
@24@0:8@16
@24@0:8@?16
@"<AVAudioPlayerDelegate>"
@"NSData"
@"NSURL"
@"AVAudioFormat"
@"NSArray"
@"AVAudioSession"
@"NSObject<OS_dispatch_queue>"
@40@0:8@16@24^@32
v28@0:8f16d20
v56@0:8@16q24^@32^@40^@48
@40@0:8@16q24^@32
v40@0:8@16q24@?32
@?16@0:8
@"NSMutableDictionary"
@"AVVCSessionManager"
@"AVAudioSession"16@0:8
v24@0:8@"AVAudioSession"16
^{AudioRecorderImpl=@@@@@@I{AudioStreamBasicDescription=dIIIIIIII}^{OpaqueAudioFileID}^{OpaqueAudioQueue}qqqdddQ*BBBBBBBB^{AudioQueueLevelMeterState}[4^{AudioQueueBuffer}]^{AudioQueueBuffer}BQBi@}16@0:8
B32@0:8d16d24
@?24@0:8@?16
@24@0:8r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16@0:8
^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}
@48@0:8@16@24@32@40
@"AVSpeechSynthesisProviderVoice"
v40@0:8@16@24@?32
v24@0:8@"NSString"16
v32@0:8@"AVAudioDeviceTestSequence"16@?<v@?@"NSArray"@"NSError">24
v40@0:8@"AVAudioDeviceTestSequence"16@"NSString"24@?<v@?@"NSError">32
v24@0:8@?<v@?@"NSError">16
@"NSXPCConnection"
@"<AVAudioDeviceTestServiceProtocol>"
{AVAudioConverterPrimeInfo=II}16@0:8
v24@0:8{AVAudioConverterPrimeInfo=II}16
B40@0:8@16@24^@32
q40@0:8@16^@24@?32
^v16@0:8
i60@0:8{CAStreamBasicDescription=dIIIIIIII}16I56
i56@0:8{AudioBufferList=I[1{AudioBuffer=II^v}]}16I40r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}44B52
{AUPreset=i^{__CFString}}24@0:8q16
v28@0:8f16Q20
@24@0:8^v16
{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16@0:8
@24@0:8^I16
Q24@0:8d16
^{MIDIPlayerImpl=^{OpaqueAUGraph}^{OpaqueMusicPlayer}^{OpaqueMusicSequence}d@?@}16@0:8
v28@0:8C16C20C24
v24@0:8C16C20
v24@0:8S16C20
v32@0:8C16C20C24C28
v24@0:8r^{MIDIEventList=iI[1{MIDIEventPacket=QI[64I]}]}16
@28@0:8@16I24
@44@0:8@16I24r^{AudioBufferList=I[1{AudioBuffer=II^v}]}28@?36
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
@40@0:8@16r^{AudioBufferList=I[1{AudioBuffer=II^v}]}24@?32
^^f16@0:8
^^i16@0:8
^^s16@0:8
B32@0:8@16q24
f44@0:8Q16^f24q32I40
@36@0:8@16I24q28
^{AudioStreamPacketDescription=qII}16@0:8
@24@0:8^{AVAudioUnitEQFilterParametersImpl=^^?^{AVAudioNodeImplBase}}16
@32@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16@24
@24@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16
@28@0:8d16I24
@32@0:8d16@24
@40@0:8Q16d24I32B36
@44@0:8Q16d24B32@36
@24@0:8^{opaqueCMFormatDescription=}16
r^{opaqueCMFormatDescription=}16@0:8
r^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
{AudioStreamBasicDescription="mSampleRate"d"mFormatID"I"mFormatFlags"I"mBytesPerPacket"I"mFramesPerPacket"I"mBytesPerFrame"I"mChannelsPerFrame"I"mBitsPerChannel"I"mReserved"I}
@"AVAudioChannelLayout"
@56@0:8@16q24q32d40d48
@"AVAudioDeviceTestProcessingChain"
@32@0:8@16@?24
@"AVSpeechSynthesisVoice"
@"NSAttributedString"
v40@0:8@16@?24@?32
B24@0:8q16
@"<AVSpeechSynthesizerDelegate>"
@48@0:8q16{_NSRange=QQ}24Q40
@56@0:8q16@24{_NSRange=QQ}32Q48
{_NSRange=QQ}16@0:8
v32@0:8{_NSRange=QQ}16
{_NSRange="location"Q"length"Q}
v28@0:8r^{AudioStreamPacketDescription=qII}16i24
^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
C16@0:8
@36@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCCB}16i24Q28
v40@0:8{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16
{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16@0:8
v28@0:8{AVAudio3DAngularOrientation=fff}16
{AVAudio3DAngularOrientation=fff}16@0:8
i24@0:8q16
i24@0:8@16
v28@0:8B16Q20
i32@0:8q16Q24
i20@0:8i16
i20@0:8B16
B28@0:8I16^@20
B48@0:8@16@24Q32^@40
B56@0:8@16@24Q32Q40^@48
B20@0:8I16
B32@0:8d16^@24
B32@0:8^Q16^@24
B36@0:8B16Q20^@28
{recursive_mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
@36@0:8I16I20I24d28
@24@0:8^{MIDINoteMessage=CCCCf}16
^{MIDINoteMessage=CCCCf}16@0:8
{MIDINoteMessage="channel"C"note"C"velocity"C"releaseVelocity"C"duration"f}
@32@0:8C16C20C24C28
@24@0:8^{MIDIChannelMessage=CCCC}16
^{MIDIChannelMessage=CCCC}16@0:8
v20@0:8C16
{MIDIChannelMessage="status"C"data1"C"data2"C"reserved"C}
@32@0:8I16q20I28
@28@0:8I16I20I24
@24@0:8I16I20
@24@0:8^{MIDIRawData=I[1C]}16
^{MIDIRawData=I[1C]}16@0:8
@"NSMutableData"
@24@0:8^{MIDIMetaEvent=CCCCI[1C]}16
^{MIDIMetaEvent=CCCCI[1C]}16@0:8
^{MIDIMetaEvent=CCCCI[1C]}
@24@0:8^{MusicEventUserData=I[1C]}16
^{MusicEventUserData=I[1C]}16@0:8
@40@0:8f16f20I24I28d32
@36@0:8f16f20I24d28
@24@0:8^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}}16
^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}}16@0:8
^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}}
@32@0:8I16I20I24f28
@24@0:8^{ParameterEvent=IIIf}16
^{ParameterEvent=IIIf}16@0:8
{ParameterEvent="parameterID"I"scope"I"element"I"value"f}
@32@0:8I16I20@24
@24@0:8^{AUPresetEvent=II^v}16
^{AUPresetEvent=II^v}16@0:8
{AUPresetEvent="scope"I"element"I"preset"^v}
@24@0:8d16
@44@0:8@16Q24B32^@36
@32@0:8^{OpaqueExtAudioFile=}16^@24
@44@0:8^{OpaqueExtAudioFile=}16Q24B32^@36
@52@0:8@16@24Q32B40^@44
B36@0:8@16I24^@28
B24@0:8^v16
B32@0:8@16Q24
v44@0:8Q16I24@28@?36
@24@0:8^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16
^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16@0:8
B44@0:8@16C24C28C32^@36
@24@0:8@"<AVAudioRemoteInputPluginDelegate>"16
@"NSArray"16@0:8
v32@0:8@"<AVAudioRemoteInputPlugin>"16@"<AVAudioRemoteInputDevice>"24
@"NSMutableArray<AVAudioRemoteInputPlugin>"
@"AVVoiceController"
Q32@0:8d16^@24
d32@0:8Q16^@24
B44@0:8@16q24B32^@36
d24@0:8d16
@24@0:8^{MusicTrackImpl=^{OpaqueMusicTrack}@BI}16
^{OpaqueMusicTrack=}16@0:8
{_AVBeatRange=dd}16@0:8
v32@0:8{_AVBeatRange=dd}16
v32@0:8@16d24
v40@0:8{_AVBeatRange=dd}16d32
v48@0:8{_AVBeatRange=dd}16@32d40
v40@0:8{_AVBeatRange=dd}16@?32
@24@0:8^{MusicTrackEventIteratorImpl=^{OpaqueMusicEventIterator}}16
v48@0:8^d16^I24^^v32^I40
B28@0:8I16r^v20
^{MusicTrackEventIteratorImpl=^{OpaqueMusicEventIterator}}
@32@0:8q16d24
@40@0:8Q16q24d32
@32@0:8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16d24
{AudioTimeStamp="mSampleTime"d"mHostTime"Q"mRateScalar"d"mWordClockTime"Q"mSMPTETime"{SMPTETime="mSubframes"s"mSubframeDivisor"s"mCounter"I"mType"I"mFlags"I"mHours"s"mMinutes"s"mSeconds"s"mFrames"s}"mFlags"I"mReserved"I}
v32@0:8q16@?24
v48@0:8@16@24Q32@?40
v56@0:8@16@24Q32q40@?48
v48@0:8@16@24q32@?40
v52@0:8@16q24I32@36@?44
v60@0:8@16q24I32@36q44@?52
v28@0:8B16@?20
v48@0:8{AudioComponentDescription=IIIII}16I36@?40
B24@0:8f16I20
f20@0:8I16
v56@0:8@16@24Q32Q40@48
v40@0:8@16@24@32
v48@0:8@16@24Q32@40
v32@0:8@16Q24
v24@0:8^{OpaqueMusicSequence=}16
^{OpaqueMusicSequence=}16@0:8
B44@0:8q16@24I32^@36
q36@0:8I16@20^@28
v48@0:8@16@24@32@?40
yE> 
mcpl
Mb@?
umuapmas
uouarneglppa
?mcpl
?xfuayledlppa
cfuairavlppa
xfua2bvrlppa
cfuaptunlppa
cfuavnoclppa
xfuatsidlppa
xmuaxmcmlppa
xmualpsmlppa
xfuaqebnlppa
mcpl)
xeps
xfuagpsdlppa
xmuamed3lppa
HDngualpsslppa
((((
X[^adg
#)/BHM
W]ci
St18bad_variant_access
NSt3__117bad_function_callE
NSt3__112bad_weak_ptrE
St9bad_alloc
uouaoipvlppa
uouacoirlppa
xfuagpsdlppa
11CAException
St12length_error
St11logic_error
St9exception
CAException
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioIONode.mm
-[AVAudioIONode enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:]
ioUnit != nil
-[AVAudioOutputNode setManualRenderingPCMFormat:maximumFrameCount:]
self.isInManualRenderingMode
-[AVAudioOutputNode manualRenderingFormat]
-[AVAudioOutputNode manualRenderingMaximumFrameCount]
required condition is false: %s
com.apple.coreaudio.avfaudio
AVVCCarplayRuntimeAvailability.mm
AVOutputContext
Class getAVOutputContextClass()_block_invoke
Unable to find class %s
void *AVFoundationLibrary()
AVAudioSessionRouteChangeCurrentRouteKey
AVVCUtils.mm
AcousticID
%@%d
DeviceClassNumber
torpedo
microphone
com.apple.audio.AVFAudio
null
{ inputs: %@, 
outputs: %@ }
(type=%@, name=%@, UID=%@); 
Unknown
NewDeviceAvailable
OldDeviceUnAvailable
CategoryChange
Override
WakeFromSleep
NoSuitableRouteForCategory
RouteConfigurationChange
com.apple.avfoundation.avvc
enable_serialization
 NOT
makeSynchronous
%04d-%02d-%02d 
%02d:%02d:%02d.%06d
Gain
Frame Qualities
StartTime
StartAnchorPoint
AVVCPluginRecordingEngine.mm
AVVCPluginRecordingEngine::startRecording
AVVCPluginRecordingEngine::stopRecording
AVVCPluginRecordingEngine::destroyRecordEngine
v32@?0@"AVAudioBuffer"8@"AVAudioTime"16@"NSDictionary"24
v20@?0I8@"NSDictionary"12
(0x0) use_count:0
(%p) streamID: %d, use_count:%ld
activation trigger
activation device uid
AlertBehavior
No Record Route
ATVRemoteInput
BluetoothDoAP
JarvisRemoteInput
ExternalDeviceInput
SetSessionActiveTime
SetSessionInactiveTime
BeginHostTime
EndHostTime
DurationMilliSeconds
undifferentiated-count
dsp-count
mic-count
speaker-ref-count
AVVoiceController.mm
v24@?0@"AVVCSessionManager"8^@16
notify server death
notify server reset
-[AVVoiceController initWithContext:error:]
-[AVVoiceController prewarmAudioSession]
finalize
-[AVVoiceController teardownWithError:]
-[AVVoiceController dealloc]
-[AVVoiceController releaseAudioSession]
-[AVVoiceController releaseAudioSession:]
-[AVVoiceController setCurrentContext:error:]
-[AVVoiceController prepareRecordWithSettings:error:]
playAlertSoundForType
-[AVVoiceController startRecording]
-[AVVoiceController startRecording:]
-[AVVoiceController startRecordingAtTime:error:]
-[AVVoiceController startRecordingWithSettings:error:]
-[AVVoiceController stopRecording]
set record delegate
setRecordEndpointMode
setRecordStartWaitTime
setRecordInterspeechWaitTime
setRecordEndWaitTime
-[AVVoiceController initVoiceControllerForClient:withError:]
-[AVVoiceController setContext:completion:]
-[AVVoiceController setContext:error:]
-[AVVoiceController setContext:streamType:error:]
-[AVVoiceController prepareRecordForStream:completion:]
-[AVVoiceController prepareRecordForStream:error:]
-[AVVoiceController startRecordWithSettings:completion:alertCompletion:audioCallback:]
-[AVVoiceController startRecordForStream:completion:]
 will skip alert
 will NOT skip alert
-[AVVoiceController startRecordForStream:error:]
-[AVVoiceController configureAlertBehaviorForStream:completion:]
-[AVVoiceController configureAlertBehaviorForStream:error:]
-[AVVoiceController stopRecordForStream:completion:]
-[AVVoiceController stopRecordForStream:error:]
-[AVVoiceController getRecordDeviceInfoForStream:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:error:]
-[AVVoiceController activateAudioSessionForStream:isPrewarm:recordMode:error:]
-[AVVoiceController deactivateAudioSessionWithOptions:]
-[AVVoiceController deactivateAudioSessionForStream:withOptions:completion:]
-[AVVoiceController deactivateAudioSessionForStream:withOptions:error:]
-[AVVoiceController setContextForStream:forStream:error:]
-[AVVoiceController playAlert:withOverride:completion:]
-[AVVoiceController playAlertSoundForType:overrideMode:]
-[AVVoiceController setDuckOthersForStream:withSettings:error:]
<fadeIn(%@), fadeOut(%@)>
<duckOthers(%@), duckToLevel(%@), isBlur(%d) mixWithOthers(%@)>
<duckOverride(%@), fadeDuration(%@)>
0x%x
 TIMEDOUT!
BlockIfAnotherAVVCIsStillAlive_v1v2
AVVC_Log.h
Output
Music Device
Music Effect
Format Converter
Effect
Mixer
Panner
Generator
Offline Effect
MIDI Processor
Apple
AVAudioUnitComponentTagsDidChangeNotification
AVAudioUnitComponentImplementation
%d.%d.%d
HasCustomView
IconURL
AudioUnitTags
com.apple.audio.ComponentTagHelper
Request
type
subtype
manufacturer
version
UserTags
com.apple.audio.units.Components
AudioUnitTypes
v20@?0I8^{__CFDictionary=}12
InitialInputs
InitialOutputs
Remote Effect
Remote Generator
Remote Instrument
Remote Music Effect
QualityDetector.cpp
SpeexEndpointer.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitTimeEffect.mm
-[AVAudioUnitTimeEffect initWithAudioComponentDescription:]
audioComponentDescription.componentType == kAudioUnitType_FormatConverter
Effects
Equalizer
Filter
Dynamics Processor
Reverb
Distortion
Delay
Time Effect
Synthesizer
Sampler
Drums
Guitar
Vocal
Bass
MIDI
Pitch
Imaging
No changes
New tags found, add it to the allTags
AVAudioUnitComponentManagerRegistrationsChangedNotification
AVVCRecordingEngine Work Queue
AVVCRecordingEngine.mm
populateRecordSettings
setRecordBufferDuration
startedRecording
doneRecording
Unknown Playback Route
getSessionProperties
getSessionProperties_HWConfig
Float32
Int16
Fixed8.24
Float64
Int32
, interleaved
, deinterleaved
%2u ch, %6.0f Hz, %s%s
%2u ch, %6.0f Hz, 'freq'
%2u ch, %6.0f Hz
%2u ch, %6.0f Hz, %s (0x%08X) 
 big-endian
 little-endian
 signed
 unsigned
integer
float
%spacked in %u bytes
 high-aligned
 low-aligned
%u.%u
%s-bit%s%s %s%s%s%s%s
from %u-bit source, 
from UNKNOWN source bit depth, 
%u frames/packet
%u bits/channel, %u bytes/packet, %u frames/packet, %u bytes/frame
ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
ret = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND)
AVFileTypeAIFF
AVFileTypeAIFC
AVFileTypeWAVE
AVFileTypeMPEG4
AVFileTypeAppleM4A
AVFileTypeCoreAudioFormat
AVFileTypeMPEGLayer3
AVFileTypeAC3
AVFileTypeSunAU
AVFileType3GPP
AVFileType3GPP2
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitGenerator.mm
-[AVAudioUnitGenerator initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Generator) || (audioComponentDescription.componentType == kAudioUnitType_RemoteGenerator)
AVVCSessionFactory.mm
AVVCSessionFactory Work Queue
AVAudioSequencerImpl.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSequencerImpl.mm
AVAudioSequencerImpl
NewMusicPlayer(&mPlayer)
NewMusicSequence(&mSequence)
MusicPlayerSetSequence(mPlayer, mSequence)
MusicSequenceSetAUGraph(mSequence, nullptr)
CurrentPosition
MusicPlayerGetTime(mPlayer, &theTime)
SetCurrentPosition
MusicPlayerSetTime(mPlayer, currentPosition)
IsPlaying
MusicPlayerIsPlaying(mPlayer, &isPlaying)
GetRate
MusicPlayerGetPlayRateScalar(mPlayer, &theRate)
SetRate
MusicPlayerSetPlayRateScalar(mPlayer, inRate)
HostTimeForBeats
MusicPlayerGetHostTimeForBeats(mPlayer, inBeats, pOutHostTime)
BeatsForHostTime
MusicPlayerGetBeatsForHostTime(mPlayer, inHostTime, pOutBeats)
NumberOfTracks
CreateTrack
MusicSequenceNewTrack(mSequence, &theTrack)
GetTrackWithIndex
MusicSequenceGetIndTrack(mSequence, inIndex, &theTrack)
GetTempoTrack
MusicSequenceGetTempoTrack(mSequence, &tempoTrack)
GetSecondsForBeats
MusicSequenceGetSecondsForBeats(mSequence, inBeats, &theSeconds)
GetBeatsForSeconds
MusicSequenceGetBeatsForSeconds(mSequence, inSeconds, &theBeats)
Reverse
MusicSequenceReverse(mSequence)
InstallUserCallback
MusicSequenceSetUserCallback(mSequence, (mUserCallbackBlock) ? UserCallback : nullptr, this)
MusicTrackImpl
MusicTrackGetProperty(inTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
SetDestinationAudioUnit
MusicTrackSetDestinationAU(mTrack, inUnit.audioUnit, &desc)
SetDestinationMIDIEndpoint
MusicTrackSetDestMIDIEndpoint(mTrack, inEndPoint)
GetDestinationMIDIEndpoint
MusicTrackGetDestMIDIEndpoint(mTrack, &endPoint)
DoSetLengthInBeats
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_TrackLength, &inLength, sizeof(inLength))
DoGetLengthInBeats
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TrackLength, &length, &pLen)
SetLengthInSeconds
MusicTrackGetSequence(mTrack, &seq)
MusicSequenceGetBeatsForSeconds(seq, inLength, &beatLength)
GetLengthInSeconds
MusicSequenceGetSecondsForBeats(seq, DoGetLengthInBeats(), &seconds)
SetOffset
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &inOffset, sizeof(inOffset))
GetOffset
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_OffsetTime, &offset, &pLen)
SetLoopCount
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, &pLen)
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_LoopRegion, &region, pLen)
GetLoopCount
SetLoopStart
GetLoopStart
SetLoopEnd
GetLoopEnd
EnableLooping
IsLoopingEnabled
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, pLen)
IsMuted
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_MuteStatus, &muteStatus, &pLen)
Solo
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, pLen)
IsSoloed
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_SoloStatus, &soloStatus, &pLen)
UseAutomatedParams
MusicTrackSetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, pLen)
UsesAutomatedParams
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_AutomatedParameters, &useAuto, &pLen)
GetTimeResolution
MusicTrackGetProperty(mTrack, kSequenceTrackProperty_TimeResolution, &timeRes, &pLen)
GetIndex
MusicTrackGetSequence(mTrack, &sequence)
MusicSequenceGetTrackIndex(sequence, mTrack, &index)
MoveEvents
MusicTrackMoveEvents(mTrack, inStartBeat, inEndBeat, inToBeat)
ClearEvents
MusicTrackClear(mTrack, inStartBeat, inEndBeat)
CutEvents
MusicTrackCut(mTrack, inStartBeat, inEndBeat)
CopyInsertEvents
MusicTrackCopyInsert(inSourceTrack, inSourceStartBeat, inSourceEndBeat, mTrack, inInsertBeat)
CopyMergeEvents
MusicTrackMerge(inSourceTrack, inSourceStartBeat, inSourceEndBeat, mTrack, inInsertBeat)
AddEvent
MusicTrackNewMIDINoteEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewMIDIChannelEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewMIDIRawDataEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewExtendedNoteEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewParameterEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewMetaEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewUserEvent(mTrack, inTimeStamp, &inEvent)
MusicTrackNewAUPresetEvent(mTrack, inTimeStamp, &inEvent)
AddExtendedTempoEvent
MusicTrackNewExtendedTempoEvent(mTrack, inTimeStamp, inTempo)
NewEventIterator
NewMusicEventIterator(mTrack, &theIterator)
Seek
MusicEventIteratorSeek(mIter, inTimeStamp)
NextEvent
result == noErr || result == kAudioToolboxErr_EndOfTrack
PreviousEvent
result == noErr || result == kAudioToolboxErr_StartOfTrack
SetEventInfo
MusicEventIteratorSetEventInfo(mIter, inEventType, inEventData)
SetEventTime
MusicEventIteratorSetEventTime(mIter, inTimeStamp)
DeleteEvent
MusicEventIteratorDeleteEvent(mIter)
HasPreviousEvent
MusicEventIteratorHasPreviousEvent(mIter, &has)
HasNextEvent
MusicEventIteratorHasNextEvent(mIter, &has)
HasCurrentEvent
MusicEventIteratorHasCurrentEvent(mIter, &has)
avas
failed call
error %d
CallbackMessenger Worker Thread
RealtimeMessenger.mServiceQueue
RealtimeMessenger.cpp
v16@?0^v8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSinkNode.mm
AVAudioSinkNodeImpl
AVAudioSinkNodeImpl::SetOutputFormat(0, format)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioNodeTap.mm
nil != _format
_initialized
AVAudioNodeTap.mm
/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox
AudioFormatGetProperty
AVVCExternalDeviceRecordingEngine
~AVVCExternalDeviceRecordingEngine
prepareRecoding
destroyRecordingEngine
setSessionIsRecordingFlag
AVVCRecordingEngineMap.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAudioEngineGraph.mm
TraverseGraphNodes
inCurrNode.GetConnection(inDirection, bus, conn)
TraverseGraphNodesBFS
connNode
connNodeFirst
connNodeSecond
TraverseGraphNodesWithLookback
inCurrNode.GetConnection(otherDirection, bus, conn)
InformNodesAboutMixerConnection
inMixerConn.destNode && inMixerConn.destNode->IsMixerNode()
InformNodesAboutMixerDisconnection
UninitializeNode
inGraph.PerformCommand(node, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
InitializeActiveNodesInOutputChain
inGraph.IsNodeInGraph(inNode.NodeImpl())
inGraph.IsValidSourceNode(*startNode)
inGraph.MakeDisconnection(mixerConn.destNode->NodeImpl(), mixerConn.destBus)
InitializeActiveNodesInInputChain
inGraph.GetInputNode() && (&inNode == inGraph.GetInputNode())
false == isInputConnToConverter
inGraph.MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
inGraph.MakeConnection(inputConn)
inGraph.PerformCommand(*inGraph.GetInputNode(), AVAudioEngineGraph::kAUSetInputCallback, &rc, sizeof(rc))
PrepareForConnection
srcNode && inGraph.IsNodeInGraph(srcNode)
destNode && inGraph.IsNodeInGraph(destNode)
srcCurrConn.destNode == NULL || srcCurrConn == inConn
destCurrConn.srcNode == NULL || destCurrConn == inConn
inGraph.PerformCommand(*destNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
PrepareForDisconnection
inGraph.IsNodeInGraph(&inDestNode)
inGraph.PerformCommand(inDestNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
AVAEGraphStateTracker.RunStateQueue
AVAudioEngineGraph.mm
outputNode != nullptr
inputNode != nullptr || outputNode != nullptr
err = PerformCommand(*outputNode, kAUInitialize, NULL, 0)
IsFormatSampleRateAndChannelCountValid(outputHWFormat)
err = _Connect(connNode->NodeImpl(), outputNode->NodeImpl(), 0, 0, format)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainOptimizedTraversal, *GetOutputNode(), isOutputChainActive)
GetOutputNode()->IsInitialized()
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *GetInputNode())
GetInputNode()->IsInitialized()
IsFormatSampleRateAndChannelCountValid(inputHWFormat)
PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
_Uninitialize
(err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0))
(err = MakeConnection(conn, outErr))
(err = PerformCommand(*GetOutputNode(), kAUUninitialize, NULL, 0))
(err = PerformCommand(*GetInputNode(), kAUUninitialize, NULL, 0))
Start
ioNode != NULL
err = PerformCommand(*ioNode, kAUStartIO, NULL, 0)
_Stop
(err = PerformCommand(*ioNode, kAUStopIO, NULL, 0))
nil != inAVNode
inImpl != nil && !IsIONode(inAVNode)
AddIONode
inImpl != nil && IsIONode(inAVNode)
NULL == ioNodeImpl && !IsNodeInGraph(inImpl)
RemoveNode
IsNodeInGraph(inImpl)
!IsRunning() && !graphNode->IsInitialized()
(graphNode->IsNodeState(kAUGraphNodeState_InInputChain) || graphNode->IsNodeState(kAUGraphNodeState_InOutputChain))
!nodeMixerConns.empty() && !hasDirectConnToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus, outErr)
err = MakeDisconnection(currSrcConn.destNode->NodeImpl(), currSrcConn.destBus, outErr)
err = PerformCommand(*graphNode, kAUUninitialize, NULL, 0)
err = DisconnectInactiveNode(graphNode, true , disjointNodes, outErr)
conn.IsSrcAndDestValid()
graphNode == conn.destNode
err = MakeConnection(conn, outErr)
err = UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
RemoveIONode
(isInputNode && graphNode == GetInputNode()) || (!isInputNode && graphNode == GetOutputNode())
!IsRunning() && !IsInitialized()
err = RemoveNode(inAVNode, outErr)
inAVNode
format.sampleRate == inputHWFormat.sampleRate
err = AUGraphParser::InitializeActiveNodesInInputChain(ThisGraph, *inputNode)
inSrcAVNode && inDestAVNode
inSrcImpl && inDestImpl
_Connect
IsNodeInGraph(inSrcImpl) && IsNodeInGraph(inDestImpl)
inSrcImpl->NumberOutputs() > 0
inDestImpl->NumberInputs() > 0 || graphNodeDest->CanResizeNumberOfInputs()
!srcNodeMixerConns.empty() && !isSrcNodeConnectedToIONode
!destNodeMixerConns.empty() && !isDestNodeConnectedToIONode
err = MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*graphNodeSrc, kAUUninitialize, NULL, 0)
err = MakeDisconnection(inDestImpl, inDestBus)
err = MakeDisconnection(graphNodeSrcCurrConnPoint.node->NodeImpl(), graphNodeSrcCurrConnPoint.bus)
[format isEqual:dstFormat]
inSrcImpl->SetOutputFormat(inSrcBus, dstFormat)
[srcFormat isEqual:format]
inDestImpl->SetInputFormat(inDestBus, srcFormat)
inSrcImpl->SetOutputFormat(inSrcBus, format) && inDestImpl->SetInputFormat(inDestBus, format)
[midiInputImpl->GetOutputFormat(0) isEqual:inSrcImpl->GetOutputFormat(0)]
err = MakeConnection(currentConn)
graphNodeDest != conn.destNode
inSrcAVNode && inDestAVConnectionPoints && inDestAVConnectionPoints.count > 0
IsNodeInGraph(inSrcImpl)
!inSrcNode->IsSplitterNode()
currentConnPoints.size() <= 1
currentConnPoints.size() > 1
avConnPoint
MakeDisconnection(conn.destNode->NodeImpl(), conn.destBus)
PerformCommand(*finalSrcNode, kAUUninitialize, NULL, 0)
_DisconnectInput(connPoint.node->NodeImpl(), connPoint.bus)
_Connect(inSrcImpl, [splitter impl], inSrcBus, kAudioUnitElement_Default, format)
RemoveNode(avNode)
PerformCommand(*finalSrcNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
[midiInputImpl->GetOutputFormat(0) isEqual:finalSrcNode->NodeImpl()->GetOutputFormat(0)]
_Connect(finalSrcNode->NodeImpl(), destImpl, srcBus, destBus, format)
UpdateGraphAfterReconfig(&disjointNodes, graphTraversalMode)
inDestAVNode
inDestImpl
_DisconnectInput
IsNodeInGraph(inDestImpl)
!IsRunning()
graphNode != conn.destNode
inSrcAVNode
inSrcImpl
_DisconnectOutput
inImpl
tmpErr = _DisconnectInput(conn.destNode->NodeImpl(), conn.destBus)
inSourceAVNode && inDestAVNodes && inDestAVNodes.count > 0
graphNodeSrc->IsMIDIProcessorNode()
destAVNode
graphNodeDest->IsMusicDevice() || graphNodeDest->IsMusicEffect() || graphNodeDest->IsMIDIProcessorNode()
inSrcImpl->SetOutputFormat(0, newFormat)
PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
err = UpdateGraphAfterReconfig(&disjointNodes, kOutputChainFullTraversal)
PerformCommand(*midiNode, kAUUninitialize, nullptr, 0)
graphNode->IsMIDIProcessorNode()
!graphNode->IsSplitterNode()
!splitterConnPoint.node->IsSplitterNode()
numSplitterConnections == 0 || numSplitterConnections > 1
!connPoint.node->IsSplitterNode()
NodeRenderingStateChanged
GetOutputDeviceLatencyForNode
GraphDescription
RenderToABL
outputNode
InputAvailable
isSink || tap != nullptr
AddPendingConnection
inConn.IsSrcAndDestValid()
RemovePendingConnection
inConn.srcNode || inConn.destNode
MakeConnection
err = MakeDisconnection(inDestImpl, inDestBus, outErr)
err = PerformCommand(*graphNodeDest, kAUMakeConnection, &connection, sizeof(connection))
err = PerformCommand(*graphNodeDest, kAUInitialize, NULL, 0)
err = PerformCommand(*graphNodeSrc, kAUInitialize, NULL, 0)
MakeVirtualConnection
IsNodeInGraph(conn.srcNode) && IsNodeInGraph(conn.destNode)
srcCurrConn.destNode == NULL || srcCurrConn == conn
destCurrConn.srcNode == NULL || destCurrConn == conn
MakeDisconnection
true == graphNodeDest->GetConnection(kUpstream, inDestBus, mixerConn)
DisconnectInactiveNode
false == inNode->IsInitialized()
err = MakeConnection(itInp->srcNode->NodeImpl(), itOut->destNode->NodeImpl(), itInp->srcBus, itOut->destBus, outErr)
UpdateGraphAfterReconfig
conn.srcNode && conn.destNode && conn.destNode->IsMixerNode()
AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, kOutputChainFullTraversal, *conn.srcNode, isChainActive)
MakeConnection(inputConn)
PerformCommand(*inputConn.srcNode, kAUInitialize, NULL, 0)
PerformCommand(*inputConn.destNode, kAUInitialize, NULL, 0)
MakeConnection(conn)
err = AUGraphParser::InitializeActiveNodesInOutputChain(ThisGraph, inTraversalMode, *GetOutputNode(), isChainActive)
LastRenderErrorInChain
startNode
(bus%d) %p, {%s} -> 
(bus%d) %p, {%s}
________ %s ________
AVAudioEngineGraph %p: initialized = %d, running = %d, number of nodes = %d
 ******** output chain ********
 ******** input chain ********
 ******** pending connections - output ********
 %s, [%s]
 ******** pending connections - input ********
 ******** other nodes ********
______________________________________
err = MusicSequenceSetAudioGraph(inSequence, _seqGraphImpl)
NodeStateChanged
GetMusicDeviceNode()
RegisterRenderCallback
UnregisterRenderCallback
GetDefaultMusicDevice
outUnit || outDesc
GetOutputAudioUnit
false condition
operator()
inGraph.PerformCommand(theNode, AVAudioEngineGraph::kAUSetPropertyMaximumFramesPerSlice, &maxFrames, sizeof(maxFrames))
v16@?0@?<v@?>8
realloc failed
GetNumberBuffers
CoreAudioBaseTypes.hpp
GetAudioBufferList().mNumberBuffers == (mStorage.size() - kHeaderSize) / sizeof(AudioBuffer)
inGraph.PerformCommand(midiNode, AVAudioEngineGraph::kAUUninitialize, NULL, 0)
conn.destNode && conn.destNode->IsMixerNode()
0 == inCurrNode.NumberOfValidConnections(kUpstream)
inNodeUpstream.IsInitialized()
inGraph.MakeDisconnection(inPrevConn->destNode->NodeImpl(), inPrevConn->destBus)
err = PerformCommand(midiInput, kAUInitialize, nullptr, 0)
v16@?0@"NSNotification"8
AVAudioEnvironmentNodeImpl.mm
name
identifier
primaryLanguages
supportedLanguages
voiceSize
gender
voice
ssmlRepresentation
avat
com.apple.avfaudio.devicetest.service
AVAudioDeviceTest.mm
v24@?0@"NSArray"8@"NSError"16
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioConverter.mm
convert
outputBuffer.frameCapacity >= inputBuffer.frameLength
FillComplexProc
impl->_inputBufferReceived
[impl->_inputBufferReceived.format isEqual: impl->_inputFormat]
ioData->mNumberBuffers == abl->mNumberBuffers
AVVCMM
AVVCMetricsManager.mm
profile_avvc
yyyy-MM-dd'T'HH:mm:ss.SSSSSSSZZZZZ
configure
ControllerImplV1.mm
getCurrentRecordDeviceInfo_v1
getCurrentRecordSettings_v1
enableMetering_v1
updateMeters_v1
getPeakPowerForChannel_v1
getAveragePowerForChannel_v1
isMeteringEnabled_v1
resetEndpointDetector
prepareRecord
prepareRecord_v1
startRecord
startRecord_v1
secondPassCompletionHostTime
setupAudioCaptureFile_v1
getRecordQueueFormat
getRecordBufferDuration_v1
setRecordBufferDuration_v1
getStartRecordTime_v1
setStartRecordTime_v1
configureAlertOverrides_v1
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.mm
AUGraphNodeBase
nil != _avNode
nullptr != _avNodeImpl
ConnectInput
nullptr != srcNode
AddNode
inNode != nil
DisconnectNode
CreateRecordingTap
nil != callbackBlock
nullptr == Tap()
NodeImpl()->SetOutputFormat(bus, format)
 node %p {%s}, '%s'
 inputs = %d
 (bus%d, en%d) <- (bus%d) %p, {%s}, [%s]
 outputs = %d
 (bus%d, en%d) -> (bus%d) %p, {%s}, [%s]
AUGraphNodeBaseV3
RenderBlock()
i44@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36
CreateMIDIConnection
midiSrc != nullptr
DestroyMIDIConnection
midiSrc == MIDIInput()
DeallocateInputBlock
false == AUI().IsRunning()
AllocateInputHandler
v36@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28
AUGraphMIDINodeV3
IsMIDIProcessorNode()
SetTapBlock
GetTapBlock()
SetTapBlockEventList
GetTapBlockEventList()
AUI().GetHostMIDIProtocol() > 0
i28@?0q8C16r^{MIDIEventList=iI[1{MIDIEventPacket=QI[64I]}]}20
AUGraphSourceNodeV3
NodeImpl()->IsAVAudioSourceNode()
InputBlock()
AUGraphSinkNodeV3
NodeImpl()->IsSinkNode()
AllocateRenderBlock
receiverBlock
i52@?0^I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16I24q28^{AudioBufferList=I[1{AudioBuffer=II^v}]}36@?<i@?^I^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}Iq^{AudioBufferList=I[1{AudioBuffer=II^v}]}>44
AVAEGraphNode.mm
AUGraphMultiBusNode
IsMixerNode() || IsSplitterNode()
GetConnection
nodeBussesVec.size() >= (inBus + 1)
GetConnectionPoint
GetBusForConnectionPoint
nodeBussesVec.size() == nodeVec.size()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAEGraph/AVAEGraphNode.h
InputMutex
bus < _inMutexes.size()
Drums - Bit Brush
Drums - Buffer Beats
Drums - Lo-Fi
Multi - Broken Speaker
Multi - Cellphone Concert
Multi - Decimated 1
Multi - Decimated 2
Multi - Decimated 3
Multi - Decimated 4
Multi - Distorted Funk
Multi - Distorted Cubed
Multi - Distorted Squared
Multi - Echo 1
Multi - Echo 2
Multi - Echo Tight 1
Multi - Echo Tight 2
Multi - Everything is Broken
Speech - Alien Chatter
Speech - Cosmic Interference
Speech - Golden Pi
Speech - Radio Tower
Speech - Waves
ControllerImplV2.mm
v28@?0Q8B16@"NSError"20
prepareRecordForStream_v2
startRecordForStream_v2
stopRecordForStream_v2
getCurrentStreamStateForStream_v2
v32@?0Q8d16@"NSError"24
getRecordBufferDurationForStream_v2
configureAlertBehaviorForStream_v2
getSessionState_v2
activateAudioSessionForStream_v2
setContextForStream_v2
v28@?0i8q12@"NSError"20
playAlertWithOverride_v2
v32@?0Q8@"AVVCRecordDeviceInfo"16@"NSError"24
getRecordDeviceInfoForStream_v2
v32@?0Q8@"NSDictionary"16@"NSError"24
getRecordSettingsForStream_v2
isMeteringEnabledForStream_v2
updateMeterLevelForStream_v2
v28@?0Q8f16@"NSError"20
getPeakPowerForStreamAndChannel_v2
getAveragePowerForStreamAndChannel_v2
setAnnounceCallsEnabledForStream
setDuckOthersForStream_v2
isDuckingSupportedOnPickedRouteForStream_v2
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioClock.mm
AVAudioClockImpl
_nodeImpl->AUI().AddV2PropertyListener(kAudioUnitProperty_StreamFormat, StreamFormatListener, this)
AVMIDIPlayer.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVMIDIPlayer/AVMIDIPlayer.mm
-[AVMIDIPlayer prepareToPlay]
MusicPlayerPreroll(impl->mPlayer)
-[AVMIDIPlayer isPlaying]
MusicPlayerIsPlaying(impl->mPlayer, &playing)
-[AVMIDIPlayer rate]
MusicPlayerGetPlayRateScalar(impl->mPlayer, &scalar)
-[AVMIDIPlayer setRate:]
MusicPlayerSetPlayRateScalar(impl->mPlayer, rate)
-[AVMIDIPlayer duration]
MusicSequenceGetSecondsForBeats(impl->mSequence, impl->mLength, &durInSeconds)
-[AVMIDIPlayer currentPosition]
MusicPlayerGetTime(impl->mPlayer, &positionInBeats)
MusicSequenceGetSecondsForBeats(impl->mSequence, positionInBeats, &positionInTime)
-[AVMIDIPlayer setCurrentPosition:]
MusicSequenceGetBeatsForSeconds(impl->mSequence, (Float64) currentPosition, &positionInBeats)
MusicPlayerSetTime(impl->mPlayer, positionInBeats)
avmp
CallbackQueue
start
MusicPlayerStart(mPlayer)
stop
MusicPlayerStop(mPlayer)
finishLoad
MusicSequenceGetAUGraph(mSequence, &graph)
MusicSequenceGetTrackCount(mSequence, &trackCount)
MusicTrackGetProperty(track, kSequenceTrackProperty_TrackLength, &length, &plength)
MusicSequenceSetUserCallback(mSequence, userCallback, this)
SetUpGraph
AUGraphOpen(inGraph)
AUGraphGetNodeCount (inGraph, &nodeCount)
AUGraphGetIndNode(inGraph, i, &node)
AUGraphNodeInfo(inGraph, node, &desc, &unit)
AudioUnitSetProperty (unit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &numFrames, sizeof(numFrames))
AUGraphInitialize(inGraph)
AVVCTestDevice
AVVCRouteManager.mm
Error! No Remote Device Found
Error! No RemoteInputDeviceName property
No Playback Route
/9luHerXthRoPoNt/PVkTg
AVAudioUnitMIDIInstrument.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitMIDIInstrument.mm
SendProgramChange
true == SendMIDIEvent(kMIDIMessage_ControlChange, 0, bankMSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_ControlChange, bankSelectLSBParam1, bankLSB, 0, channel)
true == SendMIDIEvent(kMIDIMessage_PatchChange, programID, 0, 0, channel)
-[AVAudioUnitMIDIInstrument initWithAudioComponentDescription:]
(description.componentType == kAudioUnitType_MusicDevice) || (description.componentType == kAudioUnitType_RemoteInstrument)
-[AVAudioUnitMIDIInstrument startNote:withVelocity:onChannel:]
_IMPL->StartNote(note, velocity, channel)
-[AVAudioUnitMIDIInstrument stopNote:onChannel:]
_IMPL->StopNote(note, channel)
-[AVAudioUnitMIDIInstrument sendController:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ControlChange, controller, controllerValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendPitchBend:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PitchBend, value&0x7F, value>>7, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressure:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_ChannelPressure, pressureValue, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendPressureForKey:withValue:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_KeyPressure, key, pressureValue, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:onChannel:]
_IMPL->SendMIDIEvent(kMIDIMessage_PatchChange, program, 0, 0, channel)
-[AVAudioUnitMIDIInstrument sendProgramChange:bankMSB:bankLSB:onChannel:]
_IMPL->SendProgramChange(program, bankMSB, bankLSB, channel)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:data2:]
_IMPL->SendMIDIEvent(midiStatus, data1, data2, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDIEvent:data1:]
_IMPL->SendMIDIEvent(midiStatus, data1, 0, 0, 0)
-[AVAudioUnitMIDIInstrument sendMIDISysExEvent:]
_IMPL->SendMIDISysexEvent((CFDataRef)midiData)
-[AVAudioUnitMIDIInstrument sendMIDIEventList:]
_IMPL->SendMIDIEventList(eventList, 0, 0)
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVFAudioCore/AVAudioBuffer.mm
-[AVAudioBuffer initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:]
isPCMFormat(fmt)
bufferList != nullptr
bufferList->mNumberBuffers == numBuffers
-[AVAudioBuffer setByteLength:]
length <= _imp->_byteCapacity
<%@@%p: %d/%d bytes>
-[AVAudioPCMBuffer initWithPCMFormat:frameCapacity:]
AVAudioBuffer.mm
_imp->OwnsMemory() && !_imp->_externalABL.has_value()
-[AVAudioPCMBuffer initWithPCMFormat:bufferListNoCopy:deallocator:]
!_imp->OwnsMemory() && _imp->_externalABL.has_value()
-[AVAudioPCMBuffer setFrameLength:]
length <= _imp->_frameCapacity
-[AVAudioCompressedBuffer initWithFormat:packetCapacity:maximumPacketSize:]
!(fmt.IsLinearPCM() || fmt.mFormatID == kAudioFormatALaw || fmt.mFormatID == kAudioFormatULaw)
maximumPacketSize != 0
-[AVAudioCompressedBuffer setPacketCount:]
length <= _imp->_packetCapacity
ExtendedAudioBufferList_CreateWithFormat failed
ExtendedAudioBufferList_Prepare failed
AVAB
cannot convert to CMAudioFormatDescription %d
<AVAudioFormat %p: %s>
mSampleRate
mFormatID
mFormatFlags
mBytesPerPacket
mFramesPerPacket
mBytesPerFrame
mChannelsPerFrame
mBitsPerChannel
channelLayout
magicCookie
Audio files cannot be non-interleaved. Ignoring setting AVLinearPCMIsNonInterleaved YES.
AVAudioSession
data
outputID
inputID
sampleRate
correlationValue
stimulusURL
outputMode
volume
inputProcessingChain
outputProcessingChain
mode
calculateCrossCorrelationPeak
processSequenceAsynchronously
parallelCrossCorrelationCalculation
numberOfChannels
micBufferNumbers
requiresBluetoothOutput
graphURL
processingStripURL
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSourceNode.mm
AVAudioSourceNodeImpl
SetInputFormat(0, format)
AVVoiceController_RecordQueue
/System/Library/Audio/Tunings/<UPPERCASE_MODEL>/AVVC/<LOWERCASE_MODEL>_mic_voice_recognition.dspg
/System/Library/Audio/Tunings/<UPPERCASE_MODEL>/AVVC/<LOWERCASE_MODEL>_mic_voice_recognition.austrip
/System/Library/Audio/Tunings/<UPPERCASE_MODEL>/AVVC/<LOWERCASE_MODEL>_mic_voice_recognition.propstrip
<UPPERCASE_MODEL>
<LOWERCASE_MODEL>
AVVCAudioQueueRecordingEngine
~AVVCAudioQueueRecordingEngine
AVVCAudioQueueRecordingEngine.mm
AudioQueueRecordPropertyListenerProc
Initialize
createRecordQueue
With
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}12@?0I8
prepareRecording
startRecording
startRecording:AudioQueueReset
future
past
immediate
startRecording : AudioQueueStart
stopRecording
mRecordQueue : AudioQueueStop
destroyRecordEngine
queue : AudioQueueStop
destroyRecordEngine: AudioQueueDispose
enableSiriListeningMode
enableMetering
DeinterleaveAudio
handleRecordQueuePropertyListener
Capture
Capture-DSPOut
resetAudioEngine
resetAudioEngine:mRecordQueue: AudioQueueReset
com.apple.speech.synthesis.voice.Alex
AVSpeechSynthesisIPANotationAttribute
/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle
language
quality
speechString
rate
pitchMultiplier
preUtteranceDelay
postUtteranceDelay
attributedSpeechString
mark
byteSampleOffset
textRange
IPHONE_SIMULATOR_ROOT
CFFIXED_USER_HOME
AVVoiceController_AlertQueue
/System/Library/Audio/UISounds/jbl_begin.caf
/System/Library/Audio/UISounds/jbl_confirm.caf
/System/Library/Audio/UISounds/jbl_cancel.caf
setDuckOthersOption
ControllerImplV1V2.mm
setSessionProperties
AVVC Rec Queue RunLoop
DispatchQueue
SIMULATOR_ROOT
%s%@
Alert
Record
Playback
Session
duck_others
AVVC Client Notification Queue
AVVC ControllerImpl Work Queue
~ControllerImpl
setActivationModeAndSessionHWControlFlagsAndOptions_v1v2
deactivateSessionForListening
unconfigured
beginAudioSessionActivate_v1v2
deactivateSessionForListening_v1v2_block_invoke
deactivateSessionForListening:AudioQueueReset
deactivateSessionForListening1
deactivateSessionForListening2
v16@?0@"NSObject<OS_dispatch_semaphore>"8
deactivateSessionForListening_v1v2
createRecordingEngine_v1v2
configureAlerts
configureAlerts_v1v2
cleanup
v20@?0@"NSString"8i16
getPlaybackRoute_v1v2
v28@?0@"NSString"8@"NSString"16i24
getRecordAndPlaybackRoutes_v1v2
setActivationContext_v1v2
checkSession
checkSession_v1
AVVCEngine-prepareRecording from checkSession
deactivateSession_v1v2
AVAudioSessionDeactivate
endAudioSessionActivate_v1v2
setSessionActive_v1v2
setSessionActive
setSessionActive1
setSessionActive2
set endpointer delegate
endpointer reset
internal Speex
external
setupEndpointer_v1v2
setup endpointer
v12@?0i8
setRecordErrorStatus_v1v2
calculateRecordStartTime_v1v2
configureAlertModeFromModeAndEngine
handsFree
built-in speaker
Auto
Post-Voice
iMessageGestureToHead
Dictation
Wired/BT ButtonPress
configureAlertModeFromModeAndEngine_v1v2
stopRecord
stopRecord_v1v2
getRecordElapsedTime_v1v2
setAlertURL
playAlert
playAlert_v1v2
createAlertQueue
primeAlertQueue
primeAlertQueue_v1v2
AudioQueueReset : mAlertQueue
setupAlert
setupAlert_v1v2
startAlertQueue
startAlertQueue_v1v2
mAlertQueue : AudioQueueStart
 but failed
mAlertQueue : AudioQueueStop
destroyAlertQueue
destroyAlertQueue_v1v2
destroyAlertQueue : AudioQueueStop
calculateAlertTimes_v1v2
alertStarted
alertStarted_v1v2
alertFinished
notifyAlertFinished_v1v2
AlertAQPropertyListenerProc
handleAlertAQPropertyChange
vibeStartAlertFinished
vibeStartAlertFinished_v1v2
vibeStopAlertFinished
vibeStopAlertFinished_v1v2
VibeAlertCompletionProc
haptic alertPlaybackFinishedOfType_v1v2
startpointDetected
interspeechPointDetected
endpointDetected
startKeepAliveQueue
stopKeepAliveQueue
primary
handleInterruptStart_v1v2
beginRecordInterruptionWithContext
handleInterruptStop_v1v2
endRecordInterruption
handleRouteChange_v1v2
interrupted
not (yet) active
handleServerDeath_v1v2
handleServerReset_v1v2
RegisterAudioUnits_Internal
getCurrentRecordingEngineStreamState_v1v2
getCurrentRecordEngineType_v1v2
v24@?0{shared_ptr<AVVCRecordingEngine>=^{AVVCRecordingEngine}^{__shared_weak_count}}8
v32@?0Q8q16@"NSError"24
setContext_v1v2
v32@?0Q8@"AVVCAudioBuffer"16B24B28
beganRecording
v36@?0Q8B16q20@"NSError"28
finishedRecording
encodeError
v20@?0Q8I16
B28@?0^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}8^f16I24
i12@?0B8
streamInvalidated
v16@?0Q8
hardwareConfigChanged
beginAudioSessionActivate
v12@?0B8
endAudioSessionActivate
fault_on_streamID_violation
_getCurrentRecordingEngine_v1v2
notifyStreamInvalidated_v1v2
ControllerImpl.h
ExternalDevice
AudioQueue
Plugin
Invalid
Uninitialized
Prepared
Stopped
Starting
Running
Stopping
stopped
starting
active
stopping
Silent
Haptic
Beep
No Override
Mute
uninit
primed
started
running
inactive
getAlertQueueFromRunLoop
implSP->getAudioQueueRunLoop()->IsCurrentThread() && "This code must run only on the AQ runloop thread"
Illegal
'Unknown'
'Override'
'Wake From Sleep'
'No Suitable Route for Category'
'Configuration Change'
avvc
debug_level
AVVC_Log.cpp
debug_encoding
debug_endpoint
debug_callbacks
debug_locking
debug_state
debug_trace
debug_timing
debug_delegate
debug_playback
debug_deviceselect
/System/Library/Frameworks/CoreMedia.framework/CoreMedia
CMAudioFormatDescriptionGetStreamBasicDescription
CMAudioFormatDescriptionCreate
CMAudioFormatDescriptionGetChannelLayout
CMAudioFormatDescriptionGetMagicCookie
VirtualAudio
siri_ducking_for_speaker
BTDetails_SupportsDoAP
BTDetails_SupportsSoftwareVolume
SoftwareVolumeEnabled
AVVCSessionManager.mm
setupOneTimeSessionSettingsForClient
-[AVVCSessionManager setupOneTimeSessionSettingsForClient:]
setSessionActivationContext
-[AVVCSessionManager setSessionActivationContext:]
-[AVVCSessionManager shouldEnableMiniDucking:withOptions:]
shouldEnableMiniDucking
-[AVVCSessionManager getHypotheticalRouteAndUpdateStates]
getHypotheticalRouteAndUpdateStates
setSessionCategoryModeOptionsForActivationMode
-[AVVCSessionManager setSessionCategoryModeOptionsForActivationMode:withOptions:]
setSessionCategoryModeOptionsFromActivationMode
setSessionAudioHWControlFlagsForActivationMode
-[AVVCSessionManager setSessionAudioHWControlFlagsForActivationMode:withOptions:]
setSessionAudioHWControlFlagsFromActivationMode
setSessionSampleRateForActivationMode
-[AVVCSessionManager setSessionSampleRateForActivationMode:]
setSessionSampleRateFromActivationMode
setSessionBufferSize
-[AVVCSessionManager setSessionBufferSize:]
-[AVVCSessionManager setDuckOthers:mixWithOthers:error:]
setDuckOthersMixWithOthers
setDuckOthers:mixWithOthers
-[AVVCSessionManager setDuckingFadeOutDuration:fadeInDuration:error:]
setDuckingFadeDuration
-[AVVCSessionManager isSessionOutputInWirelessSplitterMode]
isSessionOutputInWirelessSplitterMode
enableSmartRoutingConsideration
-[AVVCSessionManager enableSmartRoutingConsideration:]
activateAudioSessionWithPrewarm
prewarmAudioSession
activateAudioSession
-[AVVCSessionManager activateAudioSessionWithPrewarm:error:]
AVAudioSessionSetActive
B8@?0
deactivateAudioSessionWithOptions
setEnableBTTriangleMode
inputLatency
outputLatency
speechDetectionDeviceSampleRate
setCategory:mode:options
setCategory:mode:routeSharingPolicy:options
clearInputPreferences
isSessionInSiriCategory
setAudioHardwareControlFlags
-[AVVCSessionManager reporterID]
reporterID
setIAmTheAssistant
setPreferredSampleRate:error
siriInputSource
setActivationContext
setActive
getOpaqueSessionID
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
setRecordingFromRemoteInput
inputNumberOfChannels
setDuckToLevelDB
setDuckToLevelScalar
isSWVolumeSupportedOnPickedRoute
ILLEGAL
NotConfigured
Inactive
InteruptedWhileRecording
InteruptedWhilePlaying
Prewarming
Activating
Deactivating
Active
dump_input
AVVCAudioCapturer.mm
/tmp/Assistant/AVVCCapture/
/usr/local/lib/libAudioDiagnostics.dylib
NewAudioCapturerImpl
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioFile.mm
-[AVAudioFile writeFromBuffer:error:]
buffer != nil
_imp->CheckClientFormatSet()
ExtAudioFileWrite(_imp->_extAudioFile, buffer.frameLength, buffer.audioBufferList)
-[AVAudioFile readIntoBuffer:frameCount:error:]
frames <= buffer.frameCapacity
buffer.frameCapacity != 0
ExtAudioFileRead(_imp->_extAudioFile, &ioFrames, buffer.mutableAudioBufferList)
-[AVAudioFile length]
ExtAudioFileGetProperty(_imp->_extAudioFile, kExtAudioFileProperty_FileLengthFrames, &propSize, &length)
-[AVAudioFile framePosition]
ExtAudioFileTell(_imp->_extAudioFile, &pos)
-[AVAudioFile setFramePosition:]
ExtAudioFileSeek(_imp->_extAudioFile, pos)
AVAudioFileImpl
fileURL != nil
ExtAudioFileOpenURL((CFURLRef)fileURL, &_extAudioFile)
_initCommonReading
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_FileDataFormat, &propSize, &fileASBD)
SetFormats(format, interleaved, fileASBD, avacl)
ReadMagicCookie
_fileFormat
_processingFormat
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &fileID)
ExtAudioFileCreateWithURL((CFURLRef)fileURL, fileType, &fileASBD, NULL, kAudioFileFlags_EraseFile, &_extAudioFile)
AudioConverterSetProperty(converter, kAudioCodecPropertyBitRateControlMode, sizeof(UInt32), &value)
GetAudioConverter
ExtAudioFileGetProperty(_extAudioFile, kExtAudioFileProperty_AudioConverter, &size, &converter)
setVBRQuality
AudioConverterSetProperty(converter, kAudioCodecPropertySoundQualityForVBR, sizeof(UInt32), &audioQuality)
setBitRate
AudioConverterSetProperty(converter, kAudioConverterEncodeBitRate, sizeof(UInt32), &bitRate)
AudioConverterSetProperty(converter, kAudioConverterEncodeBitRate, sizeof(UInt32), &bitRatePerChannel)
ExtAudioFileGetProperty(openFileImpl->_extAudioFile, kExtAudioFileProperty_AudioFile, &propSize, &openAudioFileID)
ExtAudioFileWrapAudioFileID(openAudioFileID, false, &_extAudioFile)
CheckClientFormatSet()
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioNode.mm
-[AVAudioNode installTapOnBus:bufferSize:format:block:]
tapBlock
NULL != engine
-[AVAudioNode removeTapOnBus:]
-[AVAudioNode destinationForMixer:bus:]
mixer
-[AVAudioMixingDestination destinationForMixer:bus:]
GetMixingDestination
inMixerAVNode
WillDisconnectFromMixer
mixingDest
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioNodeImpl.h
AVAE_CheckNodeHasEngine
_engine != nil
aupreset
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitSampler.mm
-[AVAudioUnitSampler loadInstrumentAtURL:error:]
error
-[AVAudioUnitSampler loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:]
-[AVAudioUnitSampler loadAudioFilesAtURLs:error:]
AVAudioIOUnit
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioIONodeImpl.mm
AUI().AddV2PropertyListener(propID, IOUnitPropertyListener, this)
_GetHWFormat
hwFormat
SetOutputFormat
_isInput
IsFormatSampleRateAndChannelCountValid(format)
IsFormatSampleRateAndChannelCountValid(hwFormat)
format.sampleRate == hwFormat.sampleRate
SetInputFormat
!_isInput
Audio/Plug-Ins/RemoteInput/
AVVCPluginRemoteInputHost.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioSequencer.mm
-[AVAudioSequencer(AVAudioSequencer_Player) prepareToPlay]
impl->PrepareToPlay()
-[AVAudioSequencer(AVAudioSequencer_Player) startAndReturnError:]
impl->Start()
-[AVAudioSequencer(AVAudioSequencer_Player) stop]
impl->Stop()
-[AVAudioSequencer loadFromURL:options:error:]
impl->LoadFromFile((__bridge CFURLRef)fileURL, (UInt32)options)
-[AVAudioSequencer loadFromData:options:error:]
impl->LoadFromData((__bridge CFDataRef)data, (UInt32)options)
-[AVAudioSequencer writeToURL:SMPTEResolution:replaceExisting:error:]
impl->WriteToFile((__bridge CFURLRef)fileURL, (SInt32)resolution, replace)
-[AVAudioSequencer dataWithSMPTEResolution:error:]
impl->WriteToData(&outData, (SInt32)SMPTEResolution)
-[AVMusicTrack setNumberOfLoops:]
numberOfLoops != 0
AVMusicEvent was not of any known class
AVAudioSequencer.mm
Should never get a NULL event type
album
approximate duration in seconds
artist
channel layout
comments
composer
copyright
encoding application
genre
ISRC
key signature
lyricist
nominal bit rate
recorded date
source bit depth
source encoder
subtitle
tempo
time signature
title
track number
year
%.6f s
%ld fr (/%.f Hz)
%.6f rs
<AVAudioTime %p: %s %s %s>
/System/Library/Frameworks/AudioToolbox.framework/libAudioDSP.dylib
GetAudioDSPManager
AVAudioUnitDSPGraph.mm
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioUnitEffect.mm
-[AVAudioUnitEffect initWithAudioComponentDescription:]
(audioComponentDescription.componentType == kAudioUnitType_Effect) || (audioComponentDescription.componentType == kAudioUnitType_MusicEffect) || (audioComponentDescription.componentType == kAudioUnitType_Panner) || (audioComponentDescription.componentType == kAudioUnitType_RemoteEffect) || (audioComponentDescription.componentType == kAudioUnitType_RemoteMusicEffect)
v16@?0q8
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioPlayerNode.mm
-[AVAudioPlayerNode scheduleBuffer:atTime:options:completionCallbackType:completionHandler:]
when == nil || when.sampleTimeValid || when.hostTimeValid
-[AVAudioPlayerNode scheduleFile:atTime:completionCallbackType:completionHandler:]
file != nil
-[AVAudioPlayerNode scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:]
stream != nil
startFrame >= 0
numberFrames > 0
-[AVAudioPlayerNode nodeTimeForPlayerTime:]
playerTime == nil || playerTime.sampleTimeValid || playerTime.hostTimeValid
-[AVAudioPlayerNode playerTimeForNodeTime:]
nodeTime == nil || nodeTime.sampleTimeValid || nodeTime.hostTimeValid
AVAudioPlayerNodeImpl.CompletionHandlerQueue
CommandQueue
v8@?0
StartImpl
AVAudioPlayerNode.mm
_engine->IsRunning()
player started when in a disconnected state
player did not see an IO cycle.
nearFutureTime.sampleTimeValid
when.hostTimeValid
inTimeFull.sampleTimeValid
avpln
avpln_verbose
ScheduleBuffer
_outputFormat.channelCount == buffer.format.channelCount
HandleCompletionOfCommand
completionHandler != nil
bufferFromFileInfo.has_value()
CallCompletionHandler
completionHandler
SignalEndOfRender
completionHandlerWrapperPtr && completionHandlerWrapperPtr->Block()
ResolveToPlayerSampleTime
playerTime && playerTime.sampleTimeValid
has_borealis_xpc
AVVoiceTriggerClient init
AVVoiceTriggerClient.mm
dealloc
handleMediaServerReset:
voiceTriggerPastDataFramesAvailableCompletion
getInputChannelInfoCompletion
voiceTriggerPastDataFramesAvailable
v24@?0Q8@"NSError"16
enableVoiceTriggerListening:
v16@?0@"NSError"8
enableVoiceTriggerListening:completionBlock:
Enable
Disable
enableSpeakerStateListening:completionBlock:
speakerStateActiveCompletionBlock:
speakerStateActive
v20@?0B8@"NSError"12
speakerStateMutedCompletionBlock:
speakerStateMuted
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:completionBlock:
listeningEnabledCompletionBlock:
siriClientRunningCountCompletionBlock:
com.apple.coreaudio.avfaudio.workloop(
%s %s %s
v20@?0^{OpaqueAudioComponentInstance=}8i16
AVAudioEngineConfigurationChangeNotification
com.apple.avfaudio
avae
avae_verbose
AVAudioEngine.mm
engine
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AVAudioEngine.mm
AttachNode
node != nil
!IsInternalNode(node)
nil == owningEngine || GetEngine() == owningEngine
nodeimpl->HasEngineImpl()
DetachNode
!nodeimpl->HasEngineImpl()
GetIOUnit
!IsInManualRenderingMode()
GetOutputNode
_outputNode != nil
GetInputNode
_inputNode != nil
UpdateOutputNode
[_outputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_outputNode)
UpdateInputNode
[_inputNode enableManualRenderingMode:GetManualRenderingMode() isInput:isInputNode]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:isInputNode forceIOUnitReset:false]
AreRenderingModesIdentical(_inputNode)
UpdateIONodesForVP
[_outputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:false forceIOUnitReset:true]
[_inputNode enableRealtimeRenderingModeWithIOUnit:ioUnit isInput:true forceIOUnitReset:true]
Connect
node1 != nil && node2 != nil
node1 != node2
[_nodes containsObject: node1] && [_nodes containsObject: node2]
ConnectMultipleOutputs
nil != sourceNode && nil != destNodes && [destNodes count] > 0
[_nodes containsObject: sourceNode]
object && [object isKindOfClass: [AVAudioConnectionPoint class]]
[_nodes containsObject: connPoint.node]
sourceNode != connPoint.node
DisconnectInput
[_nodes containsObject: node]
_graph->DisconnectInput(node, bus)
DisconnectOutput
_graph->DisconnectOutput(node, bus)
DisconnectAllInputs
_graph->DisconnectAllInputs(node)
DisconnectAllOutputs
_graph->DisconnectAllOutputs(node)
ConnectMIDI
node1 != nil && node2 != nil && node1 != node2
object && [object isKindOfClass: [AVAudioNode class]]
DisconnectMIDI
sourceNode != nil && destNode != nil
sourceNode != nil && destNodes != nil && destNodes.count > 0
_graph->DisconnectMIDI(sourceNode, destNodes)
DisconnectAllMIDIInputs
DisconnectAllMIDIOutputs
GetInputConnectionPointForNode
node != nil && [_nodes containsObject: node]
GetOutputConnectionPointsForNode
Uninitialize
_graph->Uninitialize(outErr)
Pause
_graph->Stop(outErr)
CheckCanPerformIO
canPerformIO
q28@?0I8^{AudioBufferList=I[1{AudioBuffer=II^v}]}12^i20
CreateGraphNode
_graph->AddNode(inNode)
DestroyGraphNode
_graph->RemoveNode(inNode, outErr)
InstallTapOnNode
_graph->InstallTapOnNode(inNode, bus, bufferSize, format, tapBlock)
RemoveTapOnNode
_graph->RemoveTapOnNode(inNode, bus)
SetSequence
_graph->SetSequence(inSequence)
 node: 
 (bus: 
AVFormatIDKey
AVSampleRateKey
AVNumberOfChannelsKey
AVLinearPCMBitDepthKey
AVLinearPCMIsBigEndianKey
AVLinearPCMIsFloatKey
AVLinearPCMIsNonInterleaved
AVAudioFileTypeKey
AVEncoderQualityKey
AVEncoderQualityForVBRKey
AVEncoderBitRateStrategyKey
AVEncoderBitRateKey
AVEncoderBitRatePerChannelKey
AVEncoderBitDepthHintKey
AVSampleRateConverterAlgorithmKey
AVSampleRateConverterQualityKey
AVChannelLayoutKey
AVAudioBitRateStrategy_Constant
AVAudioBitRateStrategy_LongTermAverage
AVAudioBitRateStrategy_VariableConstrained
AVAudioBitRateStrategy_Variable
AVSampleRateConverterAlgorithm_Normal
AVSampleRateConverterAlgorithm_Mastering
AVSampleRateConverterAlgorithm_MinimumPhase
/Library/Caches/com.apple.xbs/Sources/AVFAudio_Sim/Source/AVFAudio/AVAudioEngine/AUInterface.mm
AddRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &inRenderCallback, sizeof(inRenderCallback))
RemoveRenderCallback
SetV2Property(kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, element, &rcb, sizeof(rcb))
AUInterfaceBaseV3
comp != nullptr
AudioComponentInstanceNew(comp, &_auv2)
_auv2 != nullptr
_auv3 == nil
_auv3 != nil
nil != midiEventBlock
nil != midiEventListBlock
SetFormat
[[busArray objectAtIndexedSubscript:(NSUInteger)element] setFormat:format error:&nsErr]
SetNumberInputs
[[auv3() inputBusses] setBusCount:(NSUInteger)numberInputs error:&nsErr]
SetNumberOutputs
[[auv3() outputBusses] setBusCount:(NSUInteger)numberOutputs error:&nsErr]
SendMIDIEvent
nil != ScheduleMIDIEventBlock()
nullptr != midiBytes
SendMIDIEventList
nil != ScheduleMIDIEventListBlock()
nullptr != eventList
AddRenderObserver
inRenderCallback.inputProc
v32@?0I8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}12I20q24
AVAEInternal.h
true
false
%s: returned %s, error %@
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
%25s:%-5d CarPlay API not available
%25s:%-5d AVOutputContext API not available
%25s:%-5d supportsMultipleBTDevices: %d
%25s:%-5d Wireless Output Devices: %@
%25s:%-5d AVOutputDevice %p supports BT sharing: %d
%25s:%-5d RegisterObject: registering %p
%25s:%-5d UnregisterObject: unregistering %p
 ASSERTION FAILED: unregistering a nonexistent object!
%25s:%-5d Acoustic ID returned %d. Lets try the older method to load DSP graph
%25s:%-5d Unexpected product 0x%x will not load DSP graph
%25s:%-5d Product 0x%x, numChannels unchanged at: %u
%25s:%-5d CurrentRoute: %@
%25s:%-5d PreviousRoute: %@
%25s:%-5d RouteChangeReason: %s
%25s:%-5d AVVC Serialization is%s enabled
%25s:%-5d runloop block timeout!
%25s:%-5d waiting for any in-flight AudioQueue property change message on run loop...
%25s:%-5d CallbackBarrier: 9 second timeout!
%25s:%-5d received all AudioQueue property change messages on run loop.
%25s:%-5d API timeout
%s API timeout. Called from %s
%25s:%-5d AVVCPluginRecordingEngine()
%25s:%-5d ~AVVCPluginRecordingEngine()
%25s:%-5d finding the first device for activation mode (%{audio:4CC}d)  : %p
%25s:%-5d device identifier shouldn't be NULL... 
%25s:%-5d device identifier : %@
%25s:%-5d setHWSampleRate() streamID(%lu) sr(%.2f) upSamp(%d)
%25s:%-5d session state (%s), rec-engine [%@], rec-engine type (%s), stream state (%s)
%25s:%-5d (self %p)startRecord : using activeDevice: %p
%25s:%-5d #### calling startRecordingWithCompletionBlock on device (%p) ####
%25s:%-5d startedRecording: nil object encountered (eng: %p). Bailing
%25s:%-5d AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING
%25s:%-5d AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: RUNNING-PAUSED
%25s:%-5d startRecordingWithCompletionBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil.
%25s:%-5d AVVCPluginRecordingEngine::startRecordingWithCompletionBlock: returned error(%d) : %@. Setting the audioInputBlock to nil.
%25s:%-5d startRecordQueue:  No device found, err : %d
%25s:%-5d AVVCPluginRecordingEngine::stopRecording: mRecordIsStopping set to true
%25s:%-5d stopRecording: nil object encountered (eng: %p). Bailing
%25s:%-5d AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: STOPPED
%25s:%-5d AVVCPluginRecordingEngine::stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%25s:%-5d stopRecording:  No device found error :%d
%25s:%-5d (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Entering --->
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine: about to call stopRecordingCompletionBlock - previous stop completion block didn't happen
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine -- stopRecordingWithCompletionBlock: STOPPED
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine - stopRecordingWithCompletionBlock: returned error(%d) : %@ 
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine:  calling doneRecording manually
%25s:%-5d AVVCPluginRecordingEngine::destroyRecordEngine:  skipping doneRecording as we are deallocating
%25s:%-5d destroyRecordEngine: device found, err : %d
%25s:%-5d (self %p)AVVCPluginRecordingEngine::destroyRecordEngine: Exiting <---
%25s:%-5d AVVCPluginRecordingEngine::createRecordQueue : no matching device found, error : %d
%25s:%-5d supported Formats[%d] : %@ 
%25s:%-5d Using Format[0] : %@ 
%25s:%-5d No Format specified.. Error
%25s:%-5d clientRequestedSR was:%.2f, setting to %.2f
%25s:%-5d clientRequestedSR was not specified, setting to %.2f
%25s:%-5d AVVCPluginRecordingEngine(%p)::createRecordQueue -->
%25s:%-5d createRecordQueue : using device %p
%25s:%-5d createRecordQueue : setting format on active device(%p), format:%@
%25s:%-5d Record queue state does not match queue (previously assertion failure)
%25s:%-5d audioInputBlock: nil object encountered (eng: %p). Bailing
%25s:%-5d audioInputBlock (lpcm) called with frameLength : %d
%25s:%-5d audioInputBlock (opus / speex) called with packetcount : %d
%25s:%-5d audioInputBlock called with an unsupported audio format ID (%lu).
%25s:%-5d audioInputBlock called
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: timeStamp : %f
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: Nil VoiceActivity NSData
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: inGain : %f
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: No Gain Value
%25s:%-5d AVVCPluginRecordingEngine::audioInputBlock: No frame qualities.
%25s:%-5d statusChangeBlock: nil object encountered (eng: %p). Bailing
%25s:%-5d statusChangeBlock: Recording cancelled by plugin device. Calling didStop recording and setting audioInputBlock to nil. strong_this(%p)
%25s:%-5d In AVVCPluginRecordingEngine::handleRecordInput: %u frames, hostTime : %lld, sampletime : %f
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput: record internally stopped, so throwing away buffer. StreamState(%s). RecordCancelled(%d)
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput - recordState is active, but getting nil buffer
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput (opus). bufferLength : %d, packetCount : %d, packetDesc.startOffset %lld, packetDesc.mVariableFramesInPacket %u, packetDesc.DataByteSize = %u
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput (opus): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%25s:%-5d Setting up client buffer
%25s:%-5d Copying BT audio buffer, size %u
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput (speex): max frame gain: %.2f dB.  sending %u bytes of encoded data to client with %u packet descs, max packet count %d
%25s:%-5d AVVCPluginRecordingEngine::handleRecordInput - Unsupported formatID: %u
%25s:%-5d Exiting AVVCPluginRecordingEngine::handleRecordInput
%25s:%-5d >> %s
%25s:%-5d << %s
%25s:%-5d AVVCRecordDeviceInfo initWithRecordingEngine[%@]. self(%p)
%25s:%-5d AVVCRecordDeviceInfo initWithRecordingEngine: recordDeviceName(%@)
%25s:%-5d AVVCRecordDeviceInfo initWithRecordingEngine: remoteDeviceUUID(%@)
%25s:%-5d AVVCRecordDeviceInfo initWithVoiceController: remoteDeviceCategory(%d)
%25s:%-5d AVVCRecordDeviceInfo dealloc. self(%p)
%25s:%-5d setSessionNotifications: setting up notifications for %s session(%p)
%25s:%-5d removeSessionNotifications: removing all notifications for %s session(%p)
%25s:%-5d #### hardwareConfigChanged: ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
 ASSERTION FAILED: handleInterruption_v1v2: called with NULL impl!
%25s:%-5d #### AVVoiceController handleInterruption_v1v2: %s session (%p), %@
 ASSERTION FAILED: handleRouteChange_v1v2: called with NULL impl!
%25s:%-5d #### AVVoiceController handleRouteChange_v1v2: %s session (%p)
 ASSERTION FAILED: handleMediaServerDeath: called with NULL impl!
 ASSERTION FAILED: handleMediaServerReset: called with NULL impl!
%25s:%-5d Error! handlePluginDidPublishDevice: ControllerImpl is NULL
%25s:%-5d Error! handlePluginDidUNpublishDevice: ControllerImpl is NULL
%25s:%-5d #### beganRecording: (success = %d status = %d streamID = %llu) ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidStartRecording: variants
%25s:%-5d finishedRecording -> called after AVVC object destroyed -- ignoring call and possibly leaking ControllerImpl
%25s:%-5d finishedRecording -> called after dealloc -- ignoring call
%25s:%-5d #### AVVoiceController: Recording finished (success = %d status = %d streamID = %llu) ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidStopRecording:forReason:
%25s:%-5d startpointDetected -> called after object destroyed -- ignoring call
%25s:%-5d #### startpointDetected: ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidDetectStartpoint:
%25s:%-5d interspeechPointDetected -> called after object destroyed -- ignoring call
%25s:%-5d #### interspeechPointDetected: time %.2f seconds ####
%25s:%-5d WARNING: delegate is nil or does not respond to voiceControllerDidDetectEndpoint:ofType:
%25s:%-5d endpointDetected -> called after object destroyed -- ignoring call
%25s:%-5d #### endpointDetected: time %.2f seconds ####
%25s:%-5d     Reporting encoder error %s via delegate
%25s:%-5d encodeError detected but no record delegate, or notify selector not supported
%25s:%-5d Calling alert playback finished delegate. Settings { Type: %d, Mode: %d, alertEndTime: %llu }
%25s:%-5d Calling alert playback finished delegate. Type: %d
%25s:%-5d Notifying streamHandle(%lu) invalidated
%25s:%-5d streamHandle(%lu) invalidated but no record delegate, or notify selector not supported
%25s:%-5d handleInterruptStart: notifying with context: %@
%25s:%-5d handleInterruptStart: notifying without context
%25s:%-5d handleInterruptStart: WARNING: delegate does not respond to voiceControllerBeginRecordInterruption:
%25s:%-5d handleInterruptStop: notifying
%25s:%-5d Calling record delegate's voiceControllerWillSetAudioSessionActive. Going active? : %d
%25s:%-5d Calling record delegate's voiceControllerDidSetAudioSessionActive. Going active? : %d
%25s:%-5d ### Record route ###
%25s:%-5d ### Playback route ###
%25s:%-5d Playback route: %@
%25s:%-5d setStopOnBargeInEnabled: barge-in previously detected -- stopping playback
%25s:%-5d prepareRecordWithSettings should be called first before asking for number of channels
%25s:%-5d [enforce 1 avvc] #### AVVoiceController: initWithContext: [self == %p]. with context:%{audio:4CC}d %@
%25s:%-5d initWithContext: ControllerImpl() failed with error: %ld
%25s:%-5d initWithContext: calling setSessionProperties
%25s:%-5d AVVoiceController: initWithContext failure
%25s:%-5d #### initWithContext finished [self = %p] ####
%25s:%-5d #### AVVoiceController: prewarmAudioSession: ####
%25s:%-5d self == %p
%25s:%-5d beginning teardown. self == %p
%25s:%-5d [enforce 1 avvc] #### AVVoiceController: dealloc [self == %p] ####
%25s:%-5d In dealloc without prior teardownWithError: call. Controller(%p)
In dealloc without prior teardownWithError: call. Controller(%p)
%25s:%-5d Problem tearing down. Error : %@
%25s:%-5d #### AVVoiceController: exiting dealloc ####
%25s:%-5d #### AVVoiceController: releaseAudioSession: [self = %p] ####
%25s:%-5d #### AVVoiceController: releaseAudioSession:options [self = %p] ####
%25s:%-5d #### AVVoiceController: enableMiniDucking: %d
%25s:%-5d #### AVVoiceController: willAcceptContext: with context:%{audio:4CC}d %@
%25s:%-5d ### unimplemented in this platform
%25s:%-5d #### AVVoiceController[self = %p]: setCurrentContext: with context:%{audio:4CC}d %@
%25s:%-5d #### setCurrentContext:error finished [self = %p]####
%25s:%-5d #### AVVoiceController[self = %p]: prepareRecordWithSettings: %@ 
%25s:%-5d prepareRecordWithSettings failed with internal error %s
%25s:%-5d #### prepareRecordWithSettings finished ####
%25s:%-5d #### AVVoiceController: setAlertSoundFromURL: %@ forType: %d ####
%25s:%-5d setAlertSoundFromURL:forType: Illegal alertType
%25s:%-5d call to playAlertSoundForType blocked because mediaserverd is dead
%25s:%-5d #### AVVoiceController: playAlertSoundForType: %d [self = %p]####
%25s:%-5d playAlertSoundForType: Session check failed: %s
%25s:%-5d playAlertSoundForType: Illegal alertType
%25s:%-5d #### AVVoiceController: resetEndpointer ####
%25s:%-5d #### AVVoiceController: playRecordStartingAlertAndResetEndpointer ####
%25s:%-5d #### AVVoiceController::playRecordStartingAlertAndResetEndpointer current Context  %@ ####
%25s:%-5d #### AVVoiceController: startRecording [self = %p]####
%25s:%-5d #### AVVoiceController: startRecording:(NSError **) [self = %p]####
%25s:%-5d #### AVVoiceController: startRecordingAtTime:error : %d [self = %p]####
%25s:%-5d #### AVVoiceController: startRecordingAtTime:error [self = %p]####
%25s:%-5d #### AVVoiceController:[self = %p] startRecordingWithSettings:error %@
%25s:%-5d AVVoiceController: startRecordingWithSettings: Ignoring old style alert behavior
%25s:%-5d #### AVVoiceController:[self = %p] startRecordingWithSettings:error = %d
%25s:%-5d #### AVVoiceController: stopRecording ####
%25s:%-5d #### AVVoiceController: setRecordDelegate: %p ####
%25s:%-5d #### AVVoiceController: setRecordBufferDuration: %f ####
%25s:%-5d #### AVVoiceController: setEndpointerDelegate ####
%25s:%-5d #### AVVoiceController: setRecordEndpointMode: %d ####
%25s:%-5d #### AVVoiceController: recordStartWaitTime: %f ####
%25s:%-5d isRecording: rec-engine type: %s, stream state: %s
%25s:%-5d #### AVVoiceController: setAlertVolume: %f ####
%25s:%-5d #### AVVoiceController: setMeteringEnabled: %d ####
%25s:%-5d setStopOnEndpointEnabled: endpoint previously detected -- stopping capture
%25s:%-5d #### AVVoiceController: currentRecordDeviceInfo. self(%p) ####
%25s:%-5d [enforce 1 avvc] #### AVVoiceController: initWithError (V2): [self == %p]
%25s:%-5d initWithError: Failed to create ControllerImpl or configureAlerts - error (%ld)
%25s:%-5d #### AVVoiceController[self = %p]: setContext:streamType:completion: activationMode(%@), deviceUID(%@)
%25s:%-5d #### AVVoiceController[self = %p]: setContext: activationMode(%@), deviceUID(%@)
%25s:%-5d !! DEPRECATED !! #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%25s:%-5d #### AVVoiceController[self = %p]: prepareRecordForStream: streamHandle(%lu), bufferDuration(%f), settings: %@
%25s:%-5d !! DEPRECATED !! #### AVVoiceController[self = %p]: startRecordWithSettings:completion:alertCompletion:audioCallback: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d)
%25s:%-5d #### AVVoiceController[self = %p]: startRecordForStream:completion: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d,%s)
%25s:%-5d #### AVVoiceController[self = %p]: startRecordForStream: streamHandle(%lu), startTime(%llu). AlertsOverride(%d,%d,%d,%s)
%25s:%-5d #### AVVoiceController[self = %p]: configureAlertBehaviorForStream:completion: streamHandle(%lu), AlertsOverride(%d,%d,%d)
%25s:%-5d #### AVVoiceController[self = %p]: configureAlertBehaviorForStream: streamHandle(%lu), AlertsOverride(%d,%d,%d)
%25s:%-5d !! DEPRECATED !! #### AVVoiceController[self = %p]: stopRecordForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: stopRecordForStream: streamHandle(%lu)
%s unexpected error (%d) returned from stopRecordForStream for streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: getCurrentStreamState: streamHandle(%lu). State(%s)
%25s:%-5d #### AVVoiceController[self = %p]: getRecordDeviceInfoForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d). streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: activateAudioSessionForStream isPrewarm(%d), switchRecordMode(%d). streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: deactivateAudioSessionWithOptions(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: deactivateAudioSessionForStream:(%d) withOptions(%lu) completion:
%25s:%-5d #### AVVoiceController[self = %p]: deactivateAudioSessionForStream:(%d) withOptions(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: setContextForStream: activationMode(%@), deviceUID(%@). streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: playAlert alertType(%d). overrideMode(%d)
%25s:%-5d #### AVVoiceController[self = %p]: playAlertSoundForStream: alertType(%d) overrideMode(%d)
%25s:%-5d playAlertSoundForStream failed with error : %d
%25s:%-5d #### AVVoiceController[self = %p]: setRecordStatusChangeBlock
%25s:%-5d #### AVVoiceController[self = %p]: enableSmartRoutingConsideration: streamHandle(%lu), enable : %d
%25s:%-5d #### AVVoiceController[self = %p]: setAnnounceCallsEnabledForStream: streamHandle(%lu), enable : %d
%25s:%-5d #### AVVoiceController[self = %p]: getInputChannelInfoForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: setDuckOthersForStream: streamHandle(%lu), duckSettings(%@)
%25s:%-5d #### AVVoiceController[self = %p]: isDuckingSupportedOnPickedRouteForStream: streamHandle(%lu)
%25s:%-5d #### AVVoiceController[self = %p]: enableTriangleModeForStream: streamHandle(%lu), opt value : %d
%25s:%-5d [enforce 1 avvc] before wait controller(%p), %@
%25s:%-5d [enforce 1 avvc] after wait%s controller(%p), %@
%25s:%-5d [enforce 1 avvc] Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously
[enforce 1 avvc] %s Timed out waiting to initialize, which means multiple AVVC objects exist simultaneously. Controller(%p)
%25s:%-5d [enforce 1 avvc] created gsAVVCSingleInstanceSemaphore %@
%25s:%-5d %s : %s : start: %s end: %s duration %.2f ms
%25s:%-5d %s : start: %s end: %s duration %.2f ms
%25s:%-5d about to lock %s
%25s:%-5d about to unlock %s
%25s:%-5d [enforce 1 avvc] before signal avvc(%p), %@
%25s:%-5d [enforce 1 avvc] after signal avvc(%p), %@
%25s:%-5d QualityDetector: Start thresh: %u Start Timeout: %u End thresh: %u  End Timeout: %u
%25s:%-5d QualityDetector: NONE => ACTIVE
%25s:%-5d QualityDetector: NoSpeech; End Counter %u / %u
%25s:%-5d QualityDetector: NONE => ENDED (TIMEOUT AT START)
%25s:%-5d QualityDetector: Active; End Counter %u / %u
%25s:%-5d QualityDetector: Active; Watching for end point (current frame quality: %u)
%25s:%-5d QualityDetector: ACTIVE => ENDED
%25s:%-5d QualityDetector: ACTIVE => ENDING
%25s:%-5d QualityDetector: Speech Ending; End Counter %u / %u
%25s:%-5d QualityDetector: ENDING => ACTIVE
%25s:%-5d QualityDetector: ENDING => ENDED
 ASSERTION FAILED: inPastFrameCount <= mFrameHistoryLength
%25s:%-5d QualityDetector: Start Timeout: %u frames
%25s:%-5d QualityDetector: Interspeech Timeout: %u frames
%25s:%-5d QualityDetector: End Timeout: %u frames
%25s:%-5d SpeexEndpointer init:
%25s:%-5d SpeexEndpointer dealloc:
%25s:%-5d SpeexEndpointer configureWithSampleRate:
%25s:%-5d SpeexEndpointer configureWithSampleRate:andFrameRate: illegal frame rate!
%25s:%-5d SpeexEndpointer configureWithASBD:andFrameRate
%25s:%-5d SpeexEndpointer setEndpointMode: %d
%25s:%-5d SpeexEndpointer setStartWaitTime: %f
%25s:%-5d SpeexEndpointer setInterspeechWaitTime: %f
%25s:%-5d SpeexEndpointer setEndWaitTime: %f
 ASSERTION FAILED: getStatus called before object was configured!
%25s:%-5d SpeexEndpointer getStatus: Raw Speex qlty frame %d/%d: %.2f rnng avrg: %.2f, med: %.2f, cls: %d
%25s:%-5d #### SpeexEndpointer: Detected start point ####
%25s:%-5d #### SpeexEndpointer: Detected soft end point ####
%25s:%-5d #### SpeexEndpointer: Detected hard end point ####
 CAMutex::CAMutex: Could not init the mutex
 CAMutex::Lock: Could not lock the mutex
 CAMutex::Unlock: Could not unlock the mutex
 CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own
 CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)
 CAPThread::SetPriority: failed to set the fixed-priority policy, Error: 0x%X
 CAPThread::SetPriority: failed to set the precedence policy, Error: 0x%X
 CAPThread::SetTimeConstraints: thread_policy_set failed, Error: %d (%s)
 CAPThread::Start: can't start because the thread is already running
 CAPThread::Start: Thread attributes could not be created.
 CAPThread::Start: A thread could not be created in the detached state.
 CAPThread::Start: Could not create a thread.
%25s:%-5d Trigger clean up of context(%s, %@)
%25s:%-5d AVVCRecordingEngine():~AVVCRecordingEngine() called
%25s:%-5d reconfigure for streamID(%lu) failed to destroy engine (%d)
%25s:%-5d reconfigure for streamID(%lu) failed to prepareRecording (%d)
%25s:%-5d Settings are nil, rebuilding queue
%25s:%-5d prepareRecord: NEW FORMAT: %s
%25s:%-5d ERROR: prepareRecord: createRecordQueue err %d
%25s:%-5d ERROR: prepareRecord: createRecordQueue err %{audio:4CC}d
%25s:%-5d Formats differ, rebuilding queue
%25s:%-5d prepareRecord: CURRENT FORMAT: %s
%25s:%-5d destroying engine because of record error: %d
%25s:%-5d Cached session pointer (%p) for engine(%d, %p)
%25s:%-5d Cached session manager pointer (%p) for engine(%d, %p)
%25s:%-5d AudioQueueGetProperty kAudioConverterSampleRateConverterQuality failed: %d
%25s:%-5d AudioQueueGetProperty kAudioConverterPropertyBitDepthHint failed: %d
%25s:%-5d AudioQueueGetProperty property size of kAudioQueueProperty_ChannelLayout failed: %d OR property size is 0
%25s:%-5d AudioQueueGetProperty returned %d for kAudioQueueProperty_ChannelLayout property size
%25s:%-5d AudioQueueGetProperty kAudioQueueProperty_ChannelLayout failed: %d
%25s:%-5d AudioQueueGetProperty returned (%p) for kAudioQueueProperty_ChannelLayout bytes
%25s:%-5d setStreamState (%s => %s)
%25s:%-5d setRecordErrorStatus: %ld
%25s:%-5d setRecordBufferDuration: Attempting to setRecordBufferDuration while record is active. Stream State(%s)
%25s:%-5d setRecordBufferDuration: specified buffer duration too small -- setting to minimum allowed
%25s:%-5d setRecordBufferDuration: rebuilding queue
%25s:%-5d setRecordBufferDuration: Failed at prepareRecording (reconfig) : %d
%25s:%-5d setRecordBufferDuration: duration now %.3f
%25s:%-5d getRecordBufferDuration: choice 1 mRecordBasePacketsPerSecond (%lu)
%25s:%-5d getRecordBufferDuration: choice 2 mRecordBasePacketsPerSecond (%lu)
%25s:%-5d getRecordBufferDuration: returning %.3f seconds
%25s:%-5d getPeakPowerForChannel on stream(%llu): returning %f for channel %d
%25s:%-5d getAveragePowerForChannel on stream(%llu): returning %f for channel %d
%25s:%-5d AVVCRecordingEngine::cacheRecordRoute : %@
%25s:%-5d setStartRecordCompletionAndAudioCallbackBlocks: startCompletionBlock(%p). audioCallbackBlock(%p)
%25s:%-5d setStopRecordCompletionBlock: stopCompletionBlock(%p).
%25s:%-5d setDidStopDelegateCompletionBlock: didStopCompletionBlock(%p).
%25s:%-5d setEncoderErrorBlock: encoderErrorBlock(%p).
%25s:%-5d setDeferredContextBlock: deferredContextBlock(%p).
%25s:%-5d setSetupEndpointerBlock: setupEndpointerBlock(%p).
%25s:%-5d setCheckForEndpointBlock: checkForEndpointBlock(%p).
%25s:%-5d setStopRecordWithRecordLockBlock: stopRecordWithRecordLockBlock(%p).
%25s:%-5d setDestroyRecordEngineWithRecordLockBlock: destroyRecordEngineWithRecordLockBlock(%p).
%25s:%-5d setReconfigureWithRecordLockBlock: reconfigureWithRecordLockBlock(%p).
%25s:%-5d setStreamInvalidatedBlock: streamInvalidatedBlock(%p).
%25s:%-5d setHardwareConfigChangedBlock: hardwareConfigChangedBlock(%p).
%25s:%-5d setBeginSessionActivateBlock: beginSessionActivateBlock(%p).
%25s:%-5d setEndSessionActivateBlock: endSessionActivateBlock(%p).
%25s:%-5d Reset completion blocks to nil for engine[%@]
%25s:%-5d myBuffer->mAudioData : %p, myBuffer->mAudioDataByteSize : %d
%25s:%-5d Ignoring action, since streamState is already %s
%25s:%-5d stopRecord: record state == kRecordStarting but object being destroyed -- just stop queue
%25s:%-5d doneRecording: resetting mRecordIsStopping and mRecordIsPrimed
%25s:%-5d doneRecording: calling startRecordCompletionBlock(%p) (notify start before stop). Error: %@
%25s:%-5d calling completion block(%p)
%25s:%-5d stopRecordWithRecordLockBlock is nil !
%25s:%-5d destroyRecordEngineWithRecordLockBlock is nil !
mImplInDealloc is true unexpectedly!
%25s:%-5d updateRecordAndPlaybackRoutes: built in route !
%25s:%-5d updateRecordAndPlaybackRoutes: Nil currentRoute!
%25s:%-5d New Record Route  : %@
%25s:%-5d New Playback Route: %@
%25s:%-5d getSessionProperties: unexpected 0.0 value for output latency
%25s:%-5d getSessionProperties: working around bad input latency value for now
%25s:%-5d getSessionProperties: input HW latency: %g output HW latency: %g
%25s:%-5d getSessionProperties: input HW sampling rate %lf
%25s:%-5d getSessionProperties: plugin mode - resetting to default HW sampling rate %lf
%25s:%-5d getSessionProperties: Error getting input hardware sample rate
%25s:%-5d setSessionActive: Error! Attemtping to activate a session that is not configured
%25s:%-5d #### AVVoiceController: %s session ####
%25s:%-5d setSessionActive(true): AVAudioSession:setActive has returned
%25s:%-5d setSessionActive(true): force of getSessionProperties requested
%25s:%-5d setSessionActive(true): force of getSessionProperties requested - returned error : %d
%25s:%-5d setSessionActive(true): Route change when we went active: %@ -- getting properties
%25s:%-5d setSessionActive(false): Deactivating session due to error: %d
%25s:%-5d setSessionActive(true): session state already %s -- no-op
 ca_verify_noerr: [%s, %d]
 timeout
%25s:%-5d Created AVVCSessionFactory (%p)
%25s:%-5d _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing session manager(%p) audioSession(%p) for context(%s, %@)
%25s:%-5d _wqCreateAuxSessionAndManagerForDeviceUID: setActivationContext returned error(%d)
%25s:%-5d _wqCreateAuxSessionAndManagerForDeviceUID: unexpected existing sessionManager(%p)
%25s:%-5d Created aux session (%p) and session manager (%p) and setup onetime settings for context(%s, %@)
%25s:%-5d Created primary session manager (%p) and setup onetime settings for context(%s, %@)
%25s:%-5d _wqSessionForContext: activationDeviceUID must be specified for this mode
%25s:%-5d First time primary session (%p) retrieved. Context(%s, %@)
%25s:%-5d retrieved session (%p) and sessionManager (%p) for context(%s, %@)
%25s:%-5d Clean up context(%s, %@), about to release session(%p) and manager(%p)
%25s:%-5d Unexpected error cleaning up context: %@
%25s:%-5d Unexpected missing session when cleaning up context
%25s:%-5d Can't cleanup because devID is missing in context(%s, %@)
%25s:%-5d Nothing to clean up for context(%s, %@)
%25s:%-5d Releasing primary session manager (%p)
%25s:%-5d ---> this = %p
%25s:%-5d <---
%25s:%-5d Track's sequence was NULL
%25s:%-5d Underlying track already destroyed
%25s:%-5d start -> %.2f [end %.2f]
%25s:%-5d end -> %.2f [start %.2f]
%25s:%-5d %sabling looping [%.2f - %.2f]
%25s:%-5d RealtimeMessenger: trying to enqueue duplicate invocation on message %p
%25s:%-5d Error fetching from ring buffer, this = %p, err = %d
%25s:%-5d AVVCRecordingEngineMap::AVVCRecordingEngineMap() Created new Engine Map
%25s:%-5d AVVCRecordingEngineMap::~AVVCRecordingEngineMap() Destroyed Engine Map
%25s:%-5d No recording engine found for stream(%lu)
%25s:%-5d No matching engine found for nil deviceUUID
%25s:%-5d Iterating through EngineMap. AVVCStreamHandle(%lu). AVVCRecordEngine[%@]. DeviceUID(%@). EngineType(%s)
%25s:%-5d Found matching engine of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d No matching plugin engine found for deviceUUID: %@
%25s:%-5d Added engine[%@] for stream(%llu) to the map of size %ld
%25s:%-5d Removing engine[%@] for stream(%llu) from the map
%25s:%-5d Engine for streamID(%llu) not found
%25s:%-5d EngineDispatchGroup wait timed out!
%25s:%-5d Empty Engine Map
%25s:%-5d Engine[%@] type(%s) stream(%llu) deviceUID(%@)
%25s:%-5d AVAudioEngine: left running idle for %.f s
%25s:%-5d AVAudioEngine (auto shutdown mode): left running idle for %.f s, stopping!
%25s:%-5d AVAudioEngine (auto shutdown mode): starting IO dynamically
%25s:%-5d AVAudioEngine (auto shutdown mode): could not dynamically start the audio hardware, err = %s
%25s:%-5d graph@%p: couldn't initialize node@%p {%s}, error %d
%25s:%-5d Can't retrieve source node to play sequence because there is no output node!
%25s:%-5d [%s:%d:%s: (%s): error %d
%25s:%-5d manual rendering mode, setting output type = external speakers
%25s:%-5d setting output type = headphones
%25s:%-5d setting output type = built-in speakers
%25s:%-5d setting output type = external speakers
%25s:%-5d multiple outputs active, setting output type = external speakers
%25s:%-5d Error creating XPC connection to %@
%25s:%-5d %@
%25s:%-5d Interruption Handler: connection got interrupted
%25s:%-5d Invalidation Handler: client exited
%25s:%-5d starting sequence on client side
%25s:%-5d Issuing sandbox %s for path %s
%25s:%-5d failed to extend the service's sandbox
%25s:%-5d result data %@ output %li input %li sample rate %f
%25s:%-5d finishing sequence on client side
%25s:%-5d playback on client side
%25s:%-5d Issuing sandbox %s for path %@
%25s:%-5d starting recording on client side
%25s:%-5d stopping recording on client side
%25s:%-5d AVVCMetricsManager: createSharedManager: referenceCount after incrementing = %llu
%25s:%-5d AVVCMetricsManager: destroySharedManager : referenceCount after decrementing = %llu
%25s:%-5d AVVCMetricsManager: sharedInstance is nil !!!!
%25s:%-5d Profiling AVVC NOW.
%25s:%-5d AVVCMetricsManager: dealloc
%25s:%-5d Measuring Elapsed Time for %@ : %f ms
%25s:%-5d configure: session not configured -- calling setSessionProperties
%25s:%-5d Overwriting an already-deferred context
%25s:%-5d setCurrentContext:error: record is active -- deferring the context change
%25s:%-5d setActivationContext in setCurrentContext failed! %d
%25s:%-5d createRecordingEngine in setCurrentContext failed! %d
%25s:%-5d getCurrentRecordDeviceInfo: Current Recording Engine is nil!
%25s:%-5d getCurrentRecordDeviceInfo: mCurrentRecordDeviceInfo already exists. Deleting old and creating new.
%25s:%-5d recordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%25s:%-5d getCurrentRecordSettings: Error, current recording engine is nil!
%25s:%-5d enableMetering: Current recording engine is nil!
%25s:%-5d updateMeters: Error, current recording engine is nil!
%25s:%-5d getPeakPowerForChannel: Error, current recording engine is nil!
%25s:%-5d isMeteringEnabled: Error, current recording engine is nil!
%25s:%-5d prepareRecord: Can't perform this action while record is starting or active
%25s:%-5d prepareRecord: home/uibp/btbp/vehb button activation : after rechecking which engine to use [%@]
%25s:%-5d createRecordingEngine in prepareRecord_v1 failed : %d
%25s:%-5d Nil Recording Engine! Couldnt get session properties
%25s:%-5d prepareRecord: recording engine is not selected, %{audio:4CC}d
%25s:%-5d startListen: Current recording engine is nil! Bailing!
%25s:%-5d SECOND PASS-Start Record Delta %f ms
%25s:%-5d Attempt to start recording without calling prepareRecordWithSettings:
%25s:%-5d startRecord: already starting or active -- no-op
%25s:%-5d startRecord: failed to play record-start alert. status = %d
%25s:%-5d startRecord: returning failed record status %d
%25s:%-5d getRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%25s:%-5d setRecordBufferDuration: Error! _getCurrentRecordingEngine_v1v2() is nil!
%25s:%-5d getStartRecordTime: Error, current recording engine is nil!
%25s:%-5d setStartRecordTime: Error, current recording engine is nil!
%25s:%-5d setStartRecordTime: %llu
%25s:%-5d configureAlertOverrides: Session is active. configureAlertModeFromModeAndEngine now. Current recording engine [%@], activation mode (%@)
%25s:%-5d Error setting manual rendering mode input PCM format on input node! %s
%25s:%-5d prepareRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d prepareRecordForStream: Found engine[%@] of type(%s) for streamID(%lu), with activation mode(%@)
%25s:%-5d prepareRecordForStream: Failed to setRecordBufferDuration
%25s:%-5d prepareRecordForStream: Error in prepareRecording: %d
%25s:%-5d prepareRecordForStream: Error in enableMetering: %d
%25s:%-5d startRecordForStream streamID(%lu)
%25s:%-5d startRecordForStream: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d startRecordForStream: Attempt to start stream(%ld) without calling prepare.
%25s:%-5d startRecordForStream: Attempt to start stream(%ld) while stream is already %s. No-op.
%25s:%-5d ERROR in startRecordForStream, failed at playAlert: %d
%25s:%-5d startRecordForStream: Error in startRecording for stream(%lu): %d
%25s:%-5d session (%p) and session mananger (%p) used for engine (%p) with context(%s, %@)
%25s:%-5d startRecordForStream: Skipping alert playback and continuing to startRecord
%25s:%-5d stopRecordForStream streamID(%lu)
%25s:%-5d stopRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%25s:%-5d stopRecordForStream: Attempt to stop on an %s stream.
%25s:%-5d stopRecordForStream: Attempt to stop while stream is already %s. No-op.
%25s:%-5d stopRecordForStream: an error : %d  occurred while recording and we need to synthesize doneRecording
%25s:%-5d stopRecordForStream: Attempt to stop while stream is about to start. NotifyStartBeforeStop
%25s:%-5d stopRecordForStream: record state == kRecordStarting but object being destroyed -- just stop queue
%25s:%-5d stopRecordForStream: record state == kRecordStarting -- we will need to send a start notify prior to stop
%25s:%-5d stopRecordForStream: record was just starting -- calling doneRecording ourselves -- watch this case
%25s:%-5d stopRecordForStream: Error stopping record engine: %d
%25s:%-5d getCurrentStreamState: Cannot find recording engine for streamID(%lu).
%25s:%-5d getRecordBufferDurationForStream_v2: Nil recording engine
%25s:%-5d configureAlertBehaviorForStream completion streamID(%lu)
%25s:%-5d startRecordForStream: Cannot find recording engine for streamID(%lu). Failing.
%25s:%-5d ERROR: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d checkSession_v2: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d KeepAliveQueue will NOT be started since output is NOT hands free
%25s:%-5d activateAudioSessionForStream ERROR: Cannot find recording engine for streamID(%lu). Bailing.
%25s:%-5d Announce option set for %s activation mode
%25s:%-5d About to activate audio session for stream(%lu). Current context: %@
%25s:%-5d activateAudioSessionForStream for stream(%lu). isPrewarm(%d). CurrentState(%s).
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionActivationContext: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionBufferSize: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%25s:%-5d activateAudioSessionForStream ERROR: Failed checkSession at setAudioSessionActive OSStatus(%d).
%25s:%-5d setContextForStream: Error! Incoming engine with streamID(%llu) is different from engine that was used to activate the session, streamID(%llu)
%25s:%-5d setContextForStream: Announce option set for %s activation mode
%25s:%-5d setContextForStream ERROR: Failed at setSessionActivationContext: %d
%25s:%-5d setContextForStream ERROR: Failed at setSessionCategoryModeOptionsForActivationMode: %d
%25s:%-5d setContextForStream ERROR: Failed at setSessionSampleRateForActivationMode: %d
%25s:%-5d setContextForStream ERROR: Failed at setSessionAudioHWControlFlagsForActivationMode: %d
%25s:%-5d setContextForStream: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%25s:%-5d setContextForStream : Session re-activation failed with error : %d
%25s:%-5d setContextForStream: session re-activated -- calling getSessionProperties
%25s:%-5d playAlertWithCompletion: called when session inactive--do nothing and return error
%25s:%-5d Current Playback Route %@
%25s:%-5d playAlertWithOverride: calling AudioServicesPlaySystemSoundWithOptions with sound ID %d
%25s:%-5d playAlertWithOverride: Finished playing the alert beep
%25s:%-5d playAlertWithCompletion: Illegal alertType
%25s:%-5d getRecordDeviceInfoForStream: Nil recording engine for streamID(%llu)
%25s:%-5d StreamID(%llu). RecordRoute: %@, isRemoteDevice: %d, productID: %@, uuid: %@, category: %d
%25s:%-5d getRecordSettingsForStream_v2: Nil recording engine
%25s:%-5d isMeteringEnabledForStream_v2: Nil recording engine
%25s:%-5d updateMeterLevelForStream_v2: Nil recording engine
%25s:%-5d updateMeterLevelForStream_v2: Error updating meter levels: %d
%25s:%-5d getRecordSettingsForStream: Nil recording engine
%25s:%-5d getAveragePowerForStreamAndChannel_v2: Nil recording engine
%25s:%-5d enableSmartRoutingConsideration: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d setAnnounceCallsEnabledForStream: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d setDuckOthersForStream_v2: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d isDuckingSupportedOnPickedRouteForStream: Nil recording engine
%25s:%-5d enableTriangleModeForStream_v2: Nil recording engine
%25s:%-5d unlocker about to unlock %s
 ASSERTION FAILED: Unlocker attempted to unlock a mutex not owned by the current thread!
%25s:%-5d unlocker about to relock %s
%25s:%-5d setStartAlertMode: %s
%25s:%-5d alert queue state => %s
%25s:%-5d setStopAlertMode: %s
%25s:%-5d setStopWithErrorAlertMode: %s
%25s:%-5d ---> self = %p
%25s:%-5d AVVCPluginRecordingEngine::getRecordRoute : no matching device found, error : %d
%25s:%-5d active device doesn't support remoteInputDeviceName property
%25s:%-5d Nil port type!
%25s:%-5d No input routes. AQ engine couldnt find routes since VSPD is not present!
%25s:%-5d Nil output port!
%25s:%-5d No output routes returned!
%25s:%-5d Unable to start playing the note %d
%25s:%-5d Unable to stop playing the note %d
%25s:%-5d Unable to send midi event status(%d), channel(%d), param1(%d), param2(%d)
%25s:%-5d Unable to send midi event list %p, offset = %d, cable = %d
%25s:%-5d format has zero bytes per frame
%25s:%-5d buffer byte capacity cannot be represented by an uint32_t
%25s:%-5d the number of buffers is 0
%25s:%-5d the number of buffers (%u) does not match the format's number of channel streams (%u)
%25s:%-5d mBuffers[0].mDataByteSize (%u) should be non-zero
%25s:%-5d mBuffers[%u].mDataByteSize (%u) does not match the previous mBuffers[%u].mDataByteSize (%u)
%25s:%-5d mBuffers[%d].mNumberChannels (%u) does not match the format's number of interleaved channels (%u)
%25s:%-5d mBuffers[%u].mData is null
%25s:%-5d AudioQueueRecordInputCallback called 
%25s:%-5d AudioQueueRecordPropertyListenerProc called 
%25s:%-5d AudioQueueRecordPropertyListenerProc: Engine[%@] Queue(%p) Property(%d)
%25s:%-5d ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %d
%25s:%-5d ERROR: QueueIsRunning: AudioQueueGetProperty(kAudioQueueProperty_IsRunning) (ignored) err %{audio:4CC}d
%25s:%-5d Error getting input hardware sample rate
%25s:%-5d clientRequestedSR was:%.2f, setting to 16000.00
%25s:%-5d clientRequestedSR was:%.2f
%25s:%-5d clientRequestedSR was not specified, setting to 16000.00
%25s:%-5d ERROR: setupRecordQueue: asbdFromSettings err %d
%25s:%-5d ERROR: setupRecordQueue: asbdFromSettings err %{audio:4CC}d
%25s:%-5d Record engine state does not match queue (previously assertion failure)
%25s:%-5d Record Queue Format: %s
%25s:%-5d Creating queue with flags 0x%x. %s runloops
%25s:%-5d ERROR: createRecordQueue: AudioQueueNewInput err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueNewInput err %{audio:4CC}d
%25s:%-5d FAILED createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d createRecordQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueSetProperty(kAudioConverterSampleRateConverterQuality, Max) err %{audio:4CC}d
%25s:%-5d ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueGetProperty(StreamDescription) err %{audio:4CC}d
%25s:%-5d AQGetProperty - kAudioQueueDeviceProperty_NumberChannels returned : %u
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_IsRunning) err %{audio:4CC}d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAddPropertyListener(kAudioQueueProperty_ConverterError) err %{audio:4CC}d
%25s:%-5d createRecordQueue: createAudioConverter error: %d. Destroying record queue.
%25s:%-5d AudioConverter is not created.. reason: requested channels is 1 or requested interleaved audio or non-lpcm is requested
%25s:%-5d FrameCapacity: %d. Buffer duration: %f s
%25s:%-5d createRecordQueue: creating %u queue buffers %u bytes each
%25s:%-5d ERROR: createRecordQueue: AudioQueueAllocateBuffer err %d
%25s:%-5d ERROR: createRecordQueue: AudioQueueAllocateBuffer err %{audio:4CC}d
%25s:%-5d Creating AVAudioPCMBuffer with frameCapacity: %d. Buffer duration: %f s
%25s:%-5d Unexpected Format found.. 
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterSampleRateConverterQuality err %{audio:4CC}d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterEncodeBitRate err %{audio:4CC}d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterPropertyBitDepthHint err %{audio:4CC}d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %d
%25s:%-5d ERROR: configureRecordConverterFromSettings: kAudioConverterCodecQuality err %{audio:4CC}d
%25s:%-5d createAudioConverter: INITIAL AUDIOCONVERTER OUTPUT FORMAT:
%25s:%-5d inASBD : %s
%25s:%-5d ERROR: createAudioConverter: AudioConverterNew err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterNew err %{audio:4CC}d
%25s:%-5d createAudioConverter: initial frames per buffer = dur %.2f * sr %.2f = %u
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertySpeexEncodeComplexity) err %{audio:4CC}d
%25s:%-5d createAudioConverter: corrupted values??? framesPerBuffer = %u, mRecordBufferDuration = %f
 ASSERTION FAILURE: mFramesPerPacket cannot be zero!
%25s:%-5d createAudioConverter: setting audio converter format to %u frames per packet
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterSetProperty(kAudioCodecPropertyCurrentOutputFormat) err %{audio:4CC}d
%25s:%-5d createAudioConverter: %u atomic blocks per second
%25s:%-5d kAudioConverterCurrentOutputStreamDescription ASBD's are different !! 
%25s:%-5d createAudioConverter: encoded audio needs minimum of %u bytes per output buffer
%25s:%-5d createAudioConverter: AudioConverterGetProperty(kAudioConverterPropertyMinimumOutputBufferSize) returned status %d
%25s:%-5d createAudioConverter: final framesPerBuffer: %u
%25s:%-5d createAudioConverter: mConvertPacketCount: %u
%25s:%-5d ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %d
%25s:%-5d ERROR: createAudioConverter: AudioConverterGetProperty(MaximumOutputPacketSize) err %{audio:4CC}d
%25s:%-5d createAudioConverter: outputSizePerPacket: %u
%25s:%-5d createAudioConverter: mConvertAudioCapacity %u bytes
%25s:%-5d FINAL RECORD FORMAT:
%25s:%-5d %s
%25s:%-5d AVVC - Cannot use DSP Graph. 
%25s:%-5d AVVC - Graph is already setup. Starting and stopping the engine/dsp
%25s:%-5d AVVC - failed to restart AVAudioEngine: %@
%25s:%-5d AVVC - Setting up DSPGraph
%25s:%-5d Exception thrown while attempting to initialize AUDSPGraph: %s
%25s:%-5d Failed to instantiate AUDSPGraph
%25s:%-5d Failed to setup DSPGraph text file: %d
%25s:%-5d dspGraphFilepath: %@
%25s:%-5d Failed to read contents of DSPGraph AUStrip file: %@
%25s:%-5d Failed to setup DSPGraph AUStrip file: %d
%25s:%-5d AVVC: AVAudioEngine EnableManualRenderingMode Offline
%25s:%-5d AVVC: Failed to EnableManualRenderingMode on AVAudioEngine: %@
%25s:%-5d AVVC: AVAudioEngine SetManualRenderingInputPCMFormat
%25s:%-5d AVVC: AVAudioEngine input rendering block call with numFrames: %d
%25s:%-5d AVVC: failed to set AVAudioEngine input rendering block
%25s:%-5d AVVC: Making AVAudioEngine node connections
%25s:%-5d mRecordASBD = %s
%25s:%-5d numFrames = %d
%25s:%-5d AVAE input format = %s
%25s:%-5d AVAE output format = %s
%25s:%-5d DSPGraph input format = %s
%25s:%-5d DSPGraph output format = %s
%25s:%-5d AVVC: Starting AVAudioEngine with desc = %s
%25s:%-5d AVVC: Failed to start AVAudioEngine: %@
%25s:%-5d Done setting up DSPGraph
%25s:%-5d Device is built in device (%@)- update channel count
%25s:%-5d AudioQueue startRecording: record state already started or stopping -- no-op
 ASSERTION FAILED: some buffers already enqueued!
%25s:%-5d startRecordQueue: enqueing %d buffers
%25s:%-5d ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %d
%25s:%-5d ERROR: startRecordQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%25s:%-5d #### Starting record queue immediately ####
%25s:%-5d #### Starting record queue at time %llu ####
%25s:%-5d AVVC starting record queue%s at (%s) hosttime (%lld) 
%25s:%-5d ERROR: startRecordQueue: AudioQueueStart err %d
%25s:%-5d ERROR: startRecordQueue: AudioQueueStart err %{audio:4CC}d
%25s:%-5d stopRecordQueue: mRecordIsStopping set to true
%25s:%-5d stopRecordQueue: AudioQueueStop%s err(%s)
%25s:%-5d Calling destroyRecordEngine
%25s:%-5d destroyRecordEngine: mRecordIsStopping set to true
%25s:%-5d destroyRecordEngine: about to call AudioQueueStop(..., true)
%25s:%-5d AVVC stopped record queue%s (%d)
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueStop err %d
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueStop err %{audio:4CC}d
%25s:%-5d destroyRecordEngine:  calling doneRecording by hand
%25s:%-5d destroyRecordEngine:  skipping doneRecording call because we are deallocating
 ASSERTION FAILED: queue was running when destroyed but not asked to stop
%25s:%-5d destroyRecordEngine: about to call AudioQueueDispose(..., true)
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueDispose err %d
%25s:%-5d ERROR: destroyRecordEngine: AudioQueueDispose err %{audio:4CC}d
%25s:%-5d destroyRecordEngine: mRecordIsStopping set to false
%25s:%-5d destroyRecordEngine: about to destroy audio converter
%25s:%-5d ERROR: destroyRecordEngine: AudioConverterDispose err %d
%25s:%-5d ERROR: destroyRecordEngine: AudioConverterDispose err %{audio:4CC}d
%25s:%-5d Deleting old DSPGraph...
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %d
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_EnableLevelMetering) err %{audio:4CC}d
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %d
%25s:%-5d ERROR: enableMetering: AudioQueueSetProperty(kAudioQueueProperty_InstantaneousMetering) err %{audio:4CC}d
%25s:%-5d AVVCAudioQueueRecordingEngine: Record queue does not exist to enable metering. Caching, and will enable during prepare
%25s:%-5d AVVCAudioQueueRecordingEngine: Enable Metering?: %d
%25s:%-5d AVVCAudioQueueRecordingEngine::updateMeterLevels: not fetching meter levels because one of them is untrue! mMeteringEnabled(%d), mRecordQueue(%d), mRecordMeters(%d)
%25s:%-5d AVVCAudioQueueRecordingEngine::updateMeterLevels: Error! In fetching meter levels. Sending 'no signal'. Error(%d)
%25s:%-5d nChannel:%d, startChannel:%d, mClientAudioBufferList->mBuffers[nChannel+startChannel].mData : %p
%25s:%-5d AudioConverterConvertComplexBuffer failed with error : %d
%25s:%-5d handleRecordAQPropertyChange: queue already destroyed -- noop
%25s:%-5d handleRecordQueuePropertyListener (%p): Stream State: %s. AQ Running: %d
%25s:%-5d Record Listener: RUNNING
%25s:%-5d Record Listener: RUNNING-PAUSED
%25s:%-5d Record Listener: STOPPED
%25s:%-5d Record Listener: Converter error: %s
%25s:%-5d (%p) - First callback from AQ -  inStartTime: ht %lld st %lld, Now: ht %lld, SiriRequestedStartTime: ht %lld. Now-SiriRequestedStartTime: %0.6f ms. AQ difference: %0.6f ms
%25s:%-5d handleRecordAQInput: sample time: %f, host time %llu, %llu frames (%d bytes), %d buffers enqueued
%25s:%-5d handleRecordAQInput: record internally stopped, so throwing away buffer
%25s:%-5d handleRecordAQInput: throwing away zero-length buffer
%25s:%-5d handleRecordAQInput: AVAudioEngine renderOffline returned SUCCESS
%25s:%-5d handleRecordAQInput: Error in AVAudioEngine renderOffline : %@
%25s:%-5d handleRecordAQInput: encoder input: packetsAvailable: %u
%25s:%-5d handleRecordAQInput: encoder input buffer %p: %u bytes, %u packets
%25s:%-5d handleRecordAQInput: handing to converter: encoder output buffer: %u bytes, ioOutputDataPackets = %u
%25s:%-5d handleRecordAQInput: err %s, got from converter %u encoded packets, %u bytes.  totalOutputByteSize = %u
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %d
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterFillComplexBuffer err %{audio:4CC}d
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %d
%25s:%-5d ERROR: handleRecordAQInput: AudioConverterGetProperty('ssql') err %{audio:4CC}d
%25s:%-5d handleRecordAQInput: sending %u bytes of encoded data (addr %p) to client with %u packet descs @time %llu
%25s:%-5d Re-enqueuing buffer %p (data ptr %p), size %u
 ASSERTION FAILED: AQ enqueue error while actively recording
%25s:%-5d ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %d
%25s:%-5d ERROR: handleRecordAQInput: AudioQueueEnqueueBuffer err %{audio:4CC}d
%25s:%-5d Exiting handleRecordAQInput (%d buffers enqueued)
%25s:%-5d setSessionIsRecordingFlag: Failed at enableSiriListeningMode(%u) with error: %d
%25s:%-5d doneRecording: resetting record queue
%25s:%-5d UpdateRecordDeviceOnQueue : AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice) - %@
%25s:%-5d UpdateRecordDeviceOnQueue: AudioQueueSetProperty(kAudioQueueProperty_CurrentDevice - %d)
%25s:%-5d AVVCAudioQueueRecordingEngine::getRecordRoute : Cached record route is nil!
%25s:%-5d RecordEncoderInputDataProc: ENTRY: *ioNumberDataPackets passed in: %u, packets remaining: %u, bytes already consumed: %u
%25s:%-5d RecordEncoderInputDataProc: End of stream -- handing back zero size buffer
%25s:%-5d RecordEncoderInputDataProc: Handing back ioData buffer %p of size %u
 ASSERTION FAILED: packetsRead <= packetsAvailable!
%25s:%-5d RecordEncoderInputDataProc: EXIT: *ioNumberDataPackets passed back out: %u, status: %s
Could not load AXSpeechImplementation: %@
%25s:%-5d setDuckOthersOption: %d. session state => %s
%25s:%-5d Error (prev Assertion Failure): Calling setDuckOthersOption on an unconfigured session
%25s:%-5d setDuckOthersOption: done : error : %d
%25s:%-5d Resetting miniducking
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: ATVRemoteSiri -- setting Playback category and Duck/Mix Options.
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: iMessage -- setting P&R category, clearing preferred input, etc.
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant: NO err %{audio:4CC}d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession clearInputPreferences: err %{audio:4CC}d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode carplaySupportsMixableSiri: %d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: category, mode and options are the same..
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: (%ld) mode. Options to set: %ld
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: AVAudioSession setCategory:error: err %{audio:4CC}d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setIAmTheAssistant err %{audio:4CC}d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: forcing %.2f audio for car audio
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %d
%25s:%-5d ERROR: setSessionCategoryModeOptionsAndSampleRateFromMode: setPreferredSampleRate err %{audio:4CC}d
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: SR changes from %f to %f
%25s:%-5d setSessionCategoryModeOptionsAndSampleRateFromMode: SR remains at %f
%25s:%-5d audioSessionForStreamID(%d) couldn't find engine, returning nil
%25s:%-5d ASSERTION FAILED: calling setSessionProperties on a configured session. Crashing process!.
%25s:%-5d setSessionProperties: done
%25s:%-5d mIsUsingV2API(%d)
%25s:%-5d QueueRunLoop started
%25s:%-5d Failed to start queue's run loop thread
%25s:%-5d Setting duck-others AudioSession option for CarPlay
%25s:%-5d ControllerImpl::Entering Dealloc
%25s:%-5d QueueRunLoop stopped
%25s:%-5d ControllerImpl::Exiting Dealloc
%25s:%-5d setNoResumeOnDeactivate(TRUE): will not notify others on deactivation
%25s:%-5d setNoResumeOnDeactivate(FALSE): will notify others on deactivation
%25s:%-5d setActivationMode: voice activation
%25s:%-5d setActivationMode: post-voice activation
%25s:%-5d setActivationMode: iMessage nudge
%25s:%-5d setActivationMode: iMessage gesture to head
%25s:%-5d setActivationMode: ATVRemoteSiri
%25s:%-5d setActivationMode: standard value (%s)
%25s:%-5d setActivationMode: Cannot revert from mode %s to mode %s while audio session is active
%25s:%-5d setActivationModeAndSessionHWControlFlagsAndOptions: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%25s:%-5d setActivationMode: will not take control of hardware for appletv upon activation
%25s:%-5d setActivationMode: will not take control of hardware upon activation for AirPlay output
%25s:%-5d setActivationMode: setting volume required hardware control flag for 'voic' activation mode (ouput is not Airplay)
%25s:%-5d ERROR: setActivationMode : Failed at setAudioHardwareControlFlags: %s
%25s:%-5d setActivationMode: (hdvc / btdt / cpvc / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%25s:%-5d setActivationMode: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%25s:%-5d setActivationMode: enabling all 4 hw control flags
%25s:%-5d ERROR: Failed at setAudioHardwareControlFlags: %s
%25s:%-5d setActivationMode: Mode already set to %s. No change in AudioSession flags or options
%25s:%-5d deactivateSessionForListening_v1v2() returned error(%@)
%25s:%-5d StreamID(%lu) is not associated with primary session, noop
%25s:%-5d deactivateSessionForListening: Error! Attemtping to deactivate a session that is not configured.
%25s:%-5d #### AVVoiceController: Deactivating session with notify ####
%25s:%-5d deactivateSessionForListening: in process of being destroyed -- kill the alert queue
%25s:%-5d deactivateSessionForListening: resetting alert queue
%25s:%-5d ERROR: setSessionActive(false): ignoring AudioQueueReset err %d
%25s:%-5d ERROR: setSessionActive(false): ignoring AudioQueueReset err %{audio:4CC}d
%25s:%-5d deactivateSessionForListening: alert state %s -- deactivating session in alertFinished
%25s:%-5d getDeviceUIDForHomeOrBluetoothButtonActivation : siriInputSource(%@), siriRemoteID(%@)
%25s:%-5d handlePluginDidPublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%25s:%-5d handlePluginDidUnpublishDevice notification for plugin(%p), device(%p), deviceID(%@)
%25s:%-5d Context is nil. can't decide what recording engine need to be created
%25s:%-5d switching to %{audio:4CC}d mode - keeping the same recording engine [%@]
%25s:%-5d ** !!! Invalid engine type creation !!! 
%25s:%-5d current recording engine - %@. type: %s
%25s:%-5d getRecordAndPlaybackRoutes_v1v2: Cannot find recording engine for streamID(%lu). Returning.
%25s:%-5d setActivationContext setting audio session activation context to: %@
%25s:%-5d setActivationContext: HACK: ignore switch away from RemoteSiri
%25s:%-5d setActivationContext: 'live' switch out of VoiceActivated -- reset session properties
%25s:%-5d setActivationContext: switching in/out of CarAudio -- reset session properties
%25s:%-5d setActivationContext: switching out of iMessage -- reset session properties
%25s:%-5d ERROR: setActivationContext: AVAudioSession setActivationContext err %s, session id:0x%x
%25s:%-5d setActivationContext: done setting audio session activation context
%25s:%-5d setActivationContext: finish 'live' switch by re-activating active session setActive:TRUE, session options : %d
%25s:%-5d ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %d
%25s:%-5d ERROR: setActivationContext: [AVAudioSession setActive:withOptions:error] err %{audio:4CC}d
%25s:%-5d setActivationContext: session re-activated -- calling getSessionProperties
%25s:%-5d setActivationContext: session is active and mode changed -- calling getSessionProperties
%25s:%-5d setActivationContext: session is inactive -- route change notification or setSessionActive should generate a call to getSessionProperties
%25s:%-5d %s: audio session is inactive or had been interrupted
%25s:%-5d %s: rebuilding alert queue
%25s:%-5d %s: calling prepare instead of create record queue
%25s:%-5d %s - setSessionActive(false): session state already %s -- forcing deactivation
%25s:%-5d deactivate session (%p) (session mananger (%p))
%25s:%-5d ERROR: %s setActive:FALSE withOptions: err %s
%25s:%-5d #### AVVoiceController: %s - error ####
%25s:%-5d #### AVVoiceController: %s - error AVAudioSessionErrorCodeMediaServicesFailed ####
%25s:%-5d ERROR: setSessionActive: setActive: FALSE - err = %s, session id:0x%x
%25s:%-5d setSessionActive: We have to wait for the session to be (re-)initialized
%25s:%-5d setSessionActive: (re-)init done!
%25s:%-5d setSessionActive: waiting...
%25s:%-5d ERROR: setSessionActive: Timed out waiting for mediaserverd err %d
%25s:%-5d #### AVVoiceController: Activating session ####
%25s:%-5d setSessionActive: setActive: TRUE for prewarming did not succeed
%25s:%-5d setSessionActive: setActive: TRUE for prewarming did not succeed and returned err: %d
%25s:%-5d ERROR: setSessionActive: setActive: TRUE for prewarming err %d
%25s:%-5d ERROR: setSessionActive: setActive: TRUE for prewarming err %{audio:4CC}d
%25s:%-5d setSessionActive: Activating : session options : %d
%25s:%-5d ERROR: setSessionActive: setActive: TRUE - err = %s, session id:0x%x
%25s:%-5d setSessionActive(true): Route change when we went active: %s -- getting properties
%25s:%-5d setSessionActive(false): destroying record queue
%25s:%-5d ERROR: setSessionActive(false): ignoring destroyRecordQueue err %d
%25s:%-5d ERROR: setSessionActive(false): ignoring destroyRecordQueue err %{audio:4CC}d
%25s:%-5d setSessionActive(false): in process of being destroyed -- kill the alert queue
%25s:%-5d setSessionActive(false): resetting alert queue
%25s:%-5d setSessionActive(false): alert state %s -- deactivating session asynchronously (NOT HERE) check alertFinished
%25s:%-5d #### setEndpointerDelegate: using %s endpointer ####
%25s:%-5d setupEndpointer: configuring SR and wait times
%25s:%-5d calculateRecordStartTime: Error, current recording engine is nil!
%25s:%-5d WARNING: startRecordingAtTime:error was used without 'silent' start alert
%25s:%-5d calculateRecordStartTime: queue plus HW delay time: %f seconds
%25s:%-5d calculateRecordStartTime: host time for start of record: %.3f seconds
%25s:%-5d this is %lld ticks beyond alert end (%.6f seconds in the future)
%25s:%-5d configureAlertModeFromModeAndEngine: Nil recording engine. Abandon ship!
%25s:%-5d configureAlertModeFromModeAndEngine: Wired headset output - disable ZLL
%25s:%-5d configureAlertModeFromModeAndEngine: record start time was set -- check for ZLL
%25s:%-5d configureAlertModeFromModeAndEngine: ZLL query - back frames: %u
%25s:%-5d configureAlertModeFromModeAndEngine: CarPlay supports ZLL. recordStartTime : %llu
%25s:%-5d ZLL query result %d, backFramesAvailable: %u. Clearing start record time
%25s:%-5d configureAlertModeFromModeAndEngine: record start time not set
%25s:%-5d configureAlertModeFromModeAndEngine: HomeButtonPress/UIButtonPress
%25s:%-5d configureAlertModeFromModeAndEngine: %s
%25s:%-5d configureAlertModeFromModeAndEngine: no vibrator support and no ZLL
%25s:%-5d configureAlertModeFromModeAndEngine: Built-In/BT/CarPlay Voice Activation
%25s:%-5d configureAlertModeFromModeAndEngine: VoiceTriggerTraining
%25s:%-5d configureAlertModeFromModeAndEngine: iMessage
%25s:%-5d configureAlertModeFromModeAndEngine: default
%25s:%-5d configureAlertModeFromModeAndEngine: [final alert modes, overrides] : Start[%s, %s], Stop[%s, %s], StopWError[%s, %s])
%25s:%-5d stopRecordWithRecordLock returned error : %d
%25s:%-5d attempt to stop recording but no current eng for streamID(%lu)
%25s:%-5d waitForAllStopRecordCompletion_v1v2: wait for all didStops to be delivered to the client
%25s:%-5d Engine Map does not exist
%25s:%-5d playAlert: alertType = %d, primeFirst=true
%25s:%-5d playAlert: using SSS to play haptic (or silence)
%25s:%-5d playAlert: alert %d already in progress -- stop it now
%25s:%-5d playAlert: silent start - fake a SS completion callback
%25s:%-5d playAlert: non-blocking SSS alert for Siri startup
%25s:%-5d playAlert: silent stop - fake a SS completion callback
%25s:%-5d playAlert: calling AudioServicesPlaySystemSoundWithOptions with sound ID %u and flags %x
%25s:%-5d playAlert: using alert queue to play beep
%25s:%-5d playAlert: alert playback failed -- attempting to re-prime
%25s:%-5d playAlert: Some Error occured! Not calling startAlertQueue() : %d
%25s:%-5d ERROR: createAlertQueue: AudioQueueNewOutput err %d
%25s:%-5d ERROR: createAlertQueue: AudioQueueNewOutput err %{audio:4CC}d
%25s:%-5d FAILED createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d createAlertQueue : AudioQueueSetProperty(kAudioQueueProperty_ClientUID) - %@
%25s:%-5d ERROR: createAlertQueue: AudioQueueAddPropertyListener err %d
%25s:%-5d ERROR: createAlertQueue: AudioQueueAddPropertyListener err %{audio:4CC}d
 ASSERTION FAILED: re-entrant request for different alert type
%25s:%-5d primeAlertQueue: alert queue state '%s'.  reentrant or multi-threaded call -- returning
%25s:%-5d primeAlertQueue: queue is NULL -- returning
%25s:%-5d primeAlertQueue: type %d (current is %d)
%25s:%-5d primeAlertQueue: sync-stopping active alert queue
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueStop err %d
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueStop err %{audio:4CC}d
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueReset err %d
%25s:%-5d ERROR: primeAlertQueue: ignoring AudioQueueReset err %{audio:4CC}d
%25s:%-5d primeAlertQueue: silent/haptic alert: not queueing a buffer
%25s:%-5d ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %d
%25s:%-5d ERROR: primeAlertQueue: AudioQueueEnqueueBuffer err %{audio:4CC}d
%25s:%-5d primeAlertQueue: done. current is now %d
%25s:%-5d primeAlertQueue: no-op
%25s:%-5d setupAlert: NULL alert URL
%25s:%-5d ERROR: setupAlert: ExtAudioFileOpenURL err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileOpenURL err %{audio:4CC}d
%25s:%-5d setupAlert: Failed to load alert '%s'
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty(kExtAudioFileProperty_FileDataFormat) err %{audio:4CC}d
%25s:%-5d ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileSetProperty(kExtAudioFileProperty_ClientDataFormat) err %{audio:4CC}d
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileGetProperty err %{audio:4CC}d
%25s:%-5d setupAlert: resetting alert queue
%25s:%-5d ERROR: setupAlert: AudioQueueAllocateBuffer err %d
%25s:%-5d ERROR: setupAlert: AudioQueueAllocateBuffer err %{audio:4CC}d
%25s:%-5d ERROR: setupAlert: ExtAudioFileRead err %d
%25s:%-5d ERROR: setupAlert: ExtAudioFileRead err %{audio:4CC}d
%25s:%-5d getRecordErrorStatus: Current recording engine is nil!
 ASSERTION FAILED: no alert buffer is enqueued!
%25s:%-5d startAlertQueue: calling AudioQueueStart
%25s:%-5d AVVC started alert queue%s (%d)
%25s:%-5d ERROR: startAlertQueue: AudioQueueStart err %d
%25s:%-5d ERROR: startAlertQueue: AudioQueueStart err %{audio:4CC}d
%25s:%-5d ERROR: startAlertQueue: AudioQueueStop(async) err %d
%25s:%-5d ERROR: startAlertQueue: AudioQueueStop(async) err %{audio:4CC}d
 ASSERTION FAILED: alert queue NULL but state != Uninitialized
%25s:%-5d detected unfinished alert, queue up alertFinished
%25s:%-5d destroyAlertQueue: calling AudioQueueStop
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueStop() err %d
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueStop() err %{audio:4CC}d
%25s:%-5d destroyAlertQueue: removing queue listener
%25s:%-5d destroyAlertQueue: calling AudioQueueDispose
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueDispose err %d
%25s:%-5d ERROR: destroyAlertQueue: AudioQueueDispose err %{audio:4CC}d
%25s:%-5d calculateAlertTimes: alert queue already stopped -- using current time as end time
%25s:%-5d ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %d
%25s:%-5d ERROR: calculateAlertTimes: AudioQueueGetCurrentTime err %{audio:4CC}d
%25s:%-5d alertStarted: record state != kRecordStarting -- noop
%25s:%-5d alertStarted: not playing start alert -- noop
%25s:%-5d alertFinished
%25s:%-5d alertFinished: state = %s mRecordState: %s -- not priming alert
%25s:%-5d alertFinished: deactivating session -- finishing the job
%25s:%-5d ERROR: alertFinished: setActive:FALSE withOptions: err %d
%25s:%-5d ERROR: alertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%25s:%-5d Alert Listener: impl or queue is NULL or object is being destroyed -- noop
%25s:%-5d Alert Listener: in the middle of priming alert queue:  Doing nothing.  [THIS IS NEW BEHAVIOR]
%25s:%-5d Alert Listener: mAlertQueueState = %s
%25s:%-5d Alert Listener: RUNNING = %d
%25s:%-5d Alert Listener: session was interrupted!  Doing nothing here
%25s:%-5d Alert Listener: state already kAlertQueueRunning.  Doing nothing here
%25s:%-5d Alert Listener: Session is inactive, alertFinishedPlayback already synthesized in deactivateSession.
%25s:%-5d Alert Listener: queue reports stopped on first IsRunning prop notification -- treat this like a regular start
%25s:%-5d Alert Listener: unhandled inID %s
%25s:%-5d vibeStartAlertFinished: Could not find engine for streamID(%lu)
%25s:%-5d vibeStartAlertFinished: record state != kRecordStarting -- noop
%25s:%-5d vibeStopAlertFinished: deactivating session -- finishing the job
%25s:%-5d ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %d
%25s:%-5d ERROR: vibeStopAlertFinished: setActive:FALSE withOptions: err %{audio:4CC}d
%25s:%-5d VibeAlertCompletionProc: SSID %u done
%25s:%-5d VibeAlertCompletionProc -> called after object destroyed -- ignoring call
%25s:%-5d VibeAlertCompletionProc: object being destroyed -- bailing out
%25s:%-5d VibeAlertCompletionProc: notified for other ssID %d -- no-op
%25s:%-5d checkForEndpoint entered: inBuffer %p
%25s:%-5d calling startpointDetected synchronously
%25s:%-5d calling interspeechPointDetected synchronously 
%25s:%-5d #### AVVoiceController: Detected end point but NO START POINT ####
%25s:%-5d checkForEndpoint: auto-stopping record
%25s:%-5d calling endpointDetected synchronously
%25s:%-5d checkForEndpoint exiting
%25s:%-5d Record Listener: handling deferred context change
%25s:%-5d AVVoiceController -> Interruption beginning for %s session (%p) info: %@
%25s:%-5d   We think our session was not active.  Make sure it isn't. deactivating session with options : %d
%25s:%-5d deactivating session returned  : %d - error - %@
%25s:%-5d   Record was active
%25s:%-5d   Nothing active
%25s:%-5d AVVoiceController -> Interruption ending for %s session (%p) info: %@
%25s:%-5d   Interrupt for aux session unexpected
%25s:%-5d   No longer reactivating audio session on interrupt end
%25s:%-5d   Was interrupted during recording -- stopping queue on resume
 Record should never be active when interrupt is ending!
%25s:%-5d   We were never interrupted to begin with!
%25s:%-5d AVVoiceController -> Route Change for %s session (%p)
%25s:%-5d   Route change for aux session unexpected
%25s:%-5d Route change reason : [%d] = %s
%25s:%-5d Route really changed -- Re-checking properties
%25s:%-5d Route really changed but session not-yet-active/interrupted -- set flag to check properties when we are active
%25s:%-5d New route Category is not ours!
%25s:%-5d We were waiting for a route change -- Re-checking properties
%25s:%-5d Route change reason: category change - ignoring
%25s:%-5d Nil Engine! Could not get session properties
%25s:%-5d Category change came in while we were %s -- ignoring
%25s:%-5d Route change reason: route configuration change - ignoring
%25s:%-5d Route change reason was NULL
%25s:%-5d AVVoiceController -> Server died!
%25s:%-5d ControllerImpl::handleServerDeath: object being destroyed -- bailing out
%25s:%-5d ControllerImpl::handleServerDeath: session is not configured
%25s:%-5d ControllerImpl::handleServerDeath: Destroying internal state for later rebuild
%25s:%-5d AVVoiceController -> Server reset after death
%25s:%-5d ControllerImpl::handleServerReset: object being destroyed -- bailing out
%25s:%-5d ControllerImpl::handleServerReset: restoring activation context and resetting session properties
%25s:%-5d Fail! Unable to load RegisterAudioUnits_Internal from libAudioDSP.dylib.
%25s:%-5d Calling RegisterAudioUnits_Internal from libAudioDSP.dylib
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: %@ requested. ignoring the device id and use built in device - %@. 
%25s:%-5d setContext: ERROR! No recording engine associated with device for post/auto activation context
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Darwin activation (%@) requested with nil deviceUUID
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with nil deviceUUID
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Plugin activation (%@) requested with deviceUUID - %@. 
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: Ambigous activation (%@) requested with deviceUUID - %@. EngineType : %d
%25s:%-5d setContext:getEngineTypeAndDeviceIDToUse: returned error - %d for activation mode(%@)
%25s:%-5d setContext: Engine lookup returned nil!
%25s:%-5d Found matching engine[%@] of type(%s) for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d _createRecordingEngineWithParameters : Fatal Error! Invalid engine type!
%25s:%-5d setContext: Reusing (%s) engine[%@] for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d setContext: Created new (%s) engine[%@] for activation mode(%@) and deviceUID(%@) with streamHandle(%lu)
%25s:%-5d nil object encountered (avvc: %p, impl: %p). Bailing
%25s:%-5d calling (v2) voiceControllerLPCMAudioCallback:forStream:buffer:
%25s:%-5d calling (v2) voiceControllerAudioCallback:forStream:buffer:
%25s:%-5d calling lpcmRecordBufferReceived:buffer
%25s:%-5d calling voiceControllerRecordBufferAvailable:buffer
%25s:%-5d Configured completion blocks for engine[%@]
%s Likely ambiguous AVVC V2 use case detected. Must pass streamID here: %s ! (or V1 engine map integrity problem). numMapEngs(%lu) v1PluginEngInvalid(%d) v1AudioQueueEngInvalid(%d) v1ValidCase(%d) v2AmbiguousCase(%d)
%25s:%-5d ASSERTION FAILURE [!streamIDViolation is false]: Likely ambiguous AVVC V2 use case detected. Must pass streamID here %s ! (or V1 engine map integrity problem)
%25s:%-5d ASSERTION FAILURE [eng != nullptr is false]: V1 engine map integrity problem. Couldn't find engine in map.
%25s:%-5d _invalidateStreamWhenDeviceUnavailable_v1v2()
%25s:%-5d VSPD is not present, removing engine associated with BuiltInStream
%25s:%-5d Engine for streamID(%llu) not found.
%25s:%-5d removeEngineFromMapWithStreamID: engine[%@] stream(%llu) 
%25s:%-5d Stopping recording here, engine's remote device has been disconnected.
%25s:%-5d DelegateDispatchGroup wait timed out after %f seconds
%25s:%-5d dispatch_async(mClientNotificationQueue) %s
%25s:%-5d calling %s synchronously
%25s:%-5d dispatch_sync(mClientNotificationQueue) %s
%25s:%-5d before barrier
%25s:%-5d mWorkQueue barrier
%25s:%-5d mClientNotificationQueue barrier
%25s:%-5d mDispatchQueue barrier
%25s:%-5d after barrier
%25s:%-5d after resume
%25s:%-5d session state(streamID %d) => %s
%25s:%-5d alert state => %s
%25s:%-5d Interrupting recording on engine[%@] with streamID(%llu)
%25s:%-5d Stopping the recording on stream(%lu) due to a category change
%25s:%-5d NOTE: AVVC Details logging is turned on by default for development
%25s:%-5d debug_encoding on
%25s:%-5d debug_endpoint on
%25s:%-5d debug_callbacks on
%25s:%-5d debug_locking on
%25s:%-5d debug_state on
%25s:%-5d debug_trace on
%25s:%-5d debug_timing on
%25s:%-5d debug_delegate on
%25s:%-5d debug_playback on
%25s:%-5d debug_deviceselect on
%25s:%-5d debug_level = %d
%25s:%-5d resetting debug_level to Notify to allow scoped logging
%25s:%-5d debug priority: %u scopes: 0x%llx
%25s:%-5d logAndReturnIfAudioSessionIsNotAvailable-%s returning : %d
%25s:%-5d ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeOptions failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setIAmTheAssistant failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setAllowHapticsAndSystemSoundsDuringRecording failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setupOneTimeSessionSettings setCategoryModeRouteSharingPolicyOptions failed with error: %@
%25s:%-5d AVVCSessionManager::setSessionActivationContext : passed 'nil' dictionary, creating empty one.
%25s:%-5d ERROR: AVVCSessionManager::setActivationContext of sessionID(0x%x) failed with error: %@
%25s:%-5d shouldEnableMiniDucking on AppleTV. Not available for now
%25s:%-5d enableMiniDucking: Called on HomePod like device, no-op
%25s:%-5d shouldEnableMiniDucking: No change, no-op
%25s:%-5d shouldEnableMiniDucking: Announce calls enabled. Will not set session properties while disabling miniDucking
%25s:%-5d pickedRoute from AudioSession: %@
%25s:%-5d isSomeOtherAudioPlaying: %d
%25s:%-5d Non-BT route OutputSupportsVolume: %d
%25s:%-5d shouldDuckOthers(%d), sessionNeedsVolumeControl(%d)
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions on 'audioOS'. Duck others.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions on older watchOS. Interrupt others.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: (wireless splitter mode). Interrupt others.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: ATV Activation  -- setting Playback category and Duck/Mix Options.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: iMessage -- setting P&R category, clearing preferred input, etc.
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: Carplay Supports Mixable Siri
%25s:%-5d AVVCSessionManager::setSessionCategoryModeOptions: announce mode for %s context - duck others
%25s:%-5d AVVCSessionManager : category, mode and options are the same (Current activation: %d, Previous activation: %d). No-op
%25s:%-5d AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x. (Current activation: %d, Previous activation: %d)
%25s:%-5d ERROR: AVVCSessionManager : setCategoryModeRouteSharingPolicyOptions failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::clearInputPreferences failed with error: %@
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (ATV + Plugin) : %@
%25s:%-5d setSessionAudioHWControlFlags: Take Audio HW control on tvOS
%25s:%-5d setSessionAudioHWControlFlags: iOS Audio Accessory Product (HomePod), setting volume desired HW control flag.
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (HomePod) : %@
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags on older watch hardware: will never take control of HW on activation
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: wireless splitter mode, no volume control, yes routing control.
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (wireless splitter) : %@
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: disable mini-ducking. Set all HW control flags
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags (disable mini-ducking) : %@
%25s:%-5d AVVCSessionManager::setAudioHardwareControlFlags: announce mode for %s context - don't set HW control flags
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: will not take control of hardware upon activation for AirPlay output (voic/rais)
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: setting volume/routing required hardware control flag for 'voic' activation mode (output is not Airplay)
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : set all hw control flags
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: (plugin activation context / (post->hdvc) : setting 3 out of 4 (no volume) hw control flags
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: post followed by BluetoothVoiceTrigger (or auto context) should not control volume, so not setting any hw control flags.
%25s:%-5d AVVCSessionManager::setSessionAudioHWControlFlags: default mode - set all HW control flags
%25s:%-5d ERROR: AVVCSessionManager::setAudioHardwareControlFlags : %@
%25s:%-5d setSessionSampleRateFromActivationMode: forcing 22050k audio for car audio
%25s:%-5d ERROR: AVVCSessionManager::setPreferredSampleRate for VehicleButtonPress : %@
%25s:%-5d setSessionSampleRateFromActivationMode: SR changes from %f to %f
%25s:%-5d ERROR: AVVCSessionManager::setPreferredSampleRate to %f : %@
%25s:%-5d setSessionSampleRateFromActivationMode: SR remains at %f
%25s:%-5d ERROR: AVVCSessionManager::setSessionBufferSize failed: %@
%25s:%-5d AVVCSessionManager::setSessionBufferSize: Current size: %d
%25s:%-5d AVVCSessionManager : Setting %@ category, %@ mode, 0x%x options. Current category: %@, mode: %@, options: 0x%x
%25s:%-5d Error in setDuckOthers:mixWithOthers %d, %@
%25s:%-5d AVVCSessionManager: category mode and options are same. No op
%25s:%-5d Error in setDuckingFadeDuration %d, %@
%25s:%-5d ERROR: AVVCSessionManager::enableSmartRoutingConsideration failed: %@
%25s:%-5d Output Port[%d / %d] : %@
%25s:%-5d %@: session options : %d
%25s:%-5d %@ succeeded error: %s, session id:0x%x
%25s:%-5d %@ failed with error: %s, session id:0x%x
%25s:%-5d deactivateAudioSession: session options : %d
%25s:%-5d deactivateAudioSession succeeded error: %s, session id:0x%x
%25s:%-5d deactivateAudioSession failed with error: %s, session id:0x%x
%25s:%-5d session(%p) state %s => %s
%25s:%-5d isSessionInSiriCategoryModeAndOptions: about to set Play&Record category, speech recognition/assistant mode. Current category: %@, mode: %@, options: 0x%x
%25s:%-5d setRecordingFromRemoteInput: %d
%25s:%-5d Error setting recording from remote input %d, %@
%25s:%-5d isSWVolumeSupportedOnPickedRoute: Picked Route is nil
%25s:%-5d isSWVolumeSupportedOnPickedRoute: %d
%25s:%-5d ~AVVCAudioCapturer(): destroyed
%25s:%-5d AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%25s:%-5d ~AVVCAudioCapturer_AudioDiagnostics(): mCapturer is reset to NULL
%25s:%-5d ~AVVCAudioCapturer_AudioDiagnostics(): destroyed
%25s:%-5d Dumping Audio for stream(%lu) at %s
%25s:%-5d Error setting up audio captures
%25s:%-5d AVVCAudioCapturer:logCapture: logging lpcm audio
%25s:%-5d AVVCAudioCapturer:logCapture: logging non-lpcm audio
%25s:%-5d Error while logging audio: %d
%25s:%-5d mCapturer is reset to NULL
%25s:%-5d *** InitializePlugins *** %p 
%25s:%-5d Plugin Bundle URL: %@
%25s:%-5d initialized plugin class %@
%25s:%-5d Unable to create the plugin bundle
%25s:%-5d dealloc : releasing all plugins *** %p
%25s:%-5d invalidatePlugins : invalidating all plugins *** %p
%25s:%-5d calling invalidate on plugin instance %p
%25s:%-5d Searching plugin path %@
%25s:%-5d Error enumerating the remote input bundles at %@: %@
%25s:%-5d plugin(%p) - device(%p) - id: %@
%25s:%-5d Device(%p). Identifier: %@
%25s:%-5d Cannot find Remote Input device %@
%25s:%-5d findDeviceWithIdentifier: found the device %@
%25s:%-5d Device(%p). Identifier: %@ (num devices = %d)
%25s:%-5d self(%p) controller(%p) plugin(%p), did publish device(%p) with id(%@)
%25s:%-5d ERROR: Received didPublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%25s:%-5d WARNING: Not forwarding didPublish event to AVVC parent because it does not exist, or is deallocating.
%25s:%-5d self(%p) controller(%p) plugin(%p), did UNpublish device(%p) with id(%@)
%25s:%-5d ERROR: Received didUNpublishDevice with 'nil' device. Not forwarding event to AVVC parent.
%25s:%-5d WARNING: Not forwarding didUNpublish event to AVVC parent because it does not exist, or is deallocating.
%25s:%-5d self(%p) controller(%p)
%25s:%-5d couldn't find mock plugin
%25s:%-5d mock plugin endpoint (%@)
%25s:%-5d Error: Unable to call RegisterAudioUnits_Internal from libAudioDSP.dylib.
%25s:%-5d unable to get property kAUDSPGraphProperty_GraphTextFilePath %i
%25s:%-5d unable to get property kAUDSPGraphProperty_AUStrip %i
%25s:%-5d Player@%p: Engine is in the middle of a config change, cannot play yet!
%25s:%-5d Player@%p: Engine could not start the audio hardware dynamically, cannot play!
%25s:%-5d Player@%p: Engine config changed when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: IOUnit stopped when waiting for playback to begin, cannot play yet!
%25s:%-5d Player@%p: Engine returned render error: %ld, node: %p {%s}, cannot play!
%25s:%-5d AVVoiceTriggerClient init %@
%25s:%-5d AVVoiceTriggerClient dealloc %@
%25s:%-5d server crashed
%25s:%-5d server reset
%25s:%-5d server timeout
%25s:%-5d enableVoiceTriggerListening: %s
 CAGuard::CAGuard: Could not init the cond var
 CAGuard::Wait: A thread has to have locked a guard before it can wait
 CAGuard::Wait: Could not wait for a signal
 CAGuard::WaitFor: A thread has to have locked a guard be for it can wait
 CAGuard::WaitFor: Wait got an error
 CAGuard::Notify: failed
 CAGuard::NotifyAll: failed
%25s:%-5d Engine@%p: could not initialize, error = %d
%25s:%-5d Engine#%p: error: couldn't connect mixer to output node!
%25s:%-5d Engine@%p: connect node1: %p (from bus: %lu) -> node2: %p (to bus: %lu), format: %s
%25s:%-5d Engine@%p: connect node: %p (from bus: %lu) ->%s, format: %s
%25s:%-5d Engine@%p: disconnect input bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect output bus: %lu on node: %p
%25s:%-5d Engine@%p: disconnect all inputs on node: %p
%25s:%-5d Engine@%p: disconnect all outputs on node: %p
%25s:%-5d Engine@%p: connect MIDI node: %p -> node: %p, format: %s
%25s:%-5d Engine@%p: connect MIDI node: %p -> %s, format: %s
%25s:%-5d Engine@%p: disconnect MIDI node: %p from node: %p
%25s:%-5d Engine@%p: disconnect MIDI node: %p from nodes: %s
%25s:%-5d Engine@%p: disconnect MIDI inputs on node: %p
%25s:%-5d Engine@%p: disconnect MIDI outputs on node: %p
%25s:%-5d Engine@%p: initialize
%25s:%-5d Engine@%p: uninitialize
%25s:%-5d Engine@%p: start
%25s:%-5d Engine@%p: pause
%25s:%-5d Engine@%p: stop
%25s:%-5d Engine@%p: could not disable manual rendering mode
%25s:%-5d Engine@%p: iounit configuration changed > posting notification
%25s:%-5d Engine@%p: iounit configuration changed < posted notification
%25s:%-5d Engine@%p: iounit configuration changed > setting flag
%25s:%-5d Engine@%p: iounit configuration changed > stopping the engine
%25s:%-5d Engine@%p: iounit stopped unexpectedly > pausing the engine
%25s:%-5d Engine@%p: install tap on node %p, bus%lu, bufferSize %d, format: %s
%25s:%-5d Engine@%p: remove tap from node %p, bus%lu
%25s:%-5d required condition is false: [%s:%d:%s: (%s)]
%25s:%-5d [%s:%d:%s: (%s)] returned %s, error %@
softlink:r:path:/System/Library/Frameworks/AVFoundation.framework/AVFoundation
AVAudioIONode
AVAudioOutputNode
AVAudioInputNode
AVAudioMixing
AVAudioStereoMixing
NSObject
AVAudio3DMixing
AVAudioConnectionPoint
AVVCRecordDeviceInfo
AVVoiceControllerInternal
AVVoiceController_Priv
AVVoiceController
AVAudioRemoteInputPlugin_PrivateTest
AVVCContextSettings
AVVCPrepareRecordSettings
AVVCConfigureAlertBehaviorSettings
AVVCStartRecordSettings
AVVCAlertInformation
AVVCDuckFadeDuration
AVVCDuckOverride
AVVCDuckSettings
AVAudioUnitComponent
SpeexEndpointer
Endpointer
SpeexEndpointer_Priv
AVAudioUnitTimeEffect
AVAudioUnitComponentManager
AVAudioUnitDelay
VoiceVerificationEndpointer
AVAudioUnitVarispeed
AVAudioUnitReverb
AVAudioUnitTimePitch
AudioPlayerImpl
AVAudioPlayerPriv
AVAudioPlayer
AVAudioUnitGenerator
AVVCSessionFactory
AVAudioRecorder
AVAudioSessionParticipant
AVAudioSinkNode
AVAudioChannelLayout
NSSecureCoding
NSCoding
AVSpeechSynthesisProviderVoice
NSCopying
AVSpeechSynthesisProviderRequest
AVSpeechSynthesisProviderAudioUnit
AVAudioDeviceTestServiceProtocol
AVAudioDeviceTest
AVAudioConverter
Encoding
AVVCMetricsManager
AVAudioUnitDistortion
AVAudioMixerNode
AVAudioClock
AVMIDIPlayer
AVMIDIPlayerPriv
AVAudioUnitMIDIInstrument
AVAudioBuffer
NSMutableCopying
AVAudioPCMBuffer
AVAudioCompressedBuffer
AVAudioUnitSplitter
AVAudioUnitEQFilterParameters
AVAudioUnitEQ
AVAudioFormat
AVAudioDeviceTestResult
AVAudioDeviceTestSequence
AVAudioDeviceTestProcessingChain
AVAudioSourceNode
AVSpeechSynthesisVoice
AVSpeechUtterance
AVSpeechSynthesizer
AVSpeechSynthesisMarker
AVVCAudioBuffer
AVVCAudioBufferPriv
AVAudioEnvironmentDistanceAttenuationParameters
AVAudioEnvironmentReverbParameters
AVAudioEnvironmentNode
AVVCSessionManager
AVMusicEvent
AVMIDINoteEvent
AVMIDIChannelEvent
AVMIDIControlChangeEvent
AVMIDIPolyPressureEvent
AVMIDIProgramChangeEvent
AVMIDIChannelPressureEvent
AVMIDIPitchBendEvent
AVMIDISysexEvent
AVMIDIMetaEvent
AVMusicUserEvent
AVExtendedNoteOnEvent
AVParameterEvent
AVAUPresetEvent
AVExtendedTempoEvent
AVAudioFile
AVAudioNode
AVAudioMixingDestination
AVAudioUnitSampler
AVAudioRemoteInputPlugin
AVVCPluginRemoteInputHost
AVAudioRemoteInputPluginDelegate
AVAudioSequencer_Player
AVAudioSequencer
AVMusicTrack
AVMusicTrackEditor
AVMusicTrackEventIterator
AVAudioTime
AVAudioUnitDSPGraph
AVAudioUnitEffect
AVAudioPlayerNode
AVVoiceTriggerClient
AVAudioUnit
AVAudioEngine
setCategory:withOptions:error:
stringByReplacingOccurrencesOfString:withString:
setClasses:forSelector:argumentIndex:ofReply:
initWithUnsignedInteger:
canPerformOutput
setMaximumFramesToRender:
dictionaryWithObjects:forKeys:count:
setFormat:
decodeBytesWithReturnedLength:
auAudioUnitForAudioUnit:
stringByTrimmingCharactersInSet:
dictionaryWithObjectsAndKeys:
numberWithDouble:
fileSystemRepresentation
stringFromDate:
decodeDoubleForKey:
category
principalClass
caseInsensitiveCompare:
numberWithFloat:
setQuality:
fileURLWithPath:
setFormat:error:
setObject:forKey:
parameterTree
stringWithCString:encoding:
isSubsetOfSet:
unionSet:
containsObject:
startHardwareAndReturnError:
whitespaceCharacterSet
numberWithInteger:
allObjects
resume
unsignedIntValue
filteredArrayUsingPredicate:
initWithObjects:count:
categoryOptions
setObject:forKeyedSubscript:
encodeBool:forKey:
stringWithFormat:
decodeFloatForKey:
audioInputBlock
relativePath
initWithObjects:forKeys:count:
decodeIntegerForKey:
encodeBytes:length:
isEnabled
URLWithString:
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
numberWithUnsignedInteger:
URLByAppendingPathComponent:
copy
decodeObjectOfClass:forKey:
stringWithString:
parameterWithAddress:
isEqualToString:
initWithObjectsAndKeys:
startRecordingWithCompletionBlock:
numberWithUnsignedLongLong:
unsignedLongLongValue
encodeDouble:forKey:
allValues
inputBusses
setActive:error:
setDateFormat:
decodeObjectOfClasses:forKey:
stringWithUTF8String:
count
maximumFramesToRender
parameterWithID:scope:element:
setHostMIDIProtocol:
object
URLsForDirectory:inDomains:
boolForKey:
isHeadphones
unsignedLongValue
defaultCenter
setRemoteObjectInterface:
UTF8String
countByEnumeratingWithState:objects:count:
substringFromIndex:
path
handleFailureInFunction:file:lineNumber:description:
objectAtIndex:
processIdentifier
channelNumber
encodeFloat:forKey:
boolValue
sharedAVSystemController
defaultManager
substringToIndex:
setOutputEnabled:
pathExtension
encodeInt64:forKey:
objectAtIndexedSubscript:
processInfo
allocateRenderResourcesAndReturnError:
remoteObjectInterface
bundleWithIdentifier:
checkResourceIsReachableAndReturnError:
firstObject
performSelectorOnMainThread:withObject:waitUntilDone:
handleFailureInMethod:object:file:lineNumber:description:
setRenderingOffline:
encodeInteger:forKey:
objectForKey:
setAllowHapticsAndSystemSoundsDuringRecording:error:
remoteObjectProxyWithErrorHandler:
initWithKeyOptions:valueOptions:capacity:
setInputEnabled:
supportedFormats
currentHandler
setOutputProvider:
encodeObject:forKey:
setTimeZone:
objectForKeyedSubscript:
pickedRoute
anyObject
bundleWithPath:
inputs
bundleWithURL:
isLoaded
initWithBool:
appendBytes:length:
scheduleMIDIEventBlock
initWithServiceName:
floatValue
removeAllObjects
opaqueSessionID
initWithLength:
valueForKey:
sharedSystemAudioContext
setInputHandler:
scheduleMIDIEventListBlock
setInterruptionHandler:
appendData:
initWithBytes:length:
removeItemAtPath:error:
loadAndReturnError:
setEligibleForBTSmartRoutingConsideration:error:
absoluteString
setAudioInputBlock:
supportsBluetoothSharing
mutableBytes
initWithCapacity:
outputBusses
initWithListenerEndpoint:
stopHardware
code
setValue:forKey:
isMusicDeviceOrEffect
array
removeObject:
raise:format:arguments:
intValue
supportsMultipleBluetoothOutputDevices
hostMIDIProtocol
mutableCopy
isOtherAudioPlaying
outputDevices
doubleValue
setInvalidationHandler:
setEligibleForBTTriangleConsideration:error:
arrayWithArray:
synchronousRemoteObjectProxyWithErrorHandler:
valueWithRange:
compare:
integerValue
errorWithDomain:code:userInfo:
portName
removeObjectAtIndex:
localTimeZone
stopRecordingWithCompletionBlock:
removeObjectsInArray:
deviceIdentifier
setLanguage:
rangeOfString:
setBusCount:error:
bytes
portType
componentsJoinedByString:
interfaceWithProtocol:
arrayWithObject:
setEnabled:
setMIDIOutputEventListBlock:
rangeValue
removeObserver:
initWithSuiteName:
activeSessionDisplayIDs
localizedDescription
postNotificationName:object:
arrayWithObjects:
dataWithBytes:length:
componentsSeparatedByString:
dictionary
arrayWithObjects:count:
addObject:
removeObserver:name:object:
localizedStringForKey:value:table:
outputs
isRenderingOffline
addObjectsFromArray:
initWithDictionary:
longLongValue
removeRenderObserver:
stringByAppendingFormat:
attributeForKey:
getBytes:range:
addObserver:selector:name:object:
dictionaryWithContentsOfURL:
dictionaryWithContentsOfURL:error:
lowercaseString
invalidateAudioUnit
initWithUUIDString:
initWithDomain:code:userInfo:
deallocateRenderResources
setWithArray:
stringByAppendingString:
setPreferredIOBufferFrameSize:error:
auxiliarySession
owningPortUID
renderBlock
dictionaryWithDictionary:
preferredIOBufferFrameSize
failWithError:
canPerformInput
setWithObjects:
reason
tokenByAddingRenderObserver:
addObserverForName:object:queue:usingBlock:
initWithDouble:
initWithUnsignedInt:
decodeBoolForKey:
initWithIOUnit:isInput:
presentationLatency
audioUnit
didAttachToEngine:
didDetachFromEngine:error:
isInManualRenderingMode
manualRenderingMode
setVoiceProcessingEnabled:error:
isVoiceProcessingEnabled
enableManualRenderingMode:isInput:
enableRealtimeRenderingModeWithIOUnit:isInput:forceIOUnitReset:
Td,R,N
T^{OpaqueAudioComponentInstance=},R,N
voiceProcessingEnabled
TB,R,N,GisVoiceProcessingEnabled
setManualRenderingPCMFormat:maximumFrameCount:
manualRenderingFormat
manualRenderingMaximumFrameCount
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
setPan:
Tf,N
renderingAlgorithm
setRenderingAlgorithm:
sourceMode
setSourceMode:
pointSourceInHeadMode
setPointSourceInHeadMode:
rate
setRate:
reverbBlend
setReverbBlend:
obstruction
setObstruction:
occlusion
setOcclusion:
position
setPosition:
Tq,N
T{AVAudio3DPoint=fff},N
destinationForMixer:bus:
volume
setVolume:
setManualRenderingInputPCMFormat:inputBlock:
isVoiceProcessingBypassed
setVoiceProcessingBypassed:
isVoiceProcessingAGCEnabled
setVoiceProcessingAGCEnabled:
isVoiceProcessingInputMuted
setVoiceProcessingInputMuted:
voiceProcessingBypassed
TB,N,GisVoiceProcessingBypassed
voiceProcessingAGCEnabled
TB,N,GisVoiceProcessingAGCEnabled
voiceProcessingInputMuted
TB,N,GisVoiceProcessingInputMuted
Tf,D,N
init
dealloc
connectionPointWithNode:bus:
initWithNode:bus:
node
_node
_bus
_reserved
T@"AVAudioNode",R,W,N,V_node
TQ,R,N,V_bus
unsignedIntegerValue
setStatusChangeBlock:
startRecordingWithSettings:withCompletionBlock:
initWithRecordingEngine:
recordRoute
isRemoteDevice
remoteProductIdentifier
remoteDeviceUID
remoteDeviceCategory
isUpsamplingSourceAudio
remoteDeviceUIDString
.cxx_destruct
_isRemoteDevice
_isUpsamplingSourceAudio
_remoteDeviceCategory
_recordRoute
_remoteProductIdentifier
_remoteDeviceUID
_remoteDeviceUIDString
T@"NSString",R,N,V_recordRoute
TB,R,V_isRemoteDevice
T@"NSString",R,N,V_remoteProductIdentifier
T@"NSUUID",R,N,V_remoteDeviceUID
TI,R,N,V_remoteDeviceCategory
TB,R,N,V_isUpsamplingSourceAudio
T@"NSString",R,N,V_remoteDeviceUIDString
voiceControllerRecordHardwareConfigurationDidChange:toConfiguration:
voiceControllerMediaServicesWereLost:
voiceControllerMediaServicesWereReset:
voiceControllerDidStartRecording:forStream:successfully:error:
voiceControllerDidStartRecording:successfully:error:
voiceControllerDidStartRecording:successfully:
voiceControllerDidStopRecording:forStream:forReason:
voiceControllerDidStopRecording:forReason:
voiceControllerDidDetectStartpoint:
voiceControllerDidDetectEndpoint:ofType:atTime:
voiceControllerDidDetectEndpoint:ofType:
voiceControllerEncoderErrorDidOccur:error:
voiceControllerDidFinishAlertPlayback:withSettings:error:
voiceControllerDidFinishAlertPlayback:ofType:error:
voiceControllerStreamInvalidated:forStream:
voiceControllerBeginRecordInterruption:withContext:
voiceControllerBeginRecordInterruption:
voiceControllerEndRecordInterruption:
voiceControllerWillSetAudioSessionActive:willActivate:
voiceControllerDidSetAudioSessionActive:isActivated:
impl
sessionSetup_v1v2
sessionCleanup_v1v2
setSessionNotifications_v1v2:
removeSessionNotifications:
hardwareConfigChanged:
handleInterruption_v1v2:
handleRouteChange_v1v2:
handleMediaServerDeath_v1v2:
handleMediaServerReset_v1v2:
handlePluginDidPublishDevice:withDevice:
handlePluginDidUnpublishDevice:withDevice:
beganRecording_v1v2:status:
finishedRecording_v1v2:status:
startpointDetected
interspeechPointDetected
endpointDetected
encodeError:
alertPlaybackFinishedOfType_v1v2:
notifyStreamInvalidated_v1v2:
beginRecordInterruptionWithContext_v1v2:
endRecordInterruption_v1v2
beginAudioSessionActivate_v1v2:
endAudioSessionActivate_v1v2:
sendRemoteConnectionMessage:
playbackRoute
lastRecordStartTime
voiceTriggerInfo
isBargeInDetectEnabled
setBargeInDetectEnabled:
isStopOnBargeInEnabled
setStopOnBargeInEnabled:
isSynchronousCallbackEnabled
setSynchronousCallbackEnabled:
pcmRecordBufferFormat
setDuckOthersOption:
duckOthersOption
numberOfChannels
bargeInDetectEnabled
TB,GisBargeInDetectEnabled
stopOnBargeInEnabled
TB,GisStopOnBargeInEnabled
T@"NSDictionary",R
synchronousCallbackEnabled
TB,GisSynchronousCallbackEnabled
T@"AVAudioFormat",R
TB,SsetDuckOthersOption:
finalize
mockPluginEndpoint
initWithContext:error:
prewarmAudioSession
teardownWithError:
_teardownWithError:
releaseAudioSession
releaseAudioSession:
enableMiniDucking:
willAcceptContext:
IsDeviceAvailableInLocalRoute:error:
setCurrentContext:error:
prepareRecordWithSettings:error:
setAlertSoundFromURL:forType:
playAlertSoundForType:
resetEndpointer
playRecordStartingAlertAndResetEndpointer
doStartRecordingAtTime_v1:behavior:
setupAlertBehavior_v1:
startRecording
startRecording:
startRecordingAtTime:error:
startRecordingWithSettings:error:
stopRecording
recordDelegate
setRecordDelegate:
recordSettings
getRecordBufferDuration
setRecordBufferDuration:
endpointerDelegate
setEndpointerDelegate:
recordEndpointMode
setRecordEndpointMode:
recordStartWaitTime
setRecordStartWaitTime:
recordInterspeechWaitTime
setRecordInterspeechWaitTime:
recordEndWaitTime
setRecordEndWaitTime:
isRecording
setAlertVolume:
alertVolume
getAlertStartTime
isMeteringEnabled
setMeteringEnabled:
updateMeters
peakPowerForChannel:
averagePowerForChannel:
isStopOnEndpointEnabled
setStopOnEndpointEnabled:
metrics
currentRecordDeviceInfo
initWithError:
initVoiceControllerForClient:withError:
setContext:completion:
setContext:error:
setContext:streamType:error:
prepareRecordForStream:completion:
prepareRecordForStream:error:
startRecordWithSettings:completion:alertCompletion:audioCallback:
startRecordForStream:completion:
startRecordForStream:error:
configureAlertBehaviorForStream:completion:
configureAlertBehaviorForStream:error:
stopRecordForStream:completion:
stopRecordForStream:error:
getCurrentStreamState:
getRecordDeviceInfoForStream:
activateAudioSessionForStream:isPrewarm:error:
activateAudioSessionForStream:isPrewarm:recordMode:error:
deactivateAudioSessionWithOptions:
deactivateAudioSessionForStream:withOptions:completion:
deactivateAudioSessionForStream:withOptions:error:
getCurrentSessionState
getCurrentSessionStateForStream:
setContextForStream:forStream:error:
playAlert:withOverride:completion:
playAlertSoundForType:overrideMode:
getRecordBufferDurationForStream:
getRecordSettingsForStream:
isMeteringEnabledForStream:
updateMeterForStream:
getPeakPowerForStream:forChannel:
getAveragePowerForStream:forChannel:
setRecordStatusChangeBlock:
enableSmartRoutingConsiderationForStream:enable:error:
setAnnounceCallsEnabledForStream:enable:
getInputChannelInfoForStream:completion:
setDuckOthersForStream:withSettings:error:
isDuckingSupportedOnPickedRouteForStream:error:
enableTriangleModeForStream:enable:withCompletion:
alertStartTime
_impl
_alertStartTime
recording
TB,R,GisRecording
T@"<Endpointer>",&
T@"<AVVoiceControllerRecordDelegate>",D
meteringEnabled
TB,GisMeteringEnabled
stopOnEndpointEnabled
TB,GisStopOnEndpointEnabled
TQ,R,V_alertStartTime
initWithMode:deviceUID:
copyWithZone:
activationMode
setActivationMode:
activationDeviceUID
setActivationDeviceUID:
announceCallsEnabled
setAnnounceCallsEnabled:
_announceCallsEnabled
_activationMode
_activationDeviceUID
Tq,N,V_activationMode
T@"NSString",&,N,V_activationDeviceUID
TB,N,V_announceCallsEnabled
initWithStreamID:settings:bufferDuration:
streamID
setStreamID:
avAudioSettings
setAvAudioSettings:
recordBufferDuration
_meteringEnabled
_streamID
_avAudioSettings
_recordBufferDuration
TQ,N,V_streamID
T@"NSDictionary",&,N,V_avAudioSettings
Td,N,V_recordBufferDuration
TB,N,V_meteringEnabled
initWithStreamID:
startAlert
setStartAlert:
stopAlert
setStopAlert:
stopOnErrorAlert
setStopOnErrorAlert:
_startAlert
_stopAlert
_stopOnErrorAlert
Tq,N,V_startAlert
Tq,N,V_stopAlert
Tq,N,V_stopOnErrorAlert
initWithStreamID:atStartHostTime:
startHostTime
setStartHostTime:
skipAlert
setSkipAlert:
startAnchorPoint
setStartAnchorPoint:
_skipAlert
_startAnchorPoint
_startHostTime
TQ,N,V_startHostTime
TB,N,V_skipAlert
TI,N,V_startAnchorPoint
initWithAlertType:mode:endTime:
type
setType:
mode
setMode:
alertEndTime
setAlertEndTime:
_type
_mode
_alertEndTime
Ti,N,V_type
Tq,N,V_mode
TQ,N,V_alertEndTime
initWithFadeIn:fadeOut:
fadeIn
setFadeIn:
fadeOut
setFadeOut:
_fadeIn
_fadeOut
T@"NSNumber",&,N,V_fadeIn
T@"NSNumber",&,N,V_fadeOut
initWithDuckOthers:duckToLevel:mixWithOthers:
duckOthers
setDuckOthers:
duckToLevel
setDuckToLevel:
isBlur
setIsBlur:
mixWithOthers
setMixWithOthers:
_isBlur
_duckOthers
_duckToLevel
_mixWithOthers
T@"NSNumber",&,N,V_duckOthers
T@"NSNumber",&,N,V_duckToLevel
TB,N,V_isBlur
T@"NSNumber",&,N,V_mixWithOthers
duckOverride
setDuckOverride:
fadeDuration
setFadeDuration:
_duckOverride
_fadeDuration
T@"AVVCDuckOverride",&,N,V_duckOverride
T@"AVVCDuckFadeDuration",&,N,V_fadeDuration
initWithComponentDescription:
initWithComponentDescription:withAVAUManagerImpl:
localeChanged
audioComponent
name
typeName
localizedTypeName
manufacturerName
versionString
iconURL
icon
userTagNames
setUserTagNames:
allTagNames
componentURL
availableArchitectures
version
hasCustomView
passesAUVal
isSandboxSafe
hasMIDIInput
hasMIDIOutput
configurationDictionary
validateWithResults:inCompletionHandler:
audioComponentDescription
supportsNumberInputChannels:outputChannels:
GetTypeName:
isComponentDescriptionMatch:
T@"NSString",R,N
TQ,R,N
T@"NSURL",R,N
T@"NSArray",R,N
sandboxSafe
TB,R,N,GisSandboxSafe
TB,R,N
T^{OpaqueAudioComponent=},R,N
T@"NSArray",C
T{AudioComponentDescription=IIIII},R,N
T@"UIImage",R,N
T@"NSDictionary",R,N
getStatus:
reset
endpointMode
setEndpointMode:
startWaitTime
setStartWaitTime:
interspeechWaitTime
setInterspeechWaitTime:
endWaitTime
setEndWaitTime:
configureWithSampleRate:andFrameRate:
configureWithASBD:andFrameRate:
mStartWaitTime
mInterspeechWaitTime
mEndWaitTime
mEndpointMode
mFrameRate
mLastStatus
getStatus:count:
initWithAudioComponentDescription:
bypass
setBypass:
TB,N
allocWithZone:
localeChanged:
registrationsChanged:
sharedAudioUnitComponentManager
privateAllocInitSingleton
tagNames
standardLocalizedTagNames
componentsMatchingPredicate:
componentsPassingTest:
componentsMatchingDescription:
setWetDryMix:
setDelayTime:
setFeedback:
setLowPassCutoff:
wetDryMix
delayTime
feedback
lowPassCutoff
Td,N
loadFactoryPreset:
setPitch:
setOverlap:
pitch
overlap
_delegate
_data
_url
_actualSettings
_format
_playRetain
_channelAssignments
_audioSession
_sessionListenerWasSet
_endInterruptionFlags
_localPlayer
_gcd
audioPlayerDidFinishPlaying:successfully:
audioPlayerDecodeErrorDidOccur:error:
audioPlayerEndInterruption:withOptions:
audioPlayerEndInterruption:withFlags:
initBase
finishedPlaying:
decodeError:
privRemoveSessionListener
handleInterruption:
beginInterruption
endInterruptionWithFlags:
endInterruption
initWithData:error:
initWithContentsOfURL:error:
initWithContentsOfURL:fileTypeHint:error:
initWithData:fileTypeHint:error:
prepareToPlay
play
playAtTime:
pause
stop
isPlaying
data
delegate
setDelegate:
settings
format
duration
setVolume:fadeDuration:
setEnableRate:
enableRate
currentTime
deviceCurrentTime
setCurrentTime:
setNumberOfLoops:
numberOfLoops
channelAssignments
setChannelAssignments:
audioSession
setAudioSession:
mixToUplink
setMixToUplink:
currentDevice
setCurrentDevice:
_currentDevice
playing
TB,R,GisPlaying
Td,R
T@"NSString",C,V_currentDevice
T@"<AVAudioPlayerDelegate>",W
T@"NSURL",R
T@"NSData",R
T@"NSArray",C,N
audioPlayerBeginInterruption:
audioPlayerEndInterruption:
sharedInstance
_wqCreateAuxSessionAndManagerForDeviceUID:clientType:session:manager:error:
_wqCreatePrimarySessionManagerIfNeeded:clientType:error:
_wqSessionAndManagerForContext:clientType:session:manager:error:
sessionForContext:completion:
sessionForContext:error:
sessionForContext:clientType:completion:
sessionForContext:clientType:error:
sessionManagerForContext:clientType:completion:
sessionManagerForContext:clientType:error:
cleanupContext:
auxSessionManagers
releasePrimarySessionManager
workQueue
setWorkQueue:
sessionManagerMap
setSessionManagerMap:
primarySessionManager
setPrimarySessionManager:
sessionWasCreatedBlock
setSessionWasCreatedBlock:
sessionWillBeDestroyedBlock
setSessionWillBeDestroyedBlock:
_workQueue
_sessionManagerMap
_primarySessionManager
_sessionWasCreatedBlock
_sessionWillBeDestroyedBlock
T@"NSObject<OS_dispatch_queue>",&,N,V_workQueue
T@"NSMutableDictionary",&,N,V_sessionManagerMap
T@"AVVCSessionManager",&,N,V_primarySessionManager
T@?,C,N,V_sessionWasCreatedBlock
T@?,C,N,V_sessionWillBeDestroyedBlock
audioRecorderDidFinishRecording:successfully:
finishedRecording
audioRecorderEndInterruption:withOptions:
audioRecorderEndInterruption:withFlags:
audioRecorderBeginInterruption:
endInterruptionWithFlags
audioRecorderEndInterruption:
T@"AVAudioSession",&
privCommonCleanup
privRemoveSessionPropertyListeners
baseInit
initWithURL:format:error:
initWithURL:settings:error:
prepareToRecord
record
recordAtTime:
recordForDuration:
recordAtTime:forDuration:
deleteRecording
setProcessToTap:
processToTap
instantaneousMetering
setInstantaneousMetering:
Ti,N
T@"<AVAudioRecorderDelegate>",W
pullInputBlockFromReceiverBlock:
initWithReceiverBlock:
layoutWithLayoutTag:
layoutWithLayout:
supportsSecureCoding
encodeWithCoder:
initWithCoder:
TB,R
initWithLayoutTag:
initWithLayout:
channelCount
layoutTag
layout
layoutSize
_layoutTag
_layout
TI,R,N
Tr^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]},R,N
initialize
updateSpeechVoices
initWithName:identifier:primaryLanguages:supportedLanguages:
setName:
identifier
setIdentifier:
primaryLanguages
supportedLanguages
setSupportedLanguages:
voiceSize
setVoiceSize:
setVersion:
gender
setGender:
setAge:
_name
_identifier
_primaryLanguages
_supportedLanguages
_voiceSize
_version
_gender
_age
T@"NSString",&,N,V_name
T@"NSString",&,N,V_identifier
T@"NSArray",&,N,V_supportedLanguages
T@"NSArray",R,N,V_primaryLanguages
Tq,N,V_voiceSize
T@"NSString",&,N,V_version
Tq,N,V_gender
Tq,N,V_age
initWithSSMLRepresentation:voice:
ssmlRepresentation
setSsmlRepresentation:
voice
setVoice:
_ssmlRepresentation
_voice
T@"NSString",&,N,V_ssmlRepresentation
T@"AVSpeechSynthesisProviderVoice",&,N,V_voice
synthesizeSpeechRequest:
cancelSpeechRequest
speechVoices
setSpeechVoices:
speechSynthesisOutputMetadataBlock
setSpeechSynthesisOutputMetadataBlock:
_speechVoices
_speechSynthesisOutputMetadataBlock
T@"NSArray",&,N,V_speechVoices
T@?,C,N,V_speechSynthesisOutputMetadataBlock
passExtensionToken:
startWithSequence:completion:
playback:filePath:completion:
startRecording:filePath:completion:
stopRecording:
cancel
initWithXPCEndPoint:
processSequenceAsynchronously
setProcessSequenceAsynchronously:
connection
setConnection:
serviceDelegateAsync
setServiceDelegateAsync:
serviceDelegateSync
setServiceDelegateSync:
_processSequenceAsynchronously
_connection
_serviceDelegateAsync
_serviceDelegateSync
T@"NSXPCConnection",&,N,V_connection
T@"<AVAudioDeviceTestServiceProtocol>",&,N,V_serviceDelegateAsync
T@"<AVAudioDeviceTestServiceProtocol>",&,N,V_serviceDelegateSync
TB,V_processSequenceAsynchronously
initFromFormat:toFormat:
inputFormat
outputFormat
dither
downmix
setDither:
setDownmix:
sampleRateConverterQuality
setSampleRateConverterQuality:
sampleRateConverterAlgorithm
setSampleRateConverterAlgorithm:
magicCookie
setMagicCookie:
channelMap
setChannelMap:
maximumOutputPacketSize
primeMethod
setPrimeMethod:
primeInfo
setPrimeInfo:
convertToBuffer:fromBuffer:error:
convertToBuffer:error:withInputFromBlock:
T@"AVAudioFormat",R,N
T@"NSArray",&,N
T@"NSData",&,N
T@"NSString",&,N
T{AVAudioConverterPrimeInfo=II},N
bitRate
setBitRate:
bitRateStrategy
setBitRateStrategy:
availableEncodeBitRates
applicableEncodeBitRates
availableEncodeSampleRates
applicableEncodeSampleRates
availableEncodeChannelLayoutTags
Tq,R,N
getLock
createSharedManager
destroySharedManager
sharedManager
retrieveMetrics
getStringDate:
resetProfileMetrics
retrieveProfileMetrics
measureElapseTimeForMetric:block:
setAudioIssueDetectorFormat:numFrames:
audioIssueDetectorAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetAudioIssueDetector
setADAMFormat:numFrames:
adamAnalyzeBuffer:numFrames:timeStamp:shouldAnalyze:
resetADAM
logProfileMetrics:
voiceTriggerStartHostTime
setVoiceTriggerStartHostTime:
callToStartRecordHostTime
setCallToStartRecordHostTime:
publicMetrics
setPublicMetrics:
avvcProfilingInfoDictionary
setAvvcProfilingInfoDictionary:
mProfileAVVC
_voiceTriggerStartHostTime
_callToStartRecordHostTime
_publicMetrics
_avvcProfilingInfoDictionary
T@"NSMutableDictionary",&,V_publicMetrics
T@"NSMutableDictionary",&,V_avvcProfilingInfoDictionary
TQ,N,V_voiceTriggerStartHostTime
TQ,N,V_callToStartRecordHostTime
FillOutAUPreset:
setPreGain:
preGain
setOutputVolume:
outputVolume
setInputVolume:bus:
setInputPan:bus:
inputConnected:
nextAvailableInputBus
initWithNode:
currentAudioTimeStamp
currentIONumberFrames
awaitIOCycle:
T@"AVAudioTime",R,N
initWithContentsOfURL:soundBankURL:error:
initWithData:soundBankURL:error:
hostTimeForBeats:
beatsForHostTime:
play:
currentPosition
setCurrentPosition:
TB,R,N,GisPlaying
destroyBase
remoteInputDeviceName
deviceCategory
startNote:withVelocity:onChannel:
stopNote:onChannel:
sendController:withValue:onChannel:
sendPitchBend:onChannel:
sendPressure:onChannel:
sendPressureForKey:withValue:onChannel:
sendProgramChange:onChannel:
sendProgramChange:bankMSB:bankLSB:onChannel:
sendMIDIEvent:data1:data2:
sendMIDIEvent:data1:
sendMIDISysExEvent:
sendMIDIEventList:
mutableCopyWithZone:
initWithFormat:byteCapacity:
initWithPCMFormat:byteCapacity:bufferListNoCopy:deallocator:
byteCapacity
byteLength
setByteLength:
audioBufferList
mutableAudioBufferList
_deallocator
Tr^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
T^{AudioBufferList=I[1{AudioBuffer=II^v}]},R,N
initWithPCMFormat:frameCapacity:
initWithPCMFormat:bufferListNoCopy:deallocator:
frameCapacity
frameLength
setFrameLength:
stride
_initChannelPtrs
floatChannelData
int32ChannelData
int16ChannelData
appendDataFromBuffer:
appendDataFromBuffer:channel:
splitIntoSingleChannelBuffers
averagePowerPerChannel
peakPowerPerChannel
calculatePower:
calculatePower:forFloatData:stride:frameLength:
TI,N
T^^f,R,N
T^^s,R,N
T^^i,R,N
initWithFormat:packetCapacity:maximumPacketSize:
initWithFormat:packetCapacity:
packetCapacity
packetCount
maximumPacketSize
packetDescriptions
setPacketCount:
T^v,R,N
TI,R,D,N
TI,D,N
T^{AudioStreamPacketDescription=qII},R,N
initWithImpl:
setFilterType:
filterType
setFrequency:
frequency
setBandwidth:
bandwidth
setGain:
gain
initWithNumberOfBands:
bands
globalGain
setGlobalGain:
formatWithInvalidSampleRateAndChannelCount
settingsFromASBD:channelLayout:
initWithStreamDescription:
initWithStreamDescription:channelLayout:
initStandardFormatWithSampleRate:channels:
initStandardFormatWithSampleRate:channelLayout:
initWithCommonFormat:sampleRate:channels:interleaved:
initWithCommonFormat:sampleRate:interleaved:channelLayout:
initWithSettings:
initWithCMAudioFormatDescription:
formatDescription
streamDescription
channelLayout
isStandard
commonFormat
sampleRate
isInterleaved
_asbd
_commonFormat
standard
TB,R,N,GisStandard
interleaved
TB,R,N,GisInterleaved
Tr^{AudioStreamBasicDescription=dIIIIIIII},R,N
T@"AVAudioChannelLayout",R,N
Tr^{opaqueCMFormatDescription=},R,N
initWithData:inputID:outputID:sampleRate:correlationValue:
inputID
setInputID:
outputID
setOutputID:
setSampleRate:
correlationValue
setCorrelationValue:
_inputID
_outputID
_sampleRate
_correlationValue
Tq,N,V_outputID
Tq,N,V_inputID
Td,N,V_sampleRate
Td,N,V_correlationValue
T@"NSData",R,N,V_data
stimulusURL
setStimulusURL:
inputProcessingChain
setInputProcessingChain:
outputProcessingChain
setOutputProcessingChain:
outputMode
setOutputMode:
priority
setPriority:
calculateCrossCorrelationPeak
setCalculateCrossCorrelationPeak:
parallelCrossCorrelationCalculation
setParallelCrossCorrelationCalculation:
setNumberOfChannels:
micBufferNumbers
setMicBufferNumbers:
requiresBluetoothOutput
setRequiresBluetoothOutput:
microphone
setMicrophone:
_calculateCrossCorrelationPeak
_parallelCrossCorrelationCalculation
_requiresBluetoothOutput
_volume
_stimulusURL
_inputProcessingChain
_outputProcessingChain
_outputMode
_priority
_numberOfChannels
_micBufferNumbers
_microphone
Tf,N,V_volume
T@"NSURL",&,N,V_stimulusURL
T@"AVAudioDeviceTestProcessingChain",&,N,V_inputProcessingChain
T@"AVAudioDeviceTestProcessingChain",&,N,V_outputProcessingChain
Tq,N,V_outputMode
Tq,N,V_priority
T@"NSString",&,V_mode
TB,V_calculateCrossCorrelationPeak
TB,V_parallelCrossCorrelationCalculation
Tq,N,V_numberOfChannels
T@"NSArray",&,N,V_micBufferNumbers
TB,V_requiresBluetoothOutput
T@"NSString",&,N,V_microphone
graphURL
setGraphURL:
processingStripURL
setProcessingStripURL:
_graphURL
_processingStripURL
T@"NSURL",&,N,V_graphURL
T@"NSURL",&,N,V_processingStripURL
pullInputBlockFromRenderBlock:
initWithRenderBlock:
initWithFormat:renderBlock:
currentLanguageCode
voiceWithLanguage:
voiceWithIdentifier:
audioFileSettings
_audioFileSettings
language
T@"NSString",C,D,N
T@"NSString",&,D,N
quality
Tq,D,N
T@"NSDictionary",R,N,V_audioFileSettings
speechUtteranceWithString:
speechUtteranceWithAttributedString:
speechUtteranceWithSSMLRepresentation:
initWithString:
initWithAttributedString:
initWithSSMLRepresentation:
setPitchMultiplier:
speechString
setSpeechString:
attributedSpeechString
setAttributedSpeechString:
pitchMultiplier
prefersAssistiveTechnologySettings
setPrefersAssistiveTechnologySettings:
preUtteranceDelay
setPreUtteranceDelay:
postUtteranceDelay
setPostUtteranceDelay:
_prefersAssistiveTechnologySettings
_rate
_pitchMultiplier
_speechString
_attributedSpeechString
_preUtteranceDelay
_postUtteranceDelay
T@"NSString",&,N,V_speechString
T@"NSAttributedString",&,N,V_attributedSpeechString
T@"AVSpeechSynthesisVoice",&,N,V_voice
Tf,N,V_rate
Tf,N,V_pitchMultiplier
TB,N,V_prefersAssistiveTechnologySettings
Td,N,V_preUtteranceDelay
Td,N,V_postUtteranceDelay
speakUtterance:
writeUtterance:toBufferCallback:
writeUtterance:toBufferCallback:toMarkerCallback:
stopSpeakingAtBoundary:
pauseSpeakingAtBoundary:
continueSpeaking
isSpeaking
isPaused
outputChannels
setOutputChannels:
usesApplicationAudioSession
setUsesApplicationAudioSession:
mixToTelephonyUplink
setMixToTelephonyUplink:
_speaking
_paused
_usesApplicationAudioSession
_mixToTelephonyUplink
_outputChannels
T@"<AVSpeechSynthesizerDelegate>",W,N,V_delegate
speaking
TB,R,N,GisSpeaking,V_speaking
paused
TB,R,N,GisPaused,V_paused
T@"NSArray",&,N,V_outputChannels
TB,N,V_usesApplicationAudioSession
TB,N,V_mixToTelephonyUplink
initWithMarkerType:forTextRange:atByteSampleOffset:
initWithMarkerType:name:forTextRange:atByteSampleOffset:
mark
setMark:
byteSampleOffset
setByteSampleOffset:
textRange
setTextRange:
_mark
_byteSampleOffset
_textRange
Tq,N,V_mark
TQ,N,V_byteSampleOffset
T{_NSRange=QQ},N,V_textRange
channels
bytesCapacity
bytesDataSize
setBytesDataSize:
packetDescriptionCapacity
packetDescriptionCount
setPacketDescriptions:count:
timeStamp
remoteVoiceActivityRMS
remoteVoiceActivityVAD
remoteVoiceActivityAvailable
upsamplingSourceAudio
Ti,R
T^v,R
T^{AudioStreamPacketDescription=qII},R
T^{AudioStreamBasicDescription=dIIIIIIII},R
TC,R
initWithAudioQueueBuffer:channels:timeStamp:
initWithEnvironment:
setDistanceAttenuationModel:
distanceAttenuationModel
setMaximumDistance:
maximumDistance
setReferenceDistance:
referenceDistance
setRolloffFactor:
rolloffFactor
setEnable:
enable
setLevel:
level
filterParameters
loadFactoryReverbPreset:
T@"AVAudioUnitEQFilterParameters",R,N
setOutputType:
outputType
applicableRenderingAlgorithms
setListenerPosition:
listenerPosition
setListenerVectorOrientation:
listenerVectorOrientation
setListenerAngularOrientation:
listenerAngularOrientation
distanceAttenuationParameters
reverbParameters
T{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}},N
T{AVAudio3DAngularOrientation=fff},N
T@"AVAudioEnvironmentDistanceAttenuationParameters",R,N
T@"AVAudioEnvironmentReverbParameters",R,N
voiceControllerLPCMAudioCallback:forStream:buffer:
voiceControllerAudioCallback:forStream:buffer:
voiceControllerLPCMRecordBufferAvailable:buffer:
voiceControllerRecordBufferAvailable:buffer:
initWithSession:
setupOneTimeSessionSettingsForClient:
setSessionActivationContext:
shouldEnableMiniDucking:withOptions:
isMiniDuckingEnabled
getHypotheticalRouteAndUpdateStates
setSessionCategoryModeOptionsForActivationMode:withOptions:
setSessionAudioHWControlFlagsForActivationMode:withOptions:
setSessionSampleRateForActivationMode:
setSessionBufferSize:
changeDuckOthersOption:
setDuckOthers:mixWithOthers:error:
setDuckingFadeOutDuration:fadeInDuration:error:
isSessionOutputInWirelessSplitterMode
getSessionActivationOptions
setSessionActivationOptions:
enableSmartRoutingConsideration:
isAirplayOneOfTheOutputRoutes:
activateAudioSessionWithPrewarm:error:
deactivateAudioSessionWithOptions:error:
setSessionState:
setSessionStateWithoutLock:
sessionState
isSessionActive
getAVVCSessionState
setClientRequestsRecording:
getClientRequestsRecording
setDeviceGain:
getDeviceGain
setPlaybackRoute:
getPlaybackRoute
setForceGetSessionProperties:
getForceGetSessionProperties
setEnableBTTriangleMode:error:
inputLatency
outputLatency
speechDetectionDeviceSampleRate
setCategory:mode:options:error:
setCategory:mode:routeSharingPolicy:options:error:
clearInputPreferences:
isSessionInSiriCategoryModeAndOptions:
isSessionInSiriCategory
setAudioHardwareControlFlags:error:
reporterID
setIAmTheAssistant:error:
setPreferredSampleRate:error:
currentRoute
sessionCurrentOutputRoutes
sessionCurrentInputRoutes
siriInputSource
siriRemoteInputIdentifier
getSiriInputSource:withIdentifier:
setActivationContext:error:
setActive:withOptions:error:
getOpaqueSessionID
getActiveSessionDisplayIDsAsString
setupSessionNotifications:
setRecordingFromRemoteInput:error:
inputNumberOfChannels
setDuckToLevelDB:error:
setDuckToLevelScalar:error:
isSWVolumeSupportedOnPickedRoute
isPrimary
clientRequestsRecording
deviceGain
forceGetSessionProperties
.cxx_construct
mShouldDuckOthers
mIsMiniDuckingEnabled
mShouldEnableMiniDucking
mShouldDisableMiniDucking
mSessionNeedsVolumeControl
mSessionNeedsRoutingControl
mSessionOutputIsWirelessSplitter
mIsOtherAudioPlaying
mRouteHasDoAPSupport
mOutputSupportsSWVolume
mDeviceIsIOSAccessory
mDeviceIsOlderWatch
mSessionActivationOptions
mPreviousActivationMode
mSessionManagerLock
_isPrimary
_clientRequestsRecording
_forceGetSessionProperties
_sessionState
_deviceGain
_reporterID
_inputLatency
_outputLatency
_playbackRoute
T@"AVAudioSession",&,N,V_audioSession
Ti,N,V_sessionState
TB,R,N,V_isPrimary
TB,N,V_clientRequestsRecording
Tf,N,V_deviceGain
T@"NSString",&,N,V_playbackRoute
TB,N,V_forceGetSessionProperties
Td,R,N,V_inputLatency
Td,R,N,V_outputLatency
Tq,R,V_reporterID
initWithChannel:key:velocity:duration:
channel
setChannel:
setKey:
velocity
setVelocity:
setDuration:
initWithMessage:
message
isEqualTo:
_msg
T^{MIDINoteMessage=CCCCf},R
initWithChannel:status:data1:data2:
data1
setData1:
data2
setData2:
T^{MIDIChannelMessage=CCCC},R
initWithChannel:messageType:value:
messageType
value
Tq,R
TI,R
initWithChannel:key:pressure:
pressure
setPressure:
initWithChannel:programNumber:
programNumber
setProgramNumber:
initWithChannel:pressure:
initWithChannel:value:
setValue:
initWithData:
sizeInBytes
initWithMIDIRawData:
rawData
_sysexData
T^{MIDIRawData=I[1C]},R
initWithType:data:
initWithMetaEvent:
metaEvent
_event
T^{MIDIMetaEvent=CCCCI[1C]},R,V_event
initWithUserData:
userData
_userData
T^{MusicEventUserData=I[1C]},R
initWithMIDINote:velocity:instrumentID:groupID:duration:
initWithMIDINote:velocity:groupID:duration:
midiNote
setMidiNote:
instrumentID
setInstrumentID:
groupID
setGroupID:
initWithNoteOnEvent:
event
T^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}},R,V_event
initWithParameterID:scope:element:value:
parameterID
setParameterID:
scope
setScope:
element
setElement:
initWithParameterEvent:
T^{ParameterEvent=IIIf},R
initWithScope:element:dictionary:
presetDictionary
initWithAUPresetEvent:
T^{AUPresetEvent=II^v},R
T@"NSDictionary",R,C
initWithTempo:
tempo
setTempo:
_bpm
Td,V_bpm
initForReading:error:
initForReading:commonFormat:interleaved:error:
initForReadingFromExtAudioFile:error:
initForReadingFromExtAudioFile:commonFormat:interleaved:error:
initForWriting:settings:error:
initForWriting:settings:commonFormat:interleaved:error:
initSecondaryReader:format:error:
readIntoBuffer:error:
writeFromBuffer:error:
readIntoBuffer:frameCount:error:
fileFormat
processingFormat
length
framePosition
setFramePosition:
resetImpl:
outputFormatForBus:
setOutputFormat:forBus:
inputFormatForBus:
setInputFormat:forBus:
nameForInputBus:
nameForOutputBus:
clock
lastRenderTime
latency
outputPresentationLatency
engine
numberOfInputs
numberOfOutputs
setNumberOfInputs:
setNumberOfOutputs:
installTapOnBus:bufferSize:format:block:
removeTapOnBus:
AUAudioUnit
T@"AVAudioEngine",R,N
T@"AUAudioUnit",R,N
implementation
connectionPoint
T@"AVAudioConnectionPoint",R,N
loadInstrumentAtURL:error:
loadSoundBankInstrumentAtURL:program:bankMSB:bankLSB:error:
loadAudioFilesAtURLs:error:
stereoPan
overallGain
masterGain
globalTuning
setStereoPan:
setOverallGain:
setMasterGain:
setGlobalTuning:
initWithPluginDelegate:
invalidate
devices
inputPlugin:didPublishDevice:
inputPlugin:didUnpublishDevice:
invalidatePlugins
allBundles:
findDeviceWithIdentifier:
findFirstBluetoothDevice
setParentVoiceController:
mMotherController
setMMotherController:
mPlugins
_mMotherController
T@"AVVoiceController",W,N,V_mMotherController
currentPositionInSeconds
setCurrentPositionInSeconds:
currentPositionInBeats
setCurrentPositionInBeats:
hostTimeForBeats:error:
beatsForHostTime:error:
startAndReturnError:
initWithAudioEngine:
numberOfTracks
cleanTracks
setupTrackArray
setupTracks
userInfo
loadFromURL:options:error:
loadFromData:options:error:
writeToURL:SMPTEResolution:replaceExisting:error:
dataWithSMPTEResolution:error:
createAndAppendTrack
tracks
getTempoTrack
removeTrack:
secondsForBeats:
beatsForSeconds:
reverseEvents
setUserCallback:
setTrackArray:
trackArray
setTempoTrack:
tempoTrack
T@"AVMusicTrack",R,N
index
track
setDestinationAudioUnit:
destinationAudioUnit
setDestinationMIDIEndpoint:
destinationMIDIEndpoint
loopRange
setLoopRange:
isLoopingEnabled
setLoopingEnabled:
offsetTime
setOffsetTime:
isMuted
setMuted:
isSoloed
setSoloed:
usesAutomatedParameters
setUsesAutomatedParameters:
lengthInBeats
setLengthInBeats:
lengthInSeconds
setLengthInSeconds:
timeResolution
T@"AVAudioUnit",&,N
T{_AVBeatRange=dd},N
loopingEnabled
TB,N,GisLoopingEnabled
muted
TB,N,GisMuted
soloed
TB,N,GisSoloed
doAddMIDINoteEvent:atBeat:
doAddMIDIChannelEvent:atBeat:
doAddMIDISysexEvent:atBeat:
doAddExtendedNoteOnEvent:atBeat:
doAddParameterEvent:atBeat:
doAddExtendedTempoEvent:atBeat:
doAddMIDIMetaEvent:atBeat:
doAddUserEvent:atBeat:
doAddAUPresetEvent:atBeat:
addEvent:atBeat:
moveEventsInRange:byAmount:
clearEventsInRange:
cutEventsInRange:
copyEventsInRange:fromTrack:insertAtBeat:
copyAndMergeEventsInRange:fromTrack:mergeAtBeat:
enumerateEventsInRange:usingBlock:
createEventIterator
seek:
nextEvent
previousEvent
getEventInfo:outEventType:eventData:dataSize:
setEventInfo:data:
setEventTime:
deleteEvent
hasPreviousEvent
hasNextEvent
hasCurrentEvent
timeWithHostTime:
timeWithSampleTime:atRate:
timeWithHostTime:sampleTime:atRate:
timeWithAudioTimeStamp:sampleRate:
hostTimeForSeconds:
secondsForHostTime:
initWithHostTime:
initWithSampleTime:atRate:
initWithHostTime:sampleTime:atRate:
isHostTimeValid
isSampleTimeValid
hostTime
sampleTime
extrapolateTimeFromAnchor:
initWithAudioTimeStamp:sampleRate:
audioTimeStamp
_ats
hostTimeValid
TB,R,N,GisHostTimeValid
sampleTimeValid
TB,R,N,GisSampleTimeValid
T{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II},R,N
loadAudioDSPManager
loadDSPGraphAtURL:error:
loadAudioUnitProcessingStripAtURL:error:
dspGraphURL
auProcessingStripURL
callLegacyCompletionHandlerForType:legacyHandler:
scheduleBuffer:completionHandler:
scheduleBuffer:completionCallbackType:completionHandler:
scheduleBuffer:atTime:options:completionHandler:
scheduleBuffer:atTime:options:completionCallbackType:completionHandler:
scheduleFile:atTime:completionHandler:
scheduleFile:atTime:completionCallbackType:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionHandler:
scheduleSegment:startingFrame:frameCount:atTime:completionCallbackType:completionHandler:
prepareWithFrameCount:
nodeTimeForPlayerTime:
playerTimeForNodeTime:
isAPIAvailable
supportsDuckingOnSpeakerOutput
callServerCrashedBlock
handleMediaServerDeath:
callServerResetBlock
handleMediaServerReset:
voiceTriggerServerConnection
voiceTriggerPastDataFramesAvailableCompletion:
getInputChannelInfoCompletion:
voiceTriggerPastDataFramesAvailable
enableVoiceTriggerListening:
enableVoiceTriggerListening:completionBlock:
setListeningProperty:completionBlock:
enableSpeakerStateListening:completionBlock:
enableSpeakerStateListening:
speakerStateActiveCompletionBlock:
speakerStateActive
speakerStateMutedCompletionBlock:
speakerStateMuted
enableBargeInMode:completionBlock:
updateVoiceTriggerConfiguration:
updateVoiceTriggerConfiguration:completionBlock:
listeningEnabledCompletionBlock:
siriClientsRecordingCompletionBlock:
setAggressiveECMode:completionBlock:
voiceTriggerNotification:
speakerStateChangedNotification:
speakerMuteStateChangedNotification:
siriClientRecordStateChangedNotification:recordingCount:
voiceTriggerBlock
setVoiceTriggerBlock:
speakerStateChangedBlock
setSpeakerStateChangedBlock:
speakerMuteStateChangedBlock
setSpeakerMuteStateChangedBlock:
siriClientRecordStateChangedBlock
setSiriClientRecordStateChangedBlock:
serverCrashedBlock
setServerCrashedBlock:
serverResetBlock
setServerResetBlock:
_voiceTriggerBlock
_speakerStateChangedBlock
_speakerMuteStateChangedBlock
_siriClientRecordStateChangedBlock
_serverCrashedBlock
_serverResetBlock
T@?,C,N,V_voiceTriggerBlock
T@?,C,N,V_speakerStateChangedBlock
T@?,C,N,V_speakerMuteStateChangedBlock
T@?,C,N,V_siriClientRecordStateChangedBlock
T@?,C,N,V_serverCrashedBlock
T@?,C,N,V_serverResetBlock
instantiateWithComponentDescription:options:completionHandler:
loadAudioUnitPresetAtURL:error:
setValue:forParam:
valueForParam:
T@"AUAudioUnit",R,D,N
attachNode:
detachNode:
outputNode
inputNode
mainMixerNode
connect:to:fromBus:toBus:format:
connect:to:format:
connect:toConnectionPoints:fromBus:format:
disconnectNodeInput:bus:
disconnectNodeOutput:bus:
disconnectNodeInput:
disconnectNodeOutput:
prepare
inputConnectionPointForNode:inputBus:
outputConnectionPointsForNode:outputBus:
setMusicSequence:
musicSequence
isRunning
isAutoShutdownEnabled
setAutoShutdownEnabled:
manualRenderingSampleTime
enableManualRenderingMode:format:maximumFrameCount:error:
disableManualRenderingMode
manualRenderingBlock
renderOffline:toBuffer:error:
connectMIDI:to:format:block:
connectMIDI:toNodes:format:block:
connectMIDI:to:format:eventListBlock:
connectMIDI:toNodes:format:eventListBlock:
disconnectMIDI:from:
disconnectMIDI:fromNodes:
disconnectMIDIInput:
disconnectMIDIOutput:
attachedNodes
T^{OpaqueMusicSequence=},N
T@"AVAudioOutputNode",R,N
T@"AVAudioInputNode",R,N
T@"AVAudioMixerNode",R,N
running
TB,R,N,GisRunning
autoShutdownEnabled
TB,N,GisAutoShutdownEnabled
T@"NSSet",R,C
T@?,R,N
@28@0:8^v16B24
d16@0:8
^{OpaqueAudioComponentInstance=}16@0:8
v24@0:8@16
v32@0:8@16^@24
B16@0:8
q16@0:8
B28@0:8B16^@20
B28@0:8q16B24
B32@0:8^v16B24B28
B28@0:8@16I24
@16@0:8
I16@0:8
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
f16@0:8
v20@0:8f16
v24@0:8q16
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@32@0:8@16Q24
@"AVAudioMixingDestination"32@0:8@"AVAudioNode"16Q24
B32@0:8@16@?24
v20@0:8B16
v16@0:8
@"AVAudioNode"
@32@0:8{shared_ptr<AVVCRecordingEngine>=^{AVVCRecordingEngine}^{__shared_weak_count}}16
@"NSString"
@"NSUUID"
{shared_ptr<ControllerImpl>=^{ControllerImpl}^{__shared_weak_count}}16@0:8
v20@0:8i16
v32@0:8@16@24
v28@0:8Q16i24
v24@0:8Q16
@"NSXPCListenerEndpoint"16@0:8
@32@0:8@16^@24
v24@0:8^@16
B32@0:8@16^@24
B28@0:8@16i24
B20@0:8i16
i32@0:8Q16@24
B24@0:8^@16
B32@0:8Q16^@24
B24@0:8d16
i16@0:8
v24@0:8d16
f24@0:8Q16
@24@0:8^@16
@32@0:8q16^@24
v32@0:8@16@?24
Q32@0:8@16^@24
Q40@0:8@16^q24^@32
v48@0:8@16@?24@?32@?40
v32@0:8Q16@?24
q24@0:8Q16
@24@0:8Q16
B36@0:8Q16B24^@28
B40@0:8Q16B24B28^@32
v40@0:8Q16Q24@?32
v40@0:8Q16Q24^@32
B40@0:8@16Q24^@32
v36@0:8i16q20@?28
B28@0:8i16q20
d24@0:8Q16
B24@0:8Q16
f32@0:8Q16Q24
v24@0:8@?16
B28@0:8Q16B24
B40@0:8Q16@24^@32
v36@0:8Q16B24@?28
@32@0:8q16@24
@24@0:8^{_NSZone=}16
@40@0:8Q16@24d32
@"NSDictionary"
@32@0:8Q16Q24
v20@0:8I16
@36@0:8i16q20Q28
@32@0:8@16@24
@"NSNumber"
@40@0:8@16@24@32
@"AVVCDuckOverride"
@"AVVCDuckFadeDuration"
@36@0:8{AudioComponentDescription=IIIII}16
@44@0:8{AudioComponentDescription=IIIII}16^{AVAudioUnitComponentManagerImpl=^^?@@@{mutex={_opaque_pthread_mutex_t=q[56c]}}}36
^{OpaqueAudioComponent=}16@0:8
{AudioComponentDescription=IIIII}16@0:8
B32@0:8q16q24
@20@0:8I16
B36@0:8{AudioComponentDescription=IIIII}16
i24@0:8^{AudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I}16
B28@0:8d16I24
B28@0:8^{AudioStreamBasicDescription=dIIIIIIII}16I24
^{Impl=^v^{Averager}}
i28@0:8^f16I24
@24@0:8@16
@24@0:8@?16
@"<AVAudioPlayerDelegate>"
@"NSData"
@"NSURL"
@"AVAudioFormat"
@"NSArray"
@"AVAudioSession"
@"NSObject<OS_dispatch_queue>"
@40@0:8@16@24^@32
v28@0:8f16d20
v56@0:8@16q24^@32^@40^@48
@40@0:8@16q24^@32
v40@0:8@16q24@?32
@?16@0:8
@"NSMutableDictionary"
@"AVVCSessionManager"
@"AVAudioSession"16@0:8
v24@0:8@"AVAudioSession"16
^{AudioRecorderImpl=@@@@@@I{AudioStreamBasicDescription=dIIIIIIII}^{OpaqueAudioFileID}^{OpaqueAudioQueue}qqqdddQ*BBBBBBBB^{AudioQueueLevelMeterState}[4^{AudioQueueBuffer}]^{AudioQueueBuffer}BQBi@}16@0:8
B32@0:8d16d24
@?24@0:8@?16
@24@0:8r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
r^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}16@0:8
^{AudioChannelLayout=III[1{AudioChannelDescription=II[3f]}]}
@48@0:8@16@24@32@40
@"AVSpeechSynthesisProviderVoice"
v40@0:8@16@24@?32
v24@0:8@"NSString"16
v32@0:8@"AVAudioDeviceTestSequence"16@?<v@?@"NSArray"@"NSError">24
v40@0:8@"AVAudioDeviceTestSequence"16@"NSString"24@?<v@?@"NSError">32
v24@0:8@?<v@?@"NSError">16
@"NSXPCConnection"
@"<AVAudioDeviceTestServiceProtocol>"
{AVAudioConverterPrimeInfo=II}16@0:8
v24@0:8{AVAudioConverterPrimeInfo=II}16
B40@0:8@16@24^@32
q40@0:8@16^@24@?32
^v16@0:8
i60@0:8{CAStreamBasicDescription=dIIIIIIII}16I56
i56@0:8{AudioBufferList=I[1{AudioBuffer=II^v}]}16I40r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}44B52
{AUPreset=i^{__CFString}}24@0:8q16
v28@0:8f16Q20
@24@0:8^v16
{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16@0:8
@24@0:8^I16
Q24@0:8d16
^{MIDIPlayerImpl=^{OpaqueAUGraph}^{OpaqueMusicPlayer}^{OpaqueMusicSequence}d@?@}16@0:8
v28@0:8C16C20C24
v24@0:8C16C20
v24@0:8S16C20
v32@0:8C16C20C24C28
v24@0:8r^{MIDIEventList=iI[1{MIDIEventPacket=QI[64I]}]}16
@28@0:8@16I24
@44@0:8@16I24r^{AudioBufferList=I[1{AudioBuffer=II^v}]}28@?36
r^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
^{AudioBufferList=I[1{AudioBuffer=II^v}]}16@0:8
@40@0:8@16r^{AudioBufferList=I[1{AudioBuffer=II^v}]}24@?32
^^f16@0:8
^^i16@0:8
^^s16@0:8
B32@0:8@16q24
f44@0:8Q16^f24q32I40
@36@0:8@16I24q28
^{AudioStreamPacketDescription=qII}16@0:8
@24@0:8^{AVAudioUnitEQFilterParametersImpl=^^?^{AVAudioNodeImplBase}}16
@32@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16@24
@24@0:8r^{AudioStreamBasicDescription=dIIIIIIII}16
@28@0:8d16I24
@32@0:8d16@24
@40@0:8Q16d24I32B36
@44@0:8Q16d24B32@36
@24@0:8^{opaqueCMFormatDescription=}16
r^{opaqueCMFormatDescription=}16@0:8
r^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
{AudioStreamBasicDescription="mSampleRate"d"mFormatID"I"mFormatFlags"I"mBytesPerPacket"I"mFramesPerPacket"I"mBytesPerFrame"I"mChannelsPerFrame"I"mBitsPerChannel"I"mReserved"I}
@"AVAudioChannelLayout"
@56@0:8@16q24q32d40d48
@"AVAudioDeviceTestProcessingChain"
@32@0:8@16@?24
@"AVSpeechSynthesisVoice"
@"NSAttributedString"
v40@0:8@16@?24@?32
B24@0:8q16
@"<AVSpeechSynthesizerDelegate>"
@48@0:8q16{_NSRange=QQ}24Q40
@56@0:8q16@24{_NSRange=QQ}32Q48
{_NSRange=QQ}16@0:8
v32@0:8{_NSRange=QQ}16
{_NSRange="location"Q"length"Q}
v28@0:8r^{AudioStreamPacketDescription=qII}16i24
^{AudioStreamBasicDescription=dIIIIIIII}16@0:8
C16@0:8
@36@0:8^{MyAudioQueueBuffer=I^vI^vI^{AudioStreamPacketDescription}I{AudioStreamBasicDescription=dIIIIIIII}BCCB}16i24Q28
v40@0:8{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16
{AVAudio3DVectorOrientation={AVAudio3DPoint=fff}{AVAudio3DPoint=fff}}16@0:8
v28@0:8{AVAudio3DAngularOrientation=fff}16
{AVAudio3DAngularOrientation=fff}16@0:8
i24@0:8q16
i24@0:8@16
v28@0:8B16Q20
i32@0:8q16Q24
i20@0:8i16
i20@0:8B16
B28@0:8I16^@20
B48@0:8@16@24Q32^@40
B56@0:8@16@24Q32Q40^@48
B20@0:8I16
B32@0:8d16^@24
B32@0:8^Q16^@24
B36@0:8B16Q20^@28
{recursive_mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
@36@0:8I16I20I24d28
@24@0:8^{MIDINoteMessage=CCCCf}16
^{MIDINoteMessage=CCCCf}16@0:8
{MIDINoteMessage="channel"C"note"C"velocity"C"releaseVelocity"C"duration"f}
@32@0:8C16C20C24C28
@24@0:8^{MIDIChannelMessage=CCCC}16
^{MIDIChannelMessage=CCCC}16@0:8
v20@0:8C16
{MIDIChannelMessage="status"C"data1"C"data2"C"reserved"C}
@32@0:8I16q20I28
@28@0:8I16I20I24
@24@0:8I16I20
@24@0:8^{MIDIRawData=I[1C]}16
^{MIDIRawData=I[1C]}16@0:8
@"NSMutableData"
@24@0:8^{MIDIMetaEvent=CCCCI[1C]}16
^{MIDIMetaEvent=CCCCI[1C]}16@0:8
^{MIDIMetaEvent=CCCCI[1C]}
@24@0:8^{MusicEventUserData=I[1C]}16
^{MusicEventUserData=I[1C]}16@0:8
@40@0:8f16f20I24I28d32
@36@0:8f16f20I24d28
@24@0:8^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}}16
^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}}16@0:8
^{ExtendedNoteOnEvent=IIf{MusicDeviceNoteParams=Iff[1{NoteParamsControlValue=If}]}}
@32@0:8I16I20I24f28
@24@0:8^{ParameterEvent=IIIf}16
^{ParameterEvent=IIIf}16@0:8
{ParameterEvent="parameterID"I"scope"I"element"I"value"f}
@32@0:8I16I20@24
@24@0:8^{AUPresetEvent=II^v}16
^{AUPresetEvent=II^v}16@0:8
{AUPresetEvent="scope"I"element"I"preset"^v}
@24@0:8d16
@44@0:8@16Q24B32^@36
@32@0:8^{OpaqueExtAudioFile=}16^@24
@44@0:8^{OpaqueExtAudioFile=}16Q24B32^@36
@52@0:8@16@24Q32B40^@44
B36@0:8@16I24^@28
B24@0:8^v16
B32@0:8@16Q24
v44@0:8Q16I24@28@?36
@24@0:8^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16
^{AVAudioMixingImpl=^^?^{AVAudioNodeImplBase}ffIIIff{AVAudio3DPoint=fff}ff}16@0:8
B44@0:8@16C24C28C32^@36
@24@0:8@"<AVAudioRemoteInputPluginDelegate>"16
@"NSArray"16@0:8
v32@0:8@"<AVAudioRemoteInputPlugin>"16@"<AVAudioRemoteInputDevice>"24
@"NSMutableArray<AVAudioRemoteInputPlugin>"
@"AVVoiceController"
Q32@0:8d16^@24
d32@0:8Q16^@24
B44@0:8@16q24B32^@36
d24@0:8d16
@24@0:8^{MusicTrackImpl=^{OpaqueMusicTrack}@BI}16
^{OpaqueMusicTrack=}16@0:8
{_AVBeatRange=dd}16@0:8
v32@0:8{_AVBeatRange=dd}16
v32@0:8@16d24
v40@0:8{_AVBeatRange=dd}16d32
v48@0:8{_AVBeatRange=dd}16@32d40
v40@0:8{_AVBeatRange=dd}16@?32
@24@0:8^{MusicTrackEventIteratorImpl=^{OpaqueMusicEventIterator}}16
v48@0:8^d16^I24^^v32^I40
B28@0:8I16r^v20
^{MusicTrackEventIteratorImpl=^{OpaqueMusicEventIterator}}
@32@0:8q16d24
@40@0:8Q16q24d32
@32@0:8r^{AudioTimeStamp=dQdQ{SMPTETime=ssIIIssss}II}16d24
{AudioTimeStamp="mSampleTime"d"mHostTime"Q"mRateScalar"d"mWordClockTime"Q"mSMPTETime"{SMPTETime="mSubframes"s"mSubframeDivisor"s"mCounter"I"mType"I"mFlags"I"mHours"s"mMinutes"s"mSeconds"s"mFrames"s}"mFlags"I"mReserved"I}
v32@0:8q16@?24
v48@0:8@16@24Q32@?40
v56@0:8@16@24Q32q40@?48
v48@0:8@16@24q32@?40
v52@0:8@16q24I32@36@?44
v60@0:8@16q24I32@36q44@?52
v28@0:8B16@?20
v48@0:8{AudioComponentDescription=IIIII}16I36@?40
B24@0:8f16I20
f20@0:8I16
v56@0:8@16@24Q32Q40@48
v40@0:8@16@24@32
v48@0:8@16@24Q32@40
v32@0:8@16Q24
v24@0:8^{OpaqueMusicSequence=}16
^{OpaqueMusicSequence=}16@0:8
B44@0:8q16@24I32^@36
q36@0:8I16@20^@28
v48@0:8@16@24@32@?40
