CN3esl11QuartzImageE
N3esl7__ImageE
NSt3__120__shared_ptr_emplaceIN3esl13QuartzContextENS_9allocatorIS2_EEEE
NSt3__120__shared_ptr_emplaceIN3esl11QuartzColorENS_9allocatorIS2_EEEE
N3geo11_retain_ptrIP7CGColorNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE
N3geo11_retain_ptrIP7CGImageNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE
N3geo11_retain_ptrIP12CGColorSpaceNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE
?N3esl13QuartzContextE
N3esl9__ContextE
N3geo11_retain_ptrIP9__CFArrayNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE
N3geo11_retain_ptrIP10CGGradientNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE
NSt3__120__shared_ptr_emplaceIN3esl11QuartzImageENS_9allocatorIS2_EEEE
N3esl17__AffineTransformE
N3esl21QuartzAffineTransformE
CN3esl11QuartzColorE
N3esl7__ColorE
N3geo11_retain_ptrIPK10__CFStringNS_10_retain_cfIS3_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE
ff&@
N3esl10QuartzPathE
N3esl6__PathE
NSt3__120__shared_ptr_emplaceIN3esl10QuartzPathENS_9allocatorIS2_EEEE
?333333
3o0/
?UUUUUU
?UUUUUU
.@ffffff
ffffff
es-8R
>333333
ffffff
?fff?
[R?
p^X?
.u?
.u?
.u?
.?\!L?
.u?
sfk?
.u?
.u?
.u?
.u?
l\k?
.u?
.u?
.u?
.u?
.u?
L?0e
.?Z)L
.u?
c?5^
c?5^
c?5^
c?5^
.?k+v>
.?k+v>
.?k+v>
?333333
MbP?
UUUUUU
3U0*
es-8R
?es-8R
?333333
m0_TA
sky/stars.bin4
4T"Z
+n1=
i;I<R
2_Oo);F
q}.l
WN,C[
s`O&
O-Kf
{ohs
3Cg5
$;MD
U#l)
D:MB
.P7^
{fZvP
9030
Q_IN
(,.qF
P/LM
G&7A
s4Wgq
IBI,
3ay}
,v3E
>tk7LO
`Wyv
1OHw
r2X~
kEB-WP
EmDK[
|~`
ulP
VY0Z
s^ zs
%F{g
Ipo#xOFZ
AMQ!C
P_kl
matA
a0-Q@
|M2a{
6`;|p}
VPV8
}z7<
y2Ep
MBbo
3$hg%
4Z!/
5vu0
e <<
e>p/
6Q{/
=fO6
yCS+
Ncgf
\%xn"
+vN
haB}
e|xs
o&b^
[cG8x
B>w%
?@nD
sJG-
uGs
E/\}
DT y
K-Yz
P?z/Ef
'AJC
]Rd
O~0Z
+k=p
g)C}u
l2C-
Vi:c'2;
1:S
7v1._2
\v+
sN2;!
<s,%
l8v:
MIxT
b%t}
Cp^0
c3F%
b}Nq
I`GwC
v>GZ
K4A~
g/Zb
bB~l
u/3I
^1?W
>zyu4l
|&:9
L/c4
<~v
eGX3E
`GC%
>;9c
$)S
PiF}J*
 Y~~
__kb
+w'P
BWH=bv
3se;aC
cnx0
{31?
J0WV
>q|>
0Ui)
2xpS
nn.v
FWy."IB
DB-ez
;5i'
*s?W
}qy'9t
vSd 
XK>5
LPD;
Q(z`O
D[s>
J?Eo
spm!0
)8'P
x}<:
c2te
;UG}
;Wc3
-OC6$
p=x!:
0vS1C
R{>uKf'
v/I{2
npea
B3j&
BUBm
1Qpe
`>fa.
}&U=
f{d)
"q\{y
B.a',
j9vf|+
XE'B]
^mtsn
{@bd
!7`E
qxv
SO5,
y*vBw
r$>/
N)a~
Q(G/
)(Z/
mFHx
p<Os
BcU"
|H]5
~E6v
0tsEo
QB''%
a<JH%#d
+D{I*3#
TeJr
:@zk
o*ZFu
(NOs
elyN"X_
c621
U#Ev
6q<?q5
)(q4
UN|gp
xfW[:
&lbs^
7P8!P
G"D<
\pCnR4;
1{~}
2fSz"!o2{
Z2XL
Xs"Y
itrW
0C2['
R=_'
Xz?J
gY k
*?#i
PD~\ Fy
[Cis|
Nq<{
B>\w.u
_hUO6V
\dm)
b<O;
{7VQ
-W2)
rEntu0
\]{~-
<ot[F
Y7r4
X0OA
8Qk<
|}hx
'Ti={(qS
c2vU
e9W'c
|}3X
/pVKg
VO@&
OoJ-W
,raO
{ ?/
D:h:
ky~k
 g;[)yz
`^Vo
yN[^F
Db:g
wk6R
Np4lKYU
Z$f ?
7SP?9
gQ_g
ZL6o
ur!r2l!
4]PT
Qc3z
l`s,
sWsj
y[.[
Cpgxz
?}7#
Np6-
ZJC^.
SSS7
EQ@X
1xXC'
,)plA
cCC3
7x#/
|j^3
|.yv!
y^2M
hwJ-
O44f++v
yVq8Gf
N{^@
B^}[D
_V{
jTMk
`OWl
EBWj
WL/'
AI18
boLf
}VDgk
KMRr
<r\kx
MO.}
uC1[
RMm0
I3Q`0
d<X(/A3c
K>&R\
q;vi
g)C}
V:=D
=rlC
PrE f
O;gD
<O09
x~4:
<rk]
2S)m
4Lfc
m8KA
E>>>
h6qq!
pn|.`
Wv'#/[w
BD<gYz
le~
#)]{
.\@#
'dG2s
rssU
J:fW*
46r*vE
Wx)F
CNd2k
vwMcs
azY/
mNYoM
NV[-
,}lR
YMK3z
~f<w
&rSU
#SSN
(Ay:f
b6qK1
]arkoq<
|^C+
Up<{
k)0^
;#+"
D8sw
}T1k
HV6N
Z,^
lXC4[
Egf\
t~p<w
_6Sh
;W@lY
c]7\
tcqv5
RsXR
}{7:
#4pC
3tj](
M>VQ}
%p.d
j?#oW#
va#)
UQ'(4
t|J f
/Kv"
I`YfM
9jV'
.wqR
Fp>T
+8C]
\zn3-3
#iS%
eN ?
Scn+:
jL}%}
h5XG
-a,mB8
Vwf5
8B_7LC
ig%B{h
P(*mm%
ssh!
em:O
Up.l
BY]q
c\vQ
q%v$
A~pe
\^L
[B&W.!
E.]B
s0{e
z 5}U
f1fO
]lq$
kzqM
T:v(
JvWm?f
@j#x
[,eh
99-
-fuTa
)m8:
sAk?
-4bA
XRbX<
we)Et=C~M
8PVg
zZ6X
NKa(
 m)Q
};>qn
Ja[g)
Vg+%v
zg&XU
cEk1{
1zO3
xMf{
?)aO
|h@&
Owavc
vHk&w
tlAgC
"1{V
cHWQ
w{;z
/IvLn
q<?j, 
tm/]
[M#&
a6nt
B(Bw
wO( 
_=SY
@n\WH
.AIf
@2p.
.+Oj+V2
I}e7
<_y/
YB.)
|(FN
_qZ>
zq%ut
;kXF%f
'yM1t
7}8Nn"d
f1r8vx}
!_cv
e}*j
Yz`+}
UozP
cpLL
OtA.u
Q5*?Q
hZ#;)%
mXF'Sl
XE*w
2s1{$
){he
YmsmvN-
S/fk
Gn1U
rlHm
'E`V)
G(."
K(R'
,'YO
|gEc
etNV
FR{/rZ
`m)y
)|.o_;
=8A$
syE<=
:0'-
zb~'Sj
%x]$V
idab
{[xn
&{f?
z8SsM
|J|1
#Wl
c'gJ/
lVj"
hEv$
AiJ$W
Nph@
?oL+m
FoJW
7chJ
>8-g
q'I|o
m"1k
>*4!
LC\x
gD's\6
1v)C
VT5&
&R=vF
._3G
Uel|C
Fiv"
j{+t&,
7e3M
Rt:5
_u!Zo
@CnM
1^4F7^
fL}a*
)r0&
Fy(c
_,<h
%Up^
W:qL
)8qR
~;l-N5
t'JZ
-;v
?ga"
<rk)E
=j8K8w
|L)s
((ig
mK'e
XG&[ 
*JYo
 Gp7
4nO<z
6&5m>f+RSI
hgfi
nLYC
O;Dr
3XDv;
'Elv
dg#|
E{$1
};z=yM+
}'mn
o\:I
sjB:}
(cx)
3W-;
%dc=
'Q<
/c0{
8+KD
osFn>R
et,d
g##w
~upXl
58g}
ANS"
47T"7tid
*.Xx
ur8l
<+yZ
S/qW
"?RoH
I,a'
}^j'
Ypj4
{>;XG-&k
|v'IN
3GkH2I
"zD1
{n}_;
zJ/r
4/.
MtX%
0W?Ao
vM2v
/kN*
m=&R+
r<g|Vd
r9fk~
JpZ2(U:
BZoa
`t*f
gCV%
[j}?
CZx^o
C^/7
_V?E~
o*#C_R
TIzj
CSJQ*
eM[w
=|XH
9X7ye%
'~^.
cT5k=z
u,y65 
~~s"
rcZ]
R+H`
gpj;
lCYt
j8AA
NE8r
\8v0
D|^hL
gh ?
Md"~5
.:WKo
+W!_
M"^nu
'%p"
eZLC
V8JJ!4=
|OZ;i
i8YG
:{T"I
8Mw}
;<Wr
.6v#
}O|l
%+jl
gO8cF
,M0{
4*j,
M^9$
C3Zdv
*)8)
-8qG7p
Y?69o"
jF41iwp
inKi
L<E?
mMKj,
M,nK"
*w=M
5$c?
+Vtj
D<}S?Z
BOV 
/?_I
q8;U
|H>=q
n1rc-e
=m^l
I8WTR
Vtqng
6.Xk
v6w'
n|lA
yJr7
2u;)X
c#(i`
*hEy*f
P`|D
rHi{
c[2-U
XLr>
rz~}
~bo5
nI!_xP
f+f+
+ymi
wc6f
f/bS
joRbk
L&41
y-qpwT3
o|.&
[<r=
+^&
=y^G
q"V))
Z^Gy/
HeA3
azo0
Trb.
>+'_
q'~8
 8il
w|z)=
G"/h
[iHj)
c(4\
SXK^
_v!o<fmV
^BOM
ys>q
HgR[w
YA^iZ
IfpN
yg:X
_z,<*
hU\'r
qlf$
2sc'
<p]&
^S8w
sd*X|@=i
;fo_-c{d
t*]&
4q}0fO-
|t'#
`*]-
x3/^
TrYy
5FT1}
]]lq
YFOJ
x_Z#}37
+9rp
RA%m,
O7nW`?
lEnS
<bH
7`xu0
r)3T
r0ra
Xa})I
u$Xf
W=[C
;RJU]s
<z~E
@vB-)
~u&}
3$uh
6r,9
cIx*
Sj}I
sji@
=I2y6r
0zF-4'
Y)oq
[#_5t
rvXc
YuFO
ak=h
*x#1
)I|1
U$;B
]NPZG.
}~_U
p~Mwe
0+kv
xRx=
#j/8
]6{+szQ
'y.;
XFg1
8<E>
FnF1p
|OIB
lSM3z
oZ> [
>m4Y
.5M`
WBSt
O,>Ce{
U4<F
!BVYp
&wm#f
Z-d,l
WL>D
~c1[c
{8W@E
*;06
_kI,%
30u5-
0W|3O(
c&;$
(&Q3
Wg-=
6N\Lq
'wug
 Z:-
"V{W
:nJ3
)%W7
l|d_
<Ay/'
]Xkk
TB%*I
i+)D
>}X/
<s#2/
<3Od/
/+C?
x)f{
6kV^
z:~!
Aa<<
w.8A
=@ME
IRtl
dCO<XL
Y94*
2$;\
md*
#{}C
]R(L
)Qe#
T;F&n:
^U4Z
88|K 
J:n:
%cZ1
*#iX
Bx&)
O_0rv
EJZN
/FNA
"&Fc
qzja
~R'`
lS8I
}Ql&_n
r-]M
$>Ki2
<!s&](
0rq2
1U_Z
k=5i
Kz=+
r-X~
5rb_
fo-c
[({Q
G-Bh
R1n6
l-jo
<g\N
uT`R
RGa$j
4Gd%
ph'}
|8W'
HbI)
=Z44*
xgm#]
C}vV
(xn|j
}4aT:2
m%<F
\T^NW
V"Syv%
1qtm
S]F=O
gA&E
H5v&6
9:<t
gr9v
Tsp?
4K;%
~S^G
}s~.-
5ROW
s(i.
yixv
OOmC\
vzbl
S1O\r=
d8XA;
wNF
:z:8
ns%<
Stx_
%GM%{
rwF*
/,1<
&{%<im[
#<Ko
pc=2
bLNY
:(1q
hrwI
h y6
)Dg@7k
f\_E.
]XcAO
}?\P;
3}G39U.
8J?y
zR8=
<r?6
F6Ou
f}<u
F@?TZ
4@/f
B?[6
5khp
Ohi!
u\MK
{Szgw
>dU4
f;bgA3
k<)1
I]72
n.#Woc
g)y`
|y~I
y,TH
VV`?~+
8>d4
~)4-
EN?d
]oZ#E
"<1~
Mxn[
'`-aym
,NhOcf
 75s
rgwR"
m,j-
;|jH
pgz3
;r%?
6=PJ
d^ X
Iu9)
 *}&
MV3\
!jU?
Z*U
m(-x-XD
^A/%
[5xP
+bIT
dJ.g^
PGNa
!{</
>q{~
2%^ 
y<--5A_
1Udz
m)%d
2W5h
_4e"
B_=:
K;I3
d&)4
Mk)x
R }]8
-x>vvR
JRhN3x
xJ><cW
u-tK
Lq~h
3E.'Y
-w7
=|1MI
g<eh
=(i;
j=-T*
S+`C
AE9s
W{E&
t;S[
images/border_full.png
%+0Y
Yk*hpl
images/arrow.png
gPSQ
774Pp
+&!///&~U
& `b
!sUMNN^MRR
:]M5
+f!S
P6q{t
oN2R
E`lu
;M<e
di`EOX
!0I,
}df=9
}WvF
@sBx
)0js
8=uX$
s#"|~HJ
Jx:8j
tI~G
`ExX
C^DZ
t>;7
vLt<E
P&R7>
(Nft
lhUE
[rTt
o+R'PO
<]q-
1"gdq
hvJ/
{u#'
a{4F
98(5
'R{C
qPT$
p&{#
@tqv
f39T]
55f8a
_6E(-w
$5(33;
VDgK
6sz<
#80a@#
5"vr
Xy&29
^Dh k}4
7OlC
icb'
Q;t0
bgQ
~^'X
it=5
h"9k
EYig
<hTk
N^dI
$8_!
;MWx
cGIeA
8ksu
Z-&v
'%,Bs
sM/L
y3I)}e{
\~9!N
H`^Z
XS2*
W2ye
$A'=
XM$I
^neuc
v@x>
~s.2.
?s/O
\zX>
D)q|
58'A
UEcS
='K'_
M;{9
~/j+
.":x:
?M.}
7_)m
r+`dI
'I_&w
$)Cq
q.Kx~j
[f|S
e%b$
sAV'f
0rDTt
>kPWQ
T{6R
;}{*
XG )
;y[3^
dPcSa
-<9b
~t(%O
W$)6b_~}
,IPF
|[CS
wgE6
c0|:
u_/j
ttm]
({ g+
,7!T
SWlK)'
{[Mqz
v/+%A
moR7
ix<(_
"_~a
v3-e
-ixQ
|3"4
&Z?2
8Pm~
o836
c38*}
<oKUK
<=jD
7__p
aZ3JQkK
qEG@
XMVN$
P-,e
dfg6
!F0W
m/vY
Ie%h
/bXw
h8SuFN&:2
t6f t
gL!|
p_di
images/eow_pattern_b.png
>&TN
6Yp;
.nbd
X[2T
-\gr
Ie8C
YfxX
:LD#
")%Y
*E!]Q
$f9=-t8I2
poles/northpole/0/0/map_0_0_0.c3h
c%\5"n$
6GM*xd
GDVw
6;jb
%V+>
fgprp
aPguA
v`wx
8'o}
4;7ta
?9eSg
(h[&Uv
)l,=
o]ZFu
7MTc
[]5-
W=cG
qSo?
q2fw
_e|~
-_jc
b1I+-
d%e6?
UGU$
+E{!j|.
.BACfn
t1O$
4q@,
xAZg9/t
+&R_
vxMP
aKX2
5|1D
_"Tvl
Wj\|
xfANL
>VaK
2l;9W5
"=XUj
wm)L
Rp;D
zeUui
z4}G
nK@F
mZk{
hCS:2
q&"O
Q+`E
7am`6
'8Q/
ADh9~
qCE5@/q
Xdo:
w'Su
cv||
pE~F
98Ne
6j_%K
\>tx
F:^Z
c~<X
ncWB
9X;|9
){`,
A-,N
<2WL3V
dpcaGX
:3P[
~X{($
A5!b
ew;G<
pM^8
DUj4\j
m0X%
/}]7;X
poles/northpole/0/0/map_0_0_0.c3b
q*AE
zIJ?
:[tt
7zS7
:,>S]c
&$&%3
bnAaQ
!i fE
L9[5
'ZwyB
2h_{
pm@k
}ty[
tXO}
W#"&
)N%|
?t*Ml
Je7a
wd%?qw
;^{v
`M"K7
>">N
fV7Y
F!Mf
*i5~
Ow`F/1
[B9c
:pFz
eLPdn$
`y6J
IDp*3
v@7;
R^Or8+
DLEl
{h1S
E[s.
dKh<
n@2`'
6]zy
]*,W
Pokv
]24S
+Eac
TS47>
x)TN
c?1>
H&@M
Dvb.
v,*f
hSh^
vC4
8lP.u
v@3K
&#FSg
yZNM
>6-/k%
!QxMv
=x4:
at.k
Vf=C
%L##
9Um/$
!hEix
Sfs_
":dD
37w_
_wzQ
"G{}q
8 Jk
Wwhk
,^mW
d5YP
{ulK
zCu=
X|x
>v+UEe
wl9
gk!P'
TWf:W
wa, >!
ps;Y`=
VNJl
j{F!`;
;S2z
g#NA
)*yE{
bg+z7
1TT-
LVvv
-}Qn
b<_=A
nC1k-
L++E
muku
?3Odl
0k%?
JMnm
# wI(
,b,\
MQ|J
XzKu
;wBLMi
F@We
87`8
YRYn
"u@;
>2^Q
L-FT9#
i\EA
K1eNA
oywV
i[=O
]"XP
fyP [?
j;\v
=B?T
p8,$5
:%>0sr
G\Up
1:Q|+
:neFF
2SU[
}#8]
;ueR]
4h-MG
#A.[
e!plR
[OFa'
boq5
f}.&
pu"1f
.J+Y
Bu#6
y!aa
6)Z1
3'u`=?
HZ5C
89Xk
x$vfW
lsyb
3>7/N
@K#I
\Tcp
S<y(
t\M'
f3J|?
jH9y
:rG7Q
]O?->V
]}u5
NSfKY
a=qW
a*AET
d}]3;
k3wC
^ki
%<97
sIr(
4Z!Pp
4j'm:
')AP
{~,*N
ml<u
Oc/[_cJ
X86uY
u@+Y
&guG7m
~97OHsq~
sIJD
vJJ\aG
y98q
R3dDfj(
1/c<
_Nru
g7Hs|
=yvc
><z=d
P9eNU|k+
1.wL{
\]Fng
gwBT'n6
 PQs%
BuDi
i]fa
qE*&]
(|(
C~IM
!16Nu
0!,tV$
{9U&
LEWC
7uk{\
90F+
Ps+~
{nX,+
;nHwdZ
;VTy
YOvi
#+K7
06b>
_Yed
+PDq
6t&B
2-K5
\)a$w
hEs;
SPtQ
+KQ&
uLfa
icu9
+~MO
JB:(
;4.=(
AkV|
P"6A"
9pS]
L`CJ
LS$32
lU=]
{o2.-
`1iS]
;R89
n/F5A1
JUQI
K\}@
I5%]
R}k-
xwUH
$b:'
7:d{%
i@@0}O
<!zR
l[!j
>[&2i
4(9w
7OiV
]:mCK
vq^J
#adY
Z; H
S]:~
k.`L>
sU4z
ZjWr
N1Xs
4\kQ
L:GdM
";YfF
\tQB
s]"e
F4Fd
q+03>
5*p3
?]dI
W:<LD
L*2=
7pnw
.j57z
ko-23Y5 V$B
v=%5
IH.V
Fe%+
ExRz)/[$
gk#NH
[a^D
4YM1{[FP
@LTH
4WzUFa
4 j;
+|\v
%GVhe
nS;P
%~`IO
`sUR
7*-!
'~=0
co'h%
'&k1C
q;_'
];"Z
:G8oBhN
gd#*
em.694
ykRTTd
$;7Z
]?y8
~+8Ey
S>C$lO"
"%^H
`i$7
9~yAh<
y1G*
>Jz'
3RHoZ
jv~-
aGY.v
ZwJ-
G)Gd
1:eE
"<*m
 &nb
A<4eLo
^H#%U
hmpq
<`0c
o~E/
V[v/
@T0(
B3+4
GN|*
[AL*
Ak'n
wKo~
Z9L#,
VAM.
9]TvF"i
ly#)#
@Ofz
:7;=
QG$^7
;gbt
w{zo1
]}Aq
a#)PYO
'#G= 
de?EO
eD~X
IR%j&
]`\m
x"4I
JCrR
 )kn:
eAIM
i9p;+
vz#O
?+HTy
?E~[
~?)`h
2J6}c
FG/X
$?No
@~x&
yd2M
^4:wi
V7P]/[
Xs2A3
b4;m
^!oNp]
}OOCu
|Byt?
ItT?
4u@
70\\
?x12x8
rSi-\
RY%a
Dc0-
vIdM
n@F?
hCFDsS
}"k3^
 +'h
l)6g
CL+Vp
wh_G9$
|6I{]
Wzga
QN 'x
@~Jx
zT-I
] 2v
Eht?
5h[@
{Xwr
Z}b!"
n1pR
1G)_
!aN.
'yUi!
WfQ
MnQ9
4BA>xe<!
M4kQ
X8sJ
hEmSe 
@]X1o
5Y4#
y4hd
JoN&
@Ormd
M@X.g
mYY_
c1X,r
#[Y0
H9Lq
E_jq
UeKpl
mvx]v
.>YN
yyac
.H=h
/lLI
,mMV
=};"
*ZQ%
c.lD
I]A)q
[j06,
,<BQ
5-!E}W?
{uo,
-!<wR
?lJ$
jGn\
>"1l
6aN"5
z:P
pHOY(o
*AW)5B
\tlY
g`y3
CCF#
h@K 
||i_
kci_
MKTg 
qnSw
IvrfM
mVs7
ti.>
gEUR_
b(h_
>*CunZ
+^s mj
 b6|E
{o!f
T;@8!
<:(A
#$_!
\n_g
v`o^
mz,(
~Qqb
cbels
<*[Ci
5kO&
rOcgA
QAe3
%xjQ
fm[V
 wAE~ 
.d(9P
|,fG
7o.9
6Vs~H
i]'$
zmpm
p|l8X:
|q`H
C!At]O
vWe6T
~v:=;
[`U 6E
f@71
C[(k
SgKF
t 9#K
N?:G
l07i
yyZM
 ]PQ-^
P'*:V
kE.m
]WZ 
7s=h
slNO3
B?tM[
So|{
-~8:
FpyH
]9or
"*GP
}w[.R
_2<:g
'7O<.|>
"|IN
KG-R!
7B;`K
sgK'
]40y
 h3F
w(nC
27Fq
{]Af
dxvd'
:^Bm~
0~D}L
bym`
[^ntAZ
*rK]
}3ZH
lA{w
9>TJ
b4hZ
I?RUT
%>^f
,aP"8q
QQHX
3! i
OKHr
Jc~C
WY<U';|
s2$A5
B~v]
O4\:
P1j=5wnK
y5VU
OYbD*$
uEYH
{wIG3
JTDE
fz>>
4-4\
?fww
3[J~
^k-"
m4f,!8
GazD
{Llo^
Y~ L
?)?0' 
lv!I
K3<Vq
;f(?
mrwA
Le^z7P{
!Cl0
s=$==
>Sl0
-@*L
}sEx
['|P
_@\^8
lAKN
.<b3
J\wB
S0[V
V\$'_wn
B#A\
uK'!
q&wpN
C9~m|
z@K0
8CPw
}Gf3#
I"5N
KUj<
J@/<
ecLB
;!?{&O
=6gw
'F"7
!q\z
O -w
y{.w
K9*6
Vd2C
hb8D
I[5h
c`!C9
'5|*N
i9]<
~Jx%\ 
6,=q
Ke)p
HuEe
eu}W6F
H?Hrimq
sUta
}cT#
tmr?
{sK+\
."'Z
3oK|
M9l@&&T
{p{P
(SNn7J
Q,f`
8IDl
[HW>9
m^Y-
N]ZQ
jku(
MktV
peA?]px
A]! 2
vW|M
',0O
lWx@
YAS{
g4CL
FoY&
D_}\
_3Nf
\Sagvkk
M+A7oV
=WoG9
ye@<
o<d4
p){9U
Wo.pN
,/IAU
OS9V
of*o
&*~H G
_Dv 
ChiB
( z*+
&J?J
(}p4
"4^,
1]:"
8TTbc@
24[e
:rJ(
]:ksY
'J[&dVi
awP[T
v"MI_
8F%b
x"bL
)6*oy
dVRm
?WTOj
[NpV|
VUOx0-
B@-o~
S_>A
jJbX
u("o
8\!%
MNzd
Q?'M
7qB'N
hY;!
)/LR
|(9VPo
h"?v`{
pW]~,
%!1SJ
Jl3'
-N(hO
`~YE,Q
o9/Ej
~1p_T
6_2gRFxo
60EF
C?g5
b+W*Yv
Q+l
3Vvd
yLdy
H(K}5)
&}+P
BehL
VK%Z
["uF
dWENvf
"k_wm
W!Lvvk
L[l<
#5!Fm
|hGR
(GV/
Z=cJT
H>p>f
98V_
c&h;
B_VM
COo-
vsu-k
|hA-Op3[
g}0,|
Bc>?
8"2t
0^XZ
sV=%~
qv[|p"
{;O+
tU5)
2bcm
c/Ut
*XZfW
nw8l
G,Xy
dl%{:m.
z<.L
}!EB
P,(j
:$#)
y>[3Sn
uW;g
^".=
]xtI
Xn?D$
885c(
/T'X
`F%x
O@v3.
mL2Ro
c)]r<
$be1
-(b}v
.|]t
#=vlc
vgv,
h)O
 rD~
j!LD
T;DZ
Kw{"
 X;B[y
_<vr
Pg=;
(-T 
Ev(gC
IuJ5
UL&b
@#C*
=o2h
K(cn
~m=B
Lem[
%{Rw?
fKZVf
J!-
NS$pL@
h#^q
;\tb
^[8"
8>Zp
XlLX
_pI"l
+H6l_=
ndo,
b--7bT
nm@g
O^A@
!P%d
Nzua:
>z/[
;P]c|
}cyJ
{lgi
Rv`+N
'JKf
C9zd
=z|8
^(9Q
o<N
8Bq
\K0VPF
<llFl
f`D@+
e>N<7JM
-(a3]]U
HDa%
!l8{
BcX#~Y
PW4R
r>{B
}[m8
Ki!r@
x;gCB
YrI~
Q8!X
\?L6
JT8&2(
_ocCf
{at:
"-?G(<
Se@kG
}NX//
}=fv
E@LI
Cs%!
9WD6
axg%
th#j
5f~~
ifs(
W\}N(
CP-f
C-0B
`u(fM
_q6M
{S(YS
ppYo
G'=O
UCk*
w|Z?
Tw,D
7N"|
Q}(xpb
)?fj
&PC0
@B=$
/ 4/
pH;4
\j+xv
G<Sj
>;6bd
nepV
]aXZ
N`JDW
cE;Y
A,9#g
NEzN
o%]i
2Kt3
MQ[q
H/Ej
P}FA
HS\Z
;#Hw
?Fjv
Lw>2
81Yn
x#_yX4
\%LqfK,
A22Ghv$
4`l-
q&2$
%omZ
Ethe
!_L9n
$:9B
wn@FB
q4/A?0B
F3QDt
o91
9[&)
's~Ol
Klv=z
W#A"L
3eF.Qly
q2.,
aC#w
4"H 
^Qj(
I}H 
9MVS
YSVJm)
MHRW
cY8\
u.IE@
CK 2r
O'5l
>f}cJf
ShHko
6Mq7V
RaygXe
?G64
+V}.
Pl+J
||MUr
Q-n)9
IH]]
UY<V
LZQz
}|hq
xnSb8
%~Ta
f~y=
AFU=
p\)l);
k:S3q
C~H$
 Iab
@35%
sx:oKg
!@;K
\7I^
ShpW
~jOk
@RpB
LX~a
iMA^
csB"PKu
& _7i
SyY7
^9t?
Mit0
!w9_
vAr9^
OZU]j
nwJVgp
U7^A
 H~[
wr*U~
C\~ 
`rQnRN{
46]n
Kd@5|H
1"N5
.+i#
Bi:$
Lql?U_
(L!7
!HJ@
>A/h
8!@g.
 ty-mG
U:vOq
/2!S
xuah
k5/7
xjmW
]r!X
[S$#
}lYFG
 os+9
pa{q
raZj
%(p%
"t|c[
DPC@
~LO N
=I'N
j-+QI
5DwW
NtVN?
&Z<$w/
H)m>
q7_[Q
NtJ]4
#d*KB
Mup/
dg;t
3N2Lw'
Ur|x
e=r 
GnNq^'
;au[eO
>D[Z
62~8
uL%r
Kq/J
eBk`
G.,n
WNfh
"1q8
N{IR
%<,sak
M;^4
i?%x*B
wsa.
(K~o
b9L+8
y.X}z.i`G
{oJ-
8i{:
93Dz
R`P&
S,Z'
Qrdg
.@9Ie
rjtR
>+C
7|<+
uos;
0Y!:1 ,/
ESGa
!Uro
dur!
n-z%rT(
aR&et
1h=F
x!g&
Q4Ma
`ene
$bM(50
5O<O
r/?%.Qz
ke3`
>Tg?
cn%i
E$?b
MjAB
:*`e|*=
BV):
P/945$
7JO<(
EK(i
7g2QQ
QHIy
dWKI)
*GWpwp
/~y87
%k'K
7`Ae
<3<qT
z8{j/
R Kj
5`#C
p6iv(_
i%#@
boX6
dss-G2x
r=+#
R6}r
iNLchA(
8|$|
WT4f
-62D
%+XR
s-Xi
6Z5#
)zkw)
7fNh&
cjB3m
-af'Hz)
'Bsp
6G'6
<V]&W"
RQa_
t3AL
6ABWK?z
(CqW
Ypk_
0zh+
f\-G
L+%_
4J!\
]jw
29E7+~
BPm01
IR4T?
A!2LC
)]&?
eO]/yK
r((kc
jx4*
|OJ:
`#!u
m:w /
O6u2
/]k!
(\[}
H=wE
bWT/[t
bAAY
Ry+jU
tv7i
[ks{
Oc/~
tt8L
pW)go
nOY6
>;63
W;c4
_+0O
 I4y [
&<wmmn
vw%fN
'S~\
]Kkm
S/1yK
Thjyu#
{N.p$
]7$B
r76t
/u@FQ
xweAO
Ul#/3
&K?k
w;o<J&^
Tw:Y
KEl$A>
%?6w
j/tAG
kV?>
Jh~J
MC!?
N[aA
jxMc
_mB#
=H-V
7p>C
nT.w;:
3k] 
u~6xg
$c8-
cAI5
N|w'
7RL_
@HDG
0ckj@
(Ksdc
F0:P
ZQ(P*
3/4dH
6FmC
s@B|
pKgj
}3C7
EDxV
eotw
u4;Y]
4.w<
h05G'd
y>v`
<hL8`
YoBK
nPS"5k?
N5t^
K+GU*/C-
/(f*
Dvk!%
O{Wbp
8qxA
\B3]
0`pa9
{1jIz<.!
X7;g
Wb!*
@g?L
c0cji
>Jx>
q-oss
iOL
o3O-
"\C+
3cEj
:1ua
}Q0{1t
seJr
~EVB
CGVc
x?kC
\c|,
|:oA
`^ba
w(i4O
lcL|
$Vr{r
H9SL
xjAg
2yFIY
=teDZ
Gs2\
RXK4g*Q4
5dHw
0TP&
x#f\
Iu520
0*1}
(9**#<(
()J!
Jm(Y
Bj18%S
oWZE
;g:o3
l^lr(
2Rbo
 `x'
!@Fs
;1msql
W[qVf}A
V]yi
n{xT/l
%R=]
{/&d
_[@q
G=Wv~
g*Y_
MZ+z
f(?k
lcx8e/
HSl1-H
e)wy/
Ap2lu
?*i*Gz
Ese7
UC4!N
:7{L
+6{f
tkP*
6HQzl
s ^8
f>g0
.: C
g&Cl
m5'7u
_):n~
wRHe*fu
7w}]
O@S=
50;Y=Z
1s=w
>R3e
$6`/
g[nm
^*"_
`7:E
%("{
JLX!
Eg-,
s'mq
D=|U
t^%+@
:xs3
NUvG
}5-&
1{OH
ctMO
9d*{
G<%U
HD`W
P[dO
5O3*
!sY-
Y-/B
;9*:
.gxalH
[6=O'/
heh0
CMs>
mWb^
`-E#
L#TTZ
rGDff'
Sz!;
*.y*
T<p}w
G.m6
$-o
se~z
t_Sr
\>3#
,w~'
z!%E.
|<r"
jF/
es6z
7Qwwd
'vm]
VSkCo
t]I 
y(Hv?
*`}Bo
"vL1)s
\$L
<zGxh
FomX
 D,%
^F/Z
W}bo
uoL_qa
sU:c
X{TK
Gw\9
i^od
D@su
0Pq
I8RN`
EoBX
!Y]d
D2~p
-llic.
)JEq
f?7Z
! ea
Jy$O
]mmI
Osop
UU5k
d}}n
l9J3K
l:G3
=BgE
vkx}
~oO-7mFX7
i12_
w}_=*~[E
dPPrw
{'I^
IrRqw
,}kB
#TD:
# E3
wk9}
OXP#&
:!>D
F7TzK
{TVE
MM?\
Za?2
6-f/
neNa
WFNB&
GUrfM
EQD)
+{pQ
vPPq#
Jq}Y
E#'&
!=b8
f$ba
fxkz
<.fo<D
7tl62:Y
(T>K
uKY 1
mBv&
^A{gZ
>a#Ru
}!Gm
H?s}$
~Tz!
4V^p
&> _
$]j~
_er;
N#,.
F1~0
_ei&G
zspHm
4'};
7S.|
(huE
>}xKa
nwPr
L|NdJ
"yW)w<
VR*v
9]%#
&% 4
m>2>
GkZQ
Tjr1
CW79
6Vnl
}|nE
|iz8
Y8c}$f|
{P;Xw
,z-u
[0;9
qOY~
EeE4
=$Iv$
}|"H
=(qr
]-&>S
&V>X
PO/<
*n2R
owks
99.U
|Fz`
nz27=
Pu VP
Q+W,
u"}F
qf@0\q
8s ?
-'CXW>
t):x
>{?g
T8)L
"&:Ll
FV/;uie%
b[WRa
E*Hi
m/r)
df'3
y^Uwc
OPY>
B{/*
h>mPP0e
Xh/A
4olj
MFeNdj
3yVM
M"5kz
l[DF
i+#$
0^[h/!
g!YLX
cId;
1KhW
TF0=`
=8ng+
4!*~
n|4A
%)\N
<Utw
RYJ_
vHs$
YQG.S
zY&KzK
vf^\`
M"Z~
V%Ha
b)+J
 i[Hr
9;9wJ
q:2x
oEuk
Mn8]8R
O6!R%
tm9L-
,1,P9ff
~lI
6CF.
{]uo
dT9G/
PY4V
b@+c
HEwSB
e*xt
3lM[j;]
@wfprk
6j::
&&[
Od`n
y86M
r"Wd
Ny[@N
Q6TV
bMQ}4
x4{5pQ
eyX7
R] \
oW5_
!U]4
l(!)4
A'VS-
0Gwn
"LrLd
T,9pmY
;,N5
oo>Fg
8,!H"
HdWq
&oW$
\R"Y
!kk:
Z_G9
Y|_"Io
1,v)(
9FG2
WhV%T4S
$)z~
U#4|
5v^sT
Tu"Y
k%$&
C12z
q`xM
IWOA
^tSt3
y78`
]}pME
2%H~
kT;2?Ij
H75O
$iuGw
w:KtC4
ukgAZ
tQtc
-<])n
l*hj
u<6U
GOTK
DLW0
2=w(
gp;C
>AyE
65op
Sd#?
Q%.xnv/
j"9-
ETXar0
<2(z
%C6
oI(B
zZ7b<&
H>bu
^8-1|
-jt5uT
HC?8Ru
H{NHa,
>V0h
UcSm
>hZ2{
&['d
S~iW^]v
KCeJ
]F=f
puBDS
X_dP
w>^<
EJ$i
BM^xvfLX^
6yQBM
:t#d
WzD@
R8-V.
y-Lx
UiK`
lwbE
>4G/
1<r.
|S0n
M6_&X
LF^Q
YdN5
5@#C
ayRr
FE{:
3db6
e]&u
ZvJJ
BRF.
q:v:
+gF{V
^^^Vv>
pQBRJZQ
{xza
Nhn1
tVEN
w+Eo
:tZp
q^a||CM
$Tia
V%eI
8O+YT
t!Aa
j-k~
})?B
t?r`
yaVT
!@Zv
CT/
eF]a
8zn:
WYR|
>z$"o
6t.^
U:}2;
BilpE
']s~
'@MZ<vk tU
vE_'
]9\nkh
Y>Rq
9C[=
(!OmG
UeJ<
d:a3I
^m0~R%
_KCrl
>)"r$
|.5]
Be}g
@%Y5
\?d2
1C;X
\qkh]
&,D;
aeN<
:D2>?
}jo2
.Z<&
/>l}
#92bm
pP&3
7DX)
c>~L`T
X7m<oh'%[y
,rg7
NuI*
4&&?t
p\i\
y3'}
wlFEr
3Wxe
x<;^
mnM~
"=f6])
h{]@
jJZR
z`SI"
wEQk
<{L<
1v=9z1
1<st2
CQ=5
zgrn
57'&
4a%[t
[Bv1
L>W(h
9l_>z
0DKV
),oV
2yjA
VJ1o
"o$wCS^
SyP%>
T30cIA
]$Y
f<6e
rwT=$R
a%<U
}e}1q
q5:y
jx5)
+CFD
*Acq
No8x
^`Vm{
{5Q/
6N8uYfG
ad(g
dKbYFZq
=Fn':
bpxX)
}Oza?
$L<2
oX;+
%"<?Y
sTkT
J*DI
~ zg
T\Er
;)i7
ONeN
l/;z6A
'.<U
P{GxUD
bUR`
Rt!S
%V1:p
svHQG_
^G=s
JM:&
kj9N
Dl1O
:cvW
4Y2-
eM.0m8W`6
\QM#
RK7\3jl
$?9E
=r<a/H6
;El@B
x6S-
yFeF
%<K>
YJ(4
>b-s
[|]$es
Y/|!_{l
t+=@
@$bJ/93.
phc?
]/d]
`.n_h
hP}Q{
DR!Z
ZU-/
pX%yM
Pr6I
(-YO
C>W"
0:Kp'
/@]O
~b=h8
<?|j
?ak`
4nbI
MSqY
FPKGaz
O5"A
'`yb
b)Nb
({3 
..j^
pKt@`
-d4AQ
(aAF
3On{
9[1~"
Uj>>5
1i1Ye
Y<aU
@:9N
Q6S@
y,FU10
XSWj*
DZ#EQ
'.=\W
<dM%
$(qgn
)% W@
K|8qL
=21(
Y$k/
"q-/
%X7](\y'
D=U0
#>ub
yAL^:
n3il
l,cT
!IZB
lnq}
zNE2\
v0F
XJoF
cSd3
H38z
?C=B
1]FgP
B!t(4
toc(
'8*w
h0Mr
xmnC
59+JMF
-oA&7AO)
O<0P
`nMY[M~;`
F*'Pu
>g0y
,q?2
!F.1
M%C49
X@T^
VXBh
z^N@
C)@I
8BKiA
&gj6
[Q5
jRyJG
j=C@!
N'-0c
f&wO
1:.^a
FsXT
j}6!f
g6|3
(Nb3h
5M\1K
bTu=
-'> G
'[=
3:%t6r
zSx0
Nnsx
@"5J
/&[,
GVZ}
E]SO
D<6s
mi+_,a
,<~K
gF J
'6R68|
C5}BQrzv
vwJK
Y0FU^
C0'i
0$S^Ta
Y>MPxA:w
Ln0t
Wv9@O
V#/DO-
E'W?
/s\4
Qq1xx$
FszQ4
K?Lr
2>\;
S9g[s
dCbf
r,K+
wS6O:yi
T!rE
bKj{
[Z|3
v(oc
W2'i$
{Ep>
R ym9
3RnZ
(MM}
*Cn^
?]74
}v6;
([uRx
 `C3
=,a1.6
DSF&
_VvbF%
g)N9}
mirY
>5])
3\7N
gn!+`
~uWis2
E@BK
Z@!!
|zn66
N4N)B
(hO~
&A\4J
-II6
00#V
nQ"]G
F?#'
f*#f
.[w)
dvB\)
_/IY
Ce[g
(t<>
@[_C
1l8D
2C}Y
%gt+
QWI<
@4[D
[)&2]
F{{'[
r? ^
z5o:F
y9#9i
tAM
MPt+
bk7,^
Z(s{
!-r"^
/-{I
0OK8
c>m|
!46?
$gFB
ROH`
9r}U
%w;6
yeRL
A<P#
_n{{
<)!G+9
ry!p
3jjZ
poles/southpole/0/0/map_0_0_0.c3h
)"  
!*"*J
 HhI
-998
:/m: i
wCcs
:{8:E%
RWm"9xT
rP0Jx
=wGd-a8!c
z-iF
V2f0gJ
MQ|9FH
iHsHD
`,:
e7Ph
$Lbi
Wh2 
cUyH
oTL)0
vMM)
!36)
mftH
^keX
( gV
<4`
q,7=
h7*>
R5+4
-F}f;
\Y-sK
8cTi
2!e#
1$:.
I,,Mm
+3}(
LjC2ur
V2;-
9F#'
v"&m 
:BvoL#[
WqPH
LM^Y
ytmC
Voi"7
,*=!':|7`
r{4E
.8UvP
#R5o
[0n1{ 
TM.|
AY5_
lWYU
ZIT\.
Zx'"
u!G|
8ud/
Yqm#2D[
jde;
%xW2H6
g9Cc
L14R.
M/Ul
1@FH'
-wM3
w_>M
klym
?8m 
ar#<]
d0l#;K
6A l
6Jg<Ri+
wazoQ
,(m.A
|h,|Nct
]GK\
poles/southpole/0/0/map_0_0_0.c3b
Q+E+
ba''
fKc\
=Jnt
P_Gg
l]v&fhi/]
XTV.
/0DhX9!
2<wa
;u~g
hzf&I_j
OY9')
94(@
mX=3t
?F_m
ZhA9
Q;NV
GE@(
N$:8
P})|
<g'z>KPN
sNb&
-bPd
\m=4
hI1;
=>\8+
$tab};
kyZuo
=hmE
ig>:z
]WWa3I
'Dyf
jOtn(
,j_n
nDP#g
|`)A
m% ?
AMnB
ots-
tr7a
U?R>
pay!
a[FY
S2;K
J\xQ
3_,0
WlED
58oa
$y"3
h.A%
fd=B
aRp5f
g1})4}
Mzmk
8Ea}>
Kjip
{Vf6
w!-^c
or-r
v7HX_
^$fzf
l+2G
T.6=8
*v(Z
^`uz
RG|P
r6yf5
ovPP!R
>{=I
[@Kt
mk.P'
y8h]
!{^bS
O2eGv
,Mz0"
qa/O
az3A
]/OL?N
H6bz
:z?#
Qafz
x$dP
LP1ns
wVz$
<hVj'
J0L$1}
],%%
s.vl
v83k
T}$N'
PT@vk
Z3;r:
4pSQ3UH
61E^
u7<F
UI9o
N;B-
S#Rj
aNMa
x,OVp
P$Ww0;
0B+KCb
I,G2
5#i&
W2:*
8;mX
wKiK
htAf
?pP8k
%uq
%s;u
dnI-
rQPv
"W.O
'{S5/v
OQD$
L%#[
z,M/
0F2.
gx|bN
xc"*
nZsZ9
ocx
=n'Y#
Rz`!
"JefL
k}jc
&kK*
p0Bdi
NN@}:"
[5Ag=
qD8p$
K?e'v
'^Un
*qy>
#VlH
@*94
FeaG
^]m0
.b 2
A~7.0
tUDc
--CD
s1W3
htC]
xozk
c<2i
\<0X
7U\R
{D&\
GV|6/*g
c[|\2/
\wws
p" 
yR//
'\\'=1
 cB/
C5t'
]ucv
^NS.
n.z&Hp
a[c#)[
]--(
cY/oEy
l=8jo
1X6ISa
l-)+
\[TM
RywQa2
s[WNL
o*xV
uU.9
^c)z7
XEb+X
jSq-
:[Al
b^uj
nt${
&kqI,
"*X7
)k3K
ai@?
z_ia
[4<$
7"@r
&l9k
VQ;C+_
W"x 
z*Z:R\
!5 ^
*yu|
Z<;[y
lpnm8
l1/R
T]q
iTk1
SrLBN
v=<n
B6{m
,Wha
*Gr
] ?'
TI\n
l$L`
_ NM
>2*4
""pN
g+Zy
AE&'
s/M[
8Y!f
p%y8Yly
7Akl
=onI
#DV_Ep
Z?=k
-M:w
S0W>
Dxtyr
~^,4iU
g>S@
U^(Wd:
G[g]'
[wr.
Zrt(o
0*)Q
~F="
$Xi`
RO#c
+<UR
p^I9
pU]R"
vOsM
Jpl~
)Vi8
[=xjM
E)~T
_k2/
<B,s
=+pM*
@$hC
>&*J
3/|"T
>0hU
uBY_
Lf?R
v\y
8;^zkH 
g_.FY
|Xj2
l_lr
-\U'r
>}|Cwh2
"SUw
[`@N
;>OG
Y.7r
1u_tI
65wd
n"Rf
v359t
r_y*
;6$w_j
`385
<X*"
^7SI
qm;r
?2!o
rNaOK
by iJ,
:+)9
U=%IN
A7vg5
&40e
KjAT
dXNs
m1I\GiD;D8
BA5y
]yI1_0
8iWV*
o,~"
u2<Y"~n
.m?,
4V85
`{>-5QK
p HV
3h8G
NAEa\
K"VF
S#2
w5NKi
shqSB
&qJ*Z
|b`K
gB|=l
pW#-
1'gn=v
4!H)$
A98H
pKJM? G+
tX&1
8YCk
mCSz
mzQQQ
Ij$|;\
]=IaJ
A"+q
kO{<
/N @
NWHV
*A^!
uT1=&
9,U-
CyH
7s>k
>Q@S
#;sq
V:5)2]/
.FTUf
1:,t
3{)P
LXAD
#bW$
6~O[
]Miulyh
W|"
rXo^
:-2s
ih"5
f>~q
scpA
=}m&
/|v.
KLR"*@u
Aj,Q
pm$U
ti]
 ruHcK
f2e2
+sR[
7b?'
rsf=<
0h@p^
hGQ
]'U^~
H/,tc
tg=
Q1Daa
@iJU
%y5T"PzU
3 _yf
;^X}_
B>iZ3
Gv>(TE
(<<QN*
DjA88)
<W}|
.]^
oPYv@
I (
qA9>p
\Uj>Q
R<^xU
Foe
]$~2
s1]Z
727J
+$tMo
BV']
'GTz
Oq(ch
U}2~T<
A${Yz
hi.f
d!!Ap
6ahQt
\STT
v#?%I2
,$7,:
q2&-
vZdc
~G.a
=5Sx
x<@|
/HT_
#\4ud
7/$l
?d]/
#v.i
F=<\|
'8.7
X?J[
?4*A-
;\2&
u=*i.h
&wew
);Y
>y4 L
HqF="
y}mr
<?y,
~-}0
IK\)9z%tGZ
HI9Q
JIHS
I$A5
b|7+V
'2)ei
1%w<
J:-o
kK-;
\.hG%
CQ8~xT
:"P&D
ufu`
t<<
L;q&
gbrD
=&7$
fN(
)/:fP
z$.C
d&2V0
6}C`x
c\;u~}<
J)xL
Q;x!
;ewx)n
`~oRE
|?Ch8
E''QX
8^u$
/\o<L
(p4L-7
)yG>'
CBD;
Wxy<
s8y?|
+1*Juepb!
BCjo
.h?a~
CQM_y2
u_zP
Mf;A
:'B>
F.0f
BQ3!
71y%
x;4j
50Exj
Sh18
Tl2
?!dn
C2OI
of=
T3/M'
r.7pY
eXSA.$w
wcI9
$q@<
F#1bep
LD1Y
duKe4
/i\M
f=h2m
E<lW+
A324d
OF*>
@/+
CH=o
xY1n
-[$/
y#fh
*T;O
+O"T``&
1CJ1
/Rza5>C
k6G^
g&LP
&4K(
 3zq
@6Yw
OVfH
\_UH }r
p%mK
^X?F
JZpc
{j#X
sbMn
X$K0
>b]@
xt11yp
Ao>%
_33^#
1QmXX
BV$N
N_lo
RK\)
J~c 
n-Z+<
|@ %
v[OWh
ro@mD
Q=/~S
cq<mgN
bY2%}p
~9#v
)A&D
a/_Q
,aiHx
^r1i
btZ2
7X8t
P"Gk
\o]x
aZYM
s{ss
*C%uQ
L!VlN
Y@h<
ITV|
`V`,Or
>uC5
'S"*$.k
5\K+
hcW>y
4ULz
I~'V
draW
*YtFA
]A7+
I7RO
wU[2O
@At)3gZL
A^]F
V2SN
z&bO3.&
w0R;
ZU\x^
_fHqW
LjD.P
VLW^i
2CqZ!
7q1Ibbu
/@FL 
XR_8j
x[]>$
u>u{
i~_j
bO&4
M+u{S
sW4vKi
E'4Z
.UWD
QfpvF
#|;V
YN\O~[@
wiHI
~DHvS
_UUh
xA15Q\Pv
k&!2ZF;
tO3v
5Y}0!bn
h1:_{*y
HH?*
fc)7
n9CG
}QZl
+byC
4gCt
|';K
|Nw[
ppzpj~h
b3^S
Mv5G
1(!n
BP3{4
M18{t
1Nh[
]?PE
1>7*s
;Q9Em^|xr{
t%p0
+N:%
Gn'[6
~{UE
G}$yy
Q!-p
N=90z
_Yv[
qr\A
M%M~
SheE
&/#f
",KQ
A.Eg
Xi{O
rh?W
?Z^1
X T4
{&-:
^Tv=M
=AGT
JstA
Qmcz{[
2usu
't/xe
@zgg
 MEnN!d
=p;7
v$s5i
N|R$
PHyw
b/Gz
Rpo
CIw 
JHww#
&Q~-
r:s[
ncln
*6[f
Y)<P
>J7a
ytcj;(
'Sc3
[>wx
HI,P/P
J%~l
C$mJ6a
qbdO
-<b_
.w(xY
9a:oX
5BE-
392y
'y}eU#r
]W-5
hM]c
Nm4~c
:>d2
s{gK
:~UK
x=|G
o)CY
>e1"sQH
!Ve$
&nv_
\^OU
Ap%b
R&r*
;rV%]h
;Jq
arJ_i
_q71z
c>2l
:_?)
:X&$
VJ,`
7q|[
7y;N
>iS}
X$b+;
&XK3
~utY5
$3v=5=
|4on
b*29
Wr+&
J@pL0
-D,=.
w/QM
A"Y$
2ALb`
foS[2
z*K'
|WSd
 *B5>-
;-7u$
GRv(
h8ya
#G?c
F=97
"}fw
_Bb`v
{#h)
_"FF"1
aIo!
~TMM
XI1Q
,0dl=
yfUd
H'"1
W[(/JB
bn&yk
Nk]]
?^T2_
q{r>
Ztd]
;~TL
JLrO
lXRR
XT5>
nk||(
 %ZnK
kp0U<w^w3
9A#X
-W}um
W3QH}
HYD!
tj.Q
B&NN)
g,l\j
!D/=,
z $B:\
C'g-W
K86d
Ad(Xx
L/)*
*Z{E
kA !B
BF2l{Y
?Zw%
<8@u-D
9NgL
z{3+8
BTt5/"
!C6Z6
0Z|tiO
W:feJ
ZK V
mBmkr
Cm%
F+[L
8'Us@
/XY]
p9K1`
nAz'
9&]w6t
Dy]2
dAs!
e8e{I
#@g[(
%kBw
3& ^
';pE(
h;6#
^*nZx
:e,;
HNF@
 Fq)
sn]e
w_FC
ei}I
I{Kk
!$Hj
dk82
{U.tT
3 ZOi7'
?doc
T}Y3u I
24pk
,>8Y
6h^
{'F=[3q
ABz
+>xi`h@
U&+9uBI
OUmr~2Qod
o('Cm&
)/@Gc
@INb>
Bi`Z
t[iR
h\9<
*,m7
h?Y
S[)wRI
LHg
sh6z
{]TB
[a7E
UE *:
&szR
@iCu
4eU=a
o|@?%
s'  0
WJ:6
H9@_7B
T\aj
euJ$
S[6p
JJqp
q4Df
TaV<2dT
Z=o~+P
~TX !$
TaK+
&3_5
mO[}K
nT"O}?
[k8L^
*N\/<
gJ,w>9
\Yk:
H`$'
+A2%&
+2;.
kkon
EuUh
Wz~>\
FsLY
A8<P
RBx?
,j;~t
HC`0
!;r{
NW`p[o
Y\eX
|s9;X`
{v5}sN
ERmlR*]
u*v|
iZ[Ksc
$S,7
_R$~X
^M+I
?u4
IbA
i;0X
)~f+
2vO&
oqX?<>4O
u|U4
KP]k
I03
f;c@
f+u;
>\#
>~WH
5]'F
>9]J
=1_8~
i::Eme
jWF+K
.qj/
~!|6
ViK*
e}3A
G4g]
D[y5
MJm+
j*_1
df}
Eex:
@aP(
:T`(
'=(f
N99>
Ji$z
2W"
sH!_L
FGF8
,G|P
_1O?
n=O
pE(9
=)x#
}GC@
O^={
J=B9
1m{h
<b0Vx
^;g?
G}co
-|dc
:jq]j
$x'@
89V*
Feec
YC)`
F`W<
c+,b
l^5R
6VW?4dn
>5|%
^Ews
1Aov
EGUp
=nym
cu>[
@<cy
V7:l
+Yt=GF
jox
6he_
G5!P
i^^q
sM,W
2=iJ
`qGA@
P@aMU
{qJH
;9S
E(R[
?*p
pFF((A
=9#=
3@XD
Y$P~dl
FF@nv
Y\pE|
>-h5_
-'^Rh_
Rv>\
}m7C
a$R*
YZGidm
$y#o-s
t}gQ
Vwr`R
XdFi#]
dXV6
5/*;
$^Ir
qwZ
m+P}-E
cvfIY<
5-dA
'yk~
m4/$
x_Vh%
{{]:
[O#Z
het[
LFP3/
!IUb
G,R
%;u1X
P1H\1
H$bz~t
7dp?
F=@4
Oc@Fd
HX'A
$SG~h
oz`#
$p{z
 ta2
udlp 
f!#$
2_|`,q&
*[c)
9#;Y
~+x2
Jd))
o(t2
Ni<-
"ey1
;kk/
~`t>
8U$C
E!`uUQ
>*y
jV3K
Ox?s
42)B
=G(H>
dF?2
Sc r
=*'&6$|
5AV*
M)RNF
?Js1^
>iwR(
Z@sM2
?Zsnq
?-7i
n*E`
aOp=)
8c529
O6'^
@v@'
{}k>
DY]O
#aIF
[}OD
q,k'
gl)m
Sx'G
[85}I
#yHKn
}Ej]
J$l}
%N0}
NjBF
N:7]
HdD~r
K6E1
 f.Kn 
Xn p
NqJW
?ZZ3
pFM=d
ZwQ@
}E.?:
rZp9
nFG>
#8`A
rLEx8
c";D>}
LYDZ
YcUX
m<Mqa
5Wbb0
ct,P
UT\]
@p'@c
NMl7e
A%;$~
#L%cs
B#wp
rt^\
b6!fU
]OH6
>v)C
=8VD
o]<L[
DJWU
;9q'K
%8Jt b
-#!F#z
)aAf
UrA.
r[kB`
S,}TF
fdp;
S2j
 B(:
k)3E
}1#p
&TA=
(Np7
2"Da
z3SW
R&sE(
4!nF
qe?W
3u<#
B|fQ
nqW=
:EE<
R)5lei
1GFlf
a6?31Z
.3~Uy
qv@*
7i7e
mcSN
OA9K
HBrZ
RgD\
)6B"
o7-9
yp).
n+I,
Jt]$
)<%pD
4kOq
5"):e
{FFI<
d`DV
OQ`
BGhw
Ldx?
X!+"g
qb.7
RTIt
CT~}4
j36M
"GH#
{osg
>ZwX=^_
-g.s
9e0f
1_Pm
f&gq
Q@)i
s.Xx
g6[|N:
-w\5
DZ[M_q
#NUg
Siol
e%UB
S?P<KaxY@
Z8,~Ea-"
71\6
%}?y%
u_*0
]*Xb
3-"
rs#:
?}gQ
.J?R/
PGuD
'xHcM
xmJ 
bES
?%JXA
c`.:
RJhO
O!~H
ym#9q
Bn1y
imXQo|
Gx"4
].qn
q[l'
-i9~
BTI1
Ep9e
M9(=:3
7-.Q
9ZWu
|H4!
L}$*
Eul45B
{2?d
S\3%
P"3'
]52U
aP7C
:HBU
FpN?{
UY7?
|K6t
);"W
boB$
h:2Y
={5Th 
oM?e
lftQ
]y{:
nY<NX
zLX/
@=EJ
]YX#Bk
\^ZO}=
'`/,
?7GH_'
(yh#
>y4f>u3
@LK]
(ldE
^vA]
c%k2
>WL1
^onlV
l(4x
Nx7ox!
fLCq
[)cH
`wae
hhM{
8LC77
+KmrRYf
{V%I
tw%w
:%s/
;{o=
Fr^P
$!<|v
iD8K(
3/iNl7
F2 v<Kb%?>
Cx9%
Ow)2
~XIJ1
p'CW
W=&w
;/CQ
,EAa
.K?S|
UMJH
qAkV
P]Hc
Q5P<
j]s[G
ljjI(
#?&
UGvo(E
BAGA
D8X8D
]@PHX
VN^AQI
7465
/,.mlnm
^\^]
?\H 
?\@$
q?&x
oUBQ{
=i*]
o'}[
K$Df`*
cO$&
2{5Q<
c}29Q
G?we
La1n
ENE:
Loj+
jYTt
l5TRtE
=rqc
,vso
QSTWr4
]IOF
rr,5
nSF<
Zn&PZ
<>Uk
:!7~
STr-_
@Ip[
%^biu]
;!OW'0U
\)rk
x_Go
Z=lO[
$h9yI_
;zFj5
^pH29
>jk|9
<ofd
Pr{?
F)AC
aycx
4O/g
P~]>2
W.%pR
7_Hc
O5J"
uJ5T
W'Q}]ie
/K-_
y,h 
;Fd*
w6hNP
vAgK
udpo
g`g(
=<)\
-|y B
3zZ?T
fsJ/
dr1N;
R4NF9
cfII{
[Kc+
we{4.
i*2KVdz
5P@?
Os$g"
fX*K
[O6C
fQV,2
F~'e
p':e
coFc
 '?9t
g`M
Kk9X
 4qg,;
XN~2
P&b@
KJ01Hp4
"{k7iil
4tCd
"*=i|c
1i<"
:D)m.<
W>c%<$
{wHi
xWW{
FMk<X
`kaV
n8fg
e+1~
nSkM
(8ee
j7=J
IOD"
d1bw
I&W+'
d}v8
&t~H+f
i2ZJ
9<},
wbvi8
`<:N
NajO
Sol^XD
B $q5h
&+Nj
F*&;[
cy(,d
H0_vI
^a{h
@S$6
sKtH
n8FO)
$E6`
Yp]h*
%~d7
EF8K
vpJF
iv6
6Sjr
Gi"%
."^&
b,gF
!oKy
=!s&
6q/|+
~((s
j[=R
bP$^C
<ce#F:
.N9Q!
~l!2l4
S8i/
v+kV
:L19
;*Y{E
ocF]
F{9f
OI"_
j'Zj9
1^Xt
&MHn?
mzxZ
EZ9|
):Mb>R
o.TS
z/5J
83hc
\*M2
7_WV
`(:{
oi%I
rA 1
;X1S
Z$in
s7%:
"r*i
HUF@
IbD,
nUx!X
/B*y
E_VpyA
Qyh:
Q|.h
uJTY
#OWm`E
wWE3c
#9!D6
+dkD
XC86@.<
StX K
G!(R
=`~t$
y72 i
^;(`a
Kaq%
m(Lb
[3v![AB
*oyKG}
MoD+
1}!?-
AXY+
o-E%q
/B4c^
5Oj7A
7 ij
zX1W
sY,9
~~w$
}9bA
@#f0
ygws
+~Pc
=4*G)
dCiz(Q
2{qN
y:{F
`7D2
g]o6r
pqss
.Arh
X&te
bl2s
^z4Uk*
9T_1
+y@\
?FC$
ex]`
DFWo
l"]P
}UG
p~20
jqd.
VBFY
JC[o
"NZH
Mw:[
t+Zh
-4TiV
^>/{
*"[c
0Tth
~=5_m@
:8H4x
d-Z
Nn,`g
DNU_
l!N\
&u1t
dWmP
=2,\$GS
pk_q$
%,Wy
T$AW
YyaY
mA3)
tS*B
?faV
H6FR
JAbR
Zk*~
["6r
0*V#
uAyD
fRM=
]6N&
ovn|
]p`\u
<?`U
B3.L
`L#H0
=0%f/
glWr
5^A`
TXou
@.7>G
TomL
4h1vw
xO e
Ys_P
#Xpo
k_@doi
<}mT(
%qb*&
"+4p
o#CBy
#Fq[
M#e*F
YqyO
M!2+
eX82
FADK
Z_mj/
"`Q8qr
IK~G_
~%hB?;
"prU
Og]1
hGy\M
ws":qJ
@i`*
d'/I 
>q!R2
2.3u
nP8>G*
\cL1
y2$g
Q\u!
=TwY
Y2!zK
L1u L2m
"Eip
x&o2
>P#qc%
;>2ec{HM!
i^@Z
94hQ
2D +
y/*V
Sly[
; GJ
W/-\|
K9 I
Bz#U
vUTB
ME=6
2uSDj
O,?AsZ4
q@Gtw
y%\B
7OPc
AZg,
PWYHDZ
GRB+
2EJ"$@
Qjp;2.W
g1qT8L
;l!n
M@@y
Xlee
2q'q7
},Vw
@cwK\&
in*#
1>9o
[|7(
V5><mQ
wlAt
]x*&
CtS3"
+b|b
-Sq`
ez]iIw;
cI|8
>v[:
HG_Y
jriHB
:4Fi
S!.D
+-# 
u&L$Ua
CL7_
Q H0
>Q0v
he|mM
vAeh
|_WFIJ
[G^6
JYxt={\
KDzYW
(sWh9
H74)
:]*
~8;;
^s7m&
7L$L
?mdu
J$M1IK
|LW,R4
?>}P
fdgC[e4
wK$e
77cm
9p$!
F(Ds
THXa
/a2fp
i#WO
sT:u4
-c>
7MPE
XIQP
sO{!lH
:Okwo=
Tj>/
^&5%
<!oF
-*l;
mm")
BPK;
w2<4
cnT8
mW+<
'ESh
D"G6!4- D
C9cu
;FY 
;XZJS
9|u]J
`=s"C
rl"M
0LK4
'C-X
=n?
F6et-e
yTV4
V -_
!pb)
5FO8
?G"}
4X}N
mX^>G
/y"}
K~uo
uyN"
#UMc
\\q8
/h1{dF
whMY
6Hc8
/=l[
h0,N
gn>0h
Gg)1_C
A[bl
YkM~
QWlG
G\%?
i/sG
@u[E
+*!!)
r50hX
yf{I
sky/stars.binPK
images/border_full.pngPK
images/arrow.pngPK
images/eow_pattern_b.pngPK
poles/northpole/0/0/map_0_0_0.c3hPK
poles/northpole/0/0/map_0_0_0.c3bPK
3jjZ
poles/southpole/0/0/map_0_0_0.c3hPK
poles/southpole/0/0/map_0_0_0.c3bPK
ff&@
 OA@
 O1@
 O1@
xJ0@
XBKBKBKBKBKBKBKBKI2I2I2I2I2I2I2I2
?ffffff
G!?\
L=33s?
333?
>333?
-5!2
nwQB
#WQfT"
Q?D5
so]J
_Dud
4)tdW
Ymv1
//AnimatableTexture::animatableTexture_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct Transform {
  highp mat4 modelViewProjectionMatrix;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform Transform view;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//AnimatableTexture::animatableTexture_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Variant {
  highp float textureWeight;
in highp vec2 v_texcoord;
uniform Variant variant;
uniform sampler2D textureMap;
uniform sampler2D variantTextureMap;
out lowp vec4 output_value;
void main ()
  highp vec4 tmpvar_1;
  tmpvar_1 = vec4((1.0 - variant.textureWeight));
  highp vec4 tmpvar_2;
  tmpvar_2 = vec4(variant.textureWeight);
  output_value = ((tmpvar_1 * texture (textureMap, v_texcoord)) + (tmpvar_2 * texture (variantTextureMap, v_texcoord)));
//AnimatedTexturedGroundCover::animatedTexturedGroundCover_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 vertex_pos;
  highp vec2 texture;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct VertexOut {
  highp vec2 texture;
in highp vec2 vertex_attributes_vertex_pos;
in highp vec2 vertex_attributes_texture;
uniform View view;
out highp vec2 v_texture;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.vertex_pos = vertex_attributes_vertex_pos;
  vertex_attributes_2.texture = vertex_attributes_texture;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertex_attributes_2.vertex_pos;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  outputValue_1.texture = vertex_attributes_2.texture;
  v_texture = outputValue_1.texture;
//AnimatedTexturedGroundCover::animatedTexturedGroundCover_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Variation {
  highp float textureVariation;
in highp vec2 v_texture;
uniform Variation variation;
uniform sampler2D landSamplerA;
uniform sampler2D landSamplerB;
out lowp vec4 output_value;
void main ()
  mediump vec3 landRGB_1;
  mediump vec4 landVariant_2;
  mediump vec4 land_3;
  lowp vec4 tmpvar_4;
  tmpvar_4 = texture (landSamplerA, v_texture);
  land_3 = tmpvar_4;
  lowp vec4 tmpvar_5;
  tmpvar_5 = texture (landSamplerB, v_texture);
  landVariant_2 = tmpvar_5;
  highp vec3 tmpvar_6;
  tmpvar_6 = ((vec3((1.0 - variation.textureVariation)) * land_3.xyz) + (vec3(variation.textureVariation) * landVariant_2.xyz));
  landRGB_1 = tmpvar_6;
  mediump vec4 tmpvar_7;
  tmpvar_7.w = 1.0;
  tmpvar_7.xyz = landRGB_1;
  output_value = tmpvar_7;
//BuildingFacadeDepth::buildingFacadeDepth_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndTexture;
  highp vec4 normalAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
in highp vec4 vertex_input_vertexAndTexture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform View view;
uniform Scale scale;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.vertexAndTexture = vertex_input_vertexAndTexture;
  vertex_input_1.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  highp vec3 tmpvar_2;
  tmpvar_2 = (scale.tileOrigin + (scale.tileSize * vertex_input_1.vertexAndTexture.xyz));
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xy = tmpvar_2.xy;
  tmpvar_3.z = (tmpvar_2.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
//BuildingFacadeDepth::buildingFacadeDepth_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
out lowp vec4 output_value;
void main ()
  output_value = vec4(0.0, 0.0, 0.0, 0.0);
//BuildingFlat::buildingFlat_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Building {
  highp vec4 color[8];
  highp vec3 origin;
  highp vec3 size;
struct VertexOut {
  lowp vec4 color;
in highp vec4 vertex_input_vertexAndStyleIndex;
uniform View view;
uniform Building building;
out lowp vec4 v_color;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  highp int tmpvar_3;
  tmpvar_3 = int((vertex_input_2.vertexAndStyleIndex.w * 256.0));
  highp vec3 tmpvar_4;
  tmpvar_4 = (building.origin + (building.size * vertex_input_2.vertexAndStyleIndex.xyz));
  highp vec4 tmpvar_5;
  tmpvar_5.zw = vec2(0.0, 1.0);
  tmpvar_5.xy = tmpvar_4.xy;
  outputValue_1.color = building.color[tmpvar_3];
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  gl_Position.z = ((1.0 - (2.0 * tmpvar_4.z)) * gl_Position.w);
  v_color = outputValue_1.color;
//BuildingFlat::buildingFlat_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in lowp vec4 v_color;
out lowp vec4 output_value;
void main ()
  output_value = v_color;
//BuildingFlatStroke::buildingFlatStroke_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
  highp vec4 offsetAndTexture;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Building {
  highp vec4 polygonColor[8];
  highp vec4 strokeColor[8];
  highp float lineWidth[8];
  highp float offsetScale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct VertexOut {
  lowp vec4 strokeColor;
  lowp vec4 polygonColor;
  highp float strokeTexture;
in highp vec4 vertex_input_vertexAndStyleIndex;
in highp vec4 vertex_input_offsetAndTexture;
uniform View view;
uniform Building building;
out lowp vec4 v_strokeColor;
out lowp vec4 v_polygonColor;
out highp float v_strokeTexture;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  vertex_input_2.offsetAndTexture = vertex_input_offsetAndTexture;
  highp int tmpvar_3;
  tmpvar_3 = int((65535.0 * vertex_input_2.vertexAndStyleIndex.w));
  outputValue_1.strokeColor = building.strokeColor[tmpvar_3];
  outputValue_1.polygonColor = building.polygonColor[tmpvar_3];
  outputValue_1.strokeTexture = vertex_input_2.offsetAndTexture.z;
  highp vec3 tmpvar_4;
  tmpvar_4 = (building.tileOrigin + (vertex_input_2.vertexAndStyleIndex.xyz * building.tileSize));
  highp vec4 tmpvar_5;
  tmpvar_5.zw = vec2(0.0, 1.0);
  tmpvar_5.xy = (tmpvar_4.xy + ((vertex_input_2.offsetAndTexture.xy * vec2(building.offsetScale)) * vec2(building.lineWidth[tmpvar_3])));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  gl_Position.z = ((1.0 - (2.0 * tmpvar_4.z)) * gl_Position.w);
  v_strokeColor = outputValue_1.strokeColor;
  v_polygonColor = outputValue_1.polygonColor;
  v_strokeTexture = outputValue_1.strokeTexture;
//BuildingFlatStroke::buildingFlatStroke_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in lowp vec4 v_strokeColor;
in lowp vec4 v_polygonColor;
in highp float v_strokeTexture;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  lowp float polygonTextureCoord_1;
  highp vec2 tmpvar_2;
  tmpvar_2.y = 0.0;
  tmpvar_2.x = v_strokeTexture;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (alphaTexture, tmpvar_2);
  highp float tmpvar_4;
  tmpvar_4 = clamp (v_strokeTexture, 0.0, 1.0);
  polygonTextureCoord_1 = tmpvar_4;
  lowp vec4 tmpvar_5;
  tmpvar_5.xyz = mix (v_strokeColor.xyz, v_polygonColor.xyz, vec3(polygonTextureCoord_1));
  tmpvar_5.w = ((tmpvar_3.x + (polygonTextureCoord_1 * 
    (1.0 - tmpvar_3.x)
  )) * v_strokeColor.w);
  output_value = tmpvar_5;
//BuildingPointyRoofDepth::buildingPointyRoofDepth_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
  highp vec4 normalAndIsFacade;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
in highp vec4 vertex_input_vertexAndStyleIndex;
in highp vec4 vertex_input_normalAndIsFacade;
uniform View view;
uniform Scale scale;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  vertex_input_1.normalAndIsFacade = vertex_input_normalAndIsFacade;
  highp vec3 tmpvar_2;
  tmpvar_2 = (scale.tileOrigin + (scale.tileSize * vertex_input_1.vertexAndStyleIndex.xyz));
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xy = tmpvar_2.xy;
  tmpvar_3.z = (tmpvar_2.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
//BuildingPointyRoofDepth::buildingPointyRoofDepth_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
out lowp vec4 output_value;
void main ()
  output_value = vec4(0.0, 0.0, 0.0, 0.0);
//BuildingShadow::buildingShadow_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct VertexOut {
  highp vec2 texture;
in highp vec2 vertex_input_position;
in highp vec2 vertex_input_texcoord;
uniform View view;
out highp vec2 v_texture;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.position = vertex_input_position;
  vertex_input_2.texcoord = vertex_input_texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.x = vertex_input_2.position.x;
  tmpvar_3.y = vertex_input_2.position.y;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  outputValue_1.texture = vertex_input_2.texcoord;
  v_texture = outputValue_1.texture;
//BuildingShadow::buildingShadow_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shadow {
  highp float brightness;
  highp vec4 color;
in highp vec2 v_texture;
uniform Shadow shadow;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  output_value = (shadow.color * texture (textureSampler, v_texture).xxxx);
//BuildingTopDepth::buildingTopDepth_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
in highp vec4 vertex_input_vertexAndStyleIndex;
uniform View view;
uniform Scale scale;
void main ()
  highp vec3 v_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  highp vec3 tmpvar_3;
  tmpvar_3 = (scale.tileOrigin + (scale.tileSize * vertex_input_2.vertexAndStyleIndex.xyz));
  v_1.xy = tmpvar_3.xy;
  v_1.z = (tmpvar_3.z * scale.scale);
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = v_1;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
//BuildingTopDepth::buildingTopDepth_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
out lowp vec4 output_value;
void main ()
  output_value = vec4(0.0, 0.0, 0.0, 0.0);
//Circle::circle_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct Style {
  highp vec4 color;
  highp vec4 strokeColor;
  highp float halfAntialiasWidth;
  highp float halfStrokeWidth;
  highp float alpha;
struct View {
  highp mat4 modelViewProjection;
struct VertexOut {
  highp vec2 normalizedPosition;
in highp vec2 vertexInput_position;
uniform Style style;
uniform View view;
out highp vec2 v_normalizedPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.position - vec2(0.5, 0.5)) * vec2((2.0 + style.halfStrokeWidth)));
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = (tmpvar_3 + vec2(0.5, 0.5));
  gl_Position = (view.modelViewProjection * tmpvar_4);
  outputValue_1.normalizedPosition = tmpvar_3;
  v_normalizedPosition = outputValue_1.normalizedPosition;
//Circle::circle_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec4 strokeColor;
  highp float halfAntialiasWidth;
  highp float halfStrokeWidth;
  highp float alpha;
in highp vec2 v_normalizedPosition;
uniform Style style;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 strokeColor_2;
  lowp vec4 fillColor_3;
  highp float tmpvar_4;
  tmpvar_4 = sqrt(dot (v_normalizedPosition, v_normalizedPosition));
  highp vec4 tmpvar_5;
  tmpvar_5 = style.color;
  fillColor_3 = tmpvar_5;
  highp float tmpvar_6;
  highp float edge0_7;
  edge0_7 = (0.5 - style.halfAntialiasWidth);
  highp float tmpvar_8;
  tmpvar_8 = clamp (((tmpvar_4 - edge0_7) / (
    (0.5 + style.halfAntialiasWidth)
   - edge0_7)), 0.0, 1.0);
  tmpvar_6 = (tmpvar_8 * (tmpvar_8 * (3.0 - 
    (2.0 * tmpvar_8)
  )));
  fillColor_3.w = (fillColor_3.w * (1.0 - tmpvar_6));
  highp vec4 tmpvar_9;
  tmpvar_9 = style.strokeColor;
  strokeColor_2 = tmpvar_9;
  highp float tmpvar_10;
  highp float edge0_11;
  edge0_11 = (style.halfStrokeWidth - style.halfAntialiasWidth);
  highp float tmpvar_12;
  tmpvar_12 = clamp (((
    abs((0.5 - tmpvar_4))
   - edge0_11) / (
    (style.halfStrokeWidth + style.halfAntialiasWidth)
   - edge0_11)), 0.0, 1.0);
  tmpvar_10 = (tmpvar_12 * (tmpvar_12 * (3.0 - 
    (2.0 * tmpvar_12)
  )));
  strokeColor_2.w = (strokeColor_2.w * (1.0 - tmpvar_10));
  o_color_1.w = (((1.0 - strokeColor_2.w) * fillColor_3.w) + strokeColor_2.w);
  if ((o_color_1.w > 0.0)) {
    o_color_1.xyz = (((vec3(
      ((1.0 - strokeColor_2.w) * fillColor_3.w)
    ) * fillColor_3.xyz) + (strokeColor_2.www * strokeColor_2.xyz)) / o_color_1.www);
  } else {
    o_color_1.xyz = vec3(0.0, 0.0, 0.0);
  };
  o_color_1.w = (o_color_1.w * style.alpha);
  output_value = o_color_1;
//Clut::clut_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform View view;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//Clut::clut_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Variation {
  highp float variation;
in highp vec2 v_texcoord;
uniform Variation variation;
uniform sampler2D textureMap;
uniform sampler2D clutMap;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 clutColor_2;
  mediump vec2 tB_3;
  mediump vec2 t_4;
  mediump vec4 color_5;
  lowp vec4 tmpvar_6;
  tmpvar_6 = texture (textureMap, v_texcoord);
  color_5 = tmpvar_6;
  mediump vec2 tmpvar_7;
  tmpvar_7 = ((color_5.xy * vec2(0.9375, 0.9375)) + vec2(0.03125, 0.03125));
  t_4.y = tmpvar_7.y;
  t_4.x = (tmpvar_7.x * 0.0625);
  mediump float tmpvar_8;
  tmpvar_8 = floor(color_5.z);
  mediump vec2 tmpvar_9;
  tmpvar_9.x = tmpvar_8;
  tmpvar_9.y = (tmpvar_8 + 1.0);
  tB_3 = (tmpvar_9 * vec2(0.9375, 0.9375));
  mediump vec2 tmpvar_10;
  tmpvar_10 = (t_4.xx + tB_3);
  mediump vec4 tmpvar_11;
  tmpvar_11.x = tmpvar_10.x;
  tmpvar_11.y = t_4.y;
  tmpvar_11.z = tmpvar_10.y;
  tmpvar_11.w = t_4.y;
  lowp vec4 tmpvar_12;
  tmpvar_12 = texture (clutMap, tmpvar_11.xy);
  lowp vec4 tmpvar_13;
  tmpvar_13 = texture (clutMap, tmpvar_11.zw);
  mediump vec4 tmpvar_14;
  tmpvar_14 = mix (tmpvar_12, tmpvar_13, vec4(((color_5.z * 0.9375) - tB_3.x)));
  clutColor_2 = tmpvar_14;
  highp vec4 tmpvar_15;
  tmpvar_15 = mix (color_5, clutColor_2, vec4(variation.variation));
  o_color_1 = tmpvar_15;
  output_value = o_color_1;
//ColorGlyphWithNormalHalo::colorGlyphWithNormalHalo_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out lowp vec4 v_color;
out lowp vec4 v_haloColor;
out highp float v_alpha;
out highp float v_haloSizeInPixels;
out highp vec2 v_tangent;
out highp vec2 v_bitangent;
out mediump vec4 v_dropShadowParams;
out mediump vec4 v_dropShadowColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.texture = vertex_attributes_texture;
  vertex_attributes_1.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_1.color = vertex_attributes_color;
  vertex_attributes_1.haloColor = vertex_attributes_haloColor;
  vertex_attributes_1.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_1.tangent = vertex_attributes_tangent;
  vertex_attributes_1.bitangent = vertex_attributes_bitangent;
  VertexOut outputValue_2;
  highp float alpha_3;
  alpha_3 = ((vertex_attributes_1.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = vertex_attributes_1.position.x;
  tmpvar_4.y = vertex_attributes_1.position.y;
  gl_Position = tmpvar_4;
  outputValue_2.texture = vertex_attributes_1.texture;
  highp vec4 tmpvar_5;
  tmpvar_5.x = vertex_attributes_1.color.x;
  tmpvar_5.y = vertex_attributes_1.color.y;
  tmpvar_5.z = vertex_attributes_1.color.z;
  tmpvar_5.w = (vertex_attributes_1.color.w * alpha_3);
  outputValue_2.color = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.x = vertex_attributes_1.haloColor.x;
  tmpvar_6.y = vertex_attributes_1.haloColor.y;
  tmpvar_6.z = vertex_attributes_1.haloColor.z;
  tmpvar_6.w = (vertex_attributes_1.haloColor.w * alpha_3);
  outputValue_2.haloColor = tmpvar_6;
  outputValue_2.tangent = vertex_attributes_1.tangent;
  outputValue_2.bitangent = vertex_attributes_1.bitangent;
  outputValue_2.haloSizeInPixels = ((vertex_attributes_1.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_7;
    tmpvar_7 = int((65535.0 * vertex_attributes_1.deviceBufferIndex.x));
    highp mat4 matrixOut_8;
    highp vec2 tmpvar_9;
    tmpvar_9.x = float(floatBufferTextureSize.width);
    tmpvar_9.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_10;
    tmpvar_10 = (1.0/(tmpvar_9));
    highp int textureWidth_11;
    textureWidth_11 = floatBufferTextureSize.width;
    highp int tmpvar_12;
    tmpvar_12 = (tmpvar_7 / textureWidth_11);
    highp float tmpvar_13;
    tmpvar_13 = ((float(
      (tmpvar_7 - (tmpvar_12 * textureWidth_11))
    ) + 0.5) / float(textureWidth_11));
    highp vec2 tmpvar_14;
    tmpvar_14.x = tmpvar_13;
    tmpvar_14.y = ((float(tmpvar_12) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, tmpvar_14);
    matrixOut_8[0] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_14.y;
    uvCoordinate_16.x = (tmpvar_13 + tmpvar_10.x);
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_10.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_8[1] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_14.y;
    uvCoordinate_19.x = (tmpvar_13 + (tmpvar_10.x * 2.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_10.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_8[2] = tmpvar_21;
    highp vec2 uvCoordinate_22;
    uvCoordinate_22.y = tmpvar_14.y;
    uvCoordinate_22.x = (tmpvar_13 + (tmpvar_10.x * 3.0));
    highp vec2 tmpvar_23;
    tmpvar_23.x = -1.0;
    tmpvar_23.y = tmpvar_10.y;
    uvCoordinate_22 = (uvCoordinate_22 + (vec2(float(
      (uvCoordinate_22.x >= 1.0)
    )) * tmpvar_23));
    lowp vec4 tmpvar_24;
    tmpvar_24 = texture (floatBufferTexture, uvCoordinate_22);
    matrixOut_8[3] = tmpvar_24;
    gl_Position = (matrixOut_8 * tmpvar_4);
  } else {
    gl_Position = (view.screenProjectionMatrix * gl_Position);
  };
  v_texture = outputValue_2.texture;
  v_color = outputValue_2.color;
  v_haloColor = outputValue_2.haloColor;
  v_alpha = outputValue_2.alpha;
  v_haloSizeInPixels = outputValue_2.haloSizeInPixels;
  v_tangent = outputValue_2.tangent;
  v_bitangent = outputValue_2.bitangent;
  v_dropShadowParams = outputValue_2.dropShadowParams;
  v_dropShadowColor = outputValue_2.dropShadowColor;
//ColorGlyphWithNormalHalo::colorGlyphWithNormalHalo_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in lowp vec4 v_color;
in lowp vec4 v_haloColor;
in highp float v_alpha;
in highp float v_haloSizeInPixels;
in highp vec2 v_tangent;
in highp vec2 v_bitangent;
in mediump vec4 v_dropShadowParams;
in mediump vec4 v_dropShadowColor;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
out lowp vec4 output_value;
void main ()
  mediump vec4 mask_1;
  lowp vec4 out_color_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureAtlas, v_texture);
  mask_1 = tmpvar_3;
  if (bool(glyphOptions.isHalo)) {
    out_color_2 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    out_color_2 = mask_1;
  };
  output_value = out_color_2;
//ColorGlyphWithOuterHalo::colorGlyphWithOuterHalo_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out lowp vec4 v_color;
out lowp vec4 v_haloColor;
out highp float v_alpha;
out highp float v_haloSizeInPixels;
out highp vec2 v_tangent;
out highp vec2 v_bitangent;
out mediump vec4 v_dropShadowParams;
out mediump vec4 v_dropShadowColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.texture = vertex_attributes_texture;
  vertex_attributes_1.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_1.color = vertex_attributes_color;
  vertex_attributes_1.haloColor = vertex_attributes_haloColor;
  vertex_attributes_1.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_1.tangent = vertex_attributes_tangent;
  vertex_attributes_1.bitangent = vertex_attributes_bitangent;
  VertexOut outputValue_2;
  highp float alpha_3;
  alpha_3 = ((vertex_attributes_1.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = vertex_attributes_1.position.x;
  tmpvar_4.y = vertex_attributes_1.position.y;
  gl_Position = tmpvar_4;
  outputValue_2.texture = vertex_attributes_1.texture;
  highp vec4 tmpvar_5;
  tmpvar_5.x = vertex_attributes_1.color.x;
  tmpvar_5.y = vertex_attributes_1.color.y;
  tmpvar_5.z = vertex_attributes_1.color.z;
  tmpvar_5.w = (vertex_attributes_1.color.w * alpha_3);
  outputValue_2.color = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.x = vertex_attributes_1.haloColor.x;
  tmpvar_6.y = vertex_attributes_1.haloColor.y;
  tmpvar_6.z = vertex_attributes_1.haloColor.z;
  tmpvar_6.w = (vertex_attributes_1.haloColor.w * alpha_3);
  outputValue_2.haloColor = tmpvar_6;
  outputValue_2.tangent = vertex_attributes_1.tangent;
  outputValue_2.bitangent = vertex_attributes_1.bitangent;
  outputValue_2.haloSizeInPixels = ((vertex_attributes_1.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_7;
    tmpvar_7 = int((65535.0 * vertex_attributes_1.deviceBufferIndex.x));
    highp mat4 matrixOut_8;
    highp vec2 tmpvar_9;
    tmpvar_9.x = float(floatBufferTextureSize.width);
    tmpvar_9.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_10;
    tmpvar_10 = (1.0/(tmpvar_9));
    highp int textureWidth_11;
    textureWidth_11 = floatBufferTextureSize.width;
    highp int tmpvar_12;
    tmpvar_12 = (tmpvar_7 / textureWidth_11);
    highp float tmpvar_13;
    tmpvar_13 = ((float(
      (tmpvar_7 - (tmpvar_12 * textureWidth_11))
    ) + 0.5) / float(textureWidth_11));
    highp vec2 tmpvar_14;
    tmpvar_14.x = tmpvar_13;
    tmpvar_14.y = ((float(tmpvar_12) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, tmpvar_14);
    matrixOut_8[0] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_14.y;
    uvCoordinate_16.x = (tmpvar_13 + tmpvar_10.x);
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_10.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_8[1] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_14.y;
    uvCoordinate_19.x = (tmpvar_13 + (tmpvar_10.x * 2.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_10.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_8[2] = tmpvar_21;
    highp vec2 uvCoordinate_22;
    uvCoordinate_22.y = tmpvar_14.y;
    uvCoordinate_22.x = (tmpvar_13 + (tmpvar_10.x * 3.0));
    highp vec2 tmpvar_23;
    tmpvar_23.x = -1.0;
    tmpvar_23.y = tmpvar_10.y;
    uvCoordinate_22 = (uvCoordinate_22 + (vec2(float(
      (uvCoordinate_22.x >= 1.0)
    )) * tmpvar_23));
    lowp vec4 tmpvar_24;
    tmpvar_24 = texture (floatBufferTexture, uvCoordinate_22);
    matrixOut_8[3] = tmpvar_24;
    gl_Position = (matrixOut_8 * tmpvar_4);
  } else {
    gl_Position = (view.screenProjectionMatrix * gl_Position);
  };
  v_texture = outputValue_2.texture;
  v_color = outputValue_2.color;
  v_haloColor = outputValue_2.haloColor;
  v_alpha = outputValue_2.alpha;
  v_haloSizeInPixels = outputValue_2.haloSizeInPixels;
  v_tangent = outputValue_2.tangent;
  v_bitangent = outputValue_2.bitangent;
  v_dropShadowParams = outputValue_2.dropShadowParams;
  v_dropShadowColor = outputValue_2.dropShadowColor;
//ColorGlyphWithOuterHalo::colorGlyphWithOuterHalo_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in lowp vec4 v_color;
in lowp vec4 v_haloColor;
in highp float v_alpha;
in highp float v_haloSizeInPixels;
in highp vec2 v_tangent;
in highp vec2 v_bitangent;
in mediump vec4 v_dropShadowParams;
in mediump vec4 v_dropShadowColor;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
inout lowp vec4 output_value;
void main ()
  mediump vec4 mask_1;
  lowp vec4 out_color_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureAtlas, v_texture);
  mask_1 = tmpvar_3;
  if (bool(glyphOptions.isHalo)) {
    out_color_2 = vec4(0.0, 0.0, 0.0, 0.0);
  } else {
    out_color_2 = mask_1;
  };
  output_value = out_color_2;
//Debug::debug_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
struct View {
  highp mat4 modelViewProjection;
struct VertexOut {
  highp vec4 color;
in highp vec3 vertexInput_position;
uniform View view;
out highp vec4 v_color;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xyz = vertexInput_2.position;
  gl_Position = (view.modelViewProjection * tmpvar_3);
  outputValue_1.color = vec4(1.0, 1.0, 1.0, 1.0);
  v_color = outputValue_1.color;
//Debug::debug_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
in highp vec4 v_color;
uniform Style style;
out lowp vec4 output_value;
void main ()
  output_value = (style.color * v_color);
//Debug::debug_extended_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexInExtended {
  highp vec3 position;
  highp vec4 color;
struct View {
  highp mat4 modelViewProjection;
struct VertexOut {
  highp vec4 color;
in highp vec3 vertexInput_position;
in highp vec4 vertexInput_color;
uniform View view;
out highp vec4 v_color;
void main ()
  VertexOut outputValue_1;
  VertexInExtended vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.color = vertexInput_color;
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xyz = vertexInput_2.position;
  gl_Position = (view.modelViewProjection * tmpvar_3);
  outputValue_1.color = vertexInput_2.color;
  v_color = outputValue_1.color;
//Debug::debug_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
in highp vec4 v_color;
uniform Style style;
out lowp vec4 output_value;
void main ()
  output_value = (style.color * v_color);
//DiffuseBuilding::diffuseBuilding_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndTexture;
  highp vec4 normalAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndTexture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.vertexAndTexture = vertex_input_vertexAndTexture;
  vertex_input_1.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_2;
  highp int tmpvar_3;
  tmpvar_3 = int(((vertex_input_1.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_2.normal = vertex_input_1.normalAndStyleIndex.xyz;
  outputValue_2.unlitColor = style.color[tmpvar_3];
  outputValue_2.shininess = style.shininessAndSpecularity[tmpvar_3].x;
  outputValue_2.specularity = style.shininessAndSpecularity[tmpvar_3].y;
  outputValue_2.position = (scale.tileOrigin + (scale.tileSize * vertex_input_1.vertexAndTexture.xyz));
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xy = outputValue_2.position.xy;
  tmpvar_4.z = (outputValue_2.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  outputValue_2.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_5;
  normal_5 = outputValue_2.normal;
  lowp vec3 lightContributions_6;
  highp vec3 tmpvar_7;
  tmpvar_7 = lightConfig.ambientLightColor.xyz;
  lightContributions_6 = tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_8) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_9) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_10) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = (outputValue_2.unlitColor.xyz * lightContributions_6);
  tmpvar_11.w = outputValue_2.unlitColor.w;
  outputValue_2.diffuseColor = tmpvar_11;
  highp float tmpvar_12;
  highp vec2 gradient_13;
  gradient_13 = gradient.equation[tmpvar_3];
  tmpvar_12 = ((gradient_13.x * outputValue_2.position.z) + gradient_13.y);
  outputValue_2.gradient = tmpvar_12;
  highp float tmpvar_14;
  tmpvar_14 = floor((vertex_input_1.vertexAndTexture.w * 256.0));
  highp vec2 tmpvar_15;
  tmpvar_15.x = tmpvar_14;
  tmpvar_15.y = floor(((
    (vertex_input_1.vertexAndTexture.w * 256.0)
   - tmpvar_14) * 256.0));
  outputValue_2.texture = floor((tmpvar_15 * vec2(style.textureCoordScale[tmpvar_3])));
  v_fogCoordinate = outputValue_2.fogCoordinate;
  v_fogColor = outputValue_2.fogColor;
  v_unlitColor = outputValue_2.unlitColor;
  v_diffuseColor = outputValue_2.diffuseColor;
  v_normal = outputValue_2.normal;
  v_position = outputValue_2.position;
  v_texture = outputValue_2.texture;
  v_gradient = outputValue_2.gradient;
  v_shininess = outputValue_2.shininess;
  v_specularity = outputValue_2.specularity;
  v_clipPosition = outputValue_2.clipPosition;
//DiffuseBuilding::diffuseBuilding_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
in highp vec3 v_clipPosition;
uniform Scale scale;
uniform Style style;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  lowp float styleBrightness_1;
  styleBrightness_1 = style.brightness;
  lowp float scale_2;
  scale_2 = scale.scale;
  highp vec2 tmpvar_3;
  tmpvar_3 = fade.fadeEquation;
  lowp vec4 texturedColor_4;
  lowp vec4 textureColor_5;
  lowp vec4 tmpvar_6;
  tmpvar_6 = texture (textureSampler, v_texture);
  mediump vec4 tmpvar_7;
  tmpvar_7 = tmpvar_6;
  textureColor_5 = tmpvar_7;
  lowp vec4 tmpvar_8;
  tmpvar_8.xyz = (v_diffuseColor.xyz * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_1), scale_2)));
  tmpvar_8.w = v_diffuseColor.w;
  lowp vec4 tmpvar_9;
  tmpvar_9 = (mix (v_unlitColor, tmpvar_8, vec4(scale_2)) * textureColor_5);
  texturedColor_4.xyz = tmpvar_9.xyz;
  lowp float tmpvar_10;
  highp float tmpvar_11;
  tmpvar_11 = clamp (((v_clipPosition.y * tmpvar_3.x) + tmpvar_3.y), fade.alphaFactor, 1.0);
  tmpvar_10 = tmpvar_11;
  texturedColor_4.w = (tmpvar_9.w * tmpvar_10);
  output_value = texturedColor_4;
//DiffuseBuildingPointyRoof::diffuseBuildingPointyRoof_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
  highp vec4 normalAndIsFacade;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndStyleIndex;
in highp vec4 vertex_input_normalAndIsFacade;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  vertex_input_2.normalAndIsFacade = vertex_input_normalAndIsFacade;
  VertexOut outputValue_3;
  lowp float isFacade_4;
  highp int tmpvar_5;
  tmpvar_5 = int((65535.0 * vertex_input_2.vertexAndStyleIndex.w));
  highp float tmpvar_6;
  tmpvar_6 = vertex_input_2.normalAndIsFacade.w;
  isFacade_4 = tmpvar_6;
  outputValue_3.normal = vertex_input_2.normalAndIsFacade.xyz;
  highp vec4 tmpvar_7;
  tmpvar_7 = mix (style.alternateColor[tmpvar_5], style.color[tmpvar_5], vec4(isFacade_4));
  outputValue_3.unlitColor = tmpvar_7;
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_5].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_5].y;
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.vertexAndStyleIndex.xyz));
  highp vec4 tmpvar_8;
  tmpvar_8.w = 1.0;
  tmpvar_8.xy = outputValue_3.position.xy;
  tmpvar_8.z = (outputValue_3.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_8);
  highp vec3 normal_9;
  normal_9 = outputValue_3.normal;
  lowp vec3 lightContributions_10;
  highp vec3 tmpvar_11;
  tmpvar_11 = lightConfig.ambientLightColor.xyz;
  lightContributions_10 = tmpvar_11;
  highp float tmpvar_12;
  tmpvar_12 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_9), 0.0, 1.0);
  lightContributions_10 = (lightContributions_10 + (vec3(tmpvar_12) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_13;
  tmpvar_13 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_9), 0.0, 1.0);
  lightContributions_10 = (lightContributions_10 + (vec3(tmpvar_13) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_14;
  tmpvar_14 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_9), 0.0, 1.0);
  lightContributions_10 = (lightContributions_10 + (vec3(tmpvar_14) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_15;
  tmpvar_15.xyz = (outputValue_3.unlitColor.xyz * lightContributions_10);
  tmpvar_15.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_15;
  highp float tmpvar_16;
  highp vec2 gradient_17;
  gradient_17 = gradient.equation[tmpvar_5];
  tmpvar_16 = ((gradient_17.x * outputValue_3.position.z) + gradient_17.y);
  outputValue_3.gradient = tmpvar_16;
  outputValue_3.texture = vec2(0.0, 0.0);
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_18;
  tmpvar_18.w = 1.0;
  tmpvar_18.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (style.fogFactor * (dot (skyfog.fogSlope, tmpvar_18) + skyfog.fogOffset));
  lowp vec4 tmpvar_19;
  highp vec4 tmpvar_20;
  tmpvar_20 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_19 = tmpvar_20;
  outputValue_1.fogColor = tmpvar_19;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//DiffuseBuildingPointyRoof::diffuseBuildingPointyRoof_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform Fade fade;
out lowp vec4 output_value;
void main ()
  lowp float styleBrightness_1;
  styleBrightness_1 = style.brightness;
  lowp float scale_2;
  scale_2 = scale.scale;
  highp vec2 tmpvar_3;
  tmpvar_3 = fade.fadeEquation;
  lowp vec4 combinedColor_4;
  lowp vec4 tmpvar_5;
  tmpvar_5.xyz = (v_diffuseColor.xyz * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_1), scale_2)));
  tmpvar_5.w = v_diffuseColor.w;
  lowp vec4 tmpvar_6;
  tmpvar_6 = mix (v_unlitColor, tmpvar_5, vec4(scale_2));
  combinedColor_4.xyz = tmpvar_6.xyz;
  lowp float tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (((v_clipPosition.y * tmpvar_3.x) + tmpvar_3.y), fade.alphaFactor, 1.0);
  tmpvar_7 = tmpvar_8;
  combinedColor_4.w = (tmpvar_6.w * tmpvar_7);
  lowp vec4 color_9;
  highp vec4 tmpvar_10;
  tmpvar_10 = mix (combinedColor_4, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_9 = tmpvar_10;
  output_value = color_9;
//DiffuseBuildingTop::diffuseBuildingTop_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndStyleIndex;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  VertexOut outputValue_2;
  highp int tmpvar_3;
  tmpvar_3 = int((vertex_input_1.vertexAndStyleIndex.w * 256.0));
  outputValue_2.unlitColor = style.color[tmpvar_3];
  outputValue_2.shininess = style.shininessAndSpecularity[tmpvar_3].x;
  outputValue_2.specularity = style.shininessAndSpecularity[tmpvar_3].y;
  outputValue_2.normal = vec3(0.0, 0.0, 1.0);
  outputValue_2.position = (scale.tileOrigin + (scale.tileSize * vertex_input_1.vertexAndStyleIndex.xyz));
  outputValue_2.position.z = (outputValue_2.position.z * scale.scale);
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = outputValue_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  outputValue_2.clipPosition = (gl_Position.xyz / gl_Position.www);
  lowp vec3 lightContributions_5;
  highp vec3 tmpvar_6;
  tmpvar_6 = lightConfig.ambientLightColor.xyz;
  lightContributions_5 = tmpvar_6;
  highp float tmpvar_7;
  tmpvar_7 = clamp (lightConfig.lightDirection[0].z, 0.0, 1.0);
  lightContributions_5 = (lightContributions_5 + (vec3(tmpvar_7) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_8;
  tmpvar_8 = clamp (lightConfig.lightDirection[1].z, 0.0, 1.0);
  lightContributions_5 = (lightContributions_5 + (vec3(tmpvar_8) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (lightConfig.lightDirection[2].z, 0.0, 1.0);
  lightContributions_5 = (lightContributions_5 + (vec3(tmpvar_9) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_10;
  tmpvar_10.xyz = (outputValue_2.unlitColor.xyz * lightContributions_5);
  tmpvar_10.w = outputValue_2.unlitColor.w;
  outputValue_2.diffuseColor = tmpvar_10;
  if ((outputValue_2.position.z < 1e-08)) {
    highp float tmpvar_11;
    tmpvar_11 = mix (0.935, 1.0, scale.scale);
    outputValue_2.gradient = tmpvar_11;
  } else {
    highp float tmpvar_12;
    highp vec2 gradient_13;
    gradient_13 = gradient.equation[tmpvar_3];
    tmpvar_12 = ((gradient_13.x * outputValue_2.position.z) + gradient_13.y);
    outputValue_2.gradient = tmpvar_12;
  };
  outputValue_2.texture = vertex_input_1.vertexAndStyleIndex.xy;
  v_fogCoordinate = outputValue_2.fogCoordinate;
  v_fogColor = outputValue_2.fogColor;
  v_unlitColor = outputValue_2.unlitColor;
  v_diffuseColor = outputValue_2.diffuseColor;
  v_normal = outputValue_2.normal;
  v_position = outputValue_2.position;
  v_texture = outputValue_2.texture;
  v_gradient = outputValue_2.gradient;
  v_shininess = outputValue_2.shininess;
  v_specularity = outputValue_2.specularity;
  v_clipPosition = outputValue_2.clipPosition;
//DiffuseBuildingTop::diffuseBuildingTop_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
in highp vec3 v_clipPosition;
uniform Style style;
uniform Scale scale;
uniform Fade fade;
out lowp vec4 output_value;
void main ()
  lowp float styleBrightness_1;
  styleBrightness_1 = style.brightness;
  lowp float scale_2;
  scale_2 = scale.scale;
  highp vec2 tmpvar_3;
  tmpvar_3 = fade.fadeEquation;
  lowp vec4 c_4;
  lowp vec4 tmpvar_5;
  tmpvar_5.xyz = (v_diffuseColor.xyz * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_1), scale_2)));
  tmpvar_5.w = v_diffuseColor.w;
  lowp vec4 tmpvar_6;
  tmpvar_6 = mix (v_unlitColor, tmpvar_5, vec4(scale_2));
  c_4.xyz = tmpvar_6.xyz;
  lowp float tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (((v_clipPosition.y * tmpvar_3.x) + tmpvar_3.y), fade.alphaFactor, 1.0);
  tmpvar_7 = tmpvar_8;
  c_4.w = (tmpvar_6.w * tmpvar_7);
  output_value = c_4;
//DiffuseLandmark::diffuseLandmark_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
  highp vec2 texture;
  highp vec4 normalAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_position;
in highp vec2 vertex_input_texture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.position = vertex_input_position;
  vertex_input_1.texture = vertex_input_texture;
  vertex_input_1.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_2;
  highp int tmpvar_3;
  tmpvar_3 = int(((vertex_input_1.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_2.normal = vertex_input_1.normalAndStyleIndex.xyz;
  outputValue_2.unlitColor = style.color[tmpvar_3];
  outputValue_2.shininess = style.shininessAndSpecularity[tmpvar_3].x;
  outputValue_2.specularity = style.shininessAndSpecularity[tmpvar_3].y;
  outputValue_2.position = (scale.tileOrigin + (scale.tileSize * vertex_input_1.position.xyz));
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xy = outputValue_2.position.xy;
  tmpvar_4.z = (outputValue_2.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  outputValue_2.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_5;
  normal_5 = outputValue_2.normal;
  lowp vec3 lightContributions_6;
  highp vec3 tmpvar_7;
  tmpvar_7 = lightConfig.ambientLightColor.xyz;
  lightContributions_6 = tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_8) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_9) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_10) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = (outputValue_2.unlitColor.xyz * lightContributions_6);
  tmpvar_11.w = outputValue_2.unlitColor.w;
  outputValue_2.diffuseColor = tmpvar_11;
  highp float tmpvar_12;
  highp vec2 gradient_13;
  gradient_13 = gradient.equation[tmpvar_3];
  tmpvar_12 = ((gradient_13.x * outputValue_2.position.z) + gradient_13.y);
  outputValue_2.gradient = tmpvar_12;
  outputValue_2.texture = vertex_input_1.texture;
  v_fogCoordinate = outputValue_2.fogCoordinate;
  v_fogColor = outputValue_2.fogColor;
  v_unlitColor = outputValue_2.unlitColor;
  v_diffuseColor = outputValue_2.diffuseColor;
  v_normal = outputValue_2.normal;
  v_position = outputValue_2.position;
  v_texture = outputValue_2.texture;
  v_gradient = outputValue_2.gradient;
  v_shininess = outputValue_2.shininess;
  v_specularity = outputValue_2.specularity;
  v_clipPosition = outputValue_2.clipPosition;
//DiffuseLandmark::diffuseLandmark_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
in highp vec3 v_clipPosition;
uniform Scale scale;
uniform Style style;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  lowp float styleBrightness_1;
  styleBrightness_1 = style.brightness;
  lowp float scale_2;
  scale_2 = scale.scale;
  mediump float textureLightness_3;
  textureLightness_3 = style.textureLightness;
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp vec4 texturedColor_5;
  lowp vec4 textureColor_6;
  lowp vec4 tmpvar_7;
  tmpvar_7 = texture (textureSampler, v_texture);
  mediump vec4 tmpvar_8;
  tmpvar_8 = mix (tmpvar_7, vec4(1.0, 1.0, 1.0, 1.0), vec4(textureLightness_3));
  textureColor_6 = tmpvar_8;
  lowp vec4 tmpvar_9;
  tmpvar_9.xyz = (v_diffuseColor.xyz * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_1), scale_2)));
  tmpvar_9.w = v_diffuseColor.w;
  lowp vec4 tmpvar_10;
  tmpvar_10 = (mix (v_unlitColor, tmpvar_9, vec4(scale_2)) * textureColor_6);
  texturedColor_5.xyz = tmpvar_10.xyz;
  lowp float tmpvar_11;
  highp float tmpvar_12;
  tmpvar_12 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_11 = tmpvar_12;
  texturedColor_5.w = (tmpvar_10.w * tmpvar_11);
  output_value = texturedColor_5;
//Fog::fog_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Varyings {
  highp float fogCoordinate;
  lowp vec4 fogColor;
in highp vec4 vertex_input_vertexAndStyleIndex;
uniform Skyfog skyfog;
uniform View view;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
void main ()
  Varyings outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.x = vertex_input_2.vertexAndStyleIndex.x;
  tmpvar_3.y = vertex_input_2.vertexAndStyleIndex.y;
  tmpvar_3.z = ((vertex_input_2.vertexAndStyleIndex.z * 2.0) - 1.0);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  outputValue_1.fogCoordinate = (dot (skyfog.fogSlope, tmpvar_3) + skyfog.fogOffset);
  lowp vec4 tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + (0.5 * gl_Position.y)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_4 = tmpvar_5;
  outputValue_1.fogColor = tmpvar_4;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
//Fog::fog_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
out lowp vec4 output_value;
void main ()
  highp vec4 tmpvar_1;
  tmpvar_1.xyz = v_fogColor.xyz;
  tmpvar_1.w = (v_fogColor.w * v_fogCoordinate);
  output_value = tmpvar_1;
//FoggedDiffuseBuilding::foggedDiffuseBuilding_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndTexture;
  highp vec4 normalAndStyleIndex;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndTexture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndTexture = vertex_input_vertexAndTexture;
  vertex_input_2.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_3;
  highp int tmpvar_4;
  tmpvar_4 = int(((vertex_input_2.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_3.normal = vertex_input_2.normalAndStyleIndex.xyz;
  outputValue_3.unlitColor = style.color[tmpvar_4];
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_4].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_4].y;
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.vertexAndTexture.xyz));
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xy = outputValue_3.position.xy;
  tmpvar_5.z = (outputValue_3.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  outputValue_3.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_6;
  normal_6 = outputValue_3.normal;
  lowp vec3 lightContributions_7;
  highp vec3 tmpvar_8;
  tmpvar_8 = lightConfig.ambientLightColor.xyz;
  lightContributions_7 = tmpvar_8;
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_9) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_10) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_11;
  tmpvar_11 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_11) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_12;
  tmpvar_12.xyz = (outputValue_3.unlitColor.xyz * lightContributions_7);
  tmpvar_12.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_12;
  highp float tmpvar_13;
  highp vec2 gradient_14;
  gradient_14 = gradient.equation[tmpvar_4];
  tmpvar_13 = ((gradient_14.x * outputValue_3.position.z) + gradient_14.y);
  outputValue_3.gradient = tmpvar_13;
  highp float tmpvar_15;
  tmpvar_15 = floor((vertex_input_2.vertexAndTexture.w * 256.0));
  highp vec2 tmpvar_16;
  tmpvar_16.x = tmpvar_15;
  tmpvar_16.y = floor(((
    (vertex_input_2.vertexAndTexture.w * 256.0)
   - tmpvar_15) * 256.0));
  outputValue_3.texture = floor((tmpvar_16 * vec2(style.textureCoordScale[tmpvar_4])));
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_17;
  tmpvar_17.w = 1.0;
  tmpvar_17.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (dot (skyfog.fogSlope, tmpvar_17) + skyfog.fogOffset);
  lowp vec4 tmpvar_18;
  highp vec4 tmpvar_19;
  tmpvar_19 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_18 = tmpvar_19;
  outputValue_1.fogColor = tmpvar_18;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//FoggedDiffuseBuilding::foggedDiffuseBuilding_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  lowp float styleBrightness_1;
  styleBrightness_1 = style.brightness;
  lowp float scale_2;
  scale_2 = scale.scale;
  highp vec2 tmpvar_3;
  tmpvar_3 = fade.fadeEquation;
  lowp vec4 texturedColor_4;
  lowp vec4 textureColor_5;
  lowp vec4 tmpvar_6;
  tmpvar_6 = texture (textureSampler, v_texture);
  mediump vec4 tmpvar_7;
  tmpvar_7 = tmpvar_6;
  textureColor_5 = tmpvar_7;
  lowp vec4 tmpvar_8;
  tmpvar_8.xyz = (v_diffuseColor.xyz * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_1), scale_2)));
  tmpvar_8.w = v_diffuseColor.w;
  lowp vec4 tmpvar_9;
  tmpvar_9 = (mix (v_unlitColor, tmpvar_8, vec4(scale_2)) * textureColor_5);
  texturedColor_4.xyz = tmpvar_9.xyz;
  lowp float tmpvar_10;
  highp float tmpvar_11;
  tmpvar_11 = clamp (((v_clipPosition.y * tmpvar_3.x) + tmpvar_3.y), fade.alphaFactor, 1.0);
  tmpvar_10 = tmpvar_11;
  texturedColor_4.w = (tmpvar_9.w * tmpvar_10);
  lowp vec4 color_12;
  highp vec4 tmpvar_13;
  tmpvar_13 = mix (texturedColor_4, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_12 = tmpvar_13;
  output_value = color_12;
//FoggedDiffuseBuildingTop::foggedDiffuseBuildingTop_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndStyleIndex;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  VertexOut outputValue_3;
  highp int tmpvar_4;
  tmpvar_4 = int((vertex_input_2.vertexAndStyleIndex.w * 256.0));
  outputValue_3.unlitColor = style.color[tmpvar_4];
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_4].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_4].y;
  outputValue_3.normal = vec3(0.0, 0.0, 1.0);
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.vertexAndStyleIndex.xyz));
  outputValue_3.position.z = (outputValue_3.position.z * scale.scale);
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = outputValue_3.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  outputValue_3.clipPosition = (gl_Position.xyz / gl_Position.www);
  lowp vec3 lightContributions_6;
  highp vec3 tmpvar_7;
  tmpvar_7 = lightConfig.ambientLightColor.xyz;
  lightContributions_6 = tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (lightConfig.lightDirection[0].z, 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_8) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (lightConfig.lightDirection[1].z, 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_9) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (lightConfig.lightDirection[2].z, 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_10) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = (outputValue_3.unlitColor.xyz * lightContributions_6);
  tmpvar_11.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_11;
  if ((outputValue_3.position.z < 1e-08)) {
    highp float tmpvar_12;
    tmpvar_12 = mix (0.935, 1.0, scale.scale);
    outputValue_3.gradient = tmpvar_12;
  } else {
    highp float tmpvar_13;
    highp vec2 gradient_14;
    gradient_14 = gradient.equation[tmpvar_4];
    tmpvar_13 = ((gradient_14.x * outputValue_3.position.z) + gradient_14.y);
    outputValue_3.gradient = tmpvar_13;
  };
  outputValue_3.texture = vertex_input_2.vertexAndStyleIndex.xy;
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (dot (skyfog.fogSlope, tmpvar_15) + skyfog.fogOffset);
  lowp vec4 tmpvar_16;
  highp vec4 tmpvar_17;
  tmpvar_17 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_16 = tmpvar_17;
  outputValue_1.fogColor = tmpvar_16;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//FoggedDiffuseBuildingTop::foggedDiffuseBuildingTop_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform Fade fade;
out lowp vec4 output_value;
void main ()
  lowp float styleBrightness_1;
  styleBrightness_1 = style.brightness;
  lowp float scale_2;
  scale_2 = scale.scale;
  highp vec2 tmpvar_3;
  tmpvar_3 = fade.fadeEquation;
  lowp float tmpvar_4;
  highp float tmpvar_5;
  tmpvar_5 = clamp (((v_clipPosition.y * tmpvar_3.x) + tmpvar_3.y), fade.alphaFactor, 1.0);
  tmpvar_4 = tmpvar_5;
  lowp vec4 tmpvar_6;
  tmpvar_6 = mix (v_unlitColor, (v_diffuseColor * vec4(mix (1.0, 
    (min (v_gradient, 0.9799805) * styleBrightness_1)
  , scale_2))), vec4((tmpvar_4 * scale_2)));
  lowp vec4 color_7;
  highp vec4 tmpvar_8;
  tmpvar_8 = mix (tmpvar_6, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_7 = tmpvar_8;
  output_value = color_7;
//FoggedDiffuseLandmark::foggedDiffuseLandmark_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
  highp vec2 texture;
  highp vec4 normalAndStyleIndex;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_position;
in highp vec2 vertex_input_texture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.position = vertex_input_position;
  vertex_input_2.texture = vertex_input_texture;
  vertex_input_2.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_3;
  highp int tmpvar_4;
  tmpvar_4 = int(((vertex_input_2.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_3.normal = vertex_input_2.normalAndStyleIndex.xyz;
  outputValue_3.unlitColor = style.color[tmpvar_4];
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_4].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_4].y;
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.position.xyz));
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xy = outputValue_3.position.xy;
  tmpvar_5.z = (outputValue_3.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  outputValue_3.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_6;
  normal_6 = outputValue_3.normal;
  lowp vec3 lightContributions_7;
  highp vec3 tmpvar_8;
  tmpvar_8 = lightConfig.ambientLightColor.xyz;
  lightContributions_7 = tmpvar_8;
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_9) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_10) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_11;
  tmpvar_11 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_11) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_12;
  tmpvar_12.xyz = (outputValue_3.unlitColor.xyz * lightContributions_7);
  tmpvar_12.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_12;
  highp float tmpvar_13;
  highp vec2 gradient_14;
  gradient_14 = gradient.equation[tmpvar_4];
  tmpvar_13 = ((gradient_14.x * outputValue_3.position.z) + gradient_14.y);
  outputValue_3.gradient = tmpvar_13;
  outputValue_3.texture = vertex_input_2.texture;
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (dot (skyfog.fogSlope, tmpvar_15) + skyfog.fogOffset);
  lowp vec4 tmpvar_16;
  highp vec4 tmpvar_17;
  tmpvar_17 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_16 = tmpvar_17;
  outputValue_1.fogColor = tmpvar_16;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//FoggedDiffuseLandmark::foggedDiffuseLandmark_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  lowp float styleBrightness_1;
  styleBrightness_1 = style.brightness;
  lowp float scale_2;
  scale_2 = scale.scale;
  mediump float textureLightness_3;
  textureLightness_3 = style.textureLightness;
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp vec4 texturedColor_5;
  lowp vec4 textureColor_6;
  lowp vec4 tmpvar_7;
  tmpvar_7 = texture (textureSampler, v_texture);
  mediump vec4 tmpvar_8;
  tmpvar_8 = mix (tmpvar_7, vec4(1.0, 1.0, 1.0, 1.0), vec4(textureLightness_3));
  textureColor_6 = tmpvar_8;
  lowp vec4 tmpvar_9;
  tmpvar_9.xyz = (v_diffuseColor.xyz * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_1), scale_2)));
  tmpvar_9.w = v_diffuseColor.w;
  lowp vec4 tmpvar_10;
  tmpvar_10 = (mix (v_unlitColor, tmpvar_9, vec4(scale_2)) * textureColor_6);
  texturedColor_5.xyz = tmpvar_10.xyz;
  lowp float tmpvar_11;
  highp float tmpvar_12;
  tmpvar_12 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_11 = tmpvar_12;
  texturedColor_5.w = (tmpvar_10.w * tmpvar_11);
  lowp vec4 color_13;
  highp vec4 tmpvar_14;
  tmpvar_14 = mix (texturedColor_5, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_13 = tmpvar_14;
  output_value = color_13;
//FoggedSpecularBuilding::foggedSpecularBuilding_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndTexture;
  highp vec4 normalAndStyleIndex;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndTexture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndTexture = vertex_input_vertexAndTexture;
  vertex_input_2.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_3;
  highp int tmpvar_4;
  tmpvar_4 = int(((vertex_input_2.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_3.normal = vertex_input_2.normalAndStyleIndex.xyz;
  outputValue_3.unlitColor = style.color[tmpvar_4];
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_4].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_4].y;
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.vertexAndTexture.xyz));
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xy = outputValue_3.position.xy;
  tmpvar_5.z = (outputValue_3.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  outputValue_3.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_6;
  normal_6 = outputValue_3.normal;
  lowp vec3 lightContributions_7;
  highp vec3 tmpvar_8;
  tmpvar_8 = lightConfig.ambientLightColor.xyz;
  lightContributions_7 = tmpvar_8;
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_9) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_10) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_11;
  tmpvar_11 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_11) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_12;
  tmpvar_12.xyz = (outputValue_3.unlitColor.xyz * lightContributions_7);
  tmpvar_12.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_12;
  highp float tmpvar_13;
  highp vec2 gradient_14;
  gradient_14 = gradient.equation[tmpvar_4];
  tmpvar_13 = ((gradient_14.x * outputValue_3.position.z) + gradient_14.y);
  outputValue_3.gradient = tmpvar_13;
  highp float tmpvar_15;
  tmpvar_15 = floor((vertex_input_2.vertexAndTexture.w * 256.0));
  highp vec2 tmpvar_16;
  tmpvar_16.x = tmpvar_15;
  tmpvar_16.y = floor(((
    (vertex_input_2.vertexAndTexture.w * 256.0)
   - tmpvar_15) * 256.0));
  outputValue_3.texture = floor((tmpvar_16 * vec2(style.textureCoordScale[tmpvar_4])));
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_17;
  tmpvar_17.w = 1.0;
  tmpvar_17.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (dot (skyfog.fogSlope, tmpvar_17) + skyfog.fogOffset);
  lowp vec4 tmpvar_18;
  highp vec4 tmpvar_19;
  tmpvar_19 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_18 = tmpvar_19;
  outputValue_1.fogColor = tmpvar_18;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//FoggedSpecularBuilding::foggedSpecularBuilding_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform LightConfiguration lightConfig;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = scale.scale;
  highp float tmpvar_2;
  tmpvar_2 = style.brightness;
  highp vec4 tmpvar_3;
  tmpvar_3 = lightConfig.lightDirection[uint(0)];
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp vec4 texturedColor_5;
  lowp float lowScale_6;
  lowScale_6 = tmpvar_1;
  lowp vec3 tmpvar_7;
  highp vec3 tmpvar_8;
  tmpvar_8 = (lightConfig.lightSpecularColor.xyz * vec3(((v_specularity * 
    pow (max (0.0, dot (normalize(
      (v_position - style.cameraPositionInTileSpace)
    ), normalize(
      (tmpvar_3.xyz - (2.0 * (dot (v_normal, tmpvar_3.xyz) * v_normal)))
    ))), v_shininess)
  ) * (
    (v_shininess + 8.0)
   / 25.13274))));
  tmpvar_7 = tmpvar_8;
  lowp float styleBrightness_9;
  styleBrightness_9 = tmpvar_2;
  lowp vec4 tmpvar_10;
  tmpvar_10.xyz = ((v_diffuseColor.xyz + tmpvar_7) * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_9), lowScale_6)));
  tmpvar_10.w = v_diffuseColor.w;
  lowp vec4 tmpvar_11;
  tmpvar_11 = (mix (v_unlitColor, tmpvar_10, vec4(lowScale_6)) * texture (textureSampler, v_texture));
  texturedColor_5.xyz = tmpvar_11.xyz;
  lowp float tmpvar_12;
  highp float tmpvar_13;
  tmpvar_13 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_12 = tmpvar_13;
  texturedColor_5.w = (tmpvar_11.w * tmpvar_12);
  lowp vec4 color_14;
  highp vec4 tmpvar_15;
  tmpvar_15 = mix (texturedColor_5, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_14 = tmpvar_15;
  output_value = color_14;
//FoggedSpecularBuildingTop::foggedSpecularBuildingTop_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndStyleIndex;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  VertexOut outputValue_3;
  highp int tmpvar_4;
  tmpvar_4 = int((vertex_input_2.vertexAndStyleIndex.w * 256.0));
  outputValue_3.unlitColor = style.color[tmpvar_4];
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_4].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_4].y;
  outputValue_3.normal = vec3(0.0, 0.0, 1.0);
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.vertexAndStyleIndex.xyz));
  outputValue_3.position.z = (outputValue_3.position.z * scale.scale);
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = outputValue_3.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  outputValue_3.clipPosition = (gl_Position.xyz / gl_Position.www);
  lowp vec3 lightContributions_6;
  highp vec3 tmpvar_7;
  tmpvar_7 = lightConfig.ambientLightColor.xyz;
  lightContributions_6 = tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (lightConfig.lightDirection[0].z, 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_8) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (lightConfig.lightDirection[1].z, 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_9) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (lightConfig.lightDirection[2].z, 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_10) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = (outputValue_3.unlitColor.xyz * lightContributions_6);
  tmpvar_11.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_11;
  if ((outputValue_3.position.z < 1e-08)) {
    highp float tmpvar_12;
    tmpvar_12 = mix (0.935, 1.0, scale.scale);
    outputValue_3.gradient = tmpvar_12;
  } else {
    highp float tmpvar_13;
    highp vec2 gradient_14;
    gradient_14 = gradient.equation[tmpvar_4];
    tmpvar_13 = ((gradient_14.x * outputValue_3.position.z) + gradient_14.y);
    outputValue_3.gradient = tmpvar_13;
  };
  outputValue_3.texture = vertex_input_2.vertexAndStyleIndex.xy;
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (dot (skyfog.fogSlope, tmpvar_15) + skyfog.fogOffset);
  lowp vec4 tmpvar_16;
  highp vec4 tmpvar_17;
  tmpvar_17 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_16 = tmpvar_17;
  outputValue_1.fogColor = tmpvar_16;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//FoggedSpecularBuildingTop::foggedSpecularBuildingTop_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform LightConfiguration lightConfig;
uniform Fade fade;
out lowp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = scale.scale;
  highp float tmpvar_2;
  tmpvar_2 = style.brightness;
  highp vec4 tmpvar_3;
  tmpvar_3 = lightConfig.lightDirection[uint(0)];
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp vec4 c_5;
  lowp float lowScale_6;
  lowScale_6 = tmpvar_1;
  lowp vec3 tmpvar_7;
  highp vec3 tmpvar_8;
  tmpvar_8.xy = tmpvar_3.xy;
  tmpvar_8.z = -(tmpvar_3.z);
  highp vec3 tmpvar_9;
  tmpvar_9 = (lightConfig.lightSpecularColor.xyz * vec3((pow (
    max (0.0, dot (normalize((v_position - style.cameraPositionInTileSpace)), normalize(tmpvar_8)))
  , v_shininess) * (
    (v_shininess + 8.0)
   / 25.13274))));
  tmpvar_7 = tmpvar_9;
  lowp float styleBrightness_10;
  styleBrightness_10 = tmpvar_2;
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = ((v_diffuseColor.xyz + tmpvar_7) * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_10), lowScale_6)));
  tmpvar_11.w = v_diffuseColor.w;
  highp vec4 tmpvar_12;
  tmpvar_12 = mix (v_unlitColor, tmpvar_11, vec4(tmpvar_1));
  c_5 = tmpvar_12;
  lowp float tmpvar_13;
  highp float tmpvar_14;
  tmpvar_14 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_13 = tmpvar_14;
  c_5.w = (c_5.w * tmpvar_13);
  lowp vec4 color_15;
  highp vec4 tmpvar_16;
  tmpvar_16 = mix (c_5, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_15 = tmpvar_16;
  output_value = color_15;
//FoggedSpecularLandmark::foggedSpecularLandmark_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
  highp vec2 texture;
  highp vec4 normalAndStyleIndex;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_position;
in highp vec2 vertex_input_texture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.position = vertex_input_position;
  vertex_input_2.texture = vertex_input_texture;
  vertex_input_2.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_3;
  highp int tmpvar_4;
  tmpvar_4 = int(((vertex_input_2.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_3.normal = vertex_input_2.normalAndStyleIndex.xyz;
  outputValue_3.unlitColor = style.color[tmpvar_4];
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_4].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_4].y;
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.position.xyz));
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xy = outputValue_3.position.xy;
  tmpvar_5.z = (outputValue_3.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  outputValue_3.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_6;
  normal_6 = outputValue_3.normal;
  lowp vec3 lightContributions_7;
  highp vec3 tmpvar_8;
  tmpvar_8 = lightConfig.ambientLightColor.xyz;
  lightContributions_7 = tmpvar_8;
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_9) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_10) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_11;
  tmpvar_11 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_6), 0.0, 1.0);
  lightContributions_7 = (lightContributions_7 + (vec3(tmpvar_11) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_12;
  tmpvar_12.xyz = (outputValue_3.unlitColor.xyz * lightContributions_7);
  tmpvar_12.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_12;
  highp float tmpvar_13;
  highp vec2 gradient_14;
  gradient_14 = gradient.equation[tmpvar_4];
  tmpvar_13 = ((gradient_14.x * outputValue_3.position.z) + gradient_14.y);
  outputValue_3.gradient = tmpvar_13;
  outputValue_3.texture = vertex_input_2.texture;
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (dot (skyfog.fogSlope, tmpvar_15) + skyfog.fogOffset);
  lowp vec4 tmpvar_16;
  highp vec4 tmpvar_17;
  tmpvar_17 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_16 = tmpvar_17;
  outputValue_1.fogColor = tmpvar_16;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//FoggedSpecularLandmark::foggedSpecularLandmark_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform LightConfiguration lightConfig;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = scale.scale;
  highp float tmpvar_2;
  tmpvar_2 = style.brightness;
  highp vec4 tmpvar_3;
  tmpvar_3 = lightConfig.lightDirection[uint(0)];
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp float textureLightness_5;
  textureLightness_5 = style.textureLightness;
  lowp vec4 texturedColor_6;
  lowp float lowScale_7;
  lowScale_7 = tmpvar_1;
  lowp vec3 tmpvar_8;
  highp vec3 tmpvar_9;
  tmpvar_9 = (lightConfig.lightSpecularColor.xyz * vec3(((v_specularity * 
    pow (max (0.0, dot (normalize(
      (v_position - style.cameraPositionInTileSpace)
    ), normalize(
      (tmpvar_3.xyz - (2.0 * (dot (v_normal, tmpvar_3.xyz) * v_normal)))
    ))), v_shininess)
  ) * (
    (v_shininess + 8.0)
   / 25.13274))));
  tmpvar_8 = tmpvar_9;
  lowp float styleBrightness_10;
  styleBrightness_10 = tmpvar_2;
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = ((v_diffuseColor.xyz + tmpvar_8) * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_10), lowScale_7)));
  tmpvar_11.w = v_diffuseColor.w;
  lowp vec4 tmpvar_12;
  tmpvar_12 = (mix (v_unlitColor, tmpvar_11, vec4(lowScale_7)) * mix (texture (textureSampler, v_texture), vec4(1.0, 1.0, 1.0, 1.0), vec4(textureLightness_5)));
  texturedColor_6.xyz = tmpvar_12.xyz;
  lowp float tmpvar_13;
  highp float tmpvar_14;
  tmpvar_14 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_13 = tmpvar_14;
  texturedColor_6.w = (tmpvar_12.w * tmpvar_13);
  lowp vec4 color_15;
  highp vec4 tmpvar_16;
  tmpvar_16 = mix (texturedColor_6, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_15 = tmpvar_16;
  output_value = color_15;
//Glow::glow_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 vertex_pos;
  highp vec4 normalAndTexture;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp float radius;
in highp vec2 vertex_attributes_vertex_pos;
in highp vec4 vertex_attributes_normalAndTexture;
uniform View view;
uniform Style style;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.vertex_pos = vertex_attributes_vertex_pos;
  vertex_attributes_1.normalAndTexture = vertex_attributes_normalAndTexture;
  highp vec2 tmpvar_2;
  tmpvar_2 = (((vertex_attributes_1.normalAndTexture.xy * vec2(style.radius)) * vec2(view.tilePerPoint)) * vertex_attributes_1.normalAndTexture.zz);
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.x = (vertex_attributes_1.vertex_pos.x + tmpvar_2.x);
  tmpvar_3.y = (vertex_attributes_1.vertex_pos.y + tmpvar_2.y);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
//Glow::glow_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp float radius;
uniform Style style;
out lowp vec4 output_value;
void main ()
  output_value = style.color;
//GlowAlpha::glowAlpha_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 vertex_pos;
  highp vec4 normalAndTexture;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Glow {
  highp float radius;
  highp float opacity;
struct VertexOut {
  highp float alphaRamp;
in highp vec2 vertex_attributes_vertex_pos;
in highp vec4 vertex_attributes_normalAndTexture;
uniform View view;
uniform Glow glow;
out highp float v_alphaRamp;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.vertex_pos = vertex_attributes_vertex_pos;
  vertex_attributes_2.normalAndTexture = vertex_attributes_normalAndTexture;
  highp vec2 tmpvar_3;
  tmpvar_3 = (((vertex_attributes_2.normalAndTexture.xy * vec2(glow.radius)) * vec2(view.tilePerPoint)) * vertex_attributes_2.normalAndTexture.zz);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = (vertex_attributes_2.vertex_pos.x + tmpvar_3.x);
  tmpvar_4.y = (vertex_attributes_2.vertex_pos.y + tmpvar_3.y);
  outputValue_1.alphaRamp = (glow.opacity * (1.0 - vertex_attributes_2.normalAndTexture.z));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  v_alphaRamp = outputValue_1.alphaRamp;
//GlowAlpha::glowAlpha_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp float v_alphaRamp;
inout lowp vec4 output_value;
void main ()
  lowp float oneMinusAlpha_1;
  highp float tmpvar_2;
  tmpvar_2 = (1.0 - v_alphaRamp);
  oneMinusAlpha_1 = tmpvar_2;
  lowp vec4 tmpvar_3;
  tmpvar_3.xyz = output_value.xyz;
  tmpvar_3.w = min (oneMinusAlpha_1, output_value.w);
  output_value = tmpvar_3;
//Glyph3d::glyph3d_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSizeB {
  highp int width;
  highp int height;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct Vertex3dOut {
  highp vec2 texture;
  mediump vec4 color;
  mediump vec4 extrusionColor;
  mediump vec4 strokeColor;
  mediump vec4 haloColor;
  mediump float strokeWidth;
  mediump float extrusionDepth;
  mediump float haloSize;
  mediump float haloBlur;
  highp vec3 tangentViewFragPosition;
  highp vec3 tangent;
  highp vec3 bitangent;
  highp vec3 normal;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform Options labelOptions;
uniform DeviceBufferTextureSizeB byteBufferTextureSize;
uniform sampler2D byteBufferTexture;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out mediump vec4 v_color;
out mediump vec4 v_extrusionColor;
out mediump vec4 v_strokeColor;
out mediump vec4 v_haloColor;
out mediump float v_strokeWidth;
out mediump float v_extrusionDepth;
out mediump float v_haloSize;
out mediump float v_haloBlur;
out highp vec3 v_tangentViewFragPosition;
out highp vec3 v_tangent;
out highp vec3 v_bitangent;
out highp vec3 v_normal;
void main ()
  Vertex3dOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.position = vertex_attributes_position;
  vertex_attributes_2.texture = vertex_attributes_texture;
  vertex_attributes_2.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_2.color = vertex_attributes_color;
  vertex_attributes_2.haloColor = vertex_attributes_haloColor;
  vertex_attributes_2.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_2.tangent = vertex_attributes_tangent;
  vertex_attributes_2.bitangent = vertex_attributes_bitangent;
  Vertex3dOut outputValue_3;
  VertexOut outputValue_4;
  highp float alpha_5;
  alpha_5 = ((vertex_attributes_2.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_6;
  tmpvar_6.zw = vec2(0.0, 1.0);
  tmpvar_6.x = vertex_attributes_2.position.x;
  tmpvar_6.y = vertex_attributes_2.position.y;
  outputValue_4.texture = vertex_attributes_2.texture;
  highp vec4 tmpvar_7;
  tmpvar_7.x = vertex_attributes_2.color.x;
  tmpvar_7.y = vertex_attributes_2.color.y;
  tmpvar_7.z = vertex_attributes_2.color.z;
  tmpvar_7.w = (vertex_attributes_2.color.w * alpha_5);
  outputValue_4.color = tmpvar_7;
  highp vec4 tmpvar_8;
  tmpvar_8.x = vertex_attributes_2.haloColor.x;
  tmpvar_8.y = vertex_attributes_2.haloColor.y;
  tmpvar_8.z = vertex_attributes_2.haloColor.z;
  tmpvar_8.w = (vertex_attributes_2.haloColor.w * alpha_5);
  outputValue_4.haloColor = tmpvar_8;
  outputValue_4.tangent = vertex_attributes_2.tangent;
  outputValue_4.bitangent = vertex_attributes_2.bitangent;
  outputValue_4.haloSizeInPixels = ((vertex_attributes_2.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  outputValue_3.texture = outputValue_4.texture;
  outputValue_3.color = outputValue_4.color;
  highp vec3 tmpvar_9;
  tmpvar_9.z = 0.0;
  tmpvar_9.xy = outputValue_4.tangent;
  outputValue_3.tangent = tmpvar_9;
  highp vec3 tmpvar_10;
  tmpvar_10.z = 0.0;
  tmpvar_10.xy = outputValue_4.bitangent;
  outputValue_3.bitangent = tmpvar_10;
  highp vec3 a_11;
  a_11 = outputValue_3.tangent;
  highp vec3 b_12;
  b_12 = outputValue_3.bitangent;
  outputValue_3.normal = normalize(((a_11.yzx * b_12.zxy) - (a_11.zxy * b_12.yzx)));
  outputValue_3.haloSize = outputValue_4.haloSizeInPixels;
  outputValue_3.haloColor = outputValue_4.haloColor;
  outputValue_1 = outputValue_3;
  highp int tmpvar_13;
  tmpvar_13 = int((65535.0 * vertex_attributes_2.deviceBufferIndex.x));
  highp int tmpvar_14;
  tmpvar_14 = int((65535.0 * vertex_attributes_2.deviceBufferIndex.y));
  highp mat4 matrixOut_15;
  highp vec2 tmpvar_16;
  tmpvar_16.x = float(floatBufferTextureSize.width);
  tmpvar_16.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_17;
  tmpvar_17 = (1.0/(tmpvar_16));
  highp int textureWidth_18;
  textureWidth_18 = floatBufferTextureSize.width;
  highp int tmpvar_19;
  tmpvar_19 = (tmpvar_13 / textureWidth_18);
  highp float tmpvar_20;
  tmpvar_20 = ((float(
    (tmpvar_13 - (tmpvar_19 * textureWidth_18))
  ) + 0.5) / float(textureWidth_18));
  highp vec2 tmpvar_21;
  tmpvar_21.x = tmpvar_20;
  tmpvar_21.y = ((float(tmpvar_19) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_22;
  tmpvar_22 = texture (floatBufferTexture, tmpvar_21);
  matrixOut_15[0] = tmpvar_22;
  highp vec2 uvCoordinate_23;
  uvCoordinate_23.y = tmpvar_21.y;
  uvCoordinate_23.x = (tmpvar_20 + tmpvar_17.x);
  highp vec2 tmpvar_24;
  tmpvar_24.x = -1.0;
  tmpvar_24.y = tmpvar_17.y;
  uvCoordinate_23 = (uvCoordinate_23 + (vec2(float(
    (uvCoordinate_23.x >= 1.0)
  )) * tmpvar_24));
  lowp vec4 tmpvar_25;
  tmpvar_25 = texture (floatBufferTexture, uvCoordinate_23);
  matrixOut_15[1] = tmpvar_25;
  highp vec2 uvCoordinate_26;
  uvCoordinate_26.y = tmpvar_21.y;
  uvCoordinate_26.x = (tmpvar_20 + (tmpvar_17.x * 2.0));
  highp vec2 tmpvar_27;
  tmpvar_27.x = -1.0;
  tmpvar_27.y = tmpvar_17.y;
  uvCoordinate_26 = (uvCoordinate_26 + (vec2(float(
    (uvCoordinate_26.x >= 1.0)
  )) * tmpvar_27));
  lowp vec4 tmpvar_28;
  tmpvar_28 = texture (floatBufferTexture, uvCoordinate_26);
  matrixOut_15[2] = tmpvar_28;
  highp vec2 uvCoordinate_29;
  uvCoordinate_29.y = tmpvar_21.y;
  uvCoordinate_29.x = (tmpvar_20 + (tmpvar_17.x * 3.0));
  highp vec2 tmpvar_30;
  tmpvar_30.x = -1.0;
  tmpvar_30.y = tmpvar_17.y;
  uvCoordinate_29 = (uvCoordinate_29 + (vec2(float(
    (uvCoordinate_29.x >= 1.0)
  )) * tmpvar_30));
  lowp vec4 tmpvar_31;
  tmpvar_31 = texture (floatBufferTexture, uvCoordinate_29);
  matrixOut_15[3] = tmpvar_31;
  highp int elementIndex_32;
  elementIndex_32 = (tmpvar_13 + 4);
  highp mat4 matrixOut_33;
  highp vec2 tmpvar_34;
  tmpvar_34.x = float(floatBufferTextureSize.width);
  tmpvar_34.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_35;
  tmpvar_35 = (1.0/(tmpvar_34));
  highp int textureWidth_36;
  textureWidth_36 = floatBufferTextureSize.width;
  highp int tmpvar_37;
  tmpvar_37 = (elementIndex_32 / textureWidth_36);
  highp float tmpvar_38;
  tmpvar_38 = ((float(
    (elementIndex_32 - (tmpvar_37 * textureWidth_36))
  ) + 0.5) / float(textureWidth_36));
  highp vec2 tmpvar_39;
  tmpvar_39.x = tmpvar_38;
  tmpvar_39.y = ((float(tmpvar_37) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_40;
  tmpvar_40 = texture (floatBufferTexture, tmpvar_39);
  matrixOut_33[0] = tmpvar_40;
  highp vec2 uvCoordinate_41;
  uvCoordinate_41.y = tmpvar_39.y;
  uvCoordinate_41.x = (tmpvar_38 + tmpvar_35.x);
  highp vec2 tmpvar_42;
  tmpvar_42.x = -1.0;
  tmpvar_42.y = tmpvar_35.y;
  uvCoordinate_41 = (uvCoordinate_41 + (vec2(float(
    (uvCoordinate_41.x >= 1.0)
  )) * tmpvar_42));
  lowp vec4 tmpvar_43;
  tmpvar_43 = texture (floatBufferTexture, uvCoordinate_41);
  matrixOut_33[1] = tmpvar_43;
  highp vec2 uvCoordinate_44;
  uvCoordinate_44.y = tmpvar_39.y;
  uvCoordinate_44.x = (tmpvar_38 + (tmpvar_35.x * 2.0));
  highp vec2 tmpvar_45;
  tmpvar_45.x = -1.0;
  tmpvar_45.y = tmpvar_35.y;
  uvCoordinate_44 = (uvCoordinate_44 + (vec2(float(
    (uvCoordinate_44.x >= 1.0)
  )) * tmpvar_45));
  lowp vec4 tmpvar_46;
  tmpvar_46 = texture (floatBufferTexture, uvCoordinate_44);
  matrixOut_33[2] = tmpvar_46;
  highp vec2 uvCoordinate_47;
  uvCoordinate_47.y = tmpvar_39.y;
  uvCoordinate_47.x = (tmpvar_38 + (tmpvar_35.x * 3.0));
  highp vec2 tmpvar_48;
  tmpvar_48.x = -1.0;
  tmpvar_48.y = tmpvar_35.y;
  uvCoordinate_47 = (uvCoordinate_47 + (vec2(float(
    (uvCoordinate_47.x >= 1.0)
  )) * tmpvar_48));
  lowp vec4 tmpvar_49;
  tmpvar_49 = texture (floatBufferTexture, uvCoordinate_47);
  matrixOut_33[3] = tmpvar_49;
  highp int elementIndex_50;
  elementIndex_50 = (tmpvar_13 + 8);
  highp vec4 matrixOut_0_51;
  highp vec4 matrixOut_1_52;
  highp vec4 matrixOut_2_53;
  highp vec2 tmpvar_54;
  tmpvar_54.x = float(floatBufferTextureSize.width);
  tmpvar_54.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_55;
  tmpvar_55 = (1.0/(tmpvar_54));
  highp int textureWidth_56;
  textureWidth_56 = floatBufferTextureSize.width;
  highp int tmpvar_57;
  tmpvar_57 = (elementIndex_50 / textureWidth_56);
  highp float tmpvar_58;
  tmpvar_58 = ((float(
    (elementIndex_50 - (tmpvar_57 * textureWidth_56))
  ) + 0.5) / float(textureWidth_56));
  highp vec2 tmpvar_59;
  tmpvar_59.x = tmpvar_58;
  tmpvar_59.y = ((float(tmpvar_57) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_60;
  tmpvar_60 = texture (floatBufferTexture, tmpvar_59);
  matrixOut_0_51 = tmpvar_60;
  highp vec2 uvCoordinate_61;
  uvCoordinate_61.y = tmpvar_59.y;
  uvCoordinate_61.x = (tmpvar_58 + tmpvar_55.x);
  highp vec2 tmpvar_62;
  tmpvar_62.x = -1.0;
  tmpvar_62.y = tmpvar_55.y;
  uvCoordinate_61 = (uvCoordinate_61 + (vec2(float(
    (uvCoordinate_61.x >= 1.0)
  )) * tmpvar_62));
  lowp vec4 tmpvar_63;
  tmpvar_63 = texture (floatBufferTexture, uvCoordinate_61);
  matrixOut_1_52 = tmpvar_63;
  highp vec2 uvCoordinate_64;
  uvCoordinate_64.y = tmpvar_59.y;
  uvCoordinate_64.x = (tmpvar_58 + (tmpvar_55.x * 2.0));
  highp vec2 tmpvar_65;
  tmpvar_65.x = -1.0;
  tmpvar_65.y = tmpvar_55.y;
  uvCoordinate_64 = (uvCoordinate_64 + (vec2(float(
    (uvCoordinate_64.x >= 1.0)
  )) * tmpvar_65));
  lowp vec4 tmpvar_66;
  tmpvar_66 = texture (floatBufferTexture, uvCoordinate_64);
  matrixOut_2_53 = tmpvar_66;
  mediump vec4 tmpvar_67;
  highp int textureWidth_68;
  textureWidth_68 = byteBufferTextureSize.width;
  highp int tmpvar_69;
  tmpvar_69 = (tmpvar_14 / textureWidth_68);
  highp vec2 tmpvar_70;
  tmpvar_70.x = ((float(
    (tmpvar_14 - (tmpvar_69 * textureWidth_68))
  ) + 0.5) / float(textureWidth_68));
  tmpvar_70.y = ((float(tmpvar_69) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_71;
  tmpvar_71 = texture (byteBufferTexture, tmpvar_70);
  tmpvar_67 = tmpvar_71;
  mediump vec4 tmpvar_72;
  highp int elementIndex_73;
  elementIndex_73 = (tmpvar_14 + 1);
  highp int textureWidth_74;
  textureWidth_74 = byteBufferTextureSize.width;
  highp int tmpvar_75;
  tmpvar_75 = (elementIndex_73 / textureWidth_74);
  highp vec2 tmpvar_76;
  tmpvar_76.x = ((float(
    (elementIndex_73 - (tmpvar_75 * textureWidth_74))
  ) + 0.5) / float(textureWidth_74));
  tmpvar_76.y = ((float(tmpvar_75) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_77;
  tmpvar_77 = texture (byteBufferTexture, tmpvar_76);
  tmpvar_72 = tmpvar_77;
  mediump vec4 tmpvar_78;
  highp int elementIndex_79;
  elementIndex_79 = (tmpvar_14 + 2);
  highp int textureWidth_80;
  textureWidth_80 = byteBufferTextureSize.width;
  highp int tmpvar_81;
  tmpvar_81 = (elementIndex_79 / textureWidth_80);
  highp vec2 tmpvar_82;
  tmpvar_82.x = ((float(
    (elementIndex_79 - (tmpvar_81 * textureWidth_80))
  ) + 0.5) / float(textureWidth_80));
  tmpvar_82.y = ((float(tmpvar_81) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_83;
  tmpvar_83 = texture (byteBufferTexture, tmpvar_82);
  tmpvar_78 = tmpvar_83;
  highp mat3 tmpvar_84;
  tmpvar_84[uint(0)] = matrixOut_0_51.xyz;
  tmpvar_84[1u] = matrixOut_1_52.xyz;
  tmpvar_84[2u] = matrixOut_2_53.xyz;
  highp vec3 tmpvar_85;
  highp vec3 tmpvar_86;
  highp vec3 tmpvar_87;
  tmpvar_85 = normalize((tmpvar_84 * outputValue_3.tangent));
  tmpvar_86 = normalize((tmpvar_84 * outputValue_3.bitangent));
  tmpvar_87 = normalize((tmpvar_84 * outputValue_3.normal));
  highp vec3 tmpvar_88;
  tmpvar_88.x = tmpvar_85.x;
  tmpvar_88.y = tmpvar_86.x;
  tmpvar_88.z = tmpvar_87.x;
  highp vec3 tmpvar_89;
  tmpvar_89.x = tmpvar_85.y;
  tmpvar_89.y = tmpvar_86.y;
  tmpvar_89.z = tmpvar_87.y;
  highp vec3 tmpvar_90;
  tmpvar_90.x = tmpvar_85.z;
  tmpvar_90.y = tmpvar_86.z;
  tmpvar_90.z = tmpvar_87.z;
  highp mat3 tmpvar_91;
  tmpvar_91[uint(0)] = tmpvar_88;
  tmpvar_91[1u] = tmpvar_89;
  tmpvar_91[2u] = tmpvar_90;
  outputValue_1.tangentViewFragPosition = (tmpvar_91 * (matrixOut_33 * tmpvar_6).xyz);
  gl_Position = (matrixOut_15 * tmpvar_6);
  outputValue_1.extrusionDepth = clamp (tmpvar_67.x, 0.0, 1.0);
  outputValue_1.strokeWidth = ((clamp (tmpvar_67.y, 0.0, 1.0) * 2.0) - 1.0);
  outputValue_1.haloBlur = clamp (tmpvar_67.z, 0.0, 1.0);
  highp vec4 tmpvar_92;
  tmpvar_92.xyz = vec3(1.0, 1.0, 1.0);
  tmpvar_92.w = labelOptions.opacity;
  outputValue_1.extrusionColor = (tmpvar_72 * tmpvar_92);
  outputValue_1.strokeColor = tmpvar_78;
  v_texture = outputValue_1.texture;
  v_color = outputValue_1.color;
  v_extrusionColor = outputValue_1.extrusionColor;
  v_strokeColor = outputValue_1.strokeColor;
  v_haloColor = outputValue_1.haloColor;
  v_strokeWidth = outputValue_1.strokeWidth;
  v_extrusionDepth = outputValue_1.extrusionDepth;
  v_haloSize = outputValue_1.haloSize;
  v_haloBlur = outputValue_1.haloBlur;
  v_tangentViewFragPosition = outputValue_1.tangentViewFragPosition;
  v_tangent = outputValue_1.tangent;
  v_bitangent = outputValue_1.bitangent;
  v_normal = outputValue_1.normal;
//Glyph3d::glyph3d_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texture;
in mediump vec4 v_color;
in mediump vec4 v_extrusionColor;
in mediump vec4 v_strokeColor;
in mediump vec4 v_haloColor;
in mediump float v_strokeWidth;
in mediump float v_extrusionDepth;
in mediump float v_haloSize;
in mediump float v_haloBlur;
in highp vec3 v_tangentViewFragPosition;
in highp vec3 v_tangent;
in highp vec3 v_bitangent;
in highp vec3 v_normal;
uniform sampler2D textureAtlas;
out mediump vec4 output_value;
void main ()
  mediump float outerEdge_1;
  mediump float innerEdge_2;
  mediump float sampleDistance_3;
  highp vec3 tmpvar_4;
  tmpvar_4 = normalize(-(v_tangentViewFragPosition));
  highp float deltaHeight_5;
  highp float currentDepth_6;
  highp vec2 currentTextureCoords_7;
  highp vec2 deltaTextureCoords_8;
  highp float currentLayerDepth_9;
  highp float layerDepth_10;
  highp float tmpvar_11;
  tmpvar_11 = mix (8.0, 1.0, abs(tmpvar_4.z));
  highp float tmpvar_12;
  tmpvar_12 = (1.0/(tmpvar_11));
  layerDepth_10 = tmpvar_12;
  currentLayerDepth_9 = 0.0;
  highp vec2 tmpvar_13;
  tmpvar_13 = (((tmpvar_4.xy / tmpvar_4.zz) * vec2(0.015, 0.015)) / vec2(tmpvar_11));
  deltaTextureCoords_8 = tmpvar_13;
  currentTextureCoords_7 = v_texture;
  lowp vec4 tmpvar_14;
  tmpvar_14 = texture (textureAtlas, v_texture);
  highp float tmpvar_15;
  tmpvar_15 = tmpvar_14.y;
  currentDepth_6 = (1.0 - float((tmpvar_15 >= 0.505)));
  while (true) {
    if ((currentLayerDepth_9 >= currentDepth_6)) {
      break;
    };
    currentTextureCoords_7 = (currentTextureCoords_7 - deltaTextureCoords_8);
    lowp vec4 tmpvar_16;
    tmpvar_16 = texture (textureAtlas, currentTextureCoords_7);
    highp float tmpvar_17;
    tmpvar_17 = tmpvar_16.y;
    currentDepth_6 = (1.0 - float((tmpvar_17 >= 0.505)));
    currentLayerDepth_9 = (currentLayerDepth_9 + layerDepth_10);
  };
  highp int tmpvar_18;
  if ((currentLayerDepth_9 == 0.0)) {
    tmpvar_18 = 1;
  } else {
    tmpvar_18 = 0;
  };
  deltaTextureCoords_8 = (tmpvar_13 * vec2(0.5, 0.5));
  highp float tmpvar_19;
  tmpvar_19 = (tmpvar_12 * 0.5);
  currentTextureCoords_7 = (currentTextureCoords_7 + deltaTextureCoords_8);
  currentLayerDepth_9 = (currentLayerDepth_9 - tmpvar_19);
  deltaTextureCoords_8 = (deltaTextureCoords_8 * vec2(0.5, 0.5));
  deltaHeight_5 = (tmpvar_19 * 0.5);
  highp float tmpvar_20;
  lowp vec4 tmpvar_21;
  tmpvar_21 = texture (textureAtlas, currentTextureCoords_7);
  highp float tmpvar_22;
  tmpvar_22 = tmpvar_21.y;
  tmpvar_20 = (1.0 - float((tmpvar_22 >= 0.505)));
  currentDepth_6 = tmpvar_20;
  if ((tmpvar_20 > currentLayerDepth_9)) {
    currentTextureCoords_7 = (currentTextureCoords_7 - deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 + deltaHeight_5);
  } else {
    currentTextureCoords_7 = (currentTextureCoords_7 + deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 - deltaHeight_5);
  };
  deltaTextureCoords_8 = (deltaTextureCoords_8 * vec2(0.5, 0.5));
  deltaHeight_5 = (deltaHeight_5 * 0.5);
  highp float tmpvar_23;
  lowp vec4 tmpvar_24;
  tmpvar_24 = texture (textureAtlas, currentTextureCoords_7);
  highp float tmpvar_25;
  tmpvar_25 = tmpvar_24.y;
  tmpvar_23 = (1.0 - float((tmpvar_25 >= 0.505)));
  currentDepth_6 = tmpvar_23;
  if ((tmpvar_23 > currentLayerDepth_9)) {
    currentTextureCoords_7 = (currentTextureCoords_7 - deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 + deltaHeight_5);
  } else {
    currentTextureCoords_7 = (currentTextureCoords_7 + deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 - deltaHeight_5);
  };
  deltaTextureCoords_8 = (deltaTextureCoords_8 * vec2(0.5, 0.5));
  deltaHeight_5 = (deltaHeight_5 * 0.5);
  highp float tmpvar_26;
  lowp vec4 tmpvar_27;
  tmpvar_27 = texture (textureAtlas, currentTextureCoords_7);
  highp float tmpvar_28;
  tmpvar_28 = tmpvar_27.y;
  tmpvar_26 = (1.0 - float((tmpvar_28 >= 0.505)));
  currentDepth_6 = tmpvar_26;
  if ((tmpvar_26 > currentLayerDepth_9)) {
    currentTextureCoords_7 = (currentTextureCoords_7 - deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 + deltaHeight_5);
  } else {
    currentTextureCoords_7 = (currentTextureCoords_7 + deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 - deltaHeight_5);
  };
  deltaTextureCoords_8 = (deltaTextureCoords_8 * vec2(0.5, 0.5));
  deltaHeight_5 = (deltaHeight_5 * 0.5);
  highp float tmpvar_29;
  lowp vec4 tmpvar_30;
  tmpvar_30 = texture (textureAtlas, currentTextureCoords_7);
  highp float tmpvar_31;
  tmpvar_31 = tmpvar_30.y;
  tmpvar_29 = (1.0 - float((tmpvar_31 >= 0.505)));
  currentDepth_6 = tmpvar_29;
  if ((tmpvar_29 > currentLayerDepth_9)) {
    currentTextureCoords_7 = (currentTextureCoords_7 - deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 + deltaHeight_5);
  } else {
    currentTextureCoords_7 = (currentTextureCoords_7 + deltaTextureCoords_8);
    currentLayerDepth_9 = (currentLayerDepth_9 - deltaHeight_5);
  };
  lowp float tmpvar_32;
  tmpvar_32 = texture (textureAtlas, currentTextureCoords_7).y;
  sampleDistance_3 = tmpvar_32;
  mediump vec3 tmpvar_33;
  if (bool(tmpvar_18)) {
    tmpvar_33 = v_color.xyz;
  } else {
    tmpvar_33 = v_extrusionColor.xyz;
  };
  mediump float tmpvar_34;
  if (bool(tmpvar_18)) {
    tmpvar_34 = v_color.w;
  } else {
    tmpvar_34 = v_extrusionColor.w;
  };
  mediump vec2 tmpvar_35;
  tmpvar_35.x = dFdx(sampleDistance_3);
  tmpvar_35.y = dFdy(sampleDistance_3);
  mediump float tmpvar_36;
  tmpvar_36 = (0.75 * sqrt(dot (tmpvar_35, tmpvar_35)));
  highp float tmpvar_37;
  tmpvar_37 = (0.5 - tmpvar_36);
  innerEdge_2 = tmpvar_37;
  highp float tmpvar_38;
  tmpvar_38 = (0.5 + tmpvar_36);
  outerEdge_1 = tmpvar_38;
  mediump float tmpvar_39;
  tmpvar_39 = clamp (((sampleDistance_3 - innerEdge_2) / (outerEdge_1 - innerEdge_2)), 0.0, 1.0);
  mediump vec4 tmpvar_40;
  tmpvar_40.xyz = tmpvar_33;
  tmpvar_40.w = (tmpvar_34 * (tmpvar_39 * (tmpvar_39 * 
    (3.0 - (2.0 * tmpvar_39))
  )));
  output_value = tmpvar_40;
//Glyph3d::glyph3d_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSizeB {
  highp int width;
  highp int height;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct Vertex3dOut {
  highp vec2 texture;
  mediump vec4 color;
  mediump vec4 extrusionColor;
  mediump vec4 strokeColor;
  mediump vec4 haloColor;
  mediump float strokeWidth;
  mediump float extrusionDepth;
  mediump float haloSize;
  mediump float haloBlur;
  highp vec3 tangentViewFragPosition;
  highp vec3 tangent;
  highp vec3 bitangent;
  highp vec3 normal;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform Options labelOptions;
uniform DeviceBufferTextureSizeB byteBufferTextureSize;
uniform sampler2D byteBufferTexture;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out mediump vec4 v_color;
out mediump vec4 v_extrusionColor;
out mediump vec4 v_strokeColor;
out mediump vec4 v_haloColor;
out mediump float v_strokeWidth;
out mediump float v_extrusionDepth;
out mediump float v_haloSize;
out mediump float v_haloBlur;
out highp vec3 v_tangentViewFragPosition;
out highp vec3 v_tangent;
out highp vec3 v_bitangent;
out highp vec3 v_normal;
void main ()
  Vertex3dOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.position = vertex_attributes_position;
  vertex_attributes_2.texture = vertex_attributes_texture;
  vertex_attributes_2.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_2.color = vertex_attributes_color;
  vertex_attributes_2.haloColor = vertex_attributes_haloColor;
  vertex_attributes_2.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_2.tangent = vertex_attributes_tangent;
  vertex_attributes_2.bitangent = vertex_attributes_bitangent;
  Vertex3dOut outputValue_3;
  VertexOut outputValue_4;
  highp float alpha_5;
  alpha_5 = ((vertex_attributes_2.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_6;
  tmpvar_6.zw = vec2(0.0, 1.0);
  tmpvar_6.x = vertex_attributes_2.position.x;
  tmpvar_6.y = vertex_attributes_2.position.y;
  outputValue_4.texture = vertex_attributes_2.texture;
  highp vec4 tmpvar_7;
  tmpvar_7.x = vertex_attributes_2.color.x;
  tmpvar_7.y = vertex_attributes_2.color.y;
  tmpvar_7.z = vertex_attributes_2.color.z;
  tmpvar_7.w = (vertex_attributes_2.color.w * alpha_5);
  outputValue_4.color = tmpvar_7;
  highp vec4 tmpvar_8;
  tmpvar_8.x = vertex_attributes_2.haloColor.x;
  tmpvar_8.y = vertex_attributes_2.haloColor.y;
  tmpvar_8.z = vertex_attributes_2.haloColor.z;
  tmpvar_8.w = (vertex_attributes_2.haloColor.w * alpha_5);
  outputValue_4.haloColor = tmpvar_8;
  outputValue_4.tangent = vertex_attributes_2.tangent;
  outputValue_4.bitangent = vertex_attributes_2.bitangent;
  outputValue_4.haloSizeInPixels = ((vertex_attributes_2.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  outputValue_3.texture = outputValue_4.texture;
  outputValue_3.color = outputValue_4.color;
  highp vec3 tmpvar_9;
  tmpvar_9.z = 0.0;
  tmpvar_9.xy = outputValue_4.tangent;
  outputValue_3.tangent = tmpvar_9;
  highp vec3 tmpvar_10;
  tmpvar_10.z = 0.0;
  tmpvar_10.xy = outputValue_4.bitangent;
  outputValue_3.bitangent = tmpvar_10;
  highp vec3 a_11;
  a_11 = outputValue_3.tangent;
  highp vec3 b_12;
  b_12 = outputValue_3.bitangent;
  outputValue_3.normal = normalize(((a_11.yzx * b_12.zxy) - (a_11.zxy * b_12.yzx)));
  outputValue_3.haloSize = outputValue_4.haloSizeInPixels;
  outputValue_3.haloColor = outputValue_4.haloColor;
  outputValue_1 = outputValue_3;
  highp int tmpvar_13;
  tmpvar_13 = int((65535.0 * vertex_attributes_2.deviceBufferIndex.x));
  highp int tmpvar_14;
  tmpvar_14 = int((65535.0 * vertex_attributes_2.deviceBufferIndex.y));
  highp mat4 matrixOut_15;
  highp vec2 tmpvar_16;
  tmpvar_16.x = float(floatBufferTextureSize.width);
  tmpvar_16.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_17;
  tmpvar_17 = (1.0/(tmpvar_16));
  highp int textureWidth_18;
  textureWidth_18 = floatBufferTextureSize.width;
  highp int tmpvar_19;
  tmpvar_19 = (tmpvar_13 / textureWidth_18);
  highp float tmpvar_20;
  tmpvar_20 = ((float(
    (tmpvar_13 - (tmpvar_19 * textureWidth_18))
  ) + 0.5) / float(textureWidth_18));
  highp vec2 tmpvar_21;
  tmpvar_21.x = tmpvar_20;
  tmpvar_21.y = ((float(tmpvar_19) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_22;
  tmpvar_22 = texture (floatBufferTexture, tmpvar_21);
  matrixOut_15[0] = tmpvar_22;
  highp vec2 uvCoordinate_23;
  uvCoordinate_23.y = tmpvar_21.y;
  uvCoordinate_23.x = (tmpvar_20 + tmpvar_17.x);
  highp vec2 tmpvar_24;
  tmpvar_24.x = -1.0;
  tmpvar_24.y = tmpvar_17.y;
  uvCoordinate_23 = (uvCoordinate_23 + (vec2(float(
    (uvCoordinate_23.x >= 1.0)
  )) * tmpvar_24));
  lowp vec4 tmpvar_25;
  tmpvar_25 = texture (floatBufferTexture, uvCoordinate_23);
  matrixOut_15[1] = tmpvar_25;
  highp vec2 uvCoordinate_26;
  uvCoordinate_26.y = tmpvar_21.y;
  uvCoordinate_26.x = (tmpvar_20 + (tmpvar_17.x * 2.0));
  highp vec2 tmpvar_27;
  tmpvar_27.x = -1.0;
  tmpvar_27.y = tmpvar_17.y;
  uvCoordinate_26 = (uvCoordinate_26 + (vec2(float(
    (uvCoordinate_26.x >= 1.0)
  )) * tmpvar_27));
  lowp vec4 tmpvar_28;
  tmpvar_28 = texture (floatBufferTexture, uvCoordinate_26);
  matrixOut_15[2] = tmpvar_28;
  highp vec2 uvCoordinate_29;
  uvCoordinate_29.y = tmpvar_21.y;
  uvCoordinate_29.x = (tmpvar_20 + (tmpvar_17.x * 3.0));
  highp vec2 tmpvar_30;
  tmpvar_30.x = -1.0;
  tmpvar_30.y = tmpvar_17.y;
  uvCoordinate_29 = (uvCoordinate_29 + (vec2(float(
    (uvCoordinate_29.x >= 1.0)
  )) * tmpvar_30));
  lowp vec4 tmpvar_31;
  tmpvar_31 = texture (floatBufferTexture, uvCoordinate_29);
  matrixOut_15[3] = tmpvar_31;
  highp int elementIndex_32;
  elementIndex_32 = (tmpvar_13 + 4);
  highp mat4 matrixOut_33;
  highp vec2 tmpvar_34;
  tmpvar_34.x = float(floatBufferTextureSize.width);
  tmpvar_34.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_35;
  tmpvar_35 = (1.0/(tmpvar_34));
  highp int textureWidth_36;
  textureWidth_36 = floatBufferTextureSize.width;
  highp int tmpvar_37;
  tmpvar_37 = (elementIndex_32 / textureWidth_36);
  highp float tmpvar_38;
  tmpvar_38 = ((float(
    (elementIndex_32 - (tmpvar_37 * textureWidth_36))
  ) + 0.5) / float(textureWidth_36));
  highp vec2 tmpvar_39;
  tmpvar_39.x = tmpvar_38;
  tmpvar_39.y = ((float(tmpvar_37) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_40;
  tmpvar_40 = texture (floatBufferTexture, tmpvar_39);
  matrixOut_33[0] = tmpvar_40;
  highp vec2 uvCoordinate_41;
  uvCoordinate_41.y = tmpvar_39.y;
  uvCoordinate_41.x = (tmpvar_38 + tmpvar_35.x);
  highp vec2 tmpvar_42;
  tmpvar_42.x = -1.0;
  tmpvar_42.y = tmpvar_35.y;
  uvCoordinate_41 = (uvCoordinate_41 + (vec2(float(
    (uvCoordinate_41.x >= 1.0)
  )) * tmpvar_42));
  lowp vec4 tmpvar_43;
  tmpvar_43 = texture (floatBufferTexture, uvCoordinate_41);
  matrixOut_33[1] = tmpvar_43;
  highp vec2 uvCoordinate_44;
  uvCoordinate_44.y = tmpvar_39.y;
  uvCoordinate_44.x = (tmpvar_38 + (tmpvar_35.x * 2.0));
  highp vec2 tmpvar_45;
  tmpvar_45.x = -1.0;
  tmpvar_45.y = tmpvar_35.y;
  uvCoordinate_44 = (uvCoordinate_44 + (vec2(float(
    (uvCoordinate_44.x >= 1.0)
  )) * tmpvar_45));
  lowp vec4 tmpvar_46;
  tmpvar_46 = texture (floatBufferTexture, uvCoordinate_44);
  matrixOut_33[2] = tmpvar_46;
  highp vec2 uvCoordinate_47;
  uvCoordinate_47.y = tmpvar_39.y;
  uvCoordinate_47.x = (tmpvar_38 + (tmpvar_35.x * 3.0));
  highp vec2 tmpvar_48;
  tmpvar_48.x = -1.0;
  tmpvar_48.y = tmpvar_35.y;
  uvCoordinate_47 = (uvCoordinate_47 + (vec2(float(
    (uvCoordinate_47.x >= 1.0)
  )) * tmpvar_48));
  lowp vec4 tmpvar_49;
  tmpvar_49 = texture (floatBufferTexture, uvCoordinate_47);
  matrixOut_33[3] = tmpvar_49;
  highp int elementIndex_50;
  elementIndex_50 = (tmpvar_13 + 8);
  highp vec4 matrixOut_0_51;
  highp vec4 matrixOut_1_52;
  highp vec4 matrixOut_2_53;
  highp vec2 tmpvar_54;
  tmpvar_54.x = float(floatBufferTextureSize.width);
  tmpvar_54.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_55;
  tmpvar_55 = (1.0/(tmpvar_54));
  highp int textureWidth_56;
  textureWidth_56 = floatBufferTextureSize.width;
  highp int tmpvar_57;
  tmpvar_57 = (elementIndex_50 / textureWidth_56);
  highp float tmpvar_58;
  tmpvar_58 = ((float(
    (elementIndex_50 - (tmpvar_57 * textureWidth_56))
  ) + 0.5) / float(textureWidth_56));
  highp vec2 tmpvar_59;
  tmpvar_59.x = tmpvar_58;
  tmpvar_59.y = ((float(tmpvar_57) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_60;
  tmpvar_60 = texture (floatBufferTexture, tmpvar_59);
  matrixOut_0_51 = tmpvar_60;
  highp vec2 uvCoordinate_61;
  uvCoordinate_61.y = tmpvar_59.y;
  uvCoordinate_61.x = (tmpvar_58 + tmpvar_55.x);
  highp vec2 tmpvar_62;
  tmpvar_62.x = -1.0;
  tmpvar_62.y = tmpvar_55.y;
  uvCoordinate_61 = (uvCoordinate_61 + (vec2(float(
    (uvCoordinate_61.x >= 1.0)
  )) * tmpvar_62));
  lowp vec4 tmpvar_63;
  tmpvar_63 = texture (floatBufferTexture, uvCoordinate_61);
  matrixOut_1_52 = tmpvar_63;
  highp vec2 uvCoordinate_64;
  uvCoordinate_64.y = tmpvar_59.y;
  uvCoordinate_64.x = (tmpvar_58 + (tmpvar_55.x * 2.0));
  highp vec2 tmpvar_65;
  tmpvar_65.x = -1.0;
  tmpvar_65.y = tmpvar_55.y;
  uvCoordinate_64 = (uvCoordinate_64 + (vec2(float(
    (uvCoordinate_64.x >= 1.0)
  )) * tmpvar_65));
  lowp vec4 tmpvar_66;
  tmpvar_66 = texture (floatBufferTexture, uvCoordinate_64);
  matrixOut_2_53 = tmpvar_66;
  mediump vec4 tmpvar_67;
  highp int textureWidth_68;
  textureWidth_68 = byteBufferTextureSize.width;
  highp int tmpvar_69;
  tmpvar_69 = (tmpvar_14 / textureWidth_68);
  highp vec2 tmpvar_70;
  tmpvar_70.x = ((float(
    (tmpvar_14 - (tmpvar_69 * textureWidth_68))
  ) + 0.5) / float(textureWidth_68));
  tmpvar_70.y = ((float(tmpvar_69) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_71;
  tmpvar_71 = texture (byteBufferTexture, tmpvar_70);
  tmpvar_67 = tmpvar_71;
  mediump vec4 tmpvar_72;
  highp int elementIndex_73;
  elementIndex_73 = (tmpvar_14 + 1);
  highp int textureWidth_74;
  textureWidth_74 = byteBufferTextureSize.width;
  highp int tmpvar_75;
  tmpvar_75 = (elementIndex_73 / textureWidth_74);
  highp vec2 tmpvar_76;
  tmpvar_76.x = ((float(
    (elementIndex_73 - (tmpvar_75 * textureWidth_74))
  ) + 0.5) / float(textureWidth_74));
  tmpvar_76.y = ((float(tmpvar_75) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_77;
  tmpvar_77 = texture (byteBufferTexture, tmpvar_76);
  tmpvar_72 = tmpvar_77;
  mediump vec4 tmpvar_78;
  highp int elementIndex_79;
  elementIndex_79 = (tmpvar_14 + 2);
  highp int textureWidth_80;
  textureWidth_80 = byteBufferTextureSize.width;
  highp int tmpvar_81;
  tmpvar_81 = (elementIndex_79 / textureWidth_80);
  highp vec2 tmpvar_82;
  tmpvar_82.x = ((float(
    (elementIndex_79 - (tmpvar_81 * textureWidth_80))
  ) + 0.5) / float(textureWidth_80));
  tmpvar_82.y = ((float(tmpvar_81) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_83;
  tmpvar_83 = texture (byteBufferTexture, tmpvar_82);
  tmpvar_78 = tmpvar_83;
  highp mat3 tmpvar_84;
  tmpvar_84[uint(0)] = matrixOut_0_51.xyz;
  tmpvar_84[1u] = matrixOut_1_52.xyz;
  tmpvar_84[2u] = matrixOut_2_53.xyz;
  highp vec3 tmpvar_85;
  highp vec3 tmpvar_86;
  highp vec3 tmpvar_87;
  tmpvar_85 = normalize((tmpvar_84 * outputValue_3.tangent));
  tmpvar_86 = normalize((tmpvar_84 * outputValue_3.bitangent));
  tmpvar_87 = normalize((tmpvar_84 * outputValue_3.normal));
  highp vec3 tmpvar_88;
  tmpvar_88.x = tmpvar_85.x;
  tmpvar_88.y = tmpvar_86.x;
  tmpvar_88.z = tmpvar_87.x;
  highp vec3 tmpvar_89;
  tmpvar_89.x = tmpvar_85.y;
  tmpvar_89.y = tmpvar_86.y;
  tmpvar_89.z = tmpvar_87.y;
  highp vec3 tmpvar_90;
  tmpvar_90.x = tmpvar_85.z;
  tmpvar_90.y = tmpvar_86.z;
  tmpvar_90.z = tmpvar_87.z;
  highp mat3 tmpvar_91;
  tmpvar_91[uint(0)] = tmpvar_88;
  tmpvar_91[1u] = tmpvar_89;
  tmpvar_91[2u] = tmpvar_90;
  outputValue_1.tangentViewFragPosition = (tmpvar_91 * (matrixOut_33 * tmpvar_6).xyz);
  gl_Position = (matrixOut_15 * tmpvar_6);
  outputValue_1.extrusionDepth = clamp (tmpvar_67.x, 0.0, 1.0);
  outputValue_1.strokeWidth = ((clamp (tmpvar_67.y, 0.0, 1.0) * 2.0) - 1.0);
  outputValue_1.haloBlur = clamp (tmpvar_67.z, 0.0, 1.0);
  highp vec4 tmpvar_92;
  tmpvar_92.xyz = vec3(1.0, 1.0, 1.0);
  tmpvar_92.w = labelOptions.opacity;
  outputValue_1.extrusionColor = (tmpvar_72 * tmpvar_92);
  outputValue_1.strokeColor = tmpvar_78;
  v_texture = outputValue_1.texture;
  v_color = outputValue_1.color;
  v_extrusionColor = outputValue_1.extrusionColor;
  v_strokeColor = outputValue_1.strokeColor;
  v_haloColor = outputValue_1.haloColor;
  v_strokeWidth = outputValue_1.strokeWidth;
  v_extrusionDepth = outputValue_1.extrusionDepth;
  v_haloSize = outputValue_1.haloSize;
  v_haloBlur = outputValue_1.haloBlur;
  v_tangentViewFragPosition = outputValue_1.tangentViewFragPosition;
  v_tangent = outputValue_1.tangent;
  v_bitangent = outputValue_1.bitangent;
  v_normal = outputValue_1.normal;
//Glyph3d::glyph3dLowPrecisionHalo_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in mediump vec4 v_color;
in mediump vec4 v_extrusionColor;
in mediump vec4 v_strokeColor;
in mediump vec4 v_haloColor;
in mediump float v_strokeWidth;
in mediump float v_extrusionDepth;
in mediump float v_haloSize;
in mediump float v_haloBlur;
in highp vec3 v_tangentViewFragPosition;
in highp vec3 v_tangent;
in highp vec3 v_bitangent;
in highp vec3 v_normal;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
out lowp vec4 output_value;
void main ()
  mediump float extrusionDistance_1;
  mediump float sampleDistance_2;
  mediump float haloEdge_3;
  mediump float strokeEdge_4;
  mediump float extrusionDepthInPixels_5;
  mediump float strokeWidthInPixels_6;
  mediump float tmpvar_7;
  tmpvar_7 = (v_haloSize / 2.0);
  highp float tmpvar_8;
  tmpvar_8 = ((v_strokeWidth * float(glyphOptions.maxStrokeWidth)) / 2.0);
  strokeWidthInPixels_6 = tmpvar_8;
  highp float tmpvar_9;
  tmpvar_9 = (v_extrusionDepth * float(glyphOptions.maxExtrusionDepth));
  extrusionDepthInPixels_5 = tmpvar_9;
  mediump float tmpvar_10;
  tmpvar_10 = (v_haloBlur * 0.5);
  highp float tmpvar_11;
  tmpvar_11 = clamp (((
    (-(strokeWidthInPixels_6) / float(glyphOptions.maxHaloDistanceStored))
   + 1.0) / 2.0), 0.0, 1.0);
  strokeEdge_4 = tmpvar_11;
  mediump float tmpvar_12;
  tmpvar_12 = min (0.5, strokeEdge_4);
  highp float tmpvar_13;
  tmpvar_13 = (tmpvar_12 - clamp ((tmpvar_7 / 
    float(glyphOptions.maxHaloDistanceStored)
  ), 0.0, 1.0));
  haloEdge_3 = tmpvar_13;
  lowp vec2 tmpvar_14;
  tmpvar_14 = vec2(textureSize (textureAtlas, 0));
  lowp float tmpvar_15;
  tmpvar_15 = texture (textureAtlas, v_texture).y;
  sampleDistance_2 = tmpvar_15;
  highp vec2 P_16;
  P_16 = (v_texture + ((
    normalize(v_tangentViewFragPosition)
  .xy * vec2(extrusionDepthInPixels_5)) / tmpvar_14));
  lowp float tmpvar_17;
  tmpvar_17 = texture (textureAtlas, P_16).y;
  extrusionDistance_1 = tmpvar_17;
  mediump float tmpvar_18;
  tmpvar_18 = max ((haloEdge_3 - tmpvar_10), 0.0);
  mediump float tmpvar_19;
  tmpvar_19 = clamp (((
    max (sampleDistance_2, extrusionDistance_1)
   - tmpvar_18) / (
    min (1.0, (tmpvar_12 + tmpvar_10))
   - tmpvar_18)), 0.0, 1.0);
  mediump vec4 tmpvar_20;
  tmpvar_20.xyz = v_haloColor.xyz;
  tmpvar_20.w = (v_haloColor.w * (tmpvar_19 * (tmpvar_19 * 
    (3.0 - (2.0 * tmpvar_19))
  )));
  output_value = tmpvar_20;
//Glyph3d::glyph3d_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSizeB {
  highp int width;
  highp int height;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct Vertex3dOut {
  highp vec2 texture;
  mediump vec4 color;
  mediump vec4 extrusionColor;
  mediump vec4 strokeColor;
  mediump vec4 haloColor;
  mediump float strokeWidth;
  mediump float extrusionDepth;
  mediump float haloSize;
  mediump float haloBlur;
  highp vec3 tangentViewFragPosition;
  highp vec3 tangent;
  highp vec3 bitangent;
  highp vec3 normal;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform Options labelOptions;
uniform DeviceBufferTextureSizeB byteBufferTextureSize;
uniform sampler2D byteBufferTexture;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out mediump vec4 v_color;
out mediump vec4 v_extrusionColor;
out mediump vec4 v_strokeColor;
out mediump vec4 v_haloColor;
out mediump float v_strokeWidth;
out mediump float v_extrusionDepth;
out mediump float v_haloSize;
out mediump float v_haloBlur;
out highp vec3 v_tangentViewFragPosition;
out highp vec3 v_tangent;
out highp vec3 v_bitangent;
out highp vec3 v_normal;
void main ()
  Vertex3dOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.position = vertex_attributes_position;
  vertex_attributes_2.texture = vertex_attributes_texture;
  vertex_attributes_2.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_2.color = vertex_attributes_color;
  vertex_attributes_2.haloColor = vertex_attributes_haloColor;
  vertex_attributes_2.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_2.tangent = vertex_attributes_tangent;
  vertex_attributes_2.bitangent = vertex_attributes_bitangent;
  Vertex3dOut outputValue_3;
  VertexOut outputValue_4;
  highp float alpha_5;
  alpha_5 = ((vertex_attributes_2.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_6;
  tmpvar_6.zw = vec2(0.0, 1.0);
  tmpvar_6.x = vertex_attributes_2.position.x;
  tmpvar_6.y = vertex_attributes_2.position.y;
  outputValue_4.texture = vertex_attributes_2.texture;
  highp vec4 tmpvar_7;
  tmpvar_7.x = vertex_attributes_2.color.x;
  tmpvar_7.y = vertex_attributes_2.color.y;
  tmpvar_7.z = vertex_attributes_2.color.z;
  tmpvar_7.w = (vertex_attributes_2.color.w * alpha_5);
  outputValue_4.color = tmpvar_7;
  highp vec4 tmpvar_8;
  tmpvar_8.x = vertex_attributes_2.haloColor.x;
  tmpvar_8.y = vertex_attributes_2.haloColor.y;
  tmpvar_8.z = vertex_attributes_2.haloColor.z;
  tmpvar_8.w = (vertex_attributes_2.haloColor.w * alpha_5);
  outputValue_4.haloColor = tmpvar_8;
  outputValue_4.tangent = vertex_attributes_2.tangent;
  outputValue_4.bitangent = vertex_attributes_2.bitangent;
  outputValue_4.haloSizeInPixels = ((vertex_attributes_2.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  outputValue_3.texture = outputValue_4.texture;
  outputValue_3.color = outputValue_4.color;
  highp vec3 tmpvar_9;
  tmpvar_9.z = 0.0;
  tmpvar_9.xy = outputValue_4.tangent;
  outputValue_3.tangent = tmpvar_9;
  highp vec3 tmpvar_10;
  tmpvar_10.z = 0.0;
  tmpvar_10.xy = outputValue_4.bitangent;
  outputValue_3.bitangent = tmpvar_10;
  highp vec3 a_11;
  a_11 = outputValue_3.tangent;
  highp vec3 b_12;
  b_12 = outputValue_3.bitangent;
  outputValue_3.normal = normalize(((a_11.yzx * b_12.zxy) - (a_11.zxy * b_12.yzx)));
  outputValue_3.haloSize = outputValue_4.haloSizeInPixels;
  outputValue_3.haloColor = outputValue_4.haloColor;
  outputValue_1 = outputValue_3;
  highp int tmpvar_13;
  tmpvar_13 = int((65535.0 * vertex_attributes_2.deviceBufferIndex.x));
  highp int tmpvar_14;
  tmpvar_14 = int((65535.0 * vertex_attributes_2.deviceBufferIndex.y));
  highp mat4 matrixOut_15;
  highp vec2 tmpvar_16;
  tmpvar_16.x = float(floatBufferTextureSize.width);
  tmpvar_16.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_17;
  tmpvar_17 = (1.0/(tmpvar_16));
  highp int textureWidth_18;
  textureWidth_18 = floatBufferTextureSize.width;
  highp int tmpvar_19;
  tmpvar_19 = (tmpvar_13 / textureWidth_18);
  highp float tmpvar_20;
  tmpvar_20 = ((float(
    (tmpvar_13 - (tmpvar_19 * textureWidth_18))
  ) + 0.5) / float(textureWidth_18));
  highp vec2 tmpvar_21;
  tmpvar_21.x = tmpvar_20;
  tmpvar_21.y = ((float(tmpvar_19) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_22;
  tmpvar_22 = texture (floatBufferTexture, tmpvar_21);
  matrixOut_15[0] = tmpvar_22;
  highp vec2 uvCoordinate_23;
  uvCoordinate_23.y = tmpvar_21.y;
  uvCoordinate_23.x = (tmpvar_20 + tmpvar_17.x);
  highp vec2 tmpvar_24;
  tmpvar_24.x = -1.0;
  tmpvar_24.y = tmpvar_17.y;
  uvCoordinate_23 = (uvCoordinate_23 + (vec2(float(
    (uvCoordinate_23.x >= 1.0)
  )) * tmpvar_24));
  lowp vec4 tmpvar_25;
  tmpvar_25 = texture (floatBufferTexture, uvCoordinate_23);
  matrixOut_15[1] = tmpvar_25;
  highp vec2 uvCoordinate_26;
  uvCoordinate_26.y = tmpvar_21.y;
  uvCoordinate_26.x = (tmpvar_20 + (tmpvar_17.x * 2.0));
  highp vec2 tmpvar_27;
  tmpvar_27.x = -1.0;
  tmpvar_27.y = tmpvar_17.y;
  uvCoordinate_26 = (uvCoordinate_26 + (vec2(float(
    (uvCoordinate_26.x >= 1.0)
  )) * tmpvar_27));
  lowp vec4 tmpvar_28;
  tmpvar_28 = texture (floatBufferTexture, uvCoordinate_26);
  matrixOut_15[2] = tmpvar_28;
  highp vec2 uvCoordinate_29;
  uvCoordinate_29.y = tmpvar_21.y;
  uvCoordinate_29.x = (tmpvar_20 + (tmpvar_17.x * 3.0));
  highp vec2 tmpvar_30;
  tmpvar_30.x = -1.0;
  tmpvar_30.y = tmpvar_17.y;
  uvCoordinate_29 = (uvCoordinate_29 + (vec2(float(
    (uvCoordinate_29.x >= 1.0)
  )) * tmpvar_30));
  lowp vec4 tmpvar_31;
  tmpvar_31 = texture (floatBufferTexture, uvCoordinate_29);
  matrixOut_15[3] = tmpvar_31;
  highp int elementIndex_32;
  elementIndex_32 = (tmpvar_13 + 4);
  highp mat4 matrixOut_33;
  highp vec2 tmpvar_34;
  tmpvar_34.x = float(floatBufferTextureSize.width);
  tmpvar_34.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_35;
  tmpvar_35 = (1.0/(tmpvar_34));
  highp int textureWidth_36;
  textureWidth_36 = floatBufferTextureSize.width;
  highp int tmpvar_37;
  tmpvar_37 = (elementIndex_32 / textureWidth_36);
  highp float tmpvar_38;
  tmpvar_38 = ((float(
    (elementIndex_32 - (tmpvar_37 * textureWidth_36))
  ) + 0.5) / float(textureWidth_36));
  highp vec2 tmpvar_39;
  tmpvar_39.x = tmpvar_38;
  tmpvar_39.y = ((float(tmpvar_37) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_40;
  tmpvar_40 = texture (floatBufferTexture, tmpvar_39);
  matrixOut_33[0] = tmpvar_40;
  highp vec2 uvCoordinate_41;
  uvCoordinate_41.y = tmpvar_39.y;
  uvCoordinate_41.x = (tmpvar_38 + tmpvar_35.x);
  highp vec2 tmpvar_42;
  tmpvar_42.x = -1.0;
  tmpvar_42.y = tmpvar_35.y;
  uvCoordinate_41 = (uvCoordinate_41 + (vec2(float(
    (uvCoordinate_41.x >= 1.0)
  )) * tmpvar_42));
  lowp vec4 tmpvar_43;
  tmpvar_43 = texture (floatBufferTexture, uvCoordinate_41);
  matrixOut_33[1] = tmpvar_43;
  highp vec2 uvCoordinate_44;
  uvCoordinate_44.y = tmpvar_39.y;
  uvCoordinate_44.x = (tmpvar_38 + (tmpvar_35.x * 2.0));
  highp vec2 tmpvar_45;
  tmpvar_45.x = -1.0;
  tmpvar_45.y = tmpvar_35.y;
  uvCoordinate_44 = (uvCoordinate_44 + (vec2(float(
    (uvCoordinate_44.x >= 1.0)
  )) * tmpvar_45));
  lowp vec4 tmpvar_46;
  tmpvar_46 = texture (floatBufferTexture, uvCoordinate_44);
  matrixOut_33[2] = tmpvar_46;
  highp vec2 uvCoordinate_47;
  uvCoordinate_47.y = tmpvar_39.y;
  uvCoordinate_47.x = (tmpvar_38 + (tmpvar_35.x * 3.0));
  highp vec2 tmpvar_48;
  tmpvar_48.x = -1.0;
  tmpvar_48.y = tmpvar_35.y;
  uvCoordinate_47 = (uvCoordinate_47 + (vec2(float(
    (uvCoordinate_47.x >= 1.0)
  )) * tmpvar_48));
  lowp vec4 tmpvar_49;
  tmpvar_49 = texture (floatBufferTexture, uvCoordinate_47);
  matrixOut_33[3] = tmpvar_49;
  highp int elementIndex_50;
  elementIndex_50 = (tmpvar_13 + 8);
  highp vec4 matrixOut_0_51;
  highp vec4 matrixOut_1_52;
  highp vec4 matrixOut_2_53;
  highp vec2 tmpvar_54;
  tmpvar_54.x = float(floatBufferTextureSize.width);
  tmpvar_54.y = float(floatBufferTextureSize.height);
  highp vec2 tmpvar_55;
  tmpvar_55 = (1.0/(tmpvar_54));
  highp int textureWidth_56;
  textureWidth_56 = floatBufferTextureSize.width;
  highp int tmpvar_57;
  tmpvar_57 = (elementIndex_50 / textureWidth_56);
  highp float tmpvar_58;
  tmpvar_58 = ((float(
    (elementIndex_50 - (tmpvar_57 * textureWidth_56))
  ) + 0.5) / float(textureWidth_56));
  highp vec2 tmpvar_59;
  tmpvar_59.x = tmpvar_58;
  tmpvar_59.y = ((float(tmpvar_57) + 0.5) / float(floatBufferTextureSize.height));
  lowp vec4 tmpvar_60;
  tmpvar_60 = texture (floatBufferTexture, tmpvar_59);
  matrixOut_0_51 = tmpvar_60;
  highp vec2 uvCoordinate_61;
  uvCoordinate_61.y = tmpvar_59.y;
  uvCoordinate_61.x = (tmpvar_58 + tmpvar_55.x);
  highp vec2 tmpvar_62;
  tmpvar_62.x = -1.0;
  tmpvar_62.y = tmpvar_55.y;
  uvCoordinate_61 = (uvCoordinate_61 + (vec2(float(
    (uvCoordinate_61.x >= 1.0)
  )) * tmpvar_62));
  lowp vec4 tmpvar_63;
  tmpvar_63 = texture (floatBufferTexture, uvCoordinate_61);
  matrixOut_1_52 = tmpvar_63;
  highp vec2 uvCoordinate_64;
  uvCoordinate_64.y = tmpvar_59.y;
  uvCoordinate_64.x = (tmpvar_58 + (tmpvar_55.x * 2.0));
  highp vec2 tmpvar_65;
  tmpvar_65.x = -1.0;
  tmpvar_65.y = tmpvar_55.y;
  uvCoordinate_64 = (uvCoordinate_64 + (vec2(float(
    (uvCoordinate_64.x >= 1.0)
  )) * tmpvar_65));
  lowp vec4 tmpvar_66;
  tmpvar_66 = texture (floatBufferTexture, uvCoordinate_64);
  matrixOut_2_53 = tmpvar_66;
  mediump vec4 tmpvar_67;
  highp int textureWidth_68;
  textureWidth_68 = byteBufferTextureSize.width;
  highp int tmpvar_69;
  tmpvar_69 = (tmpvar_14 / textureWidth_68);
  highp vec2 tmpvar_70;
  tmpvar_70.x = ((float(
    (tmpvar_14 - (tmpvar_69 * textureWidth_68))
  ) + 0.5) / float(textureWidth_68));
  tmpvar_70.y = ((float(tmpvar_69) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_71;
  tmpvar_71 = texture (byteBufferTexture, tmpvar_70);
  tmpvar_67 = tmpvar_71;
  mediump vec4 tmpvar_72;
  highp int elementIndex_73;
  elementIndex_73 = (tmpvar_14 + 1);
  highp int textureWidth_74;
  textureWidth_74 = byteBufferTextureSize.width;
  highp int tmpvar_75;
  tmpvar_75 = (elementIndex_73 / textureWidth_74);
  highp vec2 tmpvar_76;
  tmpvar_76.x = ((float(
    (elementIndex_73 - (tmpvar_75 * textureWidth_74))
  ) + 0.5) / float(textureWidth_74));
  tmpvar_76.y = ((float(tmpvar_75) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_77;
  tmpvar_77 = texture (byteBufferTexture, tmpvar_76);
  tmpvar_72 = tmpvar_77;
  mediump vec4 tmpvar_78;
  highp int elementIndex_79;
  elementIndex_79 = (tmpvar_14 + 2);
  highp int textureWidth_80;
  textureWidth_80 = byteBufferTextureSize.width;
  highp int tmpvar_81;
  tmpvar_81 = (elementIndex_79 / textureWidth_80);
  highp vec2 tmpvar_82;
  tmpvar_82.x = ((float(
    (elementIndex_79 - (tmpvar_81 * textureWidth_80))
  ) + 0.5) / float(textureWidth_80));
  tmpvar_82.y = ((float(tmpvar_81) + 0.5) / float(byteBufferTextureSize.height));
  lowp vec4 tmpvar_83;
  tmpvar_83 = texture (byteBufferTexture, tmpvar_82);
  tmpvar_78 = tmpvar_83;
  highp mat3 tmpvar_84;
  tmpvar_84[uint(0)] = matrixOut_0_51.xyz;
  tmpvar_84[1u] = matrixOut_1_52.xyz;
  tmpvar_84[2u] = matrixOut_2_53.xyz;
  highp vec3 tmpvar_85;
  highp vec3 tmpvar_86;
  highp vec3 tmpvar_87;
  tmpvar_85 = normalize((tmpvar_84 * outputValue_3.tangent));
  tmpvar_86 = normalize((tmpvar_84 * outputValue_3.bitangent));
  tmpvar_87 = normalize((tmpvar_84 * outputValue_3.normal));
  highp vec3 tmpvar_88;
  tmpvar_88.x = tmpvar_85.x;
  tmpvar_88.y = tmpvar_86.x;
  tmpvar_88.z = tmpvar_87.x;
  highp vec3 tmpvar_89;
  tmpvar_89.x = tmpvar_85.y;
  tmpvar_89.y = tmpvar_86.y;
  tmpvar_89.z = tmpvar_87.y;
  highp vec3 tmpvar_90;
  tmpvar_90.x = tmpvar_85.z;
  tmpvar_90.y = tmpvar_86.z;
  tmpvar_90.z = tmpvar_87.z;
  highp mat3 tmpvar_91;
  tmpvar_91[uint(0)] = tmpvar_88;
  tmpvar_91[1u] = tmpvar_89;
  tmpvar_91[2u] = tmpvar_90;
  outputValue_1.tangentViewFragPosition = (tmpvar_91 * (matrixOut_33 * tmpvar_6).xyz);
  gl_Position = (matrixOut_15 * tmpvar_6);
  outputValue_1.extrusionDepth = clamp (tmpvar_67.x, 0.0, 1.0);
  outputValue_1.strokeWidth = ((clamp (tmpvar_67.y, 0.0, 1.0) * 2.0) - 1.0);
  outputValue_1.haloBlur = clamp (tmpvar_67.z, 0.0, 1.0);
  highp vec4 tmpvar_92;
  tmpvar_92.xyz = vec3(1.0, 1.0, 1.0);
  tmpvar_92.w = labelOptions.opacity;
  outputValue_1.extrusionColor = (tmpvar_72 * tmpvar_92);
  outputValue_1.strokeColor = tmpvar_78;
  v_texture = outputValue_1.texture;
  v_color = outputValue_1.color;
  v_extrusionColor = outputValue_1.extrusionColor;
  v_strokeColor = outputValue_1.strokeColor;
  v_haloColor = outputValue_1.haloColor;
  v_strokeWidth = outputValue_1.strokeWidth;
  v_extrusionDepth = outputValue_1.extrusionDepth;
  v_haloSize = outputValue_1.haloSize;
  v_haloBlur = outputValue_1.haloBlur;
  v_tangentViewFragPosition = outputValue_1.tangentViewFragPosition;
  v_tangent = outputValue_1.tangent;
  v_bitangent = outputValue_1.bitangent;
  v_normal = outputValue_1.normal;
//Glyph3d::glyph3dLowPrecision_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in mediump vec4 v_color;
in mediump vec4 v_extrusionColor;
in mediump vec4 v_strokeColor;
in mediump vec4 v_haloColor;
in mediump float v_strokeWidth;
in mediump float v_extrusionDepth;
in mediump float v_haloSize;
in mediump float v_haloBlur;
in highp vec3 v_tangentViewFragPosition;
in highp vec3 v_tangent;
in highp vec3 v_bitangent;
in highp vec3 v_normal;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
out lowp vec4 output_value;
void main ()
  mediump float extrusionDistance_1;
  mediump float strokeEdge_2;
  mediump float sampleDistance_3;
  mediump float extrusionDepthInPixels_4;
  mediump float strokeWidthInPixels_5;
  highp float tmpvar_6;
  tmpvar_6 = ((v_strokeWidth * float(glyphOptions.maxStrokeWidth)) / 2.0);
  strokeWidthInPixels_5 = tmpvar_6;
  highp float tmpvar_7;
  tmpvar_7 = (v_extrusionDepth * float(glyphOptions.maxExtrusionDepth));
  extrusionDepthInPixels_4 = tmpvar_7;
  lowp float tmpvar_8;
  tmpvar_8 = texture (textureAtlas, v_texture).y;
  sampleDistance_3 = tmpvar_8;
  mediump vec2 tmpvar_9;
  tmpvar_9.x = dFdx(sampleDistance_3);
  tmpvar_9.y = dFdy(sampleDistance_3);
  mediump float tmpvar_10;
  tmpvar_10 = (0.75 * sqrt(dot (tmpvar_9, tmpvar_9)));
  highp float tmpvar_11;
  tmpvar_11 = clamp (((
    (-(strokeWidthInPixels_5) / float(glyphOptions.maxHaloDistanceStored))
   + 1.0) / 2.0), 0.0, 1.0);
  strokeEdge_2 = tmpvar_11;
  mediump float tmpvar_12;
  tmpvar_12 = min (0.5, strokeEdge_2);
  mediump float tmpvar_13;
  tmpvar_13 = max (0.5, strokeEdge_2);
  mediump float tmpvar_14;
  tmpvar_14 = (tmpvar_12 - tmpvar_10);
  mediump float tmpvar_15;
  mediump float tmpvar_16;
  tmpvar_16 = clamp (((sampleDistance_3 - tmpvar_14) / (
    (tmpvar_12 + tmpvar_10)
   - tmpvar_14)), 0.0, 1.0);
  tmpvar_15 = (tmpvar_16 * (tmpvar_16 * (3.0 - 
    (2.0 * tmpvar_16)
  )));
  mediump float tmpvar_17;
  tmpvar_17 = (tmpvar_13 - tmpvar_10);
  mediump float tmpvar_18;
  tmpvar_18 = clamp (((sampleDistance_3 - tmpvar_17) / (
    (tmpvar_13 + tmpvar_10)
   - tmpvar_17)), 0.0, 1.0);
  mediump vec4 tmpvar_19;
  tmpvar_19 = mix (v_color, v_strokeColor, vec4(((1.0 - 
    (tmpvar_18 * (tmpvar_18 * (3.0 - (2.0 * tmpvar_18))))
  ) * abs(
    sign(strokeWidthInPixels_5)
  ))));
  mediump vec4 tmpvar_20;
  tmpvar_20.xyz = tmpvar_19.xyz;
  tmpvar_20.w = (tmpvar_19.w * tmpvar_15);
  lowp vec2 tmpvar_21;
  tmpvar_21 = vec2(textureSize (textureAtlas, 0));
  highp vec2 P_22;
  P_22 = (v_texture + ((
    normalize(v_tangentViewFragPosition)
  .xy * vec2(extrusionDepthInPixels_4)) / tmpvar_21));
  lowp float tmpvar_23;
  tmpvar_23 = texture (textureAtlas, P_22).y;
  extrusionDistance_1 = tmpvar_23;
  mediump float tmpvar_24;
  tmpvar_24 = (tmpvar_12 - tmpvar_10);
  mediump float tmpvar_25;
  tmpvar_25 = clamp (((extrusionDistance_1 - tmpvar_24) / (
    (tmpvar_12 + tmpvar_10)
   - tmpvar_24)), 0.0, 1.0);
  mediump vec4 tmpvar_26;
  tmpvar_26.xyz = v_extrusionColor.xyz;
  tmpvar_26.w = (v_extrusionColor.w * (tmpvar_25 * (tmpvar_25 * 
    (3.0 - (2.0 * tmpvar_25))
  )));
  mediump vec4 tmpvar_27;
  tmpvar_27 = mix (tmpvar_26, tmpvar_20, vec4(tmpvar_15));
  output_value = tmpvar_27;
//GlyphWithNormalHalo::glyphWithNormalHalo_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out lowp vec4 v_color;
out lowp vec4 v_haloColor;
out highp float v_alpha;
out highp float v_haloSizeInPixels;
out highp vec2 v_tangent;
out highp vec2 v_bitangent;
out mediump vec4 v_dropShadowParams;
out mediump vec4 v_dropShadowColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.texture = vertex_attributes_texture;
  vertex_attributes_1.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_1.color = vertex_attributes_color;
  vertex_attributes_1.haloColor = vertex_attributes_haloColor;
  vertex_attributes_1.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_1.tangent = vertex_attributes_tangent;
  vertex_attributes_1.bitangent = vertex_attributes_bitangent;
  VertexOut outputValue_2;
  highp float alpha_3;
  alpha_3 = ((vertex_attributes_1.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = vertex_attributes_1.position.x;
  tmpvar_4.y = vertex_attributes_1.position.y;
  gl_Position = tmpvar_4;
  outputValue_2.texture = vertex_attributes_1.texture;
  highp vec4 tmpvar_5;
  tmpvar_5.x = vertex_attributes_1.color.x;
  tmpvar_5.y = vertex_attributes_1.color.y;
  tmpvar_5.z = vertex_attributes_1.color.z;
  tmpvar_5.w = (vertex_attributes_1.color.w * alpha_3);
  outputValue_2.color = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.x = vertex_attributes_1.haloColor.x;
  tmpvar_6.y = vertex_attributes_1.haloColor.y;
  tmpvar_6.z = vertex_attributes_1.haloColor.z;
  tmpvar_6.w = (vertex_attributes_1.haloColor.w * alpha_3);
  outputValue_2.haloColor = tmpvar_6;
  outputValue_2.tangent = vertex_attributes_1.tangent;
  outputValue_2.bitangent = vertex_attributes_1.bitangent;
  outputValue_2.haloSizeInPixels = ((vertex_attributes_1.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_7;
    tmpvar_7 = int((65535.0 * vertex_attributes_1.deviceBufferIndex.x));
    highp mat4 matrixOut_8;
    highp vec2 tmpvar_9;
    tmpvar_9.x = float(floatBufferTextureSize.width);
    tmpvar_9.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_10;
    tmpvar_10 = (1.0/(tmpvar_9));
    highp int textureWidth_11;
    textureWidth_11 = floatBufferTextureSize.width;
    highp int tmpvar_12;
    tmpvar_12 = (tmpvar_7 / textureWidth_11);
    highp float tmpvar_13;
    tmpvar_13 = ((float(
      (tmpvar_7 - (tmpvar_12 * textureWidth_11))
    ) + 0.5) / float(textureWidth_11));
    highp vec2 tmpvar_14;
    tmpvar_14.x = tmpvar_13;
    tmpvar_14.y = ((float(tmpvar_12) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, tmpvar_14);
    matrixOut_8[0] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_14.y;
    uvCoordinate_16.x = (tmpvar_13 + tmpvar_10.x);
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_10.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_8[1] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_14.y;
    uvCoordinate_19.x = (tmpvar_13 + (tmpvar_10.x * 2.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_10.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_8[2] = tmpvar_21;
    highp vec2 uvCoordinate_22;
    uvCoordinate_22.y = tmpvar_14.y;
    uvCoordinate_22.x = (tmpvar_13 + (tmpvar_10.x * 3.0));
    highp vec2 tmpvar_23;
    tmpvar_23.x = -1.0;
    tmpvar_23.y = tmpvar_10.y;
    uvCoordinate_22 = (uvCoordinate_22 + (vec2(float(
      (uvCoordinate_22.x >= 1.0)
    )) * tmpvar_23));
    lowp vec4 tmpvar_24;
    tmpvar_24 = texture (floatBufferTexture, uvCoordinate_22);
    matrixOut_8[3] = tmpvar_24;
    gl_Position = (matrixOut_8 * tmpvar_4);
  } else {
    gl_Position = (view.screenProjectionMatrix * gl_Position);
  };
  v_texture = outputValue_2.texture;
  v_color = outputValue_2.color;
  v_haloColor = outputValue_2.haloColor;
  v_alpha = outputValue_2.alpha;
  v_haloSizeInPixels = outputValue_2.haloSizeInPixels;
  v_tangent = outputValue_2.tangent;
  v_bitangent = outputValue_2.bitangent;
  v_dropShadowParams = outputValue_2.dropShadowParams;
  v_dropShadowColor = outputValue_2.dropShadowColor;
//GlyphWithNormalHalo::glyphWithNormalHalo_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in lowp vec4 v_color;
in lowp vec4 v_haloColor;
in highp float v_alpha;
in highp float v_haloSizeInPixels;
in highp vec2 v_tangent;
in highp vec2 v_bitangent;
in mediump vec4 v_dropShadowParams;
in mediump vec4 v_dropShadowColor;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
out lowp vec4 output_value;
void main ()
  mediump vec4 mask_1;
  lowp vec4 out_color_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureAtlas, v_texture);
  mask_1 = tmpvar_3;
  if (!(bool(glyphOptions.isHalo))) {
    mediump vec4 tmpvar_4;
    tmpvar_4.xyz = v_color.xyz;
    tmpvar_4.w = (mask_1.x * v_color.w);
    out_color_2 = tmpvar_4;
  } else {
    mediump float alpha_5;
    mediump float haloDistance_6;
    highp float tmpvar_7;
    tmpvar_7 = abs(((
      (mask_1.y * 2.0)
     - 1.0) * float(glyphOptions.maxHaloDistanceStored)));
    haloDistance_6 = tmpvar_7;
    highp float tmpvar_8;
    tmpvar_8 = (1.0 - min (max (
      ((haloDistance_6 - v_haloSizeInPixels) / 2.0)
    , 0.0), 1.0));
    alpha_5 = tmpvar_8;
    mediump vec4 tmpvar_9;
    tmpvar_9.xyz = v_haloColor.xyz;
    tmpvar_9.w = (alpha_5 * v_haloColor.w);
    out_color_2 = tmpvar_9;
  };
  output_value = out_color_2;
//GlyphWithOuterHalo::glyphWithOuterHalo_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out lowp vec4 v_color;
out lowp vec4 v_haloColor;
out highp float v_alpha;
out highp float v_haloSizeInPixels;
out highp vec2 v_tangent;
out highp vec2 v_bitangent;
out mediump vec4 v_dropShadowParams;
out mediump vec4 v_dropShadowColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.texture = vertex_attributes_texture;
  vertex_attributes_1.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_1.color = vertex_attributes_color;
  vertex_attributes_1.haloColor = vertex_attributes_haloColor;
  vertex_attributes_1.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_1.tangent = vertex_attributes_tangent;
  vertex_attributes_1.bitangent = vertex_attributes_bitangent;
  VertexOut outputValue_2;
  highp float alpha_3;
  alpha_3 = ((vertex_attributes_1.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = vertex_attributes_1.position.x;
  tmpvar_4.y = vertex_attributes_1.position.y;
  gl_Position = tmpvar_4;
  outputValue_2.texture = vertex_attributes_1.texture;
  highp vec4 tmpvar_5;
  tmpvar_5.x = vertex_attributes_1.color.x;
  tmpvar_5.y = vertex_attributes_1.color.y;
  tmpvar_5.z = vertex_attributes_1.color.z;
  tmpvar_5.w = (vertex_attributes_1.color.w * alpha_3);
  outputValue_2.color = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.x = vertex_attributes_1.haloColor.x;
  tmpvar_6.y = vertex_attributes_1.haloColor.y;
  tmpvar_6.z = vertex_attributes_1.haloColor.z;
  tmpvar_6.w = (vertex_attributes_1.haloColor.w * alpha_3);
  outputValue_2.haloColor = tmpvar_6;
  outputValue_2.tangent = vertex_attributes_1.tangent;
  outputValue_2.bitangent = vertex_attributes_1.bitangent;
  outputValue_2.haloSizeInPixels = ((vertex_attributes_1.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_7;
    tmpvar_7 = int((65535.0 * vertex_attributes_1.deviceBufferIndex.x));
    highp mat4 matrixOut_8;
    highp vec2 tmpvar_9;
    tmpvar_9.x = float(floatBufferTextureSize.width);
    tmpvar_9.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_10;
    tmpvar_10 = (1.0/(tmpvar_9));
    highp int textureWidth_11;
    textureWidth_11 = floatBufferTextureSize.width;
    highp int tmpvar_12;
    tmpvar_12 = (tmpvar_7 / textureWidth_11);
    highp float tmpvar_13;
    tmpvar_13 = ((float(
      (tmpvar_7 - (tmpvar_12 * textureWidth_11))
    ) + 0.5) / float(textureWidth_11));
    highp vec2 tmpvar_14;
    tmpvar_14.x = tmpvar_13;
    tmpvar_14.y = ((float(tmpvar_12) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, tmpvar_14);
    matrixOut_8[0] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_14.y;
    uvCoordinate_16.x = (tmpvar_13 + tmpvar_10.x);
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_10.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_8[1] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_14.y;
    uvCoordinate_19.x = (tmpvar_13 + (tmpvar_10.x * 2.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_10.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_8[2] = tmpvar_21;
    highp vec2 uvCoordinate_22;
    uvCoordinate_22.y = tmpvar_14.y;
    uvCoordinate_22.x = (tmpvar_13 + (tmpvar_10.x * 3.0));
    highp vec2 tmpvar_23;
    tmpvar_23.x = -1.0;
    tmpvar_23.y = tmpvar_10.y;
    uvCoordinate_22 = (uvCoordinate_22 + (vec2(float(
      (uvCoordinate_22.x >= 1.0)
    )) * tmpvar_23));
    lowp vec4 tmpvar_24;
    tmpvar_24 = texture (floatBufferTexture, uvCoordinate_22);
    matrixOut_8[3] = tmpvar_24;
    gl_Position = (matrixOut_8 * tmpvar_4);
  } else {
    gl_Position = (view.screenProjectionMatrix * gl_Position);
  };
  v_texture = outputValue_2.texture;
  v_color = outputValue_2.color;
  v_haloColor = outputValue_2.haloColor;
  v_alpha = outputValue_2.alpha;
  v_haloSizeInPixels = outputValue_2.haloSizeInPixels;
  v_tangent = outputValue_2.tangent;
  v_bitangent = outputValue_2.bitangent;
  v_dropShadowParams = outputValue_2.dropShadowParams;
  v_dropShadowColor = outputValue_2.dropShadowColor;
//GlyphWithOuterHalo::glyphWithOuterHalo_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in lowp vec4 v_color;
in lowp vec4 v_haloColor;
in highp float v_alpha;
in highp float v_haloSizeInPixels;
in highp vec2 v_tangent;
in highp vec2 v_bitangent;
in mediump vec4 v_dropShadowParams;
in mediump vec4 v_dropShadowColor;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
inout lowp vec4 output_value;
void main ()
  mediump vec4 mask_1;
  lowp vec4 out_color_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureAtlas, v_texture);
  mask_1 = tmpvar_3;
  if (bool(glyphOptions.isHalo)) {
    mediump float haloSizeInPixels_4;
    mediump float haloDistance_5;
    highp float tmpvar_6;
    tmpvar_6 = abs(((
      (mask_1.y * 2.0)
     - 1.0) * float(glyphOptions.maxHaloDistanceStored)));
    haloDistance_5 = tmpvar_6;
    highp float tmpvar_7;
    tmpvar_7 = max (v_haloSizeInPixels, ((v_haloSizeInPixels + 2.0) * output_value.w));
    haloSizeInPixels_4 = tmpvar_7;
    mediump float tmpvar_8;
    tmpvar_8 = (1.0 - min (max (
      ((haloDistance_5 - haloSizeInPixels_4) / 2.0)
    , 0.0), 1.0));
    mediump vec4 tmpvar_9;
    tmpvar_9.xyz = mix (output_value.xyz, v_haloColor.xyz, vec3((tmpvar_8 * v_haloColor.w)));
    tmpvar_9.w = min ((1.0 - (tmpvar_8 * v_haloColor.w)), output_value.w);
    out_color_2 = tmpvar_9;
  } else {
    mediump vec4 tmpvar_10;
    tmpvar_10.xyz = mix (output_value.xyz, v_color.xyz, vec3((mask_1.x * v_color.w)));
    tmpvar_10.w = output_value.w;
    out_color_2 = tmpvar_10;
  };
  output_value = out_color_2;
//Grid::grid_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct GridView {
  highp mat4 gridView;
  highp vec4 color;
struct Style {
  highp vec4 lineColor;
  highp float majorSize;
  highp float minorSize;
  highp float gridMix;
  highp vec4 lineParams;
struct MajorMinorVertex {
  highp vec4 majorMinorVertex;
in highp vec4 vertex_input_position;
uniform View view;
uniform GridView gridView;
uniform Style style;
out highp vec4 v_majorMinorVertex;
void main ()
  MajorMinorVertex out_value_1;
  VertexIn vertex_input_2;
  vertex_input_2.position = vertex_input_position;
  highp vec4 tmpvar_3;
  tmpvar_3 = vertex_input_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  highp vec4 tmpvar_4;
  tmpvar_4 = (gridView.gridView * tmpvar_3);
  out_value_1.majorMinorVertex.xy = (tmpvar_4.xy * vec2(style.majorSize));
  out_value_1.majorMinorVertex.zw = (tmpvar_4.xy * vec2(style.minorSize));
  v_majorMinorVertex = out_value_1.majorMinorVertex;
//Grid::grid_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct GridView {
  highp mat4 gridView;
  highp vec4 color;
struct Style {
  highp vec4 lineColor;
  highp float majorSize;
  highp float minorSize;
  highp float gridMix;
  highp vec4 lineParams;
in highp vec4 v_majorMinorVertex;
uniform GridView gridView;
uniform Style style;
out lowp vec4 output_value;
void main ()
  mediump float grid_1;
  mediump vec4 g_2;
  lowp vec4 out_color_3;
  highp vec4 tmpvar_4;
  tmpvar_4 = (abs(dFdx(v_majorMinorVertex)) + abs(dFdy(v_majorMinorVertex)));
  highp vec4 tmpvar_5;
  tmpvar_5.x = style.lineParams.x;
  tmpvar_5.y = style.lineParams.x;
  tmpvar_5.z = style.lineParams.z;
  tmpvar_5.w = style.lineParams.z;
  highp vec4 tmpvar_6;
  tmpvar_6.x = style.lineParams.y;
  tmpvar_6.y = style.lineParams.y;
  tmpvar_6.z = style.lineParams.w;
  tmpvar_6.w = style.lineParams.w;
  highp vec4 tmpvar_7;
  tmpvar_7 = clamp (((
    abs((fract((v_majorMinorVertex - vec4(0.5, 0.5, 0.5, 0.5))) - vec4(0.5, 0.5, 0.5, 0.5)))
   - 
    (tmpvar_4 * tmpvar_5)
  ) / (tmpvar_4 * 
    (tmpvar_6 - tmpvar_5)
  )), vec4(0.0, 0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 1.0));
  g_2 = tmpvar_7;
  mediump float tmpvar_8;
  tmpvar_8 = min (g_2.x, g_2.y);
  mediump float tmpvar_9;
  tmpvar_9 = min (g_2.z, g_2.w);
  highp float tmpvar_10;
  tmpvar_10 = mix (tmpvar_9, tmpvar_8, style.gridMix);
  grid_1 = tmpvar_10;
  mediump vec4 tmpvar_11;
  tmpvar_11 = vec4((1.0 - grid_1));
  highp vec4 tmpvar_12;
  tmpvar_12 = ((style.lineColor * tmpvar_11) + (gridView.color * vec4(grid_1)));
  out_color_3.xyz = tmpvar_12.xyz;
  out_color_3.w = 1.0;
  output_value = out_color_3;
//Icon::icon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  mediump vec4 alphaBrightnessPercentSaturation;
  highp vec2 deviceBufferIndex;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  mediump float alpha;
  mediump float brightness;
  mediump float saturation;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in mediump vec4 vertex_attributes_alphaBrightnessPercentSaturation;
in highp vec2 vertex_attributes_deviceBufferIndex;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out mediump float v_alpha;
out mediump float v_brightness;
out mediump float v_saturation;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.position = vertex_attributes_position;
  vertex_attributes_2.texture = vertex_attributes_texture;
  vertex_attributes_2.alphaBrightnessPercentSaturation = vertex_attributes_alphaBrightnessPercentSaturation;
  vertex_attributes_2.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  outputValue_1.texture = vertex_attributes_2.texture;
  outputValue_1.alpha = (vertex_attributes_2.alphaBrightnessPercentSaturation.x * labelOptions.opacity);
  outputValue_1.brightness = (vertex_attributes_2.alphaBrightnessPercentSaturation.y * 2.55);
  outputValue_1.saturation = vertex_attributes_2.alphaBrightnessPercentSaturation.z;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.x = vertex_attributes_2.position.x;
  tmpvar_3.y = vertex_attributes_2.position.y;
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_4;
    tmpvar_4 = int((65535.0 * vertex_attributes_2.deviceBufferIndex.x));
    highp mat4 matrixOut_5;
    highp vec2 tmpvar_6;
    tmpvar_6.x = float(floatBufferTextureSize.width);
    tmpvar_6.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_7;
    tmpvar_7 = (1.0/(tmpvar_6));
    highp int textureWidth_8;
    textureWidth_8 = floatBufferTextureSize.width;
    highp int tmpvar_9;
    tmpvar_9 = (tmpvar_4 / textureWidth_8);
    highp float tmpvar_10;
    tmpvar_10 = ((float(
      (tmpvar_4 - (tmpvar_9 * textureWidth_8))
    ) + 0.5) / float(textureWidth_8));
    highp vec2 tmpvar_11;
    tmpvar_11.x = tmpvar_10;
    tmpvar_11.y = ((float(tmpvar_9) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_12;
    tmpvar_12 = texture (floatBufferTexture, tmpvar_11);
    matrixOut_5[0] = tmpvar_12;
    highp vec2 uvCoordinate_13;
    uvCoordinate_13.y = tmpvar_11.y;
    uvCoordinate_13.x = (tmpvar_10 + tmpvar_7.x);
    highp vec2 tmpvar_14;
    tmpvar_14.x = -1.0;
    tmpvar_14.y = tmpvar_7.y;
    uvCoordinate_13 = (uvCoordinate_13 + (vec2(float(
      (uvCoordinate_13.x >= 1.0)
    )) * tmpvar_14));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, uvCoordinate_13);
    matrixOut_5[1] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_11.y;
    uvCoordinate_16.x = (tmpvar_10 + (tmpvar_7.x * 2.0));
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_7.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_5[2] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_11.y;
    uvCoordinate_19.x = (tmpvar_10 + (tmpvar_7.x * 3.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_7.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_5[3] = tmpvar_21;
    gl_Position = (matrixOut_5 * tmpvar_3);
  } else {
    gl_Position = (view.screenProjectionMatrix * tmpvar_3);
  };
  v_texture = outputValue_1.texture;
  v_alpha = outputValue_1.alpha;
  v_brightness = outputValue_1.brightness;
  v_saturation = outputValue_1.saturation;
//Icon::icon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texture;
in mediump float v_alpha;
in mediump float v_brightness;
in mediump float v_saturation;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  mediump vec4 tex0_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (textureMap, v_texture);
  tex0_1 = tmpvar_2;
  tex0_1.xyz = mix (vec3(dot (tex0_1.xyz, vec3(0.2990723, 0.5869141, 0.1140137))), tex0_1.xyz, vec3(v_saturation));
  tex0_1.xyz = mix ((tex0_1.xyz * vec3((1.0 - 
    max (0.0, (1.0 - v_brightness))
  ))), tex0_1.www, vec3(max (0.0, (v_brightness - 1.0))));
  output_value = (tex0_1 * vec4(v_alpha));
//ImageCopy::imageCopy_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = ((vertexInput_2.position * vec2(2.0, 2.0)) - vec2(1.0, 1.0));
  gl_Position = tmpvar_3;
  v_texcoord = outputValue_1.texcoord;
//ImageCopy::imageCopy_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texcoord;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  output_value = texture (textureMap, v_texcoord);
//LandmarkDepth::landmarkDepth_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
  highp vec2 texture;
  highp vec4 normalAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
in highp vec4 vertex_input_position;
in highp vec2 vertex_input_texture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform View view;
uniform Scale scale;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.position = vertex_input_position;
  vertex_input_1.texture = vertex_input_texture;
  vertex_input_1.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  highp vec3 tmpvar_2;
  tmpvar_2 = (scale.tileOrigin + (scale.tileSize * vertex_input_1.position.xyz));
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xy = tmpvar_2.xy;
  tmpvar_3.z = (tmpvar_2.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
//LandmarkDepth::landmarkDepth_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
out lowp vec4 output_value;
void main ()
  output_value = vec4(0.0, 0.0, 0.0, 0.0);
//LandmarkFlat::landmarkFlat_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
  highp vec2 texture;
  highp vec4 normalAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct VertexOut {
  lowp vec4 color;
  highp vec2 texture;
in highp vec4 vertex_input_position;
in highp vec2 vertex_input_texture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform View view;
uniform Scale scale;
uniform Style style;
out lowp vec4 v_color;
out highp vec2 v_texture;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.position = vertex_input_position;
  vertex_input_1.texture = vertex_input_texture;
  vertex_input_1.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_2;
  highp int tmpvar_3;
  tmpvar_3 = int(((vertex_input_1.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_2.color = style.color[tmpvar_3];
  highp vec3 tmpvar_4;
  tmpvar_4 = (scale.tileOrigin + (scale.tileSize * vertex_input_1.position.xyz));
  highp vec4 tmpvar_5;
  tmpvar_5.zw = vec2(0.0, 1.0);
  tmpvar_5.xy = tmpvar_4.xy;
  highp vec4 tmpvar_6;
  tmpvar_6 = (view.modelViewProjectionMatrix * tmpvar_5);
  highp vec4 tmpvar_7;
  tmpvar_7.xy = tmpvar_6.xy;
  tmpvar_7.z = ((1.0 - tmpvar_4.z) * tmpvar_6.w);
  tmpvar_7.w = tmpvar_6.w;
  gl_Position = tmpvar_7;
  outputValue_2.texture = vertex_input_1.texture;
  v_color = outputValue_2.color;
  v_texture = outputValue_2.texture;
//LandmarkFlat::landmarkFlat_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
in lowp vec4 v_color;
in highp vec2 v_texture;
uniform Style style;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  lowp vec4 tmpvar_1;
  mediump float textureLightness_2;
  textureLightness_2 = style.textureLightness;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureSampler, v_texture);
  mediump vec4 tmpvar_4;
  tmpvar_4 = mix (tmpvar_3, vec4(1.0, 1.0, 1.0, 1.0), vec4(textureLightness_2));
  tmpvar_1 = (v_color * tmpvar_4);
  output_value = tmpvar_1;
//Line::line_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_normal;
in highp vec2 vertex_attributes_texCoord;
uniform View view;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.normal = vertex_attributes_normal;
  vertex_attributes_1.texCoord = vertex_attributes_texCoord;
  highp vec4 tmpvar_2;
  tmpvar_2.zw = vec2(0.0, 1.0);
  tmpvar_2.x = vertex_attributes_1.position.x;
  tmpvar_2.y = vertex_attributes_1.position.y;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_2);
//Line::line_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
uniform Style style;
out lowp vec4 output_value;
void main ()
  output_value = style.color;
//ManeuverPoint::maneuverPoint_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp float halfWidth;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = (vertexInput_2.position + (vertexInput_2.normal * vec2(style.halfWidth)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  outputValue_1.texCoord = vertexInput_2.normal;
  v_texCoord = outputValue_1.texCoord;
//ManeuverPoint::maneuverPoint_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp float halfWidth;
in highp vec2 v_texCoord;
uniform Style style;
uniform sampler2D alphaMap;
out lowp vec4 output_value;
void main ()
  lowp vec4 tmpvar_1;
  tmpvar_1 = texture (alphaMap, v_texCoord);
  highp vec4 tmpvar_2;
  tmpvar_2.xyz = style.color.xyz;
  tmpvar_2.w = (style.color.w * tmpvar_1.x);
  output_value = tmpvar_2;
//OcclusionLine::occlusionLine_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
struct View {
  highp mat4 matrix;
  highp vec4 color;
  highp float pointSize;
in highp vec3 vertex_attributes_position;
uniform View view;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xyz = vertex_attributes_1.position;
  gl_Position = (view.matrix * tmpvar_2);
  gl_PointSize = view.pointSize;
//OcclusionLine::occlusionLine_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct View {
  highp mat4 matrix;
  highp vec4 color;
  highp float pointSize;
uniform View view;
out lowp vec4 output_value;
void main ()
  output_value = view.color;
//OptimizedTraffic::optimizedTraffic_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 startPosition;
  highp vec2 endPosition;
  highp float startDistance;
  highp float endDistance;
  highp vec2 direction;
  highp float uniDirectional;
  highp vec2 coordinates;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float pitchRatio;
  highp vec4 glowColor;
  highp float drivingDirection;
  highp float zoomDependentShift;
  highp float pillPhase;
  highp float frameBufferAlphaScale;
  highp float sideOffset;
  highp float pillLength;
  highp float localPillRadius;
  highp float localPillStart;
  highp float pillAspectRatio;
  highp vec4 pillAlphaFunction;
struct VertexOut {
  highp vec3 pillCoords;
  highp float pillY;
in highp vec2 vertexInput_startPosition;
in highp vec2 vertexInput_endPosition;
in highp float vertexInput_startDistance;
in highp float vertexInput_endDistance;
in highp vec2 vertexInput_direction;
in highp float vertexInput_uniDirectional;
in highp vec2 vertexInput_coordinates;
uniform View view;
uniform Style style;
out highp vec3 v_pillCoords;
out highp float v_pillY;
void main ()
  highp float extrusionAmount_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.startPosition = vertexInput_startPosition;
  vertexInput_3.endPosition = vertexInput_endPosition;
  vertexInput_3.startDistance = vertexInput_startDistance;
  vertexInput_3.endDistance = vertexInput_endDistance;
  vertexInput_3.direction = vertexInput_direction;
  vertexInput_3.uniDirectional = vertexInput_uniDirectional;
  vertexInput_3.coordinates = vertexInput_coordinates;
  highp float tmpvar_4;
  tmpvar_4 = (style.drivingDirection * (1.0 - (style.zoomDependentShift * vertexInput_3.uniDirectional)));
  highp vec2 tmpvar_5;
  tmpvar_5.x = vertexInput_3.direction.y;
  tmpvar_5.y = -(vertexInput_3.direction.x);
  highp float tmpvar_6;
  if ((vertexInput_3.coordinates.x < 0.0)) {
    tmpvar_6 = vertexInput_3.startDistance;
  } else {
    tmpvar_6 = vertexInput_3.endDistance;
  };
  highp float tmpvar_7;
  tmpvar_7 = fract(((tmpvar_6 / style.pillLength) + style.pillPhase));
  highp float tmpvar_8;
  tmpvar_8 = (tmpvar_7 - clamp (tmpvar_7, style.localPillStart, (1.0 - style.localPillStart)));
  if (((tmpvar_8 * tmpvar_8) < 1e-06)) {
    extrusionAmount_1 = ((style.localPillStart * sign(vertexInput_3.coordinates.x)) * style.pillLength);
  } else {
    extrusionAmount_1 = (((style.localPillStart - 
      abs(tmpvar_8)
    ) * sign(tmpvar_8)) * style.pillLength);
  };
  highp vec4 tmpvar_9;
  tmpvar_9.zw = vec2(0.0, 1.0);
  tmpvar_9.xy = ((mix (vertexInput_3.startPosition, vertexInput_3.endPosition, vec2(
    float((vertexInput_3.coordinates.x >= 0.0))
  )) + (tmpvar_5 * vec2(
    (((tmpvar_4 * style.sideOffset) + (sign(vertexInput_3.coordinates.y) * style.halfWidth)) * view.tilePerPoint)
  ))) + (vertexInput_3.direction * vec2(extrusionAmount_1)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_9);
  highp vec3 tmpvar_10;
  tmpvar_10.x = (tmpvar_6 + extrusionAmount_1);
  tmpvar_10.y = vertexInput_3.startDistance;
  tmpvar_10.z = vertexInput_3.endDistance;
  highp vec3 tmpvar_11;
  tmpvar_11.x = 0.0;
  tmpvar_11.y = -(style.localPillStart);
  tmpvar_11.z = style.localPillStart;
  outputValue_2.pillCoords = (((tmpvar_10 / vec3(style.pillLength)) + vec3(style.pillPhase)) + tmpvar_11);
  outputValue_2.pillY = ((vertexInput_3.coordinates.y * 0.5) / style.pillAspectRatio);
  v_pillCoords = outputValue_2.pillCoords;
  v_pillY = outputValue_2.pillY;
//OptimizedTraffic::optimizedTraffic_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float pitchRatio;
  highp vec4 glowColor;
  highp float drivingDirection;
  highp float zoomDependentShift;
  highp float pillPhase;
  highp float frameBufferAlphaScale;
  highp float sideOffset;
  highp float pillLength;
  highp float localPillRadius;
  highp float localPillStart;
  highp float pillAspectRatio;
  highp vec4 pillAlphaFunction;
in highp vec3 v_pillCoords;
in highp float v_pillY;
uniform Style style;
inout lowp vec4 output_value;
void main ()
  lowp vec3 glowColor_1;
  lowp float maxAlpha_2;
  lowp vec4 o_color_3;
  highp vec3 tmpvar_4;
  tmpvar_4 = (v_pillCoords - vec3(floor(v_pillCoords.x)));
  highp vec2 tmpvar_5;
  tmpvar_5 = clamp (tmpvar_4.yz, vec2(0.0, 0.0), vec2(1.0, 1.0));
  highp vec2 tmpvar_6;
  tmpvar_6.x = abs((tmpvar_4.x - clamp (tmpvar_4.x, 
    (tmpvar_5.x + style.localPillStart)
  , 
    (tmpvar_5.y - style.localPillStart)
  )));
  tmpvar_6.y = v_pillY;
  highp vec2 tmpvar_7;
  tmpvar_7.x = style.color.w;
  tmpvar_7.y = style.glowColor.w;
  highp vec2 tmpvar_8;
  tmpvar_8 = (clamp ((
    (style.pillAlphaFunction.xy - vec2(sqrt(dot (tmpvar_6, tmpvar_6))))
   * 
    (1.0/((style.pillAlphaFunction.zw * vec2((abs(
      dFdx(v_pillY)
    ) + abs(
      dFdy(v_pillY)
    ))))))
  ), vec2(0.0, 0.0), vec2(1.0, 1.0)) * tmpvar_7);
  highp float tmpvar_9;
  tmpvar_9 = (1.0 - (output_value.w * style.frameBufferAlphaScale));
  maxAlpha_2 = tmpvar_9;
  highp vec3 tmpvar_10;
  tmpvar_10 = mix (output_value.xyz, style.glowColor.xyz, vec3((maxAlpha_2 * tmpvar_8.y)));
  glowColor_1 = tmpvar_10;
  highp vec4 tmpvar_11;
  tmpvar_11.xyz = mix (glowColor_1, style.color.xyz, vec3(min (tmpvar_8.x, maxAlpha_2)));
  tmpvar_11.w = max (tmpvar_8.x, output_value.w);
  o_color_3 = tmpvar_11;
  output_value = o_color_3;
//OuterShadowRibbon::outerShadowRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp float halfWidth;
  highp float imageWidth;
  highp float strokeSlopeFactor;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texCoord = outputValue_1.texCoord;
//OuterShadowRibbon::outerShadowRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp float halfWidth;
  highp float imageWidth;
  highp float strokeSlopeFactor;
in highp vec2 v_texCoord;
uniform Style style;
uniform sampler2D distanceTexture;
out lowp vec4 output_value;
void main ()
  lowp float shadow_1;
  mediump float dist_2;
  lowp vec4 o_color_3;
  highp vec4 tmpvar_4;
  tmpvar_4 = style.color;
  o_color_3 = tmpvar_4;
  mediump float tmpvar_5;
  highp float tmpvar_6;
  tmpvar_6 = dFdx(v_texCoord.y);
  highp float tmpvar_7;
  tmpvar_7 = dFdy(v_texCoord.y);
  highp float tmpvar_8;
  tmpvar_8 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_6 * tmpvar_6) + (tmpvar_7 * tmpvar_7)))
  )));
  tmpvar_5 = tmpvar_8;
  lowp float tmpvar_9;
  tmpvar_9 = textureLod (distanceTexture, v_texCoord, tmpvar_5).x;
  dist_2 = tmpvar_9;
  highp float tmpvar_10;
  tmpvar_10 = clamp ((dist_2 * style.strokeSlopeFactor), 0.0, 1.0);
  shadow_1 = tmpvar_10;
  o_color_3.w = (o_color_3.w * (shadow_1 * shadow_1));
  output_value = o_color_3;
//PatternedRibbon::writeStencilPatternedRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float distance;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float distanceMultiplier;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_distance;
uniform View view;
uniform Style style;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  vertexInput_1.normal = vertexInput_normal;
  vertexInput_1.texCoord = vertexInput_texCoord;
  vertexInput_1.distance = vertexInput_distance;
  highp vec4 tmpvar_2;
  tmpvar_2.zw = vec2(0.0, 1.0);
  tmpvar_2.xy = (vertexInput_1.position + ((
    (vertexInput_1.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_2);
//PatternedRibbon::writeStencilPatternedRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
out lowp vec4 output_value;
void main ()
  output_value = vec4(0.0, 0.0, 0.0, 0.0);
//PatternedRibbon::patternedRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float distance;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float distanceMultiplier;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_distance;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.distance = vertexInput_distance;
  highp vec2 tmpvar_3;
  tmpvar_3.x = ((vertexInput_2.texCoord.y + 1.0) / 2.0);
  tmpvar_3.y = (vertexInput_2.distance * style.distanceMultiplier);
  outputValue_1.texCoord = tmpvar_3;
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  v_texCoord = outputValue_1.texCoord;
//PatternedRibbon::patternedRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float distanceMultiplier;
in highp vec2 v_texCoord;
uniform Style style;
uniform sampler2D textureSampler;
inout lowp vec4 output_value;
void main ()
  lowp vec4 outColor_1;
  highp vec2 tmpvar_2;
  tmpvar_2.x = v_texCoord.x;
  tmpvar_2.y = fract(v_texCoord.y);
  highp vec4 tmpvar_3;
  tmpvar_3 = style.color;
  outColor_1 = tmpvar_3;
  outColor_1.w = (outColor_1.w * texture (textureSampler, tmpvar_2).x);
  lowp vec4 result_4;
  if ((output_value.w >= 0.9902344)) {
    result_4.xyz = mix (output_value.xyz, outColor_1.xyz, outColor_1.www);
    result_4.w = outColor_1.w;
  } else {
    if ((outColor_1.w > output_value.w)) {
      result_4.xyz = mix (output_value.xyz, outColor_1.xyz, vec3((outColor_1.w - output_value.w)));
      result_4.w = outColor_1.w;
    } else {
      result_4 = output_value;
    };
  };
  output_value = result_4;
//PolygonAnimatableFill::polygonAnimatableFill_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Fill {
  highp mat4 worldTransform;
  highp vec4 color;
  highp vec4 variantColor;
  highp float scale;
  highp vec2 origin;
  highp vec2 size;
struct VertexOut {
  highp vec2 texture;
in highp vec4 vertex_attributes_vertexAndStyleIndex;
uniform View view;
uniform Fill fill;
out highp vec2 v_texture;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.vertexAndStyleIndex = vertex_attributes_vertexAndStyleIndex;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = (fill.origin + (fill.size * vertex_attributes_2.vertexAndStyleIndex.xy));
  highp vec4 tmpvar_4;
  tmpvar_4 = (fill.worldTransform * tmpvar_3);
  outputValue_1.texture = (tmpvar_4.xy * vec2(fill.scale));
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xy = tmpvar_4.xy;
  tmpvar_5.z = ((vertex_attributes_2.vertexAndStyleIndex.z * 2.0) - 1.0);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  v_texture = outputValue_1.texture;
//PolygonAnimatableFill::polygonAnimatableFill_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Fill {
  highp mat4 worldTransform;
  highp vec4 color;
  highp vec4 variantColor;
  highp float scale;
  highp vec2 origin;
  highp vec2 size;
struct Variant {
  highp float textureWeight;
in highp vec2 v_texture;
uniform Fill fill;
uniform Variant variant;
uniform sampler2D textureSampler;
uniform sampler2D variantTextureSampler;
out lowp vec4 output_value;
void main ()
  lowp vec4 color2_1;
  lowp vec4 color1_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureSampler, v_texture);
  highp vec4 tmpvar_4;
  tmpvar_4.xyz = (fill.color.xyz * tmpvar_3.xyz);
  tmpvar_4.w = fill.color.w;
  color1_2 = tmpvar_4;
  lowp vec4 tmpvar_5;
  tmpvar_5 = texture (variantTextureSampler, v_texture);
  highp vec4 tmpvar_6;
  tmpvar_6.xyz = (fill.variantColor.xyz * tmpvar_5.xyz);
  tmpvar_6.w = fill.variantColor.w;
  color2_1 = tmpvar_6;
  highp vec4 tmpvar_7;
  tmpvar_7 = mix (color1_2, color2_1, vec4(variant.textureWeight));
  output_value = tmpvar_7;
//PolygonAnimatableStroke::polygonAnimatableStroke_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexStyleIndicesAndTexture;
  highp vec4 tangents;
  highp float side;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Polygon {
  highp mat4 worldTransform;
  highp vec4 strokeColor[16];
  highp vec4 polygonColor;
  highp float lineWidthOuter[16];
  highp float lineWidthInner[16];
  highp float scale;
struct VertexOut {
  highp float strokeTexture;
  highp vec2 polygonTexture;
  highp vec4 strokeColor;
in highp vec4 vertex_attributes_vertexStyleIndicesAndTexture;
in highp vec4 vertex_attributes_tangents;
in highp float vertex_attributes_side;
uniform View view;
uniform Polygon polygon;
out highp float v_strokeTexture;
out highp vec2 v_polygonTexture;
out highp vec4 v_strokeColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.vertexStyleIndicesAndTexture = vertex_attributes_vertexStyleIndicesAndTexture;
  vertex_attributes_1.tangents = vertex_attributes_tangents;
  vertex_attributes_1.side = vertex_attributes_side;
  highp mat4 modelViewProjectionMatrix_2;
  modelViewProjectionMatrix_2 = view.modelViewProjectionMatrix;
  VertexOut outputValue_3;
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = vertex_attributes_1.vertexStyleIndicesAndTexture.xy;
  highp int tmpvar_5;
  tmpvar_5 = int((vertex_attributes_1.vertexStyleIndicesAndTexture.z * 256.0));
  highp int tmpvar_6;
  tmpvar_6 = int(((
    (vertex_attributes_1.vertexStyleIndicesAndTexture.z * 256.0)
   - 
    float(tmpvar_5)
  ) * 256.0));
  highp float tmpvar_7;
  tmpvar_7 = ((vertex_attributes_1.vertexStyleIndicesAndTexture.w * 2.0) - 1.0);
  highp vec2 tmpvar_8;
  tmpvar_8 = vertex_attributes_1.tangents.xy;
  highp vec2 tmpvar_9;
  tmpvar_9 = vertex_attributes_1.tangents.zw;
  highp float tmpvar_10;
  if ((vertex_attributes_1.side > 0.5)) {
    tmpvar_10 = polygon.lineWidthOuter[tmpvar_5];
  } else {
    tmpvar_10 = polygon.lineWidthInner[tmpvar_5];
  };
  highp float tmpvar_11;
  if ((vertex_attributes_1.side > 0.5)) {
    tmpvar_11 = polygon.lineWidthOuter[tmpvar_6];
  } else {
    tmpvar_11 = polygon.lineWidthInner[tmpvar_6];
  };
  highp vec2 tmpvar_12;
  tmpvar_12.x = tmpvar_8.y;
  tmpvar_12.y = -(tmpvar_8.x);
  highp float factor_13;
  factor_13 = 0.0;
  highp float tmpvar_14;
  tmpvar_14 = ((tmpvar_8.x * tmpvar_9.y) - (tmpvar_8.y * tmpvar_9.x));
  highp float tmpvar_15;
  tmpvar_15 = dot (tmpvar_9, tmpvar_9);
  highp float tmpvar_16;
  tmpvar_16 = float((dot (tmpvar_8, tmpvar_8) >= 0.08));
  highp float tmpvar_17;
  tmpvar_17 = float((tmpvar_15 >= 0.08));
  highp float tmpvar_18;
  tmpvar_18 = float((abs(tmpvar_14) >= 0.08));
  if ((((tmpvar_16 * tmpvar_17) * tmpvar_18) > 0.0)) {
    factor_13 = (((tmpvar_11 * tmpvar_15) - (tmpvar_10 * 
      dot (tmpvar_8, tmpvar_9)
    )) * (1.0/(tmpvar_14)));
    highp float tmpvar_19;
    tmpvar_19 = (abs(tmpvar_10) * 2.0);
    factor_13 = clamp (factor_13, -(tmpvar_19), tmpvar_19);
  };
  highp vec4 tmpvar_20;
  tmpvar_20.zw = vec2(0.0, 0.0);
  tmpvar_20.xy = ((tmpvar_12 * vec2(tmpvar_10)) + (tmpvar_8 * vec2(factor_13)));
  highp vec4 tmpvar_21;
  tmpvar_21 = ((polygon.worldTransform * tmpvar_4) + tmpvar_20);
  gl_Position = (modelViewProjectionMatrix_2 * tmpvar_21);
  outputValue_3.polygonTexture = (tmpvar_21.xy * vec2(polygon.scale));
  outputValue_3.strokeTexture = tmpvar_7;
  outputValue_3.strokeColor = polygon.strokeColor[tmpvar_5];
  v_strokeTexture = outputValue_3.strokeTexture;
  v_polygonTexture = outputValue_3.polygonTexture;
  v_strokeColor = outputValue_3.strokeColor;
//PolygonAnimatableStroke::polygonAnimatableStroke_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Polygon {
  highp mat4 worldTransform;
  highp vec4 strokeColor[16];
  highp vec4 polygonColor;
  highp float lineWidthOuter[16];
  highp float lineWidthInner[16];
  highp float scale;
struct Variant {
  highp float textureWeight;
struct AnimatablePolygon {
  highp vec4 targetColor;
in highp float v_strokeTexture;
in highp vec2 v_polygonTexture;
in highp vec4 v_strokeColor;
uniform Polygon polygon;
uniform Variant variant;
uniform AnimatablePolygon animatablePolygon;
uniform sampler2D alphaTexture;
uniform sampler2D texturePolygonSampler;
uniform sampler2D textureVariantSampler;
out lowp vec4 output_value;
void main ()
  lowp vec4 polyColor_1;
  lowp vec4 color2_2;
  lowp vec4 color1_3;
  lowp vec4 tmpvar_4;
  tmpvar_4 = texture (texturePolygonSampler, v_polygonTexture);
  highp vec4 tmpvar_5;
  tmpvar_5 = (polygon.polygonColor * tmpvar_4);
  color1_3 = tmpvar_5;
  lowp vec4 tmpvar_6;
  tmpvar_6 = texture (textureVariantSampler, v_polygonTexture);
  highp vec4 tmpvar_7;
  tmpvar_7 = (animatablePolygon.targetColor * tmpvar_6);
  color2_2 = tmpvar_7;
  highp vec4 tmpvar_8;
  tmpvar_8 = mix (color1_3, color2_2, vec4(variant.textureWeight));
  polyColor_1 = tmpvar_8;
  lowp vec4 tmpvar_9;
  highp vec2 tmpvar_10;
  tmpvar_10.y = 0.0;
  tmpvar_10.x = v_strokeTexture;
  lowp vec4 tmpvar_11;
  tmpvar_11 = texture (alphaTexture, tmpvar_10);
  if ((v_strokeColor.w > 0.0001000166)) {
    lowp float polygonTextureCoord_12;
    highp float tmpvar_13;
    tmpvar_13 = clamp (v_strokeTexture, 0.0, 1.0);
    polygonTextureCoord_12 = tmpvar_13;
    lowp float tmpvar_14;
    tmpvar_14 = (polygonTextureCoord_12 * (1.0 - tmpvar_11.x));
    highp vec4 tmpvar_15;
    tmpvar_15.xyz = mix (v_strokeColor.xyz, polyColor_1.xyz, vec3(polygonTextureCoord_12));
    tmpvar_15.w = ((tmpvar_11.x + tmpvar_14) * mix (v_strokeColor.w, polyColor_1.w, polygonTextureCoord_12));
    tmpvar_9 = tmpvar_15;
  } else {
    lowp float polygonTextureCoord_16;
    highp float tmpvar_17;
    tmpvar_17 = ((v_strokeTexture + 1.0) / 2.0);
    polygonTextureCoord_16 = tmpvar_17;
    lowp vec4 tmpvar_18;
    tmpvar_18.xyz = polyColor_1.xyz;
    tmpvar_18.w = (polyColor_1.w * (polygonTextureCoord_16 * (1.0 - tmpvar_11.x)));
    tmpvar_9 = tmpvar_18;
  };
  output_value = tmpvar_9;
//PolygonFill::polygonFill_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Fill {
  highp mat4 worldTransform;
  highp vec4 color;
  highp float scale;
  highp vec2 origin;
  highp vec2 size;
struct VertexOut {
  highp vec2 texture;
in highp vec4 vertex_attributes_vertexAndStyleIndex;
uniform View view;
uniform Fill fill;
out highp vec2 v_texture;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.vertexAndStyleIndex = vertex_attributes_vertexAndStyleIndex;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = (fill.origin + (fill.size * vertex_attributes_2.vertexAndStyleIndex.xy));
  highp vec4 tmpvar_4;
  tmpvar_4 = (fill.worldTransform * tmpvar_3);
  outputValue_1.texture = (tmpvar_4.xy * vec2(fill.scale));
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xy = tmpvar_4.xy;
  tmpvar_5.z = ((vertex_attributes_2.vertexAndStyleIndex.z * 2.0) - 1.0);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_5);
  v_texture = outputValue_1.texture;
//PolygonFill::polygonFill_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Fill {
  highp mat4 worldTransform;
  highp vec4 color;
  highp float scale;
  highp vec2 origin;
  highp vec2 size;
in highp vec2 v_texture;
uniform Fill fill;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  output_value = (fill.color * texture (textureSampler, v_texture));
//PolygonShadowedStroke::polygonShadowedStroke_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 vertexPosition;
  highp vec2 offsetAndTexture;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct ShadowPath {
  highp vec4 color;
  highp float width;
  highp vec3 direction;
  highp float offsetScale;
struct VertexOut {
  highp float alphaRamp;
  highp float alphaAdjust;
in highp vec2 vertex_attributes_vertexPosition;
in highp vec2 vertex_attributes_offsetAndTexture;
uniform View view;
uniform ShadowPath shadowPath;
out highp float v_alphaRamp;
out highp float v_alphaAdjust;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.vertexPosition = vertex_attributes_vertexPosition;
  vertex_attributes_2.offsetAndTexture = vertex_attributes_offsetAndTexture;
  highp float tmpvar_3;
  tmpvar_3 = float(int((255.0 * vertex_attributes_2.offsetAndTexture.x)));
  highp vec2 tmpvar_4;
  tmpvar_4.x = ((tmpvar_3 / 127.5) - 1.0);
  tmpvar_4.y = ((floor(
    ((vertex_attributes_2.offsetAndTexture.x * 255.0) - tmpvar_3)
  ) * 2.0) - 1.0);
  highp vec3 tmpvar_5;
  tmpvar_5 = (((shadowPath.direction * vec3(shadowPath.width)) * vertex_attributes_2.offsetAndTexture.yyy) * vec3(view.tilePerPoint));
  highp vec4 tmpvar_6;
  tmpvar_6.w = 1.0;
  tmpvar_6.x = (vertex_attributes_2.vertexPosition.x + tmpvar_5.x);
  tmpvar_6.y = (vertex_attributes_2.vertexPosition.y + tmpvar_5.y);
  tmpvar_6.z = tmpvar_5.z;
  highp vec3 tmpvar_7;
  tmpvar_7.z = 0.0;
  tmpvar_7.xy = (vec2(shadowPath.offsetScale) * tmpvar_4);
  outputValue_1.alphaAdjust = min ((1.0 - abs(
    dot (tmpvar_7, shadowPath.direction)
  )), 1.0);
  outputValue_1.alphaRamp = vertex_attributes_2.offsetAndTexture.y;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_6);
  v_alphaRamp = outputValue_1.alphaRamp;
  v_alphaAdjust = outputValue_1.alphaAdjust;
//PolygonShadowedStroke::polygonShadowedStroke_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct ShadowPath {
  highp vec4 color;
  highp float width;
  highp vec3 direction;
  highp float offsetScale;
in highp float v_alphaRamp;
in highp float v_alphaAdjust;
uniform ShadowPath shadowPath;
inout lowp vec4 output_value;
void main ()
  lowp vec3 shadowColor_1;
  lowp float alpha_2;
  lowp float mask_alpha_3;
  lowp float landAlpha_4;
  highp float tmpvar_5;
  tmpvar_5 = (1.0 - min ((v_alphaRamp + 1.0), 1.0));
  landAlpha_4 = tmpvar_5;
  lowp vec4 tmpvar_6;
  tmpvar_6.xyz = (output_value.xyz * vec3(landAlpha_4));
  tmpvar_6.w = landAlpha_4;
  highp float tmpvar_7;
  tmpvar_7 = (1.0 - v_alphaRamp);
  mask_alpha_3 = tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = (shadowPath.color.w * mask_alpha_3);
  alpha_2 = tmpvar_8;
  alpha_2 = (min ((alpha_2 + landAlpha_4), 1.0) * v_alphaAdjust);
  highp vec3 tmpvar_9;
  tmpvar_9 = (shadowPath.color.xyz * vec3(alpha_2));
  shadowColor_1 = tmpvar_9;
  lowp vec4 tmpvar_10;
  tmpvar_10.xyz = (tmpvar_6.xyz + (vec3((1.0 - landAlpha_4)) * shadowColor_1));
  tmpvar_10.w = alpha_2;
  output_value = tmpvar_10;
//PolygonSolidFill::polygonSolidFill_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct SolidFill {
  highp vec4 color;
  highp vec2 origin;
  highp vec2 size;
in highp vec4 vertex_attributes_vertexAndStyleIndex;
uniform View view;
uniform SolidFill solidFill;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.vertexAndStyleIndex = vertex_attributes_vertexAndStyleIndex;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xy = (solidFill.origin + (solidFill.size * vertex_attributes_1.vertexAndStyleIndex.xy));
  tmpvar_2.z = ((vertex_attributes_1.vertexAndStyleIndex.z * 2.0) - 1.0);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_2);
//PolygonSolidFill::polygonSolidFill_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct SolidFill {
  highp vec4 color;
  highp vec2 origin;
  highp vec2 size;
uniform SolidFill solidFill;
out lowp vec4 output_value;
void main ()
  output_value = solidFill.color;
//PolygonStroke::polygonStroke_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexStyleIndicesAndTexture;
  highp vec4 tangents;
  highp float side;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Polygon {
  highp mat4 worldTransform;
  highp vec4 strokeColor[16];
  highp vec4 polygonColor;
  highp float lineWidthOuter[16];
  highp float lineWidthInner[16];
  highp float scale;
struct VertexOut {
  highp float strokeTexture;
  highp vec2 polygonTexture;
  highp vec4 strokeColor;
in highp vec4 vertex_attributes_vertexStyleIndicesAndTexture;
in highp vec4 vertex_attributes_tangents;
in highp float vertex_attributes_side;
uniform View view;
uniform Polygon polygon;
out highp float v_strokeTexture;
out highp vec2 v_polygonTexture;
out highp vec4 v_strokeColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.vertexStyleIndicesAndTexture = vertex_attributes_vertexStyleIndicesAndTexture;
  vertex_attributes_1.tangents = vertex_attributes_tangents;
  vertex_attributes_1.side = vertex_attributes_side;
  highp mat4 modelViewProjectionMatrix_2;
  modelViewProjectionMatrix_2 = view.modelViewProjectionMatrix;
  VertexOut outputValue_3;
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = vertex_attributes_1.vertexStyleIndicesAndTexture.xy;
  highp int tmpvar_5;
  tmpvar_5 = int((vertex_attributes_1.vertexStyleIndicesAndTexture.z * 256.0));
  highp int tmpvar_6;
  tmpvar_6 = int(((
    (vertex_attributes_1.vertexStyleIndicesAndTexture.z * 256.0)
   - 
    float(tmpvar_5)
  ) * 256.0));
  highp float tmpvar_7;
  tmpvar_7 = ((vertex_attributes_1.vertexStyleIndicesAndTexture.w * 2.0) - 1.0);
  highp vec2 tmpvar_8;
  tmpvar_8 = vertex_attributes_1.tangents.xy;
  highp vec2 tmpvar_9;
  tmpvar_9 = vertex_attributes_1.tangents.zw;
  highp float tmpvar_10;
  if ((vertex_attributes_1.side > 0.5)) {
    tmpvar_10 = polygon.lineWidthOuter[tmpvar_5];
  } else {
    tmpvar_10 = polygon.lineWidthInner[tmpvar_5];
  };
  highp float tmpvar_11;
  if ((vertex_attributes_1.side > 0.5)) {
    tmpvar_11 = polygon.lineWidthOuter[tmpvar_6];
  } else {
    tmpvar_11 = polygon.lineWidthInner[tmpvar_6];
  };
  highp vec2 tmpvar_12;
  tmpvar_12.x = tmpvar_8.y;
  tmpvar_12.y = -(tmpvar_8.x);
  highp float factor_13;
  factor_13 = 0.0;
  highp float tmpvar_14;
  tmpvar_14 = ((tmpvar_8.x * tmpvar_9.y) - (tmpvar_8.y * tmpvar_9.x));
  highp float tmpvar_15;
  tmpvar_15 = dot (tmpvar_9, tmpvar_9);
  highp float tmpvar_16;
  tmpvar_16 = float((dot (tmpvar_8, tmpvar_8) >= 0.08));
  highp float tmpvar_17;
  tmpvar_17 = float((tmpvar_15 >= 0.08));
  highp float tmpvar_18;
  tmpvar_18 = float((abs(tmpvar_14) >= 0.08));
  if ((((tmpvar_16 * tmpvar_17) * tmpvar_18) > 0.0)) {
    factor_13 = (((tmpvar_11 * tmpvar_15) - (tmpvar_10 * 
      dot (tmpvar_8, tmpvar_9)
    )) * (1.0/(tmpvar_14)));
    highp float tmpvar_19;
    tmpvar_19 = (abs(tmpvar_10) * 2.0);
    factor_13 = clamp (factor_13, -(tmpvar_19), tmpvar_19);
  };
  highp vec4 tmpvar_20;
  tmpvar_20.zw = vec2(0.0, 0.0);
  tmpvar_20.xy = ((tmpvar_12 * vec2(tmpvar_10)) + (tmpvar_8 * vec2(factor_13)));
  highp vec4 tmpvar_21;
  tmpvar_21 = ((polygon.worldTransform * tmpvar_4) + tmpvar_20);
  gl_Position = (modelViewProjectionMatrix_2 * tmpvar_21);
  outputValue_3.polygonTexture = (tmpvar_21.xy * vec2(polygon.scale));
  outputValue_3.strokeTexture = tmpvar_7;
  outputValue_3.strokeColor = polygon.strokeColor[tmpvar_5];
  v_strokeTexture = outputValue_3.strokeTexture;
  v_polygonTexture = outputValue_3.polygonTexture;
  v_strokeColor = outputValue_3.strokeColor;
//PolygonStroke::polygonStroke_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Polygon {
  highp mat4 worldTransform;
  highp vec4 strokeColor[16];
  highp vec4 polygonColor;
  highp float lineWidthOuter[16];
  highp float lineWidthInner[16];
  highp float scale;
in highp float v_strokeTexture;
in highp vec2 v_polygonTexture;
in highp vec4 v_strokeColor;
uniform Polygon polygon;
uniform sampler2D alphaTexture;
uniform sampler2D texturePolygonSampler;
out lowp vec4 output_value;
void main ()
  lowp vec4 polyColor_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (texturePolygonSampler, v_polygonTexture);
  highp vec4 tmpvar_3;
  tmpvar_3 = (polygon.polygonColor * tmpvar_2);
  polyColor_1 = tmpvar_3;
  lowp vec4 tmpvar_4;
  highp vec2 tmpvar_5;
  tmpvar_5.y = 0.0;
  tmpvar_5.x = v_strokeTexture;
  lowp vec4 tmpvar_6;
  tmpvar_6 = texture (alphaTexture, tmpvar_5);
  if ((v_strokeColor.w > 0.0001000166)) {
    lowp float polygonTextureCoord_7;
    highp float tmpvar_8;
    tmpvar_8 = clamp (v_strokeTexture, 0.0, 1.0);
    polygonTextureCoord_7 = tmpvar_8;
    lowp float tmpvar_9;
    tmpvar_9 = (polygonTextureCoord_7 * (1.0 - tmpvar_6.x));
    highp vec4 tmpvar_10;
    tmpvar_10.xyz = mix (v_strokeColor.xyz, polyColor_1.xyz, vec3(polygonTextureCoord_7));
    tmpvar_10.w = ((tmpvar_6.x + tmpvar_9) * mix (v_strokeColor.w, polyColor_1.w, polygonTextureCoord_7));
    tmpvar_4 = tmpvar_10;
  } else {
    lowp float polygonTextureCoord_11;
    highp float tmpvar_12;
    tmpvar_12 = ((v_strokeTexture + 1.0) / 2.0);
    polygonTextureCoord_11 = tmpvar_12;
    lowp vec4 tmpvar_13;
    tmpvar_13.xyz = polyColor_1.xyz;
    tmpvar_13.w = (polyColor_1.w * (polygonTextureCoord_11 * (1.0 - tmpvar_6.x)));
    tmpvar_4 = tmpvar_13;
  };
  output_value = tmpvar_4;
//Point::point_extended_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexInExtended {
  highp vec3 position;
  highp float size;
  highp vec4 color;
struct View {
  highp mat4 modelViewProjection;
  highp float pointsize;
  highp vec4 color;
  highp float ringSize;
struct VertexOut {
  highp vec4 color;
  highp float emptyRegionSq;
in highp vec3 vertexInput_position;
in highp float vertexInput_size;
in highp vec4 vertexInput_color;
uniform View view;
out highp vec4 v_color;
out highp float v_emptyRegionSq;
void main ()
  VertexOut outputValue_1;
  VertexInExtended vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.size = vertexInput_size;
  vertexInput_2.color = vertexInput_color;
  gl_PointSize = (view.pointsize * vertexInput_2.size);
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xyz = vertexInput_2.position;
  gl_Position = (view.modelViewProjection * tmpvar_3);
  outputValue_1.color = vertexInput_2.color;
  highp float tmpvar_4;
  tmpvar_4 = ((gl_PointSize - view.ringSize) / gl_PointSize);
  highp float tmpvar_5;
  if ((view.ringSize > 0.0)) {
    tmpvar_5 = (tmpvar_4 * tmpvar_4);
  } else {
    tmpvar_5 = 0.0;
  };
  outputValue_1.emptyRegionSq = tmpvar_5;
  v_color = outputValue_1.color;
  v_emptyRegionSq = outputValue_1.emptyRegionSq;
//Point::point_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct View {
  highp mat4 modelViewProjection;
  highp float pointsize;
  highp vec4 color;
  highp float ringSize;
in highp vec4 v_color;
in highp float v_emptyRegionSq;
uniform View view;
out lowp vec4 output_value;
void main ()
  lowp vec4 color_1;
  mediump vec2 tmpvar_2;
  tmpvar_2 = ((gl_PointCoord - vec2(0.5, 0.5)) * vec2(2.0, 2.0));
  mediump float tmpvar_3;
  tmpvar_3 = ((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y));
  mediump float value_4;
  value_4 = (1.0 - tmpvar_3);
  mediump vec2 tmpvar_5;
  tmpvar_5.x = dFdx(value_4);
  tmpvar_5.y = dFdy(value_4);
  mediump float tmpvar_6;
  tmpvar_6 = (0.75 * sqrt(dot (tmpvar_5, tmpvar_5)));
  mediump float edge0_7;
  edge0_7 = -(tmpvar_6);
  mediump float tmpvar_8;
  tmpvar_8 = clamp (((value_4 - edge0_7) / (tmpvar_6 - edge0_7)), 0.0, 1.0);
  mediump float edge_9;
  edge_9 = v_emptyRegionSq;
  mediump vec2 tmpvar_10;
  tmpvar_10.x = dFdx(tmpvar_3);
  tmpvar_10.y = dFdy(tmpvar_3);
  mediump float tmpvar_11;
  tmpvar_11 = (0.75 * sqrt(dot (tmpvar_10, tmpvar_10)));
  mediump float edge0_12;
  edge0_12 = (edge_9 - tmpvar_11);
  mediump float tmpvar_13;
  tmpvar_13 = clamp (((tmpvar_3 - edge0_12) / (
    (edge_9 + tmpvar_11)
   - edge0_12)), 0.0, 1.0);
  mediump float tmpvar_14;
  tmpvar_14 = ((tmpvar_8 * (tmpvar_8 * 
    (3.0 - (2.0 * tmpvar_8))
  )) * (tmpvar_13 * (tmpvar_13 * 
    (3.0 - (2.0 * tmpvar_13))
  )));
  highp vec4 tmpvar_15;
  tmpvar_15 = (view.color * v_color);
  color_1 = tmpvar_15;
  color_1.w = (color_1.w * tmpvar_14);
  output_value = color_1;
//Point::point_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct View {
  highp mat4 modelViewProjection;
  highp float pointsize;
  highp vec4 color;
  highp float ringSize;
struct VertexOut {
  highp vec4 color;
  highp float emptyRegionSq;
in highp vec2 vertexInput_position;
uniform View view;
out highp vec4 v_color;
out highp float v_emptyRegionSq;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  gl_PointSize = view.pointsize;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjection * tmpvar_3);
  outputValue_1.color = vec4(1.0, 1.0, 1.0, 1.0);
  highp float tmpvar_4;
  tmpvar_4 = ((gl_PointSize - view.ringSize) / gl_PointSize);
  highp float tmpvar_5;
  if ((view.ringSize > 0.0)) {
    tmpvar_5 = (tmpvar_4 * tmpvar_4);
  } else {
    tmpvar_5 = 0.0;
  };
  outputValue_1.emptyRegionSq = tmpvar_5;
  v_color = outputValue_1.color;
  v_emptyRegionSq = outputValue_1.emptyRegionSq;
//Point::point_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct View {
  highp mat4 modelViewProjection;
  highp float pointsize;
  highp vec4 color;
  highp float ringSize;
in highp vec4 v_color;
in highp float v_emptyRegionSq;
uniform View view;
out lowp vec4 output_value;
void main ()
  lowp vec4 color_1;
  mediump vec2 tmpvar_2;
  tmpvar_2 = ((gl_PointCoord - vec2(0.5, 0.5)) * vec2(2.0, 2.0));
  mediump float tmpvar_3;
  tmpvar_3 = ((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y));
  mediump float value_4;
  value_4 = (1.0 - tmpvar_3);
  mediump vec2 tmpvar_5;
  tmpvar_5.x = dFdx(value_4);
  tmpvar_5.y = dFdy(value_4);
  mediump float tmpvar_6;
  tmpvar_6 = (0.75 * sqrt(dot (tmpvar_5, tmpvar_5)));
  mediump float edge0_7;
  edge0_7 = -(tmpvar_6);
  mediump float tmpvar_8;
  tmpvar_8 = clamp (((value_4 - edge0_7) / (tmpvar_6 - edge0_7)), 0.0, 1.0);
  mediump float edge_9;
  edge_9 = v_emptyRegionSq;
  mediump vec2 tmpvar_10;
  tmpvar_10.x = dFdx(tmpvar_3);
  tmpvar_10.y = dFdy(tmpvar_3);
  mediump float tmpvar_11;
  tmpvar_11 = (0.75 * sqrt(dot (tmpvar_10, tmpvar_10)));
  mediump float edge0_12;
  edge0_12 = (edge_9 - tmpvar_11);
  mediump float tmpvar_13;
  tmpvar_13 = clamp (((tmpvar_3 - edge0_12) / (
    (edge_9 + tmpvar_11)
   - edge0_12)), 0.0, 1.0);
  mediump float tmpvar_14;
  tmpvar_14 = ((tmpvar_8 * (tmpvar_8 * 
    (3.0 - (2.0 * tmpvar_8))
  )) * (tmpvar_13 * (tmpvar_13 * 
    (3.0 - (2.0 * tmpvar_13))
  )));
  highp vec4 tmpvar_15;
  tmpvar_15 = (view.color * v_color);
  color_1 = tmpvar_15;
  color_1.w = (color_1.w * tmpvar_14);
  output_value = color_1;
//PrefilteredLine::prefilteredLine_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertex1AndCorner;
  highp vec4 vertex2AndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 vertexOffset[8];
  highp vec4 color[8];
  highp float halfWidth[8];
  highp vec2 canvasSize;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
  highp float zScale;
  highp float fogFactor;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct VertexOut {
  highp float texCoord;
  highp float fogCoordinate;
  lowp vec4 color;
  lowp vec4 fogColor;
in highp vec4 vertex_input_vertex1AndCorner;
in highp vec4 vertex_input_vertex2AndStyleIndex;
uniform View view;
uniform Style style;
uniform Skyfog skyfog;
out highp float v_texCoord;
out highp float v_fogCoordinate;
out lowp vec4 v_color;
out lowp vec4 v_fogColor;
void main ()
  highp vec4 unprojectedP_1;
  highp vec4 p_2;
  highp vec4 p1_3;
  highp vec4 p0_4;
  highp vec4 secondVertex_5;
  highp vec4 firstVertex_6;
  VertexOut outputValue_7;
  VertexIn vertex_input_8;
  vertex_input_8.vertex1AndCorner = vertex_input_vertex1AndCorner;
  vertex_input_8.vertex2AndStyleIndex = vertex_input_vertex2AndStyleIndex;
  highp int tmpvar_9;
  tmpvar_9 = int((65535.0 * vertex_input_8.vertex2AndStyleIndex.w));
  highp vec4 tmpvar_10;
  tmpvar_10 = style.vertexOffset[tmpvar_9];
  highp float tmpvar_11;
  tmpvar_11 = style.halfWidth[tmpvar_9];
  outputValue_7.color = style.color[tmpvar_9];
  highp int tmpvar_12;
  tmpvar_12 = int((65535.0 * vertex_input_8.vertex1AndCorner.w));
  highp int tmpvar_13;
  tmpvar_13 = (tmpvar_12 / 256);
  highp vec2 tmpvar_14;
  tmpvar_14.x = float(tmpvar_13);
  tmpvar_14.y = float((tmpvar_12 - (tmpvar_13 * 256)));
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = (style.tileOrigin + (style.tileSize * vertex_input_8.vertex1AndCorner.xyz));
  firstVertex_6.xyw = tmpvar_15.xyw;
  firstVertex_6.z = (tmpvar_15.z * style.zScale);
  firstVertex_6 = (firstVertex_6 + tmpvar_10);
  highp vec4 tmpvar_16;
  tmpvar_16.w = 1.0;
  tmpvar_16.xyz = (style.tileOrigin + (style.tileSize * vertex_input_8.vertex2AndStyleIndex.xyz));
  secondVertex_5.xyw = tmpvar_16.xyw;
  secondVertex_5.z = (tmpvar_16.z * style.zScale);
  secondVertex_5 = (secondVertex_5 + tmpvar_10);
  highp vec4 tmpvar_17;
  tmpvar_17 = (view.modelViewProjectionMatrix * firstVertex_6);
  p0_4 = tmpvar_17;
  highp vec4 tmpvar_18;
  tmpvar_18 = (view.modelViewProjectionMatrix * secondVertex_5);
  p1_3 = tmpvar_18;
  if ((tmpvar_14.x < 0.5)) {
    p_2 = tmpvar_17;
    unprojectedP_1 = firstVertex_6;
  } else {
    p_2 = tmpvar_18;
    unprojectedP_1 = secondVertex_5;
  };
  highp vec4 tmpvar_19;
  tmpvar_19.zw = vec2(1.0, 1.0);
  tmpvar_19.xy = (style.canvasSize * vec2(0.5, 0.5));
  p0_4 = (((tmpvar_17 / tmpvar_17.wwww) + vec4(1.0, 1.0, 0.0, 0.0)) * tmpvar_19);
  p1_3 = (((tmpvar_18 / tmpvar_18.wwww) + vec4(1.0, 1.0, 0.0, 0.0)) * tmpvar_19);
  highp vec2 tmpvar_20;
  tmpvar_20.x = (p1_3.y - p0_4.y);
  tmpvar_20.y = (p0_4.x - p1_3.x);
  highp vec4 tmpvar_21;
  tmpvar_21.zw = vec2(0.0, 0.0);
  tmpvar_21.xy = (vec2((p_2.w * tmpvar_11)) * normalize(tmpvar_20));
  outputValue_7.texCoord = ((tmpvar_14.y * 2.0) - 1.0);
  gl_Position = (p_2 + (vec4(-(outputValue_7.texCoord)) * (tmpvar_21 / tmpvar_19)));
  outputValue_7.fogCoordinate = (style.fogFactor * (dot (skyfog.fogSlope, unprojectedP_1) + skyfog.fogOffset));
  lowp vec4 tmpvar_22;
  highp vec4 tmpvar_23;
  tmpvar_23 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + (0.5 * p_2.y)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_22 = tmpvar_23;
  outputValue_7.fogColor = tmpvar_22;
  v_texCoord = outputValue_7.texCoord;
  v_fogCoordinate = outputValue_7.fogCoordinate;
  v_color = outputValue_7.color;
  v_fogColor = outputValue_7.fogColor;
//PrefilteredLine::prefilteredLine_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp float v_texCoord;
in highp float v_fogCoordinate;
in lowp vec4 v_color;
in lowp vec4 v_fogColor;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  highp vec2 tmpvar_1;
  tmpvar_1.y = 0.0;
  tmpvar_1.x = v_texCoord;
  lowp vec4 tmpvar_2;
  tmpvar_2.xyz = v_color.xyz;
  tmpvar_2.w = (v_color.w * texture (alphaTexture, tmpvar_1).x);
  lowp vec4 color_3;
  highp vec4 tmpvar_4;
  tmpvar_4 = mix (tmpvar_2, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_3 = tmpvar_4;
  output_value = color_3;
//RenderTargetBlend::renderTargetBlend_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertex_attributes_position;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.position = vertex_attributes_position;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.x = ((vertex_attributes_2.position.x * 2.0) - 1.0);
  tmpvar_3.y = ((vertex_attributes_2.position.y * 2.0) - 1.0);
  gl_Position = tmpvar_3;
  outputValue_1.texcoord = vertex_attributes_2.position;
  v_texcoord = outputValue_1.texcoord;
//RenderTargetBlend::renderTargetBlend_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Blend {
  highp float blendFactor;
in highp vec2 v_texcoord;
uniform Blend blend;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  mediump vec4 colorTexture_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (textureMap, v_texcoord);
  colorTexture_1 = tmpvar_2;
  highp vec4 tmpvar_3;
  tmpvar_3.xyz = colorTexture_1.xyz;
  tmpvar_3.w = (colorTexture_1.w * blend.blendFactor);
  output_value = tmpvar_3;
//RouteLine::routeLine_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float distance;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float splitLength;
  highp vec4 travelledColor;
  highp vec4 inverseBaseColor;
  highp float alphaScale;
  highp float alphaTest;
  highp float alphaComp;
struct VertexOut {
  highp vec2 texCoord;
  highp float distance;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_distance;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
out highp float v_distance;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.distance = vertexInput_distance;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  outputValue_1.distance = vertexInput_2.distance;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texCoord = outputValue_1.texCoord;
  v_distance = outputValue_1.distance;
//RouteLine::routeLine_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float splitLength;
  highp vec4 travelledColor;
  highp vec4 inverseBaseColor;
  highp float alphaScale;
  highp float alphaTest;
  highp float alphaComp;
in highp vec2 v_texCoord;
in highp float v_distance;
uniform Style style;
uniform sampler2D alphaTexture;
inout lowp vec4 output_value;
void main ()
  lowp vec4 outColor_1;
  if ((output_value.w >= 0.9902344)) {
    discard;
  };
  highp float splitLength_2;
  splitLength_2 = style.splitLength;
  lowp vec4 inverseBaseColor_3;
  inverseBaseColor_3 = style.inverseBaseColor;
  lowp vec4 travelledColor_4;
  travelledColor_4 = style.travelledColor;
  lowp vec4 baseColor_5;
  lowp vec4 tmpvar_6;
  tmpvar_6 = (vec4(1.0, 1.0, 1.0, 1.0) - inverseBaseColor_3);
  baseColor_5 = tmpvar_6;
  lowp float tmpvar_7;
  if ((splitLength_2 < v_distance)) {
    tmpvar_7 = 1.0;
  } else {
    tmpvar_7 = 0.0;
  };
  baseColor_5 = ((tmpvar_6 * vec4(tmpvar_7)) + (travelledColor_4 * vec4((1.0 - tmpvar_7))));
  outColor_1.xyz = baseColor_5.xyz;
  lowp vec4 tmpvar_8;
  tmpvar_8 = texture (alphaTexture, v_texCoord);
  outColor_1.w = (baseColor_5.w * (tmpvar_8.x * style.alphaScale));
  lowp vec4 tmpvar_9;
  tmpvar_9.xyz = mix (output_value.xyz, baseColor_5.xyz, outColor_1.www);
  tmpvar_9.w = tmpvar_8.x;
  output_value = tmpvar_9;
//RouteLine::patternedRouteLine_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float distance;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float distanceMultiplier;
struct PatternedVertexOut {
  highp vec2 texCoord;
  highp float distance;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_distance;
uniform View view;
uniform Style patternStyle;
out highp vec2 v_texCoord;
out highp float v_distance;
void main ()
  PatternedVertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.distance = vertexInput_distance;
  highp vec2 tmpvar_3;
  tmpvar_3.x = ((vertexInput_2.texCoord.y + 1.0) / 2.0);
  tmpvar_3.y = (vertexInput_2.distance * patternStyle.distanceMultiplier);
  outputValue_1.texCoord = tmpvar_3;
  outputValue_1.distance = vertexInput_2.distance;
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(patternStyle.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  v_texCoord = outputValue_1.texCoord;
  v_distance = outputValue_1.distance;
//RouteLine::patternedRouteLine_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float splitLength;
  highp vec4 travelledColor;
  highp vec4 inverseBaseColor;
  highp float alphaScale;
  highp float alphaTest;
  highp float alphaComp;
in highp vec2 v_texCoord;
in highp float v_distance;
uniform Style routeStyle;
uniform sampler2D textureSampler;
inout lowp vec4 output_value;
void main ()
  lowp vec4 outColor_1;
  highp float splitLength_2;
  splitLength_2 = routeStyle.splitLength;
  lowp vec4 inverseBaseColor_3;
  inverseBaseColor_3 = routeStyle.inverseBaseColor;
  lowp vec4 travelledColor_4;
  travelledColor_4 = routeStyle.travelledColor;
  lowp vec4 baseColor_5;
  lowp vec4 tmpvar_6;
  tmpvar_6 = (vec4(1.0, 1.0, 1.0, 1.0) - inverseBaseColor_3);
  baseColor_5 = tmpvar_6;
  lowp float tmpvar_7;
  if ((splitLength_2 < v_distance)) {
    tmpvar_7 = 1.0;
  } else {
    tmpvar_7 = 0.0;
  };
  baseColor_5 = ((tmpvar_6 * vec4(tmpvar_7)) + (travelledColor_4 * vec4((1.0 - tmpvar_7))));
  outColor_1.xyz = baseColor_5.xyz;
  highp vec2 tmpvar_8;
  tmpvar_8.x = v_texCoord.x;
  tmpvar_8.y = fract(v_texCoord.y);
  outColor_1.w = (baseColor_5.w * (texture (textureSampler, tmpvar_8).x * routeStyle.alphaScale));
  lowp vec4 result_9;
  if ((output_value.w >= 0.9902344)) {
    result_9.xyz = mix (output_value.xyz, baseColor_5.xyz, outColor_1.www);
    result_9.w = outColor_1.w;
  } else {
    if ((outColor_1.w > output_value.w)) {
      result_9.xyz = mix (output_value.xyz, baseColor_5.xyz, vec3((outColor_1.w - output_value.w)));
      result_9.w = outColor_1.w;
    } else {
      result_9 = output_value;
    };
  };
  output_value = result_9;
//RouteLineAlphaReset::routeLineAlphaReset_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp float halfWidth;
struct VertexOut {
  highp float v;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
uniform View view;
uniform Style style;
out highp float v_v;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  outputValue_1.v = vertexInput_2.texCoord.y;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_v = outputValue_1.v;
//RouteLineAlphaReset::routeLineAlphaReset_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct FadeParams {
  highp float fadeStart;
in highp float v_v;
uniform FadeParams params;
inout lowp vec4 output_value;
void main ()
  lowp float alpha_1;
  highp float tmpvar_2;
  highp float tmpvar_3;
  tmpvar_3 = clamp (((
    abs(v_v)
   - 1.0) / (params.fadeStart - 1.0)), 0.0, 1.0);
  tmpvar_2 = (tmpvar_3 * (tmpvar_3 * (3.0 - 
    (2.0 * tmpvar_3)
  )));
  alpha_1 = tmpvar_2;
  lowp vec4 tmpvar_4;
  tmpvar_4.xyz = vec3(0.0, 0.0, 0.0);
  tmpvar_4.w = max (alpha_1, output_value.w);
  output_value = tmpvar_4;
//RouteLineArrow::routeLineArrow_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float arrowIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float pitchRatio;
  highp float currentArrowIndex;
  highp vec4 fillColor;
  highp vec4 strokeColor;
  highp vec4 highlightedFillColor;
  highp vec4 highlightedStrokeColor;
  highp float hightlightedHalfWidth;
  highp float alphaScale;
struct VertexOut {
  highp vec2 texture;
  highp vec4 fillColor;
  highp vec4 strokeColor;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_arrowIndex;
uniform View view;
uniform Style style;
out highp vec2 v_texture;
out highp vec4 v_fillColor;
out highp vec4 v_strokeColor;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.arrowIndex = vertexInput_arrowIndex;
  outputValue_1.texture = vertexInput_2.texCoord;
  highp float tmpvar_3;
  tmpvar_3 = clamp (abs((vertexInput_2.arrowIndex - style.currentArrowIndex)), 0.0, 1.0);
  outputValue_1.fillColor = mix (style.highlightedFillColor, style.fillColor, vec4(tmpvar_3));
  outputValue_1.strokeColor = mix (style.highlightedStrokeColor, style.strokeColor, vec4(tmpvar_3));
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(mix (style.hightlightedHalfWidth, style.halfWidth, tmpvar_3)))
   * vec2(view.tilePerPoint)) * vec2(16.0, 16.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  v_texture = outputValue_1.texture;
  v_fillColor = outputValue_1.fillColor;
  v_strokeColor = outputValue_1.strokeColor;
//RouteLineArrow::routeLineArrow_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float pitchRatio;
  highp float currentArrowIndex;
  highp vec4 fillColor;
  highp vec4 strokeColor;
  highp vec4 highlightedFillColor;
  highp vec4 highlightedStrokeColor;
  highp float hightlightedHalfWidth;
  highp float alphaScale;
in highp vec2 v_texture;
in highp vec4 v_fillColor;
in highp vec4 v_strokeColor;
uniform Style style;
uniform sampler2D alphaTextureSampler;
inout lowp vec4 output_value;
void main ()
  lowp vec4 arrowColor_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (alphaTextureSampler, v_texture);
  highp vec4 tmpvar_3;
  tmpvar_3 = mix (v_strokeColor, v_fillColor, tmpvar_2.yyyy);
  arrowColor_1.xyz = tmpvar_3.xyz;
  arrowColor_1.w = (tmpvar_2.x * style.alphaScale);
  lowp vec4 tmpvar_4;
  tmpvar_4.xyz = mix (output_value.xyz, arrowColor_1.xyz, arrowColor_1.www);
  tmpvar_4.w = arrowColor_1.w;
  arrowColor_1 = tmpvar_4;
  output_value = tmpvar_4;
//RouteLineTraffic::routeLineTraffic_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float distance;
  highp vec2 trafficSpeed;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 trafficColors[5];
  highp vec4 travelledTrafficColors[5];
  highp float splitLength;
struct VertexOut {
  highp vec2 texCoord;
  highp float distance;
  highp vec4 trafficColor;
  highp vec4 travelledTrafficColor;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_distance;
in highp vec2 vertexInput_trafficSpeed;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
out highp float v_distance;
out highp vec4 v_trafficColor;
out highp vec4 v_travelledTrafficColor;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.distance = vertexInput_distance;
  vertexInput_2.trafficSpeed = vertexInput_trafficSpeed;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  highp int tmpvar_4;
  tmpvar_4 = int(floor((vertexInput_2.trafficSpeed.x + 0.5)));
  outputValue_1.distance = vertexInput_2.distance;
  outputValue_1.trafficColor = style.trafficColors[tmpvar_4];
  outputValue_1.travelledTrafficColor = style.travelledTrafficColors[tmpvar_4];
  v_texCoord = outputValue_1.texCoord;
  v_distance = outputValue_1.distance;
  v_trafficColor = outputValue_1.trafficColor;
  v_travelledTrafficColor = outputValue_1.travelledTrafficColor;
//RouteLineTraffic::routeLineTraffic_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float halfWidth;
  highp vec4 trafficColors[5];
  highp vec4 travelledTrafficColors[5];
  highp float splitLength;
in highp vec2 v_texCoord;
in highp float v_distance;
in highp vec4 v_trafficColor;
in highp vec4 v_travelledTrafficColor;
uniform Style style;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  lowp vec4 trafficColor_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = mix (v_travelledTrafficColor, v_trafficColor, vec4(float((v_distance >= style.splitLength))));
  trafficColor_1 = tmpvar_2;
  output_value = (trafficColor_1 * texture (alphaTexture, v_texCoord).xxxx);
//SDFGlyph::sdfGlyph_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out lowp vec4 v_color;
out lowp vec4 v_haloColor;
out highp float v_alpha;
out highp float v_haloSizeInPixels;
out highp vec2 v_tangent;
out highp vec2 v_bitangent;
out mediump vec4 v_dropShadowParams;
out mediump vec4 v_dropShadowColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.texture = vertex_attributes_texture;
  vertex_attributes_1.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_1.color = vertex_attributes_color;
  vertex_attributes_1.haloColor = vertex_attributes_haloColor;
  vertex_attributes_1.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_1.tangent = vertex_attributes_tangent;
  vertex_attributes_1.bitangent = vertex_attributes_bitangent;
  VertexOut outputValue_2;
  highp float alpha_3;
  alpha_3 = ((vertex_attributes_1.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = vertex_attributes_1.position.x;
  tmpvar_4.y = vertex_attributes_1.position.y;
  gl_Position = tmpvar_4;
  outputValue_2.texture = vertex_attributes_1.texture;
  highp vec4 tmpvar_5;
  tmpvar_5.x = vertex_attributes_1.color.x;
  tmpvar_5.y = vertex_attributes_1.color.y;
  tmpvar_5.z = vertex_attributes_1.color.z;
  tmpvar_5.w = (vertex_attributes_1.color.w * alpha_3);
  outputValue_2.color = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.x = vertex_attributes_1.haloColor.x;
  tmpvar_6.y = vertex_attributes_1.haloColor.y;
  tmpvar_6.z = vertex_attributes_1.haloColor.z;
  tmpvar_6.w = (vertex_attributes_1.haloColor.w * alpha_3);
  outputValue_2.haloColor = tmpvar_6;
  outputValue_2.tangent = vertex_attributes_1.tangent;
  outputValue_2.bitangent = vertex_attributes_1.bitangent;
  outputValue_2.haloSizeInPixels = ((vertex_attributes_1.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_7;
    tmpvar_7 = int((65535.0 * vertex_attributes_1.deviceBufferIndex.x));
    highp mat4 matrixOut_8;
    highp vec2 tmpvar_9;
    tmpvar_9.x = float(floatBufferTextureSize.width);
    tmpvar_9.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_10;
    tmpvar_10 = (1.0/(tmpvar_9));
    highp int textureWidth_11;
    textureWidth_11 = floatBufferTextureSize.width;
    highp int tmpvar_12;
    tmpvar_12 = (tmpvar_7 / textureWidth_11);
    highp float tmpvar_13;
    tmpvar_13 = ((float(
      (tmpvar_7 - (tmpvar_12 * textureWidth_11))
    ) + 0.5) / float(textureWidth_11));
    highp vec2 tmpvar_14;
    tmpvar_14.x = tmpvar_13;
    tmpvar_14.y = ((float(tmpvar_12) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, tmpvar_14);
    matrixOut_8[0] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_14.y;
    uvCoordinate_16.x = (tmpvar_13 + tmpvar_10.x);
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_10.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_8[1] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_14.y;
    uvCoordinate_19.x = (tmpvar_13 + (tmpvar_10.x * 2.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_10.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_8[2] = tmpvar_21;
    highp vec2 uvCoordinate_22;
    uvCoordinate_22.y = tmpvar_14.y;
    uvCoordinate_22.x = (tmpvar_13 + (tmpvar_10.x * 3.0));
    highp vec2 tmpvar_23;
    tmpvar_23.x = -1.0;
    tmpvar_23.y = tmpvar_10.y;
    uvCoordinate_22 = (uvCoordinate_22 + (vec2(float(
      (uvCoordinate_22.x >= 1.0)
    )) * tmpvar_23));
    lowp vec4 tmpvar_24;
    tmpvar_24 = texture (floatBufferTexture, uvCoordinate_22);
    matrixOut_8[3] = tmpvar_24;
    gl_Position = (matrixOut_8 * tmpvar_4);
  } else {
    gl_Position = (view.screenProjectionMatrix * gl_Position);
  };
  v_texture = outputValue_2.texture;
  v_color = outputValue_2.color;
  v_haloColor = outputValue_2.haloColor;
  v_alpha = outputValue_2.alpha;
  v_haloSizeInPixels = outputValue_2.haloSizeInPixels;
  v_tangent = outputValue_2.tangent;
  v_bitangent = outputValue_2.bitangent;
  v_dropShadowParams = outputValue_2.dropShadowParams;
  v_dropShadowColor = outputValue_2.dropShadowColor;
//SDFGlyph::sdfGlyph_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texture;
in lowp vec4 v_color;
in lowp vec4 v_haloColor;
in highp float v_alpha;
in highp float v_haloSizeInPixels;
in highp vec2 v_tangent;
in highp vec2 v_bitangent;
in mediump vec4 v_dropShadowParams;
in mediump vec4 v_dropShadowColor;
uniform sampler2D textureAtlas;
out lowp vec4 output_value;
void main ()
  mediump float sampleDistance_1;
  lowp float tmpvar_2;
  tmpvar_2 = texture (textureAtlas, v_texture).y;
  sampleDistance_1 = tmpvar_2;
  mediump vec2 tmpvar_3;
  tmpvar_3.x = dFdx(sampleDistance_1);
  tmpvar_3.y = dFdy(sampleDistance_1);
  mediump float tmpvar_4;
  tmpvar_4 = (0.75 * sqrt(dot (tmpvar_3, tmpvar_3)));
  mediump float tmpvar_5;
  tmpvar_5 = (0.5 - tmpvar_4);
  mediump float tmpvar_6;
  tmpvar_6 = clamp (((sampleDistance_1 - tmpvar_5) / (
    (0.5 + tmpvar_4)
   - tmpvar_5)), 0.0, 1.0);
  mediump vec4 tmpvar_7;
  tmpvar_7.xyz = v_color.xyz;
  tmpvar_7.w = ((tmpvar_6 * (tmpvar_6 * 
    (3.0 - (2.0 * tmpvar_6))
  )) * v_color.w);
  output_value = tmpvar_7;
//SDFGlyph::sdfGlyph_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out lowp vec4 v_color;
out lowp vec4 v_haloColor;
out highp float v_alpha;
out highp float v_haloSizeInPixels;
out highp vec2 v_tangent;
out highp vec2 v_bitangent;
out mediump vec4 v_dropShadowParams;
out mediump vec4 v_dropShadowColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.texture = vertex_attributes_texture;
  vertex_attributes_1.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_1.color = vertex_attributes_color;
  vertex_attributes_1.haloColor = vertex_attributes_haloColor;
  vertex_attributes_1.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_1.tangent = vertex_attributes_tangent;
  vertex_attributes_1.bitangent = vertex_attributes_bitangent;
  VertexOut outputValue_2;
  highp float alpha_3;
  alpha_3 = ((vertex_attributes_1.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = vertex_attributes_1.position.x;
  tmpvar_4.y = vertex_attributes_1.position.y;
  gl_Position = tmpvar_4;
  outputValue_2.texture = vertex_attributes_1.texture;
  highp vec4 tmpvar_5;
  tmpvar_5.x = vertex_attributes_1.color.x;
  tmpvar_5.y = vertex_attributes_1.color.y;
  tmpvar_5.z = vertex_attributes_1.color.z;
  tmpvar_5.w = (vertex_attributes_1.color.w * alpha_3);
  outputValue_2.color = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.x = vertex_attributes_1.haloColor.x;
  tmpvar_6.y = vertex_attributes_1.haloColor.y;
  tmpvar_6.z = vertex_attributes_1.haloColor.z;
  tmpvar_6.w = (vertex_attributes_1.haloColor.w * alpha_3);
  outputValue_2.haloColor = tmpvar_6;
  outputValue_2.tangent = vertex_attributes_1.tangent;
  outputValue_2.bitangent = vertex_attributes_1.bitangent;
  outputValue_2.haloSizeInPixels = ((vertex_attributes_1.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_7;
    tmpvar_7 = int((65535.0 * vertex_attributes_1.deviceBufferIndex.x));
    highp mat4 matrixOut_8;
    highp vec2 tmpvar_9;
    tmpvar_9.x = float(floatBufferTextureSize.width);
    tmpvar_9.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_10;
    tmpvar_10 = (1.0/(tmpvar_9));
    highp int textureWidth_11;
    textureWidth_11 = floatBufferTextureSize.width;
    highp int tmpvar_12;
    tmpvar_12 = (tmpvar_7 / textureWidth_11);
    highp float tmpvar_13;
    tmpvar_13 = ((float(
      (tmpvar_7 - (tmpvar_12 * textureWidth_11))
    ) + 0.5) / float(textureWidth_11));
    highp vec2 tmpvar_14;
    tmpvar_14.x = tmpvar_13;
    tmpvar_14.y = ((float(tmpvar_12) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, tmpvar_14);
    matrixOut_8[0] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_14.y;
    uvCoordinate_16.x = (tmpvar_13 + tmpvar_10.x);
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_10.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_8[1] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_14.y;
    uvCoordinate_19.x = (tmpvar_13 + (tmpvar_10.x * 2.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_10.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_8[2] = tmpvar_21;
    highp vec2 uvCoordinate_22;
    uvCoordinate_22.y = tmpvar_14.y;
    uvCoordinate_22.x = (tmpvar_13 + (tmpvar_10.x * 3.0));
    highp vec2 tmpvar_23;
    tmpvar_23.x = -1.0;
    tmpvar_23.y = tmpvar_10.y;
    uvCoordinate_22 = (uvCoordinate_22 + (vec2(float(
      (uvCoordinate_22.x >= 1.0)
    )) * tmpvar_23));
    lowp vec4 tmpvar_24;
    tmpvar_24 = texture (floatBufferTexture, uvCoordinate_22);
    matrixOut_8[3] = tmpvar_24;
    gl_Position = (matrixOut_8 * tmpvar_4);
  } else {
    gl_Position = (view.screenProjectionMatrix * gl_Position);
  };
  v_texture = outputValue_2.texture;
  v_color = outputValue_2.color;
  v_haloColor = outputValue_2.haloColor;
  v_alpha = outputValue_2.alpha;
  v_haloSizeInPixels = outputValue_2.haloSizeInPixels;
  v_tangent = outputValue_2.tangent;
  v_bitangent = outputValue_2.bitangent;
  v_dropShadowParams = outputValue_2.dropShadowParams;
  v_dropShadowColor = outputValue_2.dropShadowColor;
//SDFGlyph::sdfGlyphSuperSample_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in lowp vec4 v_color;
in lowp vec4 v_haloColor;
in highp float v_alpha;
in highp float v_haloSizeInPixels;
in highp vec2 v_tangent;
in highp vec2 v_bitangent;
in mediump vec4 v_dropShadowParams;
in mediump vec4 v_dropShadowColor;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
out lowp vec4 output_value;
void main ()
  mediump float sampleDistance_1;
  lowp float tmpvar_2;
  tmpvar_2 = texture (textureAtlas, v_texture).y;
  sampleDistance_1 = tmpvar_2;
  mediump vec2 tmpvar_3;
  tmpvar_3.x = dFdx(sampleDistance_1);
  tmpvar_3.y = dFdy(sampleDistance_1);
  mediump float tmpvar_4;
  tmpvar_4 = (0.75 * sqrt(dot (tmpvar_3, tmpvar_3)));
  mediump float tmpvar_5;
  tmpvar_5 = (0.5 - tmpvar_4);
  mediump float tmpvar_6;
  tmpvar_6 = clamp (((sampleDistance_1 - tmpvar_5) / (
    (0.5 + tmpvar_4)
   - tmpvar_5)), 0.0, 1.0);
  highp vec2 tmpvar_7;
  tmpvar_7 = ((dFdx(v_texture) + dFdy(v_texture)) * vec2((0.354 * glyphOptions.superSamplingKernelSize)));
  highp vec4 tmpvar_8;
  tmpvar_8.xy = (v_texture - tmpvar_7);
  tmpvar_8.zw = (v_texture + tmpvar_7);
  lowp vec4 tmpvar_9;
  tmpvar_9 = texture (textureAtlas, tmpvar_8.xy);
  mediump float sampelDistance_10;
  sampelDistance_10 = tmpvar_9.y;
  mediump float tmpvar_11;
  tmpvar_11 = (0.5 - tmpvar_4);
  mediump float tmpvar_12;
  tmpvar_12 = clamp (((sampelDistance_10 - tmpvar_11) / (
    (0.5 + tmpvar_4)
   - tmpvar_11)), 0.0, 1.0);
  lowp vec4 tmpvar_13;
  tmpvar_13 = texture (textureAtlas, tmpvar_8.zw);
  mediump float sampelDistance_14;
  sampelDistance_14 = tmpvar_13.y;
  mediump float tmpvar_15;
  tmpvar_15 = (0.5 - tmpvar_4);
  mediump float tmpvar_16;
  tmpvar_16 = clamp (((sampelDistance_14 - tmpvar_15) / (
    (0.5 + tmpvar_4)
   - tmpvar_15)), 0.0, 1.0);
  lowp vec4 tmpvar_17;
  tmpvar_17 = texture (textureAtlas, tmpvar_8.xw);
  mediump float sampelDistance_18;
  sampelDistance_18 = tmpvar_17.y;
  mediump float tmpvar_19;
  tmpvar_19 = (0.5 - tmpvar_4);
  mediump float tmpvar_20;
  tmpvar_20 = clamp (((sampelDistance_18 - tmpvar_19) / (
    (0.5 + tmpvar_4)
   - tmpvar_19)), 0.0, 1.0);
  lowp vec4 tmpvar_21;
  tmpvar_21 = texture (textureAtlas, tmpvar_8.zy);
  mediump float sampelDistance_22;
  sampelDistance_22 = tmpvar_21.y;
  mediump float tmpvar_23;
  tmpvar_23 = (0.5 - tmpvar_4);
  mediump float tmpvar_24;
  tmpvar_24 = clamp (((sampelDistance_22 - tmpvar_23) / (
    (0.5 + tmpvar_4)
   - tmpvar_23)), 0.0, 1.0);
  mediump vec4 tmpvar_25;
  tmpvar_25.xyz = v_color.xyz;
  tmpvar_25.w = (((
    (tmpvar_6 * (tmpvar_6 * (3.0 - (2.0 * tmpvar_6))))
   + 
    (0.5 * (((
      (tmpvar_12 * (tmpvar_12 * (3.0 - (2.0 * tmpvar_12))))
     + 
      (tmpvar_16 * (tmpvar_16 * (3.0 - (2.0 * tmpvar_16))))
    ) + (tmpvar_20 * 
      (tmpvar_20 * (3.0 - (2.0 * tmpvar_20)))
    )) + (tmpvar_24 * (tmpvar_24 * 
      (3.0 - (2.0 * tmpvar_24))
    ))))
  ) / 3.0) * v_color.w);
  output_value = tmpvar_25;
//SDFGlyph::sdfGlyph_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texture;
  highp vec2 alphaAndHaloSizeInPixels;
  mediump vec4 color;
  mediump vec4 haloColor;
  highp vec2 deviceBufferIndex;
  highp vec2 tangent;
  highp vec2 bitangent;
struct View {
  highp mat4 projectionMatrix;
  highp mat4 screenProjectionMatrix;
struct Options {
  highp int useDeviceBufferMatrix;
  highp float opacity;
struct DeviceBufferTextureSize {
  highp int width;
  highp int height;
struct VertexOut {
  highp vec2 texture;
  lowp vec4 color;
  lowp vec4 haloColor;
  highp float alpha;
  highp float haloSizeInPixels;
  highp vec2 tangent;
  highp vec2 bitangent;
  mediump vec4 dropShadowParams;
  mediump vec4 dropShadowColor;
in highp vec2 vertex_attributes_position;
in highp vec2 vertex_attributes_texture;
in highp vec2 vertex_attributes_alphaAndHaloSizeInPixels;
in mediump vec4 vertex_attributes_color;
in mediump vec4 vertex_attributes_haloColor;
in highp vec2 vertex_attributes_deviceBufferIndex;
in highp vec2 vertex_attributes_tangent;
in highp vec2 vertex_attributes_bitangent;
uniform View view;
uniform Options labelOptions;
uniform DeviceBufferTextureSize floatBufferTextureSize;
uniform sampler2D floatBufferTexture;
out highp vec2 v_texture;
out lowp vec4 v_color;
out lowp vec4 v_haloColor;
out highp float v_alpha;
out highp float v_haloSizeInPixels;
out highp vec2 v_tangent;
out highp vec2 v_bitangent;
out mediump vec4 v_dropShadowParams;
out mediump vec4 v_dropShadowColor;
void main ()
  VertexIn vertex_attributes_1;
  vertex_attributes_1.position = vertex_attributes_position;
  vertex_attributes_1.texture = vertex_attributes_texture;
  vertex_attributes_1.alphaAndHaloSizeInPixels = vertex_attributes_alphaAndHaloSizeInPixels;
  vertex_attributes_1.color = vertex_attributes_color;
  vertex_attributes_1.haloColor = vertex_attributes_haloColor;
  vertex_attributes_1.deviceBufferIndex = vertex_attributes_deviceBufferIndex;
  vertex_attributes_1.tangent = vertex_attributes_tangent;
  vertex_attributes_1.bitangent = vertex_attributes_bitangent;
  VertexOut outputValue_2;
  highp float alpha_3;
  alpha_3 = ((vertex_attributes_1.alphaAndHaloSizeInPixels.x / 65535.0) * labelOptions.opacity);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.x = vertex_attributes_1.position.x;
  tmpvar_4.y = vertex_attributes_1.position.y;
  gl_Position = tmpvar_4;
  outputValue_2.texture = vertex_attributes_1.texture;
  highp vec4 tmpvar_5;
  tmpvar_5.x = vertex_attributes_1.color.x;
  tmpvar_5.y = vertex_attributes_1.color.y;
  tmpvar_5.z = vertex_attributes_1.color.z;
  tmpvar_5.w = (vertex_attributes_1.color.w * alpha_3);
  outputValue_2.color = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.x = vertex_attributes_1.haloColor.x;
  tmpvar_6.y = vertex_attributes_1.haloColor.y;
  tmpvar_6.z = vertex_attributes_1.haloColor.z;
  tmpvar_6.w = (vertex_attributes_1.haloColor.w * alpha_3);
  outputValue_2.haloColor = tmpvar_6;
  outputValue_2.tangent = vertex_attributes_1.tangent;
  outputValue_2.bitangent = vertex_attributes_1.bitangent;
  outputValue_2.haloSizeInPixels = ((vertex_attributes_1.alphaAndHaloSizeInPixels.y - 32767.5) * 0.01);
  if (bool(labelOptions.useDeviceBufferMatrix)) {
    highp int tmpvar_7;
    tmpvar_7 = int((65535.0 * vertex_attributes_1.deviceBufferIndex.x));
    highp mat4 matrixOut_8;
    highp vec2 tmpvar_9;
    tmpvar_9.x = float(floatBufferTextureSize.width);
    tmpvar_9.y = float(floatBufferTextureSize.height);
    highp vec2 tmpvar_10;
    tmpvar_10 = (1.0/(tmpvar_9));
    highp int textureWidth_11;
    textureWidth_11 = floatBufferTextureSize.width;
    highp int tmpvar_12;
    tmpvar_12 = (tmpvar_7 / textureWidth_11);
    highp float tmpvar_13;
    tmpvar_13 = ((float(
      (tmpvar_7 - (tmpvar_12 * textureWidth_11))
    ) + 0.5) / float(textureWidth_11));
    highp vec2 tmpvar_14;
    tmpvar_14.x = tmpvar_13;
    tmpvar_14.y = ((float(tmpvar_12) + 0.5) / float(floatBufferTextureSize.height));
    lowp vec4 tmpvar_15;
    tmpvar_15 = texture (floatBufferTexture, tmpvar_14);
    matrixOut_8[0] = tmpvar_15;
    highp vec2 uvCoordinate_16;
    uvCoordinate_16.y = tmpvar_14.y;
    uvCoordinate_16.x = (tmpvar_13 + tmpvar_10.x);
    highp vec2 tmpvar_17;
    tmpvar_17.x = -1.0;
    tmpvar_17.y = tmpvar_10.y;
    uvCoordinate_16 = (uvCoordinate_16 + (vec2(float(
      (uvCoordinate_16.x >= 1.0)
    )) * tmpvar_17));
    lowp vec4 tmpvar_18;
    tmpvar_18 = texture (floatBufferTexture, uvCoordinate_16);
    matrixOut_8[1] = tmpvar_18;
    highp vec2 uvCoordinate_19;
    uvCoordinate_19.y = tmpvar_14.y;
    uvCoordinate_19.x = (tmpvar_13 + (tmpvar_10.x * 2.0));
    highp vec2 tmpvar_20;
    tmpvar_20.x = -1.0;
    tmpvar_20.y = tmpvar_10.y;
    uvCoordinate_19 = (uvCoordinate_19 + (vec2(float(
      (uvCoordinate_19.x >= 1.0)
    )) * tmpvar_20));
    lowp vec4 tmpvar_21;
    tmpvar_21 = texture (floatBufferTexture, uvCoordinate_19);
    matrixOut_8[2] = tmpvar_21;
    highp vec2 uvCoordinate_22;
    uvCoordinate_22.y = tmpvar_14.y;
    uvCoordinate_22.x = (tmpvar_13 + (tmpvar_10.x * 3.0));
    highp vec2 tmpvar_23;
    tmpvar_23.x = -1.0;
    tmpvar_23.y = tmpvar_10.y;
    uvCoordinate_22 = (uvCoordinate_22 + (vec2(float(
      (uvCoordinate_22.x >= 1.0)
    )) * tmpvar_23));
    lowp vec4 tmpvar_24;
    tmpvar_24 = texture (floatBufferTexture, uvCoordinate_22);
    matrixOut_8[3] = tmpvar_24;
    gl_Position = (matrixOut_8 * tmpvar_4);
  } else {
    gl_Position = (view.screenProjectionMatrix * gl_Position);
  };
  v_texture = outputValue_2.texture;
  v_color = outputValue_2.color;
  v_haloColor = outputValue_2.haloColor;
  v_alpha = outputValue_2.alpha;
  v_haloSizeInPixels = outputValue_2.haloSizeInPixels;
  v_tangent = outputValue_2.tangent;
  v_bitangent = outputValue_2.bitangent;
  v_dropShadowParams = outputValue_2.dropShadowParams;
  v_dropShadowColor = outputValue_2.dropShadowColor;
//SDFGlyph::sdfGlyphHalo_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Options {
  highp int isHalo;
  highp int maxHaloDistanceStored;
  highp int maxExtrusionDepth;
  highp int maxStrokeWidth;
  highp float superSamplingKernelSize;
in highp vec2 v_texture;
in lowp vec4 v_color;
in lowp vec4 v_haloColor;
in highp float v_alpha;
in highp float v_haloSizeInPixels;
in highp vec2 v_tangent;
in highp vec2 v_bitangent;
in mediump vec4 v_dropShadowParams;
in mediump vec4 v_dropShadowColor;
uniform Options glyphOptions;
uniform sampler2D textureAtlas;
out lowp vec4 output_value;
void main ()
  mediump float alpha_1;
  mediump vec3 color_2;
  mediump float innerEdgeExtent_3;
  mediump float haloEdge_4;
  mediump float strokeEdge_5;
  mediump float sampleDistance_6;
  lowp vec4 out_color_7;
  lowp float tmpvar_8;
  tmpvar_8 = texture (textureAtlas, v_texture).y;
  sampleDistance_6 = tmpvar_8;
  highp float tmpvar_9;
  tmpvar_9 = clamp (((
    (-(v_haloSizeInPixels) / float(glyphOptions.maxHaloDistanceStored))
   + 1.0) / 2.0), 0.0, 0.5);
  strokeEdge_5 = tmpvar_9;
  highp float tmpvar_10;
  tmpvar_10 = clamp (((
    (-((v_haloSizeInPixels + 2.0)) / float(glyphOptions.maxHaloDistanceStored))
   + 1.0) / 2.0), 0.0, 0.5);
  haloEdge_4 = tmpvar_10;
  highp float tmpvar_11;
  tmpvar_11 = (1.0/(float(glyphOptions.maxHaloDistanceStored)));
  innerEdgeExtent_3 = tmpvar_11;
  mediump float tmpvar_12;
  tmpvar_12 = (0.5 - innerEdgeExtent_3);
  mediump float tmpvar_13;
  tmpvar_13 = (0.5 + innerEdgeExtent_3);
  lowp vec3 tmpvar_14;
  tmpvar_14 = v_haloColor.xyz;
  color_2 = tmpvar_14;
  alpha_1 = 1.0;
  if (((sampleDistance_6 <= tmpvar_13) && (sampleDistance_6 >= haloEdge_4))) {
    if ((sampleDistance_6 <= strokeEdge_5)) {
      mediump float tmpvar_15;
      tmpvar_15 = clamp (((sampleDistance_6 - haloEdge_4) / (strokeEdge_5 - haloEdge_4)), 0.0, 1.0);
      alpha_1 = (tmpvar_15 * (tmpvar_15 * (3.0 - 
        (2.0 * tmpvar_15)
      )));
    } else {
      mediump float tmpvar_16;
      tmpvar_16 = clamp (((sampleDistance_6 - tmpvar_13) / (tmpvar_12 - tmpvar_13)), 0.0, 1.0);
      color_2 = mix (v_color.xyz, v_haloColor.xyz, vec3((tmpvar_16 * (tmpvar_16 * 
        (3.0 - (2.0 * tmpvar_16))
      ))));
    };
    mediump vec4 tmpvar_17;
    tmpvar_17.xyz = color_2;
    tmpvar_17.w = (alpha_1 * v_haloColor.w);
    out_color_7 = tmpvar_17;
  } else {
    out_color_7 = vec4(0.0, 0.0, 0.0, 0.0);
  };
  output_value = out_color_7;
//SimpleGrid::simpleGrid_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct GridView {
  highp mat4 gridView;
  highp vec4 color;
struct MajorMinorVertex {
  highp vec2 v_vertex;
in highp vec4 vertex_input_position;
uniform View view;
uniform GridView gridView;
out highp vec2 v_v_vertex;
void main ()
  MajorMinorVertex out_value_1;
  VertexIn vertex_input_2;
  vertex_input_2.position = vertex_input_position;
  highp vec4 tmpvar_3;
  tmpvar_3 = vertex_input_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  out_value_1.v_vertex = (gridView.gridView * tmpvar_3).xy;
  v_v_vertex = out_value_1.v_vertex;
//SimpleGrid::simpleGrid_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct GridView {
  highp mat4 gridView;
  highp vec4 color;
struct Style {
  highp vec2 invFwidth;
in highp vec2 v_v_vertex;
uniform GridView gridView;
uniform Style style;
out lowp vec4 output_value;
void main ()
  mediump vec2 f_1;
  lowp vec4 out_color_2;
  highp vec2 tmpvar_3;
  tmpvar_3 = (abs((
    fract(v_v_vertex)
   - vec2(0.5, 0.5))) * style.invFwidth);
  f_1 = tmpvar_3;
  mediump float tmpvar_4;
  tmpvar_4 = min (f_1.x, f_1.y);
  out_color_2.xyz = gridView.color.xyz;
  out_color_2.w = tmpvar_4;
  output_value = out_color_2;
//Sky::sky_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 vertexPosition;
struct Style {
  highp float skyStartOffset;
  highp vec4 horizon;
  highp vec4 color;
  highp float screenHeight;
struct VertexOut {
  lowp vec4 skyColor;
in highp vec2 vertexInput_vertexPosition;
uniform Style style;
out lowp vec4 v_skyColor;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.vertexPosition = vertexInput_vertexPosition;
  highp vec3 tmpvar_3;
  tmpvar_3.z = 1.0;
  tmpvar_3.x = vertexInput_2.vertexPosition.x;
  tmpvar_3.y = (style.skyStartOffset + (vertexInput_2.vertexPosition.y * (1.0 - style.skyStartOffset)));
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = (vec3(-1.0, -1.0, -1.0) + (vec3(2.0, 2.0, 2.0) * tmpvar_3));
  gl_Position = tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5 = mix (style.horizon, style.color, vec4(clamp ((
    (tmpvar_3.y - style.skyStartOffset)
   * 10.0), 0.0, 1.0)));
  outputValue_1.skyColor = tmpvar_5;
  v_skyColor = outputValue_1.skyColor;
//Sky::sky_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in lowp vec4 v_skyColor;
out lowp vec4 output_value;
void main ()
  output_value = v_skyColor;
//SolidRibbon::solidRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp vec4 pos_3;
  highp vec4 tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5.zw = vec2(0.0, 1.0);
  tmpvar_5.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  tmpvar_4 = (view.modelViewProjectionMatrix * tmpvar_5);
  pos_3.zw = tmpvar_4.zw;
  pos_3.xy = (tmpvar_4.xy + (style.offset * tmpvar_4.ww));
  gl_Position = pos_3;
  v_texCoord = outputValue_1.texCoord;
//SolidRibbon::solidRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
in highp vec2 v_texCoord;
uniform Style style;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = style.color;
  o_color_1 = tmpvar_2;
  mediump float tmpvar_3;
  highp float tmpvar_4;
  tmpvar_4 = dFdx(v_texCoord.y);
  highp float tmpvar_5;
  tmpvar_5 = dFdy(v_texCoord.y);
  highp float tmpvar_6;
  tmpvar_6 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_4 * tmpvar_4) + (tmpvar_5 * tmpvar_5)))
  )));
  tmpvar_3 = tmpvar_6;
  o_color_1.w = (o_color_1.w * textureLod (alphaTexture, v_texCoord, tmpvar_3).x);
  output_value = o_color_1;
//SolidRibbonAlpha::solidRibbonAlpha_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp vec4 pos_3;
  highp vec4 tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5.zw = vec2(0.0, 1.0);
  tmpvar_5.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  tmpvar_4 = (view.modelViewProjectionMatrix * tmpvar_5);
  pos_3.zw = tmpvar_4.zw;
  pos_3.xy = (tmpvar_4.xy + (style.offset * tmpvar_4.ww));
  gl_Position = pos_3;
  v_texCoord = outputValue_1.texCoord;
//SolidRibbonAlpha::solidRibbonAlpha_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
in highp vec2 v_texCoord;
uniform Style style;
uniform sampler2D alphaTexture;
inout lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = style.color;
  o_color_1 = tmpvar_2;
  mediump float tmpvar_3;
  highp float tmpvar_4;
  tmpvar_4 = dFdx(v_texCoord.y);
  highp float tmpvar_5;
  tmpvar_5 = dFdy(v_texCoord.y);
  highp float tmpvar_6;
  tmpvar_6 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_4 * tmpvar_4) + (tmpvar_5 * tmpvar_5)))
  )));
  tmpvar_3 = tmpvar_6;
  o_color_1.w = (o_color_1.w * textureLod (alphaTexture, v_texCoord, tmpvar_3).x);
  lowp vec4 tmpvar_7;
  tmpvar_7.xyz = output_value.xyz;
  tmpvar_7.w = min ((1.0 - o_color_1.w), output_value.w);
  output_value = tmpvar_7;
//SolidRibbonAlpha::solidRibbonAlpha_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp vec4 pos_3;
  highp vec4 tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5.zw = vec2(0.0, 1.0);
  tmpvar_5.xy = (vertexInput_2.position + ((
    (vertexInput_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  tmpvar_4 = (view.modelViewProjectionMatrix * tmpvar_5);
  pos_3.zw = tmpvar_4.zw;
  pos_3.xy = (tmpvar_4.xy + (style.offset * tmpvar_4.ww));
  gl_Position = pos_3;
  v_texCoord = outputValue_1.texCoord;
//SolidRibbonAlpha::solidRibbonAlphaFill_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
in highp vec2 v_texCoord;
uniform Style style;
out lowp vec4 output_value;
void main ()
  output_value = style.color;
//SolidTraffic::solidTraffic_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float uniDirectional;
  highp vec2 shiftDir;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp float halfWidth;
  highp float imageWidth;
  highp float zoomDependentShift;
  highp float drivingDirection;
  highp float sideOffset;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_uniDirectional;
in highp vec2 vertexInput_shiftDir;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.uniDirectional = vertexInput_uniDirectional;
  vertexInput_2.shiftDir = vertexInput_shiftDir;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp float styleDrivingDirection_3;
  styleDrivingDirection_3 = style.drivingDirection;
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = ((vertexInput_2.position + (vec2(
    (styleDrivingDirection_3 * (style.halfWidth * view.tilePerPoint))
  ) * 
    (vertexInput_2.normal * vec2(4.0, 4.0))
  )) + (vec2((
    ((styleDrivingDirection_3 * (1.0 - (style.zoomDependentShift * vertexInput_2.uniDirectional))) * style.sideOffset)
   * view.tilePerPoint)) * (vertexInput_2.shiftDir * vec2(4.0, 4.0))));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  v_texCoord = outputValue_1.texCoord;
//SolidTraffic::solidTraffic_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp float halfWidth;
  highp float imageWidth;
  highp float zoomDependentShift;
  highp float drivingDirection;
  highp float sideOffset;
in highp vec2 v_texCoord;
uniform Style style;
uniform sampler2D alphaTexture;
inout mediump vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 dst_2;
  dst_2 = output_value;
  highp vec4 tmpvar_3;
  tmpvar_3 = style.color;
  o_color_1 = tmpvar_3;
  mediump float tmpvar_4;
  highp float tmpvar_5;
  tmpvar_5 = dFdx(v_texCoord.y);
  highp float tmpvar_6;
  tmpvar_6 = dFdy(v_texCoord.y);
  highp float tmpvar_7;
  tmpvar_7 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_5 * tmpvar_5) + (tmpvar_6 * tmpvar_6)))
  )));
  tmpvar_4 = tmpvar_7;
  o_color_1.w = (o_color_1.w * textureLod (alphaTexture, v_texCoord, tmpvar_4).x);
  o_color_1.xyz = mix (dst_2.xyz, o_color_1.xyz, o_color_1.www);
  o_color_1.w = (((1.0 - dst_2.w) * o_color_1.w) + dst_2.w);
  output_value = o_color_1;
//SolidTraffic::solidTraffic_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float uniDirectional;
  highp vec2 shiftDir;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp float halfWidth;
  highp float imageWidth;
  highp float zoomDependentShift;
  highp float drivingDirection;
  highp float sideOffset;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_uniDirectional;
in highp vec2 vertexInput_shiftDir;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.uniDirectional = vertexInput_uniDirectional;
  vertexInput_2.shiftDir = vertexInput_shiftDir;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp float styleDrivingDirection_3;
  styleDrivingDirection_3 = style.drivingDirection;
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = ((vertexInput_2.position + (vec2(
    (styleDrivingDirection_3 * (style.halfWidth * view.tilePerPoint))
  ) * 
    (vertexInput_2.normal * vec2(4.0, 4.0))
  )) + (vec2((
    ((styleDrivingDirection_3 * (1.0 - (style.zoomDependentShift * vertexInput_2.uniDirectional))) * style.sideOffset)
   * view.tilePerPoint)) * (vertexInput_2.shiftDir * vec2(4.0, 4.0))));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  v_texCoord = outputValue_1.texCoord;
//SolidTraffic::solidMaskedTraffic_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp float halfWidth;
  highp float imageWidth;
  highp float zoomDependentShift;
  highp float drivingDirection;
  highp float sideOffset;
in highp vec2 v_texCoord;
uniform Style style;
uniform sampler2D alphaTexture;
inout mediump vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp float alpha_2;
  mediump float tmpvar_3;
  highp float tmpvar_4;
  tmpvar_4 = dFdx(v_texCoord.y);
  highp float tmpvar_5;
  tmpvar_5 = dFdy(v_texCoord.y);
  highp float tmpvar_6;
  tmpvar_6 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_4 * tmpvar_4) + (tmpvar_5 * tmpvar_5)))
  )));
  tmpvar_3 = tmpvar_6;
  alpha_2 = (textureLod (alphaTexture, v_texCoord, tmpvar_3).x * style.color.w);
  alpha_2 = (alpha_2 * (1.0 - output_value.w));
  highp vec3 tmpvar_7;
  tmpvar_7 = mix (output_value.xyz, style.color.xyz, vec3(alpha_2));
  o_color_1.xyz = tmpvar_7;
  o_color_1.w = (((1.0 - output_value.w) * alpha_2) + output_value.w);
  output_value = o_color_1;
//SpecularBuilding::specularBuilding_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndTexture;
  highp vec4 normalAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndTexture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.vertexAndTexture = vertex_input_vertexAndTexture;
  vertex_input_1.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_2;
  highp int tmpvar_3;
  tmpvar_3 = int(((vertex_input_1.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_2.normal = vertex_input_1.normalAndStyleIndex.xyz;
  outputValue_2.unlitColor = style.color[tmpvar_3];
  outputValue_2.shininess = style.shininessAndSpecularity[tmpvar_3].x;
  outputValue_2.specularity = style.shininessAndSpecularity[tmpvar_3].y;
  outputValue_2.position = (scale.tileOrigin + (scale.tileSize * vertex_input_1.vertexAndTexture.xyz));
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xy = outputValue_2.position.xy;
  tmpvar_4.z = (outputValue_2.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  outputValue_2.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_5;
  normal_5 = outputValue_2.normal;
  lowp vec3 lightContributions_6;
  highp vec3 tmpvar_7;
  tmpvar_7 = lightConfig.ambientLightColor.xyz;
  lightContributions_6 = tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_8) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_9) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_10) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = (outputValue_2.unlitColor.xyz * lightContributions_6);
  tmpvar_11.w = outputValue_2.unlitColor.w;
  outputValue_2.diffuseColor = tmpvar_11;
  highp float tmpvar_12;
  highp vec2 gradient_13;
  gradient_13 = gradient.equation[tmpvar_3];
  tmpvar_12 = ((gradient_13.x * outputValue_2.position.z) + gradient_13.y);
  outputValue_2.gradient = tmpvar_12;
  highp float tmpvar_14;
  tmpvar_14 = floor((vertex_input_1.vertexAndTexture.w * 256.0));
  highp vec2 tmpvar_15;
  tmpvar_15.x = tmpvar_14;
  tmpvar_15.y = floor(((
    (vertex_input_1.vertexAndTexture.w * 256.0)
   - tmpvar_14) * 256.0));
  outputValue_2.texture = floor((tmpvar_15 * vec2(style.textureCoordScale[tmpvar_3])));
  v_fogCoordinate = outputValue_2.fogCoordinate;
  v_fogColor = outputValue_2.fogColor;
  v_unlitColor = outputValue_2.unlitColor;
  v_diffuseColor = outputValue_2.diffuseColor;
  v_normal = outputValue_2.normal;
  v_position = outputValue_2.position;
  v_texture = outputValue_2.texture;
  v_gradient = outputValue_2.gradient;
  v_shininess = outputValue_2.shininess;
  v_specularity = outputValue_2.specularity;
  v_clipPosition = outputValue_2.clipPosition;
//SpecularBuilding::specularBuilding_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform LightConfiguration lightConfig;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = scale.scale;
  highp float tmpvar_2;
  tmpvar_2 = style.brightness;
  highp vec4 tmpvar_3;
  tmpvar_3 = lightConfig.lightDirection[uint(0)];
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp vec4 texturedColor_5;
  lowp float lowScale_6;
  lowScale_6 = tmpvar_1;
  lowp vec3 tmpvar_7;
  highp vec3 tmpvar_8;
  tmpvar_8 = (lightConfig.lightSpecularColor.xyz * vec3(((v_specularity * 
    pow (max (0.0, dot (normalize(
      (v_position - style.cameraPositionInTileSpace)
    ), normalize(
      (tmpvar_3.xyz - (2.0 * (dot (v_normal, tmpvar_3.xyz) * v_normal)))
    ))), v_shininess)
  ) * (
    (v_shininess + 8.0)
   / 25.13274))));
  tmpvar_7 = tmpvar_8;
  lowp float styleBrightness_9;
  styleBrightness_9 = tmpvar_2;
  lowp vec4 tmpvar_10;
  tmpvar_10.xyz = ((v_diffuseColor.xyz + tmpvar_7) * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_9), lowScale_6)));
  tmpvar_10.w = v_diffuseColor.w;
  lowp vec4 tmpvar_11;
  tmpvar_11 = (mix (v_unlitColor, tmpvar_10, vec4(lowScale_6)) * texture (textureSampler, v_texture));
  texturedColor_5.xyz = tmpvar_11.xyz;
  lowp float tmpvar_12;
  highp float tmpvar_13;
  tmpvar_13 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_12 = tmpvar_13;
  texturedColor_5.w = (tmpvar_11.w * tmpvar_12);
  output_value = texturedColor_5;
//SpecularBuildingPointyRoof::specularBuildingPointyRoof_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
  highp vec4 normalAndIsFacade;
struct Skyfog {
  highp vec4 fogSlope;
  highp float fogOffset;
  highp float screenHeight;
  highp float skyOffset;
  highp vec4 skyBottomColor;
  highp vec4 skyTopColor;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndStyleIndex;
in highp vec4 vertex_input_normalAndIsFacade;
uniform Skyfog skyfog;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_input_2;
  vertex_input_2.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  vertex_input_2.normalAndIsFacade = vertex_input_normalAndIsFacade;
  VertexOut outputValue_3;
  lowp float isFacade_4;
  highp int tmpvar_5;
  tmpvar_5 = int((65535.0 * vertex_input_2.vertexAndStyleIndex.w));
  highp float tmpvar_6;
  tmpvar_6 = vertex_input_2.normalAndIsFacade.w;
  isFacade_4 = tmpvar_6;
  outputValue_3.normal = vertex_input_2.normalAndIsFacade.xyz;
  highp vec4 tmpvar_7;
  tmpvar_7 = mix (style.alternateColor[tmpvar_5], style.color[tmpvar_5], vec4(isFacade_4));
  outputValue_3.unlitColor = tmpvar_7;
  outputValue_3.shininess = style.shininessAndSpecularity[tmpvar_5].x;
  outputValue_3.specularity = style.shininessAndSpecularity[tmpvar_5].y;
  outputValue_3.position = (scale.tileOrigin + (scale.tileSize * vertex_input_2.vertexAndStyleIndex.xyz));
  highp vec4 tmpvar_8;
  tmpvar_8.w = 1.0;
  tmpvar_8.xy = outputValue_3.position.xy;
  tmpvar_8.z = (outputValue_3.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_8);
  highp vec3 normal_9;
  normal_9 = outputValue_3.normal;
  lowp vec3 lightContributions_10;
  highp vec3 tmpvar_11;
  tmpvar_11 = lightConfig.ambientLightColor.xyz;
  lightContributions_10 = tmpvar_11;
  highp float tmpvar_12;
  tmpvar_12 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_9), 0.0, 1.0);
  lightContributions_10 = (lightContributions_10 + (vec3(tmpvar_12) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_13;
  tmpvar_13 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_9), 0.0, 1.0);
  lightContributions_10 = (lightContributions_10 + (vec3(tmpvar_13) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_14;
  tmpvar_14 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_9), 0.0, 1.0);
  lightContributions_10 = (lightContributions_10 + (vec3(tmpvar_14) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_15;
  tmpvar_15.xyz = (outputValue_3.unlitColor.xyz * lightContributions_10);
  tmpvar_15.w = outputValue_3.unlitColor.w;
  outputValue_3.diffuseColor = tmpvar_15;
  highp float tmpvar_16;
  highp vec2 gradient_17;
  gradient_17 = gradient.equation[tmpvar_5];
  tmpvar_16 = ((gradient_17.x * outputValue_3.position.z) + gradient_17.y);
  outputValue_3.gradient = tmpvar_16;
  outputValue_3.texture = vec2(0.0, 0.0);
  outputValue_1 = outputValue_3;
  highp vec4 tmpvar_18;
  tmpvar_18.w = 1.0;
  tmpvar_18.xyz = outputValue_3.position;
  outputValue_1.fogCoordinate = (style.fogFactor * (dot (skyfog.fogSlope, tmpvar_18) + skyfog.fogOffset));
  lowp vec4 tmpvar_19;
  highp vec4 tmpvar_20;
  tmpvar_20 = mix (skyfog.skyBottomColor, skyfog.skyTopColor, vec4(clamp ((
    ((0.5 + ((0.5 * gl_Position.y) / gl_Position.w)) - skyfog.skyOffset)
   * 10.0), 0.0, 1.0)));
  tmpvar_19 = tmpvar_20;
  outputValue_1.fogColor = tmpvar_19;
  v_fogCoordinate = outputValue_1.fogCoordinate;
  v_fogColor = outputValue_1.fogColor;
  v_unlitColor = outputValue_1.unlitColor;
  v_diffuseColor = outputValue_1.diffuseColor;
  v_normal = outputValue_1.normal;
  v_position = outputValue_1.position;
  v_texture = outputValue_1.texture;
  v_gradient = outputValue_1.gradient;
  v_shininess = outputValue_1.shininess;
  v_specularity = outputValue_1.specularity;
  v_clipPosition = outputValue_1.clipPosition;
//SpecularBuildingPointyRoof::specularBuildingPointyRoof_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform LightConfiguration lightConfig;
uniform Fade fade;
out lowp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = scale.scale;
  highp float tmpvar_2;
  tmpvar_2 = style.brightness;
  highp vec4 tmpvar_3;
  tmpvar_3 = lightConfig.lightDirection[uint(0)];
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp vec4 combinedColor_5;
  lowp float lowScale_6;
  lowScale_6 = tmpvar_1;
  lowp vec3 tmpvar_7;
  highp vec3 tmpvar_8;
  tmpvar_8 = (lightConfig.lightSpecularColor.xyz * vec3(((v_specularity * 
    pow (max (0.0, dot (normalize(
      (v_position - style.cameraPositionInTileSpace)
    ), normalize(
      (tmpvar_3.xyz - (2.0 * (dot (v_normal, tmpvar_3.xyz) * v_normal)))
    ))), v_shininess)
  ) * (
    (v_shininess + 8.0)
   / 25.13274))));
  tmpvar_7 = tmpvar_8;
  lowp float styleBrightness_9;
  styleBrightness_9 = tmpvar_2;
  lowp vec4 tmpvar_10;
  tmpvar_10.xyz = ((v_diffuseColor.xyz + tmpvar_7) * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_9), lowScale_6)));
  tmpvar_10.w = v_diffuseColor.w;
  lowp vec4 tmpvar_11;
  tmpvar_11 = mix (v_unlitColor, tmpvar_10, vec4(lowScale_6));
  combinedColor_5.xyz = tmpvar_11.xyz;
  lowp float tmpvar_12;
  highp float tmpvar_13;
  tmpvar_13 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_12 = tmpvar_13;
  combinedColor_5.w = (tmpvar_11.w * tmpvar_12);
  lowp vec4 color_14;
  highp vec4 tmpvar_15;
  tmpvar_15 = mix (combinedColor_5, v_fogColor, vec4(clamp (v_fogCoordinate, 0.0, 1.0)));
  color_14 = tmpvar_15;
  output_value = color_14;
//SpecularBuildingTop::specularBuildingTop_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_vertexAndStyleIndex;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.vertexAndStyleIndex = vertex_input_vertexAndStyleIndex;
  VertexOut outputValue_2;
  highp int tmpvar_3;
  tmpvar_3 = int((vertex_input_1.vertexAndStyleIndex.w * 256.0));
  outputValue_2.unlitColor = style.color[tmpvar_3];
  outputValue_2.shininess = style.shininessAndSpecularity[tmpvar_3].x;
  outputValue_2.specularity = style.shininessAndSpecularity[tmpvar_3].y;
  outputValue_2.normal = vec3(0.0, 0.0, 1.0);
  outputValue_2.position = (scale.tileOrigin + (scale.tileSize * vertex_input_1.vertexAndStyleIndex.xyz));
  outputValue_2.position.z = (outputValue_2.position.z * scale.scale);
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = outputValue_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  outputValue_2.clipPosition = (gl_Position.xyz / gl_Position.www);
  lowp vec3 lightContributions_5;
  highp vec3 tmpvar_6;
  tmpvar_6 = lightConfig.ambientLightColor.xyz;
  lightContributions_5 = tmpvar_6;
  highp float tmpvar_7;
  tmpvar_7 = clamp (lightConfig.lightDirection[0].z, 0.0, 1.0);
  lightContributions_5 = (lightContributions_5 + (vec3(tmpvar_7) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_8;
  tmpvar_8 = clamp (lightConfig.lightDirection[1].z, 0.0, 1.0);
  lightContributions_5 = (lightContributions_5 + (vec3(tmpvar_8) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (lightConfig.lightDirection[2].z, 0.0, 1.0);
  lightContributions_5 = (lightContributions_5 + (vec3(tmpvar_9) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_10;
  tmpvar_10.xyz = (outputValue_2.unlitColor.xyz * lightContributions_5);
  tmpvar_10.w = outputValue_2.unlitColor.w;
  outputValue_2.diffuseColor = tmpvar_10;
  if ((outputValue_2.position.z < 1e-08)) {
    highp float tmpvar_11;
    tmpvar_11 = mix (0.935, 1.0, scale.scale);
    outputValue_2.gradient = tmpvar_11;
  } else {
    highp float tmpvar_12;
    highp vec2 gradient_13;
    gradient_13 = gradient.equation[tmpvar_3];
    tmpvar_12 = ((gradient_13.x * outputValue_2.position.z) + gradient_13.y);
    outputValue_2.gradient = tmpvar_12;
  };
  outputValue_2.texture = vertex_input_1.vertexAndStyleIndex.xy;
  v_fogCoordinate = outputValue_2.fogCoordinate;
  v_fogColor = outputValue_2.fogColor;
  v_unlitColor = outputValue_2.unlitColor;
  v_diffuseColor = outputValue_2.diffuseColor;
  v_normal = outputValue_2.normal;
  v_position = outputValue_2.position;
  v_texture = outputValue_2.texture;
  v_gradient = outputValue_2.gradient;
  v_shininess = outputValue_2.shininess;
  v_specularity = outputValue_2.specularity;
  v_clipPosition = outputValue_2.clipPosition;
//SpecularBuildingTop::specularBuildingTop_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform LightConfiguration lightConfig;
uniform Fade fade;
out lowp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = scale.scale;
  highp float tmpvar_2;
  tmpvar_2 = style.brightness;
  highp vec4 tmpvar_3;
  tmpvar_3 = lightConfig.lightDirection[uint(0)];
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp vec4 c_5;
  lowp float lowScale_6;
  lowScale_6 = tmpvar_1;
  lowp vec3 tmpvar_7;
  highp vec3 tmpvar_8;
  tmpvar_8.xy = tmpvar_3.xy;
  tmpvar_8.z = -(tmpvar_3.z);
  highp vec3 tmpvar_9;
  tmpvar_9 = (lightConfig.lightSpecularColor.xyz * vec3((pow (
    max (0.0, dot (normalize((v_position - style.cameraPositionInTileSpace)), normalize(tmpvar_8)))
  , v_shininess) * (
    (v_shininess + 8.0)
   / 25.13274))));
  tmpvar_7 = tmpvar_9;
  lowp float styleBrightness_10;
  styleBrightness_10 = tmpvar_2;
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = ((v_diffuseColor.xyz + tmpvar_7) * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_10), lowScale_6)));
  tmpvar_11.w = v_diffuseColor.w;
  highp vec4 tmpvar_12;
  tmpvar_12 = mix (v_unlitColor, tmpvar_11, vec4(tmpvar_1));
  c_5 = tmpvar_12;
  lowp float tmpvar_13;
  highp float tmpvar_14;
  tmpvar_14 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_13 = tmpvar_14;
  c_5.w = (c_5.w * tmpvar_13);
  output_value = c_5;
//SpecularLandmark::specularLandmark_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 position;
  highp vec2 texture;
  highp vec4 normalAndStyleIndex;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct Gradient {
  highp vec2 equation[8];
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct VertexOut {
  highp float fogCoordinate;
  lowp vec4 fogColor;
  lowp vec4 unlitColor;
  lowp vec4 diffuseColor;
  highp vec3 normal;
  highp vec3 position;
  highp vec2 texture;
  lowp float gradient;
  highp float shininess;
  highp float specularity;
  highp vec3 clipPosition;
in highp vec4 vertex_input_position;
in highp vec2 vertex_input_texture;
in highp vec4 vertex_input_normalAndStyleIndex;
uniform View view;
uniform Scale scale;
uniform Style style;
uniform Gradient gradient;
uniform LightConfiguration lightConfig;
out highp float v_fogCoordinate;
out lowp vec4 v_fogColor;
out lowp vec4 v_unlitColor;
out lowp vec4 v_diffuseColor;
out highp vec3 v_normal;
out highp vec3 v_position;
out highp vec2 v_texture;
out lowp float v_gradient;
out highp float v_shininess;
out highp float v_specularity;
out highp vec3 v_clipPosition;
void main ()
  VertexIn vertex_input_1;
  vertex_input_1.position = vertex_input_position;
  vertex_input_1.texture = vertex_input_texture;
  vertex_input_1.normalAndStyleIndex = vertex_input_normalAndStyleIndex;
  VertexOut outputValue_2;
  highp int tmpvar_3;
  tmpvar_3 = int(((vertex_input_1.normalAndStyleIndex.w * 127.0) + 0.5));
  outputValue_2.normal = vertex_input_1.normalAndStyleIndex.xyz;
  outputValue_2.unlitColor = style.color[tmpvar_3];
  outputValue_2.shininess = style.shininessAndSpecularity[tmpvar_3].x;
  outputValue_2.specularity = style.shininessAndSpecularity[tmpvar_3].y;
  outputValue_2.position = (scale.tileOrigin + (scale.tileSize * vertex_input_1.position.xyz));
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xy = outputValue_2.position.xy;
  tmpvar_4.z = (outputValue_2.position.z * scale.scale);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  outputValue_2.clipPosition = (gl_Position.xyz / gl_Position.www);
  highp vec3 normal_5;
  normal_5 = outputValue_2.normal;
  lowp vec3 lightContributions_6;
  highp vec3 tmpvar_7;
  tmpvar_7 = lightConfig.ambientLightColor.xyz;
  lightContributions_6 = tmpvar_7;
  highp float tmpvar_8;
  tmpvar_8 = clamp (dot (lightConfig.lightDirection[0].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_8) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_9;
  tmpvar_9 = clamp (dot (lightConfig.lightDirection[1].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_9) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (lightConfig.lightDirection[2].xyz, normal_5), 0.0, 1.0);
  lightContributions_6 = (lightContributions_6 + (vec3(tmpvar_10) * lightConfig.lightColor[2].xyz));
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = (outputValue_2.unlitColor.xyz * lightContributions_6);
  tmpvar_11.w = outputValue_2.unlitColor.w;
  outputValue_2.diffuseColor = tmpvar_11;
  highp float tmpvar_12;
  highp vec2 gradient_13;
  gradient_13 = gradient.equation[tmpvar_3];
  tmpvar_12 = ((gradient_13.x * outputValue_2.position.z) + gradient_13.y);
  outputValue_2.gradient = tmpvar_12;
  outputValue_2.texture = vertex_input_1.texture;
  v_fogCoordinate = outputValue_2.fogCoordinate;
  v_fogColor = outputValue_2.fogColor;
  v_unlitColor = outputValue_2.unlitColor;
  v_diffuseColor = outputValue_2.diffuseColor;
  v_normal = outputValue_2.normal;
  v_position = outputValue_2.position;
  v_texture = outputValue_2.texture;
  v_gradient = outputValue_2.gradient;
  v_shininess = outputValue_2.shininess;
  v_specularity = outputValue_2.specularity;
  v_clipPosition = outputValue_2.clipPosition;
//SpecularLandmark::specularLandmark_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Scale {
  highp float scale;
  highp vec3 tileOrigin;
  highp vec3 tileSize;
struct Style {
  highp vec4 color[8];
  highp vec4 alternateColor[8];
  highp vec2 shininessAndSpecularity[8];
  highp float textureCoordScale[8];
  highp float textureLightness;
  highp float brightness;
  highp vec3 cameraPositionInTileSpace;
  highp float fogFactor;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Fade {
  highp vec2 fadeEquation;
  highp float alphaFactor;
in highp float v_fogCoordinate;
in lowp vec4 v_fogColor;
in lowp vec4 v_unlitColor;
in lowp vec4 v_diffuseColor;
in highp vec3 v_normal;
in highp vec3 v_position;
in highp vec3 v_clipPosition;
in highp vec2 v_texture;
in lowp float v_gradient;
in highp float v_shininess;
in highp float v_specularity;
uniform Scale scale;
uniform Style style;
uniform LightConfiguration lightConfig;
uniform Fade fade;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = scale.scale;
  highp float tmpvar_2;
  tmpvar_2 = style.brightness;
  highp vec4 tmpvar_3;
  tmpvar_3 = lightConfig.lightDirection[uint(0)];
  highp vec2 tmpvar_4;
  tmpvar_4 = fade.fadeEquation;
  lowp float textureLightness_5;
  textureLightness_5 = style.textureLightness;
  lowp vec4 texturedColor_6;
  lowp float lowScale_7;
  lowScale_7 = tmpvar_1;
  lowp vec3 tmpvar_8;
  highp vec3 tmpvar_9;
  tmpvar_9 = (lightConfig.lightSpecularColor.xyz * vec3(((v_specularity * 
    pow (max (0.0, dot (normalize(
      (v_position - style.cameraPositionInTileSpace)
    ), normalize(
      (tmpvar_3.xyz - (2.0 * (dot (v_normal, tmpvar_3.xyz) * v_normal)))
    ))), v_shininess)
  ) * (
    (v_shininess + 8.0)
   / 25.13274))));
  tmpvar_8 = tmpvar_9;
  lowp float styleBrightness_10;
  styleBrightness_10 = tmpvar_2;
  lowp vec4 tmpvar_11;
  tmpvar_11.xyz = ((v_diffuseColor.xyz + tmpvar_8) * vec3(mix (1.0, (
    min (v_gradient, 0.9799805)
   * styleBrightness_10), lowScale_7)));
  tmpvar_11.w = v_diffuseColor.w;
  lowp vec4 tmpvar_12;
  tmpvar_12 = (mix (v_unlitColor, tmpvar_11, vec4(lowScale_7)) * mix (texture (textureSampler, v_texture), vec4(1.0, 1.0, 1.0, 1.0), vec4(textureLightness_5)));
  texturedColor_6.xyz = tmpvar_12.xyz;
  lowp float tmpvar_13;
  highp float tmpvar_14;
  tmpvar_14 = clamp (((v_clipPosition.y * tmpvar_4.x) + tmpvar_4.y), fade.alphaFactor, 1.0);
  tmpvar_13 = tmpvar_14;
  texturedColor_6.w = (tmpvar_12.w * tmpvar_13);
  output_value = texturedColor_6;
//StyleTextureRibbon::styleTextureRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp vec2 styleTexture;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 halfWidthRange;
  highp float halfWidth;
  highp float imageWidth;
struct VertexOut {
  highp vec2 texCoord;
  mediump vec4 color;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp vec2 vertexInput_styleTexture;
uniform View view;
uniform Style style;
uniform sampler2D styleTexture;
out highp vec2 v_texCoord;
out mediump vec4 v_color;
void main ()
  mediump vec4 styleSample_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.texCoord = vertexInput_texCoord;
  vertexInput_3.styleTexture = vertexInput_styleTexture;
  lowp vec4 tmpvar_4;
  highp vec2 P_5;
  P_5 = vertexInput_3.styleTexture;
  tmpvar_4 = texture (styleTexture, P_5);
  styleSample_1 = tmpvar_4;
  highp vec2 tmpvar_6;
  tmpvar_6.x = 1.0;
  tmpvar_6.y = vertexInput_3.styleTexture.y;
  lowp vec4 tmpvar_7;
  tmpvar_7 = texture (styleTexture, tmpvar_6);
  outputValue_2.color = tmpvar_7;
  outputValue_2.texCoord = vertexInput_3.texCoord;
  highp vec4 tmpvar_8;
  tmpvar_8.zw = vec2(0.0, 1.0);
  tmpvar_8.xy = (vertexInput_3.position + ((vec2(
    (mix (style.halfWidthRange.x, style.halfWidthRange.y, styleSample_1.x) * view.tilePerPoint)
  ) * vertexInput_3.normal) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_8);
  v_texCoord = outputValue_2.texCoord;
  v_color = outputValue_2.color;
//StyleTextureRibbon::styleTextureRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec2 halfWidthRange;
  highp float halfWidth;
  highp float imageWidth;
in highp vec2 v_texCoord;
in mediump vec4 v_color;
uniform Style style;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  o_color_1 = v_color;
  mediump float tmpvar_2;
  highp float tmpvar_3;
  tmpvar_3 = dFdx(v_texCoord.y);
  highp float tmpvar_4;
  tmpvar_4 = dFdy(v_texCoord.y);
  highp float tmpvar_5;
  tmpvar_5 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_3 * tmpvar_3) + (tmpvar_4 * tmpvar_4)))
  )));
  tmpvar_2 = tmpvar_5;
  o_color_1.w = (o_color_1.w * textureLod (alphaTexture, v_texCoord, tmpvar_2).x);
  output_value = o_color_1;
//TextureAlphaMask::textureAlphaMask_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform View view;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//TextureAlphaMask::textureAlphaMask_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
in highp vec2 v_texcoord;
uniform Style style;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  lowp vec4 color_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = style.color;
  color_1 = tmpvar_2;
  color_1.w = (color_1.w * texture (textureMap, v_texcoord).w);
  output_value = color_1;
//Textured::texture_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform View view;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//Textured::texture_extended_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
in highp vec2 v_texcoord;
uniform Style style;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  output_value = (texture (textureMap, v_texcoord) * style.color);
//Textured::texture_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform View view;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//Textured::texture_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texcoord;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  output_value = texture (textureMap, v_texcoord);
//TexturedInnerShadowRibbon::texturedInnerShadowRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
struct Noise {
  highp vec4 offsetScale;
struct VertexOut {
  highp vec2 lineUV;
  highp vec2 tileUV;
in highp vec2 ribbonVertex_position;
in highp vec2 ribbonVertex_normal;
in highp vec2 ribbonVertex_texCoord;
uniform View view;
uniform Style style;
uniform Noise noise;
out highp vec2 v_lineUV;
out highp vec2 v_tileUV;
void main ()
  VertexOut vout_1;
  VertexIn ribbonVertex_2;
  ribbonVertex_2.position = ribbonVertex_position;
  ribbonVertex_2.normal = ribbonVertex_normal;
  ribbonVertex_2.texCoord = ribbonVertex_texCoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = (ribbonVertex_2.position + ((
    (ribbonVertex_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = tmpvar_3;
  highp vec4 tmpvar_5;
  tmpvar_5 = (view.modelViewProjectionMatrix * tmpvar_4);
  highp vec4 tmpvar_6;
  tmpvar_6.xy = (tmpvar_5.xy + (style.offset * tmpvar_5.ww));
  tmpvar_6.zw = tmpvar_5.zw;
  vout_1.lineUV = ribbonVertex_2.texCoord;
  vout_1.tileUV = (noise.offsetScale.xy + (noise.offsetScale.zw * tmpvar_3));
  gl_Position = tmpvar_6;
  v_lineUV = vout_1.lineUV;
  v_tileUV = vout_1.tileUV;
//TexturedInnerShadowRibbon::texturedInnerShadowRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
struct ShadowStyle {
  highp vec2 slopeOffset;
  highp vec2 coefficents;
in highp vec2 v_lineUV;
in highp vec2 v_tileUV;
uniform Style style;
uniform ShadowStyle shadowStyle;
uniform sampler2D modulated;
uniform sampler2D distanceField;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  lowp vec4 color_1;
  lowp float shadow_2;
  lowp vec2 coefficents_3;
  mediump vec2 slopeOffset_4;
  mediump float radius_5;
  mediump float tmpvar_6;
  highp float tmpvar_7;
  tmpvar_7 = dFdx(v_lineUV.y);
  highp float tmpvar_8;
  tmpvar_8 = dFdy(v_lineUV.y);
  highp float tmpvar_9;
  tmpvar_9 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_7 * tmpvar_7) + (tmpvar_8 * tmpvar_8)))
  )));
  tmpvar_6 = tmpvar_9;
  lowp float tmpvar_10;
  tmpvar_10 = (1.0 - textureLod (distanceField, v_lineUV, tmpvar_6).x);
  radius_5 = tmpvar_10;
  highp vec2 tmpvar_11;
  tmpvar_11 = shadowStyle.slopeOffset;
  slopeOffset_4 = tmpvar_11;
  highp vec2 tmpvar_12;
  tmpvar_12 = shadowStyle.coefficents;
  coefficents_3 = tmpvar_12;
  mediump float tmpvar_13;
  tmpvar_13 = clamp (((1.0 + 
    (slopeOffset_4.x * slopeOffset_4.y)
  ) - (radius_5 * slopeOffset_4.y)), 0.0, 1.0);
  shadow_2 = tmpvar_13;
  highp vec4 tmpvar_14;
  tmpvar_14 = style.color;
  color_1 = tmpvar_14;
  color_1.xyz = (color_1.xyz * (texture (modulated, v_tileUV).xyz * vec3(2.0, 2.0, 2.0)));
  color_1.w = (color_1.w * ((coefficents_3.x * shadow_2) + (coefficents_3.y * 
    (shadow_2 * shadow_2)
  )));
  color_1.w = (color_1.w * textureLod (alphaTexture, v_lineUV, tmpvar_6).x);
  output_value = color_1;
//TexturedSolidRibbon::texturedSolidRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
struct Noise {
  highp vec4 offsetScale;
struct VertexOut {
  highp vec2 lineUV;
  highp vec2 tileUV;
in highp vec2 ribbonVertex_position;
in highp vec2 ribbonVertex_normal;
in highp vec2 ribbonVertex_texCoord;
uniform View view;
uniform Style style;
uniform Noise noise;
out highp vec2 v_lineUV;
out highp vec2 v_tileUV;
void main ()
  VertexOut vout_1;
  VertexIn ribbonVertex_2;
  ribbonVertex_2.position = ribbonVertex_position;
  ribbonVertex_2.normal = ribbonVertex_normal;
  ribbonVertex_2.texCoord = ribbonVertex_texCoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = (ribbonVertex_2.position + ((
    (ribbonVertex_2.normal * vec2(style.halfWidth))
   * vec2(view.tilePerPoint)) * vec2(4.0, 4.0)));
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = tmpvar_3;
  highp vec4 tmpvar_5;
  tmpvar_5 = (view.modelViewProjectionMatrix * tmpvar_4);
  highp vec4 tmpvar_6;
  tmpvar_6.xy = (tmpvar_5.xy + (style.offset * tmpvar_5.ww));
  tmpvar_6.zw = tmpvar_5.zw;
  vout_1.lineUV = ribbonVertex_2.texCoord;
  vout_1.tileUV = (noise.offsetScale.xy + (noise.offsetScale.zw * tmpvar_3));
  gl_Position = tmpvar_6;
  v_lineUV = vout_1.lineUV;
  v_tileUV = vout_1.tileUV;
//TexturedSolidRibbon::texturedSolidRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec2 offset;
  highp float halfWidth;
  highp float imageWidth;
in highp vec2 v_lineUV;
in highp vec2 v_tileUV;
uniform Style style;
uniform sampler2D alphaTexture;
uniform sampler2D modulated;
out lowp vec4 output_value;
void main ()
  lowp vec4 color_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = style.color;
  color_1 = tmpvar_2;
  mediump float tmpvar_3;
  highp float tmpvar_4;
  tmpvar_4 = dFdx(v_lineUV.y);
  highp float tmpvar_5;
  tmpvar_5 = dFdy(v_lineUV.y);
  highp float tmpvar_6;
  tmpvar_6 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_4 * tmpvar_4) + (tmpvar_5 * tmpvar_5)))
  )));
  tmpvar_3 = tmpvar_6;
  lowp vec4 tmpvar_7;
  tmpvar_7.xyz = ((texture (modulated, v_tileUV).xxx * vec3(2.0, 2.0, 2.0)) * color_1.xyz);
  tmpvar_7.w = (color_1.w * textureLod (alphaTexture, v_lineUV, tmpvar_3).x);
  output_value = tmpvar_7;
//TextureWithBrightness::textureWithBrightness_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform View view;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//TextureWithBrightness::textureWithBrightness_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float brightness;
in highp vec2 v_texcoord;
uniform Style style;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  lowp vec4 color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (textureMap, v_texcoord);
  color_1.w = tmpvar_2.w;
  highp vec3 tmpvar_3;
  tmpvar_3 = vec3(style.brightness);
  color_1.xyz = (tmpvar_2.xyz * tmpvar_3);
  output_value = color_1;
//TextureWithReverseAlpha::textureWithReverseAlpha_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform View view;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//TextureWithReverseAlpha::textureWithReverseAlpha_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct ReverseAlpha {
  highp float alpha;
in highp vec2 v_texcoord;
uniform ReverseAlpha reverseAlpha;
uniform sampler2D textureMap;
inout lowp vec4 output_value;
void main ()
  mediump vec4 colorTexture_1;
  lowp vec4 last_2;
  highp vec4 tmpvar_3;
  tmpvar_3 = (output_value * vec4(reverseAlpha.alpha));
  last_2 = tmpvar_3;
  lowp vec4 tmpvar_4;
  tmpvar_4 = texture (textureMap, v_texcoord);
  colorTexture_1 = tmpvar_4;
  lowp vec3 tmpvar_5;
  tmpvar_5 = vec3((1.0 - last_2.w));
  mediump vec4 tmpvar_6;
  tmpvar_6.w = 1.0;
  tmpvar_6.xyz = ((colorTexture_1.xyz * tmpvar_5) + last_2.xyz);
  output_value = tmpvar_6;
//TrafficGlow::trafficGlow_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp float uniDirectional;
  highp vec2 shiftDir;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float pitchRatio;
  highp float zoomDependentShift;
  highp float drivingDirection;
  highp float sideOffset;
  highp float alphaFadeParam;
struct VertexOut {
  highp vec2 texCoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp float vertexInput_uniDirectional;
in highp vec2 vertexInput_shiftDir;
uniform View view;
uniform Style style;
out highp vec2 v_texCoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.texCoord = vertexInput_texCoord;
  vertexInput_2.uniDirectional = vertexInput_uniDirectional;
  vertexInput_2.shiftDir = vertexInput_shiftDir;
  outputValue_1.texCoord = vertexInput_2.texCoord;
  highp float styleDrivingDirection_3;
  styleDrivingDirection_3 = style.drivingDirection;
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 1.0);
  tmpvar_4.xy = ((vertexInput_2.position + (vec2(
    (styleDrivingDirection_3 * (style.halfWidth * view.tilePerPoint))
  ) * 
    (vertexInput_2.normal * vec2(4.0, 4.0))
  )) + (vec2((
    ((styleDrivingDirection_3 * (1.0 - (style.zoomDependentShift * vertexInput_2.uniDirectional))) * style.sideOffset)
   * view.tilePerPoint)) * (vertexInput_2.shiftDir * vec2(4.0, 4.0))));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_4);
  v_texCoord = outputValue_1.texCoord;
//TrafficGlow::trafficGlow_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float halfWidth;
  highp vec4 color;
  highp float pitchRatio;
  highp float zoomDependentShift;
  highp float drivingDirection;
  highp float sideOffset;
  highp float alphaFadeParam;
in highp vec2 v_texCoord;
uniform Style style;
inout lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp float alpha_2;
  lowp float dist_3;
  highp float tmpvar_4;
  tmpvar_4 = sqrt(dot (v_texCoord, v_texCoord));
  dist_3 = tmpvar_4;
  highp float tmpvar_5;
  tmpvar_5 = clamp (((1.0 - dist_3) * style.alphaFadeParam), 0.0, 1.0);
  alpha_2 = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6 = style.color;
  o_color_1 = tmpvar_6;
  o_color_1.w = (o_color_1.w * alpha_2);
  o_color_1.xyz = mix (output_value.xyz, o_color_1.xyz, o_color_1.www);
  o_color_1.w = (((1.0 - output_value.w) * o_color_1.w) + output_value.w);
  output_value = o_color_1;
//TransitLineRibbon::patternedTransitLine_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp vec2 styleTextureCoord;
  highp float normalOffsetMixFactor;
  highp float distance;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec2 halfWidthRange;
  highp vec2 normalOffsetRange;
  highp float imageWidth;
  highp float styleTextureColorPixelOffset;
struct PatternStyle {
  highp vec4 color;
  highp float halfWidth;
  highp float distanceMultiplier;
struct PatternedVertexOut {
  highp vec2 patternTextureCoord;
  highp vec2 alphaTextureCoord;
  mediump vec4 color;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp vec2 vertexInput_styleTextureCoord;
in highp float vertexInput_normalOffsetMixFactor;
in highp float vertexInput_distance;
uniform View view;
uniform Style style;
uniform PatternStyle patternStyle;
uniform sampler2D styleTexture;
out highp vec2 v_patternTextureCoord;
out highp vec2 v_alphaTextureCoord;
out mediump vec4 v_color;
void main ()
  mediump vec4 styleValue_1;
  PatternedVertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.texCoord = vertexInput_texCoord;
  vertexInput_3.styleTextureCoord = vertexInput_styleTextureCoord;
  vertexInput_3.normalOffsetMixFactor = vertexInput_normalOffsetMixFactor;
  vertexInput_3.distance = vertexInput_distance;
  outputValue_2.color = patternStyle.color;
  highp vec2 tmpvar_4;
  tmpvar_4.x = 0.5;
  tmpvar_4.y = (vertexInput_3.distance * patternStyle.distanceMultiplier);
  outputValue_2.patternTextureCoord = tmpvar_4;
  outputValue_2.alphaTextureCoord = vertexInput_3.texCoord;
  lowp vec4 tmpvar_5;
  highp vec2 P_6;
  P_6 = vertexInput_3.styleTextureCoord;
  tmpvar_5 = texture (styleTexture, P_6);
  styleValue_1 = tmpvar_5;
  highp vec4 tmpvar_7;
  tmpvar_7.zw = vec2(0.0, 1.0);
  tmpvar_7.xy = (vertexInput_3.position + ((vec2(
    ((patternStyle.halfWidth + (mix (
      mix (mix (style.normalOffsetRange.x, style.normalOffsetRange.y, styleValue_1.y), mix (style.normalOffsetRange.x, style.normalOffsetRange.y, styleValue_1.w), min (max (vertexInput_3.normalOffsetMixFactor, 0.0), 1.0))
    , 
      mix (style.normalOffsetRange.x, style.normalOffsetRange.y, styleValue_1.z)
    , 
      max (0.0, (abs(vertexInput_3.normalOffsetMixFactor) - 1.0))
    ) * vertexInput_3.texCoord.y)) * view.tilePerPoint)
  ) * vertexInput_3.normal) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_7);
  v_patternTextureCoord = outputValue_2.patternTextureCoord;
  v_alphaTextureCoord = outputValue_2.alphaTextureCoord;
  v_color = outputValue_2.color;
//TransitLineRibbon::patternedTransitLine_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec2 halfWidthRange;
  highp vec2 normalOffsetRange;
  highp float imageWidth;
  highp float styleTextureColorPixelOffset;
in highp vec2 v_patternTextureCoord;
in highp vec2 v_alphaTextureCoord;
in mediump vec4 v_color;
uniform Style style;
uniform sampler2D alphaTexture;
uniform sampler2D patternTexture;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  mediump float alpha_2;
  mediump float tmpvar_3;
  highp float tmpvar_4;
  tmpvar_4 = dFdx(v_alphaTextureCoord.y);
  highp float tmpvar_5;
  tmpvar_5 = dFdy(v_alphaTextureCoord.y);
  highp float tmpvar_6;
  tmpvar_6 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_4 * tmpvar_4) + (tmpvar_5 * tmpvar_5)))
  )));
  tmpvar_3 = tmpvar_6;
  lowp float tmpvar_7;
  tmpvar_7 = textureLod (alphaTexture, v_alphaTextureCoord, tmpvar_3).x;
  alpha_2 = tmpvar_7;
  highp vec2 tmpvar_8;
  tmpvar_8.x = v_patternTextureCoord.x;
  tmpvar_8.y = fract(v_patternTextureCoord.y);
  o_color_1 = v_color;
  o_color_1.w = (o_color_1.w * ((1.0 - texture (patternTexture, tmpvar_8).x) * alpha_2));
  output_value = o_color_1;
//TransitLineRibbon::transitLine_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 normal;
  highp vec2 texCoord;
  highp vec2 styleTextureCoord;
  highp float normalOffsetMixFactor;
  highp float distance;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec2 halfWidthRange;
  highp vec2 normalOffsetRange;
  highp float imageWidth;
  highp float styleTextureColorPixelOffset;
struct VertexOut {
  highp vec2 alphaTextureCoord;
  mediump vec4 color;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_normal;
in highp vec2 vertexInput_texCoord;
in highp vec2 vertexInput_styleTextureCoord;
in highp float vertexInput_normalOffsetMixFactor;
in highp float vertexInput_distance;
uniform View view;
uniform Style style;
uniform sampler2D styleTexture;
out highp vec2 v_alphaTextureCoord;
out mediump vec4 v_color;
void main ()
  mediump vec4 styleValue_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.texCoord = vertexInput_texCoord;
  vertexInput_3.styleTextureCoord = vertexInput_styleTextureCoord;
  vertexInput_3.normalOffsetMixFactor = vertexInput_normalOffsetMixFactor;
  vertexInput_3.distance = vertexInput_distance;
  highp vec2 tmpvar_4;
  tmpvar_4.x = (vertexInput_3.styleTextureCoord.x + style.styleTextureColorPixelOffset);
  tmpvar_4.y = vertexInput_3.styleTextureCoord.y;
  lowp vec4 tmpvar_5;
  tmpvar_5 = texture (styleTexture, tmpvar_4);
  outputValue_2.color = tmpvar_5;
  outputValue_2.alphaTextureCoord = vertexInput_3.texCoord;
  lowp vec4 tmpvar_6;
  highp vec2 P_7;
  P_7 = vertexInput_3.styleTextureCoord;
  tmpvar_6 = texture (styleTexture, P_7);
  styleValue_1 = tmpvar_6;
  highp vec4 tmpvar_8;
  tmpvar_8.zw = vec2(0.0, 1.0);
  tmpvar_8.xy = (vertexInput_3.position + ((vec2(
    ((mix (style.halfWidthRange.x, style.halfWidthRange.y, styleValue_1.x) + (mix (
      mix (mix (style.normalOffsetRange.x, style.normalOffsetRange.y, styleValue_1.y), mix (style.normalOffsetRange.x, style.normalOffsetRange.y, styleValue_1.w), min (max (vertexInput_3.normalOffsetMixFactor, 0.0), 1.0))
    , 
      mix (style.normalOffsetRange.x, style.normalOffsetRange.y, styleValue_1.z)
    , 
      max (0.0, (abs(vertexInput_3.normalOffsetMixFactor) - 1.0))
    ) * vertexInput_3.texCoord.y)) * view.tilePerPoint)
  ) * vertexInput_3.normal) * vec2(4.0, 4.0)));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_8);
  v_alphaTextureCoord = outputValue_2.alphaTextureCoord;
  v_color = outputValue_2.color;
//TransitLineRibbon::transitLine_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec2 halfWidthRange;
  highp vec2 normalOffsetRange;
  highp float imageWidth;
  highp float styleTextureColorPixelOffset;
in highp vec2 v_alphaTextureCoord;
in mediump vec4 v_color;
uniform Style style;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  o_color_1 = v_color;
  mediump float tmpvar_2;
  highp float tmpvar_3;
  tmpvar_3 = dFdx(v_alphaTextureCoord.y);
  highp float tmpvar_4;
  tmpvar_4 = dFdy(v_alphaTextureCoord.y);
  highp float tmpvar_5;
  tmpvar_5 = log2(max (1.0, (style.imageWidth * 
    sqrt(((tmpvar_3 * tmpvar_3) + (tmpvar_4 * tmpvar_4)))
  )));
  tmpvar_2 = tmpvar_5;
  o_color_1.w = (o_color_1.w * textureLod (alphaTexture, v_alphaTextureCoord, tmpvar_2).x);
  output_value = o_color_1;
//TransitNodeColorized::transitNodeColorized_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec4 color;
  highp vec4 secondarycolor;
  highp vec2 texcoord;
  highp vec2 brightness;
struct Settings {
  highp vec2 atlasSize;
  highp vec2 halfScreenSize;
struct VertexOut {
  highp vec2 texcoord;
  lowp vec4 color;
  lowp vec4 secondarycolor;
  mediump float brightness;
in highp vec2 vertexInput_position;
in highp vec4 vertexInput_color;
in highp vec4 vertexInput_secondarycolor;
in highp vec2 vertexInput_texcoord;
in highp vec2 vertexInput_brightness;
uniform Settings settings;
out highp vec2 v_texcoord;
out lowp vec4 v_color;
out lowp vec4 v_secondarycolor;
out mediump float v_brightness;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.color = vertexInput_color;
  vertexInput_2.secondarycolor = vertexInput_secondarycolor;
  vertexInput_2.texcoord = vertexInput_texcoord;
  vertexInput_2.brightness = vertexInput_brightness;
  outputValue_1.color = vertexInput_2.color;
  outputValue_1.secondarycolor = vertexInput_2.secondarycolor;
  outputValue_1.brightness = (vertexInput_2.brightness.x * 2.55);
  outputValue_1.texcoord = (vertexInput_2.texcoord / settings.atlasSize);
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = ((vertexInput_2.position / settings.halfScreenSize) - vec2(1.0, 1.0));
  gl_Position = tmpvar_3;
  v_texcoord = outputValue_1.texcoord;
  v_color = outputValue_1.color;
  v_secondarycolor = outputValue_1.secondarycolor;
  v_brightness = outputValue_1.brightness;
//TransitNodeColorized::transitNodeColorized_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texcoord;
in lowp vec4 v_color;
in lowp vec4 v_secondarycolor;
in mediump float v_brightness;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  lowp vec3 rgb_1;
  lowp float alpha_2;
  mediump vec4 tex_3;
  lowp vec4 tmpvar_4;
  tmpvar_4 = texture (textureMap, v_texcoord);
  tex_3 = tmpvar_4;
  mediump float tmpvar_5;
  tmpvar_5 = (v_color.w * tex_3.w);
  alpha_2 = tmpvar_5;
  mediump vec3 tmpvar_6;
  tmpvar_6 = mix ((v_color.xyz * tex_3.xxx), v_secondarycolor.xyz, tex_3.yyy);
  rgb_1 = tmpvar_6;
  mediump vec3 tmpvar_7;
  tmpvar_7 = mix ((rgb_1 * vec3((1.0 - 
    max (0.0, (1.0 - v_brightness))
  ))), vec3(1.0, 1.0, 1.0), vec3(max (0.0, (v_brightness - 1.0))));
  rgb_1 = tmpvar_7;
  lowp vec4 tmpvar_8;
  tmpvar_8.xyz = (rgb_1 * vec3(alpha_2));
  tmpvar_8.w = alpha_2;
  output_value = tmpvar_8;
//TransitNodeRGB::transitNodeRGB_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec4 color;
  highp vec4 secondarycolor;
  highp vec2 texcoord;
  highp vec2 brightness;
struct Settings {
  highp vec2 atlasSize;
  highp vec2 halfScreenSize;
struct VertexOut {
  highp vec2 texcoord;
  lowp float alpha;
  mediump float brightness;
in highp vec2 vertexInput_position;
in highp vec4 vertexInput_color;
in highp vec4 vertexInput_secondarycolor;
in highp vec2 vertexInput_texcoord;
in highp vec2 vertexInput_brightness;
uniform Settings settings;
out highp vec2 v_texcoord;
out lowp float v_alpha;
out mediump float v_brightness;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.color = vertexInput_color;
  vertexInput_2.secondarycolor = vertexInput_secondarycolor;
  vertexInput_2.texcoord = vertexInput_texcoord;
  vertexInput_2.brightness = vertexInput_brightness;
  outputValue_1.alpha = vertexInput_2.color.w;
  outputValue_1.brightness = (vertexInput_2.brightness.x * 2.55);
  outputValue_1.texcoord = (vertexInput_2.texcoord / settings.atlasSize);
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = ((vertexInput_2.position / settings.halfScreenSize) - vec2(1.0, 1.0));
  gl_Position = tmpvar_3;
  v_texcoord = outputValue_1.texcoord;
  v_alpha = outputValue_1.alpha;
  v_brightness = outputValue_1.brightness;
//TransitNodeRGB::transitNodeRGB_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texcoord;
in lowp float v_alpha;
in mediump float v_brightness;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  mediump vec4 tex0_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (textureMap, v_texcoord);
  tex0_1 = tmpvar_2;
  tex0_1.xyz = mix ((tex0_1.xyz * vec3((1.0 - 
    max (0.0, (1.0 - v_brightness))
  ))), tex0_1.www, vec3(max (0.0, (v_brightness - 1.0))));
  output_value = (tex0_1 * vec4(v_alpha));
//VenueWall::venueWall_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 styleIndices;
  highp vec2 quadSpaceCoordAndXTexCoord;
  highp vec4 tangents;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Gradient {
  highp vec2 equation[8];
struct Wall {
  highp vec4 color[16];
  highp float width[16];
  highp float baseHeight[16];
  highp float height[16];
  highp float normalMultiplier;
  highp float textureScale;
  highp float maximumTexCoord;
struct VertexOut {
  highp vec4 color;
  highp vec2 texCoord;
  lowp float gradient;
in highp vec2 vertexAttributes_position;
in highp vec2 vertexAttributes_styleIndices;
in highp vec2 vertexAttributes_quadSpaceCoordAndXTexCoord;
in highp vec4 vertexAttributes_tangents;
uniform View view;
uniform LightConfiguration lightConfig;
uniform Gradient gradient;
uniform Wall wall;
out highp vec4 v_color;
out highp vec2 v_texCoord;
out lowp float v_gradient;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexAttributes_2;
  vertexAttributes_2.position = vertexAttributes_position;
  vertexAttributes_2.styleIndices = vertexAttributes_styleIndices;
  vertexAttributes_2.quadSpaceCoordAndXTexCoord = vertexAttributes_quadSpaceCoordAndXTexCoord;
  vertexAttributes_2.tangents = vertexAttributes_tangents;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexAttributes_2.position;
  highp int tmpvar_4;
  tmpvar_4 = int((65535.0 * vertexAttributes_2.styleIndices.x));
  highp int tmpvar_5;
  tmpvar_5 = int((65535.0 * vertexAttributes_2.styleIndices.y));
  highp vec2 tmpvar_6;
  tmpvar_6 = vertexAttributes_2.tangents.xy;
  highp vec2 tmpvar_7;
  tmpvar_7 = vertexAttributes_2.tangents.zw;
  highp vec2 tmpvar_8;
  tmpvar_8.x = tmpvar_6.y;
  tmpvar_8.y = -(tmpvar_6.x);
  highp vec2 tmpvar_9;
  tmpvar_9.x = tmpvar_7.y;
  tmpvar_9.y = -(tmpvar_7.x);
  highp int tmpvar_10;
  tmpvar_10 = int((65535.0 * vertexAttributes_2.quadSpaceCoordAndXTexCoord.x));
  highp int tmpvar_11;
  tmpvar_11 = (tmpvar_10 / 256);
  highp float tmpvar_12;
  tmpvar_12 = (float(tmpvar_11) / 255.0);
  highp float tmpvar_13;
  tmpvar_13 = (float((tmpvar_10 - tmpvar_11)) / 255.0);
  highp float tmpvar_14;
  if ((tmpvar_13 > 0.5)) {
    tmpvar_14 = wall.height[tmpvar_4];
  } else {
    tmpvar_14 = wall.baseHeight[tmpvar_4];
  };
  highp float tmpvar_15;
  tmpvar_15 = wall.width[tmpvar_4];
  highp float tmpvar_16;
  tmpvar_16 = wall.width[tmpvar_5];
  highp float factor_17;
  factor_17 = 0.0;
  highp float tmpvar_18;
  tmpvar_18 = ((tmpvar_6.x * tmpvar_7.y) - (tmpvar_6.y * tmpvar_7.x));
  highp float tmpvar_19;
  tmpvar_19 = dot (tmpvar_7, tmpvar_7);
  highp float tmpvar_20;
  tmpvar_20 = float((dot (tmpvar_6, tmpvar_6) >= 0.08));
  highp float tmpvar_21;
  tmpvar_21 = float((tmpvar_19 >= 0.08));
  highp float tmpvar_22;
  tmpvar_22 = float((abs(tmpvar_18) >= 0.08));
  if ((((tmpvar_20 * tmpvar_21) * tmpvar_22) > 0.0)) {
    factor_17 = (((tmpvar_16 * tmpvar_19) - (tmpvar_15 * 
      dot (tmpvar_6, tmpvar_7)
    )) * (1.0/(tmpvar_18)));
    highp float tmpvar_23;
    tmpvar_23 = (abs(tmpvar_15) * 2.0);
    factor_17 = clamp (factor_17, -(tmpvar_23), tmpvar_23);
  };
  highp vec4 tmpvar_24;
  tmpvar_24.zw = vec2(0.0, 0.0);
  tmpvar_24.xy = ((tmpvar_8 * vec2(tmpvar_15)) + (tmpvar_6 * vec2(factor_17)));
  highp vec4 tmpvar_25;
  tmpvar_25.w = 0.0;
  tmpvar_25.xy = -(tmpvar_24.xy);
  tmpvar_25.z = tmpvar_14;
  highp vec4 tmpvar_26;
  tmpvar_26 = (tmpvar_3 + tmpvar_25);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_26);
  highp float tmpvar_27;
  highp vec2 gradient_28;
  gradient_28 = gradient.equation[tmpvar_4];
  tmpvar_27 = ((gradient_28.x * tmpvar_26.z) + gradient_28.y);
  outputValue_1.gradient = tmpvar_27;
  highp vec4 tmpvar_29;
  tmpvar_29 = wall.color[tmpvar_4];
  highp vec2 tmpvar_30;
  if ((tmpvar_12 > 0.5)) {
    tmpvar_30 = tmpvar_9;
  } else {
    tmpvar_30 = tmpvar_8;
  };
  highp vec3 tmpvar_31;
  tmpvar_31.z = 0.0;
  tmpvar_31.xy = (tmpvar_30 * vec2(wall.normalMultiplier));
  lowp vec3 lightContributions_32;
  highp vec3 tmpvar_33;
  tmpvar_33 = lightConfig.ambientLightColor.xyz;
  lightContributions_32 = tmpvar_33;
  highp float tmpvar_34;
  tmpvar_34 = clamp (dot (lightConfig.lightDirection[0].xyz, tmpvar_31), 0.0, 1.0);
  lightContributions_32 = (lightContributions_32 + (vec3(tmpvar_34) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_35;
  tmpvar_35 = clamp (dot (lightConfig.lightDirection[1].xyz, tmpvar_31), 0.0, 1.0);
  lightContributions_32 = (lightContributions_32 + (vec3(tmpvar_35) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_36;
  tmpvar_36 = clamp (dot (lightConfig.lightDirection[2].xyz, tmpvar_31), 0.0, 1.0);
  lightContributions_32 = (lightContributions_32 + (vec3(tmpvar_36) * lightConfig.lightColor[2].xyz));
  highp vec4 tmpvar_37;
  tmpvar_37.xyz = (tmpvar_29.xyz * lightContributions_32);
  tmpvar_37.w = tmpvar_29.w;
  outputValue_1.color = tmpvar_37;
  highp vec2 tmpvar_38;
  tmpvar_38.x = (vertexAttributes_2.quadSpaceCoordAndXTexCoord.y * wall.maximumTexCoord);
  tmpvar_38.y = tmpvar_14;
  outputValue_1.texCoord = (tmpvar_38 * vec2(wall.textureScale));
  v_color = outputValue_1.color;
  v_texCoord = outputValue_1.texCoord;
  v_gradient = outputValue_1.gradient;
//VenueWall::venueWall_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec4 v_color;
in highp vec2 v_texCoord;
in lowp float v_gradient;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  output_value = ((vec4(min (v_gradient, 0.9799805)) * v_color) * texture (textureSampler, v_texCoord));
//VenueWall::venueWallEndCap_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct EndCapVertexIn {
  highp vec2 position;
  highp vec2 styleIndices;
  highp vec2 quadSpaceCoord;
  highp vec4 tangents;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct Gradient {
  highp vec2 equation[8];
struct WallEndCap {
  highp vec4 color[16];
  highp float innerOffset[16];
  highp float outerOffset[16];
  highp float baseHeight[16];
  highp float height[16];
struct VertexOut {
  highp vec4 color;
  highp vec2 texCoord;
  lowp float gradient;
in highp vec2 vertexAttributes_position;
in highp vec2 vertexAttributes_styleIndices;
in highp vec2 vertexAttributes_quadSpaceCoord;
in highp vec4 vertexAttributes_tangents;
uniform View view;
uniform LightConfiguration lightConfig;
uniform Gradient gradient;
uniform WallEndCap wall;
out highp vec4 v_color;
out highp vec2 v_texCoord;
out lowp float v_gradient;
void main ()
  VertexOut outputValue_1;
  EndCapVertexIn vertexAttributes_2;
  vertexAttributes_2.position = vertexAttributes_position;
  vertexAttributes_2.styleIndices = vertexAttributes_styleIndices;
  vertexAttributes_2.quadSpaceCoord = vertexAttributes_quadSpaceCoord;
  vertexAttributes_2.tangents = vertexAttributes_tangents;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexAttributes_2.position;
  highp int tmpvar_4;
  tmpvar_4 = int((65535.0 * vertexAttributes_2.styleIndices.x));
  highp int tmpvar_5;
  tmpvar_5 = int((65535.0 * vertexAttributes_2.styleIndices.y));
  highp vec2 tmpvar_6;
  tmpvar_6 = vertexAttributes_2.tangents.xy;
  highp vec2 tmpvar_7;
  tmpvar_7 = vertexAttributes_2.tangents.zw;
  highp vec2 tmpvar_8;
  tmpvar_8.x = tmpvar_6.y;
  tmpvar_8.y = -(tmpvar_6.x);
  highp float tmpvar_9;
  tmpvar_9 = vertexAttributes_2.quadSpaceCoord.x;
  highp float tmpvar_10;
  if ((tmpvar_9 > 0.5)) {
    tmpvar_10 = wall.outerOffset[tmpvar_4];
  } else {
    tmpvar_10 = wall.innerOffset[tmpvar_4];
  };
  highp float tmpvar_11;
  if ((tmpvar_9 > 0.5)) {
    tmpvar_11 = wall.outerOffset[tmpvar_5];
  } else {
    tmpvar_11 = wall.innerOffset[tmpvar_5];
  };
  highp float tmpvar_12;
  tmpvar_12 = wall.height[tmpvar_4];
  highp float tmpvar_13;
  tmpvar_13 = wall.height[tmpvar_5];
  bool tmpvar_14;
  tmpvar_14 = (tmpvar_12 > tmpvar_13);
  highp float tmpvar_15;
  if (tmpvar_14) {
    tmpvar_15 = tmpvar_12;
  } else {
    tmpvar_15 = tmpvar_13;
  };
  highp float tmpvar_16;
  tmpvar_16 = wall.baseHeight[tmpvar_4];
  highp float tmpvar_17;
  tmpvar_17 = wall.baseHeight[tmpvar_5];
  highp float tmpvar_18;
  if ((tmpvar_12 > 0.0)) {
    tmpvar_18 = tmpvar_16;
  } else {
    tmpvar_18 = tmpvar_17;
  };
  highp float tmpvar_19;
  if ((tmpvar_13 > 0.0)) {
    tmpvar_19 = tmpvar_17;
  } else {
    tmpvar_19 = tmpvar_16;
  };
  highp float tmpvar_20;
  tmpvar_20 = min (tmpvar_19, tmpvar_18);
  highp float tmpvar_21;
  if ((vertexAttributes_2.quadSpaceCoord.y > 0.5)) {
    tmpvar_21 = tmpvar_15;
  } else {
    tmpvar_21 = tmpvar_20;
  };
  highp vec2 tmpvar_22;
  if (tmpvar_14) {
    tmpvar_22 = tmpvar_7;
  } else {
    tmpvar_22 = -(tmpvar_6);
  };
  highp vec3 tmpvar_23;
  tmpvar_23.z = 0.0;
  tmpvar_23.xy = tmpvar_22;
  highp float factor_24;
  factor_24 = 0.0;
  highp float tmpvar_25;
  tmpvar_25 = ((tmpvar_6.x * tmpvar_7.y) - (tmpvar_6.y * tmpvar_7.x));
  highp float tmpvar_26;
  tmpvar_26 = dot (tmpvar_7, tmpvar_7);
  highp float tmpvar_27;
  tmpvar_27 = float((dot (tmpvar_6, tmpvar_6) >= 0.08));
  highp float tmpvar_28;
  tmpvar_28 = float((tmpvar_26 >= 0.08));
  highp float tmpvar_29;
  tmpvar_29 = float((abs(tmpvar_25) >= 0.08));
  if ((((tmpvar_27 * tmpvar_28) * tmpvar_29) > 0.0)) {
    factor_24 = (((tmpvar_11 * tmpvar_26) - (tmpvar_10 * 
      dot (tmpvar_6, tmpvar_7)
    )) * (1.0/(tmpvar_25)));
    highp float tmpvar_30;
    tmpvar_30 = (abs(tmpvar_10) * 2.0);
    factor_24 = clamp (factor_24, -(tmpvar_30), tmpvar_30);
  };
  highp vec4 tmpvar_31;
  tmpvar_31.zw = vec2(0.0, 0.0);
  tmpvar_31.xy = ((tmpvar_8 * vec2(tmpvar_10)) + (tmpvar_6 * vec2(factor_24)));
  highp vec4 tmpvar_32;
  tmpvar_32.w = 0.0;
  tmpvar_32.xy = -(tmpvar_31.xy);
  tmpvar_32.z = tmpvar_21;
  highp vec4 tmpvar_33;
  tmpvar_33 = (tmpvar_3 + tmpvar_32);
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_33);
  highp int tmpvar_34;
  if (tmpvar_14) {
    tmpvar_34 = tmpvar_4;
  } else {
    tmpvar_34 = tmpvar_5;
  };
  highp float tmpvar_35;
  highp vec2 gradient_36;
  gradient_36 = gradient.equation[tmpvar_34];
  tmpvar_35 = ((gradient_36.x * tmpvar_33.z) + gradient_36.y);
  outputValue_1.gradient = tmpvar_35;
  highp vec4 tmpvar_37;
  tmpvar_37 = wall.color[tmpvar_4];
  lowp vec3 lightContributions_38;
  highp vec3 tmpvar_39;
  tmpvar_39 = lightConfig.ambientLightColor.xyz;
  lightContributions_38 = tmpvar_39;
  highp float tmpvar_40;
  tmpvar_40 = clamp (dot (lightConfig.lightDirection[0].xyz, tmpvar_23), 0.0, 1.0);
  lightContributions_38 = (lightContributions_38 + (vec3(tmpvar_40) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_41;
  tmpvar_41 = clamp (dot (lightConfig.lightDirection[1].xyz, tmpvar_23), 0.0, 1.0);
  lightContributions_38 = (lightContributions_38 + (vec3(tmpvar_41) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_42;
  tmpvar_42 = clamp (dot (lightConfig.lightDirection[2].xyz, tmpvar_23), 0.0, 1.0);
  lightContributions_38 = (lightContributions_38 + (vec3(tmpvar_42) * lightConfig.lightColor[2].xyz));
  highp vec4 tmpvar_43;
  tmpvar_43.xyz = (tmpvar_37.xyz * lightContributions_38);
  tmpvar_43.w = tmpvar_37.w;
  outputValue_1.color = tmpvar_43;
  outputValue_1.texCoord = vec2(0.0, 0.0);
  v_color = outputValue_1.color;
  v_texCoord = outputValue_1.texCoord;
  v_gradient = outputValue_1.gradient;
//VenueWall::venueWall_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec4 v_color;
in highp vec2 v_texCoord;
in lowp float v_gradient;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  output_value = ((vec4(min (v_gradient, 0.9799805)) * v_color) * texture (textureSampler, v_texCoord));
//VenueWall::venueWallTop_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 styleIndices;
  highp vec2 quadSpaceCoordAndXTexCoord;
  highp vec4 tangents;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct LightConfiguration {
  highp vec4 lightDirection[3];
  highp vec4 lightColor[3];
  highp vec4 lightSpecularColor;
  highp vec4 ambientLightColor;
struct WallTop {
  highp vec4 color[16];
  highp float innerOffset[16];
  highp float outerOffset[16];
  highp float height[16];
  highp float normalMultiplier;
  highp float textureScale;
  highp float maximumTexCoord;
struct VertexOut {
  highp vec4 color;
  highp vec2 texCoord;
  lowp float gradient;
in highp vec2 vertexAttributes_position;
in highp vec2 vertexAttributes_styleIndices;
in highp vec2 vertexAttributes_quadSpaceCoordAndXTexCoord;
in highp vec4 vertexAttributes_tangents;
uniform View view;
uniform LightConfiguration lightConfig;
uniform WallTop wall;
out highp vec4 v_color;
out highp vec2 v_texCoord;
out lowp float v_gradient;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexAttributes_2;
  vertexAttributes_2.position = vertexAttributes_position;
  vertexAttributes_2.styleIndices = vertexAttributes_styleIndices;
  vertexAttributes_2.quadSpaceCoordAndXTexCoord = vertexAttributes_quadSpaceCoordAndXTexCoord;
  vertexAttributes_2.tangents = vertexAttributes_tangents;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexAttributes_2.position;
  highp int tmpvar_4;
  tmpvar_4 = int((65535.0 * vertexAttributes_2.styleIndices.x));
  highp int tmpvar_5;
  tmpvar_5 = int((65535.0 * vertexAttributes_2.styleIndices.y));
  highp vec2 tmpvar_6;
  tmpvar_6 = vertexAttributes_2.tangents.xy;
  highp vec2 tmpvar_7;
  tmpvar_7 = vertexAttributes_2.tangents.zw;
  highp vec2 tmpvar_8;
  tmpvar_8.x = tmpvar_6.y;
  tmpvar_8.y = -(tmpvar_6.x);
  highp int tmpvar_9;
  tmpvar_9 = int((65535.0 * vertexAttributes_2.quadSpaceCoordAndXTexCoord.x));
  highp int tmpvar_10;
  tmpvar_10 = (tmpvar_9 / 256);
  highp vec2 tmpvar_11;
  tmpvar_11.x = (float(tmpvar_10) / 255.0);
  tmpvar_11.y = (float((tmpvar_9 - tmpvar_10)) / 255.0);
  highp float tmpvar_12;
  if ((tmpvar_11.y > 0.5)) {
    tmpvar_12 = wall.outerOffset[tmpvar_4];
  } else {
    tmpvar_12 = wall.innerOffset[tmpvar_4];
  };
  highp float tmpvar_13;
  if ((tmpvar_11.y > 0.5)) {
    tmpvar_13 = wall.outerOffset[tmpvar_5];
  } else {
    tmpvar_13 = wall.innerOffset[tmpvar_5];
  };
  highp float wallHeight_14;
  wallHeight_14 = wall.height[tmpvar_4];
  highp float factor_15;
  factor_15 = 0.0;
  highp float tmpvar_16;
  tmpvar_16 = ((tmpvar_6.x * tmpvar_7.y) - (tmpvar_6.y * tmpvar_7.x));
  highp float tmpvar_17;
  tmpvar_17 = dot (tmpvar_7, tmpvar_7);
  highp float tmpvar_18;
  tmpvar_18 = float((dot (tmpvar_6, tmpvar_6) >= 0.08));
  highp float tmpvar_19;
  tmpvar_19 = float((tmpvar_17 >= 0.08));
  highp float tmpvar_20;
  tmpvar_20 = float((abs(tmpvar_16) >= 0.08));
  if ((((tmpvar_18 * tmpvar_19) * tmpvar_20) > 0.0)) {
    factor_15 = (((tmpvar_13 * tmpvar_17) - (tmpvar_12 * 
      dot (tmpvar_6, tmpvar_7)
    )) * (1.0/(tmpvar_16)));
    highp float tmpvar_21;
    tmpvar_21 = (abs(tmpvar_12) * 2.0);
    factor_15 = clamp (factor_15, -(tmpvar_21), tmpvar_21);
  };
  highp vec4 tmpvar_22;
  tmpvar_22.zw = vec2(0.0, 0.0);
  tmpvar_22.xy = ((tmpvar_8 * vec2(tmpvar_12)) + (tmpvar_6 * vec2(factor_15)));
  highp vec4 tmpvar_23;
  tmpvar_23.w = 0.0;
  tmpvar_23.xy = -(tmpvar_22.xy);
  tmpvar_23.z = wallHeight_14;
  gl_Position = (view.modelViewProjectionMatrix * (tmpvar_3 + tmpvar_23));
  outputValue_1.gradient = 1.0;
  highp vec4 tmpvar_24;
  tmpvar_24 = wall.color[tmpvar_4];
  lowp vec3 lightContributions_25;
  highp vec3 tmpvar_26;
  tmpvar_26 = lightConfig.ambientLightColor.xyz;
  lightContributions_25 = tmpvar_26;
  highp float tmpvar_27;
  tmpvar_27 = clamp (lightConfig.lightDirection[0].z, 0.0, 1.0);
  lightContributions_25 = (lightContributions_25 + (vec3(tmpvar_27) * lightConfig.lightColor[0].xyz));
  highp float tmpvar_28;
  tmpvar_28 = clamp (lightConfig.lightDirection[1].z, 0.0, 1.0);
  lightContributions_25 = (lightContributions_25 + (vec3(tmpvar_28) * lightConfig.lightColor[1].xyz));
  highp float tmpvar_29;
  tmpvar_29 = clamp (lightConfig.lightDirection[2].z, 0.0, 1.0);
  lightContributions_25 = (lightContributions_25 + (vec3(tmpvar_29) * lightConfig.lightColor[2].xyz));
  highp vec4 tmpvar_30;
  tmpvar_30.xyz = (tmpvar_24.xyz * lightContributions_25);
  tmpvar_30.w = tmpvar_24.w;
  outputValue_1.color = tmpvar_30;
  highp vec2 tmpvar_31;
  tmpvar_31.x = (vertexAttributes_2.quadSpaceCoordAndXTexCoord.y * wall.maximumTexCoord);
  tmpvar_31.y = sqrt(dot (tmpvar_23, tmpvar_23));
  outputValue_1.texCoord = (tmpvar_31 * vec2(wall.textureScale));
  v_color = outputValue_1.color;
  v_texCoord = outputValue_1.texCoord;
  v_gradient = outputValue_1.gradient;
//VenueWall::venueWall_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec4 v_color;
in highp vec2 v_texCoord;
in lowp float v_gradient;
uniform sampler2D textureSampler;
out lowp vec4 output_value;
void main ()
  output_value = ((vec4(min (v_gradient, 0.9799805)) * v_color) * texture (textureSampler, v_texCoord));
//VenueWallShadow::venueWallShadow_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 styleIndices;
  highp vec2 quadSpaceCoordAndXTexCoord;
  highp vec4 tangents;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct WallShadow {
  highp vec4 color[16];
  highp vec2 direction[16];
struct VertexOut {
  highp vec4 color;
in highp vec2 vertexAttributes_position;
in highp vec2 vertexAttributes_styleIndices;
in highp vec2 vertexAttributes_quadSpaceCoordAndXTexCoord;
in highp vec4 vertexAttributes_tangents;
uniform View view;
uniform WallShadow wall;
out highp vec4 v_color;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexAttributes_2;
  vertexAttributes_2.position = vertexAttributes_position;
  vertexAttributes_2.styleIndices = vertexAttributes_styleIndices;
  vertexAttributes_2.quadSpaceCoordAndXTexCoord = vertexAttributes_quadSpaceCoordAndXTexCoord;
  vertexAttributes_2.tangents = vertexAttributes_tangents;
  highp int tmpvar_3;
  tmpvar_3 = int((65535.0 * vertexAttributes_2.styleIndices.x));
  highp int tmpvar_4;
  tmpvar_4 = int((65535.0 * vertexAttributes_2.quadSpaceCoordAndXTexCoord.x));
  highp int tmpvar_5;
  tmpvar_5 = (tmpvar_4 / 256);
  highp vec2 tmpvar_6;
  tmpvar_6.x = (float(tmpvar_5) / 255.0);
  tmpvar_6.y = (float((tmpvar_4 - tmpvar_5)) / 255.0);
  highp vec4 tmpvar_7;
  tmpvar_7.zw = vec2(0.0, 1.0);
  tmpvar_7.xy = (vertexAttributes_2.position + (tmpvar_6.xx * wall.direction[tmpvar_3]));
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_7);
  outputValue_1.color = wall.color[tmpvar_3];
  v_color = outputValue_1.color;
//VenueWallShadow::venueWallShadow_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec4 v_color;
out lowp vec4 output_value;
void main ()
  output_value = v_color;
//Venue3DStroke::verticalVenue3DStroke_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VerticalVertexIn {
  highp vec4 vertex1AndCorner;
  highp vec4 vertex2;
  highp vec4 styleIndices;
  highp vec4 tangents;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color[8];
  highp float halfStrokeWidth[8];
  highp float height[8];
  highp float baseHeight[8];
  highp float width[8];
  highp vec2 canvasSize;
struct VertexOut {
  highp float texCoord;
  lowp vec4 color;
in highp vec4 vertex_input_vertex1AndCorner;
in highp vec4 vertex_input_vertex2;
in highp vec4 vertex_input_styleIndices;
in highp vec4 vertex_input_tangents;
uniform View view;
uniform Style style;
out highp float v_texCoord;
out lowp vec4 v_color;
void main ()
  highp vec4 secondVertex_1;
  highp vec4 firstVertex_2;
  VertexOut outputValue_3;
  VerticalVertexIn vertex_input_4;
  vertex_input_4.vertex1AndCorner = vertex_input_vertex1AndCorner;
  vertex_input_4.vertex2 = vertex_input_vertex2;
  vertex_input_4.styleIndices = vertex_input_styleIndices;
  vertex_input_4.tangents = vertex_input_tangents;
  highp int tmpvar_5;
  tmpvar_5 = int((255.0 * vertex_input_4.styleIndices.x));
  highp int tmpvar_6;
  tmpvar_6 = int((255.0 * vertex_input_4.styleIndices.y));
  highp float tmpvar_7;
  tmpvar_7 = style.height[tmpvar_5];
  highp float tmpvar_8;
  tmpvar_8 = style.height[tmpvar_6];
  highp float tmpvar_9;
  tmpvar_9 = style.baseHeight[tmpvar_5];
  highp float tmpvar_10;
  tmpvar_10 = style.baseHeight[tmpvar_6];
  highp float tmpvar_11;
  if ((tmpvar_7 > 0.0)) {
    tmpvar_11 = tmpvar_9;
  } else {
    tmpvar_11 = tmpvar_10;
  };
  highp float tmpvar_12;
  if ((tmpvar_8 > 0.0)) {
    tmpvar_12 = tmpvar_10;
  } else {
    tmpvar_12 = tmpvar_9;
  };
  bool tmpvar_13;
  tmpvar_13 = (tmpvar_7 > tmpvar_8);
  highp int tmpvar_14;
  if (tmpvar_13) {
    tmpvar_14 = tmpvar_5;
  } else {
    tmpvar_14 = tmpvar_6;
  };
  highp float tmpvar_15;
  if (tmpvar_13) {
    tmpvar_15 = tmpvar_7;
  } else {
    tmpvar_15 = tmpvar_8;
  };
  highp float tmpvar_16;
  tmpvar_16 = min (tmpvar_11, tmpvar_12);
  outputValue_3.color = style.color[tmpvar_14];
  highp float tmpvar_17;
  tmpvar_17 = style.halfStrokeWidth[tmpvar_14];
  highp int tmpvar_18;
  tmpvar_18 = int((65535.0 * vertex_input_4.vertex1AndCorner.w));
  highp int tmpvar_19;
  tmpvar_19 = int((float(tmpvar_18) / 256.0));
  highp vec2 tmpvar_20;
  tmpvar_20.x = float(tmpvar_19);
  tmpvar_20.y = (float(tmpvar_18) - (float(tmpvar_19) * 256.0));
  bool tmpvar_21;
  tmpvar_21 = (tmpvar_20.x < 0.5);
  highp float tmpvar_22;
  tmpvar_22 = style.width[tmpvar_5];
  highp float tmpvar_23;
  tmpvar_23 = style.width[tmpvar_6];
  highp vec2 tmpvar_24;
  tmpvar_24 = vertex_input_4.tangents.xy;
  highp vec2 tmpvar_25;
  tmpvar_25 = vertex_input_4.tangents.zw;
  highp vec2 tmpvar_26;
  tmpvar_26.x = tmpvar_24.y;
  tmpvar_26.y = -(tmpvar_24.x);
  highp float factor_27;
  factor_27 = 0.0;
  highp float tmpvar_28;
  tmpvar_28 = ((tmpvar_24.x * tmpvar_25.y) - (tmpvar_24.y * tmpvar_25.x));
  highp float tmpvar_29;
  tmpvar_29 = dot (tmpvar_25, tmpvar_25);
  highp float tmpvar_30;
  tmpvar_30 = float((dot (tmpvar_24, tmpvar_24) >= 0.08));
  highp float tmpvar_31;
  tmpvar_31 = float((tmpvar_29 >= 0.08));
  highp float tmpvar_32;
  tmpvar_32 = float((abs(tmpvar_28) >= 0.08));
  if ((((tmpvar_30 * tmpvar_31) * tmpvar_32) > 0.0)) {
    factor_27 = (((tmpvar_23 * tmpvar_29) - (tmpvar_22 * 
      dot (tmpvar_24, tmpvar_25)
    )) * (1.0/(tmpvar_28)));
    highp float tmpvar_33;
    tmpvar_33 = (abs(tmpvar_22) * 2.0);
    factor_27 = clamp (factor_27, -(tmpvar_33), tmpvar_33);
  };
  highp vec4 tmpvar_34;
  tmpvar_34.zw = vec2(0.0, 0.0);
  tmpvar_34.xy = ((tmpvar_26 * vec2(tmpvar_22)) + (tmpvar_24 * vec2(factor_27)));
  highp vec4 tmpvar_35;
  tmpvar_35.w = 1.0;
  tmpvar_35.xyz = vertex_input_4.vertex1AndCorner.xyz;
  highp vec4 tmpvar_36;
  tmpvar_36 = (tmpvar_35 - tmpvar_34);
  firstVertex_2 = tmpvar_36;
  highp vec4 tmpvar_37;
  tmpvar_37.w = 1.0;
  tmpvar_37.xyz = vertex_input_4.vertex2.xyz;
  highp vec4 tmpvar_38;
  tmpvar_38 = (tmpvar_37 - tmpvar_34);
  secondVertex_1 = tmpvar_38;
  highp float tmpvar_39;
  if ((tmpvar_36.z > 0.5)) {
    tmpvar_39 = tmpvar_15;
  } else {
    tmpvar_39 = tmpvar_16;
  };
  firstVertex_2.z = tmpvar_39;
  highp float tmpvar_40;
  if ((tmpvar_38.z > 0.5)) {
    tmpvar_40 = tmpvar_15;
  } else {
    tmpvar_40 = tmpvar_16;
  };
  secondVertex_1.z = tmpvar_40;
  highp vec4 tmpvar_41;
  tmpvar_41 = (view.modelViewProjectionMatrix * firstVertex_2);
  highp vec4 tmpvar_42;
  tmpvar_42 = (view.modelViewProjectionMatrix * secondVertex_1);
  highp vec4 tmpvar_43;
  if (tmpvar_21) {
    tmpvar_43 = tmpvar_41;
  } else {
    tmpvar_43 = tmpvar_42;
  };
  highp vec4 p0_44;
  highp vec4 p1_45;
  highp vec4 tmpvar_46;
  tmpvar_46.zw = vec2(1.0, 1.0);
  tmpvar_46.xy = (style.canvasSize * vec2(0.5, 0.5));
  p0_44 = (((tmpvar_41 / tmpvar_41.wwww) + vec4(1.0, 1.0, 0.0, 0.0)) * tmpvar_46);
  p1_45 = (((tmpvar_42 / tmpvar_42.wwww) + vec4(1.0, 1.0, 0.0, 0.0)) * tmpvar_46);
  highp vec2 tmpvar_47;
  tmpvar_47.x = (p1_45.y - p0_44.y);
  tmpvar_47.y = (p0_44.x - p1_45.x);
  highp vec4 tmpvar_48;
  tmpvar_48.zw = vec2(0.0, 0.0);
  tmpvar_48.xy = (vec2((tmpvar_43.w * tmpvar_17)) * normalize(tmpvar_47));
  outputValue_3.texCoord = ((tmpvar_20.y * 2.0) - 1.0);
  gl_Position = (tmpvar_43 - (vec4(outputValue_3.texCoord) * (tmpvar_48 / tmpvar_46)));
  v_texCoord = outputValue_3.texCoord;
  v_color = outputValue_3.color;
//Venue3DStroke::venue3DStroke_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp float v_texCoord;
in lowp vec4 v_color;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  highp vec2 tmpvar_1;
  tmpvar_1.y = 0.0;
  tmpvar_1.x = v_texCoord;
  lowp vec4 tmpvar_2;
  tmpvar_2.xyz = v_color.xyz;
  tmpvar_2.w = (v_color.w * texture (alphaTexture, tmpvar_1).x);
  output_value = tmpvar_2;
//Venue3DStroke::horizontalVenue3DStroke_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct HorizontalVertexIn {
  highp vec4 vertex1AndCorner;
  highp vec4 vertex2;
  highp vec4 styleIndices;
  highp vec4 tangents;
  highp vec2 tangent3;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color[8];
  highp float halfStrokeWidth[8];
  highp float height[8];
  highp float baseHeight[8];
  highp float width[8];
  highp vec2 canvasSize;
struct VertexOut {
  highp float texCoord;
  lowp vec4 color;
in highp vec4 vertex_input_vertex1AndCorner;
in highp vec4 vertex_input_vertex2;
in highp vec4 vertex_input_styleIndices;
in highp vec4 vertex_input_tangents;
in highp vec2 vertex_input_tangent3;
uniform View view;
uniform Style style;
out highp float v_texCoord;
out lowp vec4 v_color;
void main ()
  highp vec4 secondVertex_1;
  highp vec4 firstVertex_2;
  VertexOut outputValue_3;
  HorizontalVertexIn vertex_input_4;
  vertex_input_4.vertex1AndCorner = vertex_input_vertex1AndCorner;
  vertex_input_4.vertex2 = vertex_input_vertex2;
  vertex_input_4.styleIndices = vertex_input_styleIndices;
  vertex_input_4.tangents = vertex_input_tangents;
  vertex_input_4.tangent3 = vertex_input_tangent3;
  highp int tmpvar_5;
  tmpvar_5 = int((255.0 * vertex_input_4.styleIndices.x));
  highp int tmpvar_6;
  tmpvar_6 = int((255.0 * vertex_input_4.styleIndices.y));
  highp int tmpvar_7;
  tmpvar_7 = int((255.0 * vertex_input_4.styleIndices.z));
  outputValue_3.color = style.color[tmpvar_6];
  highp float tmpvar_8;
  tmpvar_8 = style.height[tmpvar_6];
  highp float tmpvar_9;
  tmpvar_9 = style.halfStrokeWidth[tmpvar_6];
  highp int tmpvar_10;
  tmpvar_10 = int((65535.0 * vertex_input_4.vertex1AndCorner.w));
  highp int tmpvar_11;
  tmpvar_11 = int((float(tmpvar_10) / 256.0));
  highp vec2 tmpvar_12;
  tmpvar_12.x = float(tmpvar_11);
  tmpvar_12.y = (float(tmpvar_10) - (float(tmpvar_11) * 256.0));
  bool tmpvar_13;
  tmpvar_13 = (tmpvar_12.x < 0.5);
  highp int tmpvar_14;
  if (tmpvar_13) {
    tmpvar_14 = tmpvar_5;
  } else {
    tmpvar_14 = tmpvar_6;
  };
  highp float tmpvar_15;
  tmpvar_15 = style.width[tmpvar_14];
  highp int tmpvar_16;
  if (tmpvar_13) {
    tmpvar_16 = tmpvar_6;
  } else {
    tmpvar_16 = tmpvar_7;
  };
  highp float tmpvar_17;
  tmpvar_17 = style.width[tmpvar_16];
  highp vec2 tmpvar_18;
  if (tmpvar_13) {
    tmpvar_18 = vertex_input_4.tangents.xy;
  } else {
    tmpvar_18 = vertex_input_4.tangents.zw;
  };
  highp vec2 tmpvar_19;
  if (tmpvar_13) {
    tmpvar_19 = vertex_input_4.tangents.zw;
  } else {
    tmpvar_19 = vertex_input_4.tangent3;
  };
  highp vec2 tmpvar_20;
  tmpvar_20.x = tmpvar_18.y;
  tmpvar_20.y = -(tmpvar_18.x);
  highp float factor_21;
  factor_21 = 0.0;
  highp float tmpvar_22;
  tmpvar_22 = ((tmpvar_18.x * tmpvar_19.y) - (tmpvar_18.y * tmpvar_19.x));
  highp float tmpvar_23;
  tmpvar_23 = dot (tmpvar_19, tmpvar_19);
  highp float tmpvar_24;
  tmpvar_24 = float((dot (tmpvar_18, tmpvar_18) >= 0.08));
  highp float tmpvar_25;
  tmpvar_25 = float((tmpvar_23 >= 0.08));
  highp float tmpvar_26;
  tmpvar_26 = float((abs(tmpvar_22) >= 0.08));
  if ((((tmpvar_24 * tmpvar_25) * tmpvar_26) > 0.0)) {
    factor_21 = (((tmpvar_17 * tmpvar_23) - (tmpvar_15 * 
      dot (tmpvar_18, tmpvar_19)
    )) * (1.0/(tmpvar_22)));
    highp float tmpvar_27;
    tmpvar_27 = (abs(tmpvar_15) * 2.0);
    factor_21 = clamp (factor_21, -(tmpvar_27), tmpvar_27);
  };
  highp vec4 tmpvar_28;
  tmpvar_28.zw = vec2(0.0, 0.0);
  tmpvar_28.xy = ((tmpvar_20 * vec2(tmpvar_15)) + (tmpvar_18 * vec2(factor_21)));
  highp vec4 tmpvar_29;
  tmpvar_29.w = 1.0;
  tmpvar_29.xyz = vertex_input_4.vertex1AndCorner.xyz;
  highp vec4 tmpvar_30;
  tmpvar_30 = (tmpvar_29 - tmpvar_28);
  firstVertex_2.xyw = tmpvar_30.xyw;
  firstVertex_2.z = (tmpvar_30.z * tmpvar_8);
  highp vec4 tmpvar_31;
  tmpvar_31.w = 1.0;
  tmpvar_31.xyz = vertex_input_4.vertex2.xyz;
  highp vec4 tmpvar_32;
  tmpvar_32 = (tmpvar_31 - tmpvar_28);
  secondVertex_1.xyw = tmpvar_32.xyw;
  secondVertex_1.z = (tmpvar_32.z * tmpvar_8);
  highp vec4 tmpvar_33;
  tmpvar_33 = (view.modelViewProjectionMatrix * firstVertex_2);
  highp vec4 tmpvar_34;
  tmpvar_34 = (view.modelViewProjectionMatrix * secondVertex_1);
  highp vec4 tmpvar_35;
  if (tmpvar_13) {
    tmpvar_35 = tmpvar_33;
  } else {
    tmpvar_35 = tmpvar_34;
  };
  highp vec4 p0_36;
  highp vec4 p1_37;
  highp vec4 tmpvar_38;
  tmpvar_38.zw = vec2(1.0, 1.0);
  tmpvar_38.xy = (style.canvasSize * vec2(0.5, 0.5));
  p0_36 = (((tmpvar_33 / tmpvar_33.wwww) + vec4(1.0, 1.0, 0.0, 0.0)) * tmpvar_38);
  p1_37 = (((tmpvar_34 / tmpvar_34.wwww) + vec4(1.0, 1.0, 0.0, 0.0)) * tmpvar_38);
  highp vec2 tmpvar_39;
  tmpvar_39.x = (p1_37.y - p0_36.y);
  tmpvar_39.y = (p0_36.x - p1_37.x);
  highp vec4 tmpvar_40;
  tmpvar_40.zw = vec2(0.0, 0.0);
  tmpvar_40.xy = (vec2((tmpvar_35.w * tmpvar_9)) * normalize(tmpvar_39));
  outputValue_3.texCoord = ((tmpvar_12.y * 2.0) - 1.0);
  gl_Position = (tmpvar_35 - (vec4(outputValue_3.texCoord) * (tmpvar_40 / tmpvar_38)));
  v_texCoord = outputValue_3.texCoord;
  v_color = outputValue_3.color;
//Venue3DStroke::venue3DStroke_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp float v_texCoord;
in lowp vec4 v_color;
uniform sampler2D alphaTexture;
out lowp vec4 output_value;
void main ()
  highp vec2 tmpvar_1;
  tmpvar_1.y = 0.0;
  tmpvar_1.x = v_texCoord;
  lowp vec4 tmpvar_2;
  tmpvar_2.xyz = v_color.xyz;
  tmpvar_2.w = (v_color.w * texture (alphaTexture, tmpvar_1).x);
  output_value = tmpvar_2;
//VenueOpenToBelowShadow::shadow_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexStyleIndicesAndTexture;
  highp vec4 tangents;
  highp float side;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 offset;
struct VertexOut {
  highp float alphaRamp;
in highp vec4 vertex_attributes_vertexStyleIndicesAndTexture;
in highp vec4 vertex_attributes_tangents;
in highp float vertex_attributes_side;
uniform View view;
uniform Style style;
out highp float v_alphaRamp;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.vertexStyleIndicesAndTexture = vertex_attributes_vertexStyleIndicesAndTexture;
  vertex_attributes_2.tangents = vertex_attributes_tangents;
  vertex_attributes_2.side = vertex_attributes_side;
  outputValue_1.alphaRamp = (style.color.w * (1.0 - vertex_attributes_2.side));
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertex_attributes_2.vertexStyleIndicesAndTexture.xy;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 0.0);
  tmpvar_4.xy = (vec2(vertex_attributes_2.side) * style.offset);
  gl_Position = (gl_Position + (tmpvar_4 * gl_Position.wwww));
  v_alphaRamp = outputValue_1.alphaRamp;
//VenueOpenToBelowShadow::shadow_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec2 offset;
in highp float v_alphaRamp;
uniform Style style;
out lowp vec4 output_value;
void main ()
  highp vec4 tmpvar_1;
  tmpvar_1.w = 1.0;
  tmpvar_1.xyz = style.color.xyz;
  output_value = tmpvar_1;
//VenueOpenToBelowShadow::shadow_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec4 vertexStyleIndicesAndTexture;
  highp vec4 tangents;
  highp float side;
struct View {
  highp mat4 modelViewProjectionMatrix;
  highp float tilePerPoint;
struct Style {
  highp vec4 color;
  highp vec2 offset;
struct VertexOut {
  highp float alphaRamp;
in highp vec4 vertex_attributes_vertexStyleIndicesAndTexture;
in highp vec4 vertex_attributes_tangents;
in highp float vertex_attributes_side;
uniform View view;
uniform Style style;
out highp float v_alphaRamp;
void main ()
  VertexOut outputValue_1;
  VertexIn vertex_attributes_2;
  vertex_attributes_2.vertexStyleIndicesAndTexture = vertex_attributes_vertexStyleIndicesAndTexture;
  vertex_attributes_2.tangents = vertex_attributes_tangents;
  vertex_attributes_2.side = vertex_attributes_side;
  outputValue_1.alphaRamp = (style.color.w * (1.0 - vertex_attributes_2.side));
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertex_attributes_2.vertexStyleIndicesAndTexture.xy;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  highp vec4 tmpvar_4;
  tmpvar_4.zw = vec2(0.0, 0.0);
  tmpvar_4.xy = (vec2(vertex_attributes_2.side) * style.offset);
  gl_Position = (gl_Position + (tmpvar_4 * gl_Position.wwww));
  v_alphaRamp = outputValue_1.alphaRamp;
//VenueOpenToBelowShadow::shadowAlpha_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp float v_alphaRamp;
inout lowp vec4 output_value;
void main ()
  lowp float oneMinusAlpha_1;
  highp float tmpvar_2;
  tmpvar_2 = (1.0 - v_alphaRamp);
  oneMinusAlpha_1 = tmpvar_2;
  lowp vec4 tmpvar_3;
  tmpvar_3.xyz = output_value.xyz;
  tmpvar_3.w = min (oneMinusAlpha_1, output_value.w);
  output_value = tmpvar_3;
.:?/
|?^tQ
Mb ?
A333?
UUUUUU
?333333
w"@G
+1@333333
?333333
3333
3333
zt?ff
C<@Av
C<@Av
C<@Av
C<@Av
C<@Av
.M;UU
?gf6?
33s=
333?333?
^8U)zj?@
Il&<
//EarthCorona::earthcorona_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexData {
  highp vec3 position;
struct Base {
  highp mat4 modelview;
  highp mat4 projection;
  highp float brightness;
  highp vec3 lightdirection;
  highp mat4 earthcoronamodelview;
  highp float horizondistance;
  highp float nightlightfade;
struct VertexOut {
  highp vec3 iDistance;
  highp float iIntensity;
in highp vec3 vertex_attributes_position;
uniform Base base;
out highp vec3 v_iDistance;
out highp float v_iIntensity;
void main ()
  highp float lz_1;
  highp vec3 p_2;
  VertexOut outputValue_3;
  VertexData vertex_attributes_4;
  vertex_attributes_4.position = vertex_attributes_position;
  highp vec3 tmpvar_5;
  tmpvar_5 = vertex_attributes_4.position;
  p_2.xy = tmpvar_5.xy;
  highp vec3 tmpvar_6;
  tmpvar_6.yz = vec2(0.0, 1.5);
  tmpvar_6.x = sqrt(dot (tmpvar_5, tmpvar_5));
  outputValue_3.iDistance = tmpvar_6;
  p_2.z = (tmpvar_5.z + (outputValue_3.iDistance.x / base.horizondistance));
  highp vec3 tmpvar_7;
  if ((outputValue_3.iDistance.x > 0.0)) {
    tmpvar_7 = (normalize(p_2) * outputValue_3.iDistance.xxx);
  } else {
    tmpvar_7 = p_2;
  };
  p_2 = tmpvar_7;
  highp vec3 tmpvar_8;
  tmpvar_8.z = 0.0;
  tmpvar_8.xy = tmpvar_7.xy;
  highp vec4 tmpvar_9;
  tmpvar_9.w = 0.0;
  tmpvar_9.xyz = base.lightdirection;
  highp vec3 tmpvar_10;
  tmpvar_10 = (base.modelview * tmpvar_9).xyz;
  lz_1 = (tmpvar_10.z * tmpvar_10.z);
  lz_1 = (lz_1 * lz_1);
  lz_1 = (lz_1 * lz_1);
  outputValue_3.iIntensity = clamp ((max (
    (1.0 - dot ((tmpvar_8 / outputValue_3.iDistance.xxx), (-(tmpvar_10) * vec3(3.0, 3.0, 3.0))))
  , 0.0) + (lz_1 * 0.7)), (1.0 - base.nightlightfade), 1.0);
  highp vec4 tmpvar_11;
  tmpvar_11.w = 1.0;
  tmpvar_11.xyz = tmpvar_7;
  gl_Position = (base.projection * (base.earthcoronamodelview * tmpvar_11));
  gl_Position.z = gl_Position.w;
  v_iDistance = outputValue_3.iDistance;
  v_iIntensity = outputValue_3.iIntensity;
//EarthCorona::earthcorona_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Base {
  highp mat4 modelview;
  highp mat4 projection;
  highp float brightness;
  highp vec3 lightdirection;
  highp mat4 earthcoronamodelview;
  highp float horizondistance;
  highp float nightlightfade;
in highp vec3 v_iDistance;
in highp float v_iIntensity;
uniform Base base;
uniform sampler2D textureMap0;
out mediump vec4 output_value;
void main ()
  mediump vec4 out_color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = textureProj (textureMap0, v_iDistance);
  out_color_1.xyz = (vec4(v_iIntensity) * tmpvar_2).xyz;
  out_color_1.w = base.brightness;
  output_value = out_color_1;
//EndOfWorld::endOfWorld_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexData {
  highp vec3 position;
  highp vec2 texcoord;
struct Element {
  highp mat4 modelview;
  highp float blend;
struct Shared {
  highp mat4 projection;
  highp float texscale;
struct VertexOut {
  highp vec2 iTextureCoord0;
in highp vec3 vertex_attributes_position;
in highp vec2 vertex_attributes_texcoord;
uniform Element element;
uniform Shared sharedConstants;
out highp vec2 v_iTextureCoord0;
void main ()
  VertexOut outputValue_1;
  VertexData vertex_attributes_2;
  vertex_attributes_2.position = vertex_attributes_position;
  vertex_attributes_2.texcoord = vertex_attributes_texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xyz = vertex_attributes_2.position;
  outputValue_1.iTextureCoord0 = (vertex_attributes_2.texcoord / vec2(sharedConstants.texscale));
  gl_Position = (sharedConstants.projection * (element.modelview * tmpvar_3));
  v_iTextureCoord0 = outputValue_1.iTextureCoord0;
//EndOfWorld::endOfWorld_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Element {
  highp mat4 modelview;
  highp float blend;
in highp vec2 v_iTextureCoord0;
uniform Element element;
uniform sampler2D textureMap0;
out mediump vec4 output_value;
void main ()
  mediump vec4 color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (textureMap0, v_iTextureCoord0);
  color_1.w = tmpvar_2.w;
  highp vec2 tmpvar_3;
  tmpvar_3.x = (v_iTextureCoord0.x / 7.5);
  tmpvar_3.y = (v_iTextureCoord0.y / 3.75);
  highp float tmpvar_4;
  tmpvar_4 = clamp ((element.blend * clamp (
    (2.0 - sqrt(dot (tmpvar_3, tmpvar_3)))
  , 0.0, 2.0)), 0.0, 1.0);
  color_1.xyz = vec3(1.0, 1.0, 1.0);
  color_1.w = (color_1.w * tmpvar_4);
  output_value = color_1;
//Flyover::flyover_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 texcoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct VertexOut {
  highp vec2 uv;
  lowp float atmosphere;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform sampler2D atmosphere;
out highp vec2 v_uv;
out lowp float v_atmosphere;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.texcoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.uv = tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = vertexInput_2.position;
  highp vec4 tmpvar_6;
  tmpvar_6 = (transform.modelview * tmpvar_5);
  highp vec2 horizon_7;
  horizon_7 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_8;
  tmpvar_8.y = 0.5;
  tmpvar_8.x = ((sqrt(
    dot (tmpvar_6.xyz, tmpvar_6.xyz)
  ) - horizon_7.x) / horizon_7.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_8).x;
  gl_Position = ((sharedConstants.projection * tmpvar_6) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  highp vec4 tmpvar_9;
  tmpvar_9.w = 1.0;
  tmpvar_9.xyz = vertexInput_2.position;
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_9);
  highp vec4 tmpvar_10;
  tmpvar_10.w = 1.0;
  tmpvar_10.xyz = vertexInput_2.position;
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_10);
  highp vec4 tmpvar_11;
  tmpvar_11.w = 1.0;
  tmpvar_11.xyz = vertexInput_2.position;
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_11);
  highp vec4 tmpvar_12;
  tmpvar_12.w = 1.0;
  tmpvar_12.xyz = vertexInput_2.position;
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_12);
  highp vec4 tmpvar_13;
  tmpvar_13.w = 1.0;
  tmpvar_13.xyz = vertexInput_2.position;
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_13);
  highp vec4 tmpvar_14;
  tmpvar_14.w = 1.0;
  tmpvar_14.xyz = vertexInput_2.position;
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_14);
  v_uv = outputValue_1.uv;
  v_atmosphere = outputValue_1.atmosphere;
//Flyover::flyover_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
in highp vec2 v_uv;
in lowp float v_atmosphere;
uniform Shared sharedConstants;
uniform Material material;
uniform sampler2D diffuse;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (diffuse, v_uv);
  lowp float tmpvar_3;
  if ((tmpvar_2.x >= 0.04043579)) {
    tmpvar_3 = pow (((tmpvar_2.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_3 = (tmpvar_2.x / 12.92188);
  };
  lowp float tmpvar_4;
  if ((tmpvar_2.y >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_2.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_2.y / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_2.z >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_2.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_2.z / 12.92188);
  };
  lowp vec4 tmpvar_6;
  tmpvar_6.x = tmpvar_3;
  tmpvar_6.y = tmpvar_4;
  tmpvar_6.z = tmpvar_5;
  tmpvar_6.w = tmpvar_2.w;
  o_color_1.xyz = (tmpvar_6.xyz + (vec3(v_atmosphere) * sharedConstants.atmospherecolor));
  o_color_1.w = (tmpvar_2.w * material.blendfactor);
  output_value = o_color_1;
//FlyoverBorder::flyoverBorder_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 merccoord;
  highp vec2 flyovercoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct VertexOut {
  highp vec2 satelliteuv;
  highp vec2 flyoveruv;
  highp vec2 blenduv;
  lowp float atmosphere;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_merccoord;
in highp vec2 vertexInput_flyovercoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform sampler2D atmosphere;
out highp vec2 v_satelliteuv;
out highp vec2 v_flyoveruv;
out highp vec2 v_blenduv;
out lowp float v_atmosphere;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.merccoord = vertexInput_merccoord;
  vertexInput_2.flyovercoord = vertexInput_flyovercoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.merccoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.satelliteuv = tmpvar_4;
  highp vec2 tmpvar_5;
  tmpvar_5.x = vertexInput_2.merccoord.x;
  tmpvar_5.y = (1.0 - vertexInput_2.merccoord.y);
  outputValue_1.blenduv = tmpvar_5;
  highp vec2 tmpvar_6;
  tmpvar_6.x = vertexInput_2.flyovercoord.x;
  tmpvar_6.y = (1.0 - vertexInput_2.flyovercoord.y);
  outputValue_1.flyoveruv = tmpvar_6;
  highp vec4 tmpvar_7;
  tmpvar_7.w = 1.0;
  tmpvar_7.xyz = vertexInput_2.position;
  highp vec4 tmpvar_8;
  tmpvar_8 = (transform.modelview * tmpvar_7);
  highp vec2 horizon_9;
  horizon_9 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_10;
  tmpvar_10.y = 0.5;
  tmpvar_10.x = ((sqrt(
    dot (tmpvar_8.xyz, tmpvar_8.xyz)
  ) - horizon_9.x) / horizon_9.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_10).x;
  gl_Position = ((sharedConstants.projection * tmpvar_8) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  highp vec4 tmpvar_11;
  tmpvar_11.w = 1.0;
  tmpvar_11.xyz = vertexInput_2.position;
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_11);
  highp vec4 tmpvar_12;
  tmpvar_12.w = 1.0;
  tmpvar_12.xyz = vertexInput_2.position;
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_12);
  highp vec4 tmpvar_13;
  tmpvar_13.w = 1.0;
  tmpvar_13.xyz = vertexInput_2.position;
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_13);
  highp vec4 tmpvar_14;
  tmpvar_14.w = 1.0;
  tmpvar_14.xyz = vertexInput_2.position;
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_14);
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = vertexInput_2.position;
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_15);
  highp vec4 tmpvar_16;
  tmpvar_16.w = 1.0;
  tmpvar_16.xyz = vertexInput_2.position;
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_16);
  v_satelliteuv = outputValue_1.satelliteuv;
  v_flyoveruv = outputValue_1.flyoveruv;
  v_blenduv = outputValue_1.blenduv;
  v_atmosphere = outputValue_1.atmosphere;
//FlyoverBorder::flyoverBorder_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
in highp vec2 v_satelliteuv;
in highp vec2 v_flyoveruv;
in highp vec2 v_blenduv;
in lowp float v_atmosphere;
uniform Shared sharedConstants;
uniform Material material;
uniform sampler2D satellite;
uniform sampler2D flyover;
uniform sampler2D blend;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  mediump float blend_value_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (satellite, v_satelliteuv);
  lowp float tmpvar_4;
  if ((tmpvar_3.x >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_3.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_3.x / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_3.y >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_3.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_3.y / 12.92188);
  };
  lowp float tmpvar_6;
  if ((tmpvar_3.z >= 0.04043579)) {
    tmpvar_6 = pow (((tmpvar_3.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_6 = (tmpvar_3.z / 12.92188);
  };
  lowp vec4 tmpvar_7;
  tmpvar_7.x = tmpvar_4;
  tmpvar_7.y = tmpvar_5;
  tmpvar_7.z = tmpvar_6;
  tmpvar_7.w = tmpvar_3.w;
  lowp vec4 tmpvar_8;
  tmpvar_8 = texture (flyover, v_flyoveruv);
  lowp float tmpvar_9;
  if ((tmpvar_8.x >= 0.04043579)) {
    tmpvar_9 = pow (((tmpvar_8.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_9 = (tmpvar_8.x / 12.92188);
  };
  lowp float tmpvar_10;
  if ((tmpvar_8.y >= 0.04043579)) {
    tmpvar_10 = pow (((tmpvar_8.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_10 = (tmpvar_8.y / 12.92188);
  };
  lowp float tmpvar_11;
  if ((tmpvar_8.z >= 0.04043579)) {
    tmpvar_11 = pow (((tmpvar_8.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_11 = (tmpvar_8.z / 12.92188);
  };
  lowp vec4 tmpvar_12;
  tmpvar_12.x = tmpvar_9;
  tmpvar_12.y = tmpvar_10;
  tmpvar_12.z = tmpvar_11;
  tmpvar_12.w = tmpvar_8.w;
  lowp float tmpvar_13;
  tmpvar_13 = texture (blend, v_blenduv).x;
  blend_value_2 = tmpvar_13;
  mediump vec4 tmpvar_14;
  tmpvar_14.w = 1.0;
  tmpvar_14.xyz = mix (tmpvar_7.xyz, tmpvar_12.xyz, vec3(blend_value_2));
  o_color_1 = tmpvar_14;
  o_color_1.xyz = (o_color_1.xyz + (vec3(v_atmosphere) * sharedConstants.atmospherecolor));
  o_color_1.w = (o_color_1.w * material.blendfactor);
  output_value = o_color_1;
//FlyoverBorderRibbon::flyoverBorderRibbon_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec4 offset;
  highp vec2 uv;
struct View {
  highp mat4 projection;
struct Tile {
  highp mat4 modelview;
struct Border {
  highp vec3 property;
struct VertexOut {
  highp vec4 uv;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec4 vertexInput_offset;
in highp vec2 vertexInput_uv;
uniform View view;
uniform Tile tile;
uniform Border border;
out highp vec4 v_uv;
void main ()
  highp vec4 p_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.offset = vertexInput_offset;
  vertexInput_3.uv = vertexInput_uv;
  highp vec4 tmpvar_4;
  tmpvar_4.y = 0.5;
  tmpvar_4.x = vertexInput_3.uv.x;
  tmpvar_4.z = (vertexInput_3.uv.x + (vertexInput_3.offset.w * border.property.x));
  tmpvar_4.w = (vertexInput_3.uv.y * border.property.z);
  outputValue_2.uv = tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = vertexInput_3.position;
  p_1.w = tmpvar_5.w;
  p_1.xyz = (tmpvar_5.xyz + (vertexInput_3.offset.xyz * vec3((vertexInput_3.offset.w * border.property.y))));
  p_1 = (tile.modelview * p_1);
  highp vec4 tmpvar_6;
  tmpvar_6.w = 0.0;
  tmpvar_6.xyz = vertexInput_3.normal;
  highp float tmpvar_7;
  tmpvar_7 = -((tile.modelview * tmpvar_6).z);
  highp float tmpvar_8;
  tmpvar_8 = (tmpvar_7 * tmpvar_7);
  highp float tmpvar_9;
  tmpvar_9 = (tmpvar_8 * tmpvar_8);
  highp float tmpvar_10;
  tmpvar_10 = (tmpvar_9 * tmpvar_9);
  highp vec4 tmpvar_11;
  tmpvar_11.xyz = (p_1.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_10))
   + 
    ((0.002 + (0.02 * tmpvar_10)) * -(p_1.z))
  )) * normalize(p_1.xyz)));
  tmpvar_11.w = p_1.w;
  gl_Position = (view.projection * tmpvar_11);
  v_uv = outputValue_2.uv;
//FlyoverBorderRibbon::flyoverBorderRibbon_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Color {
  highp vec4 primary;
  highp vec4 secondary;
in highp vec4 v_uv;
uniform Color color;
uniform sampler2D patternMap;
uniform sampler2D discMap;
inout lowp vec4 output_value;
void main ()
  lowp vec4 colors_1;
  highp vec2 uv_2;
  uv_2.x = v_uv.z;
  uv_2.y = (float(mod (v_uv.w, 1.0)));
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (patternMap, uv_2);
  lowp vec4 tmpvar_4;
  tmpvar_4 = texture (discMap, v_uv.xy);
  highp vec4 tmpvar_5;
  tmpvar_5 = mix (color.secondary, color.primary, tmpvar_3.xxxx);
  colors_1 = tmpvar_5;
  lowp float tmpvar_6;
  tmpvar_6 = (1.0 - mix (tmpvar_4.x, tmpvar_3.x, tmpvar_3.x));
  lowp vec4 tmpvar_7;
  tmpvar_7.xyz = mix (output_value.xyz, colors_1.xyz, vec3((colors_1.w * tmpvar_4.x)));
  tmpvar_7.w = tmpvar_6;
  output_value = mix (output_value, tmpvar_7, vec4(float((output_value.w >= tmpvar_6))));
//FlyoverFlat::flyoverFlat_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 texcoord;
  highp vec2 flatcoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct VertexOut {
  highp vec2 uv;
  mediump vec3 flatcolor;
  lowp float atmosphere;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_texcoord;
in highp vec2 vertexInput_flatcoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform sampler2D atmosphere;
uniform sampler2D colorlookup;
out highp vec2 v_uv;
flat out mediump vec3 v_flatcolor;
out lowp float v_atmosphere;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  vertexInput_2.flatcoord = vertexInput_flatcoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.texcoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.uv = tmpvar_4;
  lowp vec4 tmpvar_5;
  highp vec2 P_6;
  P_6 = vertexInput_2.flatcoord;
  tmpvar_5 = texture (colorlookup, P_6);
  outputValue_1.flatcolor = tmpvar_5.xyz;
  highp vec4 tmpvar_7;
  tmpvar_7.w = 1.0;
  tmpvar_7.xyz = vertexInput_2.position;
  highp vec4 tmpvar_8;
  tmpvar_8 = (transform.modelview * tmpvar_7);
  highp vec2 horizon_9;
  horizon_9 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_10;
  tmpvar_10.y = 0.5;
  tmpvar_10.x = ((sqrt(
    dot (tmpvar_8.xyz, tmpvar_8.xyz)
  ) - horizon_9.x) / horizon_9.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_10).x;
  gl_Position = ((sharedConstants.projection * tmpvar_8) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  highp vec4 tmpvar_11;
  tmpvar_11.w = 1.0;
  tmpvar_11.xyz = vertexInput_2.position;
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_11);
  highp vec4 tmpvar_12;
  tmpvar_12.w = 1.0;
  tmpvar_12.xyz = vertexInput_2.position;
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_12);
  highp vec4 tmpvar_13;
  tmpvar_13.w = 1.0;
  tmpvar_13.xyz = vertexInput_2.position;
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_13);
  highp vec4 tmpvar_14;
  tmpvar_14.w = 1.0;
  tmpvar_14.xyz = vertexInput_2.position;
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_14);
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = vertexInput_2.position;
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_15);
  highp vec4 tmpvar_16;
  tmpvar_16.w = 1.0;
  tmpvar_16.xyz = vertexInput_2.position;
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_16);
  v_uv = outputValue_1.uv;
  v_flatcolor = outputValue_1.flatcolor;
  v_atmosphere = outputValue_1.atmosphere;
//FlyoverFlat::flyoverFlat_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
struct FlatFactor {
  highp float factor;
in highp vec2 v_uv;
flat in mediump vec3 v_flatcolor;
in lowp float v_atmosphere;
uniform Shared sharedConstants;
uniform Material material;
uniform FlatFactor flatFactor;
uniform sampler2D diffuse;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (diffuse, v_uv);
  lowp float tmpvar_3;
  if ((tmpvar_2.x >= 0.04043579)) {
    tmpvar_3 = pow (((tmpvar_2.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_3 = (tmpvar_2.x / 12.92188);
  };
  lowp float tmpvar_4;
  if ((tmpvar_2.y >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_2.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_2.y / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_2.z >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_2.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_2.z / 12.92188);
  };
  lowp vec4 tmpvar_6;
  tmpvar_6.x = tmpvar_3;
  tmpvar_6.y = tmpvar_4;
  tmpvar_6.z = tmpvar_5;
  tmpvar_6.w = tmpvar_2.w;
  mediump vec4 tmpvar_7;
  tmpvar_7.w = 1.0;
  tmpvar_7.xyz = v_flatcolor;
  highp vec4 tmpvar_8;
  tmpvar_8 = mix (tmpvar_6, tmpvar_7, vec4(flatFactor.factor));
  o_color_1 = tmpvar_8;
  o_color_1.xyz = (o_color_1.xyz + (vec3(v_atmosphere) * sharedConstants.atmospherecolor));
  o_color_1.w = (o_color_1.w * material.blendfactor);
  output_value = o_color_1;
//FlyoverManeuver::flyoverManeuver_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec4 offset;
  highp vec2 uv;
struct View {
  highp mat4 projection;
struct Displacement {
  highp mat4 modelview;
  highp vec3 properties;
  highp vec4 color[4];
struct VertexOut {
  highp vec2 uv;
  lowp vec4 primary;
  lowp vec4 secondary;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec4 vertexInput_offset;
in highp vec2 vertexInput_uv;
uniform View view;
uniform Displacement displacement;
out highp vec2 v_uv;
out lowp vec4 v_primary;
out lowp vec4 v_secondary;
void main ()
  highp vec4 p_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.offset = vertexInput_offset;
  vertexInput_3.uv = vertexInput_uv;
  highp float tmpvar_4;
  tmpvar_4 = ((vertexInput_3.uv.y - displacement.properties.z) * 2.0);
  highp vec2 tmpvar_5;
  tmpvar_5.x = vertexInput_3.uv.x;
  tmpvar_5.y = (1.0 - vertexInput_3.uv.y);
  outputValue_2.uv = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6.w = 1.0;
  tmpvar_6.xyz = vertexInput_3.position;
  p_1.w = tmpvar_6.w;
  p_1.xyz = (tmpvar_6.xyz + (vertexInput_3.offset.xyz * vec3((vertexInput_3.uv.x * displacement.properties.x))));
  p_1 = (displacement.modelview * p_1);
  if (((tmpvar_4 * tmpvar_4) > 0.01)) {
    highp vec3 a_7;
    a_7 = vertexInput_3.normal;
    highp vec3 b_8;
    b_8 = vertexInput_3.offset.xyz;
    highp vec4 tmpvar_9;
    tmpvar_9.w = 0.0;
    tmpvar_9.xyz = normalize(((a_7.yzx * b_8.zxy) - (a_7.zxy * b_8.yzx)));
    p_1 = (p_1 + ((displacement.modelview * 
      (tmpvar_9 * vec4(tmpvar_4))
    ) * displacement.properties.xxxx));
  };
  highp float tmpvar_10;
  tmpvar_10 = (vertexInput_3.offset.w - displacement.properties.y);
  highp float tmpvar_11;
  tmpvar_11 = clamp ((tmpvar_10 * tmpvar_10), 0.0, 1.0);
  highp vec4 tmpvar_12;
  tmpvar_12 = mix (displacement.color[0], displacement.color[2], vec4(tmpvar_11));
  outputValue_2.primary = tmpvar_12;
  highp vec4 tmpvar_13;
  tmpvar_13 = mix (displacement.color[1], displacement.color[3], vec4(tmpvar_11));
  outputValue_2.secondary = tmpvar_13;
  highp vec4 tmpvar_14;
  tmpvar_14.w = 0.0;
  tmpvar_14.xyz = vertexInput_3.normal;
  highp float tmpvar_15;
  tmpvar_15 = -((displacement.modelview * tmpvar_14).z);
  highp float tmpvar_16;
  tmpvar_16 = (tmpvar_15 * tmpvar_15);
  highp float tmpvar_17;
  tmpvar_17 = (tmpvar_16 * tmpvar_16);
  highp float tmpvar_18;
  tmpvar_18 = (tmpvar_17 * tmpvar_17);
  highp vec4 tmpvar_19;
  tmpvar_19.xyz = (p_1.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_18))
   + 
    ((0.002 + (0.02 * tmpvar_18)) * -(p_1.z))
  )) * normalize(p_1.xyz)));
  tmpvar_19.w = p_1.w;
  gl_Position = (view.projection * tmpvar_19);
  v_uv = outputValue_2.uv;
  v_primary = outputValue_2.primary;
  v_secondary = outputValue_2.secondary;
//FlyoverManeuver::flyoverManeuver_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp float alpha;
in highp vec2 v_uv;
in lowp vec4 v_primary;
in lowp vec4 v_secondary;
uniform Style style;
uniform sampler2D textureMap;
inout lowp vec4 output_value;
void main ()
  mediump float distance_1;
  lowp float tmpvar_2;
  tmpvar_2 = texture (textureMap, v_uv).z;
  distance_1 = tmpvar_2;
  lowp float tmpvar_3;
  mediump float tmpvar_4;
  tmpvar_4 = clamp ((distance_1 * 48.0), 0.0, 1.0);
  tmpvar_3 = tmpvar_4;
  lowp float tmpvar_5;
  mediump float tmpvar_6;
  tmpvar_6 = clamp (((distance_1 * 12.0) - 1.0), 0.0, 1.0);
  tmpvar_5 = tmpvar_6;
  lowp vec3 tmpvar_7;
  tmpvar_7 = mix (mix (v_primary, v_secondary, vec4(tmpvar_3)).xyz, output_value.xyz, vec3(tmpvar_5));
  lowp float tmpvar_8;
  tmpvar_8 = max (output_value.w, (1.0 - tmpvar_5));
  highp vec4 tmpvar_9;
  tmpvar_9.xyz = mix (output_value.xyz, tmpvar_7, vec3(style.alpha));
  tmpvar_9.w = tmpvar_8;
  output_value = tmpvar_9;
//FlyoverMasked::flyoverMasked_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 texcoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct VertexOut {
  highp vec2 uv;
  lowp float atmosphere;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform sampler2D atmosphere;
out highp vec2 v_uv;
out lowp float v_atmosphere;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.texcoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.uv = tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = vertexInput_2.position;
  highp vec4 tmpvar_6;
  tmpvar_6 = (transform.modelview * tmpvar_5);
  highp vec2 horizon_7;
  horizon_7 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_8;
  tmpvar_8.y = 0.5;
  tmpvar_8.x = ((sqrt(
    dot (tmpvar_6.xyz, tmpvar_6.xyz)
  ) - horizon_7.x) / horizon_7.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_8).x;
  gl_Position = ((sharedConstants.projection * tmpvar_6) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  highp vec4 tmpvar_9;
  tmpvar_9.w = 1.0;
  tmpvar_9.xyz = vertexInput_2.position;
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_9);
  highp vec4 tmpvar_10;
  tmpvar_10.w = 1.0;
  tmpvar_10.xyz = vertexInput_2.position;
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_10);
  highp vec4 tmpvar_11;
  tmpvar_11.w = 1.0;
  tmpvar_11.xyz = vertexInput_2.position;
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_11);
  highp vec4 tmpvar_12;
  tmpvar_12.w = 1.0;
  tmpvar_12.xyz = vertexInput_2.position;
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_12);
  highp vec4 tmpvar_13;
  tmpvar_13.w = 1.0;
  tmpvar_13.xyz = vertexInput_2.position;
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_13);
  highp vec4 tmpvar_14;
  tmpvar_14.w = 1.0;
  tmpvar_14.xyz = vertexInput_2.position;
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_14);
  v_uv = outputValue_1.uv;
  v_atmosphere = outputValue_1.atmosphere;
//FlyoverMasked::flyoverMasked_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
in highp vec2 v_uv;
in lowp float v_atmosphere;
uniform Shared sharedConstants;
uniform Material material;
uniform sampler2D diffuse;
uniform sampler2D alphamask;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (alphamask, v_uv);
  if ((tmpvar_2.x < 0.5)) {
    discard;
  };
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (diffuse, v_uv);
  lowp float tmpvar_4;
  if ((tmpvar_3.x >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_3.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_3.x / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_3.y >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_3.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_3.y / 12.92188);
  };
  lowp float tmpvar_6;
  if ((tmpvar_3.z >= 0.04043579)) {
    tmpvar_6 = pow (((tmpvar_3.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_6 = (tmpvar_3.z / 12.92188);
  };
  lowp vec4 tmpvar_7;
  tmpvar_7.x = tmpvar_4;
  tmpvar_7.y = tmpvar_5;
  tmpvar_7.z = tmpvar_6;
  tmpvar_7.w = tmpvar_3.w;
  o_color_1.xyz = (tmpvar_7.xyz + (vec3(v_atmosphere) * sharedConstants.atmospherecolor));
  o_color_1.w = (tmpvar_3.w * material.blendfactor);
  output_value = o_color_1;
//FlyoverMorph::flyoverMorph_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp float morphX;
  highp vec2 finercoord;
  highp vec2 coarsecoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct Morph {
  highp vec2 coarseScale;
  highp vec2 coarseOffset;
  highp vec2 factor;
struct VertexOut {
  highp vec2 fineruv;
  highp vec2 coarseuv;
  lowp float atmosphere;
in highp vec3 vertexInput_position;
in highp float vertexInput_morphX;
in highp vec2 vertexInput_finercoord;
in highp vec2 vertexInput_coarsecoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform Morph morph;
uniform sampler2D atmosphere;
out highp vec2 v_fineruv;
out highp vec2 v_coarseuv;
out lowp float v_atmosphere;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.morphX = vertexInput_morphX;
  vertexInput_2.finercoord = vertexInput_finercoord;
  vertexInput_2.coarsecoord = vertexInput_coarsecoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.finercoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.fineruv = tmpvar_4;
  highp vec2 tmpvar_5;
  tmpvar_5 = ((vertexInput_2.coarsecoord * morph.coarseScale) + morph.coarseOffset);
  highp vec2 tmpvar_6;
  tmpvar_6.x = tmpvar_5.x;
  tmpvar_6.y = (1.0 - tmpvar_5.y);
  outputValue_1.coarseuv = tmpvar_6;
  highp vec4 tmpvar_7;
  tmpvar_7.w = 1.0;
  tmpvar_7.x = mix (vertexInput_2.position.x, vertexInput_2.morphX, morph.factor.x);
  tmpvar_7.y = vertexInput_2.position.y;
  tmpvar_7.z = vertexInput_2.position.z;
  highp vec4 tmpvar_8;
  tmpvar_8 = (transform.modelview * tmpvar_7);
  highp vec2 horizon_9;
  horizon_9 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_10;
  tmpvar_10.y = 0.5;
  tmpvar_10.x = ((sqrt(
    dot (tmpvar_8.xyz, tmpvar_8.xyz)
  ) - horizon_9.x) / horizon_9.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_10).x;
  gl_Position = ((sharedConstants.projection * tmpvar_8) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_7);
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_7);
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_7);
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_7);
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_7);
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_7);
  v_fineruv = outputValue_1.fineruv;
  v_coarseuv = outputValue_1.coarseuv;
  v_atmosphere = outputValue_1.atmosphere;
//FlyoverMorph::flyoverMorph_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
struct Morph {
  highp vec2 coarseScale;
  highp vec2 coarseOffset;
  highp vec2 factor;
in highp vec2 v_fineruv;
in highp vec2 v_coarseuv;
in lowp float v_atmosphere;
uniform Shared sharedConstants;
uniform Material material;
uniform Morph morph;
uniform sampler2D finer;
uniform sampler2D coarse;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (finer, v_fineruv);
  lowp float tmpvar_3;
  if ((tmpvar_2.x >= 0.04043579)) {
    tmpvar_3 = pow (((tmpvar_2.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_3 = (tmpvar_2.x / 12.92188);
  };
  lowp float tmpvar_4;
  if ((tmpvar_2.y >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_2.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_2.y / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_2.z >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_2.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_2.z / 12.92188);
  };
  lowp vec4 tmpvar_6;
  tmpvar_6.x = tmpvar_3;
  tmpvar_6.y = tmpvar_4;
  tmpvar_6.z = tmpvar_5;
  tmpvar_6.w = tmpvar_2.w;
  lowp vec4 tmpvar_7;
  tmpvar_7.w = 1.0;
  tmpvar_7.xyz = tmpvar_6.xyz;
  o_color_1 = tmpvar_7;
  lowp vec4 tmpvar_8;
  tmpvar_8 = texture (coarse, v_coarseuv);
  lowp float tmpvar_9;
  if ((tmpvar_8.x >= 0.04043579)) {
    tmpvar_9 = pow (((tmpvar_8.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_9 = (tmpvar_8.x / 12.92188);
  };
  lowp float tmpvar_10;
  if ((tmpvar_8.y >= 0.04043579)) {
    tmpvar_10 = pow (((tmpvar_8.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_10 = (tmpvar_8.y / 12.92188);
  };
  lowp float tmpvar_11;
  if ((tmpvar_8.z >= 0.04043579)) {
    tmpvar_11 = pow (((tmpvar_8.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_11 = (tmpvar_8.z / 12.92188);
  };
  lowp vec4 tmpvar_12;
  tmpvar_12.x = tmpvar_9;
  tmpvar_12.y = tmpvar_10;
  tmpvar_12.z = tmpvar_11;
  tmpvar_12.w = tmpvar_8.w;
  highp vec4 tmpvar_13;
  tmpvar_13 = mix (tmpvar_7, tmpvar_12, morph.factor.yyyy);
  o_color_1 = tmpvar_13;
  o_color_1.xyz = (o_color_1.xyz + (vec3(v_atmosphere) * sharedConstants.atmospherecolor));
  o_color_1.w = (o_color_1.w * material.blendfactor);
  output_value = o_color_1;
//FlyoverMorphBorder::flyoverMorphBorder_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp float morphX;
  highp vec2 finermerccoord;
  highp vec2 finerflyovercoord;
  highp vec2 coarsemerccoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct Morph {
  highp vec2 coarseScale;
  highp vec2 coarseOffset;
  highp vec2 factor;
struct VertexOut {
  highp vec2 finersatelliteuv;
  highp vec2 finerflyoveruv;
  highp vec2 finerblenduv;
  highp vec2 coarsesatelliteuv;
  lowp float atmosphere;
in highp vec3 vertexInput_position;
in highp float vertexInput_morphX;
in highp vec2 vertexInput_finermerccoord;
in highp vec2 vertexInput_finerflyovercoord;
in highp vec2 vertexInput_coarsemerccoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform Morph morph;
uniform sampler2D atmosphere;
out highp vec2 v_finersatelliteuv;
out highp vec2 v_finerflyoveruv;
out highp vec2 v_finerblenduv;
out highp vec2 v_coarsesatelliteuv;
out lowp float v_atmosphere;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.morphX = vertexInput_morphX;
  vertexInput_2.finermerccoord = vertexInput_finermerccoord;
  vertexInput_2.finerflyovercoord = vertexInput_finerflyovercoord;
  vertexInput_2.coarsemerccoord = vertexInput_coarsemerccoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.finermerccoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.finersatelliteuv = tmpvar_4;
  highp vec2 tmpvar_5;
  tmpvar_5.x = vertexInput_2.finermerccoord.x;
  tmpvar_5.y = (1.0 - vertexInput_2.finermerccoord.y);
  outputValue_1.finerblenduv = tmpvar_5;
  highp vec2 tmpvar_6;
  tmpvar_6.x = vertexInput_2.finerflyovercoord.x;
  tmpvar_6.y = (1.0 - vertexInput_2.finerflyovercoord.y);
  outputValue_1.finerflyoveruv = tmpvar_6;
  highp vec2 tmpvar_7;
  tmpvar_7 = ((vertexInput_2.coarsemerccoord * morph.coarseScale) + morph.coarseOffset);
  highp vec2 tmpvar_8;
  tmpvar_8.x = tmpvar_7.x;
  tmpvar_8.y = (1.0 - tmpvar_7.y);
  outputValue_1.coarsesatelliteuv = tmpvar_8;
  highp vec4 tmpvar_9;
  tmpvar_9.w = 1.0;
  tmpvar_9.x = mix (vertexInput_2.position.x, vertexInput_2.morphX, morph.factor.x);
  tmpvar_9.y = vertexInput_2.position.y;
  tmpvar_9.z = vertexInput_2.position.z;
  highp vec4 tmpvar_10;
  tmpvar_10 = (transform.modelview * tmpvar_9);
  highp vec2 horizon_11;
  horizon_11 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_12;
  tmpvar_12.y = 0.5;
  tmpvar_12.x = ((sqrt(
    dot (tmpvar_10.xyz, tmpvar_10.xyz)
  ) - horizon_11.x) / horizon_11.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_12).x;
  gl_Position = ((sharedConstants.projection * tmpvar_10) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_9);
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_9);
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_9);
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_9);
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_9);
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_9);
  v_finersatelliteuv = outputValue_1.finersatelliteuv;
  v_finerflyoveruv = outputValue_1.finerflyoveruv;
  v_finerblenduv = outputValue_1.finerblenduv;
  v_coarsesatelliteuv = outputValue_1.coarsesatelliteuv;
  v_atmosphere = outputValue_1.atmosphere;
//FlyoverMorphBorder::flyoverMorphBorder_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
struct Morph {
  highp vec2 coarseScale;
  highp vec2 coarseOffset;
  highp vec2 factor;
in highp vec2 v_finersatelliteuv;
in highp vec2 v_finerflyoveruv;
in highp vec2 v_finerblenduv;
in highp vec2 v_coarsesatelliteuv;
in lowp float v_atmosphere;
uniform Shared sharedConstants;
uniform Material material;
uniform Morph morph;
uniform sampler2D finerSatellite;
uniform sampler2D finerFlyover;
uniform sampler2D finerBlend;
uniform sampler2D coarseSatellite;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (finerSatellite, v_finersatelliteuv);
  lowp float tmpvar_3;
  if ((tmpvar_2.x >= 0.04043579)) {
    tmpvar_3 = pow (((tmpvar_2.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_3 = (tmpvar_2.x / 12.92188);
  };
  lowp float tmpvar_4;
  if ((tmpvar_2.y >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_2.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_2.y / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_2.z >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_2.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_2.z / 12.92188);
  };
  lowp vec4 tmpvar_6;
  tmpvar_6.x = tmpvar_3;
  tmpvar_6.y = tmpvar_4;
  tmpvar_6.z = tmpvar_5;
  tmpvar_6.w = tmpvar_2.w;
  lowp vec4 tmpvar_7;
  tmpvar_7 = texture (finerFlyover, v_finerflyoveruv);
  lowp float tmpvar_8;
  if ((tmpvar_7.x >= 0.04043579)) {
    tmpvar_8 = pow (((tmpvar_7.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_8 = (tmpvar_7.x / 12.92188);
  };
  lowp float tmpvar_9;
  if ((tmpvar_7.y >= 0.04043579)) {
    tmpvar_9 = pow (((tmpvar_7.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_9 = (tmpvar_7.y / 12.92188);
  };
  lowp float tmpvar_10;
  if ((tmpvar_7.z >= 0.04043579)) {
    tmpvar_10 = pow (((tmpvar_7.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_10 = (tmpvar_7.z / 12.92188);
  };
  lowp vec4 tmpvar_11;
  tmpvar_11.x = tmpvar_8;
  tmpvar_11.y = tmpvar_9;
  tmpvar_11.z = tmpvar_10;
  tmpvar_11.w = tmpvar_7.w;
  lowp vec4 tmpvar_12;
  tmpvar_12.w = 1.0;
  tmpvar_12.xyz = mix (tmpvar_6.xyz, tmpvar_11.xyz, texture (finerBlend, v_finerblenduv).xxx);
  o_color_1 = tmpvar_12;
  lowp vec4 tmpvar_13;
  tmpvar_13 = texture (coarseSatellite, v_coarsesatelliteuv);
  lowp float tmpvar_14;
  if ((tmpvar_13.x >= 0.04043579)) {
    tmpvar_14 = pow (((tmpvar_13.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_14 = (tmpvar_13.x / 12.92188);
  };
  lowp float tmpvar_15;
  if ((tmpvar_13.y >= 0.04043579)) {
    tmpvar_15 = pow (((tmpvar_13.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_15 = (tmpvar_13.y / 12.92188);
  };
  lowp float tmpvar_16;
  if ((tmpvar_13.z >= 0.04043579)) {
    tmpvar_16 = pow (((tmpvar_13.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_16 = (tmpvar_13.z / 12.92188);
  };
  lowp vec4 tmpvar_17;
  tmpvar_17.x = tmpvar_14;
  tmpvar_17.y = tmpvar_15;
  tmpvar_17.z = tmpvar_16;
  tmpvar_17.w = tmpvar_13.w;
  highp vec4 tmpvar_18;
  tmpvar_18 = mix (tmpvar_12, tmpvar_17, morph.factor.yyyy);
  o_color_1 = tmpvar_18;
  o_color_1.xyz = (o_color_1.xyz + (vec3(v_atmosphere) * sharedConstants.atmospherecolor));
  o_color_1.w = (o_color_1.w * material.blendfactor);
  output_value = o_color_1;
//FlyoverMorphNight::flyoverMorphNight_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp float morphX;
  highp vec2 finercoord;
  highp vec2 coarsecoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct Morph {
  highp vec2 coarseScale;
  highp vec2 coarseOffset;
  highp vec2 factor;
struct VertexOut {
  highp vec2 fineruv;
  highp vec2 coarseuv;
  lowp float atmosphere;
  lowp float nightLightIntensity;
in highp vec3 vertexInput_position;
in highp float vertexInput_morphX;
in highp vec2 vertexInput_finercoord;
in highp vec2 vertexInput_coarsecoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform Morph morph;
uniform sampler2D atmosphere;
out highp vec2 v_fineruv;
out highp vec2 v_coarseuv;
out lowp float v_atmosphere;
out lowp float v_nightLightIntensity;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.morphX = vertexInput_morphX;
  vertexInput_2.finercoord = vertexInput_finercoord;
  vertexInput_2.coarsecoord = vertexInput_coarsecoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.finercoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.fineruv = tmpvar_4;
  highp vec2 tmpvar_5;
  tmpvar_5 = ((vertexInput_2.coarsecoord * morph.coarseScale) + morph.coarseOffset);
  highp vec2 tmpvar_6;
  tmpvar_6.x = tmpvar_5.x;
  tmpvar_6.y = (1.0 - tmpvar_5.y);
  outputValue_1.coarseuv = tmpvar_6;
  highp vec4 tmpvar_7;
  tmpvar_7.w = 1.0;
  tmpvar_7.x = mix (vertexInput_2.position.x, vertexInput_2.morphX, morph.factor.x);
  tmpvar_7.y = vertexInput_2.position.y;
  tmpvar_7.z = vertexInput_2.position.z;
  highp vec4 tmpvar_8;
  tmpvar_8 = (transform.modelview * tmpvar_7);
  highp vec2 horizon_9;
  horizon_9 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_10;
  tmpvar_10.y = 0.5;
  tmpvar_10.x = ((sqrt(
    dot (tmpvar_8.xyz, tmpvar_8.xyz)
  ) - horizon_9.x) / horizon_9.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_10).x;
  gl_Position = ((sharedConstants.projection * tmpvar_8) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  highp vec4 tmpvar_11;
  tmpvar_11.w = 1.0;
  tmpvar_11.xyz = vertexInput_2.position;
  highp float tmpvar_12;
  tmpvar_12 = clamp (dot (normalize(
    ((transform.modelmat * tmpvar_11).xyz / vec3(6000000.0, 6000000.0, 6000000.0))
  ), (
    -(sharedConstants.lightdirection)
   * vec3(5.0, 5.0, 5.0))), 0.0, 1.0);
  outputValue_1.nightLightIntensity = (tmpvar_12 * sharedConstants.nightlightfade);
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_7);
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_7);
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_7);
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_7);
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_7);
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_7);
  v_fineruv = outputValue_1.fineruv;
  v_coarseuv = outputValue_1.coarseuv;
  v_atmosphere = outputValue_1.atmosphere;
  v_nightLightIntensity = outputValue_1.nightLightIntensity;
//FlyoverMorphNight::flyoverMorphNight_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
struct Morph {
  highp vec2 coarseScale;
  highp vec2 coarseOffset;
  highp vec2 factor;
in highp vec2 v_fineruv;
in highp vec2 v_coarseuv;
in lowp float v_atmosphere;
in lowp float v_nightLightIntensity;
uniform Shared sharedConstants;
uniform Material material;
uniform Morph morph;
uniform sampler2D finer;
uniform sampler2D coarse;
uniform sampler2D finerNight;
uniform sampler2D coarseNight;
out lowp vec4 output_value;
void main ()
  lowp vec4 nightTexture_1;
  lowp vec4 o_color_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (finer, v_fineruv);
  lowp float tmpvar_4;
  if ((tmpvar_3.x >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_3.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_3.x / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_3.y >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_3.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_3.y / 12.92188);
  };
  lowp float tmpvar_6;
  if ((tmpvar_3.z >= 0.04043579)) {
    tmpvar_6 = pow (((tmpvar_3.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_6 = (tmpvar_3.z / 12.92188);
  };
  lowp vec4 tmpvar_7;
  tmpvar_7.x = tmpvar_4;
  tmpvar_7.y = tmpvar_5;
  tmpvar_7.z = tmpvar_6;
  tmpvar_7.w = tmpvar_3.w;
  lowp vec4 tmpvar_8;
  tmpvar_8.w = 1.0;
  tmpvar_8.xyz = tmpvar_7.xyz;
  o_color_2 = tmpvar_8;
  lowp vec4 tmpvar_9;
  tmpvar_9 = texture (coarse, v_coarseuv);
  lowp float tmpvar_10;
  if ((tmpvar_9.x >= 0.04043579)) {
    tmpvar_10 = pow (((tmpvar_9.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_10 = (tmpvar_9.x / 12.92188);
  };
  lowp float tmpvar_11;
  if ((tmpvar_9.y >= 0.04043579)) {
    tmpvar_11 = pow (((tmpvar_9.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_11 = (tmpvar_9.y / 12.92188);
  };
  lowp float tmpvar_12;
  if ((tmpvar_9.z >= 0.04043579)) {
    tmpvar_12 = pow (((tmpvar_9.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_12 = (tmpvar_9.z / 12.92188);
  };
  lowp vec4 tmpvar_13;
  tmpvar_13.x = tmpvar_10;
  tmpvar_13.y = tmpvar_11;
  tmpvar_13.z = tmpvar_12;
  tmpvar_13.w = tmpvar_9.w;
  highp vec4 tmpvar_14;
  tmpvar_14 = mix (tmpvar_8, tmpvar_13, morph.factor.yyyy);
  o_color_2 = tmpvar_14;
  lowp vec4 tmpvar_15;
  tmpvar_15 = texture (finerNight, v_fineruv);
  lowp float tmpvar_16;
  if ((tmpvar_15.x >= 0.04043579)) {
    tmpvar_16 = pow (((tmpvar_15.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_16 = (tmpvar_15.x / 12.92188);
  };
  lowp float tmpvar_17;
  if ((tmpvar_15.y >= 0.04043579)) {
    tmpvar_17 = pow (((tmpvar_15.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_17 = (tmpvar_15.y / 12.92188);
  };
  lowp float tmpvar_18;
  if ((tmpvar_15.z >= 0.04043579)) {
    tmpvar_18 = pow (((tmpvar_15.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_18 = (tmpvar_15.z / 12.92188);
  };
  lowp vec4 tmpvar_19;
  tmpvar_19.x = tmpvar_16;
  tmpvar_19.y = tmpvar_17;
  tmpvar_19.z = tmpvar_18;
  tmpvar_19.w = tmpvar_15.w;
  lowp vec4 tmpvar_20;
  tmpvar_20 = texture (coarseNight, v_coarseuv);
  lowp float tmpvar_21;
  if ((tmpvar_20.x >= 0.04043579)) {
    tmpvar_21 = pow (((tmpvar_20.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_21 = (tmpvar_20.x / 12.92188);
  };
  lowp float tmpvar_22;
  if ((tmpvar_20.y >= 0.04043579)) {
    tmpvar_22 = pow (((tmpvar_20.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_22 = (tmpvar_20.y / 12.92188);
  };
  lowp float tmpvar_23;
  if ((tmpvar_20.z >= 0.04043579)) {
    tmpvar_23 = pow (((tmpvar_20.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_23 = (tmpvar_20.z / 12.92188);
  };
  lowp vec4 tmpvar_24;
  tmpvar_24.x = tmpvar_21;
  tmpvar_24.y = tmpvar_22;
  tmpvar_24.z = tmpvar_23;
  tmpvar_24.w = tmpvar_20.w;
  highp vec4 tmpvar_25;
  tmpvar_25 = mix (tmpvar_19, tmpvar_24, morph.factor.yyyy);
  nightTexture_1 = tmpvar_25;
  lowp vec3 tmpvar_26;
  tmpvar_26.x = nightTexture_1.x;
  tmpvar_26.y = nightTexture_1.x;
  tmpvar_26.z = (nightTexture_1.x * 0.3999023);
  lowp vec3 tmpvar_27;
  tmpvar_27 = ((mat3(0.04798632, 0.04798632, 0.1199902, 0.04798632, 0.04798632, 0.1199902, 0.04798632, 0.04798632, 0.0) * o_color_2.xyz) + tmpvar_26);
  lowp vec3 tmpvar_28;
  tmpvar_28.x = mix (o_color_2.x, tmpvar_27.x, pow (v_nightLightIntensity, 1.299805));
  tmpvar_28.yz = mix (o_color_2.yz, tmpvar_27.yz, vec2(v_nightLightIntensity));
  o_color_2.xyz = mix (tmpvar_28, tmpvar_27, vec3(v_nightLightIntensity));
  lowp vec3 tmpvar_29;
  tmpvar_29 = vec3((1.0 - v_nightLightIntensity));
  highp vec3 tmpvar_30;
  tmpvar_30 = mix (o_color_2.xyz, ((o_color_2.xyz + 
    (vec3(v_atmosphere) * sharedConstants.atmospherecolor)
  ) * tmpvar_29), vec3(v_atmosphere));
  o_color_2.xyz = tmpvar_30;
  o_color_2.w = (o_color_2.w * material.blendfactor);
  output_value = o_color_2;
//FlyoverNight::flyoverNight_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 texcoord;
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Transform {
  highp mat4 modelview;
  highp mat4 modelmat;
struct Clip {
  highp vec4 clipPlanes[6];
struct Material {
  highp float blendfactor;
struct Texcoords {
  highp vec2 offset;
  highp vec2 scale;
struct VertexOut {
  highp vec2 uv;
  lowp float atmosphere;
  lowp float nightLightIntensity;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform Shared sharedConstants;
uniform Transform transform;
uniform Clip clip;
uniform Material material;
uniform Texcoords texcoords;
uniform sampler2D atmosphere;
out highp vec2 v_uv;
out lowp float v_atmosphere;
out lowp float v_nightLightIntensity;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  highp vec2 tmpvar_3;
  tmpvar_3 = ((vertexInput_2.texcoord * texcoords.scale) + texcoords.offset);
  highp vec2 tmpvar_4;
  tmpvar_4.x = tmpvar_3.x;
  tmpvar_4.y = (1.0 - tmpvar_3.y);
  outputValue_1.uv = tmpvar_4;
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = vertexInput_2.position;
  highp vec4 tmpvar_6;
  tmpvar_6 = (transform.modelview * tmpvar_5);
  highp vec2 horizon_7;
  horizon_7 = sharedConstants.horizonvalues;
  highp vec2 tmpvar_8;
  tmpvar_8.y = 0.5;
  tmpvar_8.x = ((sqrt(
    dot (tmpvar_6.xyz, tmpvar_6.xyz)
  ) - horizon_7.x) / horizon_7.y);
  outputValue_1.atmosphere = texture (atmosphere, tmpvar_8).x;
  gl_Position = ((sharedConstants.projection * tmpvar_6) + vec4(((1.0 - 
    max (0.0, material.blendfactor)
  ) * 0.02)));
  highp vec4 tmpvar_9;
  tmpvar_9.w = 1.0;
  tmpvar_9.xyz = vertexInput_2.position;
  highp float tmpvar_10;
  tmpvar_10 = clamp (dot (normalize(
    ((transform.modelmat * tmpvar_9).xyz / vec3(6000000.0, 6000000.0, 6000000.0))
  ), (
    -(sharedConstants.lightdirection)
   * vec3(5.0, 5.0, 5.0))), 0.0, 1.0);
  outputValue_1.nightLightIntensity = (tmpvar_10 * sharedConstants.nightlightfade);
  highp vec4 tmpvar_11;
  tmpvar_11.w = 1.0;
  tmpvar_11.xyz = vertexInput_2.position;
  gl_ClipDistance[0] = dot (clip.clipPlanes[0], tmpvar_11);
  highp vec4 tmpvar_12;
  tmpvar_12.w = 1.0;
  tmpvar_12.xyz = vertexInput_2.position;
  gl_ClipDistance[1] = dot (clip.clipPlanes[1], tmpvar_12);
  highp vec4 tmpvar_13;
  tmpvar_13.w = 1.0;
  tmpvar_13.xyz = vertexInput_2.position;
  gl_ClipDistance[2] = dot (clip.clipPlanes[2], tmpvar_13);
  highp vec4 tmpvar_14;
  tmpvar_14.w = 1.0;
  tmpvar_14.xyz = vertexInput_2.position;
  gl_ClipDistance[3] = dot (clip.clipPlanes[3], tmpvar_14);
  highp vec4 tmpvar_15;
  tmpvar_15.w = 1.0;
  tmpvar_15.xyz = vertexInput_2.position;
  gl_ClipDistance[4] = dot (clip.clipPlanes[4], tmpvar_15);
  highp vec4 tmpvar_16;
  tmpvar_16.w = 1.0;
  tmpvar_16.xyz = vertexInput_2.position;
  gl_ClipDistance[5] = dot (clip.clipPlanes[5], tmpvar_16);
  v_uv = outputValue_1.uv;
  v_atmosphere = outputValue_1.atmosphere;
  v_nightLightIntensity = outputValue_1.nightLightIntensity;
//FlyoverNight::flyoverNight_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp vec3 atmospherecolor;
  highp vec2 horizonvalues;
  highp vec3 lightdirection;
  highp float nightlightfade;
struct Material {
  highp float blendfactor;
in highp vec2 v_uv;
in lowp float v_atmosphere;
in lowp float v_nightLightIntensity;
uniform Shared sharedConstants;
uniform Material material;
uniform sampler2D diffuse;
uniform sampler2D night;
out lowp vec4 output_value;
void main ()
  lowp vec4 o_color_1;
  lowp vec4 tmpvar_2;
  tmpvar_2 = texture (diffuse, v_uv);
  lowp float tmpvar_3;
  if ((tmpvar_2.x >= 0.04043579)) {
    tmpvar_3 = pow (((tmpvar_2.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_3 = (tmpvar_2.x / 12.92188);
  };
  lowp float tmpvar_4;
  if ((tmpvar_2.y >= 0.04043579)) {
    tmpvar_4 = pow (((tmpvar_2.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_4 = (tmpvar_2.y / 12.92188);
  };
  lowp float tmpvar_5;
  if ((tmpvar_2.z >= 0.04043579)) {
    tmpvar_5 = pow (((tmpvar_2.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_5 = (tmpvar_2.z / 12.92188);
  };
  lowp vec4 tmpvar_6;
  tmpvar_6.x = tmpvar_3;
  tmpvar_6.y = tmpvar_4;
  tmpvar_6.z = tmpvar_5;
  tmpvar_6.w = tmpvar_2.w;
  o_color_1 = tmpvar_6;
  lowp vec4 tmpvar_7;
  tmpvar_7 = texture (night, v_uv);
  lowp float tmpvar_8;
  if ((tmpvar_7.x >= 0.04043579)) {
    tmpvar_8 = pow (((tmpvar_7.x + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_8 = (tmpvar_7.x / 12.92188);
  };
  lowp float tmpvar_9;
  if ((tmpvar_7.y >= 0.04043579)) {
    tmpvar_9 = pow (((tmpvar_7.y + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_9 = (tmpvar_7.y / 12.92188);
  };
  lowp float tmpvar_10;
  if ((tmpvar_7.z >= 0.04043579)) {
    tmpvar_10 = pow (((tmpvar_7.z + 0.05499268) / 1.054688), 2.400391);
  } else {
    tmpvar_10 = (tmpvar_7.z / 12.92188);
  };
  lowp vec4 tmpvar_11;
  tmpvar_11.x = tmpvar_8;
  tmpvar_11.y = tmpvar_9;
  tmpvar_11.z = tmpvar_10;
  tmpvar_11.w = tmpvar_7.w;
  lowp vec3 tmpvar_12;
  tmpvar_12.x = tmpvar_11.x;
  tmpvar_12.y = tmpvar_11.x;
  tmpvar_12.z = (tmpvar_8 * 0.3999023);
  lowp vec3 tmpvar_13;
  tmpvar_13 = ((mat3(0.04798632, 0.04798632, 0.1199902, 0.04798632, 0.04798632, 0.1199902, 0.04798632, 0.04798632, 0.0) * tmpvar_6.xyz) + tmpvar_12);
  lowp vec3 tmpvar_14;
  tmpvar_14.x = mix (tmpvar_3, tmpvar_13.x, pow (v_nightLightIntensity, 1.299805));
  tmpvar_14.yz = mix (tmpvar_6.yz, tmpvar_13.yz, vec2(v_nightLightIntensity));
  o_color_1.xyz = mix (tmpvar_14, tmpvar_13, vec3(v_nightLightIntensity));
  lowp vec3 tmpvar_15;
  tmpvar_15 = vec3((1.0 - v_nightLightIntensity));
  highp vec3 tmpvar_16;
  tmpvar_16 = mix (o_color_1.xyz, ((o_color_1.xyz + 
    (vec3(v_atmosphere) * sharedConstants.atmospherecolor)
  ) * tmpvar_15), vec3(v_atmosphere));
  o_color_1.xyz = tmpvar_16;
  o_color_1.w = (tmpvar_2.w * material.blendfactor);
  output_value = o_color_1;
//FlyoverNightDim::flyoverNightDim_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 unit;
in highp vec2 vertexInput_unit;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.unit = vertexInput_unit;
  highp vec4 tmpvar_2;
  tmpvar_2.zw = vec2(0.0, 1.0);
  tmpvar_2.xy = vertexInput_1.unit;
  gl_Position = tmpvar_2;
//FlyoverNightDim::flyoverNightDim_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Color {
  highp vec3 color;
uniform Color color;
inout lowp vec4 output_value;
void main ()
  lowp vec4 out_color_1;
  highp vec2 tmpvar_2;
  tmpvar_2 = color.color.zz;
  out_color_1.xy = (tmpvar_2 * output_value.xy);
  highp float tmpvar_3;
  tmpvar_3 = dot (color.color, output_value.xyz);
  out_color_1.z = tmpvar_3;
  out_color_1.w = output_value.w;
  output_value = out_color_1;
//FlyoverOverlay::flyoverOverlay_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 texcoord;
struct Shared {
  highp mat4 projection;
  highp float offsetfactor;
struct Transform {
  highp mat4 modelview;
struct VertexOut {
  highp vec2 uv;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform Shared sharedConstants;
uniform Transform transform;
out highp vec2 v_uv;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.uv = vertexInput_2.texcoord;
  outputValue_1.uv.y = (1.0 - outputValue_1.uv.y);
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xyz = vertexInput_2.position;
  highp vec4 tmpvar_4;
  tmpvar_4 = (transform.modelview * tmpvar_3);
  highp float factor_5;
  factor_5 = sharedConstants.offsetfactor;
  highp vec4 tmpvar_6;
  tmpvar_6.xyz = (tmpvar_4.xyz - (vec3((
    (2.5 + (7.5 * factor_5))
   + 
    ((0.005 + factor_5) * -(tmpvar_4.z))
  )) * normalize(tmpvar_4.xyz)));
  tmpvar_6.w = tmpvar_4.w;
  gl_Position = (sharedConstants.projection * tmpvar_6);
  v_uv = outputValue_1.uv;
//FlyoverOverlay::flyoverOverlay_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_uv;
uniform sampler2D overlay;
out lowp vec4 output_value;
void main ()
  output_value = texture (overlay, v_uv);
//FlyoverRoadFillProcedural::flyoverRoadFillProcedural_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec4 offset;
  highp vec2 uv;
struct View {
  highp mat4 projection;
struct Transform {
  highp mat4 modelview;
  highp float width;
struct VertexOut {
  highp vec2 uv;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec4 vertexInput_offset;
in highp vec2 vertexInput_uv;
uniform View view;
uniform Transform transform;
out highp vec2 v_uv;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.offset = vertexInput_offset;
  vertexInput_2.uv = vertexInput_uv;
  highp vec3 tmpvar_3;
  tmpvar_3.z = 1.0;
  tmpvar_3.xy = vertexInput_2.uv;
  outputValue_1.uv = (mat3(2.0, 0.0, 0.0, 0.0, 2.0, 0.0, -1.0, -1.0, 1.0) * tmpvar_3).xy;
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = (vertexInput_2.position + (vertexInput_2.offset.xyz * vec3((vertexInput_2.offset.w * transform.width))));
  highp vec4 tmpvar_5;
  tmpvar_5 = (transform.modelview * tmpvar_4);
  highp vec4 tmpvar_6;
  tmpvar_6.w = 0.0;
  tmpvar_6.xyz = vertexInput_2.normal;
  highp float tmpvar_7;
  tmpvar_7 = -((transform.modelview * tmpvar_6).z);
  highp float tmpvar_8;
  tmpvar_8 = (tmpvar_7 * tmpvar_7);
  highp float tmpvar_9;
  tmpvar_9 = (tmpvar_8 * tmpvar_8);
  highp float tmpvar_10;
  tmpvar_10 = (tmpvar_9 * tmpvar_9);
  highp vec4 tmpvar_11;
  tmpvar_11.xyz = (tmpvar_5.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_10))
   + 
    ((0.002 + (0.02 * tmpvar_10)) * -(tmpvar_5.z))
  )) * normalize(tmpvar_5.xyz)));
  tmpvar_11.w = tmpvar_5.w;
  gl_Position = (view.projection * tmpvar_11);
  v_uv = outputValue_1.uv;
//FlyoverRoadFillProcedural::flyoverRoadFillProcedural_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Blend {
  highp float alpha;
struct Color {
  highp vec4 fill;
  highp vec4 stroke;
in highp vec2 v_uv;
uniform Blend blend;
uniform Color color;
inout lowp vec4 output_value;
void main ()
  lowp float fillA_1;
  mediump float edgeStep_2;
  lowp vec2 nUv_3;
  lowp float radius_4;
  highp float tmpvar_5;
  tmpvar_5 = sqrt(dot (v_uv, v_uv));
  radius_4 = tmpvar_5;
  highp vec2 tmpvar_6;
  tmpvar_6 = normalize(v_uv);
  nUv_3 = tmpvar_6;
  highp float tmpvar_7;
  tmpvar_7 = max (abs(dot (
    dFdx(v_uv)
  , nUv_3)), abs(dot (
    dFdy(v_uv)
  , nUv_3)));
  edgeStep_2 = tmpvar_7;
  mediump float edge0_8;
  edge0_8 = (1.0 - (2.0 * edgeStep_2));
  mediump float tmpvar_9;
  tmpvar_9 = clamp (((radius_4 - edge0_8) / (1.0 - edge0_8)), 0.0, 1.0);
  mediump float tmpvar_10;
  tmpvar_10 = (1.0 - (tmpvar_9 * (tmpvar_9 * 
    (3.0 - (2.0 * tmpvar_9))
  )));
  fillA_1 = tmpvar_10;
  if ((fillA_1 < 0.9)) {
    discard;
  };
  highp vec4 tmpvar_11;
  tmpvar_11.w = 0.0;
  tmpvar_11.xyz = mix (output_value.xyz, color.fill.xyz, vec3(((color.fill.w * fillA_1) * blend.alpha)));
  output_value = tmpvar_11;
//FlyoverRoadFillTextured::flyoverRoadFillTextured_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec4 offset;
  highp vec2 uv;
struct View {
  highp mat4 projection;
struct Transform {
  highp mat4 modelview;
  highp float width;
struct VertexOut {
  highp vec2 uv;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec4 vertexInput_offset;
in highp vec2 vertexInput_uv;
uniform View view;
uniform Transform transform;
out highp vec2 v_uv;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  vertexInput_2.offset = vertexInput_offset;
  vertexInput_2.uv = vertexInput_uv;
  outputValue_1.uv = vertexInput_2.uv;
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xyz = (vertexInput_2.position + (vertexInput_2.offset.xyz * vec3((vertexInput_2.offset.w * transform.width))));
  highp vec4 tmpvar_4;
  tmpvar_4 = (transform.modelview * tmpvar_3);
  highp vec4 tmpvar_5;
  tmpvar_5.w = 0.0;
  tmpvar_5.xyz = vertexInput_2.normal;
  highp float tmpvar_6;
  tmpvar_6 = -((transform.modelview * tmpvar_5).z);
  highp float tmpvar_7;
  tmpvar_7 = (tmpvar_6 * tmpvar_6);
  highp float tmpvar_8;
  tmpvar_8 = (tmpvar_7 * tmpvar_7);
  highp float tmpvar_9;
  tmpvar_9 = (tmpvar_8 * tmpvar_8);
  highp vec4 tmpvar_10;
  tmpvar_10.xyz = (tmpvar_4.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_9))
   + 
    ((0.002 + (0.02 * tmpvar_9)) * -(tmpvar_4.z))
  )) * normalize(tmpvar_4.xyz)));
  tmpvar_10.w = tmpvar_4.w;
  gl_Position = (view.projection * tmpvar_10);
  v_uv = outputValue_1.uv;
//FlyoverRoadFillTextured::flyoverRoadFillTextured_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Blend {
  highp float alpha;
struct Color {
  highp vec4 fill;
  highp vec4 stroke;
in highp vec2 v_uv;
uniform Blend blend;
uniform Color color;
uniform sampler2D discMap;
inout lowp vec4 output_value;
void main ()
  lowp vec4 tmpvar_1;
  tmpvar_1 = texture (discMap, v_uv);
  if ((tmpvar_1.x < 0.9)) {
    discard;
  };
  highp vec4 tmpvar_2;
  tmpvar_2.w = 0.0;
  tmpvar_2.xyz = mix (output_value.xyz, color.fill.xyz, vec3(((color.fill.w * tmpvar_1.x) * blend.alpha)));
  output_value = tmpvar_2;
//FlyoverRoadStrokeProcedural::flyoverRoadStrokeProcedural_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec4 offset;
  highp vec2 uv;
struct View {
  highp mat4 projection;
struct Transform {
  highp mat4 modelview;
  highp float width;
struct VertexOut {
  highp vec2 uv;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec4 vertexInput_offset;
in highp vec2 vertexInput_uv;
uniform View view;
uniform Transform transform;
out highp vec2 v_uv;
void main ()
  highp vec4 pme_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.offset = vertexInput_offset;
  vertexInput_3.uv = vertexInput_uv;
  highp vec3 tmpvar_4;
  tmpvar_4.z = 1.0;
  tmpvar_4.xy = vertexInput_3.uv;
  outputValue_2.uv = (mat3(2.0, 0.0, 0.0, 0.0, 2.0, 0.0, -1.0, -1.0, 1.0) * tmpvar_4).xy;
  highp float tmpvar_5;
  tmpvar_5 = outputValue_2.uv.y;
  highp vec4 tmpvar_6;
  tmpvar_6.w = 1.0;
  tmpvar_6.xyz = (vertexInput_3.position + (vertexInput_3.offset.xyz * vec3((vertexInput_3.offset.w * transform.width))));
  highp vec4 tmpvar_7;
  tmpvar_7 = (transform.modelview * tmpvar_6);
  if (((tmpvar_5 * tmpvar_5) > 0.1)) {
    highp vec3 a_8;
    a_8 = vertexInput_3.normal;
    highp vec3 b_9;
    b_9 = vertexInput_3.offset.xyz;
    highp vec4 tmpvar_10;
    tmpvar_10.w = 0.0;
    tmpvar_10.xyz = normalize(((a_8.yzx * b_9.zxy) - (a_8.zxy * b_9.yzx)));
    pme_1 = (tmpvar_7 + ((
      (transform.modelview * (tmpvar_10 * vec4(tmpvar_5)))
     * vec4(transform.width)) * vec4(0.5, 0.5, 0.5, 0.5)));
  } else {
    pme_1 = tmpvar_7;
  };
  highp vec4 tmpvar_11;
  tmpvar_11.w = 0.0;
  tmpvar_11.xyz = vertexInput_3.normal;
  highp float tmpvar_12;
  tmpvar_12 = -((transform.modelview * tmpvar_11).z);
  highp float tmpvar_13;
  tmpvar_13 = (tmpvar_12 * tmpvar_12);
  highp float tmpvar_14;
  tmpvar_14 = (tmpvar_13 * tmpvar_13);
  highp float tmpvar_15;
  tmpvar_15 = (tmpvar_14 * tmpvar_14);
  highp vec4 tmpvar_16;
  tmpvar_16.xyz = (pme_1.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_15))
   + 
    ((0.002 + (0.02 * tmpvar_15)) * -(pme_1.z))
  )) * normalize(pme_1.xyz)));
  tmpvar_16.w = pme_1.w;
  gl_Position = (view.projection * tmpvar_16);
  v_uv = outputValue_2.uv;
//FlyoverRoadStrokeProcedural::flyoverRoadStrokeProcedural_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Blend {
  highp float alpha;
struct Color {
  highp vec4 fill;
  highp vec4 stroke;
struct RibbonExtra {
  highp float ewidth;
in highp vec2 v_uv;
uniform Blend blend;
uniform Color color;
uniform RibbonExtra ribbonExtra;
inout lowp vec4 output_value;
void main ()
  lowp vec3 fineC_1;
  lowp vec4 computed_color_2;
  lowp float fillA_3;
  lowp float fillT_4;
  lowp float strokeA_5;
  mediump float edgeStep_6;
  lowp vec2 nUv_7;
  lowp float radius_8;
  highp float tmpvar_9;
  tmpvar_9 = sqrt(dot (v_uv, v_uv));
  radius_8 = tmpvar_9;
  highp vec2 tmpvar_10;
  tmpvar_10 = normalize(v_uv);
  nUv_7 = tmpvar_10;
  highp float tmpvar_11;
  tmpvar_11 = max (abs(dot (
    dFdx(v_uv)
  , nUv_7)), abs(dot (
    dFdy(v_uv)
  , nUv_7)));
  edgeStep_6 = tmpvar_11;
  mediump float edge0_12;
  edge0_12 = (1.0 - (2.0 * edgeStep_6));
  mediump float tmpvar_13;
  tmpvar_13 = clamp (((radius_8 - edge0_12) / (1.0 - edge0_12)), 0.0, 1.0);
  mediump float tmpvar_14;
  tmpvar_14 = (1.0 - (tmpvar_13 * (tmpvar_13 * 
    (3.0 - (2.0 * tmpvar_13))
  )));
  strokeA_5 = tmpvar_14;
  highp float tmpvar_15;
  tmpvar_15 = ribbonExtra.ewidth;
  fillT_4 = tmpvar_15;
  mediump float edge0_16;
  edge0_16 = (fillT_4 - (2.0 * edgeStep_6));
  mediump float tmpvar_17;
  tmpvar_17 = clamp (((radius_8 - edge0_16) / (fillT_4 - edge0_16)), 0.0, 1.0);
  mediump float tmpvar_18;
  tmpvar_18 = (1.0 - (tmpvar_17 * (tmpvar_17 * 
    (3.0 - (2.0 * tmpvar_17))
  )));
  fillA_3 = tmpvar_18;
  highp vec4 tmpvar_19;
  tmpvar_19 = mix (color.stroke, color.fill, vec4(fillA_3));
  computed_color_2 = tmpvar_19;
  lowp float tmpvar_20;
  tmpvar_20 = (1.0 - strokeA_5);
  lowp vec3 tmpvar_21;
  tmpvar_21 = mix (mix (mix (vec3(0.3999023, 0.3999023, 0.3999023), output_value.xyz, output_value.www), output_value.xyz, vec3((tmpvar_20 * tmpvar_20))), computed_color_2.xyz, computed_color_2.www);
  highp vec3 tmpvar_22;
  tmpvar_22 = mix (output_value.xyz, tmpvar_21, vec3((strokeA_5 * blend.alpha)));
  fineC_1 = tmpvar_22;
  highp vec4 tmpvar_23;
  tmpvar_23.xyz = fineC_1;
  tmpvar_23.w = min ((1.0 - (strokeA_5 * blend.alpha)), output_value.w);
  output_value = tmpvar_23;
//FlyoverRoadStrokeTextured::flyoverRoadStrokeTextured_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec4 offset;
  highp vec2 uv;
struct View {
  highp mat4 projection;
struct Transform {
  highp mat4 modelview;
  highp float width;
struct RibbonExtra {
  highp float ewidth;
struct VertexOut {
  highp vec2 uv;
  highp vec2 uvf;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec4 vertexInput_offset;
in highp vec2 vertexInput_uv;
uniform View view;
uniform Transform transform;
uniform RibbonExtra ribbonExtra;
out highp vec2 v_uv;
out highp vec2 v_uvf;
void main ()
  highp vec4 pme_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.offset = vertexInput_offset;
  vertexInput_3.uv = vertexInput_uv;
  outputValue_2.uv = vertexInput_3.uv;
  outputValue_2.uvf = vertexInput_3.uv;
  outputValue_2.uvf.x = (vertexInput_3.uv.x + (vertexInput_3.offset.w * ribbonExtra.ewidth));
  highp float tmpvar_4;
  tmpvar_4 = ((vertexInput_3.uv.y - 0.5) * 2.0);
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = (vertexInput_3.position + (vertexInput_3.offset.xyz * vec3((vertexInput_3.offset.w * transform.width))));
  highp vec4 tmpvar_6;
  tmpvar_6 = (transform.modelview * tmpvar_5);
  if (((tmpvar_4 * tmpvar_4) > 0.1)) {
    highp vec3 a_7;
    a_7 = vertexInput_3.normal;
    highp vec3 b_8;
    b_8 = vertexInput_3.offset.xyz;
    highp vec4 tmpvar_9;
    tmpvar_9.w = 0.0;
    tmpvar_9.xyz = normalize(((a_7.yzx * b_8.zxy) - (a_7.zxy * b_8.yzx)));
    outputValue_2.uvf.y = (outputValue_2.uvf.y + (tmpvar_4 * ribbonExtra.ewidth));
    pme_1 = (tmpvar_6 + ((
      (transform.modelview * (tmpvar_9 * vec4(tmpvar_4)))
     * vec4(transform.width)) * vec4(0.5, 0.5, 0.5, 0.5)));
  } else {
    pme_1 = tmpvar_6;
  };
  highp vec4 tmpvar_10;
  tmpvar_10.w = 0.0;
  tmpvar_10.xyz = vertexInput_3.normal;
  highp float tmpvar_11;
  tmpvar_11 = -((transform.modelview * tmpvar_10).z);
  highp float tmpvar_12;
  tmpvar_12 = (tmpvar_11 * tmpvar_11);
  highp float tmpvar_13;
  tmpvar_13 = (tmpvar_12 * tmpvar_12);
  highp float tmpvar_14;
  tmpvar_14 = (tmpvar_13 * tmpvar_13);
  highp vec4 tmpvar_15;
  tmpvar_15.xyz = (pme_1.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_14))
   + 
    ((0.002 + (0.02 * tmpvar_14)) * -(pme_1.z))
  )) * normalize(pme_1.xyz)));
  tmpvar_15.w = pme_1.w;
  gl_Position = (view.projection * tmpvar_15);
  v_uv = outputValue_2.uv;
  v_uvf = outputValue_2.uvf;
//FlyoverRoadStrokeTextured::flyoverRoadStrokeTextured_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Blend {
  highp float alpha;
struct Color {
  highp vec4 fill;
  highp vec4 stroke;
in highp vec2 v_uv;
in highp vec2 v_uvf;
uniform Blend blend;
uniform Color color;
uniform sampler2D discMap;
inout lowp vec4 output_value;
void main ()
  lowp vec3 fineC_1;
  lowp vec4 color_computed_2;
  lowp float tmpvar_3;
  tmpvar_3 = texture (discMap, v_uvf).x;
  lowp vec4 tmpvar_4;
  tmpvar_4 = texture (discMap, v_uv);
  highp vec4 tmpvar_5;
  tmpvar_5 = mix (color.stroke, color.fill, vec4(tmpvar_3));
  color_computed_2 = tmpvar_5;
  lowp float tmpvar_6;
  tmpvar_6 = (1.0 - tmpvar_4.x);
  lowp vec3 tmpvar_7;
  tmpvar_7 = mix (mix (mix (vec3(0.3999023, 0.3999023, 0.3999023), output_value.xyz, output_value.www), output_value.xyz, vec3((tmpvar_6 * tmpvar_6))), color_computed_2.xyz, color_computed_2.www);
  highp vec3 tmpvar_8;
  tmpvar_8 = mix (output_value.xyz, tmpvar_7, vec3((tmpvar_4.x * blend.alpha)));
  fineC_1 = tmpvar_8;
  highp vec4 tmpvar_9;
  tmpvar_9.xyz = fineC_1;
  tmpvar_9.w = min ((1.0 - (tmpvar_4.x * blend.alpha)), output_value.w);
  output_value = tmpvar_9;
//FlyoverRoute::flyoverRoute_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec4 offset;
  highp vec2 texcoord;
  highp float fraction;
struct View {
  highp mat4 projection;
struct Displacement {
  highp mat4 modelview;
  highp float width;
struct VertexOut {
  highp vec2 uv;
  highp float fraction;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec4 vertexInput_offset;
in highp vec2 vertexInput_texcoord;
in highp float vertexInput_fraction;
uniform View view;
uniform Displacement displacement;
out highp vec2 v_uv;
out highp float v_fraction;
void main ()
  highp vec4 pm_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.offset = vertexInput_offset;
  vertexInput_3.texcoord = vertexInput_texcoord;
  vertexInput_3.fraction = vertexInput_fraction;
  outputValue_2.uv = vertexInput_3.texcoord;
  outputValue_2.fraction = vertexInput_3.fraction;
  highp float tmpvar_4;
  tmpvar_4 = (outputValue_2.uv.y - 0.5);
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = (vertexInput_3.position + ((vertexInput_3.offset.xyz * vec3(displacement.width)) * vertexInput_3.offset.www));
  highp vec4 tmpvar_6;
  tmpvar_6 = (displacement.modelview * tmpvar_5);
  pm_1 = tmpvar_6;
  if (((tmpvar_4 * tmpvar_4) > 0.0)) {
    highp vec4 move_7;
    highp vec3 a_8;
    a_8 = vertexInput_3.normal;
    highp vec3 b_9;
    b_9 = vertexInput_3.offset.xyz;
    highp vec4 tmpvar_10;
    tmpvar_10.w = 0.0;
    tmpvar_10.xyz = ((a_8.yzx * b_9.zxy) - (a_8.zxy * b_9.yzx));
    move_7 = (tmpvar_10 * vec4((tmpvar_4 * displacement.width)));
    move_7 = (displacement.modelview * move_7);
    pm_1 = (tmpvar_6 + move_7);
  };
  highp vec4 tmpvar_11;
  tmpvar_11.w = 0.0;
  tmpvar_11.xyz = vertexInput_3.normal;
  highp float tmpvar_12;
  tmpvar_12 = -((displacement.modelview * tmpvar_11).z);
  highp float tmpvar_13;
  tmpvar_13 = (tmpvar_12 * tmpvar_12);
  highp float tmpvar_14;
  tmpvar_14 = (tmpvar_13 * tmpvar_13);
  highp float tmpvar_15;
  tmpvar_15 = (tmpvar_14 * tmpvar_14);
  highp vec4 tmpvar_16;
  tmpvar_16.xyz = (pm_1.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_15))
   + 
    ((0.002 + (0.02 * tmpvar_15)) * -(pm_1.z))
  )) * normalize(pm_1.xyz)));
  tmpvar_16.w = pm_1.w;
  gl_Position = (view.projection * tmpvar_16);
  v_uv = outputValue_2.uv;
  v_fraction = outputValue_2.fraction;
//FlyoverRoute::flyoverRoute_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
  highp vec4 secondary;
  highp float split;
  highp int greater;
  highp float alphaThreshold;
in highp vec2 v_uv;
in highp float v_fraction;
uniform Style style;
uniform sampler2D textureMap;
inout lowp vec4 output_value;
void main ()
  lowp vec4 baseColor_1;
  highp vec4 tmpvar_2;
  if ((v_fraction < style.split)) {
    tmpvar_2 = style.secondary;
  } else {
    tmpvar_2 = style.color;
  };
  baseColor_1 = tmpvar_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureMap, v_uv);
  lowp vec4 tmpvar_4;
  tmpvar_4.xyz = mix (output_value.xyz, mix (output_value.xyz, baseColor_1.xyz, vec3((tmpvar_3.x * baseColor_1.w))), output_value.www);
  tmpvar_4.w = (1.0 - (1.0 - (output_value.w * 
    (1.0 - tmpvar_3.x)
  )));
  output_value = tmpvar_4;
//FlyoverTraffic::flyoverTraffic_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
  highp vec3 offset;
  highp vec3 binormal;
  highp vec4 texcoord;
  highp vec3 bounds;
  highp vec4 misc;
  highp vec2 extension;
struct View {
  highp mat4 projection;
struct Displacement {
  highp mat4 modelview;
  highp float width;
  highp vec3 scaling;
struct Pattern {
  highp vec4 pattern;
struct VertexOut {
  highp vec2 uv;
  highp vec2 segment;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
in highp vec3 vertexInput_offset;
in highp vec3 vertexInput_binormal;
in highp vec4 vertexInput_texcoord;
in highp vec3 vertexInput_bounds;
in highp vec4 vertexInput_misc;
in highp vec2 vertexInput_extension;
uniform View view;
uniform Displacement displacement;
uniform Pattern pattern;
out highp vec2 v_uv;
out highp vec2 v_segment;
void main ()
  highp vec4 p_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.normal = vertexInput_normal;
  vertexInput_3.offset = vertexInput_offset;
  vertexInput_3.binormal = vertexInput_binormal;
  vertexInput_3.texcoord = vertexInput_texcoord;
  vertexInput_3.bounds = vertexInput_bounds;
  vertexInput_3.misc = vertexInput_misc;
  vertexInput_3.extension = vertexInput_extension;
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = vertexInput_3.position;
  p_1 = tmpvar_4;
  outputValue_2.uv = vertexInput_3.texcoord.xy;
  outputValue_2.segment = vertexInput_3.texcoord.zw;
  outputValue_2.uv.y = (outputValue_2.uv.y + vertexInput_3.bounds.y);
  outputValue_2.segment = (outputValue_2.segment + vertexInput_3.bounds.yy);
  highp float tmpvar_5;
  tmpvar_5 = (1.0/(pattern.pattern.x));
  highp float tmpvar_6;
  tmpvar_6 = fract(((
    (outputValue_2.uv.y * displacement.scaling.y)
   * tmpvar_5) - displacement.scaling.x));
  highp float tmpvar_7;
  tmpvar_7 = (clamp (tmpvar_6, (0.5 - pattern.pattern.y), (0.5 + pattern.pattern.y)) - tmpvar_6);
  highp float tmpvar_8;
  tmpvar_8 = sign(tmpvar_7);
  highp float tmpvar_9;
  if (((tmpvar_8 * tmpvar_8) > 0.0)) {
    tmpvar_9 = ((-(tmpvar_8) * (
      (0.5 - pattern.pattern.y)
     - 
      (tmpvar_8 * tmpvar_7)
    )) * pattern.pattern.x);
  } else {
    tmpvar_9 = vertexInput_3.misc.x;
  };
  highp vec3 tmpvar_10;
  tmpvar_10 = ((vertexInput_3.offset * outputValue_2.uv.xxx) * vec3(displacement.width));
  p_1.xyz = (tmpvar_4.xyz + (tmpvar_10 + (
    (vertexInput_3.binormal * vec3(tmpvar_9))
   * vec3(displacement.width))));
  p_1.xyz = (p_1.xyz + ((
    (tmpvar_10 * outputValue_2.uv.xxx)
   * vertexInput_3.misc.zzz) * vec3((1.0 - 
    (displacement.scaling.z * vertexInput_3.misc.w)
  ))));
  outputValue_2.uv.y = (outputValue_2.uv.y + (tmpvar_9 * displacement.width));
  outputValue_2.uv = (outputValue_2.uv * vec2(tmpvar_5));
  outputValue_2.uv.y = ((outputValue_2.uv.y * displacement.scaling.y) - displacement.scaling.x);
  outputValue_2.segment = ((outputValue_2.segment * displacement.scaling.yy) * vec2(tmpvar_5));
  outputValue_2.segment = (outputValue_2.segment - displacement.scaling.xx);
  p_1 = (displacement.modelview * p_1);
  highp vec4 tmpvar_11;
  tmpvar_11.w = 0.0;
  tmpvar_11.xyz = vertexInput_3.normal;
  highp float tmpvar_12;
  tmpvar_12 = -((displacement.modelview * tmpvar_11).z);
  highp float tmpvar_13;
  tmpvar_13 = (tmpvar_12 * tmpvar_12);
  highp float tmpvar_14;
  tmpvar_14 = (tmpvar_13 * tmpvar_13);
  highp float tmpvar_15;
  tmpvar_15 = (tmpvar_14 * tmpvar_14);
  highp vec4 tmpvar_16;
  tmpvar_16.xyz = (p_1.xyz - (vec3((
    (2.5 + (7.5 * tmpvar_15))
   + 
    ((0.002 + (0.02 * tmpvar_15)) * -(p_1.z))
  )) * normalize(p_1.xyz)));
  tmpvar_16.w = p_1.w;
  p_1 = (view.projection * tmpvar_16);
  gl_Position = p_1;
  v_uv = outputValue_2.uv;
  v_segment = outputValue_2.segment;
//FlyoverTraffic::flyoverTraffic_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Pattern {
  highp vec4 pattern;
struct Style {
  highp vec4 color;
  highp vec4 glow;
  highp vec2 ramp;
struct Shared {
  highp float skew;
in highp vec2 v_uv;
in highp vec2 v_segment;
uniform Pattern pattern;
uniform Style style;
uniform Shared sharedConstants;
inout lowp vec4 output_value;
void main ()
  lowp vec3 C_1;
  lowp float skew_2;
  lowp vec2 preF_3;
  lowp vec2 pre_4;
  lowp vec2 mask_5;
  highp float dsqr_6;
  lowp vec2 diff_7;
  lowp vec2 pixel_8;
  highp float tmpvar_9;
  tmpvar_9 = clamp (v_uv.y, v_segment.x, v_segment.y);
  highp float tmpvar_10;
  tmpvar_10 = fract(tmpvar_9);
  highp vec2 tmpvar_11;
  tmpvar_11.x = 0.0;
  tmpvar_11.y = tmpvar_10;
  pixel_8 = tmpvar_11;
  highp vec2 tmpvar_12;
  tmpvar_12.x = v_uv.x;
  tmpvar_12.y = (v_uv.y - (tmpvar_9 - tmpvar_10));
  highp vec2 tmpvar_13;
  tmpvar_13 = (pixel_8 - tmpvar_12);
  diff_7 = tmpvar_13;
  highp vec2 tmpvar_14;
  tmpvar_14.x = 0.0;
  tmpvar_14.y = (clamp (tmpvar_10, (0.5 - pattern.pattern.y), (0.5 + pattern.pattern.y)) - tmpvar_10);
  diff_7 = (diff_7 + tmpvar_14);
  lowp float tmpvar_15;
  tmpvar_15 = dot (diff_7, diff_7);
  dsqr_6 = tmpvar_15;
  highp vec2 tmpvar_16;
  tmpvar_16 = clamp (((pattern.pattern.zw - vec2(dsqr_6)) * (style.ramp / 
    (abs(dFdx(v_uv)) + abs(dFdy(v_uv)))
  .xx)), vec2(0.0, 0.0), vec2(1.0, 1.0));
  mask_5 = tmpvar_16;
  highp vec2 tmpvar_17;
  tmpvar_17.x = 1.0;
  tmpvar_17.y = style.glow.w;
  highp vec2 tmpvar_18;
  tmpvar_18 = (mask_5 * tmpvar_17);
  pre_4 = tmpvar_18;
  lowp vec2 tmpvar_19;
  tmpvar_19 = clamp (pre_4, vec2(0.0, 0.0), vec2(1.0, 1.0));
  preF_3.x = tmpvar_19.x;
  preF_3.y = (tmpvar_19.y * (1.0 - tmpvar_19.x));
  lowp float tmpvar_20;
  tmpvar_20 = (tmpvar_19.x + preF_3.y);
  highp float tmpvar_21;
  tmpvar_21 = (1.0 - ((sharedConstants.skew * tmpvar_20) * tmpvar_20));
  skew_2 = tmpvar_21;
  lowp float tmpvar_22;
  tmpvar_22 = (tmpvar_20 - (skew_2 * (1.0 - output_value.w)));
  lowp float tmpvar_23;
  if ((tmpvar_22 > 0.0)) {
    tmpvar_23 = tmpvar_22;
  } else {
    tmpvar_23 = 0.0;
  };
  highp vec3 tmpvar_24;
  tmpvar_24 = ((style.color.xyz * pre_4.xxx) + (style.glow.xyz * pre_4.yyy));
  C_1 = tmpvar_24;
  C_1 = ((mix (output_value.xyz, C_1, vec3(tmpvar_20)) * vec3(tmpvar_23)) + (output_value.xyz * vec3((1.0 - tmpvar_23))));
  lowp vec4 tmpvar_25;
  tmpvar_25.xyz = C_1;
  tmpvar_25.w = (1.0 - ((skew_2 * 
    (1.0 - output_value.w)
  ) + tmpvar_23));
  output_value = tmpvar_25;
//SolidLine::solidLine_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
struct View {
  highp mat4 modelViewProjection;
in highp vec3 vertexInput_position;
uniform View view;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xyz = vertexInput_1.position;
  gl_Position = (view.modelViewProjection * tmpvar_2);
//SolidLine::solidLine_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Style {
  highp vec4 color;
uniform Style style;
out mediump vec4 output_value;
void main ()
  output_value = style.color;
//Stars::stars_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp float color;
struct View {
  highp mat4 modelview;
  highp mat4 projection;
  highp float fadein;
  highp float pointsize;
struct VertexOut {
  highp float alpha;
in highp vec3 vertexInput_position;
in highp float vertexInput_color;
uniform View view;
out highp float v_alpha;
void main ()
  highp vec4 pw_1;
  VertexOut outputValue_2;
  VertexIn vertexInput_3;
  vertexInput_3.position = vertexInput_position;
  vertexInput_3.color = vertexInput_color;
  outputValue_2.alpha = (vertexInput_3.color * view.fadein);
  highp vec4 tmpvar_4;
  tmpvar_4.w = 0.0;
  tmpvar_4.xyz = vertexInput_3.position;
  highp vec4 tmpvar_5;
  tmpvar_5.w = 1.0;
  tmpvar_5.xyz = (view.modelview * tmpvar_4).xyz;
  highp vec4 tmpvar_6;
  tmpvar_6 = (view.projection * tmpvar_5);
  pw_1.xyw = (tmpvar_6 / tmpvar_6.wwww).xyw;
  pw_1.z = 0.9999999;
  gl_PointSize = view.pointsize;
  gl_Position = pw_1;
  v_alpha = outputValue_2.alpha;
//Stars::stars_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp float v_alpha;
out lowp vec4 output_value;
void main ()
  highp vec4 tmpvar_1;
  tmpvar_1.xyz = vec3(1.0, 1.0, 1.0);
  tmpvar_1.w = v_alpha;
  output_value = tmpvar_1;
//StenciledAlphaClear::stenciledAlphaClear_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
in highp vec2 vertexInput_position;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  highp vec4 tmpvar_2;
  tmpvar_2.zw = vec2(0.0, 1.0);
  tmpvar_2.xy = vertexInput_1.position;
  gl_Position = tmpvar_2;
//StenciledAlphaClear::stenciledAlphaClear_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
inout lowp vec4 output_value;
void main ()
  lowp vec4 tmpvar_1;
  tmpvar_1.w = 1.0;
  tmpvar_1.xyz = output_value.xyz;
  output_value = tmpvar_1;
//TileBaseSurface::tileBaseSurface_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 texcoord;
  highp vec2 texcoord2;
struct Element {
  highp mat4 modelview;
  highp vec2 tcScale;
  highp vec2 tcOffset;
  highp vec2 tcLimit;
struct Shared {
  highp mat4 projection;
  highp float levelFade;
  highp vec4 lineColor;
  highp vec4 backgroundColor;
  highp float majorSize;
  highp float minorSize;
  highp vec4 lineParams;
struct VertexOut {
  highp vec4 majorMinorVertex;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_texcoord;
in highp vec2 vertexInput_texcoord2;
uniform Element element;
uniform Shared sharedConstants;
out highp vec4 v_majorMinorVertex;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  vertexInput_2.texcoord2 = vertexInput_texcoord2;
  highp vec4 tmpvar_3;
  tmpvar_3.w = 1.0;
  tmpvar_3.xyz = vertexInput_2.position;
  gl_Position = (sharedConstants.projection * (element.modelview * tmpvar_3));
  highp vec2 tmpvar_4;
  tmpvar_4 = (mix ((vertexInput_2.texcoord * element.tcScale), (
    (vertexInput_2.texcoord2 * element.tcScale)
   * element.tcLimit.yy), vec2(float(
    (element.tcScale.x >= element.tcLimit.x)
  ))) + element.tcOffset);
  outputValue_1.majorMinorVertex.xy = (tmpvar_4 * vec2(sharedConstants.majorSize));
  outputValue_1.majorMinorVertex.zw = (tmpvar_4 * vec2(sharedConstants.minorSize));
  v_majorMinorVertex = outputValue_1.majorMinorVertex;
//TileBaseSurface::tileBaseSurface_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Shared {
  highp mat4 projection;
  highp float levelFade;
  highp vec4 lineColor;
  highp vec4 backgroundColor;
  highp float majorSize;
  highp float minorSize;
  highp vec4 lineParams;
in highp vec4 v_majorMinorVertex;
uniform Shared sharedConstants;
out mediump vec4 output_value;
void main ()
  lowp float grid_1;
  lowp vec4 g_2;
  mediump vec4 mi_3;
  lowp vec4 out_color_4;
  highp vec4 tmpvar_5;
  tmpvar_5 = sharedConstants.lineParams;
  mi_3 = tmpvar_5;
  highp vec4 tmpvar_6;
  tmpvar_6 = clamp (((
    abs((fract((v_majorMinorVertex - vec4(0.5, 0.5, 0.5, 0.5))) - vec4(0.5, 0.5, 0.5, 0.5)))
   / 
    (abs(dFdx(v_majorMinorVertex)) + abs(dFdy(v_majorMinorVertex)))
  ) - mi_3), vec4(0.0, 0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 1.0));
  g_2 = tmpvar_6;
  lowp float tmpvar_7;
  tmpvar_7 = min (g_2.x, g_2.y);
  lowp float tmpvar_8;
  tmpvar_8 = min (g_2.z, g_2.w);
  highp float tmpvar_9;
  tmpvar_9 = mix (tmpvar_8, tmpvar_7, sharedConstants.levelFade);
  grid_1 = tmpvar_9;
  lowp vec4 tmpvar_10;
  tmpvar_10 = vec4((1.0 - grid_1));
  highp vec4 tmpvar_11;
  tmpvar_11 = ((sharedConstants.lineColor * tmpvar_10) + (sharedConstants.backgroundColor * vec4(grid_1)));
  out_color_4 = tmpvar_11;
  output_value = out_color_4;
//TileSkybox::tileSkybox_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec2 texcoord;
struct Element {
  highp mat4 modelview;
  highp float blendfactor;
struct View {
  highp mat4 projection;
struct VertexOut {
  highp vec2 iTextureCoord0;
in highp vec3 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform Element element;
uniform View view;
out highp vec2 v_iTextureCoord0;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  highp vec2 tmpvar_3;
  tmpvar_3.x = vertexInput_2.texcoord.x;
  tmpvar_3.y = (1.0 - vertexInput_2.texcoord.y);
  outputValue_1.iTextureCoord0 = tmpvar_3;
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = vertexInput_2.position;
  gl_Position = (view.projection * (element.modelview * tmpvar_4));
  gl_Position.z = (gl_Position.z - ((
    sign(element.blendfactor)
   * 
    clamp ((1.0 - abs(element.blendfactor)), 0.0, 1.0)
  ) * 0.02));
  v_iTextureCoord0 = outputValue_1.iTextureCoord0;
//TileSkybox::tileSkybox_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Element {
  highp mat4 modelview;
  highp float blendfactor;
in highp vec2 v_iTextureCoord0;
uniform Element element;
uniform sampler2D textureMap0;
out mediump vec4 output_value;
void main ()
  mediump vec4 out_color_1;
  mediump vec4 tex0_2;
  lowp vec4 tmpvar_3;
  tmpvar_3 = texture (textureMap0, v_iTextureCoord0);
  tex0_2 = tmpvar_3;
  mediump vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = tex0_2.xyz;
  out_color_1.xyz = tmpvar_4.xyz;
  highp float tmpvar_5;
  tmpvar_5 = abs(element.blendfactor);
  out_color_1.w = tmpvar_5;
  output_value = out_color_1;
//ImageCopy::imageCopy_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct VertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
out highp vec2 v_texcoord;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = ((vertexInput_2.position * vec2(2.0, 2.0)) - vec2(1.0, 1.0));
  gl_Position = tmpvar_3;
  v_texcoord = outputValue_1.texcoord;
//ImageCopy::imageCopy_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texcoord;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  output_value = texture (textureMap, v_texcoord);
ffffff
333333
?es-8R
N@UUUUUU
>N@DDDDDD
@DDDDDD
p?VU
E?fff?
THA9
>fff?
fff?fff?fff?fff?
33s?
33s?
>gf&
L?ff
4M@>
#/@V
333333
HsG&
%> 9
@(#)PROGRAM:VectorKit  PROJECT:VectorKit-
o8`?
//Clear::clear_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct ClearConstants {
  highp vec4 color;
  highp float depth;
in highp vec2 vertexInput_position;
uniform ClearConstants clearConstants;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xy = vertexInput_1.position;
  tmpvar_2.z = clearConstants.depth;
  gl_Position = tmpvar_2;
//Clear::clear_depth_stencil_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
void main ();
//Clear::clear_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct ClearConstants {
  highp vec4 color;
  highp float depth;
in highp vec2 vertexInput_position;
uniform ClearConstants clearConstants;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xy = vertexInput_1.position;
  tmpvar_2.z = clearConstants.depth;
  gl_Position = tmpvar_2;
//Clear::clear_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct ClearConstants {
  highp vec4 color;
  highp float depth;
uniform ClearConstants clearConstants;
out lowp vec4 output_value;
void main ()
  output_value = clearConstants.color;
//Clear::clear_vertex_mrt
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct ClearConstants {
  highp vec4 color;
  highp float depth;
in highp vec2 vertexInput_position;
uniform ClearConstants clearConstants;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xy = vertexInput_1.position;
  tmpvar_2.z = clearConstants.depth;
  gl_Position = tmpvar_2;
//Clear::clear_fragment2
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct ClearConstants {
  highp vec4 color;
  highp float depth;
uniform ClearConstants clearConstants;
out lowp vec4 v_color0;
out lowp vec4 v_color1;
void main ()
  lowp vec4 lowColor_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = clearConstants.color;
  lowColor_1 = tmpvar_2;
  v_color0 = lowColor_1;
  v_color1 = lowColor_1;
//Clear::clear_vertex_mrt
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct ClearConstants {
  highp vec4 color;
  highp float depth;
in highp vec2 vertexInput_position;
uniform ClearConstants clearConstants;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xy = vertexInput_1.position;
  tmpvar_2.z = clearConstants.depth;
  gl_Position = tmpvar_2;
//Clear::clear_fragment3
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct ClearConstants {
  highp vec4 color;
  highp float depth;
uniform ClearConstants clearConstants;
out lowp vec4 v_color0;
out lowp vec4 v_color1;
out lowp vec4 v_color2;
void main ()
  lowp vec4 lowColor_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = clearConstants.color;
  lowColor_1 = tmpvar_2;
  v_color0 = lowColor_1;
  v_color1 = lowColor_1;
  v_color2 = lowColor_1;
//Clear::clear_vertex_mrt
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
struct ClearConstants {
  highp vec4 color;
  highp float depth;
in highp vec2 vertexInput_position;
uniform ClearConstants clearConstants;
void main ()
  VertexIn vertexInput_1;
  vertexInput_1.position = vertexInput_position;
  highp vec4 tmpvar_2;
  tmpvar_2.w = 1.0;
  tmpvar_2.xy = vertexInput_1.position;
  tmpvar_2.z = clearConstants.depth;
  gl_Position = tmpvar_2;
//Clear::clear_fragment4
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct ClearConstants {
  highp vec4 color;
  highp float depth;
uniform ClearConstants clearConstants;
out lowp vec4 v_color0;
out lowp vec4 v_color1;
out lowp vec4 v_color2;
out lowp vec4 v_color3;
void main ()
  lowp vec4 lowColor_1;
  highp vec4 tmpvar_2;
  tmpvar_2 = clearConstants.color;
  lowColor_1 = tmpvar_2;
  v_color0 = lowColor_1;
  v_color1 = lowColor_1;
  v_color2 = lowColor_1;
  v_color3 = lowColor_1;
//ColoredText::coloredText_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec2 position;
  highp vec2 texcoord;
  lowp vec4 color;
  lowp vec4 outlinecolor;
struct View {
  highp mat4 modelViewProjectionMatrix;
struct VertexOut {
  highp vec2 texcoord;
  lowp vec4 color;
  lowp vec4 outlinecolor;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
in lowp vec4 vertexInput_color;
in lowp vec4 vertexInput_outlinecolor;
uniform View view;
out highp vec2 v_texcoord;
out lowp vec4 v_color;
out lowp vec4 v_outlinecolor;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  vertexInput_2.color = vertexInput_color;
  vertexInput_2.outlinecolor = vertexInput_outlinecolor;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  outputValue_1.color = vertexInput_2.color;
  outputValue_1.outlinecolor = vertexInput_2.outlinecolor;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
  v_color = outputValue_1.color;
  v_outlinecolor = outputValue_1.outlinecolor;
//ColoredText::coloredText_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texcoord;
in lowp vec4 v_color;
in lowp vec4 v_outlinecolor;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  lowp vec4 tmpvar_1;
  tmpvar_1 = texture (textureMap, v_texcoord);
  output_value = ((v_color * tmpvar_1.xxxx) + (v_outlinecolor * tmpvar_1.yyyy));
//ShadedColor::shadedColor_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct VertexIn {
  highp vec3 position;
  highp vec3 normal;
struct Global {
  highp mat4 view;
  highp mat4 projection;
struct Props {
  highp vec4 color;
  highp vec3 eyelightdir;
  highp vec3 scale;
  highp mat4 modelview;
struct VertexOut {
  highp vec3 normal;
in highp vec3 vertexInput_position;
in highp vec3 vertexInput_normal;
uniform Global global;
uniform Props props;
out highp vec3 v_normal;
void main ()
  VertexOut outputValue_1;
  VertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.normal = vertexInput_normal;
  highp mat3 tmpvar_3;
  tmpvar_3[uint(0)] = props.modelview[0].xyz;
  tmpvar_3[1u] = props.modelview[1].xyz;
  tmpvar_3[2u] = props.modelview[2].xyz;
  outputValue_1.normal = (tmpvar_3 * vertexInput_2.normal);
  highp vec4 tmpvar_4;
  tmpvar_4.w = 1.0;
  tmpvar_4.xyz = (props.scale * vertexInput_2.position);
  gl_Position = ((global.projection * props.modelview) * tmpvar_4);
  v_normal = outputValue_1.normal;
//ShadedColor::shadedColor_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
struct Props {
  highp vec4 color;
  highp vec3 eyelightdir;
  highp vec3 scale;
  highp mat4 modelview;
in highp vec3 v_normal;
uniform Props props;
out highp vec4 output_value;
void main ()
  highp float tmpvar_1;
  tmpvar_1 = dot (v_normal, props.eyelightdir);
  highp vec4 tmpvar_2;
  tmpvar_2.x = (tmpvar_1 * props.color.x);
  tmpvar_2.y = (tmpvar_1 * props.color.y);
  tmpvar_2.z = (tmpvar_1 * props.color.z);
  tmpvar_2.w = props.color.w;
  output_value = tmpvar_2;
//TextureRect::textureRect_vertex
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
#extension GL_APPLE_clip_distance : enable
out highp float gl_ClipDistance[6];
struct TextureVertexIn {
  highp vec2 position;
  highp vec2 texcoord;
struct View {
  highp mat4 modelViewProjectionMatrix;
struct TextureVertexOut {
  highp vec2 texcoord;
in highp vec2 vertexInput_position;
in highp vec2 vertexInput_texcoord;
uniform View view;
out highp vec2 v_texcoord;
void main ()
  TextureVertexOut outputValue_1;
  TextureVertexIn vertexInput_2;
  vertexInput_2.position = vertexInput_position;
  vertexInput_2.texcoord = vertexInput_texcoord;
  outputValue_1.texcoord = vertexInput_2.texcoord;
  highp vec4 tmpvar_3;
  tmpvar_3.zw = vec2(0.0, 1.0);
  tmpvar_3.xy = vertexInput_2.position;
  gl_Position = (view.modelViewProjectionMatrix * tmpvar_3);
  v_texcoord = outputValue_1.texcoord;
//TextureRect::textureRect_fragment
#version 300 es
#extension GL_EXT_shader_framebuffer_fetch : enable
in highp vec2 v_texcoord;
uniform sampler2D textureMap;
out lowp vec4 output_value;
void main ()
  output_value = texture (textureMap, v_texcoord);
ression_astc_ldrKHR_texture_compcard_framebufferGL_EXT_discard_f
Ga=NSt3__110__function6__funcIPFbRN3geo10ibitstreamERN3gss16StylePropertySetINS5_10PropertyIDEEEyNS5_18StylePropertyIndexERKNS5_15DecodingContextERNS_19basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEEENSH_ISM_EESL_EE
NSt3__110__function6__baseIFbRN3geo10ibitstreamERN3gss16StylePropertySetINS5_10PropertyIDEEEyNS5_18StylePropertyIndexERKNS5_15DecodingContextERNS_19basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEE
PFbRN3geo10ibitstreamERN3gss16StylePropertySetINS2_10PropertyIDEEEyNS2_18StylePropertyIndexERKNS2_15DecodingContextERNSt3__119basic_ostringstreamIcNSB_11char_traitsIcEENSB_9allocatorIcEEEEE
FbRN3geo10ibitstreamERN3gss16StylePropertySetINS2_10PropertyIDEEEyNS2_18StylePropertyIndexERKNS2_15DecodingContextERNSt3__119basic_ostringstreamIcNSB_11char_traitsIcEENSB_9allocatorIcEEEEE
NSt3__110__function6__funcIPFbRN3geo10ibitstreamERN3gss16StylePropertySetINS5_15ScenePropertyIDEEEyNS5_24SceneConfigPropertyIndexERKNS5_15DecodingContextERNS_19basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEEENSH_ISM_EESL_EE
NSt3__110__function6__baseIFbRN3geo10ibitstreamERN3gss16StylePropertySetINS5_15ScenePropertyIDEEEyNS5_24SceneConfigPropertyIndexERKNS5_15DecodingContextERNS_19basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEE
PFbRN3geo10ibitstreamERN3gss16StylePropertySetINS2_15ScenePropertyIDEEEyNS2_24SceneConfigPropertyIndexERKNS2_15DecodingContextERNSt3__119basic_ostringstreamIcNSB_11char_traitsIcEENSB_9allocatorIcEEEEE
FbRN3geo10ibitstreamERN3gss16StylePropertySetINS2_15ScenePropertyIDEEEyNS2_24SceneConfigPropertyIndexERKNS2_15DecodingContextERNSt3__119basic_ostringstreamIcNSB_11char_traitsIcEENSB_9allocatorIcEEEEE
Default
=>=h/?R
reH=u^
N&>cJ
?ffF@
N3mdc16LayerDataManagerE
N3geo11_retain_ptrIPU28objcproto17OS_dispatch_group8NSObjectNS_16_retain_dispatchIS3_EENS_17_release_dispatchENS_9_hash_ptrENS_10_equal_ptrEEE
NSt3__110__function6__funcIZN3mdc16LayerDataManagerC1ENS_8functionIFvvEEEPN3geo9TaskQueueEE3$_0NS_9allocatorISA_EES5_EE
NSt3__110__function6__baseIFvvEEE
ZN3mdc16LayerDataManagerC1ENSt3__18functionIFvvEEEPN3geo9TaskQueueEE3$_0
N3mdc12TileSelectorE
N3mdc15LayerDataSourceE
NSt3__119basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__110__function6__funcIZN3mdc15LayerDataSourceC1EtPNS2_14LayerDataStoreERNS2_23ResourceStatusContainerEPN3geo9TaskQueueEE3$_2NS_9allocatorISB_EEFvvEEE
ZN3mdc15LayerDataSourceC1EtPNS_14LayerDataStoreERNS_23ResourceStatusContainerEPN3geo9TaskQueueEE3$_2
NSt3__110__function6__funcIZN3mdc15LayerDataSource22setNeedsUpdateFunctionENS_8functionIFvvEEEE3$_3NS_9allocatorIS7_EEFvRKNS_10shared_ptrINS2_9LayerDataEEEEEE
NSt3__110__function6__baseIFvRKNS_10shared_ptrIN3mdc9LayerDataEEEEEE
ZN3mdc15LayerDataSource22setNeedsUpdateFunctionENSt3__18functionIFvvEEEE3$_3
NSt3__110__function6__funcIZN3mdc15LayerDataSource24processLayerDataRequestsEPNS2_15ResourceManagerEPN3geo9TaskGroupExE3$_5NS_9allocatorIS9_EEFvvEEE
ZN3mdc15LayerDataSource24processLayerDataRequestsEPNS_15ResourceManagerEPN3geo9TaskGroupExE3$_5
N3mdc16FlatTileSelectorE
N3mdc9LayerDataE
N3mdc15ResourceFetcherE
NSt3__110__function6__funcIZN3mdc15ResourceFetcher14createResourceEyRKNS2_11ResourceKeyENS2_26ResourceOriginalLoadReasonENS2_14ResourceSourceExbRKNS2_21RawResourceSourceDataEE3$_0NS_9allocatorISC_EEFvvEEE
ZN3mdc15ResourceFetcher14createResourceEyRKNS_11ResourceKeyENS_26ResourceOriginalLoadReasonENS_14ResourceSourceExbRKNS_21RawResourceSourceDataEE3$_0
NSt3__110__function6__funcIZN3mdc15ResourceFetcher14createResourceEyRKNS2_11ResourceKeyENS2_26ResourceOriginalLoadReasonENS2_14ResourceSourceExbRKNS2_21RawResourceSourceDataEE3$_1NS_9allocatorISC_EEFvvEEE
ZN3mdc15ResourceFetcher14createResourceEyRKNS_11ResourceKeyENS_26ResourceOriginalLoadReasonENS_14ResourceSourceExbRKNS_21RawResourceSourceDataEE3$_1
N3mdc23ResourceStatusContainerE
N3mdc23ResourceRequestObserverE
N3mdc15ResourceManagerE
N3mdc24ResourceManifestInformerE
NSt3__110__function6__funcIZN3mdc15ResourceManagerC1EPN3geo9TaskQueueENS_8functionIFvvEEEE3$_0NS_9allocatorISA_EEFNS_12basic_stringIcNS_11char_traitsIcEENSB_IcEEEEtEEE
NSt3__110__function6__baseIFNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEtEEE
ZN3mdc15ResourceManagerC1EPN3geo9TaskQueueENSt3__18functionIFvvEEEE3$_0
NSt3__110__function6__funcIZN3mdc15ResourceManagerD1EvE3$_1NS_9allocatorIS4_EEFvvEEE
ZN3mdc15ResourceManagerD1EvE3$_1
NSt3__120__shared_ptr_emplaceIN3mdc13ResourceStoreENS_9allocatorIS2_EEEE
NSt3__110__function6__funcIZN3mdc15ResourceManager18addResourceFetcherEONS_10unique_ptrINS2_15ResourceFetcherENS_14default_deleteIS5_EEEEE3$_2NS_9allocatorISA_EEFvRKNS_6vectorINS_10shared_ptrINS2_8ResourceEEENSB_ISG_EEEERKNSD_INS2_15ResourceRequestENSB_ISL_EEEESP_EEE
NSt3__110__function6__baseIFvRKNS_6vectorINS_10shared_ptrIN3mdc8ResourceEEENS_9allocatorIS6_EEEERKNS2_INS4_15ResourceRequestENS7_ISC_EEEESG_EEE
ZN3mdc15ResourceManager18addResourceFetcherEONSt3__110unique_ptrINS_15ResourceFetcherENS1_14default_deleteIS3_EEEEE3$_2
NSt3__110__function6__funcIZN3mdc15ResourceManager18addResourceFetcherEONS_10unique_ptrINS2_15ResourceFetcherENS_14default_deleteIS5_EEEEE3$_3NS_9allocatorISA_EEFvRKNS_13unordered_setINS2_11ResourceKeyENS2_15ResourceKeyHashENS_8equal_toISE_EENSB_ISE_EEEEEEE
NSt3__110__function6__baseIFvRKNS_13unordered_setIN3mdc11ResourceKeyENS3_15ResourceKeyHashENS_8equal_toIS4_EENS_9allocatorIS4_EEEEEEE
ZN3mdc15ResourceManager18addResourceFetcherEONSt3__110unique_ptrINS_15ResourceFetcherENS1_14default_deleteIS3_EEEEE3$_3
NSt3__110__function6__funcIZN3mdc15ResourceManager18addResourceFetcherEONS_10unique_ptrINS2_15ResourceFetcherENS_14default_deleteIS5_EEEEE3$_4NS_9allocatorISA_EEFvRKNS_10shared_ptrINS2_8ResourceEEEEEE
NSt3__110__function6__baseIFvRKNS_10shared_ptrIN3mdc8ResourceEEEEEE
ZN3mdc15ResourceManager18addResourceFetcherEONSt3__110unique_ptrINS_15ResourceFetcherENS1_14default_deleteIS3_EEEEE3$_4
N3mdc23ConsistentZTileSelectorE
N3mdc10StatisticsE
N3mdc16SelectionContextE
N3mdc23TileSetSelectionContextE
N3mdc20LoadingStatusTrackerE
N3mdc29ResourceLoadingStatusObserverE
N3mdc9HistogramE
NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
public.png
Failed to write image to %s
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
isValid
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/Submodules/Easel/context/context.cpp
(valid) && "Invalid QuartzContext: missing CGContextRef."
write
(ImageFormat::PNG == format) && "Only PNG is supported for writing thus far"
setAlpha
(0.0f <= alpha && 1.0f >= alpha) && "Alpha values are expected to be 0.0 <= alpha <= 1.0"
setShadowWithColor
(0 <= radius) && "Can not set shadow with negative blur radius"
pngData
false && "Need to implement QuartzContext::pngData before using."
QuartzColor
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/Submodules/Easel/context/color.cpp
(r >= 0.0f && g >= 0.0f && b >= 0.0f && a >= 0.0f) && "Colors must be between 0 and 1."
(r <= 1.0f && g <= 1.0f && b <= 1.0f && a <= 1.0f) && "Colors must be between 0 and 1."
_hasValue
optional has no value. Undefined behavior.
/BuildRoot/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator13.2.Internal.sdk/usr/local/include/GeoStdLib/Optional.hpp
%s : Assertion with expression - %s : Failed in file - %s line - %i
Assertion with expression - %s : Failed in file - %s line - %i
apple
%s&z=%d&x=%d&y=%d&h=0
georesource_c3h
%s_%i_%i_%i.c3h
georesource_c3b
%s_%i_%i_%i.c3b
%s%i/%i/map_%i_%i_%i%s
%s&z=%d&x=%d&y=%d&h=%d
%s%i/%i/map_%i_%i_%i_%i%s
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
altitude.xml
Transit Item:
Tile:%s
LayoutZoom:%.2f
Tile:%s
default
iconManager
T@"VKInternalIconManager",R,N
textureManager
T{shared_ptr<md::TextureManager>=^{TextureManager}^{__shared_weak_count}},R,N
resourceManager
T@"VKResourceManager",R,N
stylesheetVendor
T{shared_ptr<md::StylesheetVendor>=^{StylesheetVendor}^{__shared_weak_count}},R,N,V_stylesheetVendor
device
T^{Device=i{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{unique_ptr<md::SharedDeviceResources, std::__1::default_delete<md::SharedDeviceResources> >={__compressed_pair<md::SharedDeviceResources *, std::__1::default_delete<md::SharedDeviceResources> >=^{SharedDeviceResources}}}},R,N
gglDevice
T^{Device=^^?{DeviceVersion=II}{DeviceCapabilities=BBIII{DeviceSize=III}}{DeviceAPIProperties=iidB}ii},R,N
alphaAtlas
T^{AlphaAtlas=BIIIf{unique_ptr<ggl::Texture2D, std::__1::default_delete<ggl::Texture2D> >={__compressed_pair<ggl::Texture2D *, std::__1::default_delete<ggl::Texture2D> >=^{Texture2D}}}},R,N
highInflationAlphaAtlas
T^{IsoAlphaAtlas=IIf{unique_ptr<ggl::Texture2D, std::__1::default_delete<ggl::Texture2D> >={__compressed_pair<ggl::Texture2D *, std::__1::default_delete<ggl::Texture2D> >=^{Texture2D}}}{shared_ptr<ggl::SamplerState>=^{SamplerState}^{__shared_weak_count}}},R,N
isoAlphaAtlas
distanceAtlas
T^{DistanceAtlas=III{unique_ptr<ggl::Texture2D, std::__1::default_delete<ggl::Texture2D> >={__compressed_pair<ggl::Texture2D *, std::__1::default_delete<ggl::Texture2D> >=^{Texture2D}}}},R,N
shaderLibrary
Tr^{StandardLibrary=^^?^{ResourceManager}^{RenderResource}^{ShaderLibraryDescriptor}{vector<ggl::ShaderLibrary::FunctionEntry, geo::StdAllocator<ggl::ShaderLibrary::FunctionEntry, ggl::Allocator> >=^{FunctionEntry}^{FunctionEntry}{__compressed_pair<ggl::ShaderLibrary::FunctionEntry *, geo::StdAllocator<ggl::ShaderLibrary::FunctionEntry, ggl::Allocator> >=^{FunctionEntry}{StdAllocator<ggl::ShaderLibrary::FunctionEntry, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ShaderLibrary::ShaderEntry, geo::StdAllocator<ggl::ShaderLibrary::ShaderEntry, ggl::Allocator> >=^{ShaderEntry}^{ShaderEntry}{__compressed_pair<ggl::ShaderLibrary::ShaderEntry *, geo::StdAllocator<ggl::ShaderLibrary::ShaderEntry, ggl::Allocator> >=^{ShaderEntry}{StdAllocator<ggl::ShaderLibrary::ShaderEntry, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ShaderLibrary::ComputeShaderEntry, geo::StdAllocator<ggl::ShaderLibrary::ComputeShaderEntry, ggl::Allocator> >=^{ComputeShaderEntry}^{ComputeShaderEntry}{__compressed_pair<ggl::ShaderLibrary::ComputeShaderEntry *, geo::StdAllocator<ggl::ShaderLibrary::ComputeShaderEntry, ggl::Allocator> >=^{ComputeShaderEntry}{StdAllocator<ggl::ShaderLibrary::ComputeShaderEntry, ggl::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<ggl::Shader>, geo::StdAllocator<std::__1::shared_ptr<ggl::Shader>, ggl::Allocator> >=^{shared_ptr<ggl::Shader>}^{shared_ptr<ggl::Shader>}{__compressed_pair<std::__1::shared_ptr<ggl::Shader> *, geo::StdAllocator<std::__1::shared_ptr<ggl::Shader>, ggl::Allocator> >=^{shared_ptr<ggl::Shader>}{StdAllocator<std::__1::shared_ptr<ggl::Shader>, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::ShaderLibraryData>=^{ShaderLibraryData}^{__shared_weak_count}}},R,N
grlIconManager
T^{IconManager=^^?{shared_ptr<grl::ResourceProvider>=^{ResourceProvider}^{__shared_weak_count}}{read_write_lock={_opaque_pthread_rwlock_t=q[192c]}}B^{PackInfo}{read_write_lock={_opaque_pthread_rwlock_t=q[192c]}}{map<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock, std::__1::less<std::__1::pair<std::__1::basic_string<char>, float> >, geo::StdAllocator<std::__1::pair<const std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, grl::Allocator> >={__tree<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, std::__1::__map_value_compare<std::__1::pair<std::__1::basic_string<char>, float>, std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, std::__1::less<std::__1::pair<std::__1::basic_string<char>, float> >, true>, geo::StdAllocator<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, grl::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, void *>, grl::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, void *>, grl::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::pair<std::__1::basic_string<char>, float>, std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, std::__1::less<std::__1::pair<std::__1::basic_string<char>, float> >, true> >=Q}}}{shared_ptr<grl::FontManager>=^{FontManager}^{__shared_weak_count}}},R,N
grlFontManager
T{shared_ptr<grl::FontManager>=^{FontManager}^{__shared_weak_count}},R,N
defaultDecompressionSession
T^{FigPhotoDecompressionSession=},R,N
v8@?0
FeatureCount:
NavStates
 None:
 Behind:
 Approaching:
 Ahead:
IconStates
 POI:
 Callout:
 Picked:
DefaultVbo
vertex_pos
texture
Standard
Flyover
Munin
<Invalid>
ColorGlyphWithNormalHaloShader
vertex_attributes_position
vertex_attributes_texture
vertex_attributes_alphaAndHaloSizeInPixels
vertex_attributes_color
vertex_attributes_haloColor
vertex_attributes_deviceBufferIndex
vertex_attributes_tangent
vertex_attributes_bitangent
vertex_attributes
view.projectionMatrix
view.screenProjectionMatrix
labelOptions.useDeviceBufferMatrix
labelOptions.opacity
floatBufferTextureSize.width
floatBufferTextureSize.height
glyphOptions.isHalo
glyphOptions.maxHaloDistanceStored
glyphOptions.maxExtrusionDepth
glyphOptions.maxStrokeWidth
glyphOptions.superSamplingKernelSize
view
labelOptions
floatBufferTextureSize
glyphOptions
textureAtlas
floatBufferTexture
floatBufferTexture_sampler
textureAtlas_sampler
com.apple.VectorKit
RouteOverlayLogic
C3_LOD_SCALE
maneuver points
maneuver indices
mp mesh
mp fill renderitem
mp stroke renderitem
read lock
com.apple.GeoStdLib
Locking
unlock
initialization
destruction
write lock
Glyph3dShader
Glyph3dLowPrecisionHaloShader
Glyph3dLowPrecisionShader
byteBufferTextureSize.width
byteBufferTextureSize.height
byteBufferTextureSize
byteBufferTexture
byteBufferTexture_sampler
FlyoverShader
vertexInput_position
vertexInput_texcoord
vertexInput
sharedConstants.projection
sharedConstants.atmospherecolor
sharedConstants.horizonvalues
sharedConstants.lightdirection
sharedConstants.nightlightfade
transform.modelview
transform.modelmat
clip.clipPlanes
material.blendfactor
texcoords.offset
texcoords.scale
sharedConstants
transform
clip
material
texcoords
atmosphere
diffuse
atmosphere_sampler
diffuse_sampler
com.apple.mapdisplay.stylesheetLoadQueue
position: %s
orientation quaternion: %f, %f, %f, %f
Frustum width: %.9f, height: %.9f, near: %.9f, far: %.9f
view projection matrix:
Super: VKCamera
position
%f, %f, %f, %f
orientation quaternion
%.9f, height: %.9f, near: %.9f, far: %.9f
Frustum width
view projection matrix
Attempt to set camera position set to NANs (%f, %f, %f)! Bailing
frustum
T{?=Bddddd},R,N
Tr^{Matrix<double, 3, 1>=[3d]},N
orientation
Tr^{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d},N
aspectRatio
Td,N,V_aspectRatio
horizontalFieldOfView
T{Unit<RadianUnitDescription, double>=d},R,N
verticalFieldOfView
T{Unit<RadianUnitDescription, double>=d},N
farClipDistance
Td,R,N
nearClipDistance
ndcZNear
Td,N,V_ndcZNear
cameraState
T{VKCameraState={RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}d{Unit<RadianUnitDescription, double>=d}d},N
minHeight
Td,N,V_minHeight
maxHeight
Td,N,V_maxHeight
maxHeightNoPitch
Td,N,V_maxHeightNoPitch
maxPitch
Td,N,V_maxPitch
minDistanceToGroundRestriction
T{optional<double>=B(ValueUnion=[8C]d)},N,V_minDistanceToGroundRestriction
maxDistanceToGroundRestriction
T{optional<double>=B(ValueUnion=[8C]d)},N,V_maxDistanceToGroundRestriction
regionRestriction
T@"VKCameraRegionRestriction",&,N,V_regionRestriction
terrainHeight
Td,N,V_terrainHeight
viewVolume
T@"VKViewVolume",R,N
footprint
T@"VKFootprint",R,N
upVector
T{Matrix<double, 3, 1>=[3d]},R,N
rightVector
forwardVector
groundPoint
pitch
tanHalfHorizFOV
tanHalfVerticalFOV
distanceToGroundAndFarClipPlaneIntersection
Td,R,N,V_distanceToGroundAndFarClipPlaneIntersection
screenHeightOfGroundAndFarClipPlaneIntersection
Td,R,N,V_screenHeightOfGroundAndFarClipPlaneIntersection
fractionOfScreenAboveFarClipPlaneAtCanonicalPitch
Td,N,V_fractionOfScreenAboveFarClipPlaneAtCanonicalPitch
allowDatelineWraparound
TB,N,V_allowDatelineWraparound
canonicalPitch
Td,N,V_canonicalPitch
horizontalOffset
Td,N,V_horizontalOffset
scaledViewMatrix
Tr^{Matrix<double, 4, 4>=[16d]},R,N
scaledProjectionMatrix
scaledViewProjectionMatrix
unscaledViewMatrix
unscaledProjectionMatrix
AlloyCommonLibrary
metallib
metal_libraries
/VertexData
Simple2DBuffer
Simple3DBuffer
q40@?0d8d16d24d32
B24@?0{?=dd}8
boundingRect
T{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}},R,N,V_boundingRect
convexHull
T{VKFootprintConvexHull_struct=i[6{Matrix<double, 3, 1>=[3d]}][6{Matrix<double, 3, 1>=[3d]}]},R,N,V_convexHull
minDepth
Td,R,N,V_minDepth
maxDepth
Td,R,N,V_maxDepth
centerDepth
Td,R,N,V_centerDepth
furthestGroundPoint
T{Matrix<double, 3, 1>=[3d]},R,N,V_furthestGroundPoint
nearestGroundPoint
T{Matrix<double, 3, 1>=[3d]},R,N,V_nearestGroundPoint
cornerGroundPoints
T^{Matrix<double, 3, 1>=[3d]},R,N
cornerGroundPointsCount
Ti,R,N,V_cornerGroundPointsCount
EndOfWorldShader
modelview
blend
Element
projection
texscale
Shared
vertex_attributes_texcoord
element.modelview
element.blend
sharedConstants.texscale
element
textureMap0
textureMap0_sampler
texcoord
corners
Tr^{Matrix<double, 3, 1>=[3d]},R,N
FlyoverNightDimShader
color
Color
vertexInput_unit
color.color
Quad
unit
"%s"
 (%s/
%.2f
/%.f
  U+%04x : %C
  %@ - %@
LabelText
Text
Font Family Name
Font Size
/GridMesh
/GridIndexData
/images/arrow.png
/route/element/clear/vdata
/route/element/clear/idata
/route/element/clear/mesh
routeAnimation
v36@?0i8f12f16r^{Matrix<float, 2, 1>=[2f]}20I28B32
v64@?0^{?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}8I16I20i24f28f32i36r^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}40C48^{Matrix<float, 2, 1>=[2f]}52I60
v16@?0^{ResourceAccessor=^^?}8
BatchType/VData
BatchType/IData
BatchType/Mesh
/Element
/render/heightmeshbuilder/indexdata
ManeuverPointShader
color
halfWidth
Style
vertexInput_normal
view.modelViewProjectionMatrix
view.tilePerPoint
style.color
style.halfWidth
style
alphaMap
alphaMap_sampler
normal
SDFGlyphShader
SDFGlyphSuperSampleShader
SDFGlyphHaloShader
VKMapViewDidBecomeFullyDrawnNotification
CAProcessCanAccessGPU
v12@?0f8
v12@?0B8
contentScale is unreasonable (NaN or Inf)
com.apple.Maps
ActivateMapInspectorOnLaunch
f12@?0f8
v16@?0@"NSString"8
v12@?0i8
%s (count) [%3.0f, %3.0f]ms
Debug Model Tile
Byte Count
tileStatistics:%@:total-tile-byte-count
tileStatistics:%@:total-tile-count
tileStatistics:%@:%@
resourceLoading:%s:%s:total-count-bytes
resourceLoading:%s:%s:total-count
resourceLoading:%s:decode:avg-time-ms
resourceLoading:%s:decode:min-time-ms
resourceLoading:%s:decode:max-time-ms
resourceLoading:%s:decode:total-count
tileStatistics:ALL:total-tile-byte-count
tileStatistics:ALL:total-tile-count
annotationTrackingZoomStyle
Tq,N
annotationTrackingHeadingAnimationDisplayRate
trackingAnnotation
T@"<VKTrackableAnnotation>",R,N
isAnimatingToTrackAnnotation
TB,R,N
isTrackingHeading
hasFailedTiles
shouldLoadFallbackTiles
TB,N
shouldLoadMapMargin
mapDelegate
T@"<VKMapViewDelegate>",N,V_mapDelegate
cameraDelegate
T@"<VKMapViewCameraDelegate>",N
staysCenteredDuringPinch
staysCenteredDuringRotation
hostDisplay
T@"CADisplay",&,N
isPitchable
pitched
TB,R,N,GisPitched
fullyPitched
TB,R,N,GisFullyPitched
canEnter3DMode
showingFlyover
TB,R,N,GisShowingFlyover
canShowFlyover
trafficEnabled
trafficIncidentsEnabled
displayRate
navigationDisplayRate
localizeLabels
labelScaleFactor
flyoverMode
Ti,R,N
mapType
Ti,N
mapDisplayStyle
T{?=CCCCB},N
styleZOffsetScale
Tf,N
targetDisplay
vehicleState
T{?=B},N
emphasis
TC,N
applicationUILayout
labelMarkerSelectionEnabled
TB,N,GisLabelMarkerSelectionEnabled
shieldSize
navigationShieldSize
shieldIdiom
showsRoadLabels
showsPointLabels
showsPointsOfInterest
showsBuildings
showsVenues
loadMuninAvailability
pointsOfInterestFilter
T@"GEOPOICategoryFilter",&,N,V_pointsOfInterestFilter
userLocationAnimator
T@"VKPuckAnimator",R,N,V_userLocationAnimator
edgeInsets
T{VKEdgeInsets=ffff},N
fullyOccludedEdgeInsets
labelEdgeInsets
mapRegion
T@"GEOMapRegion",R,N
presentationYaw
altitude
centerCoordinate
T{?=ddd},R,N
gesturing
TB,N,GisGesturing
iconsShouldAlignToPixels
fullyDrawn
TB,R,N,GisFullyDrawn
sceneState
TQ,R,N,GgetSceneState
trackingCameraShouldHandleGestures
trackingZoomScale
Td,N
animatingToTrackAnnotation
TB,R,N,GisAnimatingToTrackAnnotation
canShowFlyoverAnimation
selectedLabelMarker
T@"VKLabelMarker",R,N
labelMarkers
T@"NSArray",R,N
focusedLabelsPolyline
T@"VKPolylineOverlay",&,N
rendersInBackground
debugLayoutContinuously
enableDebugLabelHighlighting
visibleTileSets
applicationState
TC,N,V_applicationState
displayedSearchResultsType
TC,N,V_displayedSearchResultsType
sceneConfiguration
T@"VKSceneConfiguration",R,N
Self
Is in Background
Map Type
NONE
Renders In Background
Did Finish Snapshotting
Hidden
Display Rate
Navigation Display Rate
Requested Rate
Application State
Display Style
Displayed Search Results Type
TimePeriod
OverlayType
ApplicationState
SearchResultsType
MapHasLabels
Map Canvas
Current Camera Controller
Puck Animator
Description
Tile Statistics
mapCanvas
T@"VKMapCanvas",R,N
mapEngine
Tr^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ},R,N
VKMapView
Browse
Route Selection
Navigation
Guidance
Feature Selection
Search
In Vehicle Browse
None
Points
Region
Venue
Default
IOSMac
Muted
Driving
Regular
MapOnly
Munin
MuninPreview
VKMapTypeStandard
VKMapTypeSatellite
VKMapTypeHybrid
VKMapTypeSatelliteGlobe
VKMapTypeHybridGlobe
VKMapTypeNavigation
VKMapTypeStandardGrid
VKMapTypeSatelliteGrid
VKMapTypeTransit
VKMapTypeARGlobe
VKMapTypeMunin
RASTER_STANDARD
VECTOR_STANDARD
VECTOR_TRAFFIC_SEGMENTS_FOR_RASTER
VECTOR_TRAFFIC_INCIDENTS_FOR_RASTER
VECTOR_TRAFFIC_SEGMENTS_AND_INCIDENTS_FOR_RASTER
RASTER_STANDARD_BACKGROUND
RASTER_HYBRID
RASTER_SATELLITE
RASTER_TERRAIN
VECTOR_BUILDINGS
VECTOR_TRAFFIC
VECTOR_POI
SPUTNIK_METADATA
SPUTNIK_C3M
SPUTNIK_DSM
SPUTNIK_DSM_GLOBAL
VECTOR_REALISTIC
VECTOR_LEGACY_REALISTIC
VECTOR_ROADS
RASTER_VEGETATION
VECTOR_TRAFFIC_SKELETON
RASTER_COASTLINE_MASK
RASTER_HILLSHADE
VECTOR_TRAFFIC_WITH_GREEN
VECTOR_TRAFFIC_STATIC
RASTER_COASTLINE_DROP_MASK
VECTOR_TRAFFIC_SKELETON_WITH_HISTORICAL
VECTOR_SPEED_PROFILES
VECTOR_VENUES
RASTER_DOWN_SAMPLED
RASTER_COLOR_BALANCED
RASTER_SATELLITE_NIGHT
SPUTNIK_VECTOR_BORDER
RASTER_SATELLITE_DIGITIZE
RASTER_HILLSHADE_PARKS
VECTOR_TRANSIT
RASTER_STANDARD_BASE
RASTER_STANDARD_LABELS
RASTER_HYBRID_ROADS
RASTER_HYBRID_LABELS
FLYOVER_C3M_MESH
FLYOVER_C3M_JPEG_TEXTURE
FLYOVER_C3M_ASTC_TEXTURE
RASTER_SATELLITE_ASTC
RASTER_HYBRID_ROADS_AND_LABELS
VECTOR_TRANSIT_SELECTION
VECTOR_COVERAGE
FLYOVER_METADATA
VECTOR_ROAD_NETWORK
VECTOR_LAND_COVER
VECTOR_DEBUG
VECTOR_STREET_POI
MUNIN_METADATA
DAVINCI_DEV1
DAVINCI_DEV2
DAVINCI_DEV3
DAVINCI_DEV4
DAVINCI_DEV5
DAVINCI_DEV6
VECTOR_STREET_LANDMARKS
COARSE_LOCATION_POLYGONS
(unknown: %i)
RasterStandard
VectorStandard
RasterStandardBackground
RasterHybrid
RasterSatellite
RasterTerrain
VectorBuildings
VectorTraffic
VectorPoi
VectorRoad
VectorTransit
VectorTransitSelection
VectorRoadNetwork
VectorVenues
VectorTrafficDynamic
VectorTrafficSkeleton
VectorLandCover
RegionalResourceSet
RegionalAttributions
FlyoverDtm
MuninDevManifest
MuninMetadata
MuninMesh
MuninPoi
Reserved5
MuninLandmark
MuninMeshCombined
MuninTextureHeif
<Invalid>
Unknown
DiskCache
MemoryCache
Network
Night
Traffic
Transit
Invalid VKMapView
Canvas size: (%f, %f)
Camera Controller:
Last Canvas Size
Size
Canvas Zoom
Traffic Enabled
delegate
T@"<VKInteractiveMapDelegate>",N
overlays
T@"<VKInteractiveMapDelegate>",N,V_delegate
TB,N,V_trafficEnabled
T@"VKMapModel",R,N,V_map
canonicalSkyHeight
Td,N,V_canonicalSkyHeight
Building
Shadow
3D Stroke
OcclusionLineShader
/VertexData
matrix
pointSize
View
view.matrix
view.color
view.pointSize
view
Map Engine Mpde
Animate Transitions
Default Max Zoom
Additional Required MapDataTypes
Additional Optional MapDataTypes
Required Logics
Allowed Logics
Polygons
Roads
Rivers
LandCover
Coastlines
Venues
BackgroundRasters
StandardRasters
HybridRasters
SatelliteRasters
Overlay
RoadNetwork
Buildings
RouteLine
SelectedTransit
RoadLabels
PointLabels
POILabels
TransitLabels
VenueLabels
RegionalResource
Attributes
MetaData
HeightMesh
SatelliteTexture
MuninView
MuninPoiLabels
MuninPointLabels
MuninRoadNetwork
MuninAvailability
Camera
Standard
Lighting
Scene
Settings
RouteOverlay
Anchor
Labels
Grid
Overlays
MuninScene
%@ state: %ld, name: %@
state
Tq,R,N,V_state
running
runsForever
TB,N,V_runsForever
frequency
Tf,N,V_frequency
hasFrequency
duration
timed
completionHandler
T@?,C,N,V_completionHandler
priority
Tq,R,N,V_priority
name
T@"NSString",R,N,V_name
timingFunction
T@?,C,N,V_timingFunction
stepHandler
T@?,C,N,V_stepHandler
v16@?0^{CartographicRenderLayer=^^?{vector<md::CommandBufferLocation, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}^{CommandBufferLocation}{__compressed_pair<md::CommandBufferLocation *, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}}}{vector<md::CommandBufferLocation, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}^{CommandBufferLocation}{__compressed_pair<md::CommandBufferLocation *, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}}}BCS^{CartographicRenderer}}8
navMapZoomLevelTransitionZ
Tf,N,V_navMapZoomLevelTransitionZ
standardMapZoomLevelTransitionZ
Tf,N,V_standardMapZoomLevelTransitionZ
currentRoadSignOffset
Tf,R,N
showingTrafficCasing
purpose
TQ,R,N,V_purpose
TB,N,V_localizeLabels
TC,N,V_labelScaleFactor
T@"<VKMapModelDelegate>",N,V_delegate
routeUserOffset
T{PolylineCoordinate=If},N,V_routeUserOffset
navigationPuckSize
Tf,N,V_navigationPuckSize
disableTransitLines
TB,N,V_disableTransitLines
camera
T@"VKCamera",R,N,V_camera
T^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ},R,N,V_mapEngine
T{VKEdgeInsets=ffff},N,V_fullyOccludedEdgeInsets
T@"<MDMapControllerDelegate>",N,V_mapDelegate
Number of blocks
Block id type
Block length
Invalid header
Invalid materials
Invalid sub meshes
Invalid scene graphs
Header type
C3m - Invalid header type
Rotation quaternion value
Translation vector value
Bounding box value
Number of materials
Material type
Material length
C3m - Incorrect material type
Failed to read texture data
Invalid image count
Invalid number of images
Texture data type
Texture data offset
Texture compressed data size
Texture uncompressed data size
Invalid file data offset
Invalid texture data type
Num submeshes
Mesh type
Mesh length
Invalid mesh type
Invalid mesh
Should never be reached
Feature classification
Layer classification
Invalid layer class
Material index
Invalid mesh chunk type
Scale factor value
Translation factor value
Mesh chunk offset
Compressed mesh chunk size
Uncompressed mesh chunk size
Invalid mesh chunk data
Failed to decompress mesh chunk
Couldn't read mesh chunk type 0
Couldn't read mesh chunk type 1
Couldn't read mesh chunk type 2
Should not happen
Number of vertices
Number of indices
Vertex x value
Vertex y value
Vertex z value
Texture u value
Texture v value
Index value
Invalid index
Index of first drape face
Invalid feature class
Huffman parameter c1 for texture coordinates
Huffman parameter c2 for texture coordinates
Huffman parameter c3 for texture coordinates
Huffman parameter range for texture coordinates
Huffman parameter c1 for vertex coordinates
Huffman parameter c2 for vertex coordinates
Huffman parameter c3 for vertex coordinates
Huffman parameter range for vertex coordinates
Number of texture coordinates
Number of faces
Number of material indices
Failed to decode edgebreaker mesh
Unable to run edgebreaker decoder on mesh
SpecularLandmarkShader
vertex_input_position
vertex_input_texture
vertex_input_normalAndStyleIndex
vertex_input
skyfog.fogSlope
skyfog.fogOffset
skyfog.screenHeight
skyfog.skyOffset
skyfog.skyBottomColor
skyfog.skyTopColor
scale.scale
scale.tileOrigin
scale.tileSize
style.alternateColor
style.shininessAndSpecularity
style.textureCoordScale
style.textureLightness
style.brightness
style.cameraPositionInTileSpace
style.fogFactor
gradient.equation
lightConfig.lightDirection
lightConfig.lightColor
lightConfig.lightSpecularColor
lightConfig.ambientLightColor
fade.fadeEquation
fade.alphaFactor
skyfog
scale
gradient
lightConfig
fade
textureSampler
textureSampler_sampler
unknown
error
parent
T@"VKDebugTreeNode",R,V_parent
T@"NSString",R
children
T@"NSArray",&,V_children
True
False
%.02f
FoggedSpecularBuildingTopShader
vertex_input_vertexAndStyleIndex
.c3h
.c3mm
apple
FractionLoadedTime
TileSetGridFraction (%)
%llu
identifier
T@"GEOMapItemIdentifier",R,N,V_identifier
featureID
TQ,R,N
shieldText
T@"NSString",R,N,V_shieldText
shieldLocale
T@"NSString",R,N,V_shieldLocale
shieldType
Tq,R,N,V_shieldType
shieldColor
T{?=ffff},R,N,V_shieldColor
labelText
T@"NSString",R,N,V_labelText
labelLocale
T@"NSString",R,N,V_labelLocale
transitLinkID
T^v,R,N,V_transitLinkID
Vertex
texCoord
TextIcon(%s)
GEOManeuverComplexityJunctionCountMin
GEODistanceToCurrentManeuverSimilarityThresholdInMeters
GEOBaseSSLPMEnabled
NavCameraShouldUseStartLocationForPounce
NavCameraMaxZoomScale
CleanupDestroysAllocators
AllowOldMnMetadata
AllowNormalMnMetadata
AllowPedestrianMnMetadata
MnResourcePenalty
MnResourceAgePenalty
MnMaxTargetPointDistance
MnMaxSnapshotMetadataTileSearchRadius
MnStepSizeMinDistance
MnStepSizeMaxDistance
MnStepSizeMinValue
MnStepSizeMaxValue
MnStepSizePenaltyDeadZone
MnStepSizePenalty
MnMinDurationDistance
MnMaxDurationDistance
MnMinDuration
MnMaxDuration
MnTargetLodMaxSizes
MnIntermediateLod
MnNearbyLodOffsetCount
MnNearbyLodOffset
MnTargetPointOmniLod
MnTargetPointHiddenLod
MnTapBillboardFaceCamera
MaxNavCameraHeight
__invalid__
CircleShader
strokeColor
halfAntialiasWidth
halfStrokeWidth
alpha
modelViewProjection
style.strokeColor
style.halfAntialiasWidth
style.halfStrokeWidth
style.alpha
view.modelViewProjection
[server:
[server]
,zooms:
/meshes/flyover
World
Active Map Data Layers
Layers
Active
Flat
ConsistentZ
astc
ASTC
_camera: %@
_animating: %d
_gesturing: %d
_regionChangeCount: %lu
@"GEOLatLng"32@?0{Matrix<double, 3, 1>=[3d]}8
T{?=dd},N
distanceFromCenterCoordinate
heading
isPitched
isRotated
isFullyPitched
mapDataAccess
T^{MapDataAccess=},R,N
animationRunner
T^{AnimationRunner=},R,N
runLoopController
T^{RunLoopController=},R,N
presentationHeading
isPitchEnabled
TB,N,V_isPitchEnabled
isRotateEnabled
TB,N,V_isRotateEnabled
TB,N,V_staysCenteredDuringPinch
TB,N,V_staysCenteredDuringRotation
canPitch
canRotate
T^{MapDataAccess=},R,N,V_mapDataAccess
T^{AnimationRunner=},R,N,V_animationRunner
T^{RunLoopController=},R,N,V_runLoopController
DiffuseLandmarkShader
SpecularBuildingTopShader
v16@?0d8
mapModel
T@"VKMapModel",&,N,V_mapModel
T@"VKMapCanvas",N,V_mapCanvas
StarsShader
/VertexData
fadein
pointsize
vertexInput_color
view.modelview
view.projection
view.fadein
view.pointsize
view
StarVertex
 Size:(%.1f, %.1f)
 Coordinate:(%.1f, %.1f, %.1f)
 Normal:(%.4f, %.4f, %.4f)
 CollectionPoint Distance=%.1f
/VertexData
gridView
GridView
PolygonShadowedStrokeShader
/VertexData
width
direction
offsetScale
ShadowPath
vertex_attributes_vertexPosition
vertex_attributes_offsetAndTexture
shadowPath.color
shadowPath.width
shadowPath.direction
shadowPath.offsetScale
shadowPath
vertexPosition
offsetAndTexture
hardwareJPEGQueue
diskQueue
processingQueue
VK State Snapshot
^{os_state_data_s=I(?=b32I){os_state_data_decoder_s=[64c][64c]}[64c][0C]}16@?0^{os_state_hints_s=I*II}8
%@ State Capture: Starting....
%@ State Capture
Completed
StateCapture
GridShader
lineColor
majorSize
minorSize
gridMix
lineParams
gridView.gridView
gridView.color
style.lineColor
style.majorSize
style.minorSize
style.gridMix
style.lineParams
TransitPillIcon
  isActive:%i, scale:%.1f
 radius:%.2f
 halfExt:(%.2f, %.2f)
  No external icon
TransitPillIconLabelPart
Is Active
Scale
Radius
Half Ext
FlyoverMaskedShader
alphamask
alphamask_sampler
Stack, Margin=%.1f
Stack, Margin:H=%.1f, V=%.1f
ClutShader
variation
Variation
variation.variation
textureMap
clutMap
textureMap_sampler
clutMap_sampler
 <nodeFeature>
 countNodes:%i
T^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ},N,V_mapEngine
globeView
T^{GlobeView=^^?^{GeoServicesLoader}^{ManifestManager}^{TriggerManager}{shared_ptr<altitude::AnchorManager>=^{AnchorManager}^{__shared_weak_count}}^{DtmCacheNode}^{DtmRequestManager}^{FreezeViewNode}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}B{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<altitude::SimpleTileKey, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}^{SimpleTileKey}{__compressed_pair<altitude::SimpleTileKey *, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}}}BII^{VKClassicGlobeCanvas}BB{AnimationManager={AnimationReferenceTimer=ddd}{unique_ptr<altitude::AnimationTimer, std::__1::default_delete<altitude::AnimationTimer> >={__compressed_pair<altitude::AnimationTimer *, std::__1::default_delete<altitude::AnimationTimer> >=^{AnimationTimer}}}d{vector<altitude::AnimationObjectHolder, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}^{AnimationObjectHolder}{__compressed_pair<altitude::AnimationObjectHolder *, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}}}}{Stopwatch={time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >={duration<long long, std::__1::ratio<1, 1000000000> >=q}}}dB{Unit<RadianUnitDescription, double>=d}d{Unit<RadianUnitDescription, double>=d}{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}^{C3mmRequestManager}^{RenderableGroup}Id{?=dd}BB^{LabelDataManagerPrivate}BBBB^{RouteLineManager}^{GlobeCleanupLoader}^{CompleteGlobeTileSetCullingGraph}^{CompleteGlobeTileSetLoader}^{TileSetNode}^{GlobeTileRenderManager}^{CullingNode}^{EarthAdjustedViewNode}^{UserViewNode}^{View}^{BasicViewNode}^{GlobeMainViewNode}^{C3bRequestManager}fB{shared_ptr<bool>=^B^{__shared_weak_count}}^{HeightRequestManager}{map<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> >, altitude::GlobeView::LessVector2i, std::__1::allocator<std::__1::pair<const gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >={__tree<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true>, std::__1::allocator<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true> >=Q}}}{Mutex=^v}{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}^{FlyoverTour}B{Viewport=iiii}B{set<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >={__tree<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<altitude::ManifestListener *, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<altitude::ManifestListener *> >=Q}}}{unique_ptr<ReachabilityChangedObserver, std::__1::default_delete<ReachabilityChangedObserver> >={__compressed_pair<ReachabilityChangedObserver *, std::__1::default_delete<ReachabilityChangedObserver> >=^{ReachabilityChangedObserver}}}^{TileManager}^{ObjectTreeLoader}^{QuickSurfaceManager}^{IntersectorHeight}{shared_ptr<karo::SharedItemManager<altitude::Map, altitude::MapRequestId> >=^{SharedItemManager<altitude::Map, altitude::MapRequestId>}^{__shared_weak_count}}^{BundleLoader}^{ProtocolLoader}^{GeoResourceManager}^{GeoResourceLoader}^{ViewNode}^{ViewportNode}^{View}^{Viewport}{shared_ptr<ggl::RenderState>=^{RenderState}^{__shared_weak_count}}I^{Statistics}{atomic<bool>=AB}^{TexturePager}^{IOSurfacePool}^{RealisticRenderer}{DclpUnique<ggl::Texture2D, altitude::util::DclpDefaultDelete<ggl::Texture2D> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<ggl::Texture2D *>=A^{Texture2D}}{function<ggl::Texture2D *()>={__value_func<ggl::Texture2D *()>={type=[32C]}^{__base<ggl::Texture2D *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}},N,V_globeView
fieldOfView
T{Unit<DegreeUnitDescription, double>=d},N,V_fieldOfView
overrideARFieldOfView
TB,N,V_overrideARFieldOfView
heightScale
offsetTransform
T{RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}},N,V_offsetTransform
NavRoadSignLabelPart
<<NO STYLE RESOLVED>>
roadArrow_hybrid
roadArrow_standard
Name
Is Default
Font Options
Family Name
Font Expansion
Is Upper Case
Is Raised Initial
Has Small Caps
Line Style Group
Road Crossing Threshold
Road Rank
Shield Rank
Road Label Spacing
Arrow Spacing
Shield Spacing
Multi Shield Gap
Road With Shield Gap
Arrow Height
Arrows Visible
Shields Visible
Road Names Visible
Offset Position
Arrow Layer
Arrow Icon Name
Right
TopRight
TopLeft
Left
BottomLeft
Bottom
BottomRight
Center
ExtAngle
MapNavLabeler
ETA Labeler Active
ETA Labeler Debug State
actualFeatureMarker
Tr^{shared_ptr<md::FeatureMarker>=^{FeatureMarker}^{__shared_weak_count}},R
T@"NSString",R,N
shortName
venueID
styleAttributes
T@"GEOFeatureStyleAttributes",R,N
EarthCoronaShader
brightness
lightdirection
earthcoronamodelview
horizondistance
nightlightfade
Base
base.modelview
base.projection
base.brightness
base.lightdirection
base.earthcoronamodelview
base.horizondistance
base.nightlightfade
base
BuildingTopDepthShader
/SharedUnitMesh
/SharedPolygonUnitMesh
/SharedTextureUnitMesh
Standard Label Manager
Flyover Label Manager
Munin Label Manager
BuildingFacadeDepthShader
vertex_input_vertexAndTexture
TileSkyboxShader
element.blendfactor
/renderutil/spherecolor/vertexdata
/renderutil/spherecolor/indexdata
/renderutil/spherecolor/mesh
MultipleShields
layer
ImageCopyShader
Route Idx 
-- current placements --
Long
Orient
Avoid
Clipped
Route
Balance
MinDist
Shr Cnt
-- last search results --
Route 
last search was 
 seconds ago. did find = 
no last search
Screen Projection Matrix :
v16@?0r^{?=@{PolylineCoordinate=If}{PolylineCoordinate=If}}8
UpLeft
UpRight
DnLeft
DnRight
modelViewProjectionMatrix
tilePerPoint
Virtual Tiles
Has Data
Status
Tile
Finish Loading Required Layers
Finish Loading All Layers
Has Failed Tiles
Tile Set
Tile Selection Size
Pending
Failed
Available
GlyphWithNormalHaloShader
VSPassthroughShader
VSCompositingShader
fractionAC
fractionABC
crossfade
stretchWeightAB
stretchWeightAC
stretchWeightBC
vertexInput_texCoord
colorTexture
depthTexture
colorSampler
depthSampler
style.fractionAC
style.fractionABC
style.crossfade
style.stretchWeightAB
style.stretchWeightAC
style.stretchWeightBC
style
sharpATex
blurATex
sharpBTex
blurBTex
sharpCTex
blurCTex
depthTex
sharpASampler
blurASampler
sharpBSampler
blurBSampler
sharpCSampler
blurCSampler
PointExtendedShader
PointShader
ringSize
vertexInput_size
view.ringSize
view
ExtendedVbo
size
SpecularBuildingPointyRoofShader
vertex_input_normalAndIsFacade
TextureWithReverseAlphaShader
ReverseAlpha
reverseAlpha.alpha
reverseAlpha
v16@?0{fast_shared_ptr<md::RouteLineSection, std::allocator>=^{_fast_shared_ptr_control}}8
v16@?0@"GEOSnappedRoutePath"8
Debug RouteLine
Debug RouteLine Mesh
Munin View Synthesis Mesh
%s.csv
transit-line-type
transit-system-type
transit-type
country
transit-display-group
routing-color
/VertexData
/VertexData
P3T2T2Vbo
texcoord2
P3T2Vbo
/DebugFrustumElement/VertexData
/DebugFrustumElement/RenderableGroup
/DebugFrustumElement
Tiles: 
 re, 
 hires, 
 kB)
.c3m
/loading/c3mmrequestmanager
/loading/dtmrequestmanager
/loading/dtmcachenode
/loading/mapavailabilitycache
/loading/maprequestmanager
/loading/c3brequestmanager
/loading/heightrequestmanager
/loading/heightfallbackrequestmanager
/loading/transitiontilerequestmanager
/render/globe/globeviewnode
/render/globe/mainviewnode
/render/globe/nocullcullinggraph
/render/globe/freezedcullingview
/render/globe/freezecullingviewnode
/loading/globe/load/completetileset
/render/globe/tilecullinggraph
/render/globe/tilecullingnode
/loading/globe/cleanuploader
/loading/globe/preload/adjustedviewnode
/loading/globe/preload/view
/loading/globe/preload/viewnode
/loading/globe/load/tileloader
/loading/globe/load/omniview
/loading/globe/load/omniviewnode
/render/globe/globetilerendermanager
/flyovertour
/georesourcemanager
/render/mainview
/render/mainviewnode
/render/mainviewport/
/render/mainviewportnode
/loading/network/geoservicesloader
/loading/bundleloader
/loading/protocol
/loading/georesourceloader
/loading/globe/tilemanager
/loading/objecttreeloader
/loading/quicksurfacemanager
quad vertex data
quad index data
screen quad mesh
Munin view mesh
Munin resize
DepthClearQuadVerts
DepthClearQuadIdx
DepthClearMesh
Munin compositing
FlyoverMorphShader
coarseScale
coarseOffset
factor
Morph
vertexInput_morphX
vertexInput_finercoord
vertexInput_coarsecoord
morph.coarseScale
morph.coarseOffset
morph.factor
morph
finer
coarse
finer_sampler
coarse_sampler
morphX
finercoord
coarsecoord
%@-%f
Invalid
@%lux
@%lu.%ux
%s%@%@.%@
%s%@.%@
@"NSData"20@?0f8@"NSString"12
@"NSData"16@?0@"NSString"8
v24@?0@"NSString"8@"NSString"16
-car
-iosmac
styl
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoCSS/GeoCSS/StyleSheet.hpp
Could not decode STYL header.
 STYL Parse Error Here: 
Could not decode stylesheet info.
Could not decode global properties.
Could not decode property sets.
Could not decode styles.
Could not decode style matching graph.
Could not read stylesheet version.
Could not read debug stylesheet flag.
Could not read number of modes.
Could not read mode support flag.
Support specified for unknown map mode.
Could not read number of attributes.
Could not read number of bits for feature attribute.
Could not read number of bits for client attribute.
Could not decode attribute.
Could not read number of bits for attribute value.
Could not read number of bits for property id.
Could not read number of properties.
Could not read property id.
Could not read property size.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoCSS/GeoCSS/StylDecoding.hpp
Could not read attribute's type.
Could not read feature attribute id.
Could not read client attribute id.
Could not read number of bits for property set index.
Could not read number of property sets.
Could not decode property set.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoCSS/GeoCSS/StylePropertySet.hpp
Could not read property index.
Could not find size for property.
Could not read size of variable sized property.
Could not decode property
Could not read number of bits for inheritance list length.
Could not read number of bits for zoom style count.
Could not read number of bits for conditional style count.
Could not read number of bits for condition count.
Could not read number of bits for condition attribute count.
Could not read number of bits for style count.
Could not read number of styles.
Could not read style name.
Could not read style score.
Could not read number of inheritted styles.
Could not read inherited style index.
Inherited style index out of bounds.
Could not read property set index.
Property set index out of bounds.
Could not read number of zoom styles.
Could not read zoom style min zoom.
Could not read zoom style max zoom.
Could not read zoom style property set index.
Zoom style property set index out of bounds.
Could not read number of conditional styles.
Could not read number of conditions.
Could not read number of attribute values for condition.
Could not read value for condition attribute.
Could not read conditional style property set index.
Conditional style property set index out of bounds.
Could not read conditional style's zoom style count.
Could not read conditional style's zoom style min zoom.
Could not read conditional style's zoom style max zoom.
Could not read conditional style's zoom style property set index.
Conditional style's zoom style property set index out of bounds.
-condStyle-
Could not decode style matching tree.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoCSS/GeoCSS/StyleMatchingTree.hpp
Could not read number of bits used for end chain counts.
Could not read number of bits used for end chain lengths.
Could not read number of bits used for attribute value counts.
Could not read number of bits used for node indices.
Could not read number of bits used for node child counts.
Could not read number of bits used for chunk sizes.
Could not read end chain chunk.
Could not read number of end chains.
Could not read end chain length.
Could not decode attributes.
Could not read number of values.
Could not read attribute value.
Could not read number of style matching graph nodes.
Could not read number of chunks.
Could not read chunk length.
Could not read number of nodes in the chunk.
Could not construct node.
Could not read indication of node being terminal.
Could not read style index.
Could not end chain index.
Could not read indication of undefined node existing.
Could not read undefined node index.
Undefined node index out of bounds
Could not read number of children.
Could not read referenced node index.
Referenced node index out of bounds
Root
Map View
DebugTree - Start
DebugTree - End
Value
Type
String
Value Type
Number
Unsigned Number
Double
Boolean
Property
Primitive
Visual Type
Time
StyleAttribute
Values
Tags
Node
Identifier
Properties
Children
Version
Root Nodes
1.2.11
<Unknown>
BuildingPointyRoofDepthShader
AnimatableTextureShader
textureWeight
Variant
variant.textureWeight
variant
variantTextureMap
variantTextureMap_sampler
LabelMarker
IconShader
/VertexData
vertex_attributes_alphaBrightnessPercentSaturation
texture_sampler
alphaBrightnessPercentSaturation
deviceBufferIndex
GlowShader
/VertexData
radius
vertex_attributes_vertex_pos
vertex_attributes_normalAndTexture
style.radius
normalAndTexture
uid:%llu, %s, %s
style:%s
attrs:{%@}
width: fill=%.1f, stroke=%.1f spacing=%.1f
system=%llu color=%X group=%i z=%i
Merge: SameSys+Color=%i SysThresh=%i Group=%i GroupThresh=%i
style=
&part=
&region=
.c3b
/map_
triggers
trigger
data
shape
c3meshdata
type
tour
meta_levels
meta_zmax
meta_region
http://some.server.com/tile?style=15
http://some.server.com/tile?style=16
latitude
longitude
tilepixels
region
version
level
max_level
true
highres_tex_min_level
c3mesh
dataurl
dataurlformat
metaurl
metaurlformat
dtmurl
dtmurlformat
sphere
http://some.server.com/tile?style=52&x=0&y=0&z=0&h=0
system
AnnotatedShieldLabelPart
Annotated Shield Gap
Text Part Outcome
Is Text Direction Reversed
Is Text Disabled
AnnotatedShields
isOnRoute
isAwayFromRoute
routeOffset
T{PolylineCoordinate=If},R,N
isRamp
shieldDisplayGroup
isStartOfRoadName
isInGuidance
intraRoadPriority
Tq,R,N
isGuidanceStepStart
isEtaFeature
isTrafficCameraFeature
isPicked
displayMercatorPoint
T{Mercator2<double>=[2d]},N,V_displayMercatorPoint
featureMercatorPoint
T{Mercator2<double>=[2d]},R,N
nextMercatorPoint
T{Mercator2<double>=[2d]},R,N,V_nextMercatorPoint
previousMercatorPoint
T{Mercator2<double>=[2d]},R,N,V_previousMercatorPoint
label
T@"VKLabelNavRoadLabel",R,N,V_roadLabel
labelNavMode
TC,R,N,V_labelNavMode
trafficFeature
T@"VKTrafficFeature",R,N,V_trafficFeature
navState
currentIconState
TC,R,N,V_iconState
expectedIconState
TC,R,N
shouldRestyleFeature
TB,N,V_shouldRestyleFeature
tailDirection
TC,N,V_tailDirection
tailOrientation
TB,R,N,V_isOnRoute
TB,R,N,V_isAwayFromRoute
T{PolylineCoordinate=If},R,N,V_routeOffset
TB,N,V_isPicked
trafficCamera
T@"VKTrafficCameraFeature",R,N,V_trafficCamera
trafficSignal
T@"VKTrafficSignalFeature",R,N,V_trafficSignal
Visible Range
mdc::ResourceType
Selection Tile Set
LandmarkFlatShader
/VertexData
isHalo
maxHaloDistanceStored
maxExtrusionDepth
maxStrokeWidth
superSamplingKernelSize
Options
alphaAndHaloSizeInPixels
haloColor
tangent
bitangent
/loading/roadcachenode
/loading/roaddatacache
/loading/roadrequestmanager
/images/border_full.png
/road/element/clear
/road/element/clear/vdata
/road/element/clear/idata
/road/element/clear/mesh
TexturedInnerShadowRibbonShader
slopeOffset
coefficents
ShadowStyle
ribbonVertex_position
ribbonVertex_normal
ribbonVertex_texCoord
ribbonVertex
style.offset
style.imageWidth
noise.offsetScale
shadowStyle.slopeOffset
shadowStyle.coefficents
noise
shadowStyle
modulated
distanceField
alphaTexture
modulated_sampler
distanceField_sampler
alphaTexture_sampler
ribbonVertex_texture
accuracy
coordinate
zoomStyle
Tq,N,V_zoomStyle
headingAnimationDisplayRate
Tq,N,V_headingAnimationDisplayRate
annotation
T@"<VKTrackableAnnotation>",R,N,V_annotation
trackingHeading
TB,R,N,GisTrackingHeading
/DebugSharedUnitRectMesh
/Debug/UnitBox/VertexData
/Debug/UnitBox/IndexData
/Debug/UnitBox/Mesh
%d.%d.%d
%d.%d.%d
%s x %d
-------------
/DebugFootprintMesh
X:%d Y:%d Z:%d
Coast Lines: %tu   Verts: %tu 
Junctions: %tu   Overpasses: %tu
Vertices: %tu 
Unnamed Lines: %tu Verts: %tu 
Named lines: %tu Verts: %tu 
Points: %tu
Polygons: %tu  Verts: %tu
traffic %s : %@
(no traffic)
Display
CellDataSaver
RoutePreload
MapAccess
Preliminary
DebugItem
VerticalVenue3DStrokeShader
HorizontalVenue3DStrokeShader
height
baseHeight
canvasSize
vertex_input_vertex1AndCorner
vertex_input_vertex2
vertex_input_styleIndices
vertex_input_tangents
style.height
style.baseHeight
style.width
style.canvasSize
vertex_input_tangent3
HorizontalDefaultVbo
vertex1AndCorner
vertex2
styleIndices
tangents
tangent3
VerticalDefaultVbo
<VKPolylinePath %p>: %f - %f, snappedPath:%s
trafficSpeed
TC,N,V_trafficSpeed
points
T^{Matrix<float, 2, 1>=[2f]},R,N
pointCount
TI,R,N
routeStart
T{PolylineCoordinate=If},N,V_routeStart
routeEnd
T{PolylineCoordinate=If},N,V_routeEnd
hasCompletedMapMatching
TB,R
isMapMatched
section
T@"GEOComposedRouteSection",R,N,V_section
snappedPath
T@"GEOSnappedRoutePath",R,N,V_snappedPath
startDistance
Td,N,V_startDistance
<VKTransitPolylinePath %p>: %f - %f; line %llu
vertexEqualityTolerance
Td,R,N,V_vertexEqualityTolerance
RoadLabel:
  Offset: elev=%.1f nrml=%.1f
  Zoom: Cur=%.2f Min=%.2f Max=%.2f, Dist=%.1f
  PerspScale: Mode=%i Value=%.1f
  Staging: State=%s Outcome=%@
  Display: State=%s Outcome=%@ isDisplayLabel=%i isActiveForDisplay=%i
  Style: %s/
/%.2f
    font:%s
No Style
  Collided with '%s'
shield(
<null>
roadName
T@"NSString",R,N,V_roadName
MuninMeshResourceFetcher<%p>
com.apple.C3mMesh
v48@?0r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}8@"GEOTileData"16Q24@"NSError"32@"NSDictionary"40
B24@?0r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}8d16
MCP4
C3bLoadJobTotalTime (ms)
C3bLoadJobMainTime (ms)
C3bLoadJobWait0Time (ms)
C3bLoadJobStep0Time (ms)
C3bLoadJobWait1Time (ms)
C3bLoadJobStep1Time (ms)
C3bLoadJobWait2Time (ms)
C3bLoadJobStep2Time (ms)
C3bLoadJobDecodeTime (ms)
C3bLoadJobDecodeMeshTime (ms)
C3bLoadJobDownloadC3bTime (ms)
TransitTransferAnnotationLabelPart
presentationCoordinate
tracking
T@"<VKAnnotation>",&,N,V_annotation
presentationCourse
mode
TB,N,V_tracking
animatingToCoordinate
TB,N,V_animatingToCoordinate
showCourse
stale
TB,N,V_stale
enabled
false
FoggedDiffuseLandmarkShader
hw.memsize
hw.ncpu
DeviceSupportsSimplisticRoadMesh
DeviceClassNumber
roadsWithSimpleLineMeshesAvailable
tilePrefetchNumberOfScreens
supportsHiResRTT
isPad
shouldDrawWhenReady
shouldStyleLabelsInParallel
canMakeSharingThumbnails
supportsBuildingShadows
supportsBuildingStrokes
TB,R,N,V_supportsBuildingStrokes
supports3DBuildingStrokes
TB,R,N,V_supports3DBuildingStrokes
supportsHiResBuildings
supports3DBuildings
supportsPerFragmentLighting
TB,R,N,V_supportsPerFragmentLighting
supportsCoastlineGlows
TB,R,N,V_supportsCoastlineGlows
proceduralRoadAlpha
TB,R,N,V_proceduralRoadAlpha
useCheapTrafficShader
TB,R,N,V_useCheapTrafficShader
memorySize
TQ,R,N,V_memSize
tileDecodeQueueWidth
processingQueueWidth
lowPerformanceDevice
routeLineSimplificationEpsilon
supportsARMode
TB,R,N,V_supportsARMode
atmospherecolor
horizonvalues
modelmat
Transform
blendfactor
Material
offset
Texcoords
clipPlanes
Clip
3D Object
StandardLibrary
AnimatableTexture::animatableTexture_vertex
AnimatableTexture::animatableTexture_fragment
AnimatedTexturedGroundCover::animatedTexturedGroundCover_vertex
AnimatedTexturedGroundCover::animatedTexturedGroundCover_fragment
BuildingFacadeDepth::buildingFacadeDepth_vertex
BuildingFacadeDepth::buildingFacadeDepth_fragment
BuildingFlat::buildingFlat_vertex
BuildingFlat::buildingFlat_fragment
BuildingFlatStroke::buildingFlatStroke_vertex
BuildingFlatStroke::buildingFlatStroke_fragment
BuildingPointyRoofDepth::buildingPointyRoofDepth_vertex
BuildingPointyRoofDepth::buildingPointyRoofDepth_fragment
BuildingShadow::buildingShadow_vertex
BuildingShadow::buildingShadow_fragment
BuildingTopDepth::buildingTopDepth_vertex
BuildingTopDepth::buildingTopDepth_fragment
Circle::circle_vertex
Circle::circle_fragment
Clut::clut_vertex
Clut::clut_fragment
ColorGlyphWithNormalHalo::colorGlyphWithNormalHalo_vertex
ColorGlyphWithNormalHalo::colorGlyphWithNormalHalo_fragment
ColorGlyphWithOuterHalo::colorGlyphWithOuterHalo_vertex
ColorGlyphWithOuterHalo::colorGlyphWithOuterHalo_fragment
Debug::debug_vertex
Debug::debug_fragment
Debug::debug_extended_vertex
DiffuseBuilding::diffuseBuilding_vertex
DiffuseBuilding::diffuseBuilding_fragment
DiffuseBuildingPointyRoof::diffuseBuildingPointyRoof_vertex
DiffuseBuildingPointyRoof::diffuseBuildingPointyRoof_fragment
DiffuseBuildingTop::diffuseBuildingTop_vertex
DiffuseBuildingTop::diffuseBuildingTop_fragment
DiffuseLandmark::diffuseLandmark_vertex
DiffuseLandmark::diffuseLandmark_fragment
Fog::fog_vertex
Fog::fog_fragment
FoggedDiffuseBuilding::foggedDiffuseBuilding_vertex
FoggedDiffuseBuilding::foggedDiffuseBuilding_fragment
FoggedDiffuseBuildingTop::foggedDiffuseBuildingTop_vertex
FoggedDiffuseBuildingTop::foggedDiffuseBuildingTop_fragment
FoggedDiffuseLandmark::foggedDiffuseLandmark_vertex
FoggedDiffuseLandmark::foggedDiffuseLandmark_fragment
FoggedSpecularBuilding::foggedSpecularBuilding_vertex
FoggedSpecularBuilding::foggedSpecularBuilding_fragment
FoggedSpecularBuildingTop::foggedSpecularBuildingTop_vertex
FoggedSpecularBuildingTop::foggedSpecularBuildingTop_fragment
FoggedSpecularLandmark::foggedSpecularLandmark_vertex
FoggedSpecularLandmark::foggedSpecularLandmark_fragment
Glow::glow_vertex
Glow::glow_fragment
GlowAlpha::glowAlpha_vertex
GlowAlpha::glowAlpha_fragment
Glyph3d::glyph3d_vertex
Glyph3d::glyph3d_fragment
Glyph3d::glyph3dLowPrecisionHalo_fragment
Glyph3d::glyph3dLowPrecision_fragment
GlyphWithNormalHalo::glyphWithNormalHalo_vertex
GlyphWithNormalHalo::glyphWithNormalHalo_fragment
GlyphWithOuterHalo::glyphWithOuterHalo_vertex
GlyphWithOuterHalo::glyphWithOuterHalo_fragment
Grid::grid_vertex
Grid::grid_fragment
Icon::icon_vertex
Icon::icon_fragment
ImageCopy::imageCopy_vertex
ImageCopy::imageCopy_fragment
LandmarkDepth::landmarkDepth_vertex
LandmarkDepth::landmarkDepth_fragment
LandmarkFlat::landmarkFlat_vertex
LandmarkFlat::landmarkFlat_fragment
Line::line_vertex
Line::line_fragment
ManeuverPoint::maneuverPoint_vertex
ManeuverPoint::maneuverPoint_fragment
OcclusionLine::occlusionLine_vertex
OcclusionLine::occlusionLine_fragment
OptimizedTraffic::optimizedTraffic_vertex
OptimizedTraffic::optimizedTraffic_fragment
OuterShadowRibbon::outerShadowRibbon_vertex
OuterShadowRibbon::outerShadowRibbon_fragment
PatternedRibbon::writeStencilPatternedRibbon_vertex
PatternedRibbon::writeStencilPatternedRibbon_fragment
PatternedRibbon::patternedRibbon_vertex
PatternedRibbon::patternedRibbon_fragment
PolygonAnimatableFill::polygonAnimatableFill_vertex
PolygonAnimatableFill::polygonAnimatableFill_fragment
PolygonAnimatableStroke::polygonAnimatableStroke_vertex
PolygonAnimatableStroke::polygonAnimatableStroke_fragment
PolygonFill::polygonFill_vertex
PolygonFill::polygonFill_fragment
PolygonShadowedStroke::polygonShadowedStroke_vertex
PolygonShadowedStroke::polygonShadowedStroke_fragment
PolygonSolidFill::polygonSolidFill_vertex
PolygonSolidFill::polygonSolidFill_fragment
PolygonStroke::polygonStroke_vertex
PolygonStroke::polygonStroke_fragment
Point::point_extended_vertex
Point::point_fragment
Point::point_vertex
PrefilteredLine::prefilteredLine_vertex
PrefilteredLine::prefilteredLine_fragment
RenderTargetBlend::renderTargetBlend_vertex
RenderTargetBlend::renderTargetBlend_fragment
RouteLine::routeLine_vertex
RouteLine::routeLine_fragment
RouteLine::patternedRouteLine_vertex
RouteLine::patternedRouteLine_fragment
RouteLineAlphaReset::routeLineAlphaReset_vertex
RouteLineAlphaReset::routeLineAlphaReset_fragment
RouteLineArrow::routeLineArrow_vertex
RouteLineArrow::routeLineArrow_fragment
RouteLineTraffic::routeLineTraffic_vertex
RouteLineTraffic::routeLineTraffic_fragment
SDFGlyph::sdfGlyph_vertex
SDFGlyph::sdfGlyph_fragment
SDFGlyph::sdfGlyphSuperSample_fragment
SDFGlyph::sdfGlyphHalo_fragment
SimpleGrid::simpleGrid_vertex
SimpleGrid::simpleGrid_fragment
Sky::sky_vertex
Sky::sky_fragment
SolidRibbon::solidRibbon_vertex
SolidRibbon::solidRibbon_fragment
SolidRibbonAlpha::solidRibbonAlpha_vertex
SolidRibbonAlpha::solidRibbonAlpha_fragment
SolidRibbonAlpha::solidRibbonAlphaFill_fragment
SolidTraffic::solidTraffic_vertex
SolidTraffic::solidTraffic_fragment
SolidTraffic::solidMaskedTraffic_fragment
SpecularBuilding::specularBuilding_vertex
SpecularBuilding::specularBuilding_fragment
SpecularBuildingPointyRoof::specularBuildingPointyRoof_vertex
SpecularBuildingPointyRoof::specularBuildingPointyRoof_fragment
SpecularBuildingTop::specularBuildingTop_vertex
SpecularBuildingTop::specularBuildingTop_fragment
SpecularLandmark::specularLandmark_vertex
SpecularLandmark::specularLandmark_fragment
StyleTextureRibbon::styleTextureRibbon_vertex
StyleTextureRibbon::styleTextureRibbon_fragment
TextureAlphaMask::textureAlphaMask_vertex
TextureAlphaMask::textureAlphaMask_fragment
Textured::texture_vertex
Textured::texture_extended_fragment
Textured::texture_fragment
TexturedInnerShadowRibbon::texturedInnerShadowRibbon_vertex
TexturedInnerShadowRibbon::texturedInnerShadowRibbon_fragment
TexturedSolidRibbon::texturedSolidRibbon_vertex
TexturedSolidRibbon::texturedSolidRibbon_fragment
TextureWithBrightness::textureWithBrightness_vertex
TextureWithBrightness::textureWithBrightness_fragment
TextureWithReverseAlpha::textureWithReverseAlpha_vertex
TextureWithReverseAlpha::textureWithReverseAlpha_fragment
TrafficGlow::trafficGlow_vertex
TrafficGlow::trafficGlow_fragment
TransitLineRibbon::patternedTransitLine_vertex
TransitLineRibbon::patternedTransitLine_fragment
TransitLineRibbon::transitLine_vertex
TransitLineRibbon::transitLine_fragment
TransitNodeColorized::transitNodeColorized_vertex
TransitNodeColorized::transitNodeColorized_fragment
TransitNodeRGB::transitNodeRGB_vertex
TransitNodeRGB::transitNodeRGB_fragment
VenueWall::venueWall_vertex
VenueWall::venueWall_fragment
VenueWall::venueWallEndCap_vertex
VenueWall::venueWallTop_vertex
VenueWallShadow::venueWallShadow_vertex
VenueWallShadow::venueWallShadow_fragment
Venue3DStroke::verticalVenue3DStroke_vertex
Venue3DStroke::venue3DStroke_fragment
Venue3DStroke::horizontalVenue3DStroke_vertex
VenueOpenToBelowShadow::shadow_vertex
VenueOpenToBelowShadow::shadow_fragment
VenueOpenToBelowShadow::shadowAlpha_fragment
VKRouteOverlayBoundingMapRegionDidChange
<VKPolylineGroupOverlay: %p polylines:%@>
T{?=dd},R,N
boundingMapRegion
polylines
T@"NSSet",R,N,V_polylines
selectedPolyline
T@"VKPolylineOverlay",&,N,V_selectedPolyline
focusedPolyline
T@"VKPolylineOverlay",&,N,V_focusedPolyline
T@"GEOMapRegion",R,N,V_boundingMapRegion
containsTransit
TB,R,N,V_containsTransit
showTraffic
TB,N,V_showTraffic
/DebugNamedLines
/DebugUnnamedLines
/DebugPolygonLines
/DebugVerticesPoints
/DebugPOIPoints
/DebugVenueOutlines
/DebugVenueBuildingOutlines
/DebugJunctionPoints
/DebugOverpassPoints
/DebugCoastLines
/RealTransitNodes
PolygonStrokeShader
vertex_attributes_vertexStyleIndicesAndTexture
vertex_attributes_tangents
vertex_attributes_side
polygon.worldTransform
polygon.strokeColor
polygon.polygonColor
polygon.lineWidthOuter
polygon.lineWidthInner
polygon.scale
polygon
texturePolygonSampler
texturePolygonSampler_sampler
VKDidReceiveMemoryWarningNotification
ExtraExtraExtraSmall
ExtraExtraSmall
ExtraSmall
Small
SmallMedium
Medium
Large
ExtraLarge
ExtraExtraLarge
ExtraExtraExtraLarge
nightMode
TB,N,V_nightMode
transitMode
TB,N,V_transitMode
navMode
TB,N,V_navMode
interactive
TB,N,V_interactive
searchResult
TB,N,GisSearchResult,V_searchResult
zoom
Tq,N,V_zoom
TQ,N,V_variant
countryCode
TQ,N,V_countryCode
{x:%d y:%d z:%d (%@)}
%d.%d.%d type: %d pixel: %d
 text: %d
 expires
 r: %llu
 Invalid
 Voltaire
 VoltaireSimple3D
 VoltaireSputnikMetadata
 Regional
 Identified
 Feature
 Test
 <Unknown %d>
displayLayer
T@"<MDRenderTarget>",N,V_displayLayer
followsTerrain
TB,N,V_followsTerrain
PolygonAnimatableStrokeShader
targetColor
AnimatablePolygon
animatablePolygon.targetColor
animatablePolygon
textureVariantSampler
textureVariantSampler_sampler
Creating VKPuckAnimator %p
Destroying VKPuckAnimator %p
VKPuckAnimator got location %f, %f
_vehicleHeading: %f
_pausedCount: %ld
_suspended: %@
_lastProjectedPosition: %f, %f, %f
_behavior: %lu
_locationProjector:
_delegate: %@
_target: %@
lastProjectedLocation
T@"GEORouteMatch",&,N,V_lastProjectedLocation
target
T@"<VKPuckAnimatorTarget>",&,N,V_target
T@"<VKPuckAnimatorDelegate>",N,V_delegate
tracePlaybackSpeedMultiplier
Td,N,V_tracePlaybackSpeedMultiplier
behavior
TQ,N,V_behavior
text
locale
T{?=ffff},R,N
<LabelMarker> rect:{%f, %f, %f, %f}
isDragged
shields
transitSystems
dataIconImageKeys
iconImageKeys
imageKeys
relatedTexts
relatedSubTexts
FoggedDiffuseBuildingShader
Icon updateCount(active)=%zu(%zu)
route
T@"GEOComposedRoute",R,N,V_route
routeMatch
T@"GEORouteMatch",&,N,V_routeMatch
currentStepIndex
TQ,N,V_currentStepIndex
groupedManeuverCount
TQ,R,D,N
groupedManeuverCounts
T@"NSArray",C,N,V_groupedManeuverCounts
navigationCameraHeadingOverride
TQ,N,V_navigationCameraHeadingOverride
StyleCrossFade
TrafficGlowShader
pitchRatio
zoomDependentShift
drivingDirection
sideOffset
alphaFadeParam
vertexInput_uniDirectional
vertexInput_shiftDir
style.pitchRatio
style.zoomDependentShift
style.drivingDirection
style.sideOffset
style.alphaFadeParam
vertexInput_texture
RouteLineAlphaResetShader
params.fadeStart
params
collectionPoint
Tr^{CollectionPoint=Q{RigidTransform<double, float>={Matrix<double, 3, 1>=[3d]}{Quaternion<float>={Matrix<float, 3, 1>=[3f]}f}}{Unit<RadianUnitDescription, float>=f}{Mercator3<double>=[3d]}Q{small_vector<md::mun::PhotoInfo, 6>=^{PhotoInfo}^{PhotoInfo}^{PhotoInfo}Q[6{type=[288C]}]}fISCCC},R,N
canMoveToMarker
T{?=ddd},R,N,V_coordinate
collectionDate
T@"NSDate",R,N
pointId
buildId
B16@?0d8
dynamicStepHandler
T@?,C,N,V_dynamicStepHandler
AnimatedCrossFadeLabelPart
/night/vdata
/night/mesh
PatternedTransitLineRibbonShader
TransitLineRibbonShader
halfWidthRange
normalOffsetRange
imageWidth
styleTextureColorPixelOffset
distanceMultiplier
PatternStyle
vertexInput_styleTextureCoord
vertexInput_normalOffsetMixFactor
vertexInput_distance
style.halfWidthRange
style.normalOffsetRange
style.styleTextureColorPixelOffset
patternStyle.color
patternStyle.halfWidth
patternStyle.distanceMultiplier
patternStyle
styleTexture
patternTexture
styleTexture_sampler
patternTexture_sampler
styleTextureCoord
normalOffsetMixFactor
distance
%@ %@
atlasIndex
quadIndex
anchorPointX
anchorPointY
iconRectX
iconRectY
iconRectWidth
iconRectHeight
matchingStyleAttributeKey
matchingStyleAttributeValue
matchingStyleAttributeLongValue
hasName
T@"NSString",&,N,V_name
TI,N,V_atlasIndex
TI,N,V_quadIndex
hasAnchorPointX
TI,N,V_anchorPointX
hasAnchorPointY
TI,N,V_anchorPointY
hasIconRectX
TI,N,V_iconRectX
hasIconRectY
TI,N,V_iconRectY
hasIconRectWidth
TI,N,V_iconRectWidth
hasIconRectHeight
TI,N,V_iconRectHeight
hasMatchingStyleAttributeKey
TI,N,V_matchingStyleAttributeKey
hasMatchingStyleAttributeValue
Ti,N,V_matchingStyleAttributeValue
hasMatchingStyleAttributeLongValue
TQ,N,V_matchingStyleAttributeLongValue
hasSize
Ti,N,V_size
shield_default
shield_small
shield_large
shield_xsmall
shield_xlarge
shield_xxsmall
shield_xxlarge
shield_xxxlarge
shield_medium
shield_xxxsmall
dflt
  Transit Shield(%s):of=%.2f,size=%s
TransitShieldIconLabelPart
Shield Size Modifier
Offset
XSmall
XLarge
XXSmall
XXLarge
XXXLarge
XXXSmall
HeightFallbackLoadJobTotalTime
HeightFallbackLoadJobMainTime
LandmarkDepthShader
TiledResourceFetcher<%p>
PreliminaryTiledResourceFetcher<%p>
Preload Only
Require Wifi
Content Scale
Tile Loader Client Identifier
null
Preliminary Tile Loader Client Identifier
Tile Style
TileLoader
MapDisplayCore
astc
h264
C3B VData
a_position
Polygon Fill Mesh
Polygon Fill Vertex Data
Polygon Fill Index Data
isFixedSize
TB,R,N,V_isFixedSize
centroid
T{Matrix<float, 2, 1>=[2f]},R,N,V_centroid
tileZoom
origin
Tr^{Matrix<float, 3, 1>=[3f]},R,N
maxPoint
T{Matrix<float, 3, 1>=[3f]},R,N
cullingMask
TI,R,N,V_cullingMask
fillMeshes
T^{vector<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >=^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >=^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}}},R,N
attributeSets
T@"NSOrderedSet",R,N
styleQueries
T^{vector<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> >, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >=^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}{__compressed_pair<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > *, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >=^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}}},R,N
selectedStyleQueries
featureIds
Tr^{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > >={__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long long> >=f}}},R,N
atlas
icons
TI,N,V_identifier
T@"NSMutableArray",&,N,V_atlas
T@"NSMutableArray",&,N,V_icons
quadWidth
quadHeight
T@"NSData",&,N,V_texture
TI,N,V_quadWidth
TI,N,V_quadHeight
Icon
Glyph
TextureAtlases: 
Texture Atlases
VKDefault
Performance
ResourceLoading
VectorKitLabels
com.apple.VectorKit
Memory
X-Fade effect
Tile
 Counts: links=%i easingPoints=%i 
 Edges Synched:T=%i L=%i,
 Neighbors:T=%i B=%i L=%i R=%i 
FlyoverNightShader
night
night_sampler
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/src/CartographicMapEngineConfiguration.mm
AnimatedTexturedGroundCoverShader
variation.textureVariation
landSamplerA
landSamplerB
landSamplerA_sampler
landSamplerB_sampler
Default
Optional
Required
Never
CaEx
AutoOff
FeatNrml
ScEx
TLnOff
RtOff
AngU
AngD
HOrAng
AutoV
VKLabelNavManeuver
isVisible
TB,R,N,V_isVisible
maneuverSign
T@"VKLabelNavRoadLabel",R,N,V_maneuverSign
TransitNodeColorizedShader
vertexInput_secondarycolor
vertexInput_brightness
settings.atlasSize
settings.halfScreenSize
settings
variants
genericShieldStyleInfo
T@"NSString",&,N,V_identifier
T@"NSMutableArray",&,N,V_variants
hasGenericShieldStyleInfo
T@"VKPGenericShieldStyleInfo",&,N,V_genericShieldStyleInfo
Loading Counts: image=%u, textData=%u, glyphImage=%u
Occlusions: unsubmitted=%zu, pending=%zu
Scissor Rect: min=(%u, %u), max=(%u, %u)
Scissor Rect(Signs): min=(%u, %u), max=(%u, %u)
RouteTrafficFeaturesActive=%i
Staging GlyphCache: hits=%u, misses=%u, hit%%=%.1f, size=%u
ImageLoader: hits=%u, misses=%u, hit%%=%.1f, size=%u
GlyphLoader: large-scale=%llu, total=%llu, %%=%.1f
GlyphSizes:
 %u=%u
RoadPath Glyphs Placed: %u
Renderer: descs=%u, items=%u(glyph=%u,icon=%u)
DevBuff:fl=%u,by=%u
Style-Cache shared:%zu layout:%zu
Layout Zoom
<<Unable to lock label background state>>
Is Background Update Running
Route traffic features active
Loading Counts
image
textData
glyphImage
totalGlyphCount
glyphsUsingLargeScaleFactorCount
Staging Glyph Cache
cacheHits
cacheMisses
cachedItemCount
Display Glyph Cache
Renderer
descriptors
renderItems
glyph renderItems
icon renderItems
Tiles
vmp4
VKTestTileRequesterDomain
T@"NSMutableArray",&,N,V_shields
idx (%tu) is out of range (%tu)
minDigits
maxDigits
textBaseline
centerOffsetX
fontName
fontSize
fontColor
textStroke
textShadow
nonDigitFontName
nonDigitFontSize
centerPoint
backgroundColor
borderColor
capWidthLeft
capWidthRight
paddingLeft
paddingRight
textMaskColor
lineSpacing
nonDigitFontColor
hasAtlasIndex
hasQuadIndex
hasMinDigits
TI,N,V_minDigits
hasMaxDigits
TI,N,V_maxDigits
hasTextBaseline
Tf,N,V_textBaseline
hasCenterOffsetX
Tf,N,V_centerOffsetX
hasFontName
T@"NSString",&,N,V_fontName
hasFontSize
Tf,N,V_fontSize
hasFontColor
T{?=fIII},N,V_fontColor
hasTextStroke
T{?={?=fIII}f},N,V_textStroke
hasTextShadow
T{?={?=fIII}fff{?=b1b1}},N,V_textShadow
hasNonDigitFontName
T@"NSString",&,N,V_nonDigitFontName
hasNonDigitFontSize
Tf,N,V_nonDigitFontSize
centerPointsCount
centerPoints
T^f,R,N
layersCount
layers
T^{?=IiifI{?=b1b1b1b1b1}},R,N
hasBackgroundColor
TI,N,V_backgroundColor
hasBorderColor
TI,N,V_borderColor
hasCapWidthLeft
Tf,N,V_capWidthLeft
hasCapWidthRight
Tf,N,V_capWidthRight
hasPaddingLeft
Tf,N,V_paddingLeft
hasPaddingRight
Tf,N,V_paddingRight
hasTextMaskColor
Ti,N,V_textMaskColor
hasLineSpacing
Tf,N,V_lineSpacing
hasNonDigitFontColor
T{?=fIII},N,V_nonDigitFontColor
MASK_COLOR_BACKGROUND
MASK_COLOR_BORDER
MASK_COLOR_TRANSIT_LINE
MASK_COLOR_LEGIBLE_ON_BACKGROUND
MASK_COLOR_LEGIBLE_ON_TRANSIT_LINE
BlurYShader
BlurXShader
ShrinkBlur4XShader
title
T@"NSString",R,C,N,V_title
subtitle
T@"NSString",R,C,N,V_subtitle
uniqueID
TQ,R,N,V_uniqueID
uniqueString
T@"NSString",R,N,V_uniqueString
Tq,R,N,V_type
isNotForDisplay
TB,R,N,V_isNotForDisplay
routeRelevance
Tq,N,V_routeRelevance
isOnSelectedRoute
TB,N,V_isOnSelectedRoute
routeOffsetInMeters
TI,N,V_routeOffsetInMeters
street
T@"NSString",R,N,V_street
crossStreet
T@"NSString",R,N,V_crossStreet
info
T@"NSString",R,N,V_info
startDate
T@"NSDate",R,N,V_startDate
endDate
T@"NSDate",R,N,V_endDate
lastUpdatedDate
T@"NSDate",R,N,V_lastUpdatedDate
significance
Tq,R,N,V_significance
VSSpriteShader
Sprite
sprite.modelViewProjectionMatrix
sprite.size
sprite.offset
sprite
sdf_sampler
alpha_sampler
tileOrigin
tileSize
alternateColor
shininessAndSpecularity
textureCoordScale
textureLightness
cameraPositionInTileSpace
fogFactor
fadeEquation
alphaFactor
Fade
equation
Gradient
FlyoverFlatShader
FlatFactor
vertexInput_flatcoord
flatFactor.factor
flatFactor
colorlookup
colorlookup_sampler
flatcoord
virtualParallaxEnabled
TB,N,V_virtualParallaxEnabled
 total: 
index data
vertex data
UnitQuad
RasterTile
OverlayTileStencil
Transit line
[%i]"%s":{%@}
{%@}
uniDirectional
shiftDir
com.apple.vectorkit.dispatch.layoutbackgroundqueue
%s.workloop
%s.root
com.apple.vectorkit.dispatch.glyphrenderqueue
com.apple.vectorkit.dispatch.textDataLoaderQueue
com.apple.vectorkit.dispatch.imageLoaderQueue
com.apple.vectorkit.dispatch.layoutqueue
com.apple.vectorkit.dispatch.renderqueue
com.apple.mapdisplay.dispatch.tiledecodequeue
com.apple.mapdisplay.dispatch.layoutworkerqueue
com.apple.mapdisplay.dispatch.labelTileDecodeQueue
com.apple.mapdisplay.dispatch.tiledecodestylingqueue
com.apple.mapdisplay.dispatch.overlaytiledecodequeue
/render/tilebasic/vertexdata
/render/tilebasic/indexdata
/ClippedElement
Screen quad verts
Screen quad indices
Screen quad mesh
Post process item
textColor
textStrokeSize
textStrokeColor
textDropShadowOffset
textDropShadowSize
textDropShadowColor
hasStyle
Ti,N,V_style
hasTextColor
TI,N,V_textColor
hasTextStrokeSize
Tf,N,V_textStrokeSize
hasTextStrokeColor
TI,N,V_textStrokeColor
textDropShadowOffsetsCount
textDropShadowOffsets
hasTextDropShadowSize
Tf,N,V_textDropShadowSize
hasTextDropShadowColor
TI,N,V_textDropShadowColor
nonbordered
bordered
interchange
intersection
junction
serviceparkingarea
FlyoverRoadFillTexturedShader
vertexInput_offset
vertexInput_uv
blend.alpha
transform.width
color.fill
color.stroke
discMap
discMap_sampler
FoggedDiffuseBuildingTopShader
Scene Tile Set
Scene Info
inView
projectionMatrix
screenProjectionMatrix
useDeviceBufferMatrix
opacity
DeviceBufferTextureSize
DeviceBufferTextureSizeB
BuildingFlatStrokeShader
polygonColor
lineWidth
vertex_input_offsetAndTexture
building.polygonColor
building.strokeColor
building.lineWidth
building.offsetScale
building.tileOrigin
building.tileSize
building
vertexAndStyleIndex
speedThreshold
TI,R,N,V_speedThreshold
isAboveSpeedThreshold
TB,N,V_isAboveSpeedThreshold
speedLimitText
T@"NSString",R,N,V_speedLimitText
VKLabelTileTypeFromAltitudeLabelDataTileTypeInvalid
Unknown value for altitude::LabelData::TileType: %d
LabelQueryMesh
B24@?0^{Tile=^^?{RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}{Box<double, 3>={Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}}{Box<double, 3>={Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}}{SizedArray<altitude::TileView, 2>=Q[2{TileView=^^?^{Tile}^{View}fIBIBI}]{vector<altitude::TileView, std::__1::allocator<altitude::TileView> >=^{TileView}^{TileView}{__compressed_pair<altitude::TileView *, std::__1::allocator<altitude::TileView> >=^{TileView}}}}^{RootTileData}^{Tile}{vector<altitude::Tile::ChildData, std::__1::allocator<altitude::Tile::ChildData> >=^{ChildData}^{ChildData}{__compressed_pair<altitude::Tile::ChildData *, std::__1::allocator<altitude::Tile::ChildData> >=^{ChildData}}}[5^{TileComponent}]QQII{TileId=IIII}fff^{TileListener}BiB}8^{Tile=^^?{RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}{Box<double, 3>={Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}}{Box<double, 3>={Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}}{SizedArray<altitude::TileView, 2>=Q[2{TileView=^^?^{Tile}^{View}fIBIBI}]{vector<altitude::TileView, std::__1::allocator<altitude::TileView> >=^{TileView}^{TileView}{__compressed_pair<altitude::TileView *, std::__1::allocator<altitude::TileView> >=^{TileView}}}}^{RootTileData}^{Tile}{vector<altitude::Tile::ChildData, std::__1::allocator<altitude::Tile::ChildData> >=^{ChildData}^{ChildData}{__compressed_pair<altitude::Tile::ChildData *, std::__1::allocator<altitude::Tile::ChildData> >=^{ChildData}}}[5^{TileComponent}]QQII{TileId=IIII}fff^{TileListener}BiB}16
etaText
T@"NSString",R,N,V_etaText
glyphType
TC,R,N,V_glyphType
tollCurrencyType
TC,R,N,V_tollCurrencyType
etaDescription
T@"VKRouteEtaDescription",&,N,V_etaDescription
hasRouteEta
hasFocus
TB,N,V_hasFocus
divergenceCoordinate
T{PolylineCoordinate=If},R,N,V_divergenceCoordinate
convergenceCoordinate
T{PolylineCoordinate=If},R,N,V_convergenceCoordinate
etaComparisionToMain
TC,N,V_etaComparisonToMain
routeInfo
T@"VKRouteInfo",R,N,V_routeInfo
useType
TC,R,N,V_useType
T{PolylineCoordinate=If},N,V_routeOffset
currentLegIndex
Tq,N,V_currentLegIndex
Tq,N,V_currentStepIndex
snappingToTransitLines
TB,N,V_snappingToTransitLines
inspectedLegIndex
Tq,N,V_inspectedLegIndex
inspectedStepIndex
Tq,N,V_inspectedStepIndex
puckLocation
T{?=dd},N,V_puckLocation
puckRadius
Tf,N,V_puckRadius
puckSnappedStopID
TQ,N,V_puckSnappedStopID
T@"NSString",&,N,V_locale
accessPointEntryName
T@"NSString",&,N,V_accessPointEntryName
accessPointExitName
T@"NSString",&,N,V_accessPointExitName
alternateRoutes
T@"NSArray",&,N,V_alternateRoutes
totalRouteCount
zh-hans
v16@?0Q8
TransitNodeExternalIcon
 <node> Missing-Feature Node
 <junction>
   IncomingLink[%i]
    line[uid:%llu,%i,%s,%s] draw[TO:%i, from:%i]
   OutgoingLink[%i]
    line[uid:%llu,%i,%s,%s] draw[to:%i, FROM:%i]
<Junction:%p>
point=(%f,%f)
RefLink:%p, isSuperSet:%i, domDir:%.1f
Links:
  %i:%p, dir:%.02f, domDelta:%.1f
PolygonOverlay
Polygon overlay vertex data
Polygon overlay index data
PolygonOverlayAntialias
Polygon overlay antialias vertex data
Polygon overlay antialias index data
Cannot properly hash this geometry. Its space is too large.
Called linkListInHashSpace with a NULL head.
Called earclipPolygon with a NULL head. Probably wrong to do so.
Wrapped around the polygon without finishing... :-(
List has 
 nodes:
/VertexData
vertexAndTexture
normalAndStyleIndex
Error: 
: Parse error in CSV file
textLocale
localizedText
localizedTextLocale
textType
minZoom
supportsSecureCoding
sizeX
sizeY
isRound
locX
locY
elevation
featureId
businessId
venueId
venueLevelId
venueComponentId
venueFloorOrdinal
maxZoom
sortKey
textDisplayMode
iconElements
textElements
SolidTrafficShader
SolidMaskedTrafficShader
alphaTextureMap_sampler
/ImageCanvasTarget
/FlippedImageCanvasTarget
/ImageCanvasMSAARenderBuffer
/ImageCanvasDepthBuffer
T{CGSize=dd},N
contentScale
bounds
T{CGRect={CGPoint=dd}{CGSize=dd}},N
renderSource
T@"<GGLRenderQueueSource>",N
multiSample
format
Tr^{RenderTargetFormat=[4i]QIi},R,N
renderer
T^{Renderer=^^?^{Device}QQQBfQ{vector<std::__1::shared_ptr<ggl::DebugRenderer>, geo::StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator> >=^{shared_ptr<ggl::DebugRenderer>}^{shared_ptr<ggl::DebugRenderer>}{__compressed_pair<std::__1::shared_ptr<ggl::DebugRenderer> *, geo::StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator> >=^{shared_ptr<ggl::DebugRenderer>}{StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator>=^{Allocator}}}}{unique_ptr<ggl::RenderQueue, std::__1::default_delete<ggl::RenderQueue> >={__compressed_pair<ggl::RenderQueue *, std::__1::default_delete<ggl::RenderQueue> >=^{RenderQueue}}}{shared_ptr<ggl::CommonLibrary>=^{CommonLibrary}^{__shared_weak_count}}{unique_ptr<ggl::RenderResourceFences, std::__1::default_delete<ggl::RenderResourceFences> >={__compressed_pair<ggl::RenderResourceFences *, std::__1::default_delete<ggl::RenderResourceFences> >=^{RenderResourceFences}}}^{Texture2D}{unique_ptr<ggl::CommandBuffer, std::__1::default_delete<ggl::CommandBuffer> >={__compressed_pair<ggl::CommandBuffer *, std::__1::default_delete<ggl::CommandBuffer> >=^{CommandBuffer}}}},R,N
shouldRasterize
sizeInPixels
T{CGSize=dd},R,N
finalRenderTarget
T^{RenderTarget=^^?^{ResourceManager}^{RenderResource}^^?*{RenderTargetFormat=[4i]QIi}[4^{Texture}][4^{Texture}]^{Texture}B},R,N
averageFPS
allowAlpha
TB,N,V_allowAlpha
renderTarget
imageTexture
T^{Texture2D=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiIII{shared_ptr<const ggl::TextureDataAbstract>=^{TextureDataAbstract}^{__shared_weak_count}}BBB{shared_ptr<ggl::SamplerState>=^{SamplerState}^{__shared_weak_count}}},R,N
resolvedRenderTargetFormat
T{RenderTargetFormat=[4i]QIi},R,N,V_resolvedRenderTargetFormat
T{CGSize=dd},N,V_size
Td,N,V_contentScale
T{CGRect={CGPoint=dd}{CGSize=dd}},N,V_bounds
T@"<GGLRenderQueueSource>",N,V_renderSource
TB,R,N,V_useMultisampling
YFlipQuad
T{CGSize=dd},R
T{?=CCCCB},N,V_mapDisplayStyle
T{VKEdgeInsets=ffff},N,V_edgeInsets
routeOverlay
T@"<VKRouteOverlay>",&,N,V_routeOverlay
routeContext
T@"VKRouteContext",&,N,V_routeContext
VKMapSnapshot
com.apple.maps.snapshot.failedtiles
taskContext
T{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}},R,N
Ti,N,V_mapType
T{DisplayStyle=CCCCC},N,V_mapDisplayStyle
FlyoverRoadStrokeProceduralShader
ribbonExtra.ewidth
ribbonExtra
CurrencyGlyphUSD
CurrencyGlyphWon
CurrencyGlyphYen
CurrencyGlyphEuro
CurrencyGlyphPound
CurrencyGlyphRuble
CurrencyGlyphRupee
Time step: 
Src: 
Dst: 
Src -> Dst: 
Inc: 
Src -> Inc -> Dst: 
Crossfade: 
Time since tap (ms): 
Point: 
 Cam: 
 Lod: 
 Priority: 
 Loading
 Complete
 Cancelled
 Missing
 Failed
Path:
Segment Fraction: 
Fraction: 
tap destination vertex data
tap destination index data
destination mesh
points vertex positions
points vertex data
points mesh
mesh vertex data
triangle mesh
Mergetype=%i, mergedIndex=%i
Offsets: Start=%.1f Middle=%.1f End=%.1f
NodeID From=%llu To=%llu Dir=%c
ewidth
RibbonExtra
fill
stroke
Blend
Border
/GroundMesh
Map Engine
Is Hidden
Is In Background
Renders in Background
Needs Layout
Needs Run Loop Update
Render Target
Has Render Target
Multi Sample
Should Rasterize
Size Points
Width
Height
Size Pixels
Map Engine Settings
HasUpdatedSettings
ShowsVenues
ShowsBuildings
ShowsTraffic
ShowsTrafficIncidents
ShowsOverlays
ShouldLoadMapMargin
ShouldPrefetch
DisableRoads
DisableLabels
DisablePolygons
DisableBuildings
DisableRasters
DisableGrid
DisableTransit
EnablePreliminaryTiles
LoadMuninMetadata
LoadMuninAvailability
GPU Frame-time
Frame-time
Frame-drops
SolidRibbonAlphaShader
SolidRibbonAlphaFillShader
VKShouldFlushTileCachesNotification
VKEnablePeformanceHUD
VKDisablePeformanceHUD
VKExtendedPeformanceHUD
VKDMinimalPeformanceHUD
VKPounceWillStartNotification
VKPounceDidEndNotification
LineShader
vertex_attributes_normal
vertex_attributes_texCoord
v52@?0r^{Matrix<float, 2, 1>=[2f]}8r^{PolylineCoordinate=If}16Q24@"VKPolylinePath"32@"GEOSnappedRouteEdge"40B48
hasNewRoadMatches
TB,V_hasNewRoadMatches
sections
T{vector<geo::fast_shared_ptr<md::RouteLineSection, std::allocator>, std::__1::allocator<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> > >=^{fast_shared_ptr<md::RouteLineSection, std::allocator>}^{fast_shared_ptr<md::RouteLineSection, std::allocator>}{__compressed_pair<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> *, std::__1::allocator<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> > >=^{fast_shared_ptr<md::RouteLineSection, std::allocator>}}},R,N,V_sections
T{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}},R,N,V_bounds
renderRegion
T@"VKPolylineOverlayRenderRegion",R,N,V_renderRegion
overlay
T@"VKPolylineOverlay",R,N,V_overlay
observer
T@"<VKRouteLineObserverProtocol>",N,V_observer
simplificationEpsilonPoints
Td,N,V_simplificationEpsilonPoints
ExternalIcon
  alpha:%.2f
  radius:%.2f
  halfExt:(%.2f, %.2f)
  %@
ExternalIconLabelPart
Alpha
Is Round
Flyover region: %d version: %d C3M version: %d.%d C3MM version: %d.%d
Tiles: %d BaseSurface: %d (%d kB, avg: %d kB) Geometry: %d (%d kB, avg: %d kB)
Tile id at camera position: %s
%s (count) [%2.1f, %2.1f]ms
sceneDidLoadCallback
T@?,C,N,V_sceneDidLoadCallback
Ti,R,N,V_flyoverMode
globeCameraController
T@"VKGlobeCameraController",R,N,V_globeCameraController
arCameraController
T@"VKARCameraController",R,N,V_arCameraController
flyoverAvailable
TB,R,N,V_canShowFlyover
disableRoads
TB,N,V_disableRoads
disableLabels
TB,N,V_disableLabels
level: 
  lat: 
  lon: 
  height: 
Error SECTION_MARKER expected %x
  ident       %s
  vers        %x
  units       %x
  x_density   %x
  y_density   %x
  x_thumbnail %x
  y_thumbnail %x
  %x %x
%2x 
  precision  %x
  height     %x
  width      %x
  components %x
    id           %x
    samp_factor  %x
    quant_tbl_no %x
  Type  %x
  Index %x
   %d  tbl_id %d tbl_no %x
RSTI: %d
%x len %d
%s#%d: warning jpg yv12. samp_factor[0] = 0x%02X, samp_factor[i] = 0x%02X
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/src/karo/media/image/pwin_jpg/ap_rwjpg.cpp
total %d
%2x %2x %4x   
EOI:
SOS:
DHT:
SOF0:
DQT:
APP0:
Error SOI expected
 <node>
 drawAsXfer:%i nodeIconType:%i, nodeType:%s, tileZ:%i
   isActive:%i isSelected:%i
  TransitLineIDs:
   %llu
 dots:%i
Connected
Parent
Orphan
FlyoverMorphBorderShader
vertexInput_finermerccoord
vertexInput_finerflyovercoord
vertexInput_coarsemerccoord
finerSatellite
finerFlyover
finerBlend
coarseSatellite
finerSatellite_sampler
finerFlyover_sampler
finerBlend_sampler
coarseSatellite_sampler
finermerccoord
finerflyovercoord
coarsemerccoord
_%lux
@"NSString"16@?0@"NSString"8
/BaseSurface/
/HeightMesh/
routeLineDatas
Tr^{set<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >={__tree<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::shared_ptr<md::RouteLineData>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<std::__1::shared_ptr<md::RouteLineData> > >=Q}}},R,N,V_routeLineDatas
visibleRect
T{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}},R,N,V_visibleRect
vkBounds
T{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}},R,N
q24@?0@8@16
traffic timestamp
selected
segment 
speed
trafficTimeStamp
Td,R,N,V_trafficTimeStamp
routeRibbon
T@"VKRouteLine",N,V_routeRibbon
routeRibbonObserver
T@"<VKPolylineOverlayRouteRibbonObserver>",N,V_routeRibbonObserver
composedRoute
T@"GEOComposedRoute",R,N,V_composedRoute
traffic
T@"GEOComposedRouteTraffic",R,N,V_traffic
TB,N,V_selected
PolygonSolidFillShader
SolidFill
vertex_attributes_vertexAndStyleIndex
solidFill.color
solidFill.origin
solidFill.size
solidFill
scene
hybrid
satellite
globe-default
StyleManager
Stylesheet Name
Is from a Dev Resource
Supports Night Mode
Is Finished Decoding
Is Valid
Target Display
Blending Factor
Client Attributes
Attribute: 
routeLineSplitAnnotation
T@"<VKRouteMatchedAnnotationPresentation>",&,N
T@"<VKGlobeLineContainerDelegate>",N,V_delegate
RouteArrowMinZoom
VK LOCK SCREEN: %@
VKDisableBackgroundLabelLayout
HideDirectionalArrowsKey
AltitudeDisableC3mTextureLoadingKey
HighlightRouteLineSnappingStatusKey
VKReadLandmarksFromDisk
VKUseStaticTrafficFeed
VKDisableGlyphTextureAtlas
VKDisableIconTextureAtlas
VKDisableStyleAnimations
VKDisableLabelStyleOverrides
VKHideClientPositionedFeatures
VKHideServerPositionedRoadFeatures
VKHideServerPositionedtransitFeatures
VKKeepTooCloseServerPositionedtransitFeatures
NavLabelOverlayKey
VKPreferOpenGLRendererKey
VKEnableSignpostsKey
VKEnableTrafficFeatureLabelDebuggingKey
VKARRenderAtNativeRateKey
EnableMuninRoadNetworkMiniMapKey
EnableMuninMiniMapRoadWidthsKey
EnableMuninMiniMapComposedEdgeRoadColoringKey
EnableMuninMiniMapCollectionPointsKey
EnableMuninMiniMapRoadZDataKey
VKDecodeStyleNamesKey
%s installed in lock screen
IS NOT
vertices
indices
disableOverlayTextConsole
TB,N,V_disableOverlayTextConsole
paintMapTiles
TB,N,V_paintMapTiles
paintSelectedMapTiles
TB,N,V_paintSelectedMapTiles
selectedMapTilesToPaint
T{GEOTileSetRegion=IIIIII},N,V_selectedMapTilesToPaint
paintTiles
TB,N,V_paintTiles
paintRoadBoundaries
TB,N,V_paintRoadBoundaries
paintRoadTiles
TB,N,V_paintRoadTiles
paintPoiTiles
TB,N,V_paintPoiTiles
paintPointTiles
TB,N,V_paintPointTiles
paintPolygonTiles
TB,N,V_paintPolygonTiles
paintLandcoverTiles
TB,N,V_paintLandcoverTiles
paintVenues
TB,N,V_paintVenues
paintVertices
TB,N,V_paintVertices
paintJunctions
TB,N,V_paintJunctions
paintCoastlines
TB,N,V_paintCoastlines
paintBuildings
TB,N,V_paintBuildings
paintLoadReason
TB,N,V_paintLoadReason
disableRoute
TB,N,V_disableRoute
labelHighlighting
TB,N,V_labelHighlighting
transitHighlighting
TB,N,V_transitHighlighting
labelFacingCullDisabled
TB,N,V_labelFacingCullDisabled
labelDedupingDisabled
TB,N,V_labelDedupingDisabled
labelCollisionDisabled
TB,N,V_labelCollisionDisabled
labelCollideContinuously
TB,N,V_labelCollideContinuously
labelFlipAlternatePositionsEnable
TB,N,V_labelFlipAlternatePositionsEnable
labelTileDecodeEnabled
TB,N,V_labelTileDecodeEnabled
disableBackgroundLabelLayout
TB,N,V_disableBackgroundLabelLayout
labelAllowDefaultStyle
TB,N,V_labelAllowDefaultStyle
labelUpdateMapTilesContinuously
TB,N,V_labelUpdateMapTilesContinuously
labelStyleOverridesDisabled
TB,N,V_labelStyleOverridesDisabled
labelAutoOffsetRoadText
TB,N,V_labelAutoOffsetRoadText
dontMatchRouteLine
TB,N,V_dontMatchRouteLine
dontMapMatchToSnappedRouteLine
TB,N,V_dontMapMatchToSnappedRouteLine
highlightRouteLineSnappingStatus
TB,N,V_highlightRouteLineSnappingStatus
dontVerifyRouteToTransitSnapping
TB,N,V_dontVerifyRouteToTransitSnapping
showManeuverPoints
TB,N,V_showManeuverPoints
paintRoadSigns
TB,N,V_paintRoadSigns
paintLabelBounds
TB,N,V_paintLabelBounds
paintLabelRoadFeatures
TB,N,V_paintLabelRoadFeatures
paintLabelCollisionLines
TB,N,V_paintLabelCollisionLines
paintLabelCounts
TB,N,V_paintLabelCounts
labelerOutputIndex
TC,N,V_labelerOutputIndex
displayTextureAtlas
TB,N,V_displayTextureAtlas
disableGlyphTextureAtlas
TB,N,V_disableGlyphTextureAtlas
disableIconTextureAtlas
TB,N,V_disableIconTextureAtlas
textureAtlasIndex
TC,N,V_textureAtlasIndex
textureAtlasPageIndex
TS,N,V_textureAtlasPageIndex
paintTransitCounts
TB,N,V_paintTransitCounts
hideDirectionalArrows
TB,N,V_hideDirectionalArrows
hideClientPositionedFeatures
TB,N,V_hideClientPositionedFeatures
hideServerPositionedRoadFeatures
TB,N,V_hideServerPositionedRoadFeatures
hideServerPositionedTransitFeatures
TB,N,V_hideServerPositionedTransitFeatures
keepTooCloseServerPositionedTransitFeatures
TB,N,V_keepTooCloseServerPositionedTransitFeatures
overrideNeworkDefaultsBaseSSLPMSwitch
TB,N,V_overrideNeworkDefaultsBaseSSLPMSwitch
textlessPOIsEnabled
TB,N,V_textlessPOIsEnabled
textlessPOIsMinZoom
Tf,N,V_textlessPOIsMinZoom
labelBaseSSLPMEnabled
TB,N,V_labelBaseSSLPMEnabled
labelHideLineFeatures
TB,N,V_labelHideLineFeatures
labelHidePointFeatures
TB,N,V_labelHidePointFeatures
loadGreenTraffic
TB,N,V_loadGreenTraffic
useStaticTrafficFeed
TB,N,V_useStaticTrafficFeed
showTrafficCasing
TB,N,V_showTrafficCasing
texturedTrafficCasing
TB,N,V_texturedTrafficCasing
prioritizeTrafficSkeleton
TB,N,V_prioritizeTrafficSkeleton
paintRoadsStitchedByName
TB,N,V_paintRoadsStitchedByName
realisticWireframeEnabled
TB,N,V_realisticWireframeEnabled
altitudePauseLoading
TB,N,V_altitudePauseLoading
altitudeFreezeViewNode
TB,N,V_altitudeFreezeViewNode
altitudeTexturePaging
TB,N,V_altitudeTexturePaging
altitudeShowTileBounds
TB,N,V_altitudeShowTileBounds
altitudeHighResSatellite
TB,N,V_altitudeHighResSatellite
altitudeMipmapSatellite
TB,N,V_altitudeMipmapSatellite
altitudeMipmapFlyover
TB,N,V_altitudeMipmapFlyover
altitudeMipmapObjectTree
TB,N,V_altitudeMipmapObjectTree
altitudeShowNightLight
TB,N,V_altitudeShowNightLight
altitudePrintRenderedTilesStat
TB,N,V_altitudePrintRenderedTilesStat
altitudeDisableC3mTextureLoading
TB,N,V_altitudeDisableC3mTextureLoading
altitudeShowTriggerBounds
TB,N,V_altitudeShowTriggerbounds
disableTransitLineDrawing
TB,N,V_disableTransitLineDrawing
disableTransitLineMerging
TB,N,V_disableTransitLineMerging
disableTransitLineGroupMerging
TB,N,V_disableTransitLineGroupMerging
dumpTransitTileContents
TB,N,V_dumpTransitTileContents
dumpRouteAndPath
TB,N,V_dumpRouteAndPath
disableIntraLinkTransitLineCrossings
TB,N,V_disableIntraLinkTransitLineCrossings
useMetalRenderer
TB,N,V_useMetalRenderer
showNavCameraDebugConsole
TB,N,V_showNavCameraDebugConsole
showNavCameraDebugConsoleAttributes
TB,N,V_showNavCameraDebugConsoleAttributes
showNavCameraDebugConsoleProperties
TB,N,V_showNavCameraDebugConsoleProperties
showNavCameraDebugLegend
TB,N,V_showNavCameraDebugLegend
showNavCameraDebugOverlay
TB,N,V_showNavCameraDebugOverlay
useGeoResourceLib
TB,N,V_useGeoResourceLib
ribbonCrispness
Tf,N,V_ribbonCrispness
altitudeLodScale
Tf,N,V_altitudeLodScale
altitudeTileQualityThreshold
Tf,N,V_altitudeTileQualityThreshold
altitudeHideMeshTime
Tf,N,V_altitudeHideMeshTime
altitudeFadeSpeed
Tf,N,V_altitudeFadeSpeed
altitudeTourSpeedup
TB,N,V_altitudeTourSpeedup
altitudeTourSpeedupFactor
Tf,N,V_altitudeTourSpeedupFactor
isInstalledInLockScreen
TB,N,V_isInstalledInLockScreen
enableLoggingInLockScreen
TB,N,V_enableLoggingInLockScreen
useBuildingShadowTexture
TB,N,V_useBuildingShadowTexture
layoutContinuously
TB,N,V_layoutContinuously
enableSignPostEvents
TB,N,V_enableSignPostEvents
disableStylesheetAnimations
TB,N,V_disableStylesheetAnimations
readLandmarksFromDisk
TB,N,V_readLandmarksFromDisk
drawPerformanceHUD
TB,N,V_drawPerformanceHUD
expandedPerformanceHUD
TB,N,V_expandedPerformanceHUD
trackingCameraZoomFurther
TB,N,V_trackingCameraZoomFurther
holdOntoStyleAttributes
TB,N,V_holdOntoStyleAttributes
footprintsToSuppress
T@"NSMutableArray",&,N,V_footprintsToSuppress
suppressFootprints
TB,N,V_suppressFootprints
debugOverlayOffsetX
Ti,N,V_debugOverlayOffsetX
debugOverlayOffsetY
Ti,N,V_debugOverlayOffsetY
drawDebugTransit
TB,N,V_drawDebugTransit
labelTransitLineCollisionEnabled
TB,N,V_labelTransitLineCollisionEnabled
labelHighlightingVerboseLoggingEnabled
TB,N,V_labelHighlightingVerboseLoggingEnabled
labelHighlightingTransitFeaturesOnly
TB,N,V_labelHighlightingTransitFeaturesOnly
labelOcclusionDisabled
TB,N,V_labelOcclusionDisabled
landmark2DStrokeSettings
T{?=BBBff},N,V_landmark2DStrokeSettings
shouldUseTestTileLoader
TB,N,V_shouldUseTestTileLoader
constantlyChangeTileGroup
TB,N,V_constantlyChangeTileGroup
constantlyChangeTileGroupInterval
Td,N,V_constantlyChangeTileGroupInterval
disableRoadSignLimit
TB,N,V_disableRoadSignLimit
showNavLabelOverlay
TB,N,V_showNavLabelOverlay
enableTrafficFeatureLabelDebugging
TB,N,V_enableTrafficFeatureLabelDebugging
enableEtaLabelDebugging
TB,N,V_enableEtaLabelDebugging
enableRouteShareSectionDebugging
TB,N,V_enableRouteShareSectionDebugging
enableEtaLabelRectDebugging
TB,N,V_enableEtaLabelRectDebugging
etaLabelDebugScore
TQ,N,V_etaLabelDebugScore
etaLabelDebugOrientationMask
TI,N,V_etaLabelDebugOrientationMask
etaLabelsAvoidScreenEdges
TB,N,V_etaLabelsAvoidScreenEdges
enableRouteIntersectionTesting
TB,N,V_enableRouteIntersectionTesting
forceEtaLabelPlacement
TB,N,V_forceEtaLabelPlacement
traceEtaDebugLog
TB,N,V_traceEtaDebugLog
enableARDebugConsole
TB,N,V_enableARDebugConsole
enableAROmniTileLoader
TB,N,V_enableAROmniTileLoader
arOverrideDefaults
TB,N,V_arOverrideDefaults
arVirtualPlaneHeight
Tf,N,V_arVirtualPlaneHeight
arDefaultHeight
Tf,N,V_arDefaultHeight
arSwipeGesture
TQ,N,V_arSwipeGesture
arPinchGesture
TQ,N,V_arPinchGesture
arRenderAtNativeRate
TB,N,V_arRenderAtNativeRate
paintKeysInView
TB,N,V_paintKeysInView
paintStandardLabelMapData
TB,N,V_paintStandardLabelMapData
paintPolygonLayerData
TB,N,V_paintPolygonLayerData
paintRoadTileData
TB,N,V_paintRoadTileData
muninDebugLayer
TB,N,V_muninDebugLayer
muninGraphConnections
TB,N,V_muninGraphConnections
muninShowRigTransitionInfo
TB,N,V_muninShowRigTransitionInfo
muninIgnorePlacesMetadata
TB,N,V_muninIgnorePlacesMetadata
muninOverrideParallax
TB,N,V_muninOverrideParallax
muninCameraPanOffset
Tf,N,V_muninCameraPanOffset
muninParallaxSpring
Tf,N,V_muninParallaxSpring
muninParallaxDamper
Tf,N,V_muninParallaxDamper
muninParallaxScale
Tf,N,V_muninParallaxScale
muninTransitionMinResolution
Tf,N,V_muninTransitionMinResolution
muninTransitionMaxResolution
Tf,N,V_muninTransitionMaxResolution
muninSlowMotion
TB,N,V_muninSlowMotion
enableMuninMiniMapRoadWidths
TB,N,V_enableMuninMiniMapRoadWidths
enableMuninMiniMapComposedEdgeRoadColoring
TB,N,V_enableMuninMiniMapComposedEdgeRoadColoring
enableMuninMiniMapCollectionPoints
TB,N,V_enableMuninMiniMapCollectionPoints
enableMuninMiniMapRoadZData
TB,N,V_enableMuninMiniMapRoadZData
enableMuninRoadNetworkMiniMap
TB,N,V_enableMuninRoadNetworkMiniMap
muninRoadNetworkMiniMapAreaInMeters
Tf,N,V_muninRoadNetworkMiniMapAreaInMeters
muninIntermediatePointStep
TQ,N,V_muninIntermediatePointStep
muninAvailabilityOverride
TQ,N,V_muninAvailabilityOverride
overrideLod
TB,N,V_overrideLod
lodOverride
TC,N,V_lodOverride
overrideIntermediateLod
TB,N,V_overrideIntermediateLod
intermediateLodOverride
TC,N,V_intermediateLodOverride
muninReplayLastTap
TB,N,V_muninReplayLastTap
muninTapState
T{?=ffddff},N,V_muninTapState
muninOverrideFov
TB,N,V_muninOverrideFov
defaultFovPortrait
Tf,N,V_defaultFovPortrait
maxFovPortrait
Tf,N,V_maxFovPortrait
defaultFovLandscape
Tf,N,V_defaultFovLandscape
maxFovLandscape
Tf,N,V_maxFovLandscape
minFov
Tf,N,V_minFov
minFovSpring
Tf,N,V_minFovSpring
maxFovSpring
Tf,N,V_maxFovSpring
forceBumpNextTap
TB,N,V_forceBumpNextTap
forceBumpAll
TB,N,V_forceBumpAll
slowMotionBump
TB,N,V_slowMotionBump
overrideAmbient
T{?=ffff},N,V_overrideAmbient
overrideLight1
T{?=ffff},N,V_overrideLight1
overrideLight2
T{?=ffff},N,V_overrideLight2
overrideLight3
T{?=ffff},N,V_overrideLight3
overrideLight1Azimuth
Tf,N,V_overrideLight1Azimuth
overrideLight1Altitude
Tf,N,V_overrideLight1Altitude
overrideLight2Azimuth
Tf,N,V_overrideLight2Azimuth
overrideLight2Altitude
Tf,N,V_overrideLight2Altitude
overrideLight3Azimuth
Tf,N,V_overrideLight3Azimuth
overrideLight3Altitude
Tf,N,V_overrideLight3Altitude
lightingOverrideAmbient
TB,N,V_lightingOverrideAmbient
lightingOverrideLight1
TB,N,V_lightingOverrideLight1
lightingOverrideLight2
TB,N,V_lightingOverrideLight2
lightingOverrideLight3
TB,N,V_lightingOverrideLight3
lightingEnableAmbient
TB,N,V_lightingEnableAmbient
lightingEnableLight1
TB,N,V_lightingEnableLight1
lightingEnableLight2
TB,N,V_lightingEnableLight2
lightingEnableLight3
TB,N,V_lightingEnableLight3
lightingAccelerateTime
TB,N,V_lightingAccelerateTime
lightingStopTime
TB,N,V_lightingStopTime
lightingStoppedTimeHour
TC,N,V_lightingStoppedTimeHour
shouldUseSDFGlyphs
TB,N,V_shouldUseSDFGlyphs
shouldOverrideUpscaleFactor
TB,N,V_shouldOverrideUpscaleFactor
sdfGlyphShaderUpscaleFactor
Tf,N,V_sdfGlyphShaderUpscaleFactor
shouldUseSDFSuperSampling
TB,N,V_shouldUseSDFSuperSampling
shouldOverrideSuperSampleKernelSize
TB,N,VshouldOverrideSuperSampleKernelSize
sdfGlyphSuperSampleKernelSize
Tf,N,V_sdfGlyphSuperSampleKernelSize
shouldFreezeLayoutCamera
TB,N,V_shouldFreezeLayoutCamera
decodeStyleNames
debugStyleManager
T{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}},N,V_debugStyleManager
VendedMesh
IndexData
VKLabelNavRoad (%@)
 ptA->B: %f, %f, %f, %f
 routeOffset:%.2f, intraPri:%ld
 isStartOfRoadName
 isInGuidance
 isGuidanceStepStart
 isAwayFromRoute
 isOnRoute
 isOnDualCarriageway
%@_%llX
%@_%llX_%@
tile
Tr^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}},R,N,V_tile
cstrName
Tr*,R,N
shieldGroup
junctionB
T^{?=II^{?}},R,N,V_junctionB
navJunctionA
T@"VKLabelNavJunction",R,N,V_navJunctionA
T{Matrix<float, 2, 1>=[2f]},N,V_direction
TB,N,V_isOnRoute
TB,N,V_isStartOfRoadName
TB,N,V_isInGuidance
TB,N,V_isGuidanceStepStart
areLabelsDisabled
TB,N,V_areLabelsDisabled
routeCrossProduct
Tf,N,V_routeCrossProduct
Tq,N,V_intraRoadPriority
isRoadLabelUnique
TB,N,V_isRoadLabelUnique
suppressRoadSignIfShieldPresent
TB,R,N,V_suppressRoadSignIfShieldPresent
isOnewayToJunction
roadClass
roadSignAlignment
DiffuseBuildingTopShader
B24@?0@8@"NSDictionary"16
drawRoadSigns
TB,N,V_drawRoadSigns
T@"VKPolylineOverlay",&,N,V_route
currentLocationText
T@"NSString",&,N,V_currentLocationText
currentRoadName
T@"NSString",&,N,V_currentRoadName
currentShieldGroup
T@"NSString",&,N,V_currentShieldGroup
activeSigns
Tr^{vector<std::__1::shared_ptr<md::NavLabel>, geo::StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator> >=^{shared_ptr<md::NavLabel>}^{shared_ptr<md::NavLabel>}{__compressed_pair<std::__1::shared_ptr<md::NavLabel> *, geo::StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator> >=^{shared_ptr<md::NavLabel>}{StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator>=^{Allocator}}}},R,N,V_activeSigns
needsLayout
TB,R,N,V_needsLayout
currentRoadSign
T^{NavCurrentRoadSign=^^?{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}{shared_ptr<md::LabelStyle>=^{LabelStyle}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{?=ff}{unique_ptr<md::NavLabelPart, std::__1::default_delete<md::NavLabelPart> >={__compressed_pair<md::NavLabelPart *, std::__1::default_delete<md::NavLabelPart> >=^{NavLabelPart}}}{Mercator2<double>=[2d]}{shared_ptr<md::Anchor>=^{Anchor}^{__shared_weak_count}}{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}{Box<float, 2>={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}}BBBfBBBff},R,N
currentRoadSignPixelHeight
debugDisableRoadSignLimit
TB,N,V_debugDisableRoadSignLimit
debugEnableShieldsOnRouteLine
TB,N,V_debugEnableShieldsOnRouteLine
artworkCache
T^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}},N,V_artworkCache
T@"NSString",R,&,N,V_name
T@"NSString",R,&,N,V_shieldGroup
T@"NSString",R,&,N,V_roadName
routePoint
Ti,R,N,V_routePoint
TransitNodeRGBShader
settings
PrefilteredLineShader
/VertexData
vertexOffset
zScale
vertex_input_vertex2AndStyleIndex
style.vertexOffset
style.tileOrigin
style.tileSize
style.zScale
vertex2AndStyleIndex
isSupported
T@"<MDARControllerDelegate>",N,V_delegate
session
T@"ARSession",R,N,V_session
sessionInterruptedReason
TQ,R,N,V_sessionInterruptedReason
GlyphWithOuterHaloShader
NoPosition
NoStyle
OffScreen
HideInNav
DebugHide
z < min
z > max
NotVisible
HikerInvalid
MatrixInvalid
LoadingGlyphInfos
NoGlyphInfos
NoQuads
NoText
LoadingArtwork
NoArtwork
DuplicateArtwork
Kinked
Extrapolated
Collided
Deduped
Occluded
ZeroTextSize
Overridden
SceneHide
DeactivateHide
PathBusy
NotDisplayable
FeatureHidden
NotFacing
CurvedUpsideDown
MaxLabelsReached
<NONE>
Dead
Prepare
Display
Hidden
FadeIn
FadeOut
Visible
%d=%llu
%d=%d
,%d=%llu
%d=%lld
%@%@
LABEL:
FEATURE:
MapTiles: %li Labels: %zu Labels shown: %i
Feature Pool: %li roads, %li points, %li transit links
Feature Pool: tiles=%zu, points=%zu, roads=%zu, transit links=%zu
Total TextDataFontVariant: %u
MapTiles: tiles=%zu, label-fail(noFeature=%u, noStyle=%u, zRange=%u)
Labels: active=%zu(%zu) cached=%zu custom=%zu overridden=%zu exist=%u
DisplayLabels: total=%zu active=%u
Custom features: %zu
ExternalObjects: %@
Count Pushed Labels: %d
StagingState: 
%s=%d 
LabelDisplayState: 
Collision Tested: Items=%u ReserveSpace=%u Lines=%u
LabelsPerStyle:%.1f
Outcome: (Staging, Display)
   %@:(%d, %d)
Fade:
   Cross Fade Parts: %d
   Style Fade Parts: %d
   Parts Cross Fading: %d
Selected Feature
Selected Label
All Labels
Label 
SkyShader
/VertexData
skyStartOffset
horizon
screenHeight
vertexInput_vertexPosition
style.skyStartOffset
style.horizon
style.screenHeight
style
imageData
{VKCameraState={RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}d{Unit<RadianUnitDescription, double>=d}d}
%@ size: (%zu, %zu)
Td,R,N,V_scale
T^{CGImage=},R,N,V_image
public.jpeg
/workers/worker
FogShader
fogSlope
fogOffset
skyOffset
skyBottomColor
skyTopColor
Skyfog
v16@?0^{?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}8
v16@?0^{?=^{?}QQQQ^{?}^{?}}8
businessID
mapIdentifier
T@"GEOMapItemIdentifier",R,N
buildings
SSLPM:
 Tile=(%i.%i.%i)
  Line ID=%llu lidx=%i rng=(%.2f:%.2f)
   Section fidx=%i rng=(%.2f:%.2f) rev=%i
 sub=(%u:%u)
   Attr type=%i rsn=%i rng=(%.2f:%.2f)
StandardLabelMarker
(%i %i %i %i)
DebugBoundsElement
/RenderableGroup
MuninRoadLabelPart
  padding:%.1f
nextFireDate
Td,R,N,V_nextFireDate
basic
centerCoordinateDistanceRange
T{?=dd},N,V_centerCoordinateDistanceRange
Tq,N,V_annotationTrackingZoomStyle
Tq,N,V_annotationTrackingHeadingAnimationDisplayRate
FoggedSpecularBuildingShader
StyleTextureRibbonShader
vertexInput_styleTexture
/loading/cache/traffic/dynamic
/loading/traffictiledatacache
/loading/skeletonrequestmanager
FlyoverLibrary
EarthCorona::earthcorona_vertex
EarthCorona::earthcorona_fragment
EndOfWorld::endOfWorld_vertex
EndOfWorld::endOfWorld_fragment
Flyover::flyover_vertex
Flyover::flyover_fragment
FlyoverBorder::flyoverBorder_vertex
FlyoverBorder::flyoverBorder_fragment
FlyoverBorderRibbon::flyoverBorderRibbon_vertex
FlyoverBorderRibbon::flyoverBorderRibbon_fragment
FlyoverFlat::flyoverFlat_vertex
FlyoverFlat::flyoverFlat_fragment
FlyoverManeuver::flyoverManeuver_vertex
FlyoverManeuver::flyoverManeuver_fragment
FlyoverMasked::flyoverMasked_vertex
FlyoverMasked::flyoverMasked_fragment
FlyoverMorph::flyoverMorph_vertex
FlyoverMorph::flyoverMorph_fragment
FlyoverMorphBorder::flyoverMorphBorder_vertex
FlyoverMorphBorder::flyoverMorphBorder_fragment
FlyoverMorphNight::flyoverMorphNight_vertex
FlyoverMorphNight::flyoverMorphNight_fragment
FlyoverNight::flyoverNight_vertex
FlyoverNight::flyoverNight_fragment
FlyoverNightDim::flyoverNightDim_vertex
FlyoverNightDim::flyoverNightDim_fragment
FlyoverOverlay::flyoverOverlay_vertex
FlyoverOverlay::flyoverOverlay_fragment
FlyoverRoadFillProcedural::flyoverRoadFillProcedural_vertex
FlyoverRoadFillProcedural::flyoverRoadFillProcedural_fragment
FlyoverRoadFillTextured::flyoverRoadFillTextured_vertex
FlyoverRoadFillTextured::flyoverRoadFillTextured_fragment
FlyoverRoadStrokeProcedural::flyoverRoadStrokeProcedural_vertex
FlyoverRoadStrokeProcedural::flyoverRoadStrokeProcedural_fragment
FlyoverRoadStrokeTextured::flyoverRoadStrokeTextured_vertex
FlyoverRoadStrokeTextured::flyoverRoadStrokeTextured_fragment
FlyoverRoute::flyoverRoute_vertex
FlyoverRoute::flyoverRoute_fragment
FlyoverTraffic::flyoverTraffic_vertex
FlyoverTraffic::flyoverTraffic_fragment
SolidLine::solidLine_vertex
SolidLine::solidLine_fragment
Stars::stars_vertex
Stars::stars_fragment
StenciledAlphaClear::stenciledAlphaClear_vertex
StenciledAlphaClear::stenciledAlphaClear_fragment
TileBaseSurface::tileBaseSurface_vertex
TileBaseSurface::tileBaseSurface_fragment
TileSkybox::tileSkybox_vertex
TileSkybox::tileSkybox_fragment
/morphactor/
/render/morph/indexdata
/render/morph/vertexdata
render/morph/vertexdata
TransitionTileLoadJobTotalTime
TransitionTileLoadJobMainTime
Tile 
Download failed: %@ Error: %@
GeoServicesLoadJobTotalTime (ms)
GeoServicesLoadJobDataSize (bytes)
FlyoverTrafficShader
scaling
Displacement
pattern
Pattern
glow
ramp
skew
vertexInput_binormal
vertexInput_bounds
vertexInput_misc
vertexInput_extension
displacement.modelview
displacement.width
displacement.scaling
pattern.pattern
style.glow
style.ramp
sharedConstants.skew
displacement
binormal
misc
extension
v60@?0c8Q12Q20{FeatureAttributeSet={vector<gss::FeatureAttributePair, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >=^{FeatureAttributePair}^{FeatureAttributePair}{__compressed_pair<gss::FeatureAttributePair *, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >=^{FeatureAttributePair}{StdAllocator<gss::FeatureAttributePair, gss::Allocator>=^{Allocator}}}}}28
white
%@@%ux
Munin mix
Munin mix depth
Mix pass
Rig pass
Munin rig buffer
Munin rig depth
Downsample/blur pass
Blur buffer
MuninViewSynthesis
Debug
MuninLabels
MuninOverlays
{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}12@?0f8
tourShouldResumeWhenDoneGesturing
TB,N,V_tourShouldResumeWhenDoneGesturing
<altitude::GeoRegionalResourceLoader> %p
Regional resource download failed: %@ Error: %@
TextureWithBrightnessShader
tap_sheet_sdf_4k
tap_sheet_alpha_1k
Polygon Stroke Mesh
Polygon Stroke Index Data
Polygon Stroke Vertex Data
Flat Building Roof Mesh
Flat Building Roof Vertex Data
Flat Building Roof Index Data
baseHeight (%f) > height (%f) for feature in tile %d.%d.%d
problem computing angle histogram for building roof, quitting
TexturedExtendedShader
TexturedShader
/VertexData
view
com.apple.Maps.MIController
com.apple.mapinspectord
v16@?0@"NSObject<OS_xpc_object>"8
Data
Ping
DebugTree
UUID
Tree Data
isActive
TB,R,N,V_isActive
OptimizedTrafficShader
glowColor
pillPhase
frameBufferAlphaScale
pillLength
localPillRadius
localPillStart
pillAspectRatio
pillAlphaFunction
vertexInput_startPosition
vertexInput_endPosition
vertexInput_startDistance
vertexInput_endDistance
vertexInput_direction
vertexInput_coordinates
style.glowColor
style.pillPhase
style.frameBufferAlphaScale
style.pillLength
style.localPillRadius
style.localPillStart
style.pillAspectRatio
style.pillAlphaFunction
startPosition
endPosition
endDistance
coordinates
/Renderable
/render/flyoverborder/vertexdata
/render/tilebasic/indexdata
/mesh
/indexdata
/loading/network/regionalresourceloader
/loading/regionalresourcecachenode
/loading/poicachenode
/loading/pointpolygoncachenode
/loading/labeldatarequestmanager
unnamed
VectorFeatureMarker
VKLabelNavJunction 
roads:%@
geoJunction
Tr^{?=II^{?}},R,N,V_geoJunction
tileCoordinate
T{Matrix<float, 2, 1>=[2f]},R,N,V_tileCoordinate
roads
T@"NSArray",R,N,V_roads
outgoingRoad
T@"VKLabelNavRoad",R,N,V_outgoingRoad
incomingRoad
T@"VKLabelNavRoad",R,N,V_incomingRoad
distanceFromPreviousShieldLabel
Tf,N,V_distanceFromPreviousShieldLabel
isOnDualCarriageway
TB,N,V_isOnDualCarriageway
hasSharedRouteDirection
TB,R,N,V_hasSharedRouteDirection
sharedRouteDirection
T{Matrix<float, 2, 1>=[2f]},N,V_sharedRouteDirection
isIntraRamp
isTileEdgeJunction
isRouteRefineJunction
TB,N,V_isRouteRefineJunction
isRoadTerminus
isIntersection
isMultiRoadIntersection
isOffRouteGraph
isOverpass
TB,R,N,V_isOverpass
isRouteOverpass
TB,N,V_isRouteOverpass
largestRoadClass
depthFromRoute
TQ,N,V_depthFromRoute
overpassJunction
T@"VKLabelNavJunction",N,V_overpassJunction
worldUnitsPerMeter
Td,R,N,V_worldUnitsPerMeter
junctionSign
T@"VKLabelNavRoadLabel",R,N,V_junctionSign
requiredLabelPlacement
preferredLabelPlacement
Ti,N,V_preferredLabelPlacement
/render/earthcorona/vertexdata
/render/earthcorona/indexdata
/render/earthcorona/mesh
offsetX
offsetY
_routeMatch: %@
_projectedRouteMatch: %@
_projectedPosition: %f, %f, %f
_projectedCourse: %f
projectedRouteMatch
T@"GEORouteMatch",&,N,V_projectedRouteMatch
projectedPosition
T{Matrix<double, 3, 1>=[3d]},R,N,V_projectedPosition
projectedLocation
projectedCourse
Td,R,N,V_projectedCourse
projectedLocationOnRoute
ViewStretchAlphaShader
ViewShader
textureSize
stretchWeightThresholdsLowHigh
view.mvp
sharedConstants.textureSize
sharedConstants.stretchWeightThresholdsLowHigh
GlowAlphaShader
Glow
glow.radius
glow.opacity
NavShieldLabelPart
MDDisplayLayer
MDDisplayLayer MSAA
v16@?0^{RenderQueue={PassDescriptor=[4{AttachmentActions=ii}]{AttachmentActions=ii}{AttachmentActions=ii}}{vector<ggl::RenderQueue::Pass, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}^{Pass}{__compressed_pair<ggl::RenderQueue::Pass *, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}{StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ComputeQueue *, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}^^{ComputeQueue}{__compressed_pair<ggl::ComputeQueue **, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}{StdAllocator<ggl::ComputeQueue *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::CommandBuffer *, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}^^{CommandBuffer}{__compressed_pair<ggl::CommandBuffer **, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}{StdAllocator<ggl::CommandBuffer *, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::RenderTransaction>=^{RenderTransaction}^{__shared_weak_count}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}}8
T@"CALayer",R,N,V_layer
TB,R,N,V_shouldRasterize
OuterShadowRibbonShader
strokeSlopeFactor
style.strokeSlopeFactor
distanceTexture
distanceTexture_sampler
Noise
heightProvider
T@"<VKMercatorTerrainHeightProvider>",N,V_heightProvider
kVKOuterStrokeWidthAttributeName
StyleFade
T@"<VKVectorOverlayDelegate>",N,G_delegate,S_setDelegate:,V_delegate
worldIndexes
T{Range<signed char>=cc},R,N,V_worldIndexes
T{shared_ptr<md::PolylineOverlayStyle>=^{PolylineOverlayStyle}^{__shared_weak_count}},R,N,V_style
T@"NSArray",R,N,V_polylines
lineJoin
lineCap
T^{CGColor=},N
miterLimit
renderable
T{shared_ptr<md::CircleOverlayRenderable>=^{CircleOverlayRenderable}^{__shared_weak_count}},R,N,G_renderable,V_renderable
T{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}},R,N,G_bounds,V_bounds
fillColor
geometry
T{shared_ptr<geo::Polygon2<double> >=^{Polygon2<double>}^{__shared_weak_count}},R,N,G_geometry,V_geometry
T{shared_ptr<md::PolygonOverlayRenderable::Style>=^{Style}^{__shared_weak_count}},R,N,G_style,V_style
polygons
T@"NSArray",R,N,V_polygons
texture2
RTTGenerator
ClearBuffers
GridFirst
GroundCover
PolygonsBelowRoads
NavPolygonsBelowRoads
TransitLinesBelowRoads
SelectedTransitLinesBelowRoads
RouteMask
RoadsFill
HybridRoadsFill
Realistic
PolygonsAboveRoads
NavPolygonsAboveRoads
TransitLines3D
SelectedTransitLines3D
BuildingShadows
BuildingsLandmarks2D
PolygonsAboveBuildings
NavPolygonsAboveBuildings
TransitLines2D
SelectedTransitLines2D
Buildings3D
BuildingsLandmarks3D
VenueBuildings
VenueBuildingsLandmarks
HybridRastersOverRoads
OverlaysBeneath
RouteClear
RouteTraveledStrokes
RouteStrokes
RouteTraveledFills
RouteFills
LabelsBeneathOverlays
TransitNodes
LabelsAboveOverlays
TrafficIncidents
LabelsAboveFog
OverlaysAbove
LabelsAboveExternalOverlays
NavigationPuck
GridLast
DiffuseBuildingPointyRoofShader
worldTransform
lineWidthOuter
lineWidthInner
Polygon
vertexStyleIndicesAndTexture
side
CenterLatitude
CenterLongitude
PitchRadians
YawRadians
ZoomLevel
TileSize
Cannot load viewport: Invalid dictionary
Cannot load viewport: Invalid coordinate
Cannot load viewport: Invalid pitch
Cannot load viewport: Invalid yaw
Cannot load viewport: Invalid zoom level
dictionaryRepresentation
T@"NSDictionary",R,N
T{?=dd},N,V_centerCoordinate
zoomLevel
Tf,N,V_zoomLevel
Tq,N,V_tileSize
Td,N,V_pitch
Td,N,V_yaw
variantType
entries
textEntries
hasVariantType
Ti,N,V_variantType
T@"NSMutableArray",&,N,V_entries
T@"NSMutableArray",&,N,V_textEntries
VARIANT_TYPE_NONE
VARIANT_TYPE_DIM
ColorGlyphWithOuterHaloShader
DI$_%X
SH$_%@
JC$_%@
%@, (%@)
navFeature
T@"<VKLabelNavFeature>",N,V_navFeature
Tr^{shared_ptr<md::NavLabel>=^{NavLabel}^{__shared_weak_count}},R,N,V_label
alignment
TC,N,V_alignment
desiredOffsetDistance
Tf,N,V_desiredOffsetDistance
displayID
TI,N,V_displayID
isShieldLabel
isRoadLabel
isJunctionLabel
isManeuverLabel
isEtaLabel
isTrafficCameraLabel
renderOrder
TS,N
mercatorPoint
T{Mercator2<double>=[2d]},N,V_mercatorPoint
 SystemTypes:%@
 LineTypes:%@
 TransitTypes:%@
oppositeCarriagewayJunctionsValid
TB,N,V_oppositeCarriagewayJunctionsValid
oppositeCarriagewayJunctions
T@"NSMutableArray",R,&,N,V_oppositeCarriagewayJunctions
junctions
T@"NSMutableArray",&,N,V_junctions
%ld.%ld
validPoint=%i validTangent=%i offset=%.2f offsetOutside = %.2f length=%.2f
    pt=(%f,%f) tngt,nrml=(%.2f,%.2f) jctn=%p type=%i sr=%i
<Link:%p>
EaseRegions: 
start=(none)
start=(%.2f:%.2f)[cl:%.2f]
 end=(none)
 end=(%.2f:%.2f)[cl:%.2f]
NodeID From=%llu To=%llu
Sections:
  %i:%@
    geoSection: start=%.2f end=%.2f
MergedLines:
  Lines Truncated...
  %i:%@
    
CollapsedLines:
  %i:MergedLine:%i %@
 Lines Truncated...
 %i:%@, slot:%d normal:%.02f
btCHECKER
btHORIZPINSTRIPE
btVERTPINSTRIPE
%d %d %d
DevResources
.transform
SUPPRESSID:
edgePadding
T{VKEdgeInsets=ffff},N,V_edgePadding
[MuninRoadLabeler]
 State: isSceneLoaded=%i
 Junctions: active=%zu maxDist(Corner=%.1f Cross=%.1f)
 Labels: active=%zu(%zu) display=%zu exist=%u
/Stars/Mesh
DebugShader
DebugExtendedShader
/VertexData
PuckArrow
PuckCircle
puckCircle
driving
walking
PuckArrowMask
lightDirection
lightColor
lightSpecularColor
ambientLightColor
LightConfiguration
RouteLineTrafficShader
trafficColors
travelledTrafficColors
splitLength
vertexInput_trafficSpeed
style.trafficColors
style.travelledTrafficColors
style.splitLength
CrossFade
VenueOpenToBelowShadowShader
VenueOpenToBelowShadowAlphaShader
Venue Wall Mesh
Venue Wall Vertex Data
Venue Wall Index Data
Venue Wall End Cap Mesh
Venue Wall End Cap Vertex Data
Venue Wall End Cap Index Data
Venue Wall Horizontal Stroke Mesh
Venue Wall Horizontal Stroke Vertex Data
Venue Wall Horizontal Stroke Index Data
Venue Wall Vertical Stroke Mesh
Venue Wall Vertical Stroke Vertex Data
Venue Wall Vertical Stroke Index Data
Ti,R,N,V_layer
buildingId
maximumSectionLength
wallTexture
venueWallMeshes
Tr^{vector<std::__1::shared_ptr<ggl::VenueWall::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >=^{shared_ptr<ggl::VenueWall::MeshMesh>}^{shared_ptr<ggl::VenueWall::MeshMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >=^{shared_ptr<ggl::VenueWall::MeshMesh>}}},R,N
venueWallEndMeshes
Tr^{vector<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >=^{shared_ptr<ggl::VenueWall::EndCapMesh>}^{shared_ptr<ggl::VenueWall::EndCapMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >=^{shared_ptr<ggl::VenueWall::EndCapMesh>}}},R,N
venueWallHorizontalStrokeMeshes
Tr^{vector<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}}},R,N
venueWallVerticalStrokeMeshes
Tr^{vector<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}}},R,N
_style != nullptr
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/src/RoadFramework.mm
maskColor
blendMode
multiply
screen
darken
lighten
colorDodge
colorBurn
softLight
hardLight
difference
exclusion
saturation
luminosity
clear
copy
sourceIn
sourceOut
sourceAtop
destinationOver
destinationIn
destinationOut
destinationAtop
plusDarker
plusLighter
/VertexData
normalAndIsFacade
NavTrafficCameraLabelPart
NavRouteEtaLabelPart
HeightLoadJobTotalTime (ms)
HeightLoadJobMainTime (ms)
HeightLoadJobTotalTime(Bounds) (ms)
HeightLoadJobMainTime(Bounds) (ms)
VenueWallShader
VenueWallEndCapShader
VenueWallTopShader
normalMultiplier
textureScale
maximumTexCoord
Wall
innerOffset
outerOffset
WallTop
WallEndCap
vertexAttributes_position
vertexAttributes_styleIndices
vertexAttributes_quadSpaceCoordAndXTexCoord
vertexAttributes_tangents
vertexAttributes
wall.color
wall.width
wall.baseHeight
wall.height
wall.normalMultiplier
wall.textureScale
wall.maximumTexCoord
wall
vertexAttributes_quadSpaceCoord
wall.innerOffset
wall.outerOffset
EndCapVbo
quadSpaceCoord
quadSpaceCoordAndXTexCoord
StenciledAlphaClearShader
Clear
SimpleGridShader
invFwidth
style.invFwidth
mdc::LayerDataRequestKey<Type:
, Tile: 
FlyoverMorphNightShader
finerNight
coarseNight
finerNight_sampler
coarseNight_sampler
course
T{?=dd},N,V_coordinate
willChangeActiveTileGroup
T{function<void (GEOResourceManifestManager *)>={__value_func<void (GEOResourceManifestManager *)>={type=[32C]}^{__base<void (GEOResourceManifestManager *)>}}},V_willChangeActiveTileGroup
didChangeActiveTileGroup
T{function<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>={__value_func<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>={type=[32C]}^{__base<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>}}},V_didChangeActiveTileGroup
experimentConfigurationDidChange
T{function<void (GEOExperimentConfiguration *)>={__value_func<void (GEOExperimentConfiguration *)>={type=[32C]}^{__base<void (GEOExperimentConfiguration *)>}}},V_experimentConfigurationDidChange
variantEntries
T@"NSMutableArray",&,N,V_variantEntries
artworkIdentifier
shieldTypes
defaultForFeatureType
hasArtworkIdentifier
T@"NSString",&,N,V_artworkIdentifier
shieldTypesCount
T^i,R,N
defaultForFeatureTypesCount
defaultForFeatureTypes
FEATURE_TYPE_NONE
FEATURE_TYPE_ROAD
FEATURE_TYPE_TRANSIT
RenderTargetBlendShader
blend.blendFactor
map_%d_%d_%d
init is not a valid initializer for VKNavCameraController
Nav Camera Controller
Style Name: %s
Camera
Lat: %f, Long: %f
Height: %.2f
Pitch: %.2f
Heading: %.2f
Computed Maneuvers To Frame: %d
Zoom Level: %f
Zoom Scale: (%f, %f), Min: %f, Max: %f
Puck Course: %f
Coordinates to frame: %lu
Springs:
Puck Lat: %f, Long: %f, Alt: %f
Pitch: %.2f => %.2f
Heading: %.2f => %.2f
Distance From Target: %.2fm => %.2fm
Screen Pos: %.2f, %.2f  => %.2f, %.2f
Route: %s
Steps: %lu
Current Step: %ld
Grouped Maneuvers: %lu
RouteMatch: %s
isGoodMatch: %s
Step: %lu
Location Lat: %f, Long: %f
v32@?0@"GEOComposedRoute"8{PolylineCoordinate=If}16{PolylineCoordinate=If}24
Alternate Routes: %d
Style:
Name: %s
Camera Type: %s
Heading Type(Overriden: %s): %s
Maneuvers To Frame: %d
Heading Delta : %.2f
Heading Delta Min: %.2f
PuckScreenPosition: %f, %f
DistanceFromTarget: %.2fm
Min Camera Height: %.2fm
Max Camera Height: %.2fm
Puck Movement Bounds: %.2f, %.2f - %.2f, %.2f
Height Delta: H(%.2f, %.2f), V(%.2f, %.2f)
Framing Insets: (%.2f + %.2f), (%.2f + %.2f) - (%.2f + %.2f), (%.2f + %.2f)
Gesture Enable pan:%s zoom:%s rotate:%s pitch:%s
Pan Return Delay: %.2fs
Framing Source: %s
Max Framing Distance: %f
Framing Distance After Maneuver: %f
Max Maneuver: %d
Frame Grouped Maneuvers: %s
Ignore Points Behind: %s
Min/Max Pitch: %.2f, %.2f
Client Attributes:
%s: %s
Maneuver
Grouped Maneuver
Current Maneuver
Point To Frame
Alternate Route Maneuver
Additional Points To Frame
Framing Rect
Viewable Rect
Heading
Desired Heading
Puck Movement Box
Ideal Puck Point
Heading Delta
Heading Delta Min
v24@?0{?=dd}8
T^{MapDataAccess=^{World}C@^{CameraAccessInternal}{unique_ptr<md::CameraAccessCartographic, std::__1::default_delete<md::CameraAccessCartographic> >={__compressed_pair<md::CameraAccessCartographic *, std::__1::default_delete<md::CameraAccessCartographic> >=^{CameraAccessCartographic}}}{unique_ptr<md::CameraAccessGlobe, std::__1::default_delete<md::CameraAccessGlobe> >={__compressed_pair<md::CameraAccessGlobe *, std::__1::default_delete<md::CameraAccessGlobe> >=^{CameraAccessGlobe}}}{unique_ptr<md::CameraAccessMunin, std::__1::default_delete<md::CameraAccessMunin> >={__compressed_pair<md::CameraAccessMunin *, std::__1::default_delete<md::CameraAccessMunin> >=^{CameraAccessMunin}}}},R,N
T^{AnimationRunner=^{MapEngine}},R,N
T^{RunLoopController=^{MapEngine}qq},R,N
screenCanvas
T@"VKScreenCanvas<VKInteractiveMap>",N
T@"VKSceneConfiguration",N
zoomScale
T@"VKScreenCanvas<VKInteractiveMap>",N,V_screenCanvas
T@"VKSceneConfiguration",N,V_sceneConfiguration
baseDisplayRate
Tq,N,V_baseDisplayRate
clientFramingInsets
T{VKEdgeInsets=ffff},N,V_clientFramingInsets
Tracking
Framing
North
Course
Destination
Incidents
SearchResults
AdditionalRoutes
LineType
BorderType
AoiType
Country
FeatureType
PoiType
LandcoverType
MinZoomRank
Significance
FerryType
RailwayType
BrunnelType
OoiIconType
DetailedLandCoverType
NetworkClass
RoofType
LabelType
RampType
DisputedType
RuralUrbanType
DrivingSide
WalkableType
DrivableType
DataSource
BackgroundType
PoiCompany
TransitAgency
RoadHierarchyClass
TollType
RampDirection
ParentChildRelationship
StrokeType
RoadSurface
TransitType
VenueCategory
VenueCategoryDetailed
DebugShape
LocalNorthRegion
TransitNodeType
RouteSignificance
AccessPointType
Polity
PoiLandmark
TransitBrandType
TransitLineType
TransitNodeId
BrowseCategory
TransitDisplayGroup
TransitSystemSignificance
CategoryType
PolygonEdgeType
MapMode
SelectionState
AnnotationType
IconTappable
TargetedDisplay
LanguageLocale
RouteProximity
TrafficIncidentType
When
TransitBrandId
TransitSystemId
TransitLineId
MapOverlay
TransitStationId
TransportType
FlyoverPlace
TransitOperationalState
TransitRoutesMerged
RouteLegWhen
TransitLineMergeType
TransitNodeImageType
ViewProximity
ViewportSizeClass
VehicleIsParked
TransitLinkVisibleLineCount
TransitLineMultipleSystems
TransitLineMultipleLines
NavigationState
DistanceToCurrentManeuver
CurrentManeuverType
NextStepLength
CurrentIncidentType
CurrentManeuverComplexity
CurrentGroupedManeuverCount
SearchAlongTheRoute
VehicleSpeed
RoadSpeed
CameraMode
NavLabelType
MapZoomLevel
TransitLinkMultipleSystems
NavCameraDetached
NextManeuverRampType
ApplicationUILayout
CategoryIconPresentation
NavigationDestination
VenueFeature
EtaComparison
PedestrianPath
PrivatePath
MinorRoad
PedestLocalRoadrianPath
LocalMajorRoad
ConnectorRoad
Highway
MajorHighway
FreewayControlled
FreewayUncontrolled
Ferry
Water
SputnikBorder
ParkingStructure
PedestrianRoad
TransitTransfer
PedestrianOverpass
PedestrianOverpassSteps
PedestrianOverpassRamp
PedestianUnderpass
PedestianUnderpassSteps
PedestianUnderpassRamp
ServiceRoad
Gate
ParkingLotRoad
TransitStationGraph
InsideVenue
Unselected
Selected
Interactive
LocationGem
OffRoute
OnRoute
RelatedRoute
Accident
Construction
RoadClosure
Event
Hazard
LaneClosure
RampClosure
Ahead
Current
Prior
Approaching
Leaving
Automobile
Walking
Bicycle
Open
Closed
NotMerged
SimilarLinesSameSystem
DissimilarLinesSameSystem
SameDisplayGroup
(Invalid)
ColoredDot
RoundPill
OvalPill
OvalPillShadow
SecondaryFocus
MainFocus
Nano
ThreePlus
NotNavigating
ProceedingToRoute
BadRoute
Recalculating
EndOfRoute
EndOfLeg
Immediate
ExtremelyNear
VeryNear
Near
VeryFar
ExtremelyFar
Continue
Turn
Sharp Turn
Slight Turn
Branch
U-Turn
Round About
Off Ramp
On Ramp
Change Highway
Start Route
StartRouteWithUTurn
Arrive At Destination
Arrive Nearby Navigation
EnterFerry
ChangeFerry
No Incident
Blockage
Heavy Traffic
Heavy Traffic With Reroute
Simple
Complex
Three
Four
FivePlus
Zero
Twenty
Forty
Sixty
Eighty
Hundred
HundredTwenty
HundredForty
HundredSixty
Thirty
Fifty
Seventy
Ninety
HundredTen
HundredThirty
HundredFifty
LowZoom
HighZoom
TopAndBottom
SideBar
LabelGlyphMesh
LabelIconMesh
LabelSerialIndexData
TexturedSolidRibbonShader
BuildingShadowShader
vertex_input_texcoord
shadow.brightness
shadow.color
shadow
T@"<VKMapViewCameraDelegate>",N,V_cameraDelegate
isChangingMapType
TB,N,V_isChangingMapType
animations
T@"NSMutableArray",R,N,V_animations
groupStepHandler
T@?,C,N,V_groupStepHandler
Feature %llu
  %@ (%@)
  FeatureID:  %llu
  BusinessID:  %llu
  FeatureZoom: Min=%.2f Max=%.2f
  External: hasAnnotation=%i
  Style:%s
      (%s)
      Default
      Dedupable
  Attrs:
    %@
  No attrs
Public Name
No Public Name
Public Locale
No Public Locale
Feature ID
Venue ID
Venue Building ID
Venue Level ID
Venue Comoponent ID
Venue Floor Ordinal
Business ID
Feature Zoom Range
is External Feature
has Annotation
No Style Found
Feature Attributes
Set: 
PolygonOverlayFill
PolygonOverlayFillAntialias
/VertexData
CompressedVbo
FlyoverBorderShader
vertexInput_merccoord
vertexInput_flyovercoord
flyover
satellite_sampler
flyover_sampler
blend_sampler
merccoord
flyovercoord
FlyoverManeuverShader
properties
displacement.properties
displacement.color
Label:
  pos:(%.8f,%.8f), world:(%.8f,%.8f)
  Collision: Order=%d
 IconOrder=%d
 Rank=%.2f
 SortKey=%i
 Layer=%i Overlay=%s
  Attrs: Dedupe=%d Layer=%i%s%s%s%s
 (selectable)
 (SELECTED)
 (occludable)
 (OVERRIDDEN)
  MKBalloon:%s
Position
Zoom Range
Collision
Order
Icon Order
Rank
Sort Key
Layer
Overlay Group
Dedupe Rank
Is Selectable
Is Selected
Is Overridden
Is Occluded
Picked Label Balloon Behavior
Item Type
Collided Label
Root Part
Next Part
NullLabelPart
Is Null LabelPart
Disabled
Show
Line
Label
GenericLabel
WriteStencilPatternedRibbonShader
PatternedRibbonShader
style.distanceMultiplier
VertexDataGeoGL
IndexDataGeoGL
TextureAlphaMaskShader
FoggedSpecularLandmarkShader
Road
    layoutZ:
, pathZ:
 shield, 
 shields, 
 position
 positions
    spacing:
    Shields:
    travel dir:
Two way
Multiple
One way pos
One way neg
LocalizationStyleAttributes.plist
v32@?0@8@16^B24
DiffuseBuildingShader
hasShieldType
Ti,N,V_shieldType
shieldTexts
T@"NSMutableArray",&,N,V_shieldTexts
Icon: alpha:%.1f brightness:%.1f saturation:%.1f padding:%.1f
IconLabelPartBase
Brightness
Saturation
Padding
 size:%i
IconLabelPart
Icon Image Size
has Rounded Icon
LabelFeatureMarker
FlyoverRoadFillProceduralShader
FlyoverBorderRibbonShader
property
primary
secondary
tile.modelview
border.property
color.primary
color.secondary
border
patternMap
patternMap_sampler
RoadPosition name=
*** no name ***
 index=
 travelDir=
VenueWallShadowShader
WallShadow
wall.direction
dataType
TC,N,V_dataType
T@"NSString",&,N,V_text
relatedText
T@"NSString",&,N,V_relatedText
dataValue
TI,N,V_dataValue
imageCenter
T{CGPoint=dd},N,V_imageCenter
fallbackImageKeys
T@"NSArray",&,N,V_fallbackImageKeys
keyType
TI,R,N,V_keyType
imageName
T@"NSString",R,N,V_imageName
TI,R,N,V_shieldType
shieldTextLocale
T@"NSString",R,N,V_shieldTextLocale
transitLineColor
iconAttributeKey
TI,R,N,V_iconAttributeKey
iconAttributeValue
TI,R,N,V_iconAttributeValue
hasDataValue
TB,R,N,V_hasDataValue
VKCameraRegionRestrictionMapRegion
empty
TB,R,N,GisEmpty,V_empty
T@"GEOMapRegion",R,&,N,V_mapRegion
Text %@
  font size=%.1f(resolved=%.1f)
  halo sz=%.2f clr=(%u,%u,%u,%u)
TextLabelPart
Label Text Font Size
Halo Size
SpecularBuildingShader
Assets
VKTestIdentifiedMapDataRequesterDomain
CurvedText
  positioningMode:%s position:%s
CurvedTextLabelPart
Positioning Mode
Road Offset
Road Width
Label Text Direction
Screen
Cardinal
CardinalExact
AutoOffset
FeatureNormal
ScreenExact
TransitLineOffset
RouteOffset
Normal
Reversed
HorizontalText
  text alpha: %.2f
  line wrapping %@: %i%@
logograms
chars
(Default)
HorizontalTextLabelPart
Text Alpha
Use Logogram Wrapping
Line Wrap Length
BuildingFlatShader
building.color
building.origin
building.size
SolidRibbonShader
DEFAULT
BACKGROUND_MASK
BORDER_MASK
FlyoverRouteShader
split
greater
alphaThreshold
vertexInput_fraction
style.secondary
style.split
style.greater
style.alphaThreshold
fraction
genericShield
T@"NSMutableArray",&,N,V_textureAtlas
genericShields
T@"NSMutableArray",&,N,V_genericShields
shouldUpdateStyle
TB,N,V_shouldUpdateStyle
worldPoint
T{Matrix<double, 3, 1>=[3d]},N,V_worldPoint
location
T{?=dd},N,V_location
trafficFeatureType
Tq,R,N,V_trafficFeatureType
uniqueIdentifier
T@"NSString",R,N,V_uniqueIdentifier
groupIdentifier
Ti,R,N,V_groupIdentifier
T@"GEOLatLng",C,N,V_position
Tf,N,V_minZoom
Tf,N,V_maxZoom
labelState
Tq,N,V_state
approachingRouteOffset
T{PolylineCoordinate=If},N,V_approachingRouteOffset
approachingDistanceInMeters
Td,R,N,V_approachingDistanceInMeters
TI,R,N,V_priority
isGrouped
JpegJITUpload
SkyBox
GlobeSurface
Globe
GlobeBlend
RoadsFill
RoadsStroke
Borders
RoadsClear
Routes
RoutesClear
Traffic
TrafficClear
OverlaysBeneath
Labels
OverlaysAbove
NavigationPuck
Debug
<Invalid>
FlyoverRoadStrokeTexturedShader
triggers
flyovertour
tourid
usesplines
source
/SkyMesh
/SkyIndexData
numberOfLines
leftCapWidth
rightCapWidth
leftPadding
rightPadding
hasNumberOfLines
TI,N,V_numberOfLines
T^{?=IfIIi{?=b1b1b1b1b1}},R,N
hasLeftCapWidth
Tf,N,V_leftCapWidth
hasRightCapWidth
Tf,N,V_rightCapWidth
hasLeftPadding
Tf,N,V_leftPadding
hasRightPadding
Tf,N,V_rightPadding
FlyoverOverlayShader
offsetfactor
sharedConstants.offsetfactor
overlay_sampler
/VertexData
VKMapViewMunin
flyoverContainer
T{weak_ptr<md::GlobeOverlayContainer>=^{GlobeOverlayContainer}^{__shared_weak_count}},N
standardContainer
T{weak_ptr<md::OverlayContainer>=^{OverlayContainer}^{__shared_weak_count}},N
T^{RunLoopController=^{MapEngine}qq},N,V_runLoopController
T@"<VKOverlayDelegate>",N,V_delegate
canProvideVectorData
TB,R,V_canProvideVectorData
replaceMapContentInRect
T{?={?=dd}{?=dd}},N,V_replaceMapContentInRect
TQ,N,V_level
TI,R,N,V_identifier
ext:{%@}
  Point:
  MinZoomRank:
 TransitMinZoomRank:
 [text]
 [placement]
<none>
 clientAlternates:
 [element] Z:
 text:
 placement:
 [style]
 <icon>
 style:
 textSource:
 size:
 scale:
 MSrcKey:
 srcKey:
 name:
  <text> source:
 shieldThreshold:
 icon-size:
Basic
POICircle
POISmall_DEPRECATED
POISquare
POIRectangle_DEPRECATED
Landmark
TransitPill
MultiPOI
POIBalloon
VenueButton
Main
TransitLine
TransitSystem
TextAnnotation
GraphicAnnotation
Image
PolygonFillShader
Fill
fill.worldTransform
fill.color
fill.scale
fill.origin
fill.size
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/src/MuninMetadataResourceDecoder.mm
/View
ArrowLabelPart
Arrow
%3.6f
T{FeatureAttributeSet={vector<gss::FeatureAttributePair, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >=^{FeatureAttributePair}^{FeatureAttributePair}{__compressed_pair<gss::FeatureAttributePair *, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >=^{FeatureAttributePair}{StdAllocator<gss::FeatureAttributePair, gss::Allocator>=^{Allocator}}}}},R,N
strokeMeshes
T^{vector<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >=^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >=^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}}},R,N
sourceTexture
targetTexture
sourceRoofTexture
targetRoofTexture
TileBaseSurfaceShader
tcScale
tcOffset
tcLimit
levelFade
vertexInput_texcoord2
element.tcScale
element.tcOffset
element.tcLimit
sharedConstants.levelFade
sharedConstants.lineColor
sharedConstants.backgroundColor
sharedConstants.majorSize
sharedConstants.minorSize
sharedConstants.lineParams
Map Engine Configuration
Renderer Type
World Type
Cartographic
VSLibrary
VSView::view_vertex
VSView::view_stretch_alpha_fragment
VSView::view_fragment
Blur::basic_vertex
Blur::blur_y5_s1_fragment
Blur::blur_x5_s1_fragment
Blur::shrink_blur_4x_fragment
VSTextured::textured_vertex
VSTextured::passthrough_fragment
VSTextured::compositing_fragment
VSSprite::sprite_vertex
VSSprite::sprite_sdf_alpha_fragment
No Road Positions
Road Positions:
    [
Road Pos 
    
UNKNOWN
RouteLineShader
PatternedRouteLineShader
travelledColor
inverseBaseColor
alphaScale
alphaTest
alphaComp
style.travelledColor
style.inverseBaseColor
style.alphaScale
style.alphaTest
style.alphaComp
routeStyle.halfWidth
routeStyle.color
routeStyle.splitLength
routeStyle.travelledColor
routeStyle.inverseBaseColor
routeStyle.alphaScale
routeStyle.alphaTest
routeStyle.alphaComp
routeStyle
(pages=
 txts=
 area=
 usage%=
 area(
RouteLineArrowShader
currentArrowIndex
highlightedFillColor
highlightedStrokeColor
hightlightedHalfWidth
vertexInput_arrowIndex
style.currentArrowIndex
style.fillColor
style.highlightedFillColor
style.highlightedStrokeColor
style.hightlightedHalfWidth
alphaTextureSampler
alphaTextureSampler_sampler
arrowIndex
TransitNodeQuadIndexData
TransitNodePillIndexData
TransitNodeMesh
Shield(%s)
  %s
ShieldIconLabelPart
Shield Text
/VertexData
atlasSize
halfScreenSize
secondarycolor
PointIcon
, multiPOI(%u)
, multiPOI-fallback
SolidLineShader
/VertexData
Venue footprint mesh
Venue footprint vertex data
Venue footprint index data
T@"VKLabelNavRoadLabel",R,N,V_etaLabel
etaComparisonToMain
T@"VKRouteInfo",&,N,V_routeInfo
displayEtaDescription
T@"VKRouteEtaDescription",R,N,V_displayEtaDescription
isRepositioning
TB,N,V_isRepositioning
TrafficIncident
Stencil Invert
Stencil Erase Water
Coastline Stencile
Shadowed Stroke
MultipleIcons, %@
<Display connection>
  Attrs:{%@}
CaptionedIcon
  textDisplayClass: %s%s
 (optional text is hidden)
  text collision alpha: %.2f
 (persisted opt text collided)
  layout style:%s
  icon margins[L:%.1f R:%.1f T:%.1f B:%.1f DiagV:%.1f DiagH:%.1f]
  [style] placement:(%s)
 alternates:[%s]
(data placement disabled)
  [placement] resolved:%s default:%s snapToDef(can:%i should:%i)
    alternates:<%s>
CaptionedIconLabelPart
Text Display Mode
Feature Text Display Mode
Hide Text Part
Text Collision Alpha
Layout Style
IconPart
Margin Left
Margin Right
Margin Top
Margin Bottom
Margin Diagonal Vertical
Margin Diagonal Horizontal
TextPart
Label Placement
Alternate Position
Resolved Placement
Default Placement
FlyoverButton
IconWithText
IconWithTextAndAnnotation
IconWithTextAndGraphicAnnotation
IconWithTextAndFlyoverButton
none
PolygonAnimatableFillShader
variantColor
fill.variantColor
variantTextureSampler
variantTextureSampler_sampler
circle index data
circle vertex data
CircleUnitQuad
CircleOverlayFill
B16@?0r^{C3mmRoot={C3mmKey=IIII}Ii}8
floorOrdinals
shortFloorNames
floorNames
debug
_cachedEncoder.renderCommandEncoder == nullptr
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoGL/GeoGL/MetalRenderer.mm
v16@?0@"<MTLCommandBuffer>"8
clearquad_verts
clearquad_idx
clearmesh
clearItem
GeoGL
TextureRectShader
/VertexData
view
TextureVBO
ColoredTextShader
/VertexData
vertexInput_outlinecolor
view
outlinecolor
debug texture mesh
debug text mesh
com.apple.VectorKit.GeoGL
ClearDepthStencilShader
ClearShader
clearConstants.color
clearConstants.depth
clearConstants
contentsScale
hidden
contents
Layer backing
Unable to allocate render buffer storage! %p
renderDelegate
T@"<GGLLayerDelegate>"
backingSize
backingFormat
Ti,R
T{CGSize=dd},R,N,V_backingSize
T^{Texture=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiII},R,N
T@"<GGLLayerDelegate>",V_delegate
CommonLibrary
Clear::clear_vertex
Clear::clear_depth_stencil_fragment
Clear::clear_fragment
Clear::clear_vertex_mrt
Clear::clear_fragment2
Clear::clear_fragment3
Clear::clear_fragment4
ColoredText::coloredText_vertex
ColoredText::coloredText_fragment
ShadedColor::shadedColor_vertex
ShadedColor::shadedColor_fragment
TextureRect::textureRect_vertex
TextureRect::textureRect_fragment
Resource Destruction Queue
VectorKit received null buffer from Metal
VectorKit received null texture from Metal
PSO error: %@
error creating compute CPS: %@
Compiler error: %@
depth
ClearConstants
ClearData
ShadedColorShader
eyelightdir
Props
global.view
global.projection
props.color
props.eyelightdir
props.scale
props.modelview
global
props
Clear2Shader
Clear3Shader
Clear4Shader
clearConstants
#version
#extension
#define %s %s
Global
P3NVbo
%.2fms
%lld
<1%%
%lld%%
GeoGL
VectorKit
Flyover
CPU Render Time
Num render items
Num draw calls
Num primitives
Num shader changes
Num texture uploads
Flushed buf mem
Flushed buffers
Texture Upload Time
Buffer Upload Time
GPU Frame Latency 0
GPU Frame Latency 1
GPU Frame Latency 2
Layout labels
Layout roads
Layout map
Layout polygon
Layout transit
Num glyphs created
Glyphs per frame
Tour Slow Down
Grid tile fraction
Non complete tiles
Active Effects
Nil drawable for layer %@
v16@?0@"<CAMetalDrawable>"8
sRGB
TB,R,N,V_sRGB
com.apple.MapKit
com.apple.VectorKit.GeoCSS
StyleSheet
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoCSS/GeoCSS/StylePropertySet.cpp
Dash pattern had strange number of bits.
Could not read dash gap.
Could not read indication of traffic visibility existing.
Could not read traffic visibility.
Could not read indication of traffic fill color existing.
Could not read traffic fill color.
Could not read indication of traffic secondary color existing.
Could not read traffic secondary color.
Could not read indication of traffic pill middle length existing.
Could not read traffic pill middle length.
Could not read indication of traffic pill spacing existing.
Could not read traffic pill spacing.
Could not read indication of traffic secondary width existing.
Could not read traffic secondary width.
Could not read indication of traffic width existing.
Could not read traffic width.
Could not read indication of traffic min width existing.
Could not read traffic min width.
Could not read indication of traffic secondary min width existing.
Could not read traffic secondary min width.
Could not read indication of traffic max width existing.
Could not read traffic max width.
Could not read indication of traffic secondary max width existing.
Could not read traffic secondary max width.
Could not read indication of label height existing.
Could not read label height.
Could not read indication of label height curve existing.
Could not read label height curve.
Could not read indication of label height curve limit existing.
Could not read label height curve limit.
Could not read indication of label halo size existing.
Could not read label halo size.
Could not read indication of label font expansion existing.
Could not read label font expansion.
Could not read indication of label spacing existing.
Could not read label spacing.
Could not read indication of arrow height existing.
Could not read arrow height.
Found boolean property with strange bit count.
Could not read boolean property.
Found RGBA color with strange bit count.
Could not read RGBA color.
Found float with strange number of bits.
Could not read float.
Could not read uint backing for enum.
Unexpected enum value, perhaps this stylesheet uses values that are too new for this client?
 STYL Parse Warning: 
Found unsigned integer property with too few bits.
Could not read unsigned integer.
Could not read string.
String property was an unexpected length.
Found int32 property with strange number of bits.
Could not read int32.
Found float pair property with strange number of bits.
Could not read first half of float pair.
Could not read second half of float pair.
Found uint64 property with a strange number of bits.
Could not read uint64 property
Found color gradient with strange number of bits.
Could not read first half of color gradient.
Could not read second half of color gradient.
Found fixed point 0 to 1 property with strange number of bits.
Could not read fixed point 0 to 1.
Found fixed point 8.8 property with strange number of bits.
Could not read fixed point 8.8.
Found fixed point 12.4 property with strange number of bits.
Could not read fixed point 12.4.
Found fixed point 5.3 property with strange number of bits.
Could not read fixed point 5.3.
Found fixed point 0 to 2.55 property with strange number of bits.
Could not read fixed point 0 to 2.55.
Found fixed point 6.2 property with strange number of bits.
Could not read fixed point 6.2.
Found fixed point 8.0 property with strange number of bits.
Could not read fixed point 8.0.
Found -180
 - 180
 property with too few bits.
Could not read -180
 - 180
 angle.
Found 0
 - 90
 property with too few bits.
Could not read 0
 - 90
 angle.
Found uint8 property with strange number of bits.
Could not read uint8.
Found 0
 - 180
 property with too few bits.
Could not read 0
 - 180
 angle.
Found int16 property with strange number of bits.
Could not read int16.
Found fixed point -1 to 1 property with strange number of bits.
Could not read fixed point -1 to 1.
GeoCSS
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoCSS/GeoCSS/GlobalProperties.cpp
Could not read indication of raster polygon changeover z existing.
Could not read raster polygon changeover z.
Could not read indication of min triangle width existing.
Could not read min line triangle width.
Could not read indication of building changeover z existing.
Could not read building changeover z.
Could not read indication of min traffic type (unknown) z existing.
Could not read min traffic type (unknown) z.
Could not read indication of min traffic type (accident) z existing.
Could not read min traffic type (accident) z.
Could not read indication of min traffic type (construction) z existing.
Could not read min traffic type (construction) z.
Could not read indication of min traffic type (road closure) z existing.
Could not read min traffic type (road closure) z.
Could not read indication of min traffic type (event) z existing.
Could not read min traffic type (event) z.
Could not read indication of min traffic type (hazard) z existing.
Could not read min traffic type (hazard) z.
Could not read indication of min traffic type (lane closure) z existing.
Could not read min traffic type (lane closure) z.
Could not read indication of min traffic type (ramp closure) z existing.
Could not read min traffic type (ramp closure) z.
Could not read indication of realistic night brightness existing.
Could not read realistic night brightness.
Could not read indication of shield night brightness existing.
Could not read shield night brightness.
Could not read indication of realistic shield night brightness existing.
Could not read realistic shieldnight brightness.
Could not read indication of background rasters zoom range existing.
Could not read background rasters min zoom.
Could not read background rasters max zoom.
Could not read indication of standard rasters zoom range existing.
Could not read standard rasters min zoom.
Could not read standard rasters max zoom.
Could not read indication of satellite rasters zoom range existing.
Could not read satellite rasters min zoom.
Could not read satellite rasters max zoom.
Could not read indication of hybrid rasters zoom range existing.
Could not read hybrid rasters min zoom.
Could not read hybrid rasters max zoom.
Could not read indication of ground cover zoom range existing.
Could not read ground cover min zoom.
Could not read ground cover max zoom.
Could not read indication of raster traffic zoom range existing.
Could not read raster traffic min zoom.
Could not read raster traffic max zoom.
Could not read indication of vector polygons zoom range existing.
Could not read vector polygons min zoom.
Could not read vector polygons max zoom.
Could not read indication of vector roads zoom range existing.
Could not read vector roads min zoom.
Could not read vector roads max zoom.
Could not read indication of vector land cover zoom range existing.
Could not read vector land cover min zoom.
Could not read vector land cover max zoom.
Could not read indication of vector buildings zoom range existing.
Could not read vector buildings min zoom.
Could not read vector buildings max zoom.
Could not read indication of vector PoIs zoom range existing.
Could not read vector PoIs min zoom.
Could not read vector PoIs max zoom.
Could not read indication of vector traffic zoom range existing.
Could not read vector traffic min zoom.
Could not read vector traffic max zoom.
Could not read indication of tile limit satellite scale existing.
Could not read tile limit satellite scale.
Could not read indication of global LoD scale existing.
Could not read global LoD scale.
Could not read indication of LoD offset existing.
Could not read LoD offset.
Could not read indication of label icon scale existing.
Could not read label icon scale.
Could not read indication of nav label road sign height existing.
Could not read nav label road sign height.
Could not read indication of nav label road sign height (small) existing.
Could not read nav label road sign height (small).
Could not read indication of nav label road sign height (medium) existing.
Could not read nav label road sign height (medium).
Could not read indication of nav label road sign height (large) existing.
Could not read nav label road sign height (large).
Could not read indication of nav label road sign height (extra large) existing.
Could not read nav label road sign height (extra large).
Could not read indication of nav label road sign height (extra extra large) existing.
Could not read nav label road sign height (extra extra large).
Could not read indication of nav label max road signs existing.
Could not read nav label max road signs.
Could not read label disable alternate text positions.
Could not read indication of min traffic type (traffic) z existing.
Could not read min traffic type (traffic) z.
Could not read indication of maneuver distance (immediate) existing.
Could not read maneuver distance (immediate).
Could not read indication of maneuver distance (extremely near) existing.
Could not read maneuver distance (extremely near).
Could not read indication of maneuver distance (very near) existing.
Could not read maneuver distance (very near).
Could not read indication of maneuver distance (near) existing.
Could not read maneuver distance (near).
Could not read indication of maneuver distance (medium) existing.
Could not read maneuver distance (medium).
Could not read indication of maneuver distance (far) existing.
Could not read maneuver distance (far).
Could not read indication of maneuver distance (very far) existing.
Could not read maneuver distance (very far).
Could not read indication of nav map zoom level transition z existing.
Could not read nav map zoom level transition z.
Could not read suppress oppositie carriageway signs.
Could not read indication of vector venue zoom range existing.
Could not read building shadow color existing.
Could not read building shadow red
Could not read building shadow green
Could not read building shadow blue
Could not read building shadow alpha
Could not read venue dimming factor existing.
Could not read venue dimming factor
Could not read value standard map zoom level transition z existing.
Could not read standard map zoom level transition z.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoCSS/GeoCSS/StylFile.cpp
This is not a styl file - it's too short.
This is not a styl file - the magic is missing.
Could not read chapter count.
Could not read chapter id.
Could not read chapter start byte offset.
Could not read chapter end byte offset.
Could not read chapter uncompressed length.
!GRL_UNIQUE_NAME(didTriggerAssert)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp
Number of Icons: 
%s : Parse Error Here: - %s : Failed in file - %s line - %i
Failed to decode Pack Header
decodeHeader(packStream, headerName, chapterDataPositions)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp
Magic code is wrong
headerName[0] == 'I' && headerName[1] == 'C' && headerName[2] == 'O' && headerName[3] == 'N' && headerName[4] == 'C' && headerName[5] == 'O' && headerName[6] == 'N' && headerName[7] == 'F' && headerName[8] == 'I' && headerName[9] == 'G' && headerName[10] == 'P' && headerName[11] == 'A' && headerName[12] == 'C' && headerName[13] == 'K'
Could not decode Chapter Data
decodeChapterData(packStream, chapterPair.second, chapterData)
Could not decode Pack Info Chapter
decodePackInfo(chapterData, _packDataContext)
Could not decode Property Info Chapter
decodePropertyInfo(chapterData, _packDataContext)
Could not decode Icon Info Chapter
decodeIconDataLocations(chapterData, _packDataContext)
decodeChapterData(packStream, chapterIter->second, chapterData)
Could not decode Icon Data Chapter
decodeIconDataLocations_DEPRECATED(chapterData, _packDataContext)
decodeIconDataData_DEPRECATED(chapterData, _packDataContext)
Failed to decode property context
PropertySet::decodePropertyContext(byteData, context.propertyContext)
Number of Icons could not be read
numberOfIcons.has_value()
Icon Key Size could not be read
iconKeySize.has_value()
Icon Data Size could not be read
iconDataSize.has_value()
Icon Data could not be decoded
iconData->decode(stream.currentByte(), iconDataSize.value(), context.propertyContext)
Number Of Data Locations could not be read
numberOfDataLocations.has_value()
Size Group could not be read
sizeGroupRaw.has_value()
Variant could not be read
variant.has_value()
Byte Position could not be read
bytePosition.has_value()
Failed to decode Icon Data Chapter
decodeChapterData(_packStream, _packStreamIconDataStart, chapterData)
Failed to read Icon Data Chapter Size
decodeChapterSize(_packStream, _packStreamIconDataStart + locationIter->second + sizeSkip, rawSize, compressedSize)
Failed to read compressed Icon Data Chapter
decodePackChunk(_packStream, _packStreamIconDataStart + locationIter->second + (sizeSkip * 2), compressedSize, chapterData)
com.apple.VectorKit.GeoResourceLib
IconManager
Codec
Font
Metrics
Math
Easel
CoreFoundation
CoreGraphics
Normal
Multiply
Screen
Overlay
Darken
Lighten
ColorDodge
ColorBurn
SoftLight
HardLight
Difference
Exclusion
Saturation
Color
Luminosity
Clear
Copy
SourceIn
SourceOut
SourceAtop
DestinationOver
DestinationIn
DestinationOut
DestinationAtop
PlusDarker
PlusLighter
%s : Parse Error Here: - %s : Failed in file - %s line - %i
ID could not be read
id.has_value()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/IconKey.cpp
Variant could not be read
variant.has_value()
Size Group could not be read
sizeGroupRaw.has_value()
icon
font
texture
style
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/IconRenderer.cpp
, size: (
, isStretched: 
, contentScale: 
, layer count: 
, layers: [
, infoLayerData: [
fillColor: 
, fillColorSource: 
, fontName: 
, fontSize: 
, haloColor: 
, haloWeight: 
, horizontalPadding: 
, nonDigitTextColor: 
, nonDigitTextFontName: 
, nonDigitTextFontSize: 
, nonDigitTextHaloColor: 
, nonDigitTextHaloWeight: 
, shadowColor: 
, shadowOffset: 
, shadowWeight: 
, text: 
, textPosition: 
, visible: 
Property Type Count could not be read
numPropertyTypes.has_value()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/TextLayerData_Generated.cpp
Property Type could not be read
propertyTypeValue.has_value()
Property Count could not be read
numPropertiesForType.has_value()
Property Type read from set that wasnt in the Property Info Chapter
decoderMapIter != propertyContext.decoderMap.end()
Property ID could not be read
propertyIDValue.has_value()
1.2.11
%s : Parse Error Here: - %s : Failed in file - %s line - %i
Pack Stream Is Invalid
packStream
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/ResourcePack.cpp
Chapter ID could not be read
chapterID.has_value()
Byte Start could not be read
byteStart.has_value()
Pack Version could not be read
version.has_value()
Region could not be read
region.has_value()
Content Scale could not be read
contentScale.has_value()
Small
Small Medium
Medium
Large
XSmall
XLarge
XXSmall
XXLarge
XXXSmall
XXXLarge
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/PathGenerator.cpp
Circle
Square
IconPack
TransitLine
None
Solid
Gradient
Linear
Radial
Reflected
ThreePart
Color
Path
Image
Text
Info
Rectangle
Balloon
BalloonWithDot
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/IconEnums.cpp
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp
iconSize == gm::Vector2f::zero() || layerMetrics->size() == iconSize
result.second
alternateImageFamily: 
, alternateImageTextLimit: 
, calloutFillColor: 
, calloutHaloColor: 
, calloutShape: 
, calloutTextColor: 
, labelTextColor: 
, scale: 
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/InfoLayerData_Generated.cpp
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp
ultralight
light
thin
regular
medium
semibold
bold
heavy
black
italic
condensed
rounded
compact
blendMode: 
, changeHaloAndShadowOrder: 
, cornerRadius: 
, fillColor: 
, fillSize: 
, fillType: 
, gradientAngle: 
, gradientEndColor: 
, gradientEndLocation: 
, gradientStartColor: 
, gradientStartLocation: 
, gradientType: 
, shapeType: 
, tailDirection: 
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/PathLayerData_Generated.cpp
_size != gm::Vector2f::zero()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/TextLayerMetrics.cpp
%s : Parse Error Here: - %s : Failed in file - %s line - %i
numPropertyTypes.has_value()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/PropertySet.cpp
Property Type could not be read
Property Types Count could not be read
type.has_value()
Bytes could not be read
bytes.has_value()
Icon Image Count could not be read
imageCount.has_value()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp
Image Layer Index could not be read
imageLayerIndex.has_value()
Image ID could not be read
imageID.has_value()
Image Size X could not be read
imageSizeX.has_value()
Image Size Y could not be read
imageSizeY.has_value()
Icon Layer Count could not be read
layerCount.has_value()
Layer Type could not be read
layerTypeRaw.has_value()
Layer Index could not be read
layerIndex.has_value()
Layer Length could not be read
layerLength.has_value()
Layer Data could not be read
layerData.has_value()
Path Layer could not be read
_internalLayers.pathLayer->decode(layerData.value(), propertyContext)
Color Layer could not be read
_internalLayers.colorLayer->decode(layerData.value(), propertyContext)
Image Layer could not be read
_internalLayers.imageLayers[layerIndex.value()].decode(layerData.value(), propertyContext)
Text Layer could not be read
_internalLayers.textLayers[layerIndex.value()].decode(layerData.value(), propertyContext)
Information Layer could not be read
_internalLayers.infoLayer->decode(layerData.value(), propertyContext)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/ColorLayerData_Generated.cpp
data
config
iconconfigpack
icondatapack
iconmappack
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/FontManager.cpp
result
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/CoreGraphicsUtilities.cpp
Number of Key Value Pairs: 
Number of Names: 
Number of Data Identifiers: 
Number of Data Text Values: 
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp
headerName[0] == 'I' && headerName[1] == 'C' && headerName[2] == 'O' && headerName[3] == 'N' && headerName[4] == 'M' && headerName[5] == 'A' && headerName[6] == 'P' && headerName[7] == 'P' && headerName[8] == 'A' && headerName[9] == 'C' && headerName[10] == 'K'
Could not decode Pack Info chapter
decodePackInfo(chapterData, context)
Could not decode Icon ID chapter
decodeIconIDMapping(chapterData, context)
Could not decode Region Name chapter
decodeRegionMapping(chapterData, context)
Could not decode Fallback chapter
decodeFallbackMapping(chapterData, context)
decodeRegionMapping_DEPRECATED(chapterData, context)
Map Count could not be read
mapCount.has_value()
Key could not be read
key.has_value()
Value could not be read
value.has_value()
Identifier could not be read
identifer.has_value()
nameMapCount.has_value()
Name could not be read
name.has_value()
Data Count could not be read
dataMapCount.has_value()
Data ID could not be read
dataID.has_value()
Text Data Count could not be read
textDataMapCount.has_value()
Text Map Count could not be read
textMapCount.has_value()
Text could not be read
text.has_value()
identifier.has_value()
Count could not be read
defaultRegionCount.has_value()
regionName.has_value()
Number of Regions to Icon ID could not be read
numberOfIconIDToRegions.has_value()
Icon ID could not be read
iconID.has_value()
Number of Regions could not be read
numberOfRegions.has_value()
Region ID could not be read
regionID.has_value()
Number of Regions to Country Code could not be read
numberOfCountryCodeToRegions.has_value()
Country Code could not be read
countryCode.has_value()
Region Name could not be read
regionCount.has_value()
Tile X Min could not be read
tileXMin.has_value()
Tile Z could not be read
tileZ.has_value()
keyFallbackCount.has_value()
dataFallbackCount.has_value()
Min could not be read
min.has_value()
Max could not be read
max.has_value()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/HaloGenerator.cpp
Number of Atlas Images: 
decodeHeader(_packStream, headerName, chapterDataPositions)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/IconDataPack.cpp
headerName[0] == 'I' && headerName[1] == 'C' && headerName[2] == 'O' && headerName[3] == 'N' && headerName[4] == 'D' && headerName[5] == 'A' && headerName[6] == 'T' && headerName[7] == 'A' && headerName[8] == 'P' && headerName[9] == 'A' && headerName[10] == 'C' && headerName[11] == 'K'
decodeChapterData(_packStream, chapterPair.second, chapterData)
Could not decode Image Info Chapter
decodeImageInfo(chapterData, context)
decodeChapterSize(_packStream, chapterPair.second, rawSize, compressedSize)
Atlases can't be compressed. This allows each one to individualy be read from disk.
compressedSize == 0
Number of Images could not be read
numImages.has_value()
Atlas Index could not be read
atlasIndex.has_value()
Atlas Offset could not be read
atlasOffsetX.has_value()
atlasOffsetY.has_value()
Image Size could not be read
Number of Indices could not be read
numIndices.has_value()
Byte Length could not be read
byteLength.has_value()
, horizontalStretchPadding: 
, imageStretchType: 
, verticalPadding: 
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/Codec/ImageLayerData_Generated.cpp
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/IconImage.cpp
_data.shapeType() != ShapeType::Balloon
/BuildRoot/Library/Caches/com.apple.xbs/Sources/VectorKit_Sim/VectorKit-1606.31.8.28.12/geo/GeoResourceLib/GeoResourceLib/LayerRenderer.cpp
_data.hasLayerStyles()
iconLayer != LayerStyle::None
fillPath
context
path
weight <= 0.0f
fontIt != fonts.end() && fontIt->second.get()
nonDigitFontIt != fonts.end() && nonDigitFontIt->second.get()
No A3D data provided
A3D appears to be malformed, there's not enough room for a header
Data does not appear to be A3D format.
A3D contains incorrect version for parser.
A3D appears to be malformed, it claims its vertices end after more than SIZE_MAX bytes.
A3D appears to be malformed, there aren't enough bytes for all its vertices.
A3D appears to be malformed, there aren't enough bytes for the sub-mesh headers.
A3D appears to be malformed, it claims one of its mesh index sets ends after more than SIZE_MAX bytes.
A3D appears to be malformed, there aren't enough bytes for all its sub mesh indices.
A3D appears to be malformed, it claims one of its textures ends after more than SIZE_MAX bytes.
A3D appears to be malformed, there aren't enough bytes for one of its textures.
A3D appears to be malformed, it claims its metadata headers end after more than SIZE_MAX bytes.
A3D appears to be malformed, there aren't enough bytes for its metadata headers.
A3D appears to be malformed, there aren't enough bytes for its metadata.
MC_CHUNK_MESH
MC_CHUNK_FACES
MC_CHUNK_VERTICES
MC_CHUNK_UV
MC_CHUNK_EB_CONNECTIVITY
MC_CHUNK_EB_VERTICES
MC_CHUNK_EB_FACE_ATTRIBUTES
MC_CHUNK_EB_UV
MC_CHUNK_EB_VERTICES_CUBE
MC_CHUNK_EB_VERTICES_CAM
MC_CHUNK_UV_MODEL
MC_CHUNK_POSTPROCESS
MC_CHUNK_END_OF_CHUNKS
UNKNOWN CHUNK TYPE
/BuildRoot/Library/Caches/com.apple.xbs/Sources/GeoServices_Sim/GeoServices-1624.31.8.28.18/geo/GeoCodecs/GeoCodecs/mcodec/mesh/mc_mesh_codec.c
mc_io_r_mc_mesh
Found unknown chunk %d, v%d.%d
Failed when parsing chunk of type %s (%d, v%d.%d)
 kt:
Resource Key
Resouce Type
Key Type
Priority
Layer Data Source
Requests
Count
Pending Creation
Has All Resources
Last Requested
Tracking Id
RequiredResources
OptionalResources
Requests with Failed Resources
Requests that Failed to Decode
Pending Cancelled Requests
LayerDataRequestKey<Type:
, Data: 
<null>
Resource
OriginalLoadReason
Source
CreatedTimestamp
LastTimestamp
TimeToLive
RequestId
Flat Tile Selector
Lod Bias
Desired Tile Area
Resources
Failed Resources
Error
Code
Domain
Layer Data
Download Zoom Range
Tile Size
Resource Types
Stores
Store 
DecodeTime
Bytes
Total
Resource Manager
RequestsInProgress
FailedRequests
Cancelled Requests
Fetchers
Fetcher 
ResourceStores
Resource Status Container
ActiveResourceKeys
RefCount
Initial
Loading
Cancelled
Consistent Z Tile Selector
Layer Data Key
Data Type
Value
->min
->max
->avg
->sum
->count
 kt:
Layer Data Key
Request Type
Trying to add child tile but slot already occupied: %u %u %u %u
No child slot match this tile: %s
Trying to remove child that is not a child: %s
Unsupported LodMode.
Resetting memory allocators
RenderLayerLayout
Updating selected polyline:%@
RouteOverlayLogic
Setting lod scale to: %f
Read/write lock %s resulted in non-zero value %d
Failed to convert image from: %d to %d
Tried to convert image without base data.
Unable to convert to %d
Unsupported pixel format: %d
GridLayout
Unknown DTM format
Set application state: %@, displayed serach results type: %@
Set label marker selection enabled: %s
Set target display: %@
Set vehicle state parked: %s
Set emphasis: %@
Set application UI layout: %@
Set trafficEnabled: %s
Set traffic incidents enabled: %s
Set display rate: %ld
Set navigation display rate: %ld
Will enter foreground
Did enter background
Did finish suspension snapshot
Set stays centered durning pitch: %s
Set localized labels: %s
Set label scale factor: %ld
Set stays centered durning rotation: %s
Set is pitchable: %s
Set hidden: %s
Visible
Set host display: %p
Set should load fallback tiles display: %s
Set should load map margin: %s
Set gesturing: %s
Gesturing
Set icons should align to pixels: %s
Set shield size: %ld
Set navigation shield size: %ld
Set shield idiom: %ld
Set show road labels: %s
Set show point labels: %s
Set shows points of interest: %s
Set shows buildings: %s
Set shows venues: %s
Set dimming base map: %s, animated: %s, duration: %f
Set desired map mode: %@
Set sky height: %f
Set map type: %@, animated: %s
Set bounds, size(%f, %f), origin: (%f, %f)
Set center coodinate: (%f, %f), altitude: %f, yaw: %f, pitch: %f, duration: %f
Set allow dateline wraparound: %s
Creating map view(%p), shouldRasterize: %s, inBackground: %s, contentScale: %f
Foreground
Destorying map view(%p)
Set contents scale: %f
Set yaw: %f, animated: %s
Set map region: %@, pitch: %f, yaw: %f
Set map region: %@, pitch: %f, yaw: %f, animation duration: %f
Set edge insets: top: %f, bottom: %f, left: %f, right: %f
Set fully occluded edge insets: top: %f, bottom: %f, left: %f, right: %f
Set label edge insets: top: %f, bottom: %f, left: %f, right: %f
Set camera framing edge insets: top: %f, bottom: %f, left: %f, right: %f
No scene logic found
Scene logic has no context
Stop tracking
Pause tracking
Navigation return to puck
Transition to tracking passed invalid start location!
Set external traffic features - count:%zu, areRouteTrafficFeaturesActive:%s
Set disable transit lines: %s
Select transit line marker: %@
Deselect transit line marker
Select feature id: %llu
Deselect feature id
Select venue poi feature id: %llu
Deselect venue poi feature
Enter 3d mode
Exit 3d mode
Set tracking zoom scale: %f
Adding route overlay: %@
Removing route overlay: %@
Adding persistent route overlay: %@
Removing persistent route overlay: %@
Setting focused labels polyline: %@
Junction didChange:%@ currentRoad:%@
Set requested display rate: %ld
Set renders in background: %s
Set horizontal offset: %f, duration: %f
CreateVKMapView
CoastlineLayout
NavGraph: No path found from start to the target point.
C3m Block size too large
C3m invalid block type
C3m - reserved material type
C3m - unsupported material type
Failed to read C3m file - %s
This decoder does not currently support scene graphs.
Missing loader! Unable to fetch request %u %u %u
Failed to load %u %u %u
Failed to load file %s
Error reading meta data loaded from %u %u %u
Failed to load file %u %u %u
Should not wait indefinitely on job: %u
Missing input node: %s
Unknown meta file extension: %s
Failed to get height field altitude bounds for tile %u %u %u
Failed to load height bounds for tile %u %u %u
Failed to load hires texture for tile %u %u %u
Failed to load traffic data for tile %u %u %u
Failed to load label data for tile %u %u %u
Got no actor when loading height mesh for tile %u %u %u
Failed to load height map for tile  %u %u %u
Got no actor when loading c3m mesh for tile %u %u %u
Inavlidating geometry for %u %u %u
Got no actor when loading base surface for tile %u %u %u
Failed to load base surface for tile %u %u %u
Failed to load road data for tile %u %u %u
Got no actor when loading height fallback data for tile %u %u %u
Failed to load height fallback data for tile %u %u %u
LabelLayout
buildRoadTileData: Received point characteristic out of order in tile %s, featureIndex %d, sectionIndex %d
invalid VectorKitConfig_ requested identifier %u
Create World:%p
Destroy World:%p
~World clear data sources
~World layerDataManager reset
InitWorld
Min visible zoom: %d
SceneLogic
Layer %s wants grid size %d for tile selection set: %s
Layer %s wants grid size %d. This is probably a bug!
Layer: %s Tile Adjust: %f, Download: %d, %d, Visible: %d, %d
Failed to mipmap image %d %d %d
Failed to download image %d %d %d %d
Trying to page non JPEG data: %d %d %d %d
Failed to decode image %d %d %d %d
Missing input! Unable to fetch request %d %d %d %d | %d | %d | %d | %d | %d | %d
Register Handler for %@ State Capture
got called os_state_add_handler
Unregister Handler for %@ State Capture
%@ State Capture Begin
Error serializing dictionary for State Capture: %@
Error os_state_data nil
LabelsNavLayout
DTM header verification failed.
DTM header bits per pixel mismatch with PNG Data
LabelsLogic
Missing node, can not load meta data!
LabelsTileDecode
RouteLayout
%s:%d STYL Parse Error Here: %{public}s
Failed to load DTM: %u %u %u
Unhandled tile style found: %d
Missing latitude in trigger specification
Missing longitude in trigger specification
Missing radius in trigger specification
Missing altitude in trigger specification
Missing region in trigger specification
Missing version in trigger specification
Malformed trigger tag in xml: missing data node
Malformed trigger tag in xml: missing shape node
Malformed trigger tag in xml: missing c3meshdata node
No data type specified for trigger
Invalid data type in trigger specification: %s
No data url specified for trigger
No meta url specified for trigger
Failed to load start level of c3 mesh trigger
No shape type specified in trigger
Missing latitude in sphere shape trigger specification
Missing longitude in sphere shape trigger specification
Missing radius in sphere shape trigger specification
Unknown shape type in trigger
Failed to get fallback dtm with key %u %u %u
Failed to get invalide value fallback dtm with key %u %u %u
DebugLayout
TransitLogic
pointId=%llu buildId=%d bucketId=%d cameraId=%d lod=%d parent_signpost=%llu
ResourceFetch
MuninMeshResourceFetcher received cancelled resource. %llu
MuninMeshResourceFetcher received failed Resource. %llu
parent_signpost=%llu
CreateResource
LegacyTrafficLayout
Failed to add overlay %@. It is already being tracked
Failed to add overlay  %@. It is already being tracked
Added overlay %@ isPersistent:%s overlaysInViewCount:%d persistentOverlaysCount:%d
Failed to removed overlay %@. It is isnt being tracked
Removed overlay %@ isPersistent:%s overlaysInViewCount:%d persistentOverlaysCount:%d
Added polyline %@ to polylineGroupOverlay %@
Removed polyline %@ from polylineGroupOverlay %@
AnchorLogic
VenueLayout
VKPolylineGroupOverlay setShowTraffic: %d
VKPolylineGroupOverlay %p addPolyline | route: %@ | _showTraffic: %d | traffic: %@
VKPolylineGroupOverlay %p removePolyline | route: %@ | _showTraffic: %d | traffic: %@
VKPolylineGroupOverlay %p setSelectedPolyline | route: %@
VKPolylineGroupOverlay %p setFocusedPolyline | route: %@
Skeleton traffic tile %@ implicates bad section (start: %f, end: %f, valid: %lu,%lu, skeleton record: %f,%f)
Skeleton traffic tile %@ implicates flow start/end offsets out of range  start: %f end:%f  section len = %ld
Skeleton traffic tile %@ implicates inverted road offsets: %f->%f 
Skeleton traffic tile implicates bad section (start: %f, end: %f, valid: %lu,%lu, skeleton record: %f,%f)
SettingsLogic
Starting VKPuckAnimator
Stopping VKPuckAnimator
Pausing VKPuckAnimator
Resuming VKPuckAnimator
BuildingLayout
PolygonLayout
LabelsRenderGlyphs
key=%d.%d.%d type=%d parent_signpost=%llu
Unknown tile key
TiledGEOResourceFetcher fetching resource: %s, %llu
TiledGEOResourceFetcher done fetching resource: %s, %llu
TiledGEOResourceFetcher received cancelled resource: %s, %llu
TiledGEOResourceFetcher received failed Resource: %s, %llu
TiledGEOResourceFetcher creating resource: %s, %llu
TiledGEOResourceFetcher done fetching preliminary resource: %s, %llu
TiledGEOResourceFetcher creating preliminary resource: %s, %llu
TiledGEOResourceFetcher canceling resource: %s
TiledGEOResourceFetcher Canceling all resources
VenueLogic
Failed to get height for road points
LightingLogic
C3M3 data block too short
C3M3 invalid header
C3M3 Unknown block type: %d
C3M3: Unknown header type %d
C3M3 LZMA texture decode failed
C3M3 texture won't fit into buffer
C3M3 unsupported image texture extension
C3M3 failed to load image data for image
C3M3 failed to convert image format for PNG image
C3M3 unsupported texture format: %d
C3M3 unsupported image format
Failed to intialize the lzma decoder.
Failed to decode lzma data.
C3M3 mesh data block too short
C3M3 LZMA mesh decode failed
C3M3 uncompressed mesh header data block too short
C3M3 index list not a multiple of 3
C3M3 uncompressed mesh body data block too short
C3M3 index out of bounds
C3M3 Unknown submesh type.
Index pointing outside vertex buffer
Unknown SG type.
Unknown node type; %d size: %d
Failed to load ObjectTree model (region: %u version: %u entity: %u lod: %u)
Register Model Placeholder [%u, %u, %u]->%p
Unregister Model Placeholder [%u, %u, %u]->%p
Destroying zone allocator with %lu allocations still alive
Resetting zone allocator with %lu allocations still alive
BasicAllocationTracker(%s)
Count: %zu
Failed to find metadata key requester: Assertion with expression - %s : Failed in file - %s line - %i
Failed to initialize thread attributes.
Failed to destroy thread attributes.
Failed to join thread. A deadlock was detected or the value of thread specifies the calling thread.
Failed to join thread. The implementation has detected that the value specified by thread does not refer to a joinable thread.
Failed to join thread. No thread could be found corresponding to that specified by the given thread ID, thread.
Tile without geometry in loaded geometry list!
Tile without hires textures in loaded hires textures list!
Tile without road in loaded road list!
Tile without traffic in loaded road list!
Tile without label data in loaded LabelData list!
Tile without fallback in loaded fallback list!
Tile without surface in loaded surface list!
Failed to get memory usage!
OverlaysLogic
Preloading %zu initial points
{"tap_state": {"x": %f, "y": %f, "latitude": %f, "longitude": %f, "yaw": %f, "pitch": %f } }
Path planned, duration %.1fs, points: %zu, views: %zu, %.1f view/point, %.1f view/s
Flagged %zu/%zu points as required (%zu are intermediate), cost: %f, total length: %f
Path has %zu points
%llu (n: %zu, %s)
views(%zu): %s
Completed path animation
Finished loading required views (n: %zu) - start animation
PathPreload
Preloaded %zu views.
OverlayLayout
SkyLogic
Create TaskContext:%p
Destroy TaskContext:%p
flushTileDecodeQueues Start
flushTileDecodeQueues Finish
Create LabelManager:%p
Destroy LabelManager:%p
LabelsAnimationFired
LabelsAnimationQueued
LayoutDisplayLabels
LabelsBgkdLayout
LabelsRender
LabelsTileDecodeStyleFeatures
LabelsStyleFeatures
Mismatching number of indices, indexCount: %zu, triangulatedIndexCount: %zu
Triangulator failed to fully triangulate polygon: %s
Failed to decode traffic skeleton resource for tile(%d.%d.%d) with error code: %d
LabelsCollision
Creating VKMapSnapshotCreator: %p with height:%f width:%f contenteScale:%f
height:%f width:%f contenteScale:%f
MapSnapshotCreator
Deallocating VKMapSnapshotCreator: %p
Dealloc VKMapSnapshotCreator end
Deleting VKMapSnapshotCreator memory: %p
VKMapSnapshotCreator %p setMapType: %ld
VKMapSnapshotCreator: %p setShowsPointsOfInterest: %s
VKMapSnapshotCreator: %p setShowsPointLabels: %s
VKMapSnapshotCreator: %p setShowsBuildings: %s
VKMapSnapshotCreator: %p setShowsVenues: %s
VKMapSnapshotCreator: %p setLabelScaleFactor: %ld
VKMapSnapshotCreator: %p cancel snapshot
Cancel
VKMapSnapshotCreator: %p willBecomeFullyDrawn
VKMapSnapshotCreator didReceiveMemoryWarning: %p
DidReceiveMemoryWarning
VKMapSnapshotCreator: %p failed to render - failed tiles!
VKMapSnapshotCreator: %p failed to fully render
VKMapSnapshotCreator: %p finished rendering snapshot!
GroundLayout
Create MapEngine:%p
Destroy MapEngine:%p
Destroy MapEngine End
RenderLayout
DisplayLinkUnpause
DisplayLinkPause
DisplayLinkSkip
InitMapEngine
RunLogic
LayoutScene
frameTime=%f
FrameDrop
Frame
ApplyConfiguration
RasterLayout
Failed to load Traffic file
Failed to load DTM file
Not recognized as ASTC data %d x %d x %d
ASTC, Invalid block size combination %d x %d
Invalid use: This request was made for altitude bounds only
Invalid use: This request was made for a mesh actor
Failed to create geometry %s
VKPolylineOverlay %p updateTraffic: %@ | %@
StyleLogic
Zip file smaller than the zip header
LabelsRenderIcon
No tile set attached to %s. Culling disabled!
No tile manager attached to %s. Culling disabled!
LabelsGenerateGlyphInfos
LabelsStylesheetDidChange
LabelsStylesheetAnimation
LabelsStylesheetLabelAnimations
Missing texture: '%s'
Missing metadata point for preload view
MuninSceneLogic
Unknown mesh type.
File loader not available for %s
Error creating processing subjob for %u %u %u
C3bLoadJob: Failed to load DTM for %u %u %u
Failed to create node for %u %u %u
GlobeLabelLayout
Loaded sky model: %s
Failed to load sky model: %s
SkyLayout
WaitForPresentable
UpdateFrameTexture
Present
MDDisplayLayer creating new render layer
MDDisplayLayer destroying render layer
SubmitCommands
RoadLayout
Unsupported output format for jpeg loader.
CameraLogic
Failed to load sky model.
Adjustment not applied, invalid depth range, znear = %f zfar = %f
TransitLayout
Failed to create time zone: %s
Unhandled node type: %d fall back to C3M_SG_NODE
Missing texture
PuckLayout
Null style detected: Assertion with expression - %s : Failed in file - %s line - %i
Stroke Z index (%d) in style %s is too large - clamping to 255
Fill Z index (%d) in style %s is too large - clamping to 255
This item is already managed, skipping add: %s
This item already exist in mItems, skipping insert: %s
This item is not added to loader %s
Removing item: %s
Missing input slot! Unable to fetch request %u %u %u
Failed to find key (%s) in string: %s
Nav Camera Started With Pounce but is already tracking
Nav Camera Started With Pounce:%s to lat:%f lon:%f with course:%f
StandardLogic
GridLogic
MuninLogic
C3M3 Error while reading chunk info.
C3M3 Could not create EdgebreakerDecodeTableCache.
Index list must be a multiple of three
Failed do decode submesh.
RoadTile isn't setup correct
Invalid venue building feature id (%llu). Venue id: %llu, building id: %llu, tile key (%u.%u.%u)
Start point same as end point.
Missing tour_region in tour trigger specification
Create LogicManager:%p
Destroy LogicManager:%p
LogicManagerRunLogic
Missing storefront info. Unable to enter munin.
Enter for storefront view
EnterForStorefrontView
Enter for marker
EnterForMarker
MarkerAtPoint
MarkerAtPointSync
Marker at point, got one from metadata
Marker at point, got one from the road network
Marker at point, failed to find a munin marker
Move to storefront view - missing storefront info
Move to storefront view
MoveToStorefrontView
Move to marker - missing collection point
Move to marker
MoveToMarker
Cancel pending move
Set virtual parallax enabled: %s
Invalid point index: Assertion with expression - %s : Failed in file - %s line - %i
Invalid build index for point: Assertion with expression - %s : Failed in file - %s line - %i
Invalid photo index for point: Assertion with expression - %s : Failed in file - %s line - %i
LabelsSelectLabel
LabelsFlushTiles
Skeleton traffic tile tried to access line outside of feature index range, likely need new chain mapping for traffic server
Skeleton traffic tile %s makes degenerate road geometry reference (start: %f, length: %f)
Skeleton traffic tile %s references invalid section %lu on feature %lu
Skeleton traffic tile %s implicates bad section (start: %f, end: %f, valid: %lu,%lu, skeleton record: %f,%f)
Incorrect c3mm version
Invalid c3mm file!
Invalid c3mm file, size (%zu) is less than header size (%d)
Invalid file type!
Failed to load c3mm file!
Failed to load c3mm lzma chunk!
Failed to load C3MM root index
Failed to load C3MM data section
Failed to load C3MM file index
Failed to load C3MM object tree
C3MM file index is missing
No meta level for file index
Meta levels are not defined
Mismatching c3mm data size
Unknown tile state!
Unknown structure type in root!
C3MM file index is missing when loading data section
ObjectTree entry is outside specified data section
Mismatching data size. Unable to decode c3mm
Expecting render command encoder to be null here (ie. ended): Assertion with expression - %s : Failed in file - %s line - %i
time=%f
GPUFrame
Starting compute encoder, but render command encoder appears active: Assertion with expression - %s : Failed in file - %s line - %i
Starting blit encoder, but render command encoder appears active: Assertion with expression - %s : Failed in file - %s line - %i
Detected stale render item %p in command buffer %d.  Please file a radar!
No query handles available
Failed to link shader: %s
Trying to load texture with unsupported texture format %d
Metal returned null buffer.
Metal returned null texture.
DestroyResources
Generating frame buffer: %d
Framebuffer incomplete, incomplete attachment
Framebuffer incomplete, missing attachment
Unsupported framebuffer format
Generating render buffer: %d
Attaching render buffer %d to attachment %d
Attaching texture %d to attachment %d
InfoLog %s: %s
Failed to compile shader: %s
Detected stale texture resource %p in render item within command buffer %d  Please file a radar!
Input image must be a non-nullptr to get a size.
Input image must be a non-nullptr to create a colorized image.
Input image must have a non-zero size to create a colorized image.
Failed to create a grayscale version of the input image to create a colorized version of the image.
Failed to create a context to draw a colorized image into.
Failed to create a color to create a colorized image.
Failed to generate an image from a colorized context.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a grayscale version of an image, to be used to colorize an image.
Failed to create gradient color to create colorized image.
Failed to generate an image from a colorized context.
Input image must be a non-nullptr to create a halo image.
Input image must have a non-zero size to create a halo image.
Generating the halo of an image has failed.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a context to render the final image with a halo in.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the halo color used for an image.
Failed to create final image with halo from halo context.: Assertion with expression - %s : Failed in file - %s line - %i
Input image must be a non-nullptr to create a stretched image.
Input image must have a non-zero size to create a stretched image.
A positive left and right padding is required to create a stretched image.
Failed to create the left part of a horizontally stretched image with size (x:%.3f, y:%.3f).
Failed to create the center part of a horizontally stretched image with size (x:%.3f, y:%.3f).
Failed to create the right part of a horizontally stretched image with size (x:%.3f, y:%.3f).
Failed to create a context to draw the horizontally stretched image with size (x:%.3f, y:%.3f).
Failed to create the horizontally stretched image from a context.
A non-nullptr context is required for drawImageToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-nullptr image is required for drawImageToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A rect with a non-zero size is required for drawImageToContext().: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a colorized image for drawImageToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-nullptr context is required for drawFillToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-nullptr path is required for drawFillToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-zero alpha color is required to draw for drawFillToContext().: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the fill color for a path.
A non-nullptr context is required for drawStrokeToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-nullptr path is required for drawStrokeToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-zero alpha color is required to draw for drawStrokeToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A positive weight is required to draw for drawStrokeToContext().: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the stroke color for a path.
A non-nullptr context is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i
A non-nullptr path is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the gradient colors for a path.
A non-nullptr context is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-nullptr path is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a path for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the shadow color for a path.
A non-nullptr image is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the shadow color for an image.
A non-nullptr context is required for drawDebugSquareToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A non-zero alpha color is required to draw for drawDebugSquareToContext().: Assertion with expression - %s : Failed in file - %s line - %i
A positive size is required for drawDebugSquareToContext().: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the fill color for a debug square.
A non-nullptr context is required.
A non-nullptr color is required.
A positive width is required.
Icon generated with metric size of zero. %s
Failed to generate a valid context.: Assertion with expression - %s : Failed in file - %s line - %i
A nullptr for a layer renderer found. Can't draw layer.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate a layer image.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate an icon image.: Assertion with expression - %s : Failed in file - %s line - %i
Nullptr LayerRenderer found in IconRenderer. This should never occur. LayerType: %hu, LayerIndex: %d: Assertion with expression - %s : Failed in file - %s line - %i
Failed to find HorizontalStretchPadding property for the image layer at index 0.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to find image size for stretched icon at index 0.: Assertion with expression - %s : Failed in file - %s line - %i
IconRenderer: HorizontalStretchPadding (%f, %f) is larger than the image size (%f, %f). Image will now use the center column of pixels to stretch. 
Nullptr LayerRenderer found, invalid object. %s
A LayerMetrics of type %s failed to generate. %s
Failed to generate placeholder glyph.: Assertion with expression - %s : Failed in file - %s line - %i
All image layers must be the same size in an icon.
Failed to create square path.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create rectangular path.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create circular path.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create balloon path.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a balloon fill path.: Assertion with expression - %s : Failed in file - %s line - %i
A contextHeight larger than zero is needed for createBalloonShadowPath().: Assertion with expression - %s : Failed in file - %s line - %i
Invalid path being given to createBalloonShadowPath(). The path is either a nullptr or invalid.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create path for createBalloonShadowPath().: Assertion with expression - %s : Failed in file - %s line - %i
LayerType value is out of range with value %d.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to get text bounds and text baseline for text layer.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to find layer metrics for image layer.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to find layer metrics for text layer.: Assertion with expression - %s : Failed in file - %s line - %i
An icon with a size of 0 was generated.
No common image size found for images used in stretched icon.: Assertion with expression - %s : Failed in file - %s line - %i
A TextLayer size of 0 was generated. %s
Found images of different sizes, all images must be the same size for stretched icons.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to find TextLayerMetrics for a stretched icon.: Assertion with expression - %s : Failed in file - %s line - %i
An icon with a size of 0 was generated.: Assertion with expression - %s : Failed in file - %s line - %i
Stretched icons should never have more than one TextLayer.
A nullptr for LayerMetrics for an ImageLayer has been found.: Assertion with expression - %s : Failed in file - %s line - %i
Image layers are different sizes after being stretched, unsupported behavior.: Assertion with expression - %s : Failed in file - %s line - %i
All given images in an icon should be the same size.: Assertion with expression - %s : Failed in file - %s line - %i
Unusally large size icon, if this is intended please adjust maxIconSizeDimension.: Assertion with expression - %s : Failed in file - %s line - %i
An icon with size of 0 or less has been generated.
Failed to insert LayerMetrics for an %s layer, due to the LayerMetrics already existing.: Assertion with expression - %s : Failed in file - %s line - %i
Creating CFDictionary with missmatching number of keys and values.
Failed to create CFDictionary.
Failed to create CFMutableDictionary.
Failed to create CFString.
Failed to tokenize font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to parse font name. No recognized special character at the start of "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create traits dictionary for font "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create CFNumber for CTFontSymbolicTraits, for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a CFNumber for font weight for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create CFDictionary for font traits for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate a CFString for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create CTFontDescriptor for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
A TextLayer of size zero has been generated.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to load a font from disk/manifest for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to get feature information for font.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to get feature dictionary for font.: Assertion with expression - %s : Failed in file - %s line - %i
Font feature type is not int, can't read feature.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to get value from feature type for font.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to get feature selectors array for font.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to get features selector array value for font.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to get feature selector id for font.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create CTFont for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Font name is empty, can't create font.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to read resource font from manifest, %s.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate CFData for font from manifest with name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create CFDataProvider for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create CGFont from data provider for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a CTFontDescriptor from font key "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create CTFont from CGFont for font name "%s".: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate CFNumber for uint32_t.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate CFNumber for float.: Assertion with expression - %s : Failed in file - %s line - %i
Input CTLine must be a valid pointer to get font bounds.
Input CTLine must be a valid pointer to get text descent.
Input text must be non-empty to create a CTLine.
Failed to create CFString from %s.
Failed to create a CFDictionary to create a CTLine for string "%s"
Failed to create a CFDictionary for a CTLine for string "%s"
Failed to create a CFAttributedString for a CTLine for string "%s"
Failed to create a CFMutableAttributedString for a CTLine for string "%s"
Nullptr color space being used to generate a CGColor.
Failed to create a CGColor.
Failed to create grayscale context for holding stroke image.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to find Icon ID for key: %i - value: %i
Failed to find Icon ID for Data ID: %i
Failed to find Icon ID for Data ID: %i - Text: %s
Failed to find Icon ID for name: %s
Failed to find ID for Map Value
Key: %i - Value: %i - Content Scale: %f
Failed to find ID for Icon Name
Name: %s - Content Scale: %f
Failed to find ID for Data Identifier
Data Identifier: %i - Content Scale: %f
grl::IconImage should never be passed a nullptr grl::IconRenderer.: Assertion with expression - %s : Failed in file - %s line - %i
grl::IconImage should never be passed a nullptr grl::IconRenderer.
Nullptr for LayerMetrics being used to render layer.
Metrics must contain a size to draw into a context.
A valid context is required to draw the path layer into.
Balloon paths have their own seperate drawing function, the code should never reach this point.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate a path for a path layer.
No LayerStyles given for path layer rendering.: Assertion with expression - %s : Failed in file - %s line - %i
Invalid LayerStyle enum being used for path layer rendering.: Assertion with expression - %s : Failed in file - %s line - %i
Nullptr for LayerMetrics being used to render layer.: Assertion with expression - %s : Failed in file - %s line - %i
Metrics must contain a size to draw into a context.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate a fill path for a balloon.: Assertion with expression - %s : Failed in file - %s line - %i
Balloon rendering needs LayerStyles to render.: Assertion with expression - %s : Failed in file - %s line - %i
Invalid LayerStyle enum used in createLayer().: Assertion with expression - %s : Failed in file - %s line - %i
Nullptr context being used for balloon shadow.: Assertion with expression - %s : Failed in file - %s line - %i
Nullptr path being used for balloon shadow.: Assertion with expression - %s : Failed in file - %s line - %i
Invalid weight being used for balloon shadow.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the shadow color for a balloon.
Image layer needs an image and layer metrics to render.: Assertion with expression - %s : Failed in file - %s line - %i
IconRenderer: Failed to find HorizontalStretchedPadding property.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to find image for image layer.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create a colorized image.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to apply a gradient to an image.: Assertion with expression - %s : Failed in file - %s line - %i
No LayerStyles given for image layer rendering.: Assertion with expression - %s : Failed in file - %s line - %i
Invalid LayerStyle enum used.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to create the halo for an image layer.: Assertion with expression - %s : Failed in file - %s line - %i
TextLayerRender: Digit font not given.: Assertion with expression - %s : Failed in file - %s line - %i
TextLayerRender: Non-digit font not given.: Assertion with expression - %s : Failed in file - %s line - %i
Failed to generate text line for text layer.: Assertion with expression - %s : Failed in file - %s line - %i
No LayerStyles given for color layer rendering.: Assertion with expression - %s : Failed in file - %s line - %i
tileKey=%d.%d.%d tileType=%d requestType=%s retry=true
Auto cancelling layer data request: %s, pendingCreation: %s
status=cancelled
Failed layer data request: %s
status=failed
Queuing creation of: %s timestamp: %lld
requestId=%zu hasAllResources=%s parent_signpost=%zu
cancelAllLayerDataRequests
Cancelling layer data request: %s
cancelLayerDataRequest: %s
Cancelling layer data request: %s, pendingCreation: %s
Created Layer Data: %s @ Time: %lld
Failed to create layer data for key: %s
Requesting layer data for: %s
tileKey=%d.%d.%d type=%d requestType=%s
LayerDataRequest
processNewLayerData: %s
Failed to create layer data for request with all resources: %s
Finished layer data request: %s
status=success
LayerDataDecodeDispatched
LayerDataDecode
Resource Arrived: %s, rid: %llu
Resource Failed: %s, rid: %llu
Resource Cancelled: %s, rid: %llu
Failed to load key: %s type: %d, %lld: %s
Failed to decode key: %s type: %d, rid: %llu
resourceSize=%lu source=%hhu
ResourceDecode
Requesting in progress resource: %s
Requesting failed resource: %s
Requested resource expired: %s
Requested resource already arrived: %s, %llu
Requesting resource: %s
Adding to requests in progress: %s, %lu
Received resource: %s, rid: %llu
Removing resource from cancelled list: %s, rid: %llu
** Received resource: %s, rid: %llu
** Received esource should either be in progress or canceled: %s, rid: %llu
Received failed resource: %s, %llu
Removing fsailed resource from cancelled list: %s, rid: %llu
Received cancelled resource: %s, rid: %llu
Removing cancelled resource: %s, rid: %llu
cleanupResourceRequests
ResourceManager cancelling resource: %s, rid: %llu
* ResourceManager cancelling resource: %s, rid: %llu
Adding cancelled resource: %s, rid: %llu
Removing %s from Resource status container, status is: %s
LoadingResources
failed=no
failed=yes
FullyLoaded
_AnimationManagerRunner
VKAnimationRunner
NSObject
VKSharedResources
GEOResourceManifestTileGroupObserver
VKSharedResourcesManager
VKSceneConfiguration
VKCamera
RouteRenderLayerObserverProxy
VKPolylineGroupOverlayObserver
VKFootprint
VKViewVolume
Tools
VKAnnotationTrackingCameraController
VKGesturingCameraController
VKMapView
Internal
IconLookup
VKMapCanvas
VKMapModelDelegate
VKInteractiveMap
VKAnimation
VKTimedAnimation
VKMapModel
VKScreenCanvas
VKDebugTreeNode
VKDebugTreeDataNode
VKDebugTreePropertyNode
VKTransitLineMarker
ReachabilityCallbacker
VKCameraController
VKMapCameraController
VKStateCaptureHandler
VKARCameraController
VKFeatureMarker
VKGlobeGestureCameraController
VKMapImageCanvas
MDSnapshotMap
VKInternalIconManager
VKDebugTree
VKLabelNavTrafficFeature
VKLabelNavFeature
VKLabelNavTrafficCamera
VKLabelNavTrafficSignal
VKPolylinePath
VKTransitPolylinePath
VKTransitStationPolylinePath
VKMuninRoad
VKNavigationPuck
VKTrackableAnnotationPresentation
VKPlatform
VKPolylineGroupOverlay
VKRouteOverlay
VKNotificationObserver
VKIconModifiers
VKIconImage
VKIconManager
LabelNavRouteContextObserverProxy
VKRouteContextObserver
VKAnchorWrapper
VKAnchorDelegate
VKPuckAnimator
VKLabelMarkerFeatureHandle
VKLabelMarkerShield
VKLabelMarker
VKNavContext
VKMuninMarker
VKDynamicAnimation
VKPIcon
NSCopying
VKPolygonalItemGroup
VKPIconPack
VKPTextureAtlas
VKMapGestureCameraController
VKRunningCurve
VKLabelNavManeuver
VKPShield
VKTestTileRequester
VKPShieldPack
VKPShieldVariant
VKTrafficIncidentFeature
VKMuninCameraController
VKRouteLineObserver
VKRouteLineObserverProtocol
VKRouteContextObserverThunk
VKPGenericShieldStyleInfo
VKRoadSignArtwork
VKTrafficCameraFeature
VKRouteEtaDescription
VKRouteInfo
VKAlternateRouteInfo
VKRouteContext
VKFoundationUtility
VKInternedString
VKFoundationInterning
VKLabelExternalTextElement
NSSecureCoding
NSCoding
VKLabelExternalIconElement
VKCustomFeature
GGLImageCanvas
MDRenderTarget
VKMapSnapshotCreator
MapEngineDelegate
VKNotificationObserverDelegate
VKImageCanvas
_MapEngineRenderQueueSource
GGLRenderQueueSource
VKRouteLine
VKImage
VKClassicGlobeCanvas
GlobeLineContainerDelegate
VKGlobeLineContainerDelegate
VKResourceManager
VKPolylineOverlayRenderRegion
VKPolylineOverlay
RenderRegion
GEOComposedRouteObserver
VKGestureCameraBehavior
VKGlobeLineContainer
VKDebugSettings
VKLabelNavRoad
LabelNavRouteLabeler
VKRouteRoadInfo
VKGuidanceStepInfo
VKARGestureCameraBehavior
MDARController
VKClientLocalizedStrings
VKMapSnapshot
VKVenueFeatureMarker
VKCustomFeatureDataSourceObserverThunk
VKCustomFeatureDataSourceObserver
VKTimer
VKScreenCameraController
GRLResourceGroupObserver
AltTileFetcher
VKGlobeCameraController
VKBuildingGroup
MIController
VKLabelNavJunction
VKPuckAnimatorLocationProjector
MDDisplayLayer
GGLLayerDelegate
VKMercatorTerrainHeightCache
VKBundle
VKVectorOverlayData
VKVectorOverlayPolyline
VKVectorOverlayPolylineGroup
VKVectorOverlayCircle
VKVectorOverlayPolygon
VKVectorOverlayPolygonGroup
Accessibility
VKViewportInfo
VKPShieldIndexVariantEntry
VKLabelNavRoadLabel
VKLabelNavTileData
VKLabelNavRoadGraph
junctionlist
VKObjectBoundsContext
VKVenueGroup
VKGlobeAnnotationTrackingCameraController
VKMuninJunction
VKClusterFeatureAnnotation
VKCustomFeatureAnnotation
VKAnnotation
VKManifestTileGroupObserverProxy
GEOExperimentConfigurationObserver
VKPShieldIndex
VKPShieldIndexEntry
VKNavCameraController
VKNavigationCameraController
VKPuckAnimatorDelegate
VKNavContextObserver
VKCameraDelegateMediator
VKMapViewCameraDelegate
VKCompoundAnimation
VKStylesheetVendorResourceManifestTileGroupObserverProxy
VKPShieldIndexTextEntry
VKImageSourceKey
VKCameraRegionRestriction
VKTestIdentifiedMapDataRequester
VKPGenericShield
VKGlobeImageCanvas
VKPGenericShieldStylePack
VKTrafficFeature
VKAttachedNavGestureCameraBehavior
VKNavGestureCameraBehavior
VKDetachedNavGestureCameraBehavior
VKPGenericShieldVariant
Munin
VKOverlay
VKVectorOverlayDelegate
VKTrafficSignalFeature
VKPolygonGroup
VKMapAnnotationTrackingCameraController
VKLabelNavRouteEta
VKVenueBuildingFeatureMarker
GGLOpenGLESLayer
GGLLayer
_GGLDisplayLinkTarget
MetalLayer
init
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
animationDidStop:
animationDidResume:
initWithAnimationManager:
_animationManager
running
onTimerFired:
priority
startWithRunner:
hasFrequency
frequency
runsForever
stop
timed
duration
modernManager
sharedManager
dataForResourceWithName:fallbackBundle:
bytes
length
activeTileGroup
activeTileSetForTileType:scale:
isHybridModeAvailableForTileKey:
isAvailableForTileKey:
activeTileSetForKey:
maximumZoomLevelInRect:
versionForRegion:
versionForTileKey:
stringWithFormat:
contentScale
sharedSettings
disableTransitLineMerging
disableTransitLineGroupMerging
disableIntraLinkTransitLineCrossings
transitHighlighting
disableOverlayTextConsole
paintTransitCounts
appendString:
appendFormat:
newlineCharacterSet
componentsSeparatedByCharactersInSet:
count
UTF8String
init:stylesheetVendor:
addTileGroupObserver:queue:
removeTileGroupObserver:
dealloc
purge
purgeDecompressSessionCachedBuffers
resourceManifestManagerWillChangeActiveTileGroup:
resourceManifestManagerDidChangeActiveTileGroup:
resourceManifestManager:didChangeActiveTileGroup:fromOldTileGroup:
dataOverrideManager
iconManager
textureManager
resourceManager
device
gglDevice
alphaAtlas
highInflationAlphaAtlas
isoAlphaAtlas
distanceAtlas
shaderLibrary
grlIconManager
grlFontManager
defaultDecompressionSession
_initWithDevice:standardLibrary:
_addResourceUser
_removeResourceUser
_hasResourceUsers
.cxx_destruct
.cxx_construct
stylesheetVendor
_iconManager
_textureManager
_resourceManager
_stylesheetVendor
_dataOverrideManager
_device
_alphaAtlas
_highInflationAlphaAtlas
_isoAlphaAtlas
_distanceAtlas
_shaderLibrary
_defaultDecompressionSession
_resourceProvider
_grlIconManager
_grlFontManager
_referenceCount
resources
modernLoader
clearAllCaches
sharedResources
addResourceUser
removeResourceUser
hasResoruces
_lock
_sharedResources
_tilegroupIdentifierToResources
attributionsCount
attributionAtIndex:
regionsCount
regionAtIndex:
regionalResourcesCount
regionalResourceAtIndex:
hasLabelWithArtwork
currentIconState
navState
featureMercatorPoint
label
nextMercatorPoint
closestPointOnRoute:
pointCount
pointAtRouteCoordinate:
countByEnumeratingWithState:objects:count:
isCamera
isSignal
isIncident
swapExternalFeature:
groupIdentifier
isGrouped
routeOffset
pointAt:
newFeatureForExternalFeature:previousMercatorPoint:nextMercatorPoint:
previousMercatorPoint
displayMercatorPoint
trafficFeature
layoutWithNavContext:
expectedIconState
tailOrientation
setTailDirection:
labelNavMode
type
shouldUpdateStyle
shouldRestyleFeature
recreateRoadSignWithNavContext:
isPOI
setDisplayMercatorPoint:
setRenderOrder:
navFeature
isAheadButNotApproaching
mercatorPoint
isPicked
trafficFeatureType
distanceFromPoint:toPoint:
uniqueIdentifier
labelState
enableTrafficFeatureLabelDebugging
setShouldRestyleFeature:
inverseManeuverTransform
maneuverTransform
boundsUnitsPerMeter
tailDirection
isApproaching
approachingRouteOffset
routeRibbon
selectedPolyline
selected
functionWithName:
_solveForInput:
resetState
_updateStyleManager
initWithTaskContext:
setSceneManager:
sceneManager
setStyleManager:
styleManager
setNavigationState:
setDistanceToCurrentManeuver:
setDistanceToDestination:
setCurrentManeuverType:
setCurrentStepLength:
setNextStepLength:
setCurrentIncidentType:
setCurrentManeuverJunctionsCount:
setCurrentGroupedManeuverCount:
setLineType:
setRampType:
setNextManeuverRampType:
setCurrentTransportationType:
setSearchAlongTheRoute:
setVehicleSpeed:
setRoadSpeed:
setNavCameraMode:
navCameraMode
setNavigationDestination:
navigationDestination
navigationState
_sceneManager
_styleManager
_pointsOfInterest
_navState
_distanceToCurrentManeuver
_distanceToDestination
_currentManeuverType
_currentStepLength
_nextStepLength
_currentIncidentType
_currentManeuverComplexity
_currentGroupedManeuverCount
_lineType
_rampType
_nextManeuverRampType
_transportType
_searchAlongTheRoute
_vehicleSpeed
_roadSpeed
_roadSpeedZeroes
_cameraMode
_navigationDestination
_distanceRanges
_taskContext
setNeedsUpdate
initWithMapRegion:
initWithFormat:
setObject:forKey:
setPosition:
sharedPlatform
isInternalInstall
updateIfNeeded
nearestGroundPoint
widthOfViewAtDepth:
upVector
isWorldSpaceRectVisible:
forwardVector
annotationRectTest
annotationCoordinateTest
cameraState
adjustClipPlanes
updateWithFrustum:matrix:
computeFromCamera:
farClipDistance
pitch
rightVector
groundPointFromScreenPoint:atGroundLevel:
tanHalfHorizFOV
groundPointFromScreenPoint:
zoomAtPoint:
position
groundPlaneIntersectionPoint
setHorizontalOffset:
initWithRunLoopController:
detailedDescription
descriptionDictionaryRepresentation
_setPosition:
setMercatorPosition:
mercatorPosition
frustum
setOrientation:
orientation
setAspectRatio:
verticalFieldOfView
setVerticalFieldOfView:
horizontalFieldOfView
nearClipDistance
tanHalfVerticalFOV
viewVolume
footprint
groundPoint
displayZoomLevel
setCameraState:
maximumStyleZForRect:
isOuterWorldBoundsVisible
depthForViewWidth:
zoomAtCentrePoint
scaledViewProjectionMatrix
scaledProjectionMatrix
scaledViewMatrix
unscaledViewMatrix
unscaledProjectionMatrix
view:
cameraFrame
aspectRatio
maxHeightNoPitch
setMaxHeightNoPitch:
minHeight
setMinHeight:
maxHeight
setMaxHeight:
maxPitch
setMaxPitch:
terrainHeight
setTerrainHeight:
fractionOfScreenAboveFarClipPlaneAtCanonicalPitch
setFractionOfScreenAboveFarClipPlaneAtCanonicalPitch:
distanceToGroundAndFarClipPlaneIntersection
screenHeightOfGroundAndFarClipPlaneIntersection
allowDatelineWraparound
setAllowDatelineWraparound:
canonicalPitch
setCanonicalPitch:
horizontalOffset
ndcZNear
setNdcZNear:
regionRestriction
setRegionRestriction:
minDistanceToGroundRestriction
setMinDistanceToGroundRestriction:
maxDistanceToGroundRestriction
setMaxDistanceToGroundRestriction:
_runLoopController
_frustum
_minHeight
_maxHeight
_maxPitch
_terrainHeight
_maxFarClipDistance
_needsUpdate
_updating
_viewVolume
_footprint
_tanHalfHorizFOV
_tanHalfVerticalFOV
_forward
_right
_fractionOfScreenAboveFarClipPlaneAtCanonicalPitch
_distanceToGroundAndFarClipPlaneIntersection
_screenHeightOfGroundAndFarClipPlaneIntersection
_allowDatelineWraparound
_canonicalPitch
_horizontalOffset
_ndcZNear
_aspectRatio
_verticalFieldOfView
_near
_far
_width
_height
_transform
_scaledViewMatrix
_scaledProjectionMatrix
_scaledViewProjectionMatrix
_unscaledViewMatrix
_unscaledProjectionMatrix
_worldMatrix
_maxHeightNoPitch
_regionRestriction
_minDistanceToGroundRestriction
_maxDistanceToGroundRestriction
removeObserver:
addObserver:
polylineGroup:didAddPolyline:
polylineGroup:didRemovePolyline:
polylineGroup:didSelectPolyline:
polylineGroup:didFocusPolyline:
initWithPolylineGroupObserver:
startObserving:
stopObserving:
_polylineGroupObserver
_retainedGroups
_observedGroupsSet
bundleWithIdentifier:
pathForResource:ofType:inDirectory:
dataWithContentsOfFile:
initWithDevice:
initWithDevice:sRGB:
corners
_expandedBoundingRect
copy
cornerGroundPoints
rejectsRect:
containsGroundPoint:
boundingRect
convexHull
minDepth
maxDepth
centerDepth
furthestGroundPoint
cornerGroundPointsCount
_boundingRect
_convexHull
_maxDistance
_furthestGroundPoint
_minDistance
_nearestGroundPoint
_minDepth
_maxDepth
_centerDepth
_cornerGroundPointsCount
_cornerGroundPoints
lerpPoint:
_corners
isNotForDisplay
initWithCapacity:
removeAllObjects
routeRelevance
isOnSelectedRoute
setRouteRelevance:
addObject:
uniqueString
compare:
format
sizeInPixels
finalRenderTarget
size
initWithFeatureMarkerPtr:
currentCanvas
featureMarkerAtScreenPoint:
currentNormalizedZoomLevel
buildingMarkerAtPoint:
featureMarkerAtPoint:
clientStyleAttributes
currentZoomLevel
loadGreenTraffic
routeLineSimplificationEpsilon
_updateMapDisplayStyle
setApplicationState:displayedSearchResultsType:
cameraDelegate
setCameraDelegate:
_labelSettings
openForClient:
openServerConnection
_closeLoaderConnection:
closeForClient:
closeServerConnection:
mainBundle
objectForInfoDictionaryKey:
boolValue
rendersInBackground
setRendersInBackground:
_createDisplayLayer
forceLayout
updateCameraForFrameResize
visibleTileSets
attributionsForCurrentRegion
reloadStylesheet
mapDisplayStyle
setMapDisplayStyle:
baseDisplayRate
setBaseDisplayRate:
contentsScale
setContentScale:
bounds
setBounds:
isEffectivelyHidden
didReceiveMemoryWarning:beAggressive:
cameraController
canRotate
setStaysCenteredDuringPinch:
staysCenteredDuringPinch
setStaysCenteredDuringRotation:
staysCenteredDuringRotation
setIsPitchEnabled:
isPitchEnabled
layoutContinuously
setLayoutContinuously:
setNeedsLayout
clearScene
setHidden:
stopLoading
isHidden
superlayer
labelHighlighting
debugHighlightObjectAtPoint:highlightTarget:
populateData:
logTree
isGesturing
setGesturing:
canZoomInForTileSize:
canZoomOutForTileSize:
minimumZoomLevelForTileSize:
topDownMinimumZoomLevelForTileSize:
maximumZoomLevelForTileSize:
currentZoomLevelForTileSize:
zoomLevelAdjustmentForTileSize:
convertGrlSizeGroup:
convertSizeGroup:
camera
setDimmingBaseMap:animated:duration:
localizeLabels
initWithVenue:localize:
initWithVenueBuilding:localize:
venueAtLocation:withMarginForError:includeNonRevealedVenues:
venueBuildingFeatureMarker
arrayWithCapacity:
mapDelegate
mapLayer:venueWithFocusDidChange:building:
setLoadMuninMetadata:
mapLayer:willTransitionTo:
_postDelegateCallbackBlock:
setCanonicalSkyHeight:
initWithMapEngine:inBackground:
setDelegate:
setMapDelegate:
supportsMapType:scale:
setMapType:animated:
canShowFlyover
isShowingFlyover
mapType
setIsChangingMapType:
setMapType:
_createGlobe
edgeInsets
setEdgeInsets:
overlays
arrayWithArray:
removeOverlay:
addOverlay:
setNightMode:
transferStateFromCanvas:
performStylesheetDidChange
map:didUpdateVerticalYawTo:
centerCoordinateDistanceRange
setCenterCoordinateDistanceRange:
canEnter3DMode
mapLayerCanEnter3DModeDidChange:
mapLayer:flyoverModeDidChange:
flyoverMode
layoutIfNeeded
waitForLoading
mapLayer:canShowFlyoverDidChange:
mapLayer:showingFlyoverDidChange:
setMapDisplayStyle:animated:duration:
mapLayerWillChangeRegionAnimated:
mapLayerDidChangeVisibleRegion
mapLayerDidChangeRegionAnimated:
setCameraController:
_updateBackgroundColor
emphasis
setBackgroundColor:
disableStylesheetAnimations
initWithDuration:
setTimingFunction:
setStepHandler:
setCompletionHandler:
requestStylesheetMapDisplayStyle:animated:
heading
altitude
mapRegion
consoleString:
centerCoordinate
setCenterCoordinate:altitude:yaw:pitch:duration:animationStyle:timingCurve:completion:
exceptionWithName:reason:userInfo:
raise
standardUserDefaults
persistentDomainForName:
objectForKey:
numberWithInt:
sharedController
activateController:
setContentsScale:
initWithQueue:withName:withCallback:
lowPerformanceDevice
openLoaderConnection
initWithMapDataAccess:animationRunner:runLoopController:cameraDelegate:
setMapModel:
setMapCanvas:
initWithTaskContext:mapDataAccess:animationRunner:runLoopController:cameraDelegate:muninSceneLogic:
initWithTarget:taskContext:
activateInternalSettings
defaultCenter
setYaw:animated:
setMapRegion:pitch:yaw:duration:completion:
durationToAnimateToMapRegion:
convertPoint:fromLayer:
convertPointToCoordinate:
convertPointToMapPoint:
convertMapPointToPoint:
convertPoint:toLayer:
convertCoordinateToPoint:
convertCoordinateToCameraModelPoint:
convertPoint:toCoordinateFromLayer:
convertPointToCoordinateOnSphere:
setEdgeInsets:duration:timingFunction:completionHandler:
edgeInsetsDidEndAnimating
edgeInsetsWillBeginAnimating
runAnimation:
setFullyOccludedEdgeInsets:
fullyOccludedEdgeInsets
setClientFramingInsets:
canShowFlyoverAnimation
prepareFlyoverAnimation:completion:
mapLayer:didStopFlyoverTourCompleted:
_notifyDelegateFlyoverTourLabelChanged:
mapLayer:flyoverTourLabelDidChange:
mapLayerWillStartFlyoverTour:
_runFlyoverTourStateChange:completion:
startFlyoverAnimation:animateToStart:labelChanged:stateChange:
createFlyoverPreTourAnimation:duration:
startFlyoverAnimation:animateToStart:completion:
startFlyoverTourAnimation:animateToStart:labelChanged:stateChange:
stopFlyoverAnimation
pauseFlyoverTourAnimation
resumeFlyoverTourAnimation
enableFlyoverStatistics
disableFlyoverStatistics
resetFlyoverStatistics
flyoverStatistics
numberWithDouble:
setValue:forKey:
stringWithUTF8String:
objectForKeyedSubscript:
unsignedLongValue
numberWithUnsignedLong:
numberWithUnsignedLongLong:
unsignedLongLongValue
returnToPuck
stopTrackingAnnotation
initWithTaskContext:device:mapDataAccess:animationRunner:runLoopController:cameraDelegate:
sceneConfiguration
setSceneConfiguration:
setNavContext:
updateLocation:andCourse:
start
transitionToTracking:mapMode:startLocation:startCourse:cameraController:pounceCompletionHandler:
markerWithLabelMarker:
feature
dataSource
setDataSource:
labelMarkerForCustomFeatureAnnotation:dataSource:
selectLabelMarker:completion:
labelMarkerImpl
deselectLabelMarker
disableTransitLines
setDisableTransitLines:
forceMapType:animated:
arrayWithObjects:count:
enter3DMode
exit3DMode
isPitched
isFullyPitched
isSupported
arCameraController
run:
globeCameraController
globeView
trasitionToARModeFromCameraFrame:withDuration:completion:
setTourShouldResumeWhenDoneGesturing:
updateCameraFrameFromARTransform
flyoverAvailable
panWithOffset:relativeToScreenPoint:animated:duration:completionHandler:
shouldHideOffscreenSelectedAnnotation
zoomScale
setZoomScale:
startTrackingAnnotation:trackHeading:animated:
annotationTrackingZoomStyle
setAnnotationTrackingZoomStyle:
annotationTrackingHeadingAnimationDisplayRate
setAnnotationTrackingHeadingAnimationDisplayRate:
trackingAnnotation
isAnimatingToTrackAnnotation
isTrackingHeading
insertOverlay:aboveOverlay:
insertOverlay:belowOverlay:
viewportInfo
restoreViewportFromInfo:
initWithMuninJunction:
initWithMuninRoadEdge:
_mapDelegateQueue
mapLayer:nearestJunctionDidChange:currentRoad:
mapLayerDidStartLoadingTiles:
mapLayerDidFinishLoadingTiles:
mapLayerDidFailLoadingTiles:withError:
mapLayerDidReloadStylesheet:
numberWithBool:
dictionaryWithObjects:forKeys:count:
postNotificationName:object:userInfo:
mapLayerDidChangeSceneState:withState:
mapLayerLabelsDidLayout:
mapLayer:selectedLabelMarkerWillDisappear:
mapLayer:labelMarkerDidChangeState:
mapLayer:selectedLabelMarkerDidChangeState:
isSelected
mapLayer:didFinishChangingMapDisplayStyle:
setCenterCoordinateDistanceRange:duration:timingFunction:
setRegionRestriction:duration:timingFunction:
updateWithTimestamp:
didPresent
mapLayerDidDraw:
wantsTimerTick
zoomToLevel:withFocusPoint:
zoom:withFocusPoint:completionHandler:
startPinchingWithFocusPoint:
updatePinchWithFocusPoint:oldFactor:newFactor:
stopPinchingWithFocusPoint:
startPanningAtPoint:panAtStartPoint:
updatePanWithTranslation:
stopPanningAtPoint:
startRotatingWithFocusPoint:
updateRotationWithFocusPoint:newValue:
stopRotatingWithFocusPoint:
startPitchingWithFocusPoint:
updatePitchWithFocusPoint:translation:
stopPitchingWithFocusPoint:
tapAtPoint:
transferGestureState:
willStopPanningAtPoint:withVelocity:
isPointValidForGesturing:
stopSnappingAnimations
goToTileX:Y:Z:tileSize:
setCameraHorizontalOffset:duration:timingFunction:
layoutWithContext:
setDisplayLayer:
mapLayer:didUpdateVerticalYawTo:
puckAnimator:updatedPosition:course:
puckAnimatorDidStop:
puckAnimator:updatedTargetPosition:
navigationPuck
setApplicationState:
setDisplayedSearchResultsType:
isLabelMarkerSelectionEnabled
setLabelMarkerSelectionEnabled:
closeLoaderConnection
secondaryCanvas
_forceLayoutForSuspensionSnapShot
forceFrame
forceCameraUpdateForFrameResize
stylesheetIsDevResource
styleZOffsetScale
setStyleZOffsetScale:
targetDisplay
setTargetDisplay:
vehicleState
setVehicleState:
setEmphasis:
applicationUILayout
setApplicationUILayout:
trafficEnabled
setTrafficEnabled:
trafficIncidentsEnabled
setTrafficIncidentsEnabled:
displayRate
setDisplayRate:
navigationDisplayRate
setNavigationDisplayRate:
willEnterForeground
didEnterBackground
didFinishSnapshotting
flushTileLoads
setLocalizeLabels:
labelScaleFactor
setLabelScaleFactor:
setIsPitchable:
isPitchable
debugLayoutContinuously
setDebugLayoutContinuously:
didReceiveMemoryWarning
didReceiveFlushTileCaches
didReceiveLocalChanged
hostDisplay
setHostDisplay:
enableDebugLabelHighlighting
debugHighlightLabelAtPoint:
debugLabelString:
setShouldLoadFallbackTiles:
shouldLoadFallbackTiles
setShouldLoadMapMargin:
shouldLoadMapMargin
detailedDescriptionDictionaryRepresentation
iconsShouldAlignToPixels
setIconsShouldAlignToPixels:
shieldSize
setShieldSize:
navigationShieldSize
setNavigationShieldSize:
shieldIdiom
setShieldIdiom:
showsRoadLabels
setShowsRoadLabels:
showsPointLabels
setShowsPointLabels:
showsPointsOfInterest
setShowsPointsOfInterest:
setPointsOfInterestFilter:
showsBuildings
setShowsBuildings:
showsVenues
setShowsVenues:
isLoadingMuninMetadata
loadMuninAvailability
setLoadMuninAvailability:
worldSpaceWidthOfView
setDimmingBaseMap:
isDimmingBaseMap
venueWithFocus
venueBuildingWithFocus
venueAtLocation:
venueAtLocation:withMarginForError:
venueWithID:
displayedFloorIsDefaultForVenueBuilding:
defaultFloorOrdinalForVenueBuilding:
displayedFloorOrdinalForVenueBuilding:
setDisplayedFloorOrdinal:forVenueBuilding:
clearVenueBuildingFloorSelections
zoomToRevealVenueFloorplan:
zoomToRevealVenueBuildingFloorplan:
_setFloorSwitcherZoomPadding:
nearestVenueDidChange:building:
setClientLocalizedStrings:
setDesiredMapMode:
supportsMapType:
supportsNightMode
setMapDisplayStyle:animated:
animateStylesWithDuration:animations:
mapRegionBounds
presentationYaw
setCenterCoordinate:altitude:yaw:pitch:duration:timingCurve:completion:
initShouldRasterize:inBackground:contentScale:auditToken:
renderInContext:
setMapRegion:pitch:yaw:
convertPoint:toMapPointFromLayer:
convertMapPoint:toPointToLayer:
convertCoordinate:toPointToLayer:
convertCoordinate:toCameraModelPointToLayer:
distanceFromPoint:toPoint:fromLayer:withPrecision:
setLabelEdgeInsets:
labelEdgeInsets
setCameraFramingInsets:
moveToFlyoverTourStartPosition:duration:completion:
startFlyoverTourAnimation:animateToStart:completion:
enableTestStatistics
disableTestStatistics
resetTestStatistics
testStatistics
tileStatistics
stopTracking
pauseTracking
navigationCameraReturnToPuck
transitionToTracking:mapMode:startLocation:startCourse:pounceCompletionHandler:
setTrackingCameraShouldHandleGestures:
trackingCameraShouldHandleGestures
setExternalTrafficFeatures:areRouteTrafficFeaturesActive:
addCustomFeatureDataSource:
removeCustomFeatureDataSource:
labelMarkerForSelectionAtPoint:selectableLabelsOnly:
labelMarkerForCustomFeatureAnnotation:
selectLabelMarker:
transitLinesDisabled
transitLineMarkersInCurrentViewport
transitLineMarkersForSelectionAtPoint:
selectedTransitLineIDs
selectTransitLineMarker:
deselectTransitLineMarker
setSelectedFeatureId:
deselectFeatureId
setSelectedVenuePoiFeatureId:
deselectVenuePoiFeatureId
canEnter3DModeFlyoverForTileSize:
setFlyoverMode:
selectedLabelMarker
labelMarkers
trackingZoomScale
setTrackingZoomScale:
addRouteOverlay:
removeRouteOverlay:
addPersistentRouteOverlay:
removePersistentRouteOverlay:
setRouteUserOffset:
setCurrentLocationText:
setRouteContext:
focusedLabelsPolyline
setFocusedLabelsPolyline:
muninJunctionDidChange:currentRoad:
didStartLoadingData
didFinishLoadingData
didFinishLoadingDataWithError:
mapDidReloadStylesheet:
willBecomeFullyDrawn
didUpdateSceneStatus:
labelManagerDidLayout
selectedLabelMarkerWillDisappear:
labelMarkerDidChangeState:
map:canShowFlyoverDidChange:
mapDidFinishChangingMapDisplayStyle:
map:selectedLabelMarkerWillDisappear:
map:labelMarkerDidChangeState:
mapLabelsDidLayout:
mapController:requestsDisplayRate:
willLayoutWithTimestamp:
startPanningAtPoint:
setDisableRoads:
setDisableLabels:
setDisablePolygons:
setDisableBuildingFootprints:
setDisableRasters:
setDisableGrid:
isFullyDrawn
getSceneState
roadsDisabled
labelsDisabled
polygonsDisabled
buildingFootprintsDisabled
rastersDisabled
gridDisabled
setRouteLineSplitAnnotation:
pptTileStatisticsForMapType:latitude:longitude:zoom:width:height:rect:
addExternalAnchor:
removeExternalAnchor:
puckAnimator:runAnimation:
applicationState
displayedSearchResultsType
userLocationAnimator
pointsOfInterestFilter
_mapType
_canvas
_globe
_mapDelegateMutex
_mapDelegate
_loaderOpen
_tileLoaderClientID
_emphasis
_mapDisplayStyle
_mapDisplayStyleAnimation
_edgeInsetAnimation
_animatingToEdgeInsets
_isChangingMapType
_verticalYaw
_applicationState
_displayedSearchResultsType
_notificationObserver
_userLocationAnimator
_navigationDisplayRate
_isInBackground
_mapCameraController
_navigationCameraController
_muninCameraController
_navContext
_lastAnimatedUserCoordinate
_lastAnimatedCourse
_mapEngine
_didFinishSnapshotting
_flyoverMode
_arController
_pointsOfInterestFilter
_stateCaptureHandler
populateDebugNode:withOptions:
allKeys
localizedCaseInsensitiveCompare:
sortedArrayUsingSelector:
valueForKey:
longLongValue
debugHighlightFeatureMarker:
mapCanvas
mapEngine
currentMapMode
setGlyphOnly:
imageForStyleAttributes:styleManager:contentScale:sizeGroup:modifiers:
iconForStyleAttributes:contentScale:size:transparent:
updateCameraToPositionOrientationLimits
beginRegionChange:
endRegionChange
averageFPS
_updateViewTransform
northYaw
_zoomLevelForCanvasSize:
sizeDidChange:
setStandardContainer:
setRunLoopController:
updateOverlays
standardContainer
stylesheetDidReload
featureMarkerAtScreenPoint:groundPoint:
stopRegionAnimation
setScreenCanvas:
startWithPounce:startLocation:startCourse:pounceCompletionHandler:
setNavCameraIsDetached:
currentRoadSignOffset
tileSize
mapModelDidReloadStylesheet:
delegate
mapModel:selectedLabelMarkerWillDisappear:
mapModel:labelMarkerDidChangeState:
mapModelLabelsDidLayout:
mapModelDidUpdateMinMaxZoomLevel:
canonicalSkyHeight
_map
_lastCanvasSize
_lastValidCanvasSizeZoomLevel
_horizontalOffsetAnimation
_canonicalSkyHeight
_overlayContainer
_trafficEnabled
_delegate
supportsCoastlineGlows
attributeSets
objectAtIndexedSubscript:
origin
fillMeshes
supportsBuildingStrokes
supports3DBuildingStrokes
supportsBuildingShadows
supports3DBuildings
supportsPerFragmentLighting
initWithName:
stopAnimation:
setDuration:
initWithPriority:name:
initWithPriority:
transferToRunner:
pause
resume
completionHandler
setRunsForever:
name
state
setFrequency:
_completionHandler
_name
_priority
_runner
_state
_frequency
_runsForever
initWithDuration:name:
setDragCoefficientGetter:
initWithDuration:priority:name:
timingFunction
stepHandler
_stepHandler
_timingFunction
_duration
_startTimestamp
_lastTimestamp
_resuming
_startTimestampSet
foreachRenderLayer:
_setStyleManagerFromMapType:
showTrafficCasing
setStyleManager:forRealistic:
performStylesheetDidReload
setNavMapZoomLevelTransitionZ:
setStandardMapZoomLevelTransitionZ:
initWithAnimationRunner:
setDebugStyleManager:
destroyAnimationRunner
array
containsObject:
_beginMapZoomLevelTransition:
_updateZoomLevel:
updateMapDrawStyleWithContext:
foreachActiveRenderLayer:
showingTrafficCasing
updateOverlayType
setStylesheetMapDisplayStyle:
initWithTarget:renderer:purpose:taskContext:logicManager:mapEngineSettings:animationRunner:
destroyRenderer
setShowingOuterHaloOnLabelsDidChange:
setNavigationPuckSize:
navigationPuckSize
navMapZoomLevelTransitionZ
standardMapZoomLevelTransitionZ
purpose
routeUserOffset
_tileSize
_zoomLevel
_blockingStylesheetObservers
_styleTransitionProgress
_forcedMaxZoomLevel
_mapEngineSettings
_animationRunner
_renderer
_rendererMutex
_logicManager
_navigationPuckSize
_mapFeatureStyleAttributes
_styleQuery
_metroArea
_forceMapDrawStyleUpdate
_highZoomTransitionAnimation
_navigationPuck
_localizeLabels
_labelScaleFactor
_disableTransitLines
_navMapZoomLevelTransitionZ
_standardMapZoomLevelTransitionZ
_purpose
_routeUserOffset
style
identifier
setStyle:
setIdentifier:
tileKeysCount
tileKeyAtIndex:
addTileKey:
attributesCount
attributeAtIndex:
value
setCamera:
canvasDidLayout
setCanvas:
cameraController:requestsDisplayRate:
_camera
_displayTarget
_userIsGesturing
_cameraController
_edgeInsets
_fullyOccludedEdgeInsets
_deallocing
_mapRenderer
_layoutContext
_view
_arSession
initWithParent:
isExpandable
propertyColumn
valueColumn
tagsColumn
searchNodes:withParameter:
parent
children
setChildren:
_parent
_children
initWithDebugTreeProperty:withParent:
initWithDebugTreeNode:withParent:
buildChildren
rangeOfString:options:
propertyCount
_node
idValueForTreeValue:
stringValue
deleteCharactersInRange:
numberWithLongLong:
_property
maxPoint
styleQueriesForPointyRoofs:selected:
hasFeatureId:
commitRangesToFillRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:
fillMeshesForPointyRoofs
commitRangesToPointyRoofTopRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:
strokeMeshes
commitRangesToStrokeRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:
featureIds
initWithFeature:transitLink:
initWithMUID:resultProviderID:coordinate:
initWithUTF8String:
muid
markerWithFeature:transitLink:
initWithIdentifier:
featureID
shieldText
shieldLocale
shieldType
shieldColor
labelText
labelLocale
transitLinkID
_identifier
_shieldText
_shieldLocale
_shieldType
_shieldColor
_labelText
_labelLocale
_transitLinkID
tileKey
sharedNetworkObserver
_reachabilityChanged:
addNetworkReachableObserver:selector:
removeNetworkReachableObserver:
initWithListener:queue:
clearListener
_listener
_queue
lines
linesCount
isBorder
isChangingRegion
isAnimating
canvas
doesNotRecognizeSelector:
minimumZoomLevel
maximumZoomLevel
topDownMinimumZoomLevel
initWithCoordinateRegion:
initWithCoordinate:
initWithMapRect:
addVertex:
setCenterCoordinate:
distanceFromCenterCoordinate
setDistanceFromCenterCoordinate:
setHeading:
setPitch:
isRotated
mapDataAccess
animationRunner
runLoopController
checkAndResetRegionChangeCount
centerScreenPoint
scaledScreenPointForPoint:
cursorFromScreenPoint:
canPitch
stylesheetDidChange
presentationHeading
centerCoordinate:andDistanceFromCenter:forMapRegion:
isRotateEnabled
setIsRotateEnabled:
_cameraDelegate
_gesturing
_regionChangeCount
_inProgressRegionChangeIsAnimated
_mapDataAccess
_staysCenteredDuringPinch
_staysCenteredDuringRotation
_isPitchEnabled
_isRotateEnabled
replaceAttributes:count:
initWithString:signMetrics:textMetrics:signColoring:glyph:
initWithCameraController:
updateCameraZBounds
currentDisplayZoomLevel
sharedConfiguration
countryCode
isEqualToString:
rotateToPitch:withPoint:preserveAltitude:animated:exaggerate:
resumeAnimation
pauseAnimation
mapLayerDidBecomePitched:
tapZoom:levels:completionHandler:
currentMaximumNormalizedZoomLevel
currentMinimumNormalizedZoomLevel
zoom:withPoint:completionHandler:
zoomToLevel:withPoint:
snapMapIfNecessary:
positionClampedToCameraRestriction:
setZoomLevel:
setTileSize:
setYaw:
zoomLevel
clampZoomLevelIfNecessary
setZoomStyle:
setHeadingAnimationDisplayRate:
minimumPitchForNormalizedZoomLevel:
isPitchIncreasing
currentStyleZoomLevel
rotateToYaw:withPoint:animated:
maxPitchForNormalizedZoomLevel:
idealPitchForNormalizedZoomLevel:
canEnter3DModeNoUpdate
maximumNormalizedZoomLevel
minimumNormalizedZoomLevel
_mercatorCenterCoordinateForMapRegion:
_animateToPosition:pitch:yaw:duration:timingCurve:completion:
clampedPosition:
_animateToPosition:pitch:yaw:duration:timingCurve:forceDestination:completion:
clampPitch:yaw:atTargetPositionZ:
_jumpToCenterPoint:pitchRadians:yawRadians:
setCenterCoordinate:altitude:yaw:pitch:duration:animationStyle:timingCurve:forceDestination:completion:
animateRegionWithDuration:timingFunction:stepHandler:completionHandler:
containsCoordinate:
clampedCoordinate:
currentTopDownMinimumNormalizedZoomLevel
normalizedZoomLevelAdjustmentForTileSize:
setCenterCoordinate3D:altitude:yaw:pitch:duration:animationStyle:timingCurve:completion:
mapModel
_mapModel
_mapCanvas
_minDistanceToGroundAlongForwardVector
_maxDistanceToGroundAlongForwardVector
_finalYaw
_finalPitch
initWithString:
processingQueueWidth
stringByAppendingString:
_registerHandlerforStateCapture:
_unregisterHandlerforStateCapture
_stateCapture
stateDataForDictionary:title:
dataWithPropertyList:format:options:error:
dataUsingEncoding:
_handle
_callback
stringWithString:
initWithARCameraController:
updateGlobeFromCamera
_updateBaseTransform
setEastLng:
setWestLng:
setNorthLat:
setSouthLat:
_intersectAndResolveWorldCollision:
_setupPounceAnimation:duration:completion:
arRenderAtNativeRate
initWithTaskContext:mapDataAccess:animationRunner:runLoopController:cameraDelegate:
cameraPosition
_fovAdjustment
setCurrentZoomLevel:
setMaxZoomLevel:
updateWithARSession:
_updateARContext
trasitionToARModeAtCoordinate:withDuration:completion:
arCameraTransform
heightScale
arSessionWasInterrupted:
setGlobeView:
setMapEngine:
overrideARFieldOfView
setOverrideARFieldOfView:
offsetTransform
setOffsetTransform:
fieldOfView
setFieldOfView:
_globeView
_currentZoomLevel
_maxZoomLevel
_altitudeOffset
_fovy
_offsetTransform
_cameraFrame
_baseTransform
_arTransform
_currentARTransform
_lastARTransform
_arOrientation
_transitionAnimation
_interfaceOrientation
_interfaceOrientationRotation
_currentCoordinate
_overrideARFieldOfView
_fieldOfView
offsetPixelForPixel:
setArtworkCache:
needsLayout
composedRoute
setRoute:
styleManagerDidChange:
styleManagerDidStartAnimating
styleManagerDidFinishAnimating
currentRoadSignPixelHeight
computeRoutePositionForPOIAtPixel:currentPosition:context:
setMaxVisibleRoadsigns:
grabTilesFromScene:
layoutWithNavContext:externalCollisionLabels:
activeSigns
clearSceneIsMemoryWarning:
disableRoadSignLimit
setDebugDisableRoadSignLimit:
needsDebugDraw
debugDraw:overlayConsole:navContext:
markerWithFeatureMarker:
shortName
venueID
styleAttributes
actualFeatureMarker
_actualFeatureMarker
debugConsoleForId:
initWithPolylineOverlay:
setSimplificationEpsilonPoints:
setRouteRibbon:
transportType
createDebugNode
initWithRouteContextChangeObserver:
alternateRoutes
route
routeInfo
resetNotificationsForObserverType:
worldPoint
totalRouteCount
repositionAtRouteCoord:
displayEtaDescription
etaText
forceEtaLabelPlacement
setForceEtaLabelPlacement:
etaComparisionToMain
updateRoadSignWithNavContext:artworkCache:
hasRouteEta
initWithRouteInfo:routeCoord:
etaDescription
createLabelWithNavContext:orientation:etaDescription:selected:artworkCache:
setRouteInfo:
setSelected:
expectedTime
forEachSectionWithShareCount:dothis:
hasFocus
toStyleEtaComparison:
styleQueryForNavContext:selected:focused:etaComparison:transportType:
artworkForEtaDescription:navContext:styleQuery:orientation:artworkCache:selected:
localSignBounds
objectAtIndex:
traceEtaDebugLog
setTraceEtaDebugLog:
enableEtaLabelDebugging
enableRouteShareSectionDebugging
enableEtaLabelRectDebugging
enableRouteIntersectionTesting
etaLabelDebugOrientationMask
etaLabelDebugScore
poisCount
pois
transitNodeCount
transitNodes
dontMatchRouteLine
needsUpdateForViewingScale:
supportsSnapping
initForVisibleRect:snappingRegion:routeLineDatas:
buildRouteLine:matchToRoads:viewUnitsPerPoint:force:
forEachSection:
generateArrowsForManeuverDisplayMode:routeLineWidth:
overlay
currentDisplayStep
createMeshIfNecessary:
snappingToTransitLines
currentLegIndex
splitRouteLineAtAnnotation:
showManeuverPoints
stepsCount
maneuverPoints
highlightRouteLineSnappingStatus
section
routeStartIndex
startPointIndex
routeEndIndex
vkBounds
points
isMapMatched
isMapMatching
forEachSnappedPath:
sections
disableRoute
boundingMapRegion
showTraffic
containsTransit
northLat
westLng
southLat
eastLng
dataWithBytesNoCopy:length:freeWhenDone:
updateState
setCameraManager:
beginZoom:
updateZoom:oldFactor:newFactor:
endZoom:
beginPan:
updatePan:lastScreenPoint:
endPan:
beginRotate:
updateRotate:atScreenPoint:
endRotate:
beginPitch:
updatePitch:translation:
endPitch:
_cameraManager
_beganDoublePanPitch
_currentDoublePanPitch
_isPitchIncreasing
dataForResourceWithName:
initWithMapEngine:
resetCameraController
cancelTileRequests
level
replaceMapContentInRect
canPossiblyDrawKey:
endPointIndex
muninTransitionMinResolution
muninTransitionMaxResolution
transitMode
navMode
interactive
nightMode
isSearchResult
zoom
variant
cppModifiers
init:
convertCalloutShape:
imageForStyleAttributes:withStylesheetName:contentScale:sizeGroup:modifiers:
imageForDataID:text:contentScale:sizeGroup:modifiers:
imageForKey:value:contentScale:sizeGroup:modifiers:
imageForName:contentScale:sizeGroup:modifiers:
styleAttributeTransitTypeKey
styleAttributeTransitSystemTypeKey
trafficIncidentTypeKey
darkVariant
isCachingAtlases
setIsCachingAtlases:
_nameToStyleManagerLock
_nameToStyleManager
_fontManager
decodeStyleNames
stringWithCString:encoding:
stringByAppendingPathExtension:
isDevResourceWithName:
_outputTree:
dictionary
doubleValue
_serializeValue:
_deserializeValue:
_serializeProperty:
_serializeNode:
_deserializeNode:
_deserializeProperty:
intValue
serializeTree
archivedDataWithRootObject:requiringSecureCoding:error:
dataWithLength:
increaseLengthBy:
mutableBytes
setLength:
dataWithData:
unarchivedObjectOfClass:fromData:error:
deserializeTree:
setOptions:
setOption:value:
enableAllOptions
disableAllOptions
_populateData
replaceInternalData:
internalData
nodes
printTree
serializeZippedTree
deserializeZippedTree:
_debugTree
_options
_nodes
trafficCamera
setIsPicked:
isTrafficCameraFeature
isEtaFeature
transitSystems
string
scale
_clearLabel
setNavFeature:
setShouldUpdateStyle:
createIcon:
initWithNavFeature:label:navLabelType:
updateLabelStateForRouteUserOffset:
setLabelState:
initWithTrafficCamera:previousMercatorPoint:nextMercatorPoint:
initWithTrafficSignal:previousMercatorPoint:nextMercatorPoint:
isOnRoute
isAwayFromRoute
isRamp
shieldDisplayGroup
isStartOfRoadName
isInGuidance
intraRoadPriority
isGuidanceStepStart
initWithTrafficFeature:previousMercatorPoint:nextMercatorPoint:
isCallout
_roadLabel
_isAwayFromRoute
_isOnRoute
_routeOffset
_displayMercatorPoint
_previousMercatorPoint
_nextMercatorPoint
_trafficFeature
_labelNavMode
_labelStyle
_isPicked
_shouldRestyleFeature
_tailDirection
_iconState
isAboveSpeedThreshold
setIsAboveSpeedThreshold:
speedLimitText
_trafficCamera
trafficSignal
_trafficSignal
hasStopIndex
stopIndex
controlPoints
accessPointEntryName
locale
accessPointExitName
hasStyleAttributes
initWithGEOStyleAttributes:
initWithAttributes:
transitSystem
artwork
routeLineArtwork
legs
pointRange
steps
transitStep
maneuverType
halls
stations
originStop
hasHallIndex
hallIndex
hasStationIndex
stationIndex
hasMuid
transitLine
hasLineColorString
lineColorString
stepIndex
destinationStop
significanceForEndNode
accessPoint
hasLocation
location
stepRange
inspectedLegIndex
inspectedStepIndex
puckSnappedStopID
composedRouteLeg
composedRouteStep
finalStepIndex
stepAtIndex:
boardStep
rideOptionsCount
attributesForTransitLine:
system
shieldDataSource
shieldColorString
attributesForTransitSystem:
artworkSourceType
iconDataSource
cartoID
defaultTransitType
transitVehicle
pickupDropoffType
maneuver
getNextStep
labelLanguage
minZoom
zoomNames
entranceZoomNames
exitZoomNames
removeObserver:forKeyPath:
setTracking:
accuracy
headingDegrees
expectedCoordinateUpdateInterval
expectedHeadingUpdateInterval
addObserver:forKeyPath:options:context:
mapLayerPresentationForAnnotation:
_goToAnnotationAnimated:duration:isInitial:
_rotateToHeadingAnimated:duration:
updateFramerate
observeValueForKeyPath:ofObject:change:context:
annotation
zoomStyle
headingAnimationDisplayRate
_annotation
_annotationPresentation
_currentAnimation
_currentAnimationStartPoint
_currentAnimationStartCameraPosition
_currentAnimationEndPoint
_currentAnimationEndCameraPosition
_pendingChangeDuration
_currentHeadingAnimation
_pendingHeadingChangeDuration
_headingAnimationCompletedAngle
_headingAnimationDisplayRate
_zoomStyle
_flags
shouldDrawDebug
paintKeysInView
paintStandardLabelMapData
paintRoadTileData
paintPolygonLayerData
paintSelectedMapTiles
paintLoadReason
selectedMapTilesToPaint
shouldFreezeLayoutCamera
paintTiles
paintVertices
paintJunctions
paintRoadBoundaries
paintRoadTiles
paintPoiTiles
paintPointTiles
paintPolygonTiles
paintCoastlines
paintLandcoverTiles
paintVenues
paintBuildings
drawDebugTransit
setDateStyle:
setTimeStyle:
dateWithTimeIntervalSince1970:
stringFromDate:
stepCount
getStationForStop:
vehicleInfosCount
vehicleInfos
hasSignificanceForEndNode
initWithOverlay:section:
lengthScaleFactor
stepDistanceFromPoint:toPoint:
initWithOverlay:section:routeStartIndex:routeEndIndex:
hasCompletedMapMatching
setTrafficSpeed:
assignTo:withSegment:
updateDistances:
setRouteStart:
setRouteEnd:
assignPoints:count:
initWithOverlay:snappedPath:
splitTrafficSegmentationAndAddTo:with:shouldSnap:
routeStart
routeEnd
snappedPath
trafficSpeed
startDistance
setStartDistance:
_overlay
_section
_snappedPath
_points
_distances
_distanceSnapping
_routeStart
_routeEnd
_startDistance
_trafficSpeed
_sectionLengthScaleFactor
initWithOverlay:section:points:pointCount:reversePoints:transform:routeStartIndex:routeEndIndex:lineID:tileZ:vertexPrecision:
initWithOverlay:section:points:pointCount:reversePoints:transform:routeStartIndex:routeEndIndex:lineID:
vertexEqualityTolerance
_lineID
_vertexEqualityTolerance
initWithOverlay:section:points:pointCount:routeStartIndex:routeEndIndex:
edges
routeOffsets
roadName
_roadName
cancelAllForClient:
data
code
domain
sharedReachability
reportLoadFailure:
errorWithDomain:code:userInfo:
loadKey:priority:forClient:options:reason:qos:signpostID:auditToken:callbackQ:beginNetwork:callback:
cancelKey:forClient:
cancelAllForClientSynchronous:
expireTilesWithPredicate:
unsignedIntValue
proceduralRoadAlpha
compareTo:
captureUserAction:target:value:
coordinate
presentationCoordinate
setPresentationCoordinate:
tracking
setMode:
mode
presentationCourse
setPresentationCourse:
showCourse
setShowCourse:
setStale:
setScale:
setAnnotation:
setAnimatingToCoordinate:
enabled
setEnabled:
puck
stale
animatingToCoordinate
_tracking
_animatingToCoordinate
_stale
_puckStyleAnimation
polylines
initWithIncidentData:worldPoint:
destroyAnchor
_determineHardware
_calculateMemSize
roadsWithSimpleLineMeshesAvailable
tileMaximumLimit:
tilePrefetchNumberOfScreens
supportsHiResRTT
canMakeSharingThumbnails
isPad
shouldDrawWhenReady
supportsHiResBuildings
shouldStyleLabelsInParallel
tileDecodeQueueWidth
memorySize
useCheapTrafficShader
supportsARMode
_memSize
_numCPUs
_isMac
_proceduralRoadAlpha
_useCheapTrafficShader
_supportsBuildingStrokes
_supports3DBuildingStrokes
_lowPerformanceDevice
_supportsCoastlineGlows
_supportsPerFragmentLighting
_supportsARMode
layer
buildingId
styleQueries
wallTexture
maximumSectionLength
venueWallMeshes
commitRangesToVenueWallRenderItemBatcher:forMeshAtIndex:cullingMask:
venueWallEndMeshes
commitRangesToVenueWallEndCapRenderItemBatcher:forMeshAtIndex:cullingMask:
venueWallHorizontalStrokeMeshes
commitRangesToHorizontalVenueWallStrokeRenderItemBatcher:forMeshAtIndex:cullingMask:
venueWallVerticalStrokeMeshes
commitRangesToVerticalVenueWallStrokeRenderItemBatcher:forMeshAtIndex:cullingMask:
cullingMask
setNeedsTextureUpdate
setFlyoverContainer:
indexOfObjectIdenticalTo:
insertObject:atIndex:
removeObject:
setShowTraffic:
uniqueRouteID
traffic
_updateBoundingMapRegion
_updateContainsTransit
setSelectedPolyline:
setFocusedPolyline:
setHasFocus:
postNotificationName:object:
addPolyline:
removePolyline:
focusedPolyline
_polylines
_boundingMapRegion
_observers
_selectedPolyline
_focusedPolyline
_containsTransit
_showTraffic
polygonsCount
polygons
totalBuildingFootprintsCount
totalThreeDBuildingsCount
venuesCount
venues
venueBuildingsCount
venueBuildings
junctionsCount
pointsOnRoad
junctions
overpasses
coastlinesCount
coastlines
transitLinkCount
transitLinks
_receivedMemoryNotification
addObserver:selector:name:object:
_receivedFlushTileCachesNotification
_receivedLocalChangedNotification
removeObserver:name:object:
_target
_selector
_memoryNotificationEventSource
initWithModifiers:
setText:
setTransitLineColor:
setInteractive:
setNavMode:
setTransitMode:
setSearchResult:
setZoom:
setVariant:
setCountryCode:
_iconModifiers
_interactive
_nightMode
_navMode
_transitMode
_searchResult
_zoom
_variant
_countryCode
image
imageSize
fillColor
haloColor
glyphColor
calloutFillColor
calloutHaloColor
calloutTextColor
calloutShape
isBalloonShape
opacity
_iconImage
_fillColor
_haloColor
_glyphColor
_calloutFillColor
_calloutHaloColor
_calloutTextColor
_internalIconManager
_usingSingletonIconManager
_iconManagerReleaseSource
hasPrefix:
substringFromIndex:
substringWithRange:
scannerWithString:
scanHexInt:
lineVertices
setEdgePadding:
addPoints:
removeObserver:withType:
addObserver:withType:
routeContextStateDidChange:
_observer
_observedContexts
_anchorWithContext:
_updateCachedPoint
anchorWorldPointDidChange:
pointInLayer:
pointOffsetForDistanceOffset:
followsTerrain
setFollowsTerrain:
displayLayer
_anchor
_followsTerrain
_screenPointInCanvas
_canvasSize
_cameraContext
_anchorManager
_lastCoordinate
_isUpdating
_pointsPerMeter
_displayLayer
reset
_step
stateAtTime:
projectedCourse
projectedLocationOnRoute
hasStateAtTime:
projectFromLocation:routeMatch:speedMultiplier:
projectedPosition
appendPosition:atTime:
setTarget:
updateLocation:routeMatch:
updateVehicleHeading:
target
lastProjectedLocation
setLastProjectedLocation:
tracePlaybackSpeedMultiplier
setTracePlaybackSpeedMultiplier:
behavior
setBehavior:
_animation
_curve
_locationProjector
_vehicleHeading
_pausedCount
_suspended
_tracePlaybackSpeedMultiplier
_behavior
_lastProjectedPosition
_lastProjectedLocation
trafficColorsCount
trafficColorOffsetsCount
trafficColorOffsets
trafficColors
maneuverDisplayEnabled
initWithLabelMarkerHandle:
actualHandle
featureType
featureIndex
tileX
tileY
tileZ
tileStyle
tileVersion
_actualHandle
transitLineColor
shieldTextLocale
initWithImageKey:
color
text
_imageKey
initWithLabelMarkerPtr:
_bounds
calloutAnchorPointWithCanvasSize:canvasScale:snapToPixels:
subtext
dataIconImageKeys
iconImageKeys
calloutAnchorRect
isSelectable
isDragged
setIsDragged:
isAlongSelectedTransitLine
isVisible
isTextVisible
isOneWayArrow
isTrafficIncident
isTrafficCamera
isRouteEta
isVenueButton
isFlyoverTour
isTransit
isTransitLine
isTransitAccessPoint
hasBusinessID
businessID
featureIDs
countFeatureIDs
venueBuildingID
venueLevelID
venueComponentID
venueFloorOrdinal
venueLookInsideFloorOrdinal
hasVenueLookInsideFloorOrdinal
venueComponentType
positionOfInterest:zoom:
featureTile
incident
featureAnnotation
featureHandles
relatedTexts
relatedSubTexts
imageKeys
shields
setLabelPressed:
setIsPickedIconDrawnExternally:
screenPointToScrollRelativeToWithCanvasSize:canvasScale:
screenCollisionBounds
isLabelHitAtScreenPoint:selectableLabelsOnly:
selectionType
pickedLabelBalloonBehavior
animationID
sortKey
elementCount
debugAnchorPointString
isCluster
isLeafCluster
clusterContentBounds
clusterFeatureCount
clusterFeatureAnnotations
isClusterChild
parentClusterLabelMarker
_labelMarker
initWithLabelImageKey:
setImageCenter:
updateWithStyleManager:
updateCachedStyles
clearRouteAttributes
setRouteAttributes:
initWithOptions:capacity:
clearAdditionalRoutesToFrame
_notifyObserversStateChanged
unsignedIntegerValue
navContextStateDidChange:
navContextCameraHeadingOverrideDidChange:
updateWithNewRoute:currentStepIndex:
setRouteMatch:
setCurrentStepIndex:
groupedManeuverCount
clearPointsToFrame
addPointToFrame:
enumeratePointsToFrameUsingBlock:
setNavigationCameraHeadingOverride:
navigationCameraHeadingOverride
addRouteToFrame:divergenceCoord:convergenceCoord:
enumerateAdditionalRoutesToFrameUsingBlock:
currentStepIndex
groupedManeuverCounts
setGroupedManeuverCounts:
routeMatch
_route
_routeMatch
_currentStepIndex
_pointsToFrame
_groupedManeuverCounts
_navCameraHeadingOverride
_additionalRoutesToFrame
_navigationCameraHeadingOverride
date
initWithCollectionPoint:
collectionPoint
collectionDate
canMoveToMarker
pointId
buildId
_collectionPoint
_coordinate
dynamicStepHandler
setDynamicStepHandler:
_dynamicStepHandler
calculateGeocentricDirectionForSunX:Y:Z:
lastPathComponent
stringByDeletingPathExtension
pathExtension
stringByDeletingLastPathComponent
setName:
dictionaryRepresentation
numberWithUnsignedInt:
allocWithZone:
copyWithZone:
hasName
setAnchorPointX:
setHasAnchorPointX:
hasAnchorPointX
setAnchorPointY:
setHasAnchorPointY:
hasAnchorPointY
setIconRectX:
setHasIconRectX:
hasIconRectX
setIconRectY:
setHasIconRectY:
hasIconRectY
setIconRectWidth:
setHasIconRectWidth:
hasIconRectWidth
setIconRectHeight:
setHasIconRectHeight:
hasIconRectHeight
setMatchingStyleAttributeKey:
setHasMatchingStyleAttributeKey:
hasMatchingStyleAttributeKey
setMatchingStyleAttributeValue:
setHasMatchingStyleAttributeValue:
hasMatchingStyleAttributeValue
setMatchingStyleAttributeLongValue:
setHasMatchingStyleAttributeLongValue:
hasMatchingStyleAttributeLongValue
setSize:
setHasSize:
hasSize
readFrom:
writeTo:
copyTo:
mergeFrom:
atlasIndex
setAtlasIndex:
quadIndex
setQuadIndex:
anchorPointX
anchorPointY
iconRectX
iconRectY
iconRectWidth
iconRectHeight
matchingStyleAttributeKey
matchingStyleAttributeValue
matchingStyleAttributeLongValue
_matchingStyleAttributeLongValue
_anchorPointX
_anchorPointY
_atlasIndex
_iconRectHeight
_iconRectWidth
_iconRectX
_iconRectY
_matchingStyleAttributeKey
_matchingStyleAttributeValue
_quadIndex
_size
_has
initWithQueue:
setDidChangeActiveTileGroup:
setExperimentConfigurationDidChange:
shouldUseTestTileLoader
decodedRepresentation
reportTileLoadSuccess:
loadKey:additionalInfo:priority:forClient:options:reason:qos:signpostID:auditToken:callbackQ:beginNetwork:callback:
reportCorruptTile:
setServerProxyClass:
initWithConfiguration:
registerTileLoader:
hasTimeToLiveSeconds
timeToLiveSeconds
availableTiles
availableTilesCount
minimumZoomLevelInRect:
version
lightingStopTime
currentCalendar
dateBySettingHour:minute:second:ofDate:options:
lightingStoppedTimeHour
initWithTimeInterval:sinceDate:
lightingAccelerateTime
timeIntervalSinceDate:
lightingEnableAmbient
lightingEnableLight1
lightingEnableLight2
lightingEnableLight3
lightingOverrideAmbient
lightingOverrideLight1
lightingOverrideLight2
lightingOverrideLight3
overrideLight1Azimuth
overrideLight1Altitude
overrideLight2Azimuth
overrideLight2Altitude
overrideLight3Azimuth
overrideLight3Altitude
overrideAmbient
overrideLight1
overrideLight2
overrideLight3
initWithLocation:date:body:
azimuth
maxAttributeSetsPerGroup
indexOfObject:
initWithStyleQuery:tileZoom:fixedAroundCentroid:contentScale:
selectedStyleQueries
tileZoom
indexForGeoFeatureAttributes:
willAddDataWithAccessor:
didFinishAddingData
canAcceptPolygon:
isFixedSize
centroid
_cullingMask
_fillMeshInfo
_fillMeshes
_fillCullingGroups
_strokeCullingGroups
_venueCullingGroups
_venueEndCapCullingGroups
_venueWallHorizontalStrokeCullingGroups
_venueWallVerticalStrokeCullingGroups
_polygonEdges
_featureIds
_boundingBox
_tileZoom
_contentScale
_fillRenderItemBatchers
_strokeRenderItemBatchers
_centroid
_attributeSets
_styleQueries
_selectedStyleQueries
_routeAttributes
_isFixedSize
_stylesUpToDate
_hasRouteAttributes
setAtlas:
setIcons:
addAtlas:
addIcons:
atlasCount
clearAtlas
atlasAtIndex:
iconsCount
clearIcons
iconsAtIndex:
atlas
icons
_atlas
_icons
setTexture:
texture
quadWidth
setQuadWidth:
quadHeight
setQuadHeight:
_quadHeight
_quadWidth
_texture
disableGlyphTextureAtlas
disableIconTextureAtlas
transitLineCount
transitLines
transitStationTransferCount
transitStationTransfers
transitNodeCollapseIDCount
transitNodeCollapseIDs
transitNodeCollapseIndices
positionClampedToCameraRestriction:delta:
isEmpty
clampedPositionForOrigin:delta:
_panLastScreenPoint
_beganPitch
_zoomAnimation
_mbValid
useType
overrideNeworkDefaultsBaseSSLPMSwitch
labelBaseSSLPMEnabled
maneuverStartPointIndex
maneuverRoadOrExitName
geoStep
drivingSide
initWithGEOComposedRouteStep:
createLabelWithNavContext:artworkCache:
prepareStyleVarsWithContext:
maneuverSign
_maneuverSign
_worldPoint
_type
_drivingSide
_isVisible
setVariants:
setGenericShieldStyleInfo:
addVariants:
variantsCount
clearVariants
variantsAtIndex:
hasGenericShieldStyleInfo
variants
genericShieldStyleInfo
_genericShieldStyleInfo
_variants
labelUpdateMapTilesContinuously
labelCollisionDisabled
labelCollideContinuously
labelTileDecodeEnabled
disableBackgroundLabelLayout
paintLabelRoadFeatures
paintLabelCounts
paintLabelCollisionLines
textlessPOIsEnabled
textlessPOIsMinZoom
displayTextureAtlas
textureAtlasPageIndex
textureAtlasIndex
labelFlipAlternatePositionsEnable
labelHideLineFeatures
labelHidePointFeatures
hideDirectionalArrows
hideClientPositionedFeatures
hideServerPositionedRoadFeatures
hideServerPositionedTransitFeatures
keepTooCloseServerPositionedTransitFeatures
labelTransitLineCollisionEnabled
labelHighlightingVerboseLoggingEnabled
labelHighlightingTransitFeaturesOnly
debugOverlayOffsetX
debugOverlayOffsetY
labelFacingCullDisabled
labelDedupingDisabled
labelOcclusionDisabled
labelAutoOffsetRoadText
shouldOverrideSuperSampleKernelSize
sdfGlyphSuperSampleKernelSize
shouldUseSDFSuperSampling
shouldUseSDFGlyphs
shouldOverrideUpscaleFactor
sdfGlyphShaderUpscaleFactor
tileRequest
keyList
stringByAppendingPathComponent:
initWithData:
tileRequester:receivedData:tileEdition:tileSetDB:tileSet:etag:forKey:userInfo:
tileRequester:receivedError:forKey:
tileRequesterFinished:
tileProviderIdentifier
setShields:
addShields:
shieldsCount
clearShields
shieldsAtIndex:
_shields
setFontName:
setNonDigitFontName:
clearLayers
numberWithFloat:
centerPointsCount
clearCenterPoints
centerPointAtIndex:
addCenterPoint:
layersCount
layerAtIndex:
addLayer:
setHasAtlasIndex:
hasAtlasIndex
setHasQuadIndex:
hasQuadIndex
setMinDigits:
setHasMinDigits:
hasMinDigits
setMaxDigits:
setHasMaxDigits:
hasMaxDigits
setTextBaseline:
setHasTextBaseline:
hasTextBaseline
setCenterOffsetX:
setHasCenterOffsetX:
hasCenterOffsetX
hasFontName
setFontSize:
setHasFontSize:
hasFontSize
setFontColor:
setHasFontColor:
hasFontColor
setTextStroke:
setHasTextStroke:
hasTextStroke
setTextShadow:
setHasTextShadow:
hasTextShadow
hasNonDigitFontName
setNonDigitFontSize:
setHasNonDigitFontSize:
hasNonDigitFontSize
centerPoints
setCenterPoints:count:
layers
setLayers:count:
setHasBackgroundColor:
hasBackgroundColor
setBorderColor:
setHasBorderColor:
hasBorderColor
setCapWidthLeft:
setHasCapWidthLeft:
hasCapWidthLeft
setCapWidthRight:
setHasCapWidthRight:
hasCapWidthRight
setPaddingLeft:
setHasPaddingLeft:
hasPaddingLeft
setPaddingRight:
setHasPaddingRight:
hasPaddingRight
textMaskColor
setTextMaskColor:
setHasTextMaskColor:
hasTextMaskColor
lineSpacing
setLineSpacing:
setHasLineSpacing:
hasLineSpacing
setNonDigitFontColor:
setHasNonDigitFontColor:
hasNonDigitFontColor
minDigits
maxDigits
textBaseline
centerOffsetX
fontName
fontSize
fontColor
textStroke
textShadow
nonDigitFontName
nonDigitFontSize
backgroundColor
borderColor
capWidthLeft
capWidthRight
paddingLeft
paddingRight
nonDigitFontColor
_textShadow
_layers
_layersCount
_layersSpace
_textStroke
_fontColor
_nonDigitFontColor
_centerPoints
_backgroundColor
_borderColor
_capWidthLeft
_capWidthRight
_centerOffsetX
_fontName
_fontSize
_lineSpacing
_maxDigits
_minDigits
_nonDigitFontName
_nonDigitFontSize
_paddingLeft
_paddingRight
_textBaseline
_textMaskColor
initWithType:
setMinZoom:
setMaxZoom:
initWithTimeIntervalSince1970:
setWorldPoint:
setLocation:
significance
laneClosureType
laneClosureCount
incidentId
street
crossStreet
info
startTime
endTime
updateTime
hasSameIdentifier:
initWithRouteIncident:routeRelevance:
uniqueID
title
subtitle
setIsOnSelectedRoute:
routeOffsetInMeters
setRouteOffsetInMeters:
startDate
endDate
lastUpdatedDate
_title
_subtitle
_routeRelevance
_significance
_isNotForDisplay
_isOnSelectedRoute
_routeOffsetInMeters
_street
_crossStreet
_info
_startDate
_endDate
_lastUpdatedDate
_uniqueID
_uniqueString
initWithBytes:length:encoding:
whitespaceCharacterSet
stringByTrimmingCharactersInSet:
setCurrentPoint:
updateCurrentPointView:
isAnimationsRunning
zoomAnimatedWithDuration:duration:completion:
_setHeading:
cancelPendingMoveExceptBump
mapLayerWillAnimateToLocation:
cancelPendingMove
forceBumpNextTap
forceBumpAll
runBumpAnimation:targetPoint:
setForceBumpNextTap:
animatePath:withTarget:lookAtTarget:constantLod:completionHandler:
stopAnimationsExceptBump
stopAnimations
isAnimationsRunningExceptBump
zoomAnimated:completion:
slowMotionBump
setMuninTapState:
screenPointWithOffset:
moveToPoint:withHeading:withPitch:animated:completionHandler:
_horizontalFieldOfView:
_verticalFieldOfView:
_zoomRubberBandFov:
setWidestFieldOfView:
setCameraFrame:
currentPoint
setCurrentSegment:
virtualParallaxEnabled
setVirtualParallaxEnabled:
_muninSceneLogic
_currentPointSegment
_pathAnimator
_bumpAnimator
_panning
_panStopping
_panTranslation
_panAnimation
_pinching
_pinchZoomOffset
_pinchStartFieldOfView
_pinchResetAnimation
_virtualParallaxEnabled
_cameraOffsetFactor
_offsetAnimation
_lastUpdateTime
_panSpring
_heading
_pitch
_restrictWidestFieldOfView
_widestFieldOfView
_rigPosition
_previousCameraFrame
muninSlowMotion
muninIntermediatePointStep
mapLayerWasUnableToAnimate
ribbonCrispness
transitSystemInfoForFeatureID:
initWithStyleAttributes:
transitLinkLabelAnnotationCount
transitLinkLabelAnnotations
initWithRouteContext:transitSupport:
initWithTransitSupport:andRouteLine:
timeIntervalSinceReferenceDate
setObserver:
routeLineDidUpdateSections:
_transitSupport
_routeLine
_routeContext
textDropShadowOffsetsCount
clearTextDropShadowOffsets
textDropShadowOffsetAtIndex:
addTextDropShadowOffset:
setHasStyle:
hasStyle
textColor
setTextColor:
setHasTextColor:
hasTextColor
setTextStrokeSize:
setHasTextStrokeSize:
hasTextStrokeSize
setTextStrokeColor:
setHasTextStrokeColor:
hasTextStrokeColor
textDropShadowOffsets
setTextDropShadowOffsets:count:
setTextDropShadowSize:
setHasTextDropShadowSize:
hasTextDropShadowSize
textDropShadowColor
setTextDropShadowColor:
setHasTextDropShadowColor:
hasTextDropShadowColor
textStrokeSize
textStrokeColor
textDropShadowSize
_textDropShadowOffsets
_style
_textColor
_textDropShadowColor
_textDropShadowSize
_textStrokeColor
_textStrokeSize
initWithString:attributes:
initWithCGImage:scale:
localRenderBounds
localCollisionBounds
_line
_frame
_framesetter
_signMetrics
_textMetrics
_generatedMetrics
_signColoring
_glyph
_imageLock
initWithEnrouteNotice:
hasSpeedThreshold
speedThreshold
hasSpeedLimitText
initWithTrafficCamera:
isSpeedLimitCamera
_isAboveSpeedThreshold
_speedLimit
_speedLimitText
_speedThreshold
raise:format:
initWithEtaText:glyphType:tollCurrencyType:
glyphType
tollCurrencyType
initWithEtaText:
_etaText
_glyphType
_tollCurrencyType
initWithComposedRoute:etaDescription:
initWithComposedRoute:etaText:
setEtaDescription:
_etaDescription
_hasFocus
initWithComposedRoute:etaDescription:divergenceRouteCoordinate:convergenceRouteCoordinate:
initWithComposedRoute:etaText:divergenceRouteCoordinate:convergenceRouteCoordinate:
divergenceCoordinate
convergenceCoordinate
setEtaComparisionToMain:
_divergenceCoordinate
_convergenceCoordinate
_etaComparisonToMain
initWithRouteInfo:useType:
_hashTableForObserverType:
_setHasContextChangedForObserverType:withValue:
setWithArray:
isEqualToSet:
initWithComposedRoute:useType:
setInspectedLegIndex:
setInspectedStepIndex:
setPuckRadius:
setPuckSnappedStopID:
setAlternateRoutes:
addShareSections:shareCount:
setRouteOffset:
setCurrentLegIndex:
setSnappingToTransitLines:
puckLocation
setPuckLocation:
puckRadius
setLocale:
setAccessPointEntryName:
setAccessPointExitName:
_routeInfo
_useType
_inspectedLegIndex
_inspectedStepIndex
_currentLegIndex
_snappingToTransitLines
_puckLocation
_puckRadius
_puckSnappedStopID
_locale
_accessPointEntryName
_accessPointExitName
_hasContextChangedForLabels
_labelObservers
_hasContextChangedForRouteLine
_routeLineObservers
_hasContextChangedForAlternateRouteLines
_alternateRouteLineObservers
_alternateRoutes
_shareSections
_vk_newWeakSet
lock
member:
unlock
characterAtIndex:
getCharacters:range:
substringToIndex:
compare:options:range:locale:
initialize
original
_vk_internedString
availableLocaleIdentifiers
_vk_indexForLocale:
initWithCharacters:length:
invertedSet
rangeOfCharacterFromSet:
labelStyleOverridesDisabled
transitPointsOnRoadCount
transitPointsOnRoad
_geometry
worldIndexes
lineJoin
miterLimit
decodeObjectOfClass:forKey:
decodeInt32ForKey:
encodeObject:forKey:
encodeInt32:forKey:
supportsSecureCoding
encodeWithCoder:
initWithCoder:
initWithTextElement:
element
_element
decodeFloatForKey:
decodeBoolForKey:
encodeFloat:forKey:
encodeBool:forKey:
initWithIconElement:
_initWithCoordinate:isInjected:
encodeDouble:forKey:
encodeInt64:forKey:
decodeDoubleForKey:
containsValueForKey:
initWithCoordinate:elevation:
decodeInt64ForKey:
setFeatureID:
setBusinessID:
setVenueID:
setVenueLevelID:
setVenueComponentID:
setVenueFloorOrdinal:
setSortKey:
setTextDisplayMode:
setStyleAttributes:
setWithObjects:
decodeObjectOfClasses:forKey:
rangeOfComposedCharacterSequenceAtIndex:
muninFeatureLocationForItemCoordinate:viewPosition:groundAltitude:
_initInternalFeatureWithCoordinate:
setVenueBuildingID:
setText:locale:
setAnnotationText:locale:
setPlaceholderIconWithSize:anchorPoint:isRound:
isInjectedFeature
_feature
_dataSource
renderTarget
finalSurface
willDrawView
renderQueueForTimestamp:
multiSample
_internalRenderTarget
didDrawView
destroyRenderTarget
createRenderTarget
hasRenderTarget
renderWithTimestamp:completion:
bitmapData
renderSource
setRenderSource:
renderer
shouldRasterize
initWithSize:scale:useMultisampling:taskContext:device:signpostId:
imageTexture
allowAlpha
setAllowAlpha:
resolvedRenderTargetFormat
_resolvedRenderTargetFormat
_canMakeImage
_recreateRenderTarget
_allowAlpha
_renderSource
_flippedSurfaceTexture
_flippedRenderTarget
_yFlipPass
_format
_renderTarget
_colorBuffer
_depthStencilBuffer
_useMultisampling
_msaaResolveBuffer
_signpostId
softDealloc
activeCanvas
_transferSettingsFrom:to:
setCenterCoordinate:altitude:yaw:pitch:
loadScene
cancelFlushingTileDecodes:
cancelLoad
renderSceneWithEngine:completion:
didReceiveMemoryWarning:
didLayout
supportsSharingThumbnails
initWithSize:scale:homeQueue:signpostId:auditToken:
lookAtX:y:z:
renderSnapshot:
cancel
setRouteOverlay:
routeOverlay
routeContext
_globeCanvas
_didBecomeFullyDrawn
_hasFailedTiles
_completion
_didSoftDealloc
_routeOverlay
_initWithImage:scale:camera:
taskContext
__vkBundle
pathForResource:ofType:
initWithData:scale:
muninDebugLayer
muninShowRigTransitionInfo
muninGraphConnections
canDrawKey:
drawKey:inContext:
isDelayedRenderQueueConsumptionSupported
initWithEngine:
initWithContentScale:shouldRasterize:taskContext:device:sharedResources:signpostId:
drawInContext:
sublayers
insertSublayer:atIndex:
mapLayerMuninAvailabilityDidChange:
extrusionFillMeshVendor
commitRangesToExtrusionFillRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:
pointyRoofFillMeshVendor
commitRangesToPointyRoofFillRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:
extrusionStrokeMeshVendor
commitRangesToExtrusionStrokeRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:
clearSnappedPathsForObserver:
mapEdge
isEquivalentToNewRegion:
dontVerifyRouteToTransitSnapping
getPathsForRenderRegion:shouldSnapToRoads:verifySnapping:observer:
_updateBounds:
_updateTilesCovered:
setHasNewRoadMatches:
routeOffsetB
routeOffsetA
mapEdgeOffset
trafficTimeStamp
isTrafficUpToDate
hasNewRoadMatches
routeCoordinate
maneuverEndPointIndex
isTrafficUptoDate:
simplificationEpsilonPoints
observer
renderRegion
_matchToRoads
_hasNewRoadMatches
_inverseMatrix
_boundsUnitsPerMeter
_metersPerPoint
_boundsInWorldUnit
_simplificationEpsilonPoints
_viewUnitsPerPoint
_sections
_userLocationSection
_userLocationIndex
_userLocation
_lastTrafficTimeStamp
_retainedTiles
_renderRegion
_maneuverArrowCoordinates
_builtViewUnitsPerPoint
initWithCGImage:scale:usedAsTextureAndImage:
initWithData:scale:usedAsTextureAndImage:
prepareTextureWithAtlas:
_prepareTextureWithAtlas:
_prepareImage
stringByAppendingFormat:
pathForResourceWithName:
gglTexture
initWithName:scale:resourceManager:
textureCoordinates
anchorPoint
collisionRect
setAnchorPoint:
setCollisionRect:
_imageRef
_data
_gglTexture
_textureAtlasRegion
_textureCoordinates
_collisionRect
_anchorPoint
_scale
_hasCollisionRect
_hasAnchorPoint
_usedAsTextureAndImage
_isTextureReady
_isImageReady
_imageHash
defaultManager
fileExistsAtPath:
setupMapScene
enableTileAnalytics
isMainThread
setAltitudeLodScale:
setAltitudePauseLoading:
setAltitudeFreezeViewNode:
setAltitudeTexturePaging:
setAltitudeShowTileBounds:
setAltitudeTileQualityThreshold:
setAltitudeHideMeshTime:
setAltitudeFadeSpeed:
setAltitudeTourSpeedup:
setAltitudeTourSpeedupFactor:
_reloadStylesheet
_updateGlobeFromCamera
updateCameraFromGlobe
cameraPathAtIndex:
createMoveToZoomOutZoomInFrameFunction:toLatLon:
setCameraPaths:count:
setSceneDidLoadCallback:
flyoverTourAnimation:animateToStart:labelChanged:stateChange:
stopFlyoverTourAnimation
_update
_updateDebugSettings
_viewTransformSetup
updateCameraManager
sceneDidLoadCallback
setMinZoomLevel:
altitudePauseLoading
altitudeFreezeViewNode
altitudeTexturePaging
altitudeShowTileBounds
altitudeShowTriggerBounds
altitudeMipmapSatellite
altitudeMipmapFlyover
altitudeMipmapObjectTree
altitudeShowNightLight
altitudeLodScale
altitudeTileQualityThreshold
altitudeHideMeshTime
altitudeFadeSpeed
altitudeTourSpeedup
altitudeTourSpeedupFactor
altitudeDisableC3mTextureLoading
altitudePrintRenderedTilesStat
useNewRenderPath
_centerScreenPoint
disableTileAnalytics
_setDefaultFov:
overlayContainer
disableRoads
disableLabels
_globeCameraController
_disableRoads
_disableLabels
_debugSettings
_globeAdapter
_flyoverLibrary
_initialized
_canShowFlyover
_isDead
_isLoading
_isDownloading
_coarseLoading
_tourIsDownloading
_loadingStatusTracker
_sceneDidLoadCallback
_arCameraController
_arRoadDisabledState
captureTileSetStateWithTileSetStateEvent_tileSetStateType:tileSetStateEvent_newCoverage:tileSetStateEvent_oldCoverage:tileSetStateEvent_durationInOldState:
captureDisplayAnalyticWithDisplayAnalytic_displayActionTrigger:displayAnalytic_requiredResourcesAvailable:displayAnalytic_totalTime:displayAnalytic_requestedImageCount:displayAnalytic_renderedImageCount:displayAnalytic_movementDistance:displayAnalytic_meanImageSpacing:displayAnalytic_displayEvent:
lineContainerNeedsDisplay:
initWithRenderer:
initWithRouteRenderLayer:
addPersistentOverlay:
addNonPersistentOverlay:
removePersistentOverlay:
removeNonPersistentOverlay:
halfWidthForLine:styleZ:
persistentOverlays
hasPersistentOverlay:
hasNonPersistentOverlay:
nonPersistentOverlays
update
clearLineSelection
setSelected:selected:
prepareForPolygon:hasNonWaterStyle:
addPolygon:hasNonWaterStyle:accessor:triangulator:
stringByReplacingOccurrencesOfString:withString:
_localNameForResourceName:
dataForResourceWithName:fallbackBundle:fallbackNameHandler:
pathForResourceWithName:fallbackBundle:fallbackNameHandler:
isDevResourceWithName:fallbackBundle:fallbackNameHandler:
_vkBundle
snappingRegion
routeLineDatas
visibleRect
_routeLineDatas
_visibleRect
_snappingRegion
pathsForRenderRegion:inOverlay:
pathsForRenderRegion:inOverlay:excludedSegments:
pathsForRenderRegion:inOverlay:shouldSnapToTransit:verifySnapping:
unsnappedPathsInOverlay:
_getEndPoints:rect:result:
lineID
transitVertices
_validateSnappedPaths:snappedTileBounds:overlay:
pathsForRenderRegion:inOverlay:shouldSnapToTransit:
updateTraffic:
setNeedsLayoutForPolyline:
polylineOverlay:didUpdateRouteRibbon:
geoRoute
routeID
distance
_setNeedsLayout
addObjectsFromArray:
getSnappedPathsForVisibleRect:rectsToSnap:rectsToSnapCount:observer:
sortUsingComparator:
isSnapping
polyline:selectedSections:deselectedSections:
composedRouteUpdatedSnappedPaths:
composedRoute:selectedSections:deselectedSections:
composedRoute:changedSelectedRideInClusteredLeg:fromIndex:toIndex:
composedRoute:appliedTransitRouteUpdates:
initWithComposedRoute:traffic:
sectionRangeForBounds:
isSnappingForSceneTiles
routeRibbonObserver
setRouteRibbonObserver:
_composedRoute
_isReadyForSnapping
_routeRibbon
_routeRibbonObserver
_trafficTimeStamp
_trafficSegments
_selected
_traffic
arrayWithObject:
isPitching
isPinching
isPanning
isRotating
_pinchStartFocusPoint
_panStartFocusPoint
_panStartScreenPoint
_rotating
_rotateStartFocusPoint
_lastRotation
_shouldRotationRubberband
_pitching
_pitchStartFocusPoint
_pitchStartScreenPoint
_notifyCameraStateChanges
addLine:
_addOverlay:
removeLine:
_removeOverlay:
_recreateLinesIfNeeded
_updateRouteSplit
routeLineSplitAnnotation
_routeLineSplitAnnotation
_overlays
_persistentOverlays
_nonPersistentOverlays
_routeRenderLayer
_polylinesToRoutes
_routeSplit
enableLoggingInLockScreen
isInstalledInLockScreen
initWithFormat:arguments:
boolForKey:
setLightingEnableAmbient:
setLightingEnableLight1:
setLightingEnableLight2:
setLightingEnableLight3:
setLightingAccelerateTime:
setLightingStopTime:
setLightingStoppedTimeHour:
setBool:forKey:
setCustomLandmarkFromDisk:tileKey:styleKey:styleValue:
constantlyChangeTileGroupInterval
setConstantlyChangeTileGroupInterval:
setConstantlyChangeTileGroup:
setShowNavLabelOverlay:
setDrawPerformanceHUD:
setExpandedPerformanceHUD:
overlaysShouldDrawDebug
setHideDirectionalArrows:
setDisableBackgroundLabelLayout:
setLabelStyleOverridesDisabled:
setDisableGlyphTextureAtlas:
setDisableIconTextureAtlas:
setHideClientPositionedFeatures:
setHideServerPositionedRoadFeatures:
setHideServerPositionedTransitFeatures:
setKeepTooCloseServerPositionedTransitFeatures:
setEnableSignPostEvents:
setEnableTrafficFeatureLabelDebugging:
setIsInstalledInLockScreen:
setHighlightRouteLineSnappingStatus:
setEnableMuninMiniMapRoadWidths:
setEnableMuninMiniMapCollectionPoints:
setEnableMuninMiniMapRoadZData:
setEnableMuninMiniMapComposedEdgeRoadColoring:
setEnableMuninRoadNetworkMiniMap:
setDecodeStyleNames:
numPerformanceGroups
nameForPerformanceGroup:
showPerformanceGroup:
hidePerformanceGroup:
isPerformanceGroupShown:
setCustomLandmarkFromDisk:tileKey:
setCustomLandmarkFromData:tileKey:texturePath:
customLandmarkObjectGroupsForKey:
addFootprintToSuppress:
clearFootprintsToSuppress
addTileToPaint:
removeTileToPaint
setAltitudeDisableC3mTextureLoading:
setUseMetalRenderer:
setArRenderAtNativeRate:
setDisableOverlayTextConsole:
paintMapTiles
setPaintMapTiles:
setPaintSelectedMapTiles:
setSelectedMapTilesToPaint:
setPaintTiles:
setPaintRoadBoundaries:
setPaintRoadTiles:
setPaintPoiTiles:
setPaintPointTiles:
setPaintPolygonTiles:
setPaintLandcoverTiles:
setPaintVenues:
setPaintVertices:
setPaintJunctions:
setPaintCoastlines:
setPaintBuildings:
setPaintLoadReason:
setDisableRoute:
setLabelHighlighting:
setTransitHighlighting:
setLabelFacingCullDisabled:
setLabelDedupingDisabled:
setLabelCollisionDisabled:
setLabelCollideContinuously:
setLabelFlipAlternatePositionsEnable:
setLabelTileDecodeEnabled:
labelAllowDefaultStyle
setLabelAllowDefaultStyle:
setLabelUpdateMapTilesContinuously:
setLabelAutoOffsetRoadText:
setDontMatchRouteLine:
dontMapMatchToSnappedRouteLine
setDontMapMatchToSnappedRouteLine:
setDontVerifyRouteToTransitSnapping:
setShowManeuverPoints:
paintRoadSigns
setPaintRoadSigns:
paintLabelBounds
setPaintLabelBounds:
setPaintLabelRoadFeatures:
setPaintLabelCollisionLines:
setDisplayTextureAtlas:
setTextureAtlasIndex:
setTextureAtlasPageIndex:
setPaintLabelCounts:
labelerOutputIndex
setLabelerOutputIndex:
setPaintTransitCounts:
setOverrideNeworkDefaultsBaseSSLPMSwitch:
setTextlessPOIsEnabled:
setTextlessPOIsMinZoom:
setLabelBaseSSLPMEnabled:
setLabelHideLineFeatures:
setLabelHidePointFeatures:
setLoadGreenTraffic:
useStaticTrafficFeed
setUseStaticTrafficFeed:
setShowTrafficCasing:
texturedTrafficCasing
setTexturedTrafficCasing:
prioritizeTrafficSkeleton
setPrioritizeTrafficSkeleton:
paintRoadsStitchedByName
setPaintRoadsStitchedByName:
realisticWireframeEnabled
setRealisticWireframeEnabled:
setAltitudeMipmapSatellite:
setAltitudeMipmapFlyover:
setAltitudeMipmapObjectTree:
setAltitudeShowNightLight:
setAltitudePrintRenderedTilesStat:
setAltitudeShowTriggerBounds:
altitudeHighResSatellite
setAltitudeHighResSatellite:
disableTransitLineDrawing
setDisableTransitLineDrawing:
setDisableTransitLineMerging:
setDisableTransitLineGroupMerging:
dumpTransitTileContents
setDumpTransitTileContents:
dumpRouteAndPath
setDumpRouteAndPath:
setDisableIntraLinkTransitLineCrossings:
useMetalRenderer
showNavCameraDebugConsole
setShowNavCameraDebugConsole:
showNavCameraDebugConsoleAttributes
setShowNavCameraDebugConsoleAttributes:
showNavCameraDebugConsoleProperties
setShowNavCameraDebugConsoleProperties:
showNavCameraDebugLegend
setShowNavCameraDebugLegend:
showNavCameraDebugOverlay
setShowNavCameraDebugOverlay:
setRibbonCrispness:
useGeoResourceLib
setUseGeoResourceLib:
setEnableLoggingInLockScreen:
useBuildingShadowTexture
setUseBuildingShadowTexture:
enableSignPostEvents
setDisableStylesheetAnimations:
readLandmarksFromDisk
setReadLandmarksFromDisk:
drawPerformanceHUD
expandedPerformanceHUD
trackingCameraZoomFurther
setTrackingCameraZoomFurther:
holdOntoStyleAttributes
setHoldOntoStyleAttributes:
setDrawDebugTransit:
setLabelTransitLineCollisionEnabled:
setLabelHighlightingVerboseLoggingEnabled:
setLabelHighlightingTransitFeaturesOnly:
setLabelOcclusionDisabled:
footprintsToSuppress
setFootprintsToSuppress:
suppressFootprints
setSuppressFootprints:
setDebugOverlayOffsetX:
setDebugOverlayOffsetY:
landmark2DStrokeSettings
setLandmark2DStrokeSettings:
debugStyleManager
setShouldUseTestTileLoader:
constantlyChangeTileGroup
setDisableRoadSignLimit:
showNavLabelOverlay
setEnableEtaLabelDebugging:
setEnableRouteShareSectionDebugging:
setEnableEtaLabelRectDebugging:
setEtaLabelDebugScore:
setEtaLabelDebugOrientationMask:
setEnableRouteIntersectionTesting:
etaLabelsAvoidScreenEdges
setEtaLabelsAvoidScreenEdges:
enableARDebugConsole
setEnableARDebugConsole:
enableAROmniTileLoader
setEnableAROmniTileLoader:
arOverrideDefaults
setArOverrideDefaults:
arVirtualPlaneHeight
setArVirtualPlaneHeight:
arDefaultHeight
setArDefaultHeight:
arSwipeGesture
setArSwipeGesture:
arPinchGesture
setArPinchGesture:
setPaintKeysInView:
setPaintStandardLabelMapData:
setPaintPolygonLayerData:
setPaintRoadTileData:
setMuninDebugLayer:
setMuninGraphConnections:
setMuninShowRigTransitionInfo:
muninIgnorePlacesMetadata
setMuninIgnorePlacesMetadata:
muninOverrideParallax
setMuninOverrideParallax:
muninCameraPanOffset
setMuninCameraPanOffset:
muninParallaxSpring
setMuninParallaxSpring:
muninParallaxDamper
setMuninParallaxDamper:
muninParallaxScale
setMuninParallaxScale:
setMuninTransitionMinResolution:
setMuninTransitionMaxResolution:
setMuninSlowMotion:
enableMuninRoadNetworkMiniMap
muninRoadNetworkMiniMapAreaInMeters
setMuninRoadNetworkMiniMapAreaInMeters:
enableMuninMiniMapRoadWidths
enableMuninMiniMapComposedEdgeRoadColoring
enableMuninMiniMapCollectionPoints
enableMuninMiniMapRoadZData
setMuninIntermediatePointStep:
muninAvailabilityOverride
setMuninAvailabilityOverride:
overrideLod
setOverrideLod:
lodOverride
setLodOverride:
overrideIntermediateLod
setOverrideIntermediateLod:
intermediateLodOverride
setIntermediateLodOverride:
muninReplayLastTap
setMuninReplayLastTap:
muninTapState
muninOverrideFov
setMuninOverrideFov:
defaultFovPortrait
setDefaultFovPortrait:
maxFovPortrait
setMaxFovPortrait:
defaultFovLandscape
setDefaultFovLandscape:
maxFovLandscape
setMaxFovLandscape:
minFov
setMinFov:
minFovSpring
setMinFovSpring:
maxFovSpring
setMaxFovSpring:
setForceBumpAll:
setSlowMotionBump:
setOverrideAmbient:
setOverrideLight1:
setOverrideLight2:
setOverrideLight3:
setOverrideLight1Azimuth:
setOverrideLight1Altitude:
setOverrideLight2Azimuth:
setOverrideLight2Altitude:
setOverrideLight3Azimuth:
setOverrideLight3Altitude:
setLightingOverrideAmbient:
setLightingOverrideLight1:
setLightingOverrideLight2:
setLightingOverrideLight3:
setShouldUseSDFGlyphs:
setShouldOverrideUpscaleFactor:
setSdfGlyphShaderUpscaleFactor:
setShouldOverrideSuperSampleKernelSize:
setSdfGlyphSuperSampleKernelSize:
setShouldUseSDFSuperSampling:
setShouldFreezeLayoutCamera:
_disableOverlayTextConsole
_paintMapTiles
_paintSelectedMapTiles
_selectedMapTilesToPaint
_paintTiles
_paintRoadBoundaries
_paintRoadTiles
_paintPointTiles
_paintPolygonTiles
_paintVertices
_paintJunctions
_paintCoastlines
_paintBuildings
_paintLoadReason
_disableRoute
_labelHighlighting
_transitHighlighting
_labelCollisionDisabled
_labelFacingCullDisabled
_labelDedupingDisabled
_labelFlipAlternatePositionsEnable
_labelTileDecodeEnabled
_disableBackgroundLabelLayout
_labelAllowDefaultStyle
_labelUpdateMapTilesContinuously
_labelStyleOverridesDisabled
_labelAutoOffsetRoadText
_dontMatchRouteLine
_dontMapMatchToSnappedRouteLine
_highlightRouteLineSnappingStatus
_highlightRouteLineSnappingRegion
_dontVerifyRouteToTransitSnapping
_showManeuverPoints
_paintRoadSigns
_paintLabelBounds
_paintLabelRoadFeatures
_displayTextureAtlas
_disableGlyphTextureAtlas
_disableIconTextureAtlas
_textureAtlasIndex
_textureAtlasPageIndex
_paintLabelCollisionLines
_paintLabelCounts
_labelerOutputIndex
_paintTransitCounts
_hideDirectionalArrows
_hideClientPositionedFeatures
_hideServerPositionedRoadFeatures
_hideServerPositionedTransitFeatures
_keepTooCloseServerPositionedTransitFeatures
_overrideNeworkDefaultsBaseSSLPMSwitch
_textlessPOIsEnabled
_textlessPOIsMinZoom
_labelBaseSSLPMEnabled
_labelHideLineFeatures
_labelHidePointFeatures
_loadGreenTraffic
_showTrafficCasing
_texturedTrafficCasing
_prioritizeTrafficSkeleton
_paintRoadsStitchedByName
_realisticWireframeEnabled
_altitudePauseLoading
_altitudeFreezeViewNode
_altitudeTexturePaging
_altitudeShowTileBounds
_altitudeHighResSatellite
_altitudeMipmapSatellite
_altitudeMipmapFlyover
_altitudeMipmapObjectTree
_altitudeShowNightLight
_altitudePrintRenderedTilesStat
_altitudeDisableC3mTextureLoading
_altitudeShowTriggerbounds
_disableTransitLineDrawing
_disableTransitLineMerging
_disableTransitLineGroupMerging
_dumpTransitTileContents
_dumpRouteAndPath
_disableIntraLinkTransitLineCrossings
_useMetalRenderer
_showNavCameraDebugConsole
_showNavCameraDebugConsoleAttributes
_showNavCameraDebugLegend
_ribbonCrispness
_useGeoResourceLib
_debugOverlayOffsetX
_debugOverlayOffsetY
_altitudeLodScale
_altitudeTileQualityThreshold
_altitudeHideMeshTime
_altitudeFadeSpeed
_altitudeTourSpeedup
_altitudeTourSpeedupFactor
_isInstalledInLockScreen
_enableLoggingInLockScreen
_useBuildingShadowTexture
_layoutContinuously
_enableSignPostEvents
_readLandmarksFromDisk
_drawPerformanceHUD
_expandedPerformanceHUD
_holdOntoStyleAttributes
_footprintsToSuppress
_suppressFootprints
_customTiles
_drawDebugTransit
_labelTransitLineCollisionEnabled
_labelHighlightingVerboseLoggingEnabled
_labelHighlightingTransitFeaturesOnly
_shouldUseTestTileLoader
_constantlyChangeTileGroup
_constantlyChangeTileGroupInterval
_disableRoadSignLimit
_showNavLabelOverlay
_enableTrafficFeatureLabelDebugging
_enableEtaLabelDebugging
_enableRouteShareSectionDebugging
_enableEtaLabelRectDebugging
_etaLabelDebugScore
_etaLabelDebugOrientationMask
_etaLabelsAvoidScreenEdges
_enableRouteIntersectionTesting
_forceEtaLabelPlacement
_traceEtaDebugLog
_arOverrideDefaults
_arVirtualPlaneHeight
_arDefaultHeight
_arSwipeGesture
_arPinchGesture
_arRenderAtNativeRate
_paintKeysInView
_paintStandardLabelMapData
_paintPolygonLayerData
_paintRoadTileData
_muninDebugLayer
_muninGraphConnections
_muninShowRigTransitionInfo
_muninIgnorePlacesMetadata
_muninOverrideParallax
_muninCameraPanOffset
_muninParallaxSpring
_muninParallaxDamper
_muninParallaxScale
_muninTransitionMinResolution
_muninTransitionMaxResolution
_muninSlowMotion
_enableMuninRoadNetworkMiniMap
_muninRoadNetworkMiniMapAreaInMeters
_muninIntermediatePointStep
_muninAvailabilityOverride
_overrideLod
_lodOverride
_overrideIntermediateLod
_intermediateLodOverride
_muninReplayLastTap
_muninTapState
_defaultFovPortrait
_maxFovPortrait
_defaultFovLandscape
_maxFovLandscape
_minFov
_minFovSpring
_maxFovSpring
_forceBumpNextTap
_forceBumpAll
_slowMotionBump
_overrideAmbient
_overrideLight1
_overrideLight2
_overrideLight3
_overrideLight1Azimuth
_overrideLight1Altitude
_overrideLight2Azimuth
_overrideLight2Altitude
_overrideLight3Azimuth
_overrideLight3Altitude
_lightingOverrideAmbient
_lightingOverrideLight1
_lightingOverrideLight2
_lightingOverrideLight3
_lightingEnableAmbient
_lightingEnableLight1
_lightingEnableLight2
_lightingEnableLight3
_lightingAccelerateTime
_lightingStopTime
_lightingStoppedTimeHour
_shouldUseSDFGlyphs
_shouldOverrideUpscaleFactor
_sdfGlyphShaderUpscaleFactor
_shouldOverrideSuperSampleKernelSize
_sdfGlyphSuperSampleKernelSize
_shouldUseSDFSuperSampling
_shouldFreezeLayoutCamera
_decodeStyleNames
_customLandmarks
_paintPoiTiles
_paintLandcoverTiles
_paintVenues
_labelCollideContinuously
_useStaticTrafficFeed
_showNavCameraDebugConsoleProperties
_showNavCameraDebugOverlay
_disableStylesheetAnimations
_trackingCameraZoomFurther
_labelOcclusionDisabled
_enableARDebugConsole
_enableAROmniTileLoader
_enableMuninMiniMapRoadWidths
_enableMuninMiniMapComposedEdgeRoadColoring
_enableMuninMiniMapCollectionPoints
_enableMuninMiniMapRoadZData
_muninOverrideFov
_landmark2DStrokeSettings
_debugStyleManager
hasVisibleSigns
hasVisibleShields
_updateWithNavContext:threshold:
depthFromRoute
hasShield
_updateWithNavContext:
isFreeway
isOnDualCarriageway
worldUnitsPerMeter
_worldRoadPoints:
nextRoadSegmentForRoad:
junctionForRoad:nearJunction:crossTileEdge:
isMultiRoadIntersection
_worldPointForRoadOffset:worldPoint:
labelWithType:
desiredOffsetDistance
outgoingRoad
direction
_findRoadOffsetForDistanceToRay:rayStart:rayVector:roadGraph:
incomingRoad
_findLabelAnchorPoint:isShieldLabel:desiredOffsetDistance:maxOffsetDistance:minJunctionDistance:roadGraph:
setDesiredOffsetDistance:
roadSignAlignment
_newLabelWithNavContext:isShieldLabel:worldPoint:alignment:artworkCache:
setDisplayID:
clearRoadSign
clearRoadShield
setAlignment:
initWithRoadEdge:navJunctionA:routeOffset:tile:
cstrName
roadClass
isOnewayToJunction
getRoadEdge:
matchesRoadEdge:
matchesRoad:
shieldGroup
createLabelWithNavContext:isShieldLabel:desiredOffsetDistance:maxOffsetDistance:minJunctionDistance:minRouteDistance:roadGraph:artworkCache:
recreateRoadSignWithAlignment:navContext:artworkCache:
recreateRoadShieldWithNavContext:artworkCache:
appendSimplifiedWorldRoadPoints:
setDirection:
setIsOnRoute:
setIsStartOfRoadName:
setIsInGuidance:
setIsGuidanceStepStart:
routeCrossProduct
setRouteCrossProduct:
junctionB
setIntraRoadPriority:
areLabelsDisabled
setAreLabelsDisabled:
isRoadLabelUnique
setIsRoadLabelUnique:
navJunctionA
suppressRoadSignIfShieldPresent
tile
_tile
_vertexIndexA
_vertexIndexB
_junctionA
_junctionB
_navJunctionA
_simplifiedPoints
_direction
_isRoadLabelUnique
_isStartOfRoadName
_isInGuidance
_isGuidanceStepStart
_areLabelsDisabled
_routeCrossProduct
_intraRoadPriority
_length
_shieldDisplayGroup
_shieldGroup
_roadSign
_roadShield
_isVisibilityCached
_cachedSignVisibility
_cachedShieldVisibility
_hasVisibleSigns
_hasVisibleShields
_suppressRoadSignIfShieldPresent
initWithJunctions:
stepIndexForPointIndex:
_refreshGuidanceRoadNames
_updateRoadsInGuidance
_updateCurrentRoadInfo
setCurrentRoadName:
setCurrentShieldGroup:
setTiles:
initWithRoadName:point:
predicateWithBlock:
filterUsingPredicate:
routeJunctionsHaveChanged
createLabelWithNavContext:isDrivingSideRight:artworkCache:
junctionSign
_tryAddLabel:navContext:labelCollisionEnabled:
isPriorRouteCollinearWithRoad:distance:
_createOrUpdateLabelForRoad:isShield:navContext:
orientationForRoadSign:roadLabel:navContext:
alignment
displayGroup
_collideLabel:activeLabel:labelsToRemove:
removeObjectForKey:
isShieldLabel
currentLocationText
collideRouteWithLabel:routeCrossProduct:context:
unitHeading
_generateCurrentRoadSignWithContext:
_updateActiveRouteRange
_reloadRouteJunctions
_addJunctionsForTile:
startingLabelLayoutWithContext:routeUserOffset:
initWithArray:
isRoadLabel
_addLabelsAtJunctions:withContext:maxLabelsToAdd:
_addLabelsForJunctions:withContext:maxLabelsToAdd:useAllJunctions:placeShieldsFrontToBack:
prepareOppositeCarriagewayJunctions
oppositeCarriagewayJunctions
countReadyJunctionLists
junctionListForDepth:
offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:
roads
offRouteJunctionList
_tryAddRoadSignForJunction:navContext:labelCollisionEnabled:
_tryAddRoadSignForRoad:isShield:navContext:labelCollisionEnabled:
reverseObjectEnumerator
clippedFront
clippedBack
addRouteRoadEdge:atA:isRouteRefineJunction:tile:junctionList:
evaluateCrossStreets
setDepthFromRoute:
removeObjectsInArray:
isOverpass
overpassJunctionForJunction:
isIntraRamp
setIsRouteOverpass:
evaluateCrossStreetsUsingRouteJunction:
evaluateDualCarriagewayForJunction:outputJunctionList:
_updateRoadStarts
_updatePreferredLabelPlacements
_initalizeCurrentRoadInfo
_updateUniqueOffRouteRoads
currentRoadName
initWithName:shieldGroup:offset:
routePoint
requiredLabelPlacement
setPreferredLabelPlacement:
_findRouteOverlappingJunctionFrom:routeJunctions:lookBackward:firstOverlap:secondOverlap:
isJunctionLabel
currentRoadSign
isNavMode
drawRoadSigns
setDrawRoadSigns:
currentShieldGroup
debugDisableRoadSignLimit
artworkCache
debugEnableShieldsOnRouteLine
setDebugEnableShieldsOnRouteLine:
_needsLayout
_drawRoadSigns
_currentLocationText
_stepIndex
_checkOnRouteLabelsAlignment
_disableTileParseForOneLayout
_tiles
_pendingTiles
_junctions
_roadGraph
_activeSigns
_fadingLabels
_visibleLabelsByName
_visibleLabels
_countVisibleOnRouteRoadSigns
_countVisibleOffRouteRoadSigns
_countVisibleRoadSigns
_maxVisibleOnRouteRoadSigns
_maxVisibleOffRouteRoadSigns
_maxVisibleRoadSigns
_maxOnRoadGraphRoadSigns
_minVisibleOffRoadGraphRoadSigns
_minVisibleProceedToRouteRoadSigns
_preferRightSideLabelPlacement
_minSignOffsetDistance
_roadNamesInGuidance
_guidanceStepInfos
_routeRoadInfos
_currentRoadName
_currentRoadNameIndex
_currentShieldGroup
_checkIfRouteSubrangeChanged
_useRouteSubrange
_regenerateRoadSigns
_isStylesheetAnimating
_routeSubrangeStart
_routeSubrangeEnd
_artworkCache
_currentRoadSign
_debugDisableRoadSignLimit
_debugCachedMaxVisibleOffRouteRoadSigns
_debugCachedMaxVisibleOnRouteRoadSigns
_debugEnableShieldsOnRouteLine
_shouldLabelOppositeCarriageways
_externalCollisionLabelsForLayout
_hasPendingTilesInSnappingRegion
_needsDebugConsoleClear
_routePoint
_startPanPosition
sessionInterruptedReason
session
_trackingState
_trackingStateReason
_sessionInterruptedReason
_session
initWithStrings:locale:
getTextForKey:text:locale:
_stringDictionary
componentsSeparatedByString:
lastObject
subarrayWithRange:
objCType
getValue:
imageDataInFormat:
value:withObjCType:
pointForCoordinate:
coordinateForPoint:
_image
maneuverDisplaySteps
coordinateAtOffset:fromRoutePoint:
coordinateAtOffset:fromRouteCoordinate:
forEachRoad:
forEachEdgeInRoad:visitTwice:visitor:
forEachEdgeOnJunction:visitor:
venueFeatureMarker
initWithMUID:coordinate:
mapIdentifier
buildings
_localize
linesLabelAnnotationCount
linesLabelAnnotations
linesAnnotationBezierVertices
labelLineFeatureSections
labelLineAttributes
tileLabelLines
initWithDataSource:observer:
isClusteringEnabled
sceneState
sceneID
clearObserver
annotationsInMapRect:
dataSource:featuresDidChangeForRect:
dataSource:didChangeSceneState:
dataSource:didChangeSceneID:
transitLineForFeatureID:
transitNodeForFeatureID:
transitAccessPointForFeatureID:
initWithShieldText:locale:type:color:
setDataType:
setRelatedText:
initWithDataType:
initWithIconAttributeKey:attributeValue:
setDataValue:
invalidate
distantFuture
initWithTarget:selector:queue:
fireAfter:
disable
nextFireDate
_source
_nextFireDate
lineCap
simplifiedGeometryAtZoomLevel:
canProvideVectorData
vectorData
_renderable
sortedPointsOnRoad
_pitchAnimation
_rotationAnimation
_regionAnimation
_annotationTrackingCameraController
_gestureCameraControllerBehavior
_annotationTrackingZoomStyle
_annotationTrackingHeadingAnimationDisplayRate
_centerCoordinateDistanceRange
initWithResourceProvider:
allResourceNames
allRegionalResourceNames
debugByteCount
debugByteCountPerChapter
canDecodeTile:quickly:
decodeTile:forKey:
reprioritizeKey:forClient:newPriority:
initWithToken:
getJobForKey:
fetchDataForJob:
cancelJob:
updateJobPriority:
cancelRequests
purgeExpired:
_geoTileLoader
_vectorTileDecoder
_auditToken
_keyToJobMap
_mutex
_numDownloads
_tileLoaderClientIdentifier
composedRouteLegIndex
loadKey:additionalInfo:priority:forClient:options:reason:callbackQ:beginNetwork:callback:
activeTileSetForStyle:
_updateIsPitched
_updateCanEnter3DMode
moveTo:zoom:rotation:tilt:duration:timingCurve:completion:
moveToZoomOutZoomInTransition:height:useHeight:zoom:rotation:tilt:duration:timingCurve:completion:
moveTo:height:useHeight:zoom:rotation:tilt:duration:timingCurve:completion:
tiltTo:animated:exaggerate:
rotate:atScreenPoint:
pitch:translation:
zoomToDistance:distance:time:completionHandler:
stopGlobeAnimations
isFlyoverTourStarted
cameraPathsCount
interruptFlyoverTourAnimation
rotateTo:animated:
_centerCoordinateForMapRegion:
earthRadiusAt:
geocAngleBetween:andCoordinate:
widestLatitudeForMapRegion:
greatCircleMidPointLatitude:fromLongitude:toLongitude:
zoomForMapRegion:
animateRegionWithDuration:timingFunction:cursor:stepHandler:completionHandler:
animateToRestriction:duration:timingFunction:
radianSingleRect:westOfDatelineRect:eastOfDatelineRect:
zoomToDistance:distance:time:
slowDownFactorFromLoadProgress
adjustLoadingForAnimation:progressFactor:
tourShouldResumeWhenDoneGesturing
_isPitching
_isRotating
_wasPitched
_couldEnter3DMode
_minZoomLevel
_tourShouldResumeWhenDoneGesturing
setWithObject:
regionalResourceKeysForTileKey:scale:scenarios:
setLoadStatus:
setCameraNumber:
setLod:
canConstructPointyRoofForPolygon:building:buildingModel:scaleThreshold:
addPointyRoofForBuilding:buildingModel:scaleThreshold:styleIndex:
addExtrusionForBuilding:index:ofTotal:
shouldSuppress3DBuildingStrokes
pointyRoofStrokeMeshVendor
commitRangesToPointyRoofStrokeRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:
prepareForBuilding:forRoofStyle:scaleThreshold:
addBuilding:index:ofTotal:accessor:triangulator:prepareExtrusion:forRoofStyle:scaleThreshold:
_strokeMeshInfo
_fillMeshInfoForPointyRoofs
_strokeMeshes
_fillMeshesForPointyRoofs
_extrusionFillMeshVendor
_extrusionStrokeMeshVendor
_pointyRoofFillMeshVendor
_pointyRoofStrokeMeshVendor
_extrusionFillCullingGroups
_extrusionStrokeCullingGroups
_fillCullingGroupsForPointyRoofs
_pointyRoofFillCullingGroups
_pointyRoofStrokeCullingGroups
_flatRoofStyleQueries
_selectedFlatRoofStyleQueries
alloc
handleXPCEvent:
sendData:
recievedData:
deactivateController
propertyListWithData:options:format:error:
decodeDebugTreeData:
isActive
_connection
_mapView
_isActive
tileCoordinate
findRoads
isIntersection
exchangeObjectAtIndex:withObjectAtIndex:
_signOrientationWithDrivingSide:
_anchorCoordinateForSignOrientation:
initWithGEOJunction:routeOffset:tile:
initWithRoadEdge:atA:routeOffset:tile:
matchesLocationForJunction:
isTileEdgeJunction
isRoadTerminus
isOffRouteGraph
largestRoadClass
addRouteEdge:atA:
setSharedRouteDirection:
geoJunction
preferredLabelPlacement
distanceFromPreviousShieldLabel
setDistanceFromPreviousShieldLabel:
setIsOnDualCarriageway:
hasSharedRouteDirection
sharedRouteDirection
overpassJunction
setOverpassJunction:
isRouteOverpass
isRouteRefineJunction
setIsRouteRefineJunction:
_tileCoordinate
_geoJunction
_roads
_incomingRoad
_outgoingRoad
_distanceFromPreviousShieldLabel
_preferredLabelPlacement
_isOnDualCarriageway
_hasSharedRouteDirection
_sharedRouteDirection
_foundRoads
_isOverpass
_isRouteOverpass
_largestRoadClass
_labelFeature
_junctionSign
_depthFromRoute
_worldUnitsPerMeter
_overpassJunction
_worldCoordinate
_sortValue
_isRouteRefineJunction
setProjectedRouteMatch:
locationCoordinate
matchedCourse
isGoodMatch
speed
clientLocation
routeMatchAtDistance:from:stopAtEndOfTunnel:stopAtEndOfManeuver:date:
routeMatchBehind:
_updateCourseAndPositionFromRouteMatch
course
projectedLocation
projectedRouteMatch
_projectedRouteMatch
_projectedPosition
_projectedCourse
enablePerformanceHUD:
disablePerformanceHUD:
expandedPerformanceHUD:
setRenderDelegate:
removeFromSuperlayer
_renderQueueForTimestamp:prepareHandler:
drawToTexture:withRenderQueue:completionHandler:
setNeedsDisplayOnBoundsChange:
setOpaque:
setContentsGravity:
prepareTexture:
_didReadPixels:
setFrame:
drawToTexture:withRenderQueue:
willPresent
willUpdateFrameTexture
didUpdateFrameTexture
_layer
_activeRenderQueue
_completionHandlers
_debugConsoleManagerCreationLock
_debugConsoleManager
_depthStencil
_msaaTexture
_colorTextures
_requiresMultisampling
_snapshotContext
_readPixels
_shouldRasterize
_contentsScale
heightAtPoint:
heightForAnchor:
removeCachedValueForAnchor:
invalidateRect:
heightProvider
setHeightProvider:
_heightProvider
_anchorToHeight
floatValue
bundleForClass:
_setDelegate:
initWithMapPoints:count:
_worldIndexes
_simplifiedGeometryCache
_simplifiedGeometryCacheLock
vectorOverlayNeedsDisplay:needsFullInvalidate:
_updateStyleColor
initWithPolylines:
lineWidth
setLineWidth:
setColor:
alpha
setAlpha:
setLineJoin:
setLineCap:
setMiterLimit:
_color
_lineWidth
_alpha
_lineJoin
_lineCap
_miterLimit
_propertiesLock
initWithMapRect:lineWidth:fillColor:strokeColor:alpha:
setFillColor:
strokeColor
setStrokeColor:
_mapRect
_strokeColor
initWithPolygons:
_polygons
roadLabelTilesInScene
integerValue
numberWithInteger:
dictionaryWithObjectsAndKeys:
initWithDictionaryRepresentation:
_centerCoordinate
_yaw
setEntries:
setTextEntries:
addEntries:
addTextEntries:
entriesCount
clearEntries
entriesAtIndex:
textEntriesCount
clearTextEntries
textEntriesAtIndex:
variantType
setVariantType:
setHasVariantType:
hasVariantType
entries
textEntries
_entries
_textEntries
_variantType
renderOrder
isManeuverLabel
isEtaLabel
isTrafficCameraLabel
displayID
setMercatorPoint:
_label
_navLabelType
_navFeature
_displayGroup
_alignment
_desiredOffsetDistance
_displayID
_mercatorPoint
setFallbackImageKeys:
initWithKeyOptions:valueOptions:capacity:
addJunction:
_findTileEdgeJunctions
initializeJunctionInfos
initWithTile:
junctionForGeoJunction:
junctionAtCoordinate:
findTileEdgeJunctionAtCoordinate:
appendNavJunctionsInWorldRect:junctions:
findOppositeCarriagewayJunctionsWithRouteFeatures:distanceThreshold:
oppositeCarriagewayJunctionsValid
setOppositeCarriagewayJunctionsValid:
_geoJunctionToJunctionMap
_tileEdgeJunctions
_foundTileEdgeJunctions
_oppositeCarriagewayJunctionsValid
_oppositeCarriagewayJunctions
_junctionInfos
objectEnumerator
_junctionForRoadEdge:atA:routeOffset:tile:
_findInterTileJunctionForJunction:
_nextIntersectionForRoad:
setJunctions:
_duplicateTiles
_tileDatasByIndex
_intersections
_unitHeading
_offRouteJunctionsValid
_offRouteJunctionSelectRect
_offRouteJunctions
_routeFeatureMapValid
_routeFeatureMap
_simplifiedRouteValid
_simplifiedRoutePoints
_currentRoadStartSimplifiedPointIndex
_screenRouteValid
_screenRouteSegments
_firstPOIAligningRouteSegment
_checkIfDualCarriageWayConnectorRoad:fromJunction:toJunction:checkShields:
_updateIntersectionsForDepth:
setObject:atIndexedSubscript:
_findOffRouteJunctions
_updateSimplifiedRoute
_transformRouteToScreenWithContext:
transitLinkSections
transitLinkLineMinZoomOverrides
nonOverlappingBuildingFootprintsCount
contentsOfDirectoryAtPath:error:
hasSuffix:
stringWithContentsOfFile:encoding:error:
rangeOfString:
numberFromString:
nonOverlappingThreeDBuildingsCount
edgePadding
_edgePadding
timeZoneWithName:
secondsFromGMT
verticalStrokeCountForSection:styles:edges:
bufferSizingForStrokesOnSection:styles:edges:
prepareToStrokeSection:key:styles:paddedCount:
generateEdgeListForPolygonSection:key:
prepareToGenerateWallsForSection:styles:edges:
prepareToGenerateWallStrokesForSection:styles:edges:
addStrokeForSection:paddedCount:key:attributes:styles:cullingMask:accessor:
addWallsForSection:edges:attributes:styles:cullingMask:accessor:
addWallStrokesForSection:edges:attributes:styles:cullingMask:accessor:
updateTextures:textureManager:
_textureForName:textureManager:
initWithStyleQuery:tileZoom:layer:buildingId:contentScale:
_venueWallMeshInfo
_venueWallEndCapMeshInfo
_venueWallHorizontalStrokeMeshInfo
_venueWallVerticalStrokeMeshInfo
_venueWallMeshes
_venueWallEndMeshes
_venueWallHorizontalStrokeMeshes
_venueWallVerticalStrokeMeshes
_venueWalls
_buildingId
_maximumSectionLength
_wallTexture
styleIndexForAttributes:edgePair:
_centerCursor
_nonOffsetCenterCursor
mapLayerDidFinishInitialTrackingAnimation
_currentAnimationStartCoordinate
_currentAnimationPresentationStartCoordinate
_currentAnimationPresentationEndCoordinate
_currentAnimationEndCoordinate
mapLayerDidEnterAR:
mapLayer:didEncounterARError:
mapLayer:arSessionWasInterrupted:
mapLayerARSessionInterruptionEnded:
mapLayer:arTrackingStateDidChange:reason:
enterARModeAtCoordinate:
exitARMode
map:didEnterARMode:
arController:didEncounterError:
arController:arSessionWasInterrupted:
arControllerSessionInterruptionEnded:
arController:didChangeTrackingState:reason:
setARInterfaceOrientation:
allObjects
lineColor
clusterStyleAttributes
getClusterImageTextForClusterFeatureCount:text:locale:
getClusterAnnotationTextForClusterFeatureCount:text:locale:
initWithClusterNode:clusterTree:baseStyle:imageText:annotationText:annotationLocale:
setCoordinate:
setCourse:
_customFeature
addExperimentObserver:queue:
experimentConfigurationDidChange:
willChangeActiveTileGroup
setWillChangeActiveTileGroup:
didChangeActiveTileGroup
experimentConfigurationDidChange
_willChangeActiveTileGroup
_didChangeActiveTileGroup
_experimentConfigurationDidChange
setVariantEntries:
addVariantEntries:
variantEntriesCount
clearVariantEntries
variantEntriesAtIndex:
variantEntries
_variantEntries
initWithBytes:length:
setArtworkIdentifier:
shieldTypesCount
clearShieldTypes
shieldTypesAtIndex:
addShieldTypes:
defaultForFeatureTypesCount
clearDefaultForFeatureTypes
defaultForFeatureTypeAtIndex:
addDefaultForFeatureType:
hasArtworkIdentifier
shieldTypes
setShieldTypes:count:
defaultForFeatureTypes
setDefaultForFeatureTypes:count:
artworkIdentifier
_defaultForFeatureTypes
_shieldTypes
_artworkIdentifier
initWithNavCameraController:
_updateZoomScaleLimts
mapLayerNavigationCameraHasStoppedPanning
_updateSceneStyles:
calculateViewableScreenRect
puckScreenPoint
animateCameraWithDuration:fromFrame:completionHandler:
updateCameraState
resetSpringsToResting
currentCameraFrame
mapLayerNavigationCameraHasStartedPanning
_setNeedsUpdate
returnToTrackingWithDelay:resetZoom:
_snapPitch
_snapHeading
_canZoomIn
_canZoomOut
_setDetached:
_updateObserverCouldZoomIn:couldZoomOut:
mapLayerCanZoomInDidChange:
mapLayerCanZoomOutDidChange:
mapLayerNavigationCameraDidReturnToDefaultZoom
mapLayerNavigationCameraDidLeaveDefaultZoom
routeCoordinateAtDistance:beforeRouteCoordinate:
updateSpringsForTrackingCamera
updateSpringsForFramingCamera
_updateStyles
_updateSprings:
_hasRunningAnimation
_updateDebugOverlay
_updateDebugText
_debugText:showNavCameraDebugConsoleAttributes:
cameraHeadingType
restingCameraFrame
_normalizedZoomLevelForDisplayZoomLevel:
calculateViewableScreenRectForEdgeInsets:
calculateHeading
_updateForAnimatedEdgeInsets
distanceBetweenLocation:nextPointIndex:toPointIndex:
courseAtRouteCoordinateIndex:
initWithRoute:routeCoordinate:locationCoordinate:stepIndex:matchedCourse:timestamp:
setIsGoodMatch:
locationAtDistance:from:
coordinateAtOffset:
distanceToManeuver:
routeCoordinateAtDistance:
destination
hasLatLng
latLng
distanceBetweenRoutePointIndex:toPointIndex:
routeLocationAtDistance:fromManeuver:
_addAdditionalRoutePointsToFrameToList:
updateManeuversToFrame
updatePointsToFrame
minZoomHeight
maxZoomHeight
screenCanvas
minZoomScale
maxZoomScale
minCameraPitch
maxCameraPitch
clientFramingInsets
_cameraType
_headingType
_puckCourse
_puckCoordinate
_headingDelta
_headingMinDelta
_lastCalculatedCameraFrame
_pitchSpring
_headingSpring
_distanceFromTargetSpring
_screenPositionSpring
_cameraDistanceFromTarget
_cameraPitch
_previousUpdateTime
_maxZoomScale
_minZoomScale
_gestureBehavior
_attachedGestureBehavior
_detachedGestureBehavior
_isDetached
_zooming
_snapPitchAnimation
_snapHeadingAnimation
_transitionFrame
_currentStyleName
_coordinatesToFrame
_styleManeuversToFrame
_maneuversToFrame
_minCameraHeight
_maxCameraHeight
_minCameraPitch
_maxCameraPitch
_previousMapEdgeInsets
_framingEdgeInset
_framingEdgeInsetProportional
_clientFramingInsets
_puckMovementBoundsMin
_puckMovementBoundsMax
_puckScreenPosition
_minHeightDeltaChangeHorizontal
_maxHeightDeltaChangeHorizontal
_minHeightDeltaChangeVertical
_maxHeightDeltaChangeVertical
_halfPuckSize
_viewableScreenRect
_framingScreenRect
_enablePan
_enableZoom
_enablePitch
_enableRotate
_panReturnDelayTime
_alternateFramingSource
_maxFramingDistance
_framingDistanceAfterManeuver
_locationCoordinate
_routeCoordinate
_frameAllGroupedManeuvers
_maxManeuversToFrame
_ignorePointsBehind
_insetsAnimating
_routeFocusCoordinate
_lastTargetStyleIdentifier
_desiredZoomScale
_animationTime
_isTracking
_depthNear
_leftHanded
_sentZoomNotification
_screenCanvas
_sceneConfiguration
_baseDisplayRate
isMuninEnabled
attributions
isChangingMapType
animations
initWithAnimations:
groupStepHandler
setGroupStepHandler:
_groupStepHandler
_animations
caseInsensitiveCompare:
firstObject
poiType
shouldDisplayPOIWithType:
initWithStylesheetVendor:
_vendor
enumerateKeysAndObjectsUsingBlock:
setShieldTexts:
addShieldText:
shieldTextsCount
clearShieldTexts
shieldTextAtIndex:
setShieldType:
setHasShieldType:
hasShieldType
shieldTexts
_shieldTexts
_initWithKeyType:
initWithIconName:
initWithShieldName:text:locale:color:
keyType
imageName
iconAttributeKey
iconAttributeValue
dataType
relatedText
hasDataValue
dataValue
imageCenter
fallbackImageKeys
_keyType
_imageName
_shieldTextLocale
_iconAttributeKey
_iconAttributeValue
_dataType
_text
_relatedText
_hasDataValue
_dataValue
_imageCenter
_fallbackImageKeys
clampedPosition:usingSingleRestriction:westOfDatelineRestriction:eastOfDatelineRestriction:wrapRange:
_singleRestrictionMercator
_westOfDatelineMercator
_eastOfDatelineMercator
_singleRestrictionCoord
_westOfDatelineCoord
_eastOfDatelineCoord
_empty
_mapRegion
venueLevelsCount
venueLevels
venueComponentsCount
venueComponents
tileSetForKey:
maxZoom
addVariant:
variantAtIndex:
updateTexturesIfNecessary:textureManager:
sourceTexture
targetTexture
sourceRoofTexture
targetRoofTexture
defaultConfiguration
dataForGenericTileType:configuration:
_updateViewport
_updateCameraFromGlobe
setTextureAtlas:
setGenericShields:
addTextureAtlas:
addGenericShield:
textureAtlasCount
clearTextureAtlas
textureAtlasAtIndex:
genericShieldsCount
clearGenericShields
genericShieldAtIndex:
textureAtlas
genericShields
_genericShields
_textureAtlas
hasGroupIdentifier
hasHighlightDistance
highlightDistance
hasPriority
initWithTrafficSignal:
approachingDistanceInMeters
setApproachingRouteOffset:
newTrafficFeatureForEnrouteNotice:onRoute:
isBehind
_approachingRouteOffset
_approachingDistanceInMeters
_uniqueIdentifier
_groupIdentifier
_position
_location
_minZoom
_maxZoom
_trafficFeatureType
_shouldUpdateStyle
_startZoomAnimationFrom:to:completionHandler:
_navCameraController
_startZoomScale
_tapZoomAnimation
_startPitch
addCameraPath:
setUseSplines:
useSplines
functionWithControlPoints::::
labelFramesCount
labelFrameAtIndex:
bestLocalizedLabelAtIndex:
numberOfLines
setNumberOfLines:
setHasNumberOfLines:
hasNumberOfLines
setLeftCapWidth:
setHasLeftCapWidth:
hasLeftCapWidth
setRightCapWidth:
setHasRightCapWidth:
hasRightCapWidth
setLeftPadding:
setHasLeftPadding:
hasLeftPadding
setRightPadding:
setHasRightPadding:
hasRightPadding
leftCapWidth
rightCapWidth
leftPadding
rightPadding
_leftCapWidth
_leftPadding
_numberOfLines
_rightCapWidth
_rightPadding
imageryInfo
dataFormatVersion
muninMarkerAtCoordinate:
enterMuninForStorefrontView:
enterMuninForMarker:withHeading:
muninMarkerAtCoordinate:completeMarkerHandler:
moveToStorefrontView:animated:completionHandler:
moveToMarker:withHeading:animated:completionHandler:
currentMarker
onscreenImageResources
timestamp
bucketId
cameras
cameraNumber
projection
lensType
textureIds
lookAt
_updateVectorData
overlay:canPossiblyDrawKey:
overlay:canDrawKey:
overlay:drawKey:inContext:
overlayCanProvideVectorData:
vectorDataForOverlay:
setNeedsDisplayInRect:level:reason:
setNeedsDisplayForReason:
flyoverContainer
setReplaceMapContentInRect:
setLevel:
_canProvideVectorGeometry
_replaceMapContentInRect
_level
_flyoverContainer
_standardContainer
_vectorData
_vectorDataLock
_canProvideVectorData
labelTextPlacements
createStrokePointStyleList:section:outPointStyles:
enclosePointsInBoundingBox:count:
prepareToFillSection:
addFillForSection:precision:styleIndex:cullingMask:accessor:triangulator:
initialStyleIndexForSection:attributes:styles:
_sourceTexture
_targetTexture
_sourceRoofTexture
_targetRoofTexture
_lastResolvedZoom
_minTrackingCameraDistance
_zoomLevelForCameraPosition:
tileLabelLinesCount
transitAccessPointCount
transitAccessPoints
poiStorefrontBundleIDs
lineType
etaComparisonToMain
isRepositioning
labelRectForOrientation:styleQuery:navContext:anchorPosition:artworkCache:
setIsRepositioning:
_etaLabel
_etaLabelArtworkKey
_displayEtaDescription
_isRepositioning
_orientation
numberWithShort:
setObject:forKeyedSubscript:
businessId
floorOrdinals
shortFloorNames
floorNames
nearestFramingPositionToLocation:
newBufferWithLength:options:
commandBufferWithUnretainedReferences
endEncoding
addScheduledHandler:
GPUEndTime
GPUStartTime
addCompletedHandler:
commit
waitUntilScheduled
getBytes:bytesPerRow:fromRegion:mipmapLevel:
computeCommandEncoder
blitCommandEncoder
optimizeContentsForGPUAccess:
optimizeContentsForCPUAccess:
fillBuffer:range:value:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
setComputePipelineState:
setBuffers:offsets:withRange:
setTexture:atIndex:
setSamplerState:atIndex:
dispatchThreadgroups:threadsPerThreadgroup:
colorAttachments
setLoadAction:
setStoreAction:
storeAction
setResolveTexture:
setClearColor:
depthAttachment
setClearDepth:
stencilAttachment
setClearStencil:
renderPassDescriptor
setVisibilityResultBuffer:
renderCommandEncoderWithDescriptor:
setViewport:
setFrontFacingWinding:
setCullMode:
setBlendColorRed:green:blue:alpha:
contents
setVisibilityResultMode:offset:
setRenderPipelineState:
setDepthStencilState:
setStencilReferenceValue:
setDepthBias:slopeScale:clamp:
setScissorRect:
setTriangleFillMode:
setVertexBuffers:offsets:withRange:
setVertexTexture:atIndex:
setVertexSamplerState:atIndex:
setFragmentBuffers:offsets:withRange:
setFragmentTexture:atIndex:
setFragmentSamplerState:atIndex:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
null
setActions:
setDrawableProperties:
setPresentsWithTransaction:
_deleteLayerRenderBuffer
backingFormat
renderbufferStorage:fromDrawable:
setParameter:to:
renderDelegate
backingSize
layoutSublayers
_createTexture
_createLayerRenderBuffer
_context
_backingSize
presentRenderbuffer:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
setTextureType:
setPixelFormat:
setWidth:
setHeight:
setDepth:
setMipmapLevelCount:
setSampleCount:
setArrayLength:
setCpuCacheMode:
setStorageMode:
setUsage:
newTextureWithDescriptor:iosurface:plane:
newTextureWithDescriptor:
setDepthCompareFunction:
setDepthWriteEnabled:
setStencilFailureOperation:
setDepthFailureOperation:
setDepthStencilPassOperation:
setStencilCompareFunction:
setReadMask:
setWriteMask:
setFrontFaceStencil:
setBackFaceStencil:
newDepthStencilStateWithDescriptor:
vertexDescriptor
layouts
setStride:
setStepFunction:
setStepRate:
attributes
setFormat:
setOffset:
setBufferIndex:
setVertexDescriptor:
setVertexFunction:
setFragmentFunction:
setBlendingEnabled:
setAlphaBlendOperation:
setRgbBlendOperation:
setDestinationAlphaBlendFactor:
setDestinationRGBBlendFactor:
setSourceAlphaBlendFactor:
setSourceRGBBlendFactor:
setDepthAttachmentPixelFormat:
setStencilAttachmentPixelFormat:
setAlphaToCoverageEnabled:
newRenderPipelineStateWithDescriptor:error:
localizedDescription
newComputePipelineStateWithFunction:error:
setSAddressMode:
setTAddressMode:
setMinFilter:
setMagFilter:
setMipFilter:
setMaxAnisotropy:
setCompareFunction:
newSamplerStateWithDescriptor:
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
setResourceOptions:
newLibraryWithData:error:
newDefaultLibraryWithBundle:error:
setFastMathEnabled:
setLanguageVersion:
newLibraryWithSource:options:error:
newFunctionWithName:
targetTimestamp
initWithCallbacker:
displayLinkFired:
_callbacker
displayLinkWithTarget:selector:
setPaused:
mainDisplay
currentRunLoop
addToRunLoop:forMode:
isPaused
setPreferredFramesPerSecond:
preferredFramesPerSecond
displayLinkWithDisplay:target:selector:
initWithAPI:properties:
sharegroup
currentContext
setCurrentContext:
setFramebufferOnly:
setFenceEnabled:
setDevice:
setDrawableSize:
nextDrawable
_updateDrawable
present
_onTimerFired:withPresent:
presentAtTime:
presentAfterMinimumDuration:
onTimerFired:presentAtTime:
onTimerFired:presentAfterMinimumDuration:
display
sRGB
_sRGB
initWithObjectsAndKeys:
newCommandQueue
setLabel:
supportsFeatureSet:
maxThreadsPerThreadgroup
enqueue
initWithContentsOfFile:
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
v24@0:8@16
v24@0:8@"VKAnimation"16
@24@0:8^{AnimationManager=^^?{_retain_ptr<_AnimationManagerRunner *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}^{RunLoopController}{mutex={_opaque_pthread_mutex_t=q[56c]}}{array<std::__1::unordered_set<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::allocator<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >, 2>=[2{unordered_set<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::allocator<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >={__hash_table<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::allocator<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>, std::__1::allocator<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> > >={__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>=^{__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >=Q}{__compressed_pair<float, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >=f}}}]}{atomic<bool>=AB}}16
^{AnimationManager=^^?{_retain_ptr<_AnimationManagerRunner *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}^{RunLoopController}{mutex={_opaque_pthread_mutex_t=q[56c]}}{array<std::__1::unordered_set<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::allocator<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >, 2>=[2{unordered_set<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::allocator<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >={__hash_table<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> >, std::__1::allocator<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>, std::__1::allocator<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> > >={__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>=^{__hash_node_base<std::__1::__hash_node<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >=Q}{__compressed_pair<float, std::__1::equal_to<geo::_retain_ptr<VKAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >=f}}}]}{atomic<bool>=AB}}
v40@0:8@16@24@32
v24@0:8@"GEOResourceManifestManager"16
v40@0:8@"GEOResourceManifestManager"16@"GEOActiveTileGroup"24@"GEOActiveTileGroup"32
r^{shared_ptr<md::DataOverrideManager>=^{DataOverrideManager}^{__shared_weak_count}}16@0:8
{shared_ptr<md::TextureManager>=^{TextureManager}^{__shared_weak_count}}16@0:8
^{Device=i{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{unique_ptr<md::SharedDeviceResources, std::__1::default_delete<md::SharedDeviceResources> >={__compressed_pair<md::SharedDeviceResources *, std::__1::default_delete<md::SharedDeviceResources> >=^{SharedDeviceResources}}}}16@0:8
^{Device=^^?{DeviceVersion=II}{DeviceCapabilities=BBIII{DeviceSize=III}}{DeviceAPIProperties=iidB}ii}16@0:8
^{AlphaAtlas=BIIIf{unique_ptr<ggl::Texture2D, std::__1::default_delete<ggl::Texture2D> >={__compressed_pair<ggl::Texture2D *, std::__1::default_delete<ggl::Texture2D> >=^{Texture2D}}}}16@0:8
^{IsoAlphaAtlas=IIf{unique_ptr<ggl::Texture2D, std::__1::default_delete<ggl::Texture2D> >={__compressed_pair<ggl::Texture2D *, std::__1::default_delete<ggl::Texture2D> >=^{Texture2D}}}{shared_ptr<ggl::SamplerState>=^{SamplerState}^{__shared_weak_count}}}16@0:8
^{DistanceAtlas=III{unique_ptr<ggl::Texture2D, std::__1::default_delete<ggl::Texture2D> >={__compressed_pair<ggl::Texture2D *, std::__1::default_delete<ggl::Texture2D> >=^{Texture2D}}}}16@0:8
r^{StandardLibrary=^^?^{ResourceManager}^{RenderResource}^{ShaderLibraryDescriptor}{vector<ggl::ShaderLibrary::FunctionEntry, geo::StdAllocator<ggl::ShaderLibrary::FunctionEntry, ggl::Allocator> >=^{FunctionEntry}^{FunctionEntry}{__compressed_pair<ggl::ShaderLibrary::FunctionEntry *, geo::StdAllocator<ggl::ShaderLibrary::FunctionEntry, ggl::Allocator> >=^{FunctionEntry}{StdAllocator<ggl::ShaderLibrary::FunctionEntry, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ShaderLibrary::ShaderEntry, geo::StdAllocator<ggl::ShaderLibrary::ShaderEntry, ggl::Allocator> >=^{ShaderEntry}^{ShaderEntry}{__compressed_pair<ggl::ShaderLibrary::ShaderEntry *, geo::StdAllocator<ggl::ShaderLibrary::ShaderEntry, ggl::Allocator> >=^{ShaderEntry}{StdAllocator<ggl::ShaderLibrary::ShaderEntry, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ShaderLibrary::ComputeShaderEntry, geo::StdAllocator<ggl::ShaderLibrary::ComputeShaderEntry, ggl::Allocator> >=^{ComputeShaderEntry}^{ComputeShaderEntry}{__compressed_pair<ggl::ShaderLibrary::ComputeShaderEntry *, geo::StdAllocator<ggl::ShaderLibrary::ComputeShaderEntry, ggl::Allocator> >=^{ComputeShaderEntry}{StdAllocator<ggl::ShaderLibrary::ComputeShaderEntry, ggl::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<ggl::Shader>, geo::StdAllocator<std::__1::shared_ptr<ggl::Shader>, ggl::Allocator> >=^{shared_ptr<ggl::Shader>}^{shared_ptr<ggl::Shader>}{__compressed_pair<std::__1::shared_ptr<ggl::Shader> *, geo::StdAllocator<std::__1::shared_ptr<ggl::Shader>, ggl::Allocator> >=^{shared_ptr<ggl::Shader>}{StdAllocator<std::__1::shared_ptr<ggl::Shader>, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::ShaderLibraryData>=^{ShaderLibraryData}^{__shared_weak_count}}}16@0:8
^{IconManager=^^?{shared_ptr<grl::ResourceProvider>=^{ResourceProvider}^{__shared_weak_count}}{read_write_lock={_opaque_pthread_rwlock_t=q[192c]}}B^{PackInfo}{read_write_lock={_opaque_pthread_rwlock_t=q[192c]}}{map<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock, std::__1::less<std::__1::pair<std::__1::basic_string<char>, float> >, geo::StdAllocator<std::__1::pair<const std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, grl::Allocator> >={__tree<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, std::__1::__map_value_compare<std::__1::pair<std::__1::basic_string<char>, float>, std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, std::__1::less<std::__1::pair<std::__1::basic_string<char>, float> >, true>, geo::StdAllocator<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, grl::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, void *>, grl::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, void *>, grl::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::pair<std::__1::basic_string<char>, float>, std::__1::__value_type<std::__1::pair<std::__1::basic_string<char>, float>, geo::read_write_lock>, std::__1::less<std::__1::pair<std::__1::basic_string<char>, float> >, true> >=Q}}}{shared_ptr<grl::FontManager>=^{FontManager}^{__shared_weak_count}}}16@0:8
^{shared_ptr<grl::FontManager>=^{FontManager}^{__shared_weak_count}}16@0:8
^{FigPhotoDecompressionSession=}16@0:8
@32@0:8^{Device=i{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{unique_ptr<md::SharedDeviceResources, std::__1::default_delete<md::SharedDeviceResources> >={__compressed_pair<md::SharedDeviceResources *, std::__1::default_delete<md::SharedDeviceResources> >=^{SharedDeviceResources}}}}16r^{shared_ptr<ggl::StandardLibrary>=^{StandardLibrary}^{__shared_weak_count}}24
v16@0:8
{shared_ptr<md::StylesheetVendor>=^{StylesheetVendor}^{__shared_weak_count}}16@0:8
{_retain_ptr<VKInternalIconManager *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKInternalIconManager""_retain"{_retain_objc=}"_release"{_release_objc=}}
{shared_ptr<md::TextureManager>="__ptr_"^{TextureManager}"__cntrl_"^{__shared_weak_count}}
{_retain_ptr<VKResourceManager *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKResourceManager""_retain"{_retain_objc=}"_release"{_release_objc=}}
{shared_ptr<md::StylesheetVendor>="__ptr_"^{StylesheetVendor}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<md::DataOverrideManager>="__ptr_"^{DataOverrideManager}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<md::Device, std::__1::default_delete<md::Device> >="__ptr_"{__compressed_pair<md::Device *, std::__1::default_delete<md::Device> >="__value_"^{Device}}}
{unique_ptr<ggl::AlphaAtlas, std::__1::default_delete<ggl::AlphaAtlas> >="__ptr_"{__compressed_pair<ggl::AlphaAtlas *, std::__1::default_delete<ggl::AlphaAtlas> >="__value_"^{AlphaAtlas}}}
{unique_ptr<ggl::IsoAlphaAtlas, std::__1::default_delete<ggl::IsoAlphaAtlas> >="__ptr_"{__compressed_pair<ggl::IsoAlphaAtlas *, std::__1::default_delete<ggl::IsoAlphaAtlas> >="__value_"^{IsoAlphaAtlas}}}
{unique_ptr<ggl::DistanceAtlas, std::__1::default_delete<ggl::DistanceAtlas> >="__ptr_"{__compressed_pair<ggl::DistanceAtlas *, std::__1::default_delete<ggl::DistanceAtlas> >="__value_"^{DistanceAtlas}}}
{shared_ptr<ggl::StandardLibrary>="__ptr_"^{StandardLibrary}"__cntrl_"^{__shared_weak_count}}
^{FigPhotoDecompressionSession=}
{shared_ptr<md::GeoResourceProvider>="__ptr_"^{GeoResourceProvider}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<grl::IconManager>="__ptr_"^{IconManager}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<grl::FontManager>="__ptr_"^{FontManager}"__cntrl_"^{__shared_weak_count}}
{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
@"VKSharedResources"
@"NSMapTable"
@24@0:8r^{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}16
v32@0:8{shared_ptr<gss::StylesheetManager<gss::ScenePropertyID> >=^{StylesheetManager<gss::ScenePropertyID>}^{__shared_weak_count}}16
{shared_ptr<gss::StylesheetManager<gss::ScenePropertyID> >=^{StylesheetManager<gss::ScenePropertyID>}^{__shared_weak_count}}16@0:8
v32@0:8{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}16
{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}16@0:8
v20@0:8i16
v24@0:8d16
v24@0:8Q16
v20@0:8I16
v20@0:8B16
C16@0:8
{shared_ptr<gss::StylesheetManager<gss::ScenePropertyID> >="__ptr_"^{StylesheetManager<gss::ScenePropertyID>}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<gss::StylesheetManager<gss::PropertyID> >="__ptr_"^{StylesheetManager<gss::PropertyID>}"__cntrl_"^{__shared_weak_count}}
{vector<GEOLocationCoordinate2D, std::__1::allocator<GEOLocationCoordinate2D> >="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<GEOLocationCoordinate2D *, std::__1::allocator<GEOLocationCoordinate2D> >="__value_"^{?}}}
{ManeveuverDistancesRange="_immediate"d"_extremlyNear"d"_veryNear"d"_near"d"_medium"d"_far"d"_veryFar"d}
{shared_ptr<md::TaskContext>="__ptr_"^{TaskContext}"__cntrl_"^{__shared_weak_count}}
@24@0:8^{RunLoopController=^{MapEngine}qq}16
v24@0:8r^{Matrix<double, 3, 1>=[3d]}16
v24@0:8r^{Mercator3<double>=[3d]}16
{Mercator3<double>=[3d]}16@0:8
r^{Matrix<double, 3, 1>=[3d]}16@0:8
{?=Bddddd}16@0:8
v24@0:8r^{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}16
r^{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}16@0:8
{Unit<RadianUnitDescription, double>=d}16@0:8
v24@0:8{Unit<RadianUnitDescription, double>=d}16
d16@0:8
{Matrix<double, 3, 1>=[3d]}16@0:8
v96@0:8{VKCameraState={RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}d{Unit<RadianUnitDescription, double>=d}d}16
{VKCameraState={RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}d{Unit<RadianUnitDescription, double>=d}d}16@0:8
f24@0:8r^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16
B24@0:8r^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16
@?16@0:8
{Matrix<double, 3, 1>=[3d]}32@0:8{CGPoint=dd}16
{Matrix<double, 3, 1>=[3d]}40@0:8{CGPoint=dd}16d32
d24@0:8d16
f32@0:8{CGPoint=dd}16
f16@0:8
r^{Matrix<double, 4, 4>=[16d]}16@0:8
{View<double>={RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}{Matrix<double, 4, 4>=[16d]}{Matrix<double, 4, 4>=[16d]}{Matrix<double, 4, 4>=[16d]}dd{ViewSize=SS}i}20@0:8{ViewSize=SS}16
{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}16@0:8
{optional<double>=B(ValueUnion=[8C]d)}16@0:8
v32@0:8{optional<double>=B(ValueUnion=[8C]d)}16
^{RunLoopController=^{MapEngine}qq}
{?="orthographic"B"width"d"height"d"near"d"far"d"horizontalOffset"d}
@"VKViewVolume"
@"VKFootprint"
{Matrix<double, 3, 1>="_e"[3d]}
{Unit<RadianUnitDescription, double>="_value"d}
{RigidTransform<double, double>="_translation"{Matrix<double, 3, 1>="_e"[3d]}"_rotation"{Quaternion<double>="_imaginary"{Matrix<double, 3, 1>="_e"[3d]}"_scalar"d}}
{Matrix<double, 4, 4>="_e"[16d]}
@"VKCameraRegionRestriction"
{optional<double>="_hasValue"B"_value"(ValueUnion="data"[8C]"type"d)}
v32@0:8@16@24
v32@0:8@"VKPolylineGroupOverlay"16@"VKPolylineOverlay"24
@24@0:8^{PolylineGroupChangeObserver=^^?}16
^{PolylineGroupChangeObserver=^^?}
{vector<geo::_retain_ptr<VKPolylineGroupOverlay *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::allocator<geo::_retain_ptr<VKPolylineGroupOverlay *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >="__begin_"^{_retain_ptr<VKPolylineGroupOverlay *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>}"__end_"^{_retain_ptr<VKPolylineGroupOverlay *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>}"__end_cap_"{__compressed_pair<geo::_retain_ptr<VKPolylineGroupOverlay *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> *, std::__1::allocator<geo::_retain_ptr<VKPolylineGroupOverlay *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> > >="__value_"^{_retain_ptr<VKPolylineGroupOverlay *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>}}}
{set<VKPolylineGroupOverlay *, std::__1::less<VKPolylineGroupOverlay *>, std::__1::allocator<VKPolylineGroupOverlay *> >="__tree_"{__tree<VKPolylineGroupOverlay *, std::__1::less<VKPolylineGroupOverlay *>, std::__1::allocator<VKPolylineGroupOverlay *> >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<VKPolylineGroupOverlay *, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::less<VKPolylineGroupOverlay *> >="__value_"Q}}}
^{Matrix<double, 3, 1>=[3d]}16@0:8
B24@0:8r^{Matrix<double, 3, 1>=[3d]}16
{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16@0:8
{VKFootprintConvexHull_struct=i[6{Matrix<double, 3, 1>=[3d]}][6{Matrix<double, 3, 1>=[3d]}]}16@0:8
i16@0:8
{Box<double, 2>="_minimum"{Matrix<double, 2, 1>="_e"[2d]}"_maximum"{Matrix<double, 2, 1>="_e"[2d]}}
{VKFootprintConvexHull_struct="edgeCount"i"edgeOrigin"[6{Matrix<double, 3, 1>="_e"[3d]}]"edgeNormal"[6{Matrix<double, 3, 1>="_e"[3d]}]}
[12{Matrix<double, 3, 1>="_e"[3d]}]
v72@0:8{?=Bddddd}16r^{Matrix<double, 4, 4>=[16d]}64
{Matrix<double, 3, 1>=[3d]}24@0:8^f16
[8{Matrix<double, 3, 1>="_e"[3d]}]
@32@0:8{CGPoint=dd}16
{unordered_map<unsigned int, unsigned long long, std::__1::hash<unsigned int>, std::__1::equal_to<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned long long> > >={__hash_table<std::__1::__hash_value_type<unsigned int, unsigned long long>, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, unsigned long long>, std::__1::hash<unsigned int>, true>, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, unsigned long long>, std::__1::equal_to<unsigned int>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned int, unsigned long long> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, unsigned long long>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, unsigned long long>, std::__1::hash<unsigned int>, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, unsigned long long>, std::__1::equal_to<unsigned int>, true> >=f}}}16@0:8
v32@0:8@16B24B28
q16@0:8
v24@0:8q16
v32@0:8@"<VKTrackableAnnotation>"16B24B28
@"<VKTrackableAnnotation>"16@0:8
v48@0:8d16{CGPoint=dd}24@?40
v32@0:8{CGPoint=dd}16
v48@0:8{CGPoint=dd}16d32d40
v36@0:8{CGPoint=dd}16B32
v40@0:8{CGPoint=dd}16d32
B32@0:8{CGPoint=dd}16
v40@0:8d16{CGPoint=dd}24
v48@0:8{CGPoint=dd}16{CGPoint=dd}32
v48@0:8d16{CGPoint=dd}24@?<v@?>40
v24@0:8@"<VKGesturingCameraController>"16
v24@0:8C16C20
v20@0:8C16
^{LabelSettings={LabelSettings_Presentation=^{LabelSettings}}{LabelSettings_Navigation=^{LabelSettings}}{LabelSettings_Markers=^{LabelSettings}}{shared_ptr<md::LabelManager>=^{LabelManager}^{__shared_weak_count}}{unique_ptr<md::LabelSettingsData, std::__1::default_delete<md::LabelSettingsData> >={__compressed_pair<md::LabelSettingsData *, std::__1::default_delete<md::LabelSettingsData> >=^{LabelSettingsData}}}}16@0:8
v20@0:8f16
{?=B}16@0:8
v17@0:8{?=B}16
@20@0:8B16
B24@0:8q16
d24@0:8q16
v32@0:8B16B20d24
@32@0:8{?=dd}16
@36@0:8{?=dd}16B32
@40@0:8{?=dd}16B32B36
@24@0:8Q16
s24@0:8@16
v28@0:8s16@20
f24@0:8@16
v32@0:8r^{Venue=QQ{vector<md::VenueBuilding, std::__1::allocator<md::VenueBuilding> >=^{VenueBuilding}^{VenueBuilding}{__compressed_pair<md::VenueBuilding *, std::__1::allocator<md::VenueBuilding> >=^{VenueBuilding}}}{Polygon2<double>={vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}}{ConvexHull2<double>={vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}}{Mercator2<double>=[2d]}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{optional<std::__1::basic_string<char> >=B(ValueUnion=[24C]{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}})}{optional<std::__1::basic_string<char> >=B(ValueUnion=[24C]{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}})}}16r^{VenueBuilding={vector<md::VenueLevel, std::__1::allocator<md::VenueLevel> >=^{VenueLevel}^{VenueLevel}{__compressed_pair<md::VenueLevel *, std::__1::allocator<md::VenueLevel> >=^{VenueLevel}}}QQQQs{Matrix<double, 2, 1>=[2d]}{ConvexHull2<double>={vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}}}24
B20@0:8i16
v24@0:8i16B20
{?=CCCCB}16@0:8
v21@0:8{?=CCCCB}16
v25@0:8{?=CCCCB}16B21
v33@0:8{?=CCCCB}16B21d25
v32@0:8d16@?24
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
{?=ddd}16@0:8
v80@0:8{?=dd}16d32d40d48d56@?64@?72
@40@0:8B16B20d24@32
v24@0:8^{CGContext=}16
v28@0:8d16B24
v40@0:8@16d24d32
v56@0:8@16d24d32d40@?48
d24@0:8@16
{?=dd}40@0:8{CGPoint=dd}16@32
{CGPoint=dd}40@0:8{?=dd}16@32
d64@0:8{CGPoint=dd}16{CGPoint=dd}32@48q56
v32@0:8{VKEdgeInsets=ffff}16
v56@0:8{VKEdgeInsets=ffff}16d32@40@?48
{VKEdgeInsets=ffff}16@0:8
v32@0:8@16@?24
v28@0:8i16@?20
v36@0:8@16B24@?28
v40@0:8@16d24@?32
v36@0:8Q16B24@?28
v60@0:8B16q20{?=dd}28d44@?52
v28@0:8@16B24
@36@0:8{CGPoint=dd}16B32
@32@0:8@16@24
@24@0:8@16
v68@0:8{CGPoint=dd}16{CGPoint=dd}32B48d52@?60
v24@0:8{PolylineCoordinate=If}16
v32@0:8r^{MuninJunction=^^?^{?}{Mercator2<double>=[2d]}{Matrix<float, 2, 1>=[2f]}{vector<const md::MuninRoadEdge *, std::__1::allocator<const md::MuninRoadEdge *> >=^^{MuninRoadEdge}^^{MuninRoadEdge}{__compressed_pair<const md::MuninRoadEdge **, std::__1::allocator<const md::MuninRoadEdge *> >=^^{MuninRoadEdge}}}iCC}16r^{MuninRoadEdge=^{?}f{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}QQ^{MuninJunction}^{MuninJunction}B}24
v24@0:8@?16
v24@0:8r^{shared_ptr<md::LabelMarker>=^{LabelMarker}^{__shared_weak_count}}16
v32@0:8@16r^{shared_ptr<md::LabelMarker>=^{LabelMarker}^{__shared_weak_count}}24
v32@0:8@16q24
v48@0:8{?=dd}16d32@?40
v32@0:8i16i20i24i28
@88@0:8i16d20d28f36d40d48{?={?=dd}{?=dd}}56
v40@0:8d16d24@32
v32@0:8@16d24
v40@0:8@16r^{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}24r^{Unit<RadianUnitDescription, double>=d}32
v32@0:8@16r^{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}24
{optional<VKMapType>="_hasValue"B"_value"(ValueUnion="data"[4C]"type"i)}
@"VKMapCanvas"
@"VKClassicGlobeCanvas"
@"<VKMapViewDelegate>"
@"NSString"
{?="timePeriod"C"overlayType"C"applicationState"C"searchResultsType"C"mapHasLabels"B}
@"VKTimedAnimation"
{VKEdgeInsets="top"f"left"f"bottom"f"right"f}
@"VKNotificationObserver"
@"VKPuckAnimator"
@"VKMapCameraController"
@"VKNavCameraController"
{_retain_ptr<VKMuninCameraController *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKMuninCameraController""_retain"{_retain_objc=}"_release"{_release_objc=}}
@"VKNavContext"
{Coordinate3D<Radians, double>="latitude"{Unit<RadianUnitDescription, double>="_value"d}"longitude"{Unit<RadianUnitDescription, double>="_value"d}"altitude"{Unit<MeterUnitDescription, double>="_value"d}}
{unique_ptr<md::MapEngine, std::__1::default_delete<md::MapEngine> >="__ptr_"{__compressed_pair<md::MapEngine *, std::__1::default_delete<md::MapEngine> >="__value_"^{MapEngine}}}
@"MDARController"
@"GEOPOICategoryFilter"
{_retain_ptr<VKStateCaptureHandler *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKStateCaptureHandler""_retain"{_retain_objc=}"_release"{_release_objc=}}
v24@0:8r^{shared_ptr<md::FeatureMarker>=}16
r^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ}16@0:8
v32@0:8^{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}16r^{bitset<4>=Q}24
@44@0:8@16d24q32B40
B24@0:8i16i20
v24@0:8@"VKMapModel"16
v25@0:8{DisplayStyle=CCCCC}16B21
v36@0:8{CGPoint=dd}16C32
{?=dd}32@0:8{CGPoint=dd}16
{CGPoint=dd}32@0:8{?=dd}16
v68@0:8B16q20{?=dd}28d44@52@?60
@"NSString"20@0:8B16
@?<q@?dddd>16@0:8
@?<B@?{?=dd}>16@0:8
v24@0:8@"VKOverlay"16
v32@0:8@"VKOverlay"16@"VKOverlay"24
@"NSArray"16@0:8
v68@0:8B16q20{?=dd}28d44@"VKCameraController<VKNavigationCameraController>"52@?<v@?B>60
@"<VKInteractiveMapDelegate>"16@0:8
v24@0:8@"<VKInteractiveMapDelegate>"16
@28@0:8^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ}16B24
{optional<float>=B(ValueUnion=[4C]f)}32@0:8{CGSize=dd}16
v32@0:8@16r^{shared_ptr<md::LabelMarker>=}24
{shared_ptr<md::FeatureMarker>=^{FeatureMarker}^{__shared_weak_count}}32@0:8{CGPoint=dd}16
v32@0:8^{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}16r^{bitset<4>=}24
@"VKMapModel"
{CGSize="width"d"height"d}
{optional<float>="_hasValue"B"_value"(ValueUnion="data"[4C]"type"f)}
{shared_ptr<md::OverlayContainer>="__ptr_"^{OverlayContainer}"__cntrl_"^{__shared_weak_count}}
@"<VKInteractiveMapDelegate>"
@32@0:8q16@24
@24@0:8q16
@"<VKAnimationRunner>"
@40@0:8d16q24@32
@24@0:8d16
@32@0:8d16@24
v21@0:8{DisplayStyle=CCCCC}16
v32@0:8{CGSize=dd}16
v36@0:8{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}16B32
@80@0:8@16^{CartographicRenderer=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}{unique_ptr<md::PassList, std::__1::default_delete<md::PassList> >={__compressed_pair<md::PassList *, std::__1::default_delete<md::PassList> >=^{PassList}}}{unique_ptr<md::RenderTargetRegistry, std::__1::default_delete<md::RenderTargetRegistry> >={__compressed_pair<md::RenderTargetRegistry *, std::__1::default_delete<md::RenderTargetRegistry> >=^{RenderTargetRegistry}}}{vector<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}{__compressed_pair<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > *, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}}}{linear_map<md::CommandBufferLocation, md::RenderLayer *, std::__1::equal_to<md::CommandBufferLocation>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> >, std::__1::vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > > >={vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}^{pair<md::CommandBufferLocation, md::RenderLayer *>}{__compressed_pair<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> *, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}}}}^{RunLoopController}^{MapEngine}@}24Q32{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}40^{LogicManager=^^?[17{unique_ptr<md::Logic, std::__1::default_delete<md::Logic> >={__compressed_pair<md::Logic *, std::__1::default_delete<md::Logic> >=^{Logic}}}][17{LogicTypePass=CS}]}56r^{MapEngineSettings={linear_map<md::MapEngineSetting, bool, std::__1::equal_to<md::MapEngineSetting>, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> >, std::__1::vector<std::__1::pair<md::MapEngineSetting, bool>, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> > > >={vector<std::__1::pair<md::MapEngineSetting, bool>, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> > >=^{pair<md::MapEngineSetting, bool>}^{pair<md::MapEngineSetting, bool>}{__compressed_pair<std::__1::pair<md::MapEngineSetting, bool> *, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> > >=^{pair<md::MapEngineSetting, bool>}}}}{set<md::MapEngineSetting, std::__1::less<md::MapEngineSetting>, std::__1::allocator<md::MapEngineSetting> >={__tree<md::MapEngineSetting, std::__1::less<md::MapEngineSetting>, std::__1::allocator<md::MapEngineSetting> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<md::MapEngineSetting, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<md::MapEngineSetting> >=Q}}}^{RunLoopController}}64^{AnimationRunner=^{MapEngine}}72
v24@0:8r^{LayoutContext=@{shared_ptr<md::ViewTransform>=^{ViewTransform}^{__shared_weak_count}}@{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}C{VKEdgeInsets=ffff}{VKEdgeInsets=ffff}{shared_ptr<ggl::PolygonBase::MeshMesh>=^{MeshMesh}^{__shared_weak_count}}{shared_ptr<ggl::PolygonBase::MeshMesh>=^{MeshMesh}^{__shared_weak_count}}{shared_ptr<ggl::TextureMesh::MeshMesh>=^{MeshMesh}^{__shared_weak_count}}{StencilManager=CCC{ClearItem=C{Matrix<float, 4, 1>=[4f]}BfCI}}{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{Loader={unique_ptr<ggl::LoaderImpl, std::__1::default_delete<ggl::LoaderImpl> >={__compressed_pair<ggl::LoaderImpl *, std::__1::default_delete<ggl::LoaderImpl> >=^{LoaderImpl}}}}^{Loader}ddBBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}ffi^{View}^{View}^{Viewport}^{ARContext}{array<std::__1::unique_ptr<md::LogicContext, std::__1::default_delete<md::LogicContext> >, 17>=[17{unique_ptr<md::LogicContext, std::__1::default_delete<md::LogicContext> >={__compressed_pair<md::LogicContext *, std::__1::default_delete<md::LogicContext> >=^{LogicContext}}}]}Q}16
{shared_ptr<md::FeatureMarker>=^{FeatureMarker}^{__shared_weak_count}}56@0:8{CGPoint=dd}16{Matrix<double, 3, 1>=[3d]}32
{PolylineCoordinate=If}16@0:8
@"<VKMapModelDelegate>"
@"NSMutableSet"
^{LabelSettings={LabelSettings_Presentation=^{LabelSettings}}{LabelSettings_Navigation=^{LabelSettings}}{LabelSettings_Markers=^{LabelSettings}}{shared_ptr<md::LabelManager>=^{LabelManager}^{__shared_weak_count}}{unique_ptr<md::LabelSettingsData, std::__1::default_delete<md::LabelSettingsData> >={__compressed_pair<md::LabelSettingsData *, std::__1::default_delete<md::LabelSettingsData> >=^{LabelSettingsData}}}}
r^{MapEngineSettings={linear_map<md::MapEngineSetting, bool, std::__1::equal_to<md::MapEngineSetting>, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> >, std::__1::vector<std::__1::pair<md::MapEngineSetting, bool>, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> > > >={vector<std::__1::pair<md::MapEngineSetting, bool>, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> > >=^{pair<md::MapEngineSetting, bool>}^{pair<md::MapEngineSetting, bool>}{__compressed_pair<std::__1::pair<md::MapEngineSetting, bool> *, std::__1::allocator<std::__1::pair<md::MapEngineSetting, bool> > >=^{pair<md::MapEngineSetting, bool>}}}}{set<md::MapEngineSetting, std::__1::less<md::MapEngineSetting>, std::__1::allocator<md::MapEngineSetting> >={__tree<md::MapEngineSetting, std::__1::less<md::MapEngineSetting>, std::__1::allocator<md::MapEngineSetting> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<md::MapEngineSetting, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<md::MapEngineSetting> >=Q}}}^{RunLoopController}}
^{AnimationRunner=^{MapEngine}}
^{CartographicRenderer=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}{unique_ptr<md::PassList, std::__1::default_delete<md::PassList> >={__compressed_pair<md::PassList *, std::__1::default_delete<md::PassList> >=^{PassList}}}{unique_ptr<md::RenderTargetRegistry, std::__1::default_delete<md::RenderTargetRegistry> >={__compressed_pair<md::RenderTargetRegistry *, std::__1::default_delete<md::RenderTargetRegistry> >=^{RenderTargetRegistry}}}{vector<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}{__compressed_pair<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > *, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}}}{linear_map<md::CommandBufferLocation, md::RenderLayer *, std::__1::equal_to<md::CommandBufferLocation>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> >, std::__1::vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > > >={vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}^{pair<md::CommandBufferLocation, md::RenderLayer *>}{__compressed_pair<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> *, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}}}}^{RunLoopController}^{MapEngine}@}
^{LogicManager=^^?[17{unique_ptr<md::Logic, std::__1::default_delete<md::Logic> >={__compressed_pair<md::Logic *, std::__1::default_delete<md::Logic> >=^{Logic}}}][17{LogicTypePass=CS}]}
{FeatureAttributeSet="_attributes"{vector<gss::FeatureAttributePair, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >="__begin_"^{FeatureAttributePair}"__end_"^{FeatureAttributePair}"__end_cap_"{__compressed_pair<gss::FeatureAttributePair *, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >="__value_"^{FeatureAttributePair}"__value_"{StdAllocator<gss::FeatureAttributePair, gss::Allocator>="_allocator"^{Allocator}}}}}
{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >="__ptr_"^{StylesheetQuery<gss::PropertyID>}"__cntrl_"^{__shared_weak_count}}
@"VKNavigationPuck"
{PolylineCoordinate="index"I"offset"f}
v24@0:8B16B20
^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ}16@0:8
^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ}
@"VKCamera"
@"<MDRenderTarget>"
@"VKCameraController"
^{Renderer=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}{unique_ptr<md::PassList, std::__1::default_delete<md::PassList> >={__compressed_pair<md::PassList *, std::__1::default_delete<md::PassList> >=^{PassList}}}{unique_ptr<md::RenderTargetRegistry, std::__1::default_delete<md::RenderTargetRegistry> >={__compressed_pair<md::RenderTargetRegistry *, std::__1::default_delete<md::RenderTargetRegistry> >=^{RenderTargetRegistry}}}{vector<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}{__compressed_pair<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > *, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}}}{linear_map<md::CommandBufferLocation, md::RenderLayer *, std::__1::equal_to<md::CommandBufferLocation>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> >, std::__1::vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > > >={vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}^{pair<md::CommandBufferLocation, md::RenderLayer *>}{__compressed_pair<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> *, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}}}}^{RunLoopController}^{MapEngine}}
^{LayoutContext=@{shared_ptr<md::ViewTransform>=^{ViewTransform}^{__shared_weak_count}}@{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}C{VKEdgeInsets=ffff}{VKEdgeInsets=ffff}{shared_ptr<ggl::PolygonBase::MeshMesh>=^{MeshMesh}^{__shared_weak_count}}{shared_ptr<ggl::PolygonBase::MeshMesh>=^{MeshMesh}^{__shared_weak_count}}{shared_ptr<ggl::TextureMesh::MeshMesh>=^{MeshMesh}^{__shared_weak_count}}{StencilManager=CCC{ClearItem=C{Matrix<float, 4, 1>=[4f]}BfCI}}{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{Loader={unique_ptr<ggl::LoaderImpl, std::__1::default_delete<ggl::LoaderImpl> >={__compressed_pair<ggl::LoaderImpl *, std::__1::default_delete<ggl::LoaderImpl> >=^{LoaderImpl}}}}^{Loader}ddBBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}ffi^{View}^{View}^{Viewport}^{ARContext}{array<std::__1::unique_ptr<md::LogicContext, std::__1::default_delete<md::LogicContext> >, 17>=[17{unique_ptr<md::LogicContext, std::__1::default_delete<md::LogicContext> >={__compressed_pair<md::LogicContext *, std::__1::default_delete<md::LogicContext> >=^{LogicContext}}}]}Q}
@"<MDMapControllerDelegate>"
{PerspectiveView<double>="_transform"{RigidTransform<double, double>="_translation"{Matrix<double, 3, 1>="_e"[3d]}"_rotation"{Quaternion<double>="_imaginary"{Matrix<double, 3, 1>="_e"[3d]}"_scalar"d}}"_projectionMatrix"{Matrix<double, 4, 4>="_e"[16d]}"_inverseProjection"{Matrix<double, 4, 4>="_e"[16d]}"_matrix"{Matrix<double, 4, 4>="_e"[16d]}"_ndcZNear"d"_aspectRatio"d"_size"{ViewSize="width"S"height"S}"_type"i"_verticalFOV"{Unit<RadianUnitDescription, double>="_value"d}"_near"d"_far"d}
@"ARSession"
@"VKDebugTreeNode"
@"NSArray"
r^{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}
@32@0:8r^{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}16@24
@24@0:8r^{DebugTreeValue={ValueStruct=qQdB{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}i}16
r^{DebugTreeProperty={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{vector<mdc::DebugTreeValue, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}^{DebugTreeValue}{__compressed_pair<mdc::DebugTreeValue *, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}}}{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}}
@32@0:8r^{DebugTreeProperty={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{vector<mdc::DebugTreeValue, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}^{DebugTreeValue}{__compressed_pair<mdc::DebugTreeValue *, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}}}{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}}16@24
@32@0:8^{?={?=@*QQQQIQBQfQ@i}CCCCIfIII}16r^{?=@II{_NSRange=QQ}^{?}^{?}QQ{_NSRange=QQ}{_NSRange=QQ}B{_NSRange=QQ}{_NSRange=QQ}[2{_NSRange=QQ}][2{_NSRange=QQ}]}24
{?=ffff}16@0:8
^v16@0:8
@"GEOMapItemIdentifier"
{?="r"f"g"f"b"f"a"f}
@72@0:8{function<void ()>={__value_func<void ()>={type=[32C]}^{__base<void ()>}}}16@64
{function<void ()>="__f_"{__value_func<void ()>="__buf_"{type="__lx"[32C]}"__f_"^{__base<void ()>}}}
@"NSObject<OS_dispatch_queue>"
{?=dd}16@0:8
v32@0:8{?=dd}16
^{MapDataAccess=}16@0:8
^{AnimationRunner=}16@0:8
^{RunLoopController=}16@0:8
@"VKViewportInfo"16@0:8
B24@0:8@"VKViewportInfo"16
@"GEOMapRegion"16@0:8
@48@0:8^{MapDataAccess=}16^{AnimationRunner=}24^{RunLoopController=}32@40
{CGPoint=dd}16@0:8
{CGPoint=dd}32@0:8{CGPoint=dd}16
{Matrix<int, 2, 1>=[2i]}32@0:8{CGPoint=dd}16
B40@0:8^{?=dd}16^d24@32
@"<VKMapViewCameraDelegate>"
^{MapDataAccess=}
^{AnimationRunner=}
^{RunLoopController=}
@48@0:8^{MapDataAccess=^{World}C@^{CameraAccessInternal}{unique_ptr<md::CameraAccessCartographic, std::__1::default_delete<md::CameraAccessCartographic> >={__compressed_pair<md::CameraAccessCartographic *, std::__1::default_delete<md::CameraAccessCartographic> >=^{CameraAccessCartographic}}}{unique_ptr<md::CameraAccessGlobe, std::__1::default_delete<md::CameraAccessGlobe> >={__compressed_pair<md::CameraAccessGlobe *, std::__1::default_delete<md::CameraAccessGlobe> >=^{CameraAccessGlobe}}}{unique_ptr<md::CameraAccessMunin, std::__1::default_delete<md::CameraAccessMunin> >={__compressed_pair<md::CameraAccessMunin *, std::__1::default_delete<md::CameraAccessMunin> >=^{CameraAccessMunin}}}}16^{AnimationRunner=^{MapEngine}}24^{RunLoopController=^{MapEngine}qq}32@40
f24@0:8q16
f20@0:8f16
v44@0:8d16r^{Matrix<double, 3, 1>=[3d]}24B32B36B40
v36@0:8d16r^{Matrix<double, 3, 1>=[3d]}24B32
v48@0:8{CGPoint=dd}16d32@?40
v56@0:8d16{Matrix<double, 3, 1>=[3d]}24@?48
v48@0:8d16{Matrix<double, 3, 1>=[3d]}24
B20@0:8B16
v40@0:8^d16^d24d32
{?=dd}24@0:8@16
{Matrix<double, 3, 1>=[3d]}40@0:8{Matrix<double, 3, 1>=[3d]}16
v80@0:8{Matrix<double, 3, 1>=[3d]}16d40d48d56@?64@?72
v84@0:8{Matrix<double, 3, 1>=[3d]}16d40d48d56@?64B72@?76
v56@0:8{Matrix<double, 3, 1>=[3d]}16d40d48
v88@0:8{?=dd}16d32d40d48d56q64@?72@?80
v92@0:8{?=dd}16d32d40d48d56q64@?72B80@?84
v96@0:8{?=ddd}16d40d48d56d64q72@?80@?88
v48@0:8d16@?24@?32@?40
^{os_state_data_s=I(?=b32I){os_state_data_decoder_s=[64c][64c]}[64c][0C]}32@0:8@16@24
@80@0:8@16@24{function<NSString *()>={__value_func<NSString *()>={type=[32C]}^{__base<NSString *()>}}}32
^{os_state_data_s=I(?=b32I){os_state_data_decoder_s=[64c][64c]}[64c][0C]}16@0:8
{function<NSString *()>="__f_"{__value_func<NSString *()>="__buf_"{type="__lx"[32C]}"__f_"^{__base<NSString *()>}}}
@64@0:8{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}16^{MapDataAccess=}32^{AnimationRunner=^{MapEngine}}40^{RunLoopController=^{MapEngine}qq}48@56
{Geocentric<double>=[3d]}16@0:8
{Matrix<double, 3, 1>=[3d]}24@0:8r^{RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}16
v40@0:8r^{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}16d24@?32
v40@0:8r^{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}16d24@?32
{RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}16@0:8
^{GlobeView=^^?^{GeoServicesLoader}^{ManifestManager}^{TriggerManager}{shared_ptr<altitude::AnchorManager>=^{AnchorManager}^{__shared_weak_count}}^{DtmCacheNode}^{DtmRequestManager}^{FreezeViewNode}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}B{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<altitude::SimpleTileKey, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}^{SimpleTileKey}{__compressed_pair<altitude::SimpleTileKey *, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}}}BII^{VKClassicGlobeCanvas}BB{AnimationManager={AnimationReferenceTimer=ddd}{unique_ptr<altitude::AnimationTimer, std::__1::default_delete<altitude::AnimationTimer> >={__compressed_pair<altitude::AnimationTimer *, std::__1::default_delete<altitude::AnimationTimer> >=^{AnimationTimer}}}d{vector<altitude::AnimationObjectHolder, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}^{AnimationObjectHolder}{__compressed_pair<altitude::AnimationObjectHolder *, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}}}}{Stopwatch={time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >={duration<long long, std::__1::ratio<1, 1000000000> >=q}}}dB{Unit<RadianUnitDescription, double>=d}d{Unit<RadianUnitDescription, double>=d}{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}^{C3mmRequestManager}^{RenderableGroup}Id{?=dd}BB^{LabelDataManagerPrivate}BBBB^{RouteLineManager}^{GlobeCleanupLoader}^{CompleteGlobeTileSetCullingGraph}^{CompleteGlobeTileSetLoader}^{TileSetNode}^{GlobeTileRenderManager}^{CullingNode}^{EarthAdjustedViewNode}^{UserViewNode}^{View}^{BasicViewNode}^{GlobeMainViewNode}^{C3bRequestManager}fB{shared_ptr<bool>=^B^{__shared_weak_count}}^{HeightRequestManager}{map<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> >, altitude::GlobeView::LessVector2i, std::__1::allocator<std::__1::pair<const gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >={__tree<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true>, std::__1::allocator<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true> >=Q}}}{Mutex=^v}{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}^{FlyoverTour}B{Viewport=iiii}B{set<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >={__tree<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<altitude::ManifestListener *, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<altitude::ManifestListener *> >=Q}}}{unique_ptr<ReachabilityChangedObserver, std::__1::default_delete<ReachabilityChangedObserver> >={__compressed_pair<ReachabilityChangedObserver *, std::__1::default_delete<ReachabilityChangedObserver> >=^{ReachabilityChangedObserver}}}^{TileManager}^{ObjectTreeLoader}^{QuickSurfaceManager}^{IntersectorHeight}{shared_ptr<karo::SharedItemManager<altitude::Map, altitude::MapRequestId> >=^{SharedItemManager<altitude::Map, altitude::MapRequestId>}^{__shared_weak_count}}^{BundleLoader}^{ProtocolLoader}^{GeoResourceManager}^{GeoResourceLoader}^{ViewNode}^{ViewportNode}^{View}^{Viewport}{shared_ptr<ggl::RenderState>=^{RenderState}^{__shared_weak_count}}I^{Statistics}{atomic<bool>=AB}^{TexturePager}^{IOSurfacePool}^{RealisticRenderer}{DclpUnique<ggl::Texture2D, altitude::util::DclpDefaultDelete<ggl::Texture2D> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<ggl::Texture2D *>=A^{Texture2D}}{function<ggl::Texture2D *()>={__value_func<ggl::Texture2D *()>={type=[32C]}^{__base<ggl::Texture2D *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}}16@0:8
v24@0:8^{GlobeView=^^?^{GeoServicesLoader}^{ManifestManager}^{TriggerManager}{shared_ptr<altitude::AnchorManager>=^{AnchorManager}^{__shared_weak_count}}^{DtmCacheNode}^{DtmRequestManager}^{FreezeViewNode}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}B{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<altitude::SimpleTileKey, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}^{SimpleTileKey}{__compressed_pair<altitude::SimpleTileKey *, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}}}BII^{VKClassicGlobeCanvas}BB{AnimationManager={AnimationReferenceTimer=ddd}{unique_ptr<altitude::AnimationTimer, std::__1::default_delete<altitude::AnimationTimer> >={__compressed_pair<altitude::AnimationTimer *, std::__1::default_delete<altitude::AnimationTimer> >=^{AnimationTimer}}}d{vector<altitude::AnimationObjectHolder, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}^{AnimationObjectHolder}{__compressed_pair<altitude::AnimationObjectHolder *, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}}}}{Stopwatch={time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >={duration<long long, std::__1::ratio<1, 1000000000> >=q}}}dB{Unit<RadianUnitDescription, double>=d}d{Unit<RadianUnitDescription, double>=d}{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}^{C3mmRequestManager}^{RenderableGroup}Id{?=dd}BB^{LabelDataManagerPrivate}BBBB^{RouteLineManager}^{GlobeCleanupLoader}^{CompleteGlobeTileSetCullingGraph}^{CompleteGlobeTileSetLoader}^{TileSetNode}^{GlobeTileRenderManager}^{CullingNode}^{EarthAdjustedViewNode}^{UserViewNode}^{View}^{BasicViewNode}^{GlobeMainViewNode}^{C3bRequestManager}fB{shared_ptr<bool>=^B^{__shared_weak_count}}^{HeightRequestManager}{map<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> >, altitude::GlobeView::LessVector2i, std::__1::allocator<std::__1::pair<const gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >={__tree<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true>, std::__1::allocator<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true> >=Q}}}{Mutex=^v}{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}^{FlyoverTour}B{Viewport=iiii}B{set<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >={__tree<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<altitude::ManifestListener *, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<altitude::ManifestListener *> >=Q}}}{unique_ptr<ReachabilityChangedObserver, std::__1::default_delete<ReachabilityChangedObserver> >={__compressed_pair<ReachabilityChangedObserver *, std::__1::default_delete<ReachabilityChangedObserver> >=^{ReachabilityChangedObserver}}}^{TileManager}^{ObjectTreeLoader}^{QuickSurfaceManager}^{IntersectorHeight}{shared_ptr<karo::SharedItemManager<altitude::Map, altitude::MapRequestId> >=^{SharedItemManager<altitude::Map, altitude::MapRequestId>}^{__shared_weak_count}}^{BundleLoader}^{ProtocolLoader}^{GeoResourceManager}^{GeoResourceLoader}^{ViewNode}^{ViewportNode}^{View}^{Viewport}{shared_ptr<ggl::RenderState>=^{RenderState}^{__shared_weak_count}}I^{Statistics}{atomic<bool>=AB}^{TexturePager}^{IOSurfacePool}^{RealisticRenderer}{DclpUnique<ggl::Texture2D, altitude::util::DclpDefaultDelete<ggl::Texture2D> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<ggl::Texture2D *>=A^{Texture2D}}{function<ggl::Texture2D *()>={__value_func<ggl::Texture2D *()>={type=[32C]}^{__base<ggl::Texture2D *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}}16
v24@0:8^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ}16
v72@0:8{RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}16
{Unit<DegreeUnitDescription, double>=d}16@0:8
v24@0:8{Unit<DegreeUnitDescription, double>=d}16
^{GlobeView=^^?^{GeoServicesLoader}^{ManifestManager}^{TriggerManager}{shared_ptr<altitude::AnchorManager>=^{AnchorManager}^{__shared_weak_count}}^{DtmCacheNode}^{DtmRequestManager}^{FreezeViewNode}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}B{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<altitude::SimpleTileKey, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}^{SimpleTileKey}{__compressed_pair<altitude::SimpleTileKey *, std::__1::allocator<altitude::SimpleTileKey> >=^{SimpleTileKey}}}BII^{VKClassicGlobeCanvas}BB{AnimationManager={AnimationReferenceTimer=ddd}{unique_ptr<altitude::AnimationTimer, std::__1::default_delete<altitude::AnimationTimer> >={__compressed_pair<altitude::AnimationTimer *, std::__1::default_delete<altitude::AnimationTimer> >=^{AnimationTimer}}}d{vector<altitude::AnimationObjectHolder, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}^{AnimationObjectHolder}{__compressed_pair<altitude::AnimationObjectHolder *, std::__1::allocator<altitude::AnimationObjectHolder> >=^{AnimationObjectHolder}}}}{Stopwatch={time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >={duration<long long, std::__1::ratio<1, 1000000000> >=q}}}dB{Unit<RadianUnitDescription, double>=d}d{Unit<RadianUnitDescription, double>=d}{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}^{C3mmRequestManager}^{RenderableGroup}Id{?=dd}BB^{LabelDataManagerPrivate}BBBB^{RouteLineManager}^{GlobeCleanupLoader}^{CompleteGlobeTileSetCullingGraph}^{CompleteGlobeTileSetLoader}^{TileSetNode}^{GlobeTileRenderManager}^{CullingNode}^{EarthAdjustedViewNode}^{UserViewNode}^{View}^{BasicViewNode}^{GlobeMainViewNode}^{C3bRequestManager}fB{shared_ptr<bool>=^B^{__shared_weak_count}}^{HeightRequestManager}{map<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> >, altitude::GlobeView::LessVector2i, std::__1::allocator<std::__1::pair<const gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >={__tree<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true>, std::__1::allocator<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<gm::Matrix<int, 2, 1>, std::__1::__value_type<gm::Matrix<int, 2, 1>, std::__1::pair<bool, geo::Coordinate3D<Radians, double> > >, altitude::GlobeView::LessVector2i, true> >=Q}}}{Mutex=^v}{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}^{FlyoverTour}B{Viewport=iiii}B{set<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >={__tree<altitude::ManifestListener *, std::__1::less<altitude::ManifestListener *>, std::__1::allocator<altitude::ManifestListener *> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<altitude::ManifestListener *, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<altitude::ManifestListener *> >=Q}}}{unique_ptr<ReachabilityChangedObserver, std::__1::default_delete<ReachabilityChangedObserver> >={__compressed_pair<ReachabilityChangedObserver *, std::__1::default_delete<ReachabilityChangedObserver> >=^{ReachabilityChangedObserver}}}^{TileManager}^{ObjectTreeLoader}^{QuickSurfaceManager}^{IntersectorHeight}{shared_ptr<karo::SharedItemManager<altitude::Map, altitude::MapRequestId> >=^{SharedItemManager<altitude::Map, altitude::MapRequestId>}^{__shared_weak_count}}^{BundleLoader}^{ProtocolLoader}^{GeoResourceManager}^{GeoResourceLoader}^{ViewNode}^{ViewportNode}^{View}^{Viewport}{shared_ptr<ggl::RenderState>=^{RenderState}^{__shared_weak_count}}I^{Statistics}{atomic<bool>=AB}^{TexturePager}^{IOSurfacePool}^{RealisticRenderer}{DclpUnique<ggl::Texture2D, altitude::util::DclpDefaultDelete<ggl::Texture2D> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<ggl::Texture2D *>=A^{Texture2D}}{function<ggl::Texture2D *()>={__value_func<ggl::Texture2D *()>={type=[32C]}^{__base<ggl::Texture2D *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}{DclpUnique<altitude::TextureMap, altitude::util::DclpDefaultDelete<altitude::TextureMap> >={mutex={_opaque_pthread_mutex_t=q[56c]}}{atomic<altitude::TextureMap *>=A^{TextureMap}}{function<altitude::TextureMap *()>={__value_func<altitude::TextureMap *()>={type=[32C]}^{__base<altitude::TextureMap *()>}}}}}
{CameraFrame<geo::Radians, double>="_target"{Coordinate3D<Radians, double>="latitude"{Unit<RadianUnitDescription, double>="_value"d}"longitude"{Unit<RadianUnitDescription, double>="_value"d}"altitude"{Unit<MeterUnitDescription, double>="_value"d}}"_distanceFromTarget"{Unit<MeterUnitDescription, double>="_value"d}"_pitch"{Unit<RadianUnitDescription, double>="_value"d}"_heading"{Unit<RadianUnitDescription, double>="_value"d}"_roll"{Unit<RadianUnitDescription, double>="_value"d}}
{Quaternion<double>="_imaginary"{Matrix<double, 3, 1>="_e"[3d]}"_scalar"d}
{Coordinate2D<Radians, double>="latitude"{Unit<RadianUnitDescription, double>="_value"d}"longitude"{Unit<RadianUnitDescription, double>="_value"d}}
{Unit<DegreeUnitDescription, double>="_value"d}
@24@0:8r^{shared_ptr<md::FeatureMarker>=^{FeatureMarker}^{__shared_weak_count}}16
r^{shared_ptr<md::FeatureMarker>=^{FeatureMarker}^{__shared_weak_count}}16@0:8
{shared_ptr<md::FeatureMarker>="__ptr_"^{FeatureMarker}"__cntrl_"^{__shared_weak_count}}
v24@0:8^{CameraManager=^^?BBB{Matrix<int, 2, 1>=[2i]}{Matrix<int, 2, 1>=[2i]}{Matrix<int, 2, 1>=[2i]}{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}dBBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Matrix<int, 2, 1>=[2i]}dBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Matrix<int, 2, 1>=[2i]}{Matrix<int, 2, 1>=[2i]}dBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Matrix<int, 2, 1>=[2i]}ddBBiBBBddd{Geocentric<double>=[3d]}{Matrix<double, 3, 1>=[3d]}d{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}}16
^{CameraManager=^^?BBB{Matrix<int, 2, 1>=[2i]}{Matrix<int, 2, 1>=[2i]}{Matrix<int, 2, 1>=[2i]}{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}dBBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Matrix<int, 2, 1>=[2i]}dBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Matrix<int, 2, 1>=[2i]}{Matrix<int, 2, 1>=[2i]}dBBB{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Matrix<int, 2, 1>=[2i]}ddBBiBBBddd{Geocentric<double>=[3d]}{Matrix<double, 3, 1>=[3d]}d{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}}
@24@0:8^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ}16
C24@0:8q16
q20@0:8C16
I20@0:8C16
@48@0:8{shared_ptr<grl::IconManager>=^{IconManager}^{__shared_weak_count}}16{shared_ptr<md::StylesheetVendor>=^{StylesheetVendor}^{__shared_weak_count}}32
@60@0:8@16{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}24f40q44@52
@52@0:8@16@24f32q36@44
@48@0:8I16@20f28q32@40
@44@0:8I16I20f24q28@36
@44@0:8@16f24q28@36
I16@0:8
{read_write_lock="_lock"{_opaque_pthread_rwlock_t="__sig"q"__opaque"[192c]}}
{map<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> >, NSStringMapComparison, geo::StdAllocator<std::__1::pair<const geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> > >, mdm::Allocator> >="__tree_"{__tree<std::__1::__value_type<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> > >, std::__1::__map_value_compare<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::__value_type<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> > >, NSStringMapComparison, true>, geo::StdAllocator<std::__1::__value_type<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> > >, mdm::Allocator> >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> > >, void *>, mdm::Allocator> >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}"__value_"{StdAllocator<std::__1::__tree_node<std::__1::__value_type<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> > >, void *>, mdm::Allocator>="_allocator"^{Allocator}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::__value_type<geo::_retain_ptr<NSString *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, std::__1::shared_ptr<gss::StylesheetManager<gss::PropertyID> > >, NSStringMapComparison, true> >="__value_"Q}}}
v28@0:8Q16B24
v24@0:8r^{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}16
r^{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}16@0:8
v24@0:8^{basic_ostream<char, std::__1::char_traits<char> >=^^?^^?IqqII^v^v^^?^iQQ^qQQ^^vQQ^{basic_ostream<char, std::__1::char_traits<char> >}i}16
{optional<mdc::DebugTreeValue>=B(ValueUnion=[64C]{DebugTreeValue={ValueStruct=qQdB{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}i})}24@0:8@16
@24@0:8r^{DebugTreeProperty={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{vector<mdc::DebugTreeValue, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}^{DebugTreeValue}{__compressed_pair<mdc::DebugTreeValue *, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}}}{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}}16
{optional<mdc::DebugTreeProperty>=B(ValueUnion=[80C]{DebugTreeProperty={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{vector<mdc::DebugTreeValue, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}^{DebugTreeValue}{__compressed_pair<mdc::DebugTreeValue *, std::__1::allocator<mdc::DebugTreeValue> >=^{DebugTreeValue}}}{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}})}24@0:8@16
@24@0:8r^{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}16
{optional<mdc::DebugTreeNode>=B(ValueUnion=[96C]{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}})}24@0:8@16
{DebugTreeNode="_name"{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"_identifier"{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"_children"{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >="__begin_"^{DebugTreeNode}"__end_"^{DebugTreeNode}"__end_cap_"{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >="__value_"^{DebugTreeNode}}}"_properties"{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >="__begin_"^{DebugTreeProperty}"__end_"^{DebugTreeProperty}"__end_cap_"{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >="__value_"^{DebugTreeProperty}}}}
{bitset<4>="__first_"Q}
@40@0:8@16r^{Mercator2<double>=[2d]}24r^{Mercator2<double>=[2d]}32
v24@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16
{Mercator2<double>=[2d]}16@0:8
v32@0:8{Mercator2<double>=[2d]}16
{shared_ptr<md::LabelIcon>=^{LabelIcon}^{__shared_weak_count}}24@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16
@"VKLabelNavRoadLabel"
{Mercator2<double>="_e"[2d]}
@"VKTrafficFeature"
{shared_ptr<md::LabelStyle>="__ptr_"^{LabelStyle}"__cntrl_"^{__shared_weak_count}}
@"VKTrafficCameraFeature"
@"VKTrafficSignalFeature"
@48@0:8^{MapDataAccess=}16^{AnimationRunner=}24^{RunLoopController=^{MapEngine}qq}32@40
v32@0:8B16d20B28
v28@0:8B16d20
v48@0:8@16@24@32^v40
@"<VKTrackableAnnotation>"
@"<VKTrackableAnnotationPresentation>"
{?="hasPendingChange"b1"paused"b1"trackingHeading"b1"hasPendingHeadingChange"b1"isInitialRegionChange"b1"isJumpingToAnnotation"b1"annotationImplementsAccuracy"b1"annotationImplementsHeading"b1"annotationImplementsExpectedCoordinateUpdateInterval"b1"annotationImplementsExpectedHeadingUpdateInterval"b1}
@40@0:8@16@24I32I36
^{Matrix<float, 2, 1>=[2f]}16@0:8
v28@0:8^{Matrix<float, 2, 1>=[2f]}16I24
v32@0:8@16r^{TrafficSegment=IC}24
v36@0:8@16^{TrafficSegmentsAlongRoute={vector<md::TrafficSegment, std::__1::allocator<md::TrafficSegment> >=^{TrafficSegment}^{TrafficSegment}{__compressed_pair<md::TrafficSegment *, std::__1::allocator<md::TrafficSegment> >=^{TrafficSegment}}}}24B32
@"VKPolylineOverlay"
@"GEOComposedRouteSection"
@"GEOSnappedRoutePath"
{vector<gm::Matrix<float, 2, 1>, std::__1::allocator<gm::Matrix<float, 2, 1> > >="__begin_"^{Matrix<float, 2, 1>}"__end_"^{Matrix<float, 2, 1>}"__end_cap_"{__compressed_pair<gm::Matrix<float, 2, 1> *, std::__1::allocator<gm::Matrix<float, 2, 1> > >="__value_"^{Matrix<float, 2, 1>}}}
{optional<std::__1::vector<double, std::__1::allocator<double> > >="_hasValue"B"_value"(ValueUnion="data"[24C]"type"{vector<double, std::__1::allocator<double> >="__begin_"^d"__end_"^d"__end_cap_"{__compressed_pair<double *, std::__1::allocator<double> >="__value_"^d}})}
@84@0:8@16@24^{Matrix<float, 2, 1>=[2f]}32Q40B48^{?={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}}52I60I64Q68I76C80
@76@0:8@16@24^{Matrix<float, 2, 1>=[2f]}32Q40B48^{?={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}}52I60I64Q68
@56@0:8@16@24^{Matrix<float, 2, 1>=[2f]}32Q40I48I52
@24@0:8r^{MuninRoadEdge=^{?}f{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}QQ^{MuninJunction}^{MuninJunction}B}16
@24@0:8^{AnimationRunner=^{MapEngine}}16
^{NavigationPuck=^{PuckStyleInfo}{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<RadianUnitDescription, double>=d}ffiBBB}16@0:8
@"<VKAnnotation>"
^{NavigationPuck=^{PuckStyleInfo}{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<RadianUnitDescription, double>=d}ffiBBB}
Q24@0:8Q16
@"GEOMapRegion"
^{__CFSet=}
@32@0:8@16r^{TaskContext=@{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}{unique_ptr<geo::TaskQueue, std::__1::default_delete<geo::TaskQueue> >={__compressed_pair<geo::TaskQueue *, std::__1::default_delete<geo::TaskQueue> >=^{TaskQueue}}}}24
{_geo_weak_ptr<id<VKNotificationObserverDelegate> >="_p"@"<VKNotificationObserverDelegate>"}
@"NSObject<OS_dispatch_source>"
@24@0:8r^{IconModifiers=BBff{optional<geo::Color<unsigned char, 4, geo::ColorSpace::sRGB> >=B(ValueUnion=[4C]{Color<unsigned char, 4, geo::ColorSpace::sRGB>={Matrix<unsigned char, 4, 1>=[4C]}})}{optional<geo::Color<unsigned char, 4, geo::ColorSpace::sRGB> >=B(ValueUnion=[4C]{Color<unsigned char, 4, geo::ColorSpace::sRGB>={Matrix<unsigned char, 4, 1>=[4C]}})}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<gm::Matrix<float, 2, 1> >=B(ValueUnion=[8C]{Matrix<float, 2, 1>=[2f]})}{optional<std::__1::basic_string<char> >=B(ValueUnion=[24C]{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}})}{map<unsigned short, std::__1::basic_string<char>, std::__1::less<unsigned short>, geo::StdAllocator<std::__1::pair<const unsigned short, std::__1::basic_string<char> >, grl::Allocator> >={__tree<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::__map_value_compare<unsigned short, std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::less<unsigned short>, true>, geo::StdAllocator<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, grl::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, void *>, grl::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, void *>, grl::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned short, std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::less<unsigned short>, true> >=Q}}}}16
^{IconModifiers=BBff{optional<geo::Color<unsigned char, 4, geo::ColorSpace::sRGB> >=B(ValueUnion=[4C]{Color<unsigned char, 4, geo::ColorSpace::sRGB>={Matrix<unsigned char, 4, 1>=[4C]}})}{optional<geo::Color<unsigned char, 4, geo::ColorSpace::sRGB> >=B(ValueUnion=[4C]{Color<unsigned char, 4, geo::ColorSpace::sRGB>={Matrix<unsigned char, 4, 1>=[4C]}})}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<gm::Matrix<float, 2, 1> >=B(ValueUnion=[8C]{Matrix<float, 2, 1>=[2f]})}{optional<std::__1::basic_string<char> >=B(ValueUnion=[24C]{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}})}{map<unsigned short, std::__1::basic_string<char>, std::__1::less<unsigned short>, geo::StdAllocator<std::__1::pair<const unsigned short, std::__1::basic_string<char> >, grl::Allocator> >={__tree<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::__map_value_compare<unsigned short, std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::less<unsigned short>, true>, geo::StdAllocator<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, grl::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, void *>, grl::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, void *>, grl::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned short, std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::less<unsigned short>, true> >=Q}}}}16@0:8
v32@0:8{?=ffff}16
{IconModifiers="_isGlyphHidden"B"_isGlyphOnly"B"_opacity"f"_scale"f"_textColor"{optional<geo::Color<unsigned char, 4, geo::ColorSpace::sRGB> >="_hasValue"B"_value"(ValueUnion="data"[4C]"type"{Color<unsigned char, 4, geo::ColorSpace::sRGB>="_backing"{Matrix<unsigned char, 4, 1>="_e"[4C]}})}"_transitLineColor"{optional<geo::Color<unsigned char, 4, geo::ColorSpace::sRGB> >="_hasValue"B"_value"(ValueUnion="data"[4C]"type"{Color<unsigned char, 4, geo::ColorSpace::sRGB>="_backing"{Matrix<unsigned char, 4, 1>="_e"[4C]}})}"_fontSize"{optional<float>="_hasValue"B"_value"(ValueUnion="data"[4C]"type"f)}"_tailDirection"{optional<float>="_hasValue"B"_value"(ValueUnion="data"[4C]"type"f)}"_textBaseline"{optional<float>="_hasValue"B"_value"(ValueUnion="data"[4C]"type"f)}"_fillSize"{optional<gm::Matrix<float, 2, 1> >="_hasValue"B"_value"(ValueUnion="data"[8C]"type"{Matrix<float, 2, 1>="_e"[2f]})}"_fontName"{optional<std::__1::basic_string<char> >="_hasValue"B"_value"(ValueUnion="data"[24C]"type"{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}})}"_text"{map<unsigned short, std::__1::basic_string<char>, std::__1::less<unsigned short>, geo::StdAllocator<std::__1::pair<const unsigned short, std::__1::basic_string<char> >, grl::Allocator> >="__tree_"{__tree<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::__map_value_compare<unsigned short, std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::less<unsigned short>, true>, geo::StdAllocator<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, grl::Allocator> >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, void *>, grl::Allocator> >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}"__value_"{StdAllocator<std::__1::__tree_node<std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, void *>, grl::Allocator>="_allocator"^{Allocator}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned short, std::__1::__value_type<unsigned short, std::__1::basic_string<char> >, std::__1::less<unsigned short>, true> >="__value_"Q}}}}
@32@0:8{shared_ptr<grl::IconImage>=^{IconImage}^{__shared_weak_count}}16
^{CGImage=}16@0:8
{CGSize=dd}16@0:8
^{CGColor=}16@0:8
{shared_ptr<grl::IconImage>="__ptr_"^{IconImage}"__cntrl_"^{__shared_weak_count}}
{_retain_ptr<CGColor *, geo::_retain_cf<CGColor *>, geo::_release_cf, geo::_hash_cf, geo::_equal_cf>="_vptr$_retain_ptr"^^?"_obj"^{CGColor}"_retain"{_retain_cf<CGColor *>=}"_release"{_release_cf=}}
@"VKInternalIconManager"
v24@0:8@"VKRouteContext"16
@24@0:8^{RouteContextChangeObserver=^^?}16
^{RouteContextChangeObserver=^^?}
{vector<geo::_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, geo::StdAllocator<geo::_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, mdm::Allocator> >="__begin_"^{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>}"__end_"^{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>}"__end_cap_"{__compressed_pair<geo::_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc> *, geo::StdAllocator<geo::_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, mdm::Allocator> >="__value_"^{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>}"__value_"{StdAllocator<geo::_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>, mdm::Allocator>="_allocator"^{Allocator}}}}
v24@0:8^v16
{CGPoint=dd}24@0:8@16
{shared_ptr<md::Anchor>=^{Anchor}^{__shared_weak_count}}24@0:8^{AnchorManager=^^?B^{GlobeView}^{MercatorTerrainHeightCache}{unordered_set<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> >={__hash_table<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>, std::__1::allocator<std::__1::__hash_node<md::Anchor *, void *> > >={__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>=^{__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<md::Anchor *> >=Q}{__compressed_pair<float, std::__1::equal_to<md::Anchor *> >=f}}}}16
{shared_ptr<md::Anchor>="__ptr_"^{Anchor}"__cntrl_"^{__shared_weak_count}}
{CGPoint="x"d"y"d}
r^{CameraContext=^^?{SingleCameraContext=^^?{CameraView={Camera={CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}{ViewSize=SS}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}d{Matrix<float, 2, 1>=[2f]}}{PerspectiveView<double>={RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}{Matrix<double, 4, 4>=[16d]}{Matrix<double, 4, 4>=[16d]}{Matrix<double, 4, 4>=[16d]}dd{ViewSize=SS}i{Unit<RadianUnitDescription, double>=d}dd}{Frustum<double>={array<gm::Plane3<double>, 6>=[6{Plane3<double>={Matrix<double, 3, 1>=[3d]}d}]}{array<gm::Matrix<double, 3, 1>, 8>=[8{Matrix<double, 3, 1>=[3d]}]}}}{CGSize=dd}d{MercatorCameraContext=^{SingleCameraContext}{CGSize=dd}d{Matrix<double, 4, 4>=[16d]}{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}{ConvexHull2<double>={vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}}Bddd{Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}ddB}{Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}{Matrix<double, 4, 4>=[16d]}{View<double>={RigidTransform<double, double>={Matrix<double, 3, 1>=[3d]}{Quaternion<double>={Matrix<double, 3, 1>=[3d]}d}}{Matrix<double, 4, 4>=[16d]}{Matrix<double, 4, 4>=[16d]}{Matrix<double, 4, 4>=[16d]}dd{ViewSize=SS}i}dddd}{unique_ptr<md::SingleCameraContext, std::__1::default_delete<md::SingleCameraContext> >={__compressed_pair<md::SingleCameraContext *, std::__1::default_delete<md::SingleCameraContext> >=^{SingleCameraContext}}}}
^{AnchorManager=^^?B^{GlobeView}^{MercatorTerrainHeightCache}{unordered_set<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> >={__hash_table<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>, std::__1::allocator<std::__1::__hash_node<md::Anchor *, void *> > >={__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>=^{__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<md::Anchor *> >=Q}{__compressed_pair<float, std::__1::equal_to<md::Anchor *> >=f}}}}
{Coordinate2D<Degrees, double>="latitude"{Unit<DegreeUnitDescription, double>="_value"d}"longitude"{Unit<DegreeUnitDescription, double>="_value"d}}
@"<VKPuckAnimatorTarget>"
@"VKRunningCurve"
@"VKPuckAnimatorLocationProjector"
@"<VKPuckAnimatorDelegate>"
@"GEORouteMatch"
@24@0:8r^{LabelMarkerFeatureHandle=Cq{MercatorTile=Cii}iI@}16
r^{LabelMarkerFeatureHandle=Cq{MercatorTile=Cii}iI@}16@0:8
{LabelMarkerFeatureHandle="featureType"C"featureIndex"q"key"{MercatorTile="_level"C"_latIdx"i"_lonIdx"i}"tileStyle"i"tileVersion"I"styleAttributes"@"GEOFeatureStyleAttributes"}
@"VKImageSourceKey"
@24@0:8r^{shared_ptr<md::LabelMarker>=^{LabelMarker}^{__shared_weak_count}}16
r^{shared_ptr<md::LabelMarker>=^{LabelMarker}^{__shared_weak_count}}16@0:8
r^Q16@0:8
s16@0:8
B32@0:8^{?=dd}16^f24
{CGPoint=dd}44@0:8{CGSize=dd}16d32B40
{CGPoint=dd}40@0:8{CGSize=dd}16d32
B36@0:8{CGPoint=dd}16B32
{shared_ptr<md::LabelMarker>="__ptr_"^{LabelMarker}"__cntrl_"^{__shared_weak_count}}
v32@0:8@16Q24
v40@0:8@16{PolylineCoordinate=If}24{PolylineCoordinate=If}32
@"GEOComposedRoute"
@"NSHashTable"
{vector<AdditionalRouteInfo, std::__1::allocator<AdditionalRouteInfo> >="__begin_"^{AdditionalRouteInfo}"__end_"^{AdditionalRouteInfo}"__end_cap_"{__compressed_pair<AdditionalRouteInfo *, std::__1::allocator<AdditionalRouteInfo> >="__value_"^{AdditionalRouteInfo}}}
@24@0:8r^{CollectionPoint=Q{RigidTransform<double, float>={Matrix<double, 3, 1>=[3d]}{Quaternion<float>={Matrix<float, 3, 1>=[3f]}f}}{Unit<RadianUnitDescription, float>=f}{Mercator3<double>=[3d]}Q{small_vector<md::mun::PhotoInfo, 6>=^{PhotoInfo}^{PhotoInfo}^{PhotoInfo}Q[6{type=[288C]}]}fISCCC}16
@40@0:8{?=ddd}16
r^{CollectionPoint=Q{RigidTransform<double, float>={Matrix<double, 3, 1>=[3d]}{Quaternion<float>={Matrix<float, 3, 1>=[3f]}f}}{Unit<RadianUnitDescription, float>=f}{Mercator3<double>=[3d]}Q{small_vector<md::mun::PhotoInfo, 6>=^{PhotoInfo}^{PhotoInfo}^{PhotoInfo}Q[6{type=[288C]}]}fISCCC}16@0:8
{optional<md::mun::CollectionPoint>="_hasValue"B"_value"(ValueUnion="data"[1864C]"type"{CollectionPoint="pointId"Q"frame"{RigidTransform<double, float>="_translation"{Matrix<double, 3, 1>="_e"[3d]}"_rotation"{Quaternion<float>="_imaginary"{Matrix<float, 3, 1>="_e"[3f]}"_scalar"f}}"heading"{Unit<RadianUnitDescription, float>="_value"f}"mercatorPosition"{Mercator3<double>="_e"[3d]}"time"Q"photos"{small_vector<md::mun::PhotoInfo, 6>="_begin"^{PhotoInfo}"_end"^{PhotoInfo}"_fixedStorage"^{PhotoInfo}"_capacity"Q"storage"[6{type="__lx"[288C]}]}"heightAboveGroundMeters"f"buildId"I"bucketId"S"type"C"dataType"C"texturedLodMask"C})}
{?="latitude"d"longitude"d"altitude"d}
@24@0:8^{_NSZone=}16
{?="matchingStyleAttributeLongValue"b1"anchorPointX"b1"anchorPointY"b1"iconRectHeight"b1"iconRectWidth"b1"iconRectX"b1"iconRectY"b1"matchingStyleAttributeKey"b1"matchingStyleAttributeValue"b1"size"b1}
@40@0:8^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}16f24r^{Matrix<float, 2, 1>=[2f]}28f36
r^{Matrix<float, 3, 1>=[3f]}16@0:8
{Matrix<float, 3, 1>=[3f]}16@0:8
^{vector<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> >, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >=^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}{__compressed_pair<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > *, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >=^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}}}16@0:8
^{vector<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >=^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >=^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}}}16@0:8
r^{MultiRange<unsigned long>={vector<gm::Range<unsigned long>, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}^{Range<unsigned long>}{__compressed_pair<gm::Range<unsigned long> *, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}}}}84@0:8^{Batcher={MultiRange<unsigned long>={vector<gm::Range<unsigned long>, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}^{Range<unsigned long>}{__compressed_pair<gm::Range<unsigned long> *, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}}}}{vector<gm::MultiRange<unsigned long>, geo::StdAllocator<gm::MultiRange<unsigned long>, ggl::Allocator> >=^{MultiRange<unsigned long>}^{MultiRange<unsigned long>}{__compressed_pair<gm::MultiRange<unsigned long> *, geo::StdAllocator<gm::MultiRange<unsigned long>, ggl::Allocator> >=^{MultiRange<unsigned long>}{StdAllocator<gm::MultiRange<unsigned long>, ggl::Allocator>=^{Allocator}}}}{MultiRange<unsigned long>={vector<gm::Range<unsigned long>, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}^{Range<unsigned long>}{__compressed_pair<gm::Range<unsigned long> *, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}}}}}16Q24I32{function<bool (unsigned long long)>={__value_func<bool (unsigned long long)>={type=[32C]}^{__base<bool (unsigned long long)>}}}36
r^{MultiRange<unsigned long>={vector<gm::Range<unsigned long>, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}^{Range<unsigned long>}{__compressed_pair<gm::Range<unsigned long> *, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}}}}36@0:8^{Batcher={MultiRange<unsigned long>={vector<gm::Range<unsigned long>, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}^{Range<unsigned long>}{__compressed_pair<gm::Range<unsigned long> *, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}}}}{vector<gm::MultiRange<unsigned long>, geo::StdAllocator<gm::MultiRange<unsigned long>, ggl::Allocator> >=^{MultiRange<unsigned long>}^{MultiRange<unsigned long>}{__compressed_pair<gm::MultiRange<unsigned long> *, geo::StdAllocator<gm::MultiRange<unsigned long>, ggl::Allocator> >=^{MultiRange<unsigned long>}{StdAllocator<gm::MultiRange<unsigned long>, ggl::Allocator>=^{Allocator}}}}{MultiRange<unsigned long>={vector<gm::Range<unsigned long>, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}^{Range<unsigned long>}{__compressed_pair<gm::Range<unsigned long> *, std::__1::allocator<gm::Range<unsigned long> > >=^{Range<unsigned long>}}}}}16Q24I32
C24@0:8@16
v24@0:8^{ResourceAccessor=^^?}16
B24@0:8^{?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}16
B24@0:8Q16
r^{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > >={__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long long> >=f}}}16@0:8
v24@0:8r^{PolygonRouteAttributes=ICB}16
{Matrix<float, 2, 1>=[2f]}16@0:8
{optional<md::MeshSet<ggl::PolygonBase::CompressedMeshMesh, ggl::PolygonBase::CompressedVbo> >="_hasValue"B"_value"(ValueUnion="data"[152C]"type"{MeshSet<ggl::PolygonBase::CompressedMeshMesh, ggl::PolygonBase::CompressedVbo>="_vertexAndIndexCounts"{vector<std::__1::pair<unsigned short, unsigned int>, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__begin_"^{pair<unsigned short, unsigned int>}"__end_"^{pair<unsigned short, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<unsigned short, unsigned int> *, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__value_"^{pair<unsigned short, unsigned int>}}}"_meshes"{vector<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >="__begin_"^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}"__end_"^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >="__value_"^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}}}"_vertexDataWrite"{DataWrite<ggl::PolygonBase::CompressedVbo>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_indexDataWrite"{DataWrite<unsigned short>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_meshIndex"C"_meshVertexOffset"S"_meshIndexOffset"I})}
{vector<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >="__begin_"^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}"__end_"^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonBase::CompressedMeshMesh> > >="__value_"^{shared_ptr<ggl::PolygonBase::CompressedMeshMesh>}}}
{vector<std::__1::vector<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> >, std::__1::allocator<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> > > >, std::__1::allocator<std::__1::vector<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> >, std::__1::allocator<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> > > > > >="__begin_"^{vector<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> >, std::__1::allocator<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> > > >}"__end_"^{vector<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> >, std::__1::allocator<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> > > >}"__end_cap_"{__compressed_pair<std::__1::vector<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> >, std::__1::allocator<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> > > > *, std::__1::allocator<std::__1::vector<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> >, std::__1::allocator<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> > > > > >="__value_"^{vector<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> >, std::__1::allocator<std::__1::vector<FeatureRange, std::__1::allocator<FeatureRange> > > >}}}
{unordered_map<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> >, std::__1::hash<SectionKey>, std::__1::equal_to<std::__1::pair<void *, unsigned long> >, std::__1::allocator<std::__1::pair<const std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > > > >="__table_"{__hash_table<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, std::__1::__unordered_map_hasher<std::__1::pair<void *, unsigned long>, std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, std::__1::hash<SectionKey>, true>, std::__1::__unordered_map_equal<std::__1::pair<void *, unsigned long>, std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, std::__1::equal_to<std::__1::pair<void *, unsigned long> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > > > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<void *, unsigned long>, std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, std::__1::hash<SectionKey>, true> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<void *, unsigned long>, std::__1::__hash_value_type<std::__1::pair<void *, unsigned long>, std::__1::vector<Edge, std::__1::allocator<Edge> > >, std::__1::equal_to<std::__1::pair<void *, unsigned long> >, true> >="__value_"f}}}
{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >="__table_"{__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::equal_to<unsigned long long> >="__value_"f}}}
{Box<float, 3>="_minimum"{Matrix<float, 3, 1>="_e"[3f]}"_maximum"{Matrix<float, 3, 1>="_e"[3f]}}
{vector<ggl::Batcher, std::__1::allocator<ggl::Batcher> >="__begin_"^{Batcher}"__end_"^{Batcher}"__end_cap_"{__compressed_pair<ggl::Batcher *, std::__1::allocator<ggl::Batcher> >="__value_"^{Batcher}}}
{Matrix<float, 2, 1>="_e"[2f]}
@"NSMutableOrderedSet"
{vector<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> >, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >="__begin_"^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}"__end_"^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > *, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >="__value_"^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}}}
{PolygonRouteAttributes="routeSignificance"I"routeProximity"C"hasRouteSignificance"B}
@"NSMutableArray"
@"NSData"
{Matrix<double, 3, 1>=[3d]}64@0:8{Matrix<double, 3, 1>=[3d]}16{Matrix<double, 3, 1>=[3d]}40
v48@0:8{Matrix<double, 3, 1>=[3d]}16d40
B24@0:8d16
{?={Matrix<double, 3, 1>=[3d]}{Matrix<double, 3, 1>=[3d]}B}24@0:8d16
{?="position"{Matrix<double, 3, 1>="_e"[3d]}"tangent"{Matrix<double, 3, 1>="_e"[3d]}"tangentValid"B}
{?="mb"[4[3d]]}
v32@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}24
@"VKPGenericShieldStyleInfo"
v32@0:8{?=fIII}16
v36@0:8{?={?=fIII}f}16
v48@0:8{?={?=fIII}fff{?=b1b1}}16
^f16@0:8
f24@0:8Q16
v32@0:8^f16Q24
^{?=IiifI{?=b1b1b1b1b1}}16@0:8
v40@0:8{?=IiifI{?=b1b1b1b1b1}}16
{?=IiifI{?=b1b1b1b1b1}}24@0:8Q16
v32@0:8^{?=IiifI{?=b1b1b1b1b1}}16Q24
{?=fIII}16@0:8
{?={?=fIII}f}16@0:8
{?={?=fIII}fff{?=b1b1}}16@0:8
{?="_color"{?="_a"f"_b"I"_g"I"_r"I}"_offsetX"f"_offsetY"f"_size"f"_has"{?="offsetX"b1"offsetY"b1}}
^{?=IiifI{?=b1b1b1b1b1}}
{?="_color"{?="_a"f"_b"I"_g"I"_r"I}"_width"f}
{?="_a"f"_b"I"_g"I"_r"I}
{?="list"^f"count"Q"size"Q}
{?="textShadow"b1"textStroke"b1"fontColor"b1"nonDigitFontColor"b1"atlasIndex"b1"backgroundColor"b1"borderColor"b1"capWidthLeft"b1"capWidthRight"b1"centerOffsetX"b1"fontSize"b1"lineSpacing"b1"maxDigits"b1"minDigits"b1"nonDigitFontSize"b1"paddingLeft"b1"paddingRight"b1"quadIndex"b1"textBaseline"b1"textMaskColor"b1}
@32@0:8r^{Incident={GeoCoordinates={Longitude=I}{Latitude=I}i}{String={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{String={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{String={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{String={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}qqqqiCBiCC}16^{Matrix<double, 3, 1>=[3d]}24
@32@0:8@16q24
@"NSDate"
@72@0:8{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}16^{MapDataAccess=^{World}C@^{CameraAccessInternal}{unique_ptr<md::CameraAccessCartographic, std::__1::default_delete<md::CameraAccessCartographic> >={__compressed_pair<md::CameraAccessCartographic *, std::__1::default_delete<md::CameraAccessCartographic> >=^{CameraAccessCartographic}}}{unique_ptr<md::CameraAccessGlobe, std::__1::default_delete<md::CameraAccessGlobe> >={__compressed_pair<md::CameraAccessGlobe *, std::__1::default_delete<md::CameraAccessGlobe> >=^{CameraAccessGlobe}}}{unique_ptr<md::CameraAccessMunin, std::__1::default_delete<md::CameraAccessMunin> >={__compressed_pair<md::CameraAccessMunin *, std::__1::default_delete<md::CameraAccessMunin> >=^{CameraAccessMunin}}}}32^{AnimationRunner=^{MapEngine}}40^{RunLoopController=^{MapEngine}qq}48@56^{MuninSceneLogic=^^?BS{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{World}^{LoadingStatusTracker}^{RunLoopController}{unique_ptr<md::mun::MuninMetadataContainer, std::__1::default_delete<md::mun::MuninMetadataContainer> >={__compressed_pair<md::mun::MuninMetadataContainer *, std::__1::default_delete<md::mun::MuninMetadataContainer> >=^{MuninMetadataContainer}}}{vector<md::mun::ViewId, std::__1::allocator<md::mun::ViewId> >=^{ViewId}^{ViewId}{__compressed_pair<md::mun::ViewId *, std::__1::allocator<md::mun::ViewId> >=^{ViewId}}}{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > >={__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long long> >=f}}}{linear_map<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> >, std::__1::equal_to<unsigned short>, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > >, std::__1::vector<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > > > >={vector<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > > >=^{pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >}^{pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >}{__compressed_pair<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > *, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > > >=^{pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >}}}}{MuninDebugViewContext={vector<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>, std::__1::allocator<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState> > >=^{pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>}^{pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>}{__compressed_pair<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState> *, std::__1::allocator<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState> > >=^{pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>}}}B{Stopwatch={time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >={duration<long long, std::__1::ratio<1, 1000000000> >=q}}}}{unique_ptr<md::mun::MuninDisplayAnalytic, std::__1::default_delete<md::mun::MuninDisplayAnalytic> >={__compressed_pair<md::mun::MuninDisplayAnalytic *, std::__1::default_delete<md::mun::MuninDisplayAnalytic> >=^{MuninDisplayAnalytic}}}{unique_ptr<md::mun::MuninNavigation, std::__1::default_delete<md::mun::MuninNavigation> >={__compressed_pair<md::mun::MuninNavigation *, std::__1::default_delete<md::mun::MuninNavigation> >=^{MuninNavigation}}}{unique_ptr<md::mun::MuninIntersector, std::__1::default_delete<md::mun::MuninIntersector> >={__compressed_pair<md::mun::MuninIntersector *, std::__1::default_delete<md::mun::MuninIntersector> >=^{MuninIntersector}}}{unique_ptr<md::FadeEffectBlock, std::__1::default_delete<md::FadeEffectBlock> >={__compressed_pair<md::FadeEffectBlock *, std::__1::default_delete<md::FadeEffectBlock> >=^{FadeEffectBlock}}}{vector<md::MuninSceneEvent, std::__1::allocator<md::MuninSceneEvent> >=^{MuninSceneEvent}^{MuninSceneEvent}{__compressed_pair<md::MuninSceneEvent *, std::__1::allocator<md::MuninSceneEvent> >=^{MuninSceneEvent}}}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{MuninSettings=ddddddddddddddCSiCC{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}{vector<unsigned short, std::__1::allocator<unsigned short> >=^S^S{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >=^S}}BQ}64
v72@0:8{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}16
v24@0:8r^{CollectionPoint=Q{RigidTransform<double, float>={Matrix<double, 3, 1>=[3d]}{Quaternion<float>={Matrix<float, 3, 1>=[3f]}f}}{Unit<RadianUnitDescription, float>=f}{Mercator3<double>=[3d]}Q{small_vector<md::mun::PhotoInfo, 6>=^{PhotoInfo}^{PhotoInfo}^{PhotoInfo}Q[6{type=[288C]}]}fISCCC}16
{Matrix<float, 2, 1>=[2f]}32@0:8{CGPoint=dd}16
v32@0:8r^{shared_ptr<md::LabelMarker>=^{LabelMarker}^{__shared_weak_count}}16@?24
B52@0:8r^{CollectionPoint=Q{RigidTransform<double, float>={Matrix<double, 3, 1>=[3d]}{Quaternion<float>={Matrix<float, 3, 1>=[3f]}f}}{Unit<RadianUnitDescription, float>=f}{Mercator3<double>=[3d]}Q{small_vector<md::mun::PhotoInfo, 6>=^{PhotoInfo}^{PhotoInfo}^{PhotoInfo}Q[6{type=[288C]}]}fISCCC}16{Unit<RadianUnitDescription, double>=d}24{Unit<RadianUnitDescription, double>=d}32B40@?44
v24@0:8^{PointSegment={PointView={CollectionPoint=Q{RigidTransform<double, float>={Matrix<double, 3, 1>=[3d]}{Quaternion<float>={Matrix<float, 3, 1>=[3f]}f}}{Unit<RadianUnitDescription, float>=f}{Mercator3<double>=[3d]}Q{small_vector<md::mun::PhotoInfo, 6>=^{PhotoInfo}^{PhotoInfo}^{PhotoInfo}Q[6{type=[288C]}]}fISCCC}{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}^{pair<md::mun::ViewId, unsigned int>}{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}}}{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}^{pair<md::mun::ViewId, unsigned int>}{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}}}{small_vector<md::mun::PointView::CameraLod, 6>=^{CameraLod}^{CameraLod}^{CameraLod}Q[6{type=[8C]}]}}{PointView={CollectionPoint=Q{RigidTransform<double, float>={Matrix<double, 3, 1>=[3d]}{Quaternion<float>={Matrix<float, 3, 1>=[3f]}f}}{Unit<RadianUnitDescription, float>=f}{Mercator3<double>=[3d]}Q{small_vector<md::mun::PhotoInfo, 6>=^{PhotoInfo}^{PhotoInfo}^{PhotoInfo}Q[6{type=[288C]}]}fISCCC}{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}^{pair<md::mun::ViewId, unsigned int>}{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}}}{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}^{pair<md::mun::ViewId, unsigned int>}{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >=^{pair<md::mun::ViewId, unsigned int>}}}{small_vector<md::mun::PointView::CameraLod, 6>=^{CameraLod}^{CameraLod}^{CameraLod}Q[6{type=[8C]}]}}}16
v48@0:8^{vector<md::mun::CollectionPoint, std::__1::allocator<md::mun::CollectionPoint> >=^{CollectionPoint}^{CollectionPoint}{__compressed_pair<md::mun::CollectionPoint *, std::__1::allocator<md::mun::CollectionPoint> >=^{CollectionPoint}}}16r^{Geocentric<double>=[3d]}24B32B36@?40
v32@0:8r^{Geocentric<double>=[3d]}16r^{Geocentric<double>=[3d]}24
{Unit<RadianUnitDescription, double>=d}24@0:8{Unit<RadianUnitDescription, double>=d}16
v36@0:8{Unit<RadianUnitDescription, double>=d}16f24@?28
v32@0:8{Unit<RadianUnitDescription, double>=d}16@?24
^{MuninSceneLogic=^^?BS{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{World}^{LoadingStatusTracker}^{RunLoopController}{unique_ptr<md::mun::MuninMetadataContainer, std::__1::default_delete<md::mun::MuninMetadataContainer> >={__compressed_pair<md::mun::MuninMetadataContainer *, std::__1::default_delete<md::mun::MuninMetadataContainer> >=^{MuninMetadataContainer}}}{vector<md::mun::ViewId, std::__1::allocator<md::mun::ViewId> >=^{ViewId}^{ViewId}{__compressed_pair<md::mun::ViewId *, std::__1::allocator<md::mun::ViewId> >=^{ViewId}}}{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > >={__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long long> >=f}}}{linear_map<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> >, std::__1::equal_to<unsigned short>, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > >, std::__1::vector<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > > > >={vector<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > > >=^{pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >}^{pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >}{__compressed_pair<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > *, std::__1::allocator<std::__1::pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > > > >=^{pair<unsigned short, std::__1::unordered_set<mdc::LayerDataRequestKey, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<mdc::LayerDataRequestKey> > >}}}}{MuninDebugViewContext={vector<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>, std::__1::allocator<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState> > >=^{pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>}^{pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>}{__compressed_pair<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState> *, std::__1::allocator<std::__1::pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState> > >=^{pair<std::__1::pair<md::mun::ViewId, unsigned int>, md::MuninDebugViewContext::ViewState>}}}B{Stopwatch={time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >={duration<long long, std::__1::ratio<1, 1000000000> >=q}}}}{unique_ptr<md::mun::MuninDisplayAnalytic, std::__1::default_delete<md::mun::MuninDisplayAnalytic> >={__compressed_pair<md::mun::MuninDisplayAnalytic *, std::__1::default_delete<md::mun::MuninDisplayAnalytic> >=^{MuninDisplayAnalytic}}}{unique_ptr<md::mun::MuninNavigation, std::__1::default_delete<md::mun::MuninNavigation> >={__compressed_pair<md::mun::MuninNavigation *, std::__1::default_delete<md::mun::MuninNavigation> >=^{MuninNavigation}}}{unique_ptr<md::mun::MuninIntersector, std::__1::default_delete<md::mun::MuninIntersector> >={__compressed_pair<md::mun::MuninIntersector *, std::__1::default_delete<md::mun::MuninIntersector> >=^{MuninIntersector}}}{unique_ptr<md::FadeEffectBlock, std::__1::default_delete<md::FadeEffectBlock> >={__compressed_pair<md::FadeEffectBlock *, std::__1::default_delete<md::FadeEffectBlock> >=^{FadeEffectBlock}}}{vector<md::MuninSceneEvent, std::__1::allocator<md::MuninSceneEvent> >=^{MuninSceneEvent}^{MuninSceneEvent}{__compressed_pair<md::MuninSceneEvent *, std::__1::allocator<md::MuninSceneEvent> >=^{MuninSceneEvent}}}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{optional<float>=B(ValueUnion=[4C]f)}{MuninSettings=ddddddddddddddCSiCC{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}{vector<unsigned short, std::__1::allocator<unsigned short> >=^S^S{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >=^S}}BQ}
{optional<(anonymous namespace)::PointSegment>="_hasValue"B"_value"(ValueUnion="data"[3984C]"type"{PointSegment="_startPoint"{PointView="_point"{CollectionPoint="pointId"Q"frame"{RigidTransform<double, float>="_translation"{Matrix<double, 3, 1>="_e"[3d]}"_rotation"{Quaternion<float>="_imaginary"{Matrix<float, 3, 1>="_e"[3f]}"_scalar"f}}"heading"{Unit<RadianUnitDescription, float>="_value"f}"mercatorPosition"{Mercator3<double>="_e"[3d]}"time"Q"photos"{small_vector<md::mun::PhotoInfo, 6>="_begin"^{PhotoInfo}"_end"^{PhotoInfo}"_fixedStorage"^{PhotoInfo}"_capacity"Q"storage"[6{type="__lx"[288C]}]}"heightAboveGroundMeters"f"buildId"I"bucketId"S"type"C"dataType"C"texturedLodMask"C}"_requiredViews"{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__begin_"^{pair<md::mun::ViewId, unsigned int>}"__end_"^{pair<md::mun::ViewId, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__value_"^{pair<md::mun::ViewId, unsigned int>}}}"_optionalViews"{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__begin_"^{pair<md::mun::ViewId, unsigned int>}"__end_"^{pair<md::mun::ViewId, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__value_"^{pair<md::mun::ViewId, unsigned int>}}}"_cameras"{small_vector<md::mun::PointView::CameraLod, 6>="_begin"^{CameraLod}"_end"^{CameraLod}"_fixedStorage"^{CameraLod}"_capacity"Q"storage"[6{type="__lx"[8C]}]}}"_endPoint"{PointView="_point"{CollectionPoint="pointId"Q"frame"{RigidTransform<double, float>="_translation"{Matrix<double, 3, 1>="_e"[3d]}"_rotation"{Quaternion<float>="_imaginary"{Matrix<float, 3, 1>="_e"[3f]}"_scalar"f}}"heading"{Unit<RadianUnitDescription, float>="_value"f}"mercatorPosition"{Mercator3<double>="_e"[3d]}"time"Q"photos"{small_vector<md::mun::PhotoInfo, 6>="_begin"^{PhotoInfo}"_end"^{PhotoInfo}"_fixedStorage"^{PhotoInfo}"_capacity"Q"storage"[6{type="__lx"[288C]}]}"heightAboveGroundMeters"f"buildId"I"bucketId"S"type"C"dataType"C"texturedLodMask"C}"_requiredViews"{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__begin_"^{pair<md::mun::ViewId, unsigned int>}"__end_"^{pair<md::mun::ViewId, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__value_"^{pair<md::mun::ViewId, unsigned int>}}}"_optionalViews"{vector<std::__1::pair<md::mun::ViewId, unsigned int>, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__begin_"^{pair<md::mun::ViewId, unsigned int>}"__end_"^{pair<md::mun::ViewId, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<md::mun::ViewId, unsigned int> *, std::__1::allocator<std::__1::pair<md::mun::ViewId, unsigned int> > >="__value_"^{pair<md::mun::ViewId, unsigned int>}}}"_cameras"{small_vector<md::mun::PointView::CameraLod, 6>="_begin"^{CameraLod}"_end"^{CameraLod}"_fixedStorage"^{CameraLod}"_capacity"Q"storage"[6{type="__lx"[8C]}]}}})}
{unique_ptr<(anonymous namespace)::PathAnimator, std::__1::default_delete<(anonymous namespace)::PathAnimator> >="__ptr_"{__compressed_pair<(anonymous namespace)::PathAnimator *, std::__1::default_delete<(anonymous namespace)::PathAnimator> >="__value_"^{PathAnimator}}}
{unique_ptr<(anonymous namespace)::BumpAnimator, std::__1::default_delete<(anonymous namespace)::BumpAnimator> >="__ptr_"{__compressed_pair<(anonymous namespace)::BumpAnimator *, std::__1::default_delete<(anonymous namespace)::BumpAnimator> >="__value_"^{BumpAnimator}}}
{_retain_ptr<VKTimedAnimation *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKTimedAnimation""_retain"{_retain_objc=}"_release"{_release_objc=}}
{Spring<double, 1, mdc::SpringType::Angular>="_position"d"_velocity"d"_restingPosition"d"_kSpring"d"_kDamper"d}
v24@0:8@"VKRouteLine"16
@32@0:8^{LabelTransitSupport=^^?^^?^{LabelManager}{shared_ptr<md::DataOverrideManager>=^{DataOverrideManager}^{__shared_weak_count}}{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<VKRouteContextObserverThunk *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}BBBBd{vector<std::__1::shared_ptr<md::LabelExternalPointFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalPointFeature>}^{shared_ptr<md::LabelExternalPointFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelExternalPointFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalPointFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<md::LabelFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}^{shared_ptr<md::LabelFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator>=^{Allocator}}}}{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, geo::StdAllocator<unsigned long long, mdm::Allocator> >={__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, geo::StdAllocator<unsigned long long, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, geo::StdAllocator<std::__1::__hash_node<unsigned long long, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}{StdAllocator<std::__1::__hash_node<unsigned long long, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long long> >=f}}}{vector<std::__1::shared_ptr<md::LabelExternalRoadFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalRoadFeature>}^{shared_ptr<md::LabelExternalRoadFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelExternalRoadFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalRoadFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<md::LabelFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}^{shared_ptr<md::LabelFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator>=^{Allocator}}}}{map<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature>, md::LabelExternalRoadFeatureLess, geo::StdAllocator<std::__1::pair<const std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, mdm::Allocator> >={__tree<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, std::__1::__map_value_compare<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, md::LabelExternalRoadFeatureLess, true>, geo::StdAllocator<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, mdm::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, void *>, mdm::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, md::LabelExternalRoadFeatureLess, true> >=Q}}}{_retain_ptr<VKRouteLineObserver *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<md::LabelTransitRoute>=^{LabelTransitRoute}^{__shared_weak_count}}{shared_ptr<md::LabelTransitRouteLine>=^{LabelTransitRouteLine}^{__shared_weak_count}}I{unordered_map<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear>, md::LabelTransitSupport::TransitLineColorKeyHash, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, geo::StdAllocator<std::__1::pair<const std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, mdm::Allocator> >={__hash_table<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::__unordered_map_hasher<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, md::LabelTransitSupport::TransitLineColorKeyHash, true>, std::__1::__unordered_map_equal<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, true>, geo::StdAllocator<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>}}{StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, md::LabelTransitSupport::TransitLineColorKeyHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, true> >=f}}}}16@24
^{LabelTransitSupport=^^?^^?^{LabelManager}{shared_ptr<md::DataOverrideManager>=^{DataOverrideManager}^{__shared_weak_count}}{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<VKRouteContextObserverThunk *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}BBBBd{vector<std::__1::shared_ptr<md::LabelExternalPointFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalPointFeature>}^{shared_ptr<md::LabelExternalPointFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelExternalPointFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalPointFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<md::LabelFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}^{shared_ptr<md::LabelFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator>=^{Allocator}}}}{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, geo::StdAllocator<unsigned long long, mdm::Allocator> >={__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, geo::StdAllocator<unsigned long long, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, geo::StdAllocator<std::__1::__hash_node<unsigned long long, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}{StdAllocator<std::__1::__hash_node<unsigned long long, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long long> >=f}}}{vector<std::__1::shared_ptr<md::LabelExternalRoadFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalRoadFeature>}^{shared_ptr<md::LabelExternalRoadFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelExternalRoadFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalRoadFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<md::LabelFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}^{shared_ptr<md::LabelFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator>=^{Allocator}}}}{map<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature>, md::LabelExternalRoadFeatureLess, geo::StdAllocator<std::__1::pair<const std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, mdm::Allocator> >={__tree<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, std::__1::__map_value_compare<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, md::LabelExternalRoadFeatureLess, true>, geo::StdAllocator<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, mdm::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, void *>, mdm::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, md::LabelExternalRoadFeatureLess, true> >=Q}}}{_retain_ptr<VKRouteLineObserver *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<md::LabelTransitRoute>=^{LabelTransitRoute}^{__shared_weak_count}}{shared_ptr<md::LabelTransitRouteLine>=^{LabelTransitRouteLine}^{__shared_weak_count}}I{unordered_map<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear>, md::LabelTransitSupport::TransitLineColorKeyHash, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, geo::StdAllocator<std::__1::pair<const std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, mdm::Allocator> >={__hash_table<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::__unordered_map_hasher<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, md::LabelTransitSupport::TransitLineColorKeyHash, true>, std::__1::__unordered_map_equal<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, true>, geo::StdAllocator<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>}}{StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, md::LabelTransitSupport::TransitLineColorKeyHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, true> >=f}}}}
@"VKRouteLine"
@32@0:8@16^{LabelTransitSupport=^^?^^?^{LabelManager}{shared_ptr<md::DataOverrideManager>=^{DataOverrideManager}^{__shared_weak_count}}{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<VKRouteContextObserverThunk *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}BBBBd{vector<std::__1::shared_ptr<md::LabelExternalPointFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalPointFeature>}^{shared_ptr<md::LabelExternalPointFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelExternalPointFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalPointFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelExternalPointFeature>, mdm::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<md::LabelFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}^{shared_ptr<md::LabelFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator>=^{Allocator}}}}{unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, geo::StdAllocator<unsigned long long, mdm::Allocator> >={__hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, geo::StdAllocator<unsigned long long, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, geo::StdAllocator<std::__1::__hash_node<unsigned long long, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>}}{StdAllocator<std::__1::__hash_node<unsigned long long, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long long> >=f}}}{vector<std::__1::shared_ptr<md::LabelExternalRoadFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalRoadFeature>}^{shared_ptr<md::LabelExternalRoadFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelExternalRoadFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelExternalRoadFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelExternalRoadFeature>, mdm::Allocator>=^{Allocator}}}}{vector<std::__1::shared_ptr<md::LabelFeature>, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}^{shared_ptr<md::LabelFeature>}{__compressed_pair<std::__1::shared_ptr<md::LabelFeature> *, geo::StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator> >=^{shared_ptr<md::LabelFeature>}{StdAllocator<std::__1::shared_ptr<md::LabelFeature>, mdm::Allocator>=^{Allocator}}}}{map<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature>, md::LabelExternalRoadFeatureLess, geo::StdAllocator<std::__1::pair<const std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, mdm::Allocator> >={__tree<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, std::__1::__map_value_compare<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, md::LabelExternalRoadFeatureLess, true>, geo::StdAllocator<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, mdm::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, void *>, mdm::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::__value_type<std::__1::shared_ptr<md::LabelExternalRoadFeature>, std::__1::shared_ptr<md::RoadLabelFeature> >, md::LabelExternalRoadFeatureLess, true> >=Q}}}{_retain_ptr<VKRouteLineObserver *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<md::LabelTransitRoute>=^{LabelTransitRoute}^{__shared_weak_count}}{shared_ptr<md::LabelTransitRouteLine>=^{LabelTransitRouteLine}^{__shared_weak_count}}I{unordered_map<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear>, md::LabelTransitSupport::TransitLineColorKeyHash, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, geo::StdAllocator<std::__1::pair<const std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, mdm::Allocator> >={__hash_table<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::__unordered_map_hasher<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, md::LabelTransitSupport::TransitLineColorKeyHash, true>, std::__1::__unordered_map_equal<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, true>, geo::StdAllocator<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *> *>}}{StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, md::LabelTransitSupport::TransitLineColorKeyHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<unsigned long long, bool>, std::__1::__hash_value_type<std::__1::pair<unsigned long long, bool>, geo::Color<unsigned char, 4, geo::ColorSpace::Linear> >, std::__1::equal_to<std::__1::pair<unsigned long long, bool> >, true> >=f}}}}24
{_retain_ptr<VKRouteContext *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKRouteContext""_retain"{_retain_objc=}"_release"{_release_objc=}}
{?="backgroundColor"b1"borderColor"b1"style"b1"textColor"b1"textDropShadowColor"b1"textDropShadowSize"b1"textStrokeColor"b1"textStrokeSize"b1}
@504@0:8@16{RoadSignMetrics=Cdddd{CGSize=dd}dddddddd{CGSize=dd}}24{RoadSignTextMetrics=dddddd{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}dd}160{RoadSignColoring=BBBBBBB{Color<double, 4, geo::ColorSpace::Linear>={Matrix<double, 4, 1>=[4d]}}{array<geo::Color<double, 4, geo::ColorSpace::Linear>, 2>=[2{Color<double, 4, geo::ColorSpace::Linear>={Matrix<double, 4, 1>=[4d]}}]}{Color<double, 4, geo::ColorSpace::Linear>={Matrix<double, 4, 1>=[4d]}}{Color<double, 4, geo::ColorSpace::Linear>={Matrix<double, 4, 1>=[4d]}}{Color<double, 4, geo::ColorSpace::Linear>={Matrix<double, 4, 1>=[4d]}}{Color<double, 4, geo::ColorSpace::Linear>={Matrix<double, 4, 1>=[4d]}}d}256^{CGImage=}496
{Matrix<float, 2, 1>=[2f]}24@0:8{Matrix<float, 2, 1>=[2f]}16
{Box<float, 2>={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}}16@0:8
^{__CTLine=}
^{__CTFrame=}
^{__CTFramesetter=}
{RoadSignMetrics="_orientation"C"_scale"d"_contentScale"d"_arrowWeight"d"_arrowLength"d"_shadowOffset"{CGSize="width"d"height"d}"_shadowRadius"d"_strokeWeight"d"_innerStrokeWeight"d"_signHeight"d"_signMargin"d"_horizontalMargin"d"_verticalMargin"d"_cornerRadius"d"_glyphSize"{CGSize="width"d"height"d}}
{RoadSignTextMetrics="_scale"d"_contentScale"d"_horizontalMargin"d"_verticalMargin"d"_verticalOffset"d"_textSize"d"_fontFamily"{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}"__value_"{StdAllocator<char, mdm::Allocator>="_allocator"^{Allocator}}}}"_textDrawWidth"d"_textWrapWidth"d}
{RoadSignGeneratedMetrics="_leftRoadSignPartMetrics"{RoadSignPartMetrics="_type"C"_imageSize"{CGSize="width"d"height"d}"_signBaseRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_topEmptySpaceHeight"d"_bottomEmptySpaceHeight"d"_leftEmptySpaceWidth"d"_rightEmptySpaceWidth"d"_outsideImagePathExtension"d"_hasArrows"B"_arrowWingMin"{CGPoint="x"d"y"d}"_arrowWingMax"{CGPoint="x"d"y"d}"_arrowTip"{CGPoint="x"d"y"d}}"_rightRoadSignPartMetrics"{RoadSignPartMetrics="_type"C"_imageSize"{CGSize="width"d"height"d}"_signBaseRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_topEmptySpaceHeight"d"_bottomEmptySpaceHeight"d"_leftEmptySpaceWidth"d"_rightEmptySpaceWidth"d"_outsideImagePathExtension"d"_hasArrows"B"_arrowWingMin"{CGPoint="x"d"y"d}"_arrowWingMax"{CGPoint="x"d"y"d}"_arrowTip"{CGPoint="x"d"y"d}}"_stretchedRoadSignPartMetrics"{RoadSignPartMetrics="_type"C"_imageSize"{CGSize="width"d"height"d}"_signBaseRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_topEmptySpaceHeight"d"_bottomEmptySpaceHeight"d"_leftEmptySpaceWidth"d"_rightEmptySpaceWidth"d"_outsideImagePathExtension"d"_hasArrows"B"_arrowWingMin"{CGPoint="x"d"y"d}"_arrowWingMax"{CGPoint="x"d"y"d}"_arrowTip"{CGPoint="x"d"y"d}}"_middleRoadSignPartMetrics"{RoadSignPartMetrics="_type"C"_imageSize"{CGSize="width"d"height"d}"_signBaseRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_topEmptySpaceHeight"d"_bottomEmptySpaceHeight"d"_leftEmptySpaceWidth"d"_rightEmptySpaceWidth"d"_outsideImagePathExtension"d"_hasArrows"B"_arrowWingMin"{CGPoint="x"d"y"d}"_arrowWingMax"{CGPoint="x"d"y"d}"_arrowTip"{CGPoint="x"d"y"d}}"_hasMiddleSignPart"B"_imageSize"{CGSize="width"d"height"d}"_signBaseRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_glyphRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_stretchedRoadSignPartWidth"d"_arrowTipPosition"{CGPoint="x"d"y"d}"_textPosition"{CGPoint="x"d"y"d}"_textBounds"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_leftPartRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_rightPartRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_stretchedPartRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_middlePartRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_middleLeftStretchedPartRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}"_middleRightStretchedPartRect"{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}}
{RoadSignColoring="_hasFillColor"B"_hasGradientFillColors"B"_hasGradientFillAngle"B"_hasStrokeColor"B"_hasInnerStrokeColor"B"_hasShadowColor"B"_hasTextColor"B"_fillColor"{Color<double, 4, geo::ColorSpace::Linear>="_backing"{Matrix<double, 4, 1>="_e"[4d]}}"_gradientFillColors"{array<geo::Color<double, 4, geo::ColorSpace::Linear>, 2>="__elems_"[2{Color<double, 4, geo::ColorSpace::Linear>="_backing"{Matrix<double, 4, 1>="_e"[4d]}}]}"_strokeColor"{Color<double, 4, geo::ColorSpace::Linear>="_backing"{Matrix<double, 4, 1>="_e"[4d]}}"_innerStrokeColor"{Color<double, 4, geo::ColorSpace::Linear>="_backing"{Matrix<double, 4, 1>="_e"[4d]}}"_shadowColor"{Color<double, 4, geo::ColorSpace::Linear>="_backing"{Matrix<double, 4, 1>="_e"[4d]}}"_textColor"{Color<double, 4, geo::ColorSpace::Linear>="_backing"{Matrix<double, 4, 1>="_e"[4d]}}"_gradientFillAngle"d}
^{CGImage=}
@32@0:8@16C24C28
@"VKRouteEtaDescription"
@48@0:8@16@24{PolylineCoordinate=If}32{PolylineCoordinate=If}40
@28@0:8@16C24
@20@0:8C16
v24@0:8C16B20
v28@0:8@16C24
v28@0:8r^{?=@{PolylineCoordinate=If}{PolylineCoordinate=If}}16I24
v28@0:8I16@?20
@"VKRouteInfo"
{?="latitude"d"longitude"d}
{multimap<unsigned int, std::__1::vector<RouteSection, std::__1::allocator<RouteSection> >, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, std::__1::vector<RouteSection, std::__1::allocator<RouteSection> > > > >="__tree_"{__tree<std::__1::__value_type<unsigned int, std::__1::vector<RouteSection, std::__1::allocator<RouteSection> > >, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, std::__1::vector<RouteSection, std::__1::allocator<RouteSection> > >, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, std::__1::vector<RouteSection, std::__1::allocator<RouteSection> > > > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, std::__1::vector<RouteSection, std::__1::allocator<RouteSection> > >, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, std::__1::vector<RouteSection, std::__1::allocator<RouteSection> > >, std::__1::less<unsigned int>, true> >="__value_"Q}}}
S24@0:8Q16
v40@0:8^S16{_NSRange=QQ}24
@32@0:8{_NSRange=QQ}16
q56@0:8@16Q24{_NSRange=QQ}32@48
q24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@24@0:8r^{LabelExternalTextElement=CC{StringWithLocale={basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}}{StringWithLocale={basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}}}16
r^{LabelExternalTextElement=CC{StringWithLocale={basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}}{StringWithLocale={basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}}}16@0:8
{LabelExternalTextElement="minZoom"C"textType"C"text"{StringWithLocale="text"{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}"__value_"{StdAllocator<char, mdm::Allocator>="_allocator"^{Allocator}}}}"locale"{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}"__value_"{StdAllocator<char, mdm::Allocator>="_allocator"^{Allocator}}}}}"localizedText"{StringWithLocale="text"{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}"__value_"{StdAllocator<char, mdm::Allocator>="_allocator"^{Allocator}}}}"locale"{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}"__value_"{StdAllocator<char, mdm::Allocator>="_allocator"^{Allocator}}}}}}
@24@0:8r^{LabelExternalIconElement={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}BC}16
r^{LabelExternalIconElement={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}BC}16@0:8
{LabelExternalIconElement="size"{Matrix<float, 2, 1>="_e"[2f]}"anchorPoint"{Matrix<float, 2, 1>="_e"[2f]}"isRound"B"minZoom"C}
{?=ddd}64@0:8{?=dd}16{?=ddd}32d56
@44@0:8{?=ddd}16B40
@40@0:8{?=dd}16d32
v20@0:8s16
v52@0:8{CGSize=dd}16{CGPoint=dd}32B48
^{shared_ptr<md::LabelExternalPointFeature>=^{LabelExternalPointFeature}^{__shared_weak_count}}16@0:8
{shared_ptr<md::LabelExternalPointFeature>="__ptr_"^{LabelExternalPointFeature}"__cntrl_"^{__shared_weak_count}}
@"<VKCustomFeatureDataSource>"
v72@0:8d16{function<void ()>={__value_func<void ()>={type=[32C]}^{__base<void ()>}}}24
{shared_ptr<ggl::BitmapDataBase>=^{BitmapDataBase}^{__shared_weak_count}}16@0:8
r^{RenderTargetFormat=[4i]QIi}16@0:8
^{Renderer=^^?^{Device}QQQBfQ{vector<std::__1::shared_ptr<ggl::DebugRenderer>, geo::StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator> >=^{shared_ptr<ggl::DebugRenderer>}^{shared_ptr<ggl::DebugRenderer>}{__compressed_pair<std::__1::shared_ptr<ggl::DebugRenderer> *, geo::StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator> >=^{shared_ptr<ggl::DebugRenderer>}{StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator>=^{Allocator}}}}{unique_ptr<ggl::RenderQueue, std::__1::default_delete<ggl::RenderQueue> >={__compressed_pair<ggl::RenderQueue *, std::__1::default_delete<ggl::RenderQueue> >=^{RenderQueue}}}{shared_ptr<ggl::CommonLibrary>=^{CommonLibrary}^{__shared_weak_count}}{unique_ptr<ggl::RenderResourceFences, std::__1::default_delete<ggl::RenderResourceFences> >={__compressed_pair<ggl::RenderResourceFences *, std::__1::default_delete<ggl::RenderResourceFences> >=^{RenderResourceFences}}}^{Texture2D}{unique_ptr<ggl::CommandBuffer, std::__1::default_delete<ggl::CommandBuffer> >={__compressed_pair<ggl::CommandBuffer *, std::__1::default_delete<ggl::CommandBuffer> >=^{CommandBuffer}}}}16@0:8
^{RenderTarget=^^?^{ResourceManager}^{RenderResource}^^?*{RenderTargetFormat=[4i]QIi}[4^{Texture}][4^{Texture}]^{Texture}B}16@0:8
{CGPoint=dd}40@0:8{CGPoint=dd}16@32
^{DebugConsole=}20@0:8i16
@"<GGLRenderQueueSource>"16@0:8
v24@0:8@"<GGLRenderQueueSource>"16
{CGPoint=dd}40@0:8{CGPoint=dd}16@"CALayer"32
^{Texture=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiII}16@0:8
@68@0:8{CGSize=dd}16d32B40r^{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}44^{Device=i{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{unique_ptr<md::SharedDeviceResources, std::__1::default_delete<md::SharedDeviceResources> >={__compressed_pair<md::SharedDeviceResources *, std::__1::default_delete<md::SharedDeviceResources> >=^{SharedDeviceResources}}}}52Q60
^{Texture2D=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiIII{shared_ptr<const ggl::TextureDataAbstract>=^{TextureDataAbstract}^{__shared_weak_count}}BBB{shared_ptr<ggl::SamplerState>=^{SamplerState}^{__shared_weak_count}}}16@0:8
{RenderTargetFormat=[4i]QIi}16@0:8
{RenderTargetFormat="colorFormats"[4i]"colorFormatsCount"Q"samples"I"depthStencilFormat"i}
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
@"<GGLRenderQueueSource>"
{unique_ptr<ggl::IOSurfaceTexture, std::__1::default_delete<ggl::IOSurfaceTexture> >="__ptr_"{__compressed_pair<ggl::IOSurfaceTexture *, std::__1::default_delete<ggl::IOSurfaceTexture> >="__value_"^{IOSurfaceTexture}}}
{unique_ptr<ggl::RenderTarget, std::__1::default_delete<ggl::RenderTarget> >="__ptr_"{__compressed_pair<ggl::RenderTarget *, std::__1::default_delete<ggl::RenderTarget> >="__value_"^{RenderTarget}}}
{unique_ptr<(anonymous namespace)::YFlipPass, std::__1::default_delete<(anonymous namespace)::YFlipPass> >="__ptr_"{__compressed_pair<(anonymous namespace)::YFlipPass *, std::__1::default_delete<(anonymous namespace)::YFlipPass> >="__value_"^{YFlipPass}}}
{shared_ptr<ggl::Device>="__ptr_"^{Device}"__cntrl_"^{__shared_weak_count}}
^{Renderer=^^?^{Device}QQQBfQ{vector<std::__1::shared_ptr<ggl::DebugRenderer>, geo::StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator> >=^{shared_ptr<ggl::DebugRenderer>}^{shared_ptr<ggl::DebugRenderer>}{__compressed_pair<std::__1::shared_ptr<ggl::DebugRenderer> *, geo::StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator> >=^{shared_ptr<ggl::DebugRenderer>}{StdAllocator<std::__1::shared_ptr<ggl::DebugRenderer>, ggl::Allocator>=^{Allocator}}}}{unique_ptr<ggl::RenderQueue, std::__1::default_delete<ggl::RenderQueue> >={__compressed_pair<ggl::RenderQueue *, std::__1::default_delete<ggl::RenderQueue> >=^{RenderQueue}}}{shared_ptr<ggl::CommonLibrary>=^{CommonLibrary}^{__shared_weak_count}}{unique_ptr<ggl::RenderResourceFences, std::__1::default_delete<ggl::RenderResourceFences> >={__compressed_pair<ggl::RenderResourceFences *, std::__1::default_delete<ggl::RenderResourceFences> >=^{RenderResourceFences}}}^{Texture2D}{unique_ptr<ggl::CommandBuffer, std::__1::default_delete<ggl::CommandBuffer> >={__compressed_pair<ggl::CommandBuffer *, std::__1::default_delete<ggl::CommandBuffer> >=^{CommandBuffer}}}}
{unique_ptr<ggl::Texture, std::__1::default_delete<ggl::Texture> >="__ptr_"{__compressed_pair<ggl::Texture *, std::__1::default_delete<ggl::Texture> >="__value_"^{Texture}}}
{unique_ptr<ggl::RenderBuffer, std::__1::default_delete<ggl::RenderBuffer> >="__ptr_"{__compressed_pair<ggl::RenderBuffer *, std::__1::default_delete<ggl::RenderBuffer> >="__value_"^{RenderBuffer}}}
v24@0:8r^{shared_ptr<md::LabelMarker>=}16
v32@0:8r^{MuninJunction=}16r^{MuninRoadEdge=}24
v24@0:8@"NSError"16
@64@0:8{CGSize=dd}16d32@40Q48@56
v40@0:8Q16Q24Q32
v56@0:8{?=dd}16d32d40d48
@"VKMapImageCanvas"
@"VKGlobeImageCanvas"
@"<VKRouteOverlay>"
@"VKRouteContext"
{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}16@0:8
v72@0:8^{MapEngine=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}^{Device}{_retain_ptr<_MapEngineRenderQueueSource *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<ggl::DisplayLink, std::__1::default_delete<ggl::DisplayLink> >={__compressed_pair<ggl::DisplayLink *, std::__1::default_delete<ggl::DisplayLink> >=^{DisplayLink}}}{unique_ptr<ggl::SnapshotRunLoop, std::__1::default_delete<ggl::SnapshotRunLoop> >={__compressed_pair<ggl::SnapshotRunLoop *, std::__1::default_delete<ggl::SnapshotRunLoop> >=^{SnapshotRunLoop}}}^{RunLoop}{unique_ptr<md::AnimationManager, std::__1::default_delete<md::AnimationManager> >={__compressed_pair<md::AnimationManager *, std::__1::default_delete<md::AnimationManager> >=^{AnimationManager}}}{unique_ptr<md::AnimationRunner, std::__1::default_delete<md::AnimationRunner> >={__compressed_pair<md::AnimationRunner *, std::__1::default_delete<md::AnimationRunner> >=^{AnimationRunner}}}{shared_ptr<md::RunLoopController>=^{RunLoopController}^{__shared_weak_count}}@@@@{unique_ptr<md::CartographicRenderer, std::__1::default_delete<md::CartographicRenderer> >={__compressed_pair<md::CartographicRenderer *, std::__1::default_delete<md::CartographicRenderer> >=^{CartographicRenderer}}}{unique_ptr<md::realistic::RealisticRenderer, std::__1::default_delete<md::realistic::RealisticRenderer> >={__compressed_pair<md::realistic::RealisticRenderer *, std::__1::default_delete<md::realistic::RealisticRenderer> >=^{RealisticRenderer}}}^{Renderer}{unique_ptr<md::World, std::__1::default_delete<md::World> >={__compressed_pair<md::World *, std::__1::default_delete<md::World> >=^{World}}}{unique_ptr<md::MapDataAccess, std::__1::default_delete<md::MapDataAccess> >={__compressed_pair<md::MapDataAccess *, std::__1::default_delete<md::MapDataAccess> >=^{MapDataAccess}}}{unique_ptr<md::LayoutContext, std::__1::default_delete<md::LayoutContext> >={__compressed_pair<md::LayoutContext *, std::__1::default_delete<md::LayoutContext> >=^{LayoutContext}}}{_retain_ptr<VKCamera *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<mdc::Camera>=^{Camera}^{__shared_weak_count}}{_retain_ptr<VKCameraDelegateMediator *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{unique_ptr<md::LogicManager, std::__1::default_delete<md::LogicManager> >={__compressed_pair<md::LogicManager *, std::__1::default_delete<md::LogicManager> >=^{LogicManager}}}{unique_ptr<md::MapEngineSettings, std::__1::default_delete<md::MapEngineSettings> >={__compressed_pair<md::MapEngineSettings *, std::__1::default_delete<md::MapEngineSettings> >=^{MapEngineSettings}}}{unique_ptr<mdc::LoadingStatusTracker, std::__1::default_delete<mdc::LoadingStatusTracker> >={__compressed_pair<mdc::LoadingStatusTracker *, std::__1::default_delete<mdc::LoadingStatusTracker> >=^{LoadingStatusTracker}}}{shared_ptr<mdc::Statistics>=^{Statistics}^{__shared_weak_count}}BBB{atomic<bool>=AB}{atomic<bool>=AB}B{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{MapEngineConfigPair=C{unique_ptr<md::MapEngineMode, std::__1::default_delete<md::MapEngineMode> >={__compressed_pair<md::MapEngineMode *, std::__1::default_delete<md::MapEngineMode> >=^{MapEngineMode}}}}{unique_ptr<md::MapEngineConfiguration, std::__1::default_delete<md::MapEngineConfiguration> >={__compressed_pair<md::MapEngineConfiguration *, std::__1::default_delete<md::MapEngineConfiguration> >=^{MapEngineConfiguration}}}{_retain_ptr<VKManifestTileGroupObserverProxy *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}QQ}16{function<void ()>={__value_func<void ()>={type=[32C]}^{__base<void ()>}}}24
{DisplayStyle=CCCCC}16@0:8
{_retain_ptr<VKCameraController *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKCameraController""_retain"{_retain_objc=}"_release"{_release_objc=}}
{DisplayStyle="timePeriod"C"overlayType"C"applicationState"C"searchResultsType"C"mapHasLabels"C}
^{RenderQueue={PassDescriptor=[4{AttachmentActions=ii}]{AttachmentActions=ii}{AttachmentActions=ii}}{vector<ggl::RenderQueue::Pass, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}^{Pass}{__compressed_pair<ggl::RenderQueue::Pass *, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}{StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ComputeQueue *, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}^^{ComputeQueue}{__compressed_pair<ggl::ComputeQueue **, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}{StdAllocator<ggl::ComputeQueue *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::CommandBuffer *, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}^^{CommandBuffer}{__compressed_pair<ggl::CommandBuffer **, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}{StdAllocator<ggl::CommandBuffer *, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::RenderTransaction>=^{RenderTransaction}^{__shared_weak_count}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}}24@0:8d16
B40@0:8@16B24d28B36
v28@0:8i16d20
{vector<gm::Matrix<float, 2, 1>, std::__1::allocator<gm::Matrix<float, 2, 1> > >=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}{__compressed_pair<gm::Matrix<float, 2, 1> *, std::__1::allocator<gm::Matrix<float, 2, 1> > >=^{Matrix<float, 2, 1>}}}16@0:8
{Matrix<double, 4, 4>=[16d]}16@0:8
{vector<geo::fast_shared_ptr<md::RouteLineSection, std::allocator>, std::__1::allocator<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> > >=^{fast_shared_ptr<md::RouteLineSection, std::allocator>}^{fast_shared_ptr<md::RouteLineSection, std::allocator>}{__compressed_pair<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> *, std::__1::allocator<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> > >=^{fast_shared_ptr<md::RouteLineSection, std::allocator>}}}16@0:8
@"<VKRouteLineObserverProtocol>"
{vector<geo::fast_shared_ptr<md::RouteLineSection, std::allocator>, std::__1::allocator<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> > >="__begin_"^{fast_shared_ptr<md::RouteLineSection, std::allocator>}"__end_"^{fast_shared_ptr<md::RouteLineSection, std::allocator>}"__end_cap_"{__compressed_pair<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> *, std::__1::allocator<geo::fast_shared_ptr<md::RouteLineSection, std::allocator> > >="__value_"^{fast_shared_ptr<md::RouteLineSection, std::allocator>}}}
{fast_shared_ptr<md::RouteLineSection, std::allocator>="_control"^{_fast_shared_ptr_control}}
@"NSSet"
@"VKPolylineOverlayRenderRegion"
{ManeuverArrowCoordinates="_maneuverArrows"{vector<md::ManeuverArrowInfo, std::__1::allocator<md::ManeuverArrowInfo> >="__begin_"^{ManeuverArrowInfo}"__end_"^{ManeuverArrowInfo}"__end_cap_"{__compressed_pair<md::ManeuverArrowInfo *, std::__1::allocator<md::ManeuverArrowInfo> >="__value_"^{ManeuverArrowInfo}}}}
@36@0:8^{CGImage=}16d24B32
@32@0:8^{CGImage=}16d24
@36@0:8@16d24B32
@32@0:8@16d24
@40@0:8@16d24@32
r^{Box<float, 2>={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}}16@0:8
v24@0:8^{TextureAtlas={vector<md::TextureAtlas::RelocateItem, std::__1::allocator<md::TextureAtlas::RelocateItem> >=^{RelocateItem}^{RelocateItem}{__compressed_pair<md::TextureAtlas::RelocateItem *, std::__1::allocator<md::TextureAtlas::RelocateItem> >=^{RelocateItem}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{Matrix<unsigned int, 2, 1>=[2I]}{Matrix<unsigned int, 2, 1>=[2I]}{Matrix<unsigned int, 2, 1>=[2I]}{Matrix<unsigned int, 2, 1>=[2I]}C{shared_ptr<ggl::SamplerState>=^{SamplerState}^{__shared_weak_count}}BII{unique_ptr<unsigned char [], std::__1::default_delete<unsigned char []> >={__compressed_pair<unsigned char *, std::__1::default_delete<unsigned char []> >=*}}{read_write_lock={_opaque_pthread_rwlock_t=q[192c]}}{atomic<bool>=AB}{atomic<bool>=AB}{vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >=^{shared_ptr<md::TextureAtlasPage>}^{shared_ptr<md::TextureAtlasPage>}{__compressed_pair<std::__1::shared_ptr<md::TextureAtlasPage> *, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >=^{shared_ptr<md::TextureAtlasPage>}}}{vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >=^{shared_ptr<md::TextureAtlasPage>}^{shared_ptr<md::TextureAtlasPage>}{__compressed_pair<std::__1::shared_ptr<md::TextureAtlasPage> *, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >=^{shared_ptr<md::TextureAtlasPage>}}}{vector<ggl::Texture2D *, std::__1::allocator<ggl::Texture2D *> >=^^{Texture2D}^^{Texture2D}{__compressed_pair<ggl::Texture2D **, std::__1::allocator<ggl::Texture2D *> >=^^{Texture2D}}}{shared_ptr<ggl::RenderTransaction>=^{RenderTransaction}^{__shared_weak_count}}{mutex={_opaque_pthread_mutex_t=q[56c]}}{mutex={_opaque_pthread_mutex_t=q[56c]}}{vector<std::__1::shared_ptr<md::TextureAtlasRegion>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasRegion> > >=^{shared_ptr<md::TextureAtlasRegion>}^{shared_ptr<md::TextureAtlasRegion>}{__compressed_pair<std::__1::shared_ptr<md::TextureAtlasRegion> *, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasRegion> > >=^{shared_ptr<md::TextureAtlasRegion>}}}{vector<ggl::Texture2DLoadItem, std::__1::allocator<ggl::Texture2DLoadItem> >=^{Texture2DLoadItem}^{Texture2DLoadItem}{__compressed_pair<ggl::Texture2DLoadItem *, std::__1::allocator<ggl::Texture2DLoadItem> >=^{Texture2DLoadItem}}}{vector<std::__1::shared_ptr<md::TextureAtlasRegion>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasRegion> > >=^{shared_ptr<md::TextureAtlasRegion>}^{shared_ptr<md::TextureAtlasRegion>}{__compressed_pair<std::__1::shared_ptr<md::TextureAtlasRegion> *, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasRegion> > >=^{shared_ptr<md::TextureAtlasRegion>}}}{vector<std::__1::vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >, std::__1::allocator<std::__1::vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > > > >=^{vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >}^{vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >}{__compressed_pair<std::__1::vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > > *, std::__1::allocator<std::__1::vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > > > >=^{vector<std::__1::shared_ptr<md::TextureAtlasPage>, std::__1::allocator<std::__1::shared_ptr<md::TextureAtlasPage> > >}}}}16
i24@0:8@16
^{Texture2D=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiIII{shared_ptr<const ggl::TextureDataAbstract>=^{TextureDataAbstract}^{__shared_weak_count}}BBB{shared_ptr<ggl::SamplerState>=^{SamplerState}^{__shared_weak_count}}}
{shared_ptr<md::TextureAtlasRegion>="__ptr_"^{TextureAtlasRegion}"__cntrl_"^{__shared_weak_count}}
{Box<float, 2>="_minimum"{Matrix<float, 2, 1>="_e"[2f]}"_maximum"{Matrix<float, 2, 1>="_e"[2f]}}
{atomic<bool>="__a_"AB}
@"VKResourceManager"
[16C]
r^{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}16@0:8
v44@0:8@16B24@?28@?36
v44@0:8Q16B24@?28@?36
^{GlobeOverlayContainer=^{GlobeView}^{NSMutableArray}{mutex={_opaque_pthread_mutex_t=q[56c]}}d}16@0:8
@"VKGlobeCameraController"
{AltitudeDebugSettings="altitudePauseLoading"B"altitudeFreezeViewNode"B"altitudeTexturePaging"B"altitudeShowTileBounds"B"altitudeThreadDrawing"B"altitudeMipmapSatellite"B"altitudeMipmapFlyover"B"altitudeMipmapObjectTree"B"altitudeShowNightLight"B"lodScale"f"tileQualityThreshold"f"hideMeshTime"f"fadeSpeed"f"tourSpeedup"B"tourSpeedupFactor"f}
^{GlobeAdapter={shared_ptr<md::GlobeAdapterData>=^{GlobeAdapterData}^{__shared_weak_count}}^{GlobeView}{unordered_set<std::__1::shared_ptr<md::LabelMapTile>, std::__1::hash<std::__1::shared_ptr<md::LabelMapTile> >, std::__1::equal_to<std::__1::shared_ptr<md::LabelMapTile> >, geo::StdAllocator<std::__1::shared_ptr<md::LabelMapTile>, mdm::Allocator> >={__hash_table<std::__1::shared_ptr<md::LabelMapTile>, std::__1::hash<std::__1::shared_ptr<md::LabelMapTile> >, std::__1::equal_to<std::__1::shared_ptr<md::LabelMapTile> >, geo::StdAllocator<std::__1::shared_ptr<md::LabelMapTile>, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *> *>}}{StdAllocator<std::__1::__hash_node<std::__1::shared_ptr<md::LabelMapTile>, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::hash<std::__1::shared_ptr<md::LabelMapTile> > >=Q}{__compressed_pair<float, std::__1::equal_to<std::__1::shared_ptr<md::LabelMapTile> > >=f}}}{shared_ptr<md::LabelManager>=^{LabelManager}^{__shared_weak_count}}}
^{RealisticRenderer=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}{unique_ptr<md::PassList, std::__1::default_delete<md::PassList> >={__compressed_pair<md::PassList *, std::__1::default_delete<md::PassList> >=^{PassList}}}{unique_ptr<md::RenderTargetRegistry, std::__1::default_delete<md::RenderTargetRegistry> >={__compressed_pair<md::RenderTargetRegistry *, std::__1::default_delete<md::RenderTargetRegistry> >=^{RenderTargetRegistry}}}{vector<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}{__compressed_pair<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > *, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}}}{linear_map<md::CommandBufferLocation, md::RenderLayer *, std::__1::equal_to<md::CommandBufferLocation>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> >, std::__1::vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > > >={vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}^{pair<md::CommandBufferLocation, md::RenderLayer *>}{__compressed_pair<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> *, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}}}}^{RunLoopController}^{MapEngine}@^{Device}^{GlobeView}^{Context}^{StencilManager}^{GlobeDispatch}^{CullingNode}^{GlobeTileRenderManager}^{TexturePager}{shared_ptr<md::GlobeOverlayContainer>=^{GlobeOverlayContainer}^{__shared_weak_count}}{shared_ptr<ggl::FlyoverLibrary>=^{FlyoverLibrary}^{__shared_weak_count}}@}
{shared_ptr<md::GlobeOverlayContainer>="__ptr_"^{GlobeOverlayContainer}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<ggl::FlyoverLibrary>="__ptr_"^{FlyoverLibrary}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<bool>="__ptr_"^B"__cntrl_"^{__shared_weak_count}}
^{LoadingStatusTracker=^^?{mutex={_opaque_pthread_mutex_t=q[56c]}}i@{optional<mdc::SceneStatus>=B(ValueUnion=[1C]C)}B{function<void ()>={__value_func<void ()>={type=[32C]}^{__base<void ()>}}}{function<void (NSError *)>={__value_func<void (NSError *)>={type=[32C]}^{__base<void (NSError *)>}}}{function<void ()>={__value_func<void ()>={type=[32C]}^{__base<void ()>}}}{function<void (mdc::SceneStatus)>={__value_func<void (mdc::SceneStatus)>={type=[32C]}^{__base<void (mdc::SceneStatus)>}}}}
@"VKARCameraController"
v24@0:8@"VKGlobeLineContainer"16
@24@0:8^{RealisticRenderer=^^?{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}{unique_ptr<md::PassList, std::__1::default_delete<md::PassList> >={__compressed_pair<md::PassList *, std::__1::default_delete<md::PassList> >=^{PassList}}}{unique_ptr<md::RenderTargetRegistry, std::__1::default_delete<md::RenderTargetRegistry> >={__compressed_pair<md::RenderTargetRegistry *, std::__1::default_delete<md::RenderTargetRegistry> >=^{RenderTargetRegistry}}}{vector<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}{__compressed_pair<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > *, std::__1::allocator<std::__1::unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> > > >=^{unique_ptr<md::RenderLayer, std::__1::default_delete<md::RenderLayer> >}}}{linear_map<md::CommandBufferLocation, md::RenderLayer *, std::__1::equal_to<md::CommandBufferLocation>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> >, std::__1::vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > > >={vector<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *>, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}^{pair<md::CommandBufferLocation, md::RenderLayer *>}{__compressed_pair<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> *, std::__1::allocator<std::__1::pair<md::CommandBufferLocation, md::RenderLayer *> > >=^{pair<md::CommandBufferLocation, md::RenderLayer *>}}}}^{RunLoopController}^{MapEngine}@^{Device}^{GlobeView}^{Context}^{StencilManager}^{GlobeDispatch}^{CullingNode}^{GlobeTileRenderManager}^{TexturePager}{shared_ptr<md::GlobeOverlayContainer>=^{GlobeOverlayContainer}^{__shared_weak_count}}{shared_ptr<ggl::FlyoverLibrary>=^{FlyoverLibrary}^{__shared_weak_count}}@}16
@"NSBundle"
@40@0:8r^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16r^{MultiRectRegion={set<gm::Box<double, 2>, md::MultiRectSetCompare, std::__1::allocator<gm::Box<double, 2> > >={__tree<gm::Box<double, 2>, md::MultiRectSetCompare, std::__1::allocator<gm::Box<double, 2> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<gm::Box<double, 2>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, md::MultiRectSetCompare>=Q}}}}24r^{set<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >={__tree<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::shared_ptr<md::RouteLineData>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<std::__1::shared_ptr<md::RouteLineData> > >=Q}}}32
r^{MultiRectRegion={set<gm::Box<double, 2>, md::MultiRectSetCompare, std::__1::allocator<gm::Box<double, 2> > >={__tree<gm::Box<double, 2>, md::MultiRectSetCompare, std::__1::allocator<gm::Box<double, 2> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<gm::Box<double, 2>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, md::MultiRectSetCompare>=Q}}}}16@0:8
r^{set<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >={__tree<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::shared_ptr<md::RouteLineData>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<std::__1::shared_ptr<md::RouteLineData> > >=Q}}}16@0:8
{set<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >="__tree_"{__tree<std::__1::shared_ptr<md::RouteLineData>, std::__1::less<std::__1::shared_ptr<md::RouteLineData> >, std::__1::allocator<std::__1::shared_ptr<md::RouteLineData> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::shared_ptr<md::RouteLineData>, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::less<std::__1::shared_ptr<md::RouteLineData> > >="__value_"Q}}}
{MultiRectRegion="_rects"{set<gm::Box<double, 2>, md::MultiRectSetCompare, std::__1::allocator<gm::Box<double, 2> > >="__tree_"{__tree<gm::Box<double, 2>, md::MultiRectSetCompare, std::__1::allocator<gm::Box<double, 2> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<gm::Box<double, 2>, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, md::MultiRectSetCompare>="__value_"Q}}}}
@40@0:8@16@24B32B36
@40@0:8@16@24r^{vector<gm::Range<unsigned int>, std::__1::allocator<gm::Range<unsigned int> > >=^{Range<unsigned int>}^{Range<unsigned int>}{__compressed_pair<gm::Range<unsigned int> *, std::__1::allocator<gm::Range<unsigned int> > >=^{Range<unsigned int>}}}32
B40@0:8@16r^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}24^{array<gm::Matrix<double, 2, 1>, 2>=[2{Matrix<double, 2, 1>=[2d]}]}32
B40@0:8@16r^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}24@32
@36@0:8@16@24B32
v48@0:8@16@24Q32Q40
v24@0:8@"GEOComposedRoute"16
v40@0:8@"GEOComposedRoute"16@"NSArray"24@"NSArray"32
v48@0:8@"GEOComposedRoute"16@"GEOComposedTransitTripRouteLeg"24Q32Q40
v32@0:8@"GEOComposedRoute"16@"NSArray"24
{_NSRange=QQ}48@0:8{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16
@40@0:8@16B24B28@32
{DebugTreeNode={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{vector<mdc::DebugTreeNode, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}^{DebugTreeNode}{__compressed_pair<mdc::DebugTreeNode *, std::__1::allocator<mdc::DebugTreeNode> >=^{DebugTreeNode}}}{vector<mdc::DebugTreeProperty, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}^{DebugTreeProperty}{__compressed_pair<mdc::DebugTreeProperty *, std::__1::allocator<mdc::DebugTreeProperty> >=^{DebugTreeProperty}}}}16@0:8
@"<VKPolylineOverlayRouteRibbonObserver>"
{unique_ptr<md::TrafficSegmentsAlongRoute, std::__1::default_delete<md::TrafficSegmentsAlongRoute> >="__ptr_"{__compressed_pair<md::TrafficSegmentsAlongRoute *, std::__1::default_delete<md::TrafficSegmentsAlongRoute> >="__value_"^{TrafficSegmentsAlongRoute}}}
@"GEOComposedRouteTraffic"
@24@0:8^{RouteRenderLayer=^^?{vector<md::CommandBufferLocation, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}^{CommandBufferLocation}{__compressed_pair<md::CommandBufferLocation *, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}}}{vector<md::CommandBufferLocation, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}^{CommandBufferLocation}{__compressed_pair<md::CommandBufferLocation *, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}}}BCS^{RealisticRenderer}BBB{RouteModelPipelineStates={shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}{shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}{shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}{shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}}{RouteModelRenderStates=^{RenderState}^{RenderState}^{RenderState}^{RenderState}^{RenderState}}{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}{unique_ptr<ggl::Drawable, std::__1::default_delete<ggl::Drawable> >={__compressed_pair<ggl::Drawable *, std::__1::default_delete<ggl::Drawable> >=^{Drawable}}}{shared_ptr<ggl::ConstantData>=^{ConstantData}^{__shared_weak_count}}{shared_ptr<ggl::ConstantData>=^{ConstantData}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{shared_ptr<ggl::Texture2D>=^{Texture2D}^{__shared_weak_count}}{shared_ptr<ggl::Texture2D>=^{Texture2D}^{__shared_weak_count}}{vector<md::realistic::RouteRenderLayer::RouteDataMapping, std::__1::allocator<md::realistic::RouteRenderLayer::RouteDataMapping> >=^{RouteDataMapping}^{RouteDataMapping}{__compressed_pair<md::realistic::RouteRenderLayer::RouteDataMapping *, std::__1::allocator<md::realistic::RouteRenderLayer::RouteDataMapping> >=^{RouteDataMapping}}}{unique_ptr<md::FlyoverRouteOverlayCache, std::__1::default_delete<md::FlyoverRouteOverlayCache> >={__compressed_pair<md::FlyoverRouteOverlayCache *, std::__1::default_delete<md::FlyoverRouteOverlayCache> >=^{FlyoverRouteOverlayCache}}}}16
B24@0:8^@16
r^{set<id<VKRouteOverlay>, std::__1::less<id<VKRouteOverlay> >, std::__1::allocator<id<VKRouteOverlay> > >={__tree<id<VKRouteOverlay>, std::__1::less<id<VKRouteOverlay> >, std::__1::allocator<id<VKRouteOverlay> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<id<VKRouteOverlay>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<id<VKRouteOverlay> > >=Q}}}16@0:8
f28@0:8@16f24
@"<VKRouteMatchedAnnotationPresentation>"
@"<VKGlobeLineContainerDelegate>"
{set<id<VKRouteOverlay>, std::__1::less<id<VKRouteOverlay> >, std::__1::allocator<id<VKRouteOverlay> > >="__tree_"{__tree<id<VKRouteOverlay>, std::__1::less<id<VKRouteOverlay> >, std::__1::allocator<id<VKRouteOverlay> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<id<VKRouteOverlay>, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::less<id<VKRouteOverlay> > >="__value_"Q}}}
^{RouteRenderLayer=^^?{vector<md::CommandBufferLocation, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}^{CommandBufferLocation}{__compressed_pair<md::CommandBufferLocation *, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}}}{vector<md::CommandBufferLocation, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}^{CommandBufferLocation}{__compressed_pair<md::CommandBufferLocation *, std::__1::allocator<md::CommandBufferLocation> >=^{CommandBufferLocation}}}BCS^{RealisticRenderer}BBB{RouteModelPipelineStates={shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}{shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}{shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}{shared_ptr<ggl::PipelineState>=^{PipelineState}^{__shared_weak_count}}}{RouteModelRenderStates=^{RenderState}^{RenderState}^{RenderState}^{RenderState}^{RenderState}}{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}{unique_ptr<ggl::Drawable, std::__1::default_delete<ggl::Drawable> >={__compressed_pair<ggl::Drawable *, std::__1::default_delete<ggl::Drawable> >=^{Drawable}}}{shared_ptr<ggl::ConstantData>=^{ConstantData}^{__shared_weak_count}}{shared_ptr<ggl::ConstantData>=^{ConstantData}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{shared_ptr<ggl::Texture2D>=^{Texture2D}^{__shared_weak_count}}{shared_ptr<ggl::Texture2D>=^{Texture2D}^{__shared_weak_count}}{vector<md::realistic::RouteRenderLayer::RouteDataMapping, std::__1::allocator<md::realistic::RouteRenderLayer::RouteDataMapping> >=^{RouteDataMapping}^{RouteDataMapping}{__compressed_pair<md::realistic::RouteRenderLayer::RouteDataMapping *, std::__1::allocator<md::realistic::RouteRenderLayer::RouteDataMapping> >=^{RouteDataMapping}}}{unique_ptr<md::FlyoverRouteOverlayCache, std::__1::default_delete<md::FlyoverRouteOverlayCache> >={__compressed_pair<md::FlyoverRouteOverlayCache *, std::__1::default_delete<md::FlyoverRouteOverlayCache> >=^{FlyoverRouteOverlayCache}}}}
{map<VKPolylineOverlay *, std::__1::weak_ptr<altitude::RouteLineData>, std::__1::less<VKPolylineOverlay *>, std::__1::allocator<std::__1::pair<VKPolylineOverlay *const, std::__1::weak_ptr<altitude::RouteLineData> > > >="__tree_"{__tree<std::__1::__value_type<VKPolylineOverlay *, std::__1::weak_ptr<altitude::RouteLineData> >, std::__1::__map_value_compare<VKPolylineOverlay *, std::__1::__value_type<VKPolylineOverlay *, std::__1::weak_ptr<altitude::RouteLineData> >, std::__1::less<VKPolylineOverlay *>, true>, std::__1::allocator<std::__1::__value_type<VKPolylineOverlay *, std::__1::weak_ptr<altitude::RouteLineData> > > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<VKPolylineOverlay *, std::__1::weak_ptr<altitude::RouteLineData> >, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<VKPolylineOverlay *, std::__1::__value_type<VKPolylineOverlay *, std::__1::weak_ptr<altitude::RouteLineData> >, std::__1::less<VKPolylineOverlay *>, true> >="__value_"Q}}}
^{VKGlobeRouteSplit=^^?@}
@20@0:8I16
B20@0:8I16
v32@0:8@16r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}24
v40@0:8@16r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}24I32i36
v40@0:8@16r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}24@32
r^{vector<std::__1::shared_ptr<md::ObjectGroup>, std::__1::allocator<std::__1::shared_ptr<md::ObjectGroup> > >=^{shared_ptr<md::ObjectGroup>}^{shared_ptr<md::ObjectGroup>}{__compressed_pair<std::__1::shared_ptr<md::ObjectGroup> *, std::__1::allocator<std::__1::shared_ptr<md::ObjectGroup> > >=^{shared_ptr<md::ObjectGroup>}}}24@0:8r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}16
v40@0:8{GEOTileSetRegion=IIIIII}16
{GEOTileSetRegion=IIIIII}16@0:8
S16@0:8
v20@0:8S16
{?=BBBff}16@0:8
v28@0:8{?=BBBff}16
{?=ffddff}16@0:8
v48@0:8{?=ffddff}16
{GEOTileSetRegion="_maxX"I"_maxY"I"_maxZ"I"_minX"I"_minY"I"_minZ"I}
@"NSMutableDictionary"
{?="x"f"y"f"latitude"d"longitude"d"yaw"f"pitch"f}
{unique_ptr<(anonymous namespace)::CustomLandmarksContainer, std::__1::default_delete<(anonymous namespace)::CustomLandmarksContainer> >="__ptr_"{__compressed_pair<(anonymous namespace)::CustomLandmarksContainer *, std::__1::default_delete<(anonymous namespace)::CustomLandmarksContainer> >="__value_"^{CustomLandmarksContainer}}}
{?="borders"B"folds"B"angles"B"minAngle"f"maxAngle"f}
@48@0:8r^{?=^{?}QQQQ^{?}^{?}}16@24{PolylineCoordinate=If}32r^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}}40
r*16@0:8
v32@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16d24
v24@0:8^{?=^{?}QQQQ^{?}^{?}}16
B24@0:8r^{?=^{?}QQQQ^{?}^{?}}16
f60@0:8f16{Matrix<double, 3, 1>=[3d]}20{Matrix<float, 2, 1>=[2f]}44@52
B48@0:8^{Mercator3<double>=[3d]}16B24f28f32f36@40
v60@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16B24f28f32f36f40@44^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}52
v36@0:8C16^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}20^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}28
v24@0:8^{vector<gm::Matrix<double, 2, 1>, geo::StdAllocator<gm::Matrix<double, 2, 1>, mdm::Allocator> >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, geo::StdAllocator<gm::Matrix<double, 2, 1>, mdm::Allocator> >=^{Matrix<double, 2, 1>}{StdAllocator<gm::Matrix<double, 2, 1>, mdm::Allocator>=^{Allocator}}}}16
B28@0:8f16^{Mercator3<double>=[3d]}20
@64@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16B24{Matrix<double, 3, 1>=[3d]}28C52^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}56
v24@0:8{Matrix<float, 2, 1>=[2f]}16
^{?=II^{?}}16@0:8
r^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}}16@0:8
{shared_ptr<md::LabelTile>="__ptr_"^{LabelTile}"__cntrl_"^{__shared_weak_count}}
^{?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}
^{?=II^{?}}
@"VKLabelNavJunction"
{vector<gm::Matrix<double, 2, 1>, geo::StdAllocator<gm::Matrix<double, 2, 1>, mdm::Allocator> >="__begin_"^{Matrix<double, 2, 1>}"__end_"^{Matrix<double, 2, 1>}"__end_cap_"{__compressed_pair<gm::Matrix<double, 2, 1> *, geo::StdAllocator<gm::Matrix<double, 2, 1>, mdm::Allocator> >="__value_"^{Matrix<double, 2, 1>}"__value_"{StdAllocator<gm::Matrix<double, 2, 1>, mdm::Allocator>="_allocator"^{Allocator}}}}
[3B]
^{NavCurrentRoadSign=^^?{basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >::__rep, geo::StdAllocator<char, mdm::Allocator> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}{StdAllocator<char, mdm::Allocator>=^{Allocator}}}}{shared_ptr<md::LabelStyle>=^{LabelStyle}^{__shared_weak_count}}{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}{?=ff}{unique_ptr<md::NavLabelPart, std::__1::default_delete<md::NavLabelPart> >={__compressed_pair<md::NavLabelPart *, std::__1::default_delete<md::NavLabelPart> >=^{NavLabelPart}}}{Mercator2<double>=[2d]}{shared_ptr<md::Anchor>=^{Anchor}^{__shared_weak_count}}{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}{Box<float, 2>={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}}BBBfBBBff}16@0:8
v24@0:8r^{SceneContext=^^?S{unordered_map<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8>, mdc::LayerDataRequestKeyHash, std::__1::equal_to<mdc::LayerDataRequestKey>, std::__1::allocator<std::__1::pair<const mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> > > >={__hash_table<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, std::__1::__unordered_map_hasher<mdc::LayerDataRequestKey, std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, mdc::LayerDataRequestKeyHash, true>, std::__1::__unordered_map_equal<mdc::LayerDataRequestKey, std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, std::__1::equal_to<mdc::LayerDataRequestKey>, true>, std::__1::allocator<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> > > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<mdc::LayerDataRequestKey, std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, mdc::LayerDataRequestKeyHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<mdc::LayerDataRequestKey, std::__1::__hash_value_type<mdc::LayerDataRequestKey, geo::small_vector<geo::MercatorTile, 8> >, std::__1::equal_to<mdc::LayerDataRequestKey>, true> >=f}}}{linear_map<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> >, std::__1::equal_to<unsigned short>, std::__1::allocator<std::__1::pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > > >, std::__1::vector<std::__1::pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > >, std::__1::allocator<std::__1::pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > > > > >={vector<std::__1::pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > >, std::__1::allocator<std::__1::pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > > > >=^{pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > >}^{pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > >}{__compressed_pair<std::__1::pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > > *, std::__1::allocator<std::__1::pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > > > >=^{pair<unsigned short, std::__1::set<mdc::LayerDataWithWorld, std::__1::less<mdc::LayerDataWithWorld>, std::__1::allocator<mdc::LayerDataWithWorld> > >}}}}{linear_map<md::TileSelectionTileSetType, md::SceneTileSet, std::__1::equal_to<md::TileSelectionTileSetType>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> >, std::__1::vector<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > > >={vector<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > >=^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}{__compressed_pair<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> *, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > >=^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}}}}{linear_map<md::TileSelectionTileSetType, md::SceneTileSet, std::__1::equal_to<md::TileSelectionTileSetType>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> >, std::__1::vector<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > > >={vector<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > >=^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}{__compressed_pair<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> *, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > >=^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}}}}{linear_map<md::TileSelectionTileSetType, md::SceneTileSet, std::__1::equal_to<md::TileSelectionTileSetType>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> >, std::__1::vector<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > > >={vector<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet>, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > >=^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}{__compressed_pair<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> *, std::__1::allocator<std::__1::pair<md::TileSelectionTileSetType, md::SceneTileSet> > >=^{pair<md::TileSelectionTileSetType, md::SceneTileSet>}}}}{linear_set<md::TileSelectionTileSetType, std::__1::less<md::TileSelectionTileSetType>, std::__1::allocator<md::TileSelectionTileSetType>, std::__1::vector<md::TileSelectionTileSetType, std::__1::allocator<md::TileSelectionTileSetType> > >={vector<md::TileSelectionTileSetType, std::__1::allocator<md::TileSelectionTileSetType> >=^S^S{__compressed_pair<md::TileSelectionTileSetType *, std::__1::allocator<md::TileSelectionTileSetType> >=^S}}}B}16
v36@0:8@16^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}24B32
v36@0:8@16B24^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}28
v40@0:8@16B24^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}28B36
B40@0:8@16@24@32
C40@0:8@16@24^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}32
v32@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16r^{vector<VKLabelNavRoadLabel *, geo::StdAllocator<VKLabelNavRoadLabel *, mdm::Allocator> >=^@^@{__compressed_pair<VKLabelNavRoadLabel **, geo::StdAllocator<VKLabelNavRoadLabel *, mdm::Allocator> >=^@{StdAllocator<VKLabelNavRoadLabel *, mdm::Allocator>=^{Allocator}}}}24
v40@0:8@16^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}24Q32
v48@0:8@16^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}24Q32B40B44
B24@0:8r^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}}16
B52@0:8q16^{vector<RouteJunctionInfo, geo::StdAllocator<RouteJunctionInfo, mdm::Allocator> >=^{RouteJunctionInfo}^{RouteJunctionInfo}{__compressed_pair<RouteJunctionInfo *, geo::StdAllocator<RouteJunctionInfo, mdm::Allocator> >=^{RouteJunctionInfo}{StdAllocator<RouteJunctionInfo, mdm::Allocator>=^{Allocator}}}}24B32^q36^q44
v40@0:8@16^{DebugConsole=^^?{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}iiQ{unique_ptr<ggl::RenderItem, std::__1::default_delete<ggl::RenderItem> >={__compressed_pair<ggl::RenderItem *, std::__1::default_delete<ggl::RenderItem> >=^{RenderItem}}}{unique_ptr<ggl::RenderItem, std::__1::default_delete<ggl::RenderItem> >={__compressed_pair<ggl::RenderItem *, std::__1::default_delete<ggl::RenderItem> >=^{RenderItem}}}{unique_ptr<ggl::DataWrite<ggl::ColoredText::My>, std::__1::default_delete<ggl::DataWrite<ggl::ColoredText::My> > >={__compressed_pair<ggl::DataWrite<ggl::ColoredText::My> *, std::__1::default_delete<ggl::DataWrite<ggl::ColoredText::My> > >=^{DataWrite<ggl::ColoredText::My>}}}Q^{Matrix<float, 2, 1>}{Color<unsigned char, 4, geo::ColorSpace::Linear>={Matrix<unsigned char, 4, 1>=[4C]}}{Color<unsigned char, 4, geo::ColorSpace::Linear>={Matrix<unsigned char, 4, 1>=[4C]}}f^{CommonLibrary}{RenderTargetFormat=[4i]QIi}}24^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}32
C36@0:8r^{Matrix<float, 2, 1>=[2f]}16C24^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}28
r^{vector<std::__1::shared_ptr<md::NavLabel>, geo::StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator> >=^{shared_ptr<md::NavLabel>}^{shared_ptr<md::NavLabel>}{__compressed_pair<std::__1::shared_ptr<md::NavLabel> *, geo::StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator> >=^{shared_ptr<md::NavLabel>}{StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator>=^{Allocator}}}}16@0:8
^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}16@0:8
v24@0:8^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}16
{unordered_set<std::__1::shared_ptr<md::LabelTile>, std::__1::hash<std::__1::shared_ptr<md::LabelTile> >, std::__1::equal_to<std::__1::shared_ptr<md::LabelTile> >, geo::StdAllocator<std::__1::shared_ptr<md::LabelTile>, mdm::Allocator> >="__table_"{__hash_table<std::__1::shared_ptr<md::LabelTile>, std::__1::hash<std::__1::shared_ptr<md::LabelTile> >, std::__1::equal_to<std::__1::shared_ptr<md::LabelTile> >, geo::StdAllocator<std::__1::shared_ptr<md::LabelTile>, mdm::Allocator> >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>}"__value_"{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> >="__data_"{__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> >="__value_"Q"__value_"{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>="_allocator"^{Allocator}}}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *>, mdm::Allocator> >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>}}"__value_"{StdAllocator<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>="_allocator"^{Allocator}}}"__p2_"{__compressed_pair<unsigned long, std::__1::hash<std::__1::shared_ptr<md::LabelTile> > >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::equal_to<std::__1::shared_ptr<md::LabelTile> > >="__value_"f}}}
@"VKLabelNavRoadGraph"
{vector<std::__1::shared_ptr<md::NavLabel>, geo::StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator> >="__begin_"^{shared_ptr<md::NavLabel>}"__end_"^{shared_ptr<md::NavLabel>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<md::NavLabel> *, geo::StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator> >="__value_"^{shared_ptr<md::NavLabel>}"__value_"{StdAllocator<std::__1::shared_ptr<md::NavLabel>, mdm::Allocator>="_allocator"^{Allocator}}}}
^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}
{shared_ptr<md::NavCurrentRoadSign>="__ptr_"^{NavCurrentRoadSign}"__cntrl_"^{__shared_weak_count}}
{vector<VKLabelNavRoadLabel *, geo::StdAllocator<VKLabelNavRoadLabel *, mdm::Allocator> >="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<VKLabelNavRoadLabel **, geo::StdAllocator<VKLabelNavRoadLabel *, mdm::Allocator> >="__value_"^@"__value_"{StdAllocator<VKLabelNavRoadLabel *, mdm::Allocator>="_allocator"^{Allocator}}}}
@40@0:8@16@24{PolylineCoordinate=If}32
@28@0:8@16i24
{Geocentric<double>="_e"[3d]}
@"<MDARControllerDelegate>"
@32@0:8^{NSDictionary=#}16@24
v40@0:8@16^@24^@32
^{NSDictionary=#}
@40@0:8^{CGImage=}16d24@32
@28@0:8r^{Venue=QQ{vector<md::VenueBuilding, std::__1::allocator<md::VenueBuilding> >=^{VenueBuilding}^{VenueBuilding}{__compressed_pair<md::VenueBuilding *, std::__1::allocator<md::VenueBuilding> >=^{VenueBuilding}}}{Polygon2<double>={vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}}{ConvexHull2<double>={vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}}{Mercator2<double>=[2d]}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{optional<std::__1::basic_string<char> >=B(ValueUnion=[24C]{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}})}{optional<std::__1::basic_string<char> >=B(ValueUnion=[24C]{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}})}}16B24
r^{shared_ptr<md::VenueFeatureMarker>=^{VenueFeatureMarker}^{__shared_weak_count}}16@0:8
v56@0:8@16{?={?=dd}{?=dd}}24
v56@0:8@"<VKCustomFeatureDataSource>"16{?={?=dd}{?=dd}}24
v28@0:8@"<VKCustomFeatureDataSource>"16C24
@32@0:8@16^{LabelCustomFeatureProvider=^{LabelCustomFeatureSupport}^{LabelManager}{_retain_ptr<VKCustomFeatureDataSourceObserverThunk *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<id<VKCustomFeatureDataSource>, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{map<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo, md::LabelCustomFeatureProvider::TileKeyLess, geo::StdAllocator<std::__1::pair<const geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, mdm::Allocator> >={__tree<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, std::__1::__map_value_compare<geo::MercatorTile, std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, md::LabelCustomFeatureProvider::TileKeyLess, true>, geo::StdAllocator<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, mdm::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, void *>, mdm::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<geo::MercatorTile, std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, md::LabelCustomFeatureProvider::TileKeyLess, true> >=Q}}}{_retain_ptr<id<VKCustomFeatureAnnotation>, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<md::LabelScene>=^{LabelScene}^{__shared_weak_count}}{map<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo, std::__1::less<id<VKCustomFeatureAnnotation> >, geo::StdAllocator<std::__1::pair<const id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, mdm::Allocator> >={__tree<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, std::__1::__map_value_compare<id<VKCustomFeatureAnnotation>, std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, std::__1::less<id<VKCustomFeatureAnnotation> >, true>, geo::StdAllocator<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, mdm::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, void *>, mdm::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<id<VKCustomFeatureAnnotation>, std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, std::__1::less<id<VKCustomFeatureAnnotation> >, true> >=Q}}}{unique_ptr<md::LabelClusterProvider, std::__1::default_delete<md::LabelClusterProvider> >={__compressed_pair<md::LabelClusterProvider *, std::__1::default_delete<md::LabelClusterProvider> >=^{LabelClusterProvider}}}BCC}24
^{LabelCustomFeatureProvider=^{LabelCustomFeatureSupport}^{LabelManager}{_retain_ptr<VKCustomFeatureDataSourceObserverThunk *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{_retain_ptr<id<VKCustomFeatureDataSource>, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{map<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo, md::LabelCustomFeatureProvider::TileKeyLess, geo::StdAllocator<std::__1::pair<const geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, mdm::Allocator> >={__tree<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, std::__1::__map_value_compare<geo::MercatorTile, std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, md::LabelCustomFeatureProvider::TileKeyLess, true>, geo::StdAllocator<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, mdm::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, void *>, mdm::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<geo::MercatorTile, std::__1::__value_type<geo::MercatorTile, md::LabelCustomFeatureProvider::TileInfo>, md::LabelCustomFeatureProvider::TileKeyLess, true> >=Q}}}{_retain_ptr<id<VKCustomFeatureAnnotation>, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}{shared_ptr<md::LabelScene>=^{LabelScene}^{__shared_weak_count}}{map<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo, std::__1::less<id<VKCustomFeatureAnnotation> >, geo::StdAllocator<std::__1::pair<const id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, mdm::Allocator> >={__tree<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, std::__1::__map_value_compare<id<VKCustomFeatureAnnotation>, std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, std::__1::less<id<VKCustomFeatureAnnotation> >, true>, geo::StdAllocator<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, mdm::Allocator> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, geo::StdAllocator<std::__1::__tree_node<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, void *>, mdm::Allocator> >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}{StdAllocator<std::__1::__tree_node<std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<id<VKCustomFeatureAnnotation>, std::__1::__value_type<id<VKCustomFeatureAnnotation>, md::LabelCustomFeatureProvider::FeatureInfo>, std::__1::less<id<VKCustomFeatureAnnotation> >, true> >=Q}}}{unique_ptr<md::LabelClusterProvider, std::__1::default_delete<md::LabelClusterProvider> >={__compressed_pair<md::LabelClusterProvider *, std::__1::default_delete<md::LabelClusterProvider> >=^{LabelClusterProvider}}}BCC}
{_retain_ptr<id<VKCustomFeatureDataSource>, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"<VKCustomFeatureDataSource>""_retain"{_retain_objc=}"_release"{_release_objc=}}
@40@0:8@16:24@32
@"VKAnnotationTrackingCameraController"
@"VKGestureCameraBehavior"
{?="min"d"max"d}
@24@0:8^{GeoResourceProvider=^^?{unordered_set<grl::ResourceObserver *, std::__1::hash<grl::ResourceObserver *>, std::__1::equal_to<grl::ResourceObserver *>, std::__1::allocator<grl::ResourceObserver *> >={__hash_table<grl::ResourceObserver *, std::__1::hash<grl::ResourceObserver *>, std::__1::equal_to<grl::ResourceObserver *>, std::__1::allocator<grl::ResourceObserver *> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>, std::__1::allocator<std::__1::__hash_node<grl::ResourceObserver *, void *> > >={__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>=^{__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<grl::ResourceObserver *> >=Q}{__compressed_pair<float, std::__1::equal_to<grl::ResourceObserver *> >=f}}}{_retain_ptr<GRLResourceGroupObserver *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}}16
^{GeoResourceProvider=^^?{unordered_set<grl::ResourceObserver *, std::__1::hash<grl::ResourceObserver *>, std::__1::equal_to<grl::ResourceObserver *>, std::__1::allocator<grl::ResourceObserver *> >={__hash_table<grl::ResourceObserver *, std::__1::hash<grl::ResourceObserver *>, std::__1::equal_to<grl::ResourceObserver *>, std::__1::allocator<grl::ResourceObserver *> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>, std::__1::allocator<std::__1::__hash_node<grl::ResourceObserver *, void *> > >={__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>=^{__hash_node_base<std::__1::__hash_node<grl::ResourceObserver *, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<grl::ResourceObserver *> >=Q}{__compressed_pair<float, std::__1::equal_to<grl::ResourceObserver *> >=f}}}{_retain_ptr<GRLResourceGroupObserver *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}}
{shared_ptr<altitude::GeoServicesLoadJob>=^{GeoServicesLoadJob}^{__shared_weak_count}}24@0:8r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}16
v24@0:8^{shared_ptr<altitude::GeoServicesLoadJob>=^{GeoServicesLoadJob}^{__shared_weak_count}}16
v24@0:8r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}16
@"GEOTileLoader"
{_retain_ptr<GEOVectorTileDecoder *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"GEOVectorTileDecoder""_retain"{_retain_objc=}"_release"{_release_objc=}}
{_retain_ptr<GEOApplicationAuditToken *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"GEOApplicationAuditToken""_retain"{_retain_objc=}"_release"{_release_objc=}}
{unordered_map<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob>, GEOTileKeyHashFunc, GEOTileKeyEqualsFunc, std::__1::allocator<std::__1::pair<const _GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> > > >="__table_"{__hash_table<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, std::__1::__unordered_map_hasher<_GEOTileKey, std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, GEOTileKeyHashFunc, true>, std::__1::__unordered_map_equal<_GEOTileKey, std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, GEOTileKeyEqualsFunc, true>, std::__1::allocator<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> > > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<_GEOTileKey, std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, GEOTileKeyHashFunc, true> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<_GEOTileKey, std::__1::__hash_value_type<_GEOTileKey, std::__1::shared_ptr<altitude::GeoServicesLoadJob> >, GEOTileKeyEqualsFunc, true> >="__value_"f}}}
{Mutex="mMutex"^v}
@64@0:8{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}16^{MapDataAccess=^{World}C@^{CameraAccessInternal}{unique_ptr<md::CameraAccessCartographic, std::__1::default_delete<md::CameraAccessCartographic> >={__compressed_pair<md::CameraAccessCartographic *, std::__1::default_delete<md::CameraAccessCartographic> >=^{CameraAccessCartographic}}}{unique_ptr<md::CameraAccessGlobe, std::__1::default_delete<md::CameraAccessGlobe> >={__compressed_pair<md::CameraAccessGlobe *, std::__1::default_delete<md::CameraAccessGlobe> >=^{CameraAccessGlobe}}}{unique_ptr<md::CameraAccessMunin, std::__1::default_delete<md::CameraAccessMunin> >={__compressed_pair<md::CameraAccessMunin *, std::__1::default_delete<md::CameraAccessMunin> >=^{CameraAccessMunin}}}}32^{AnimationRunner=^{MapEngine}}40^{RunLoopController=^{MapEngine}qq}48@56
v32@0:8d16B24B28
v56@0:8{CGPoint=dd}16d32d40@?48
v92@0:8{?=dd}16d32B40d44d52d60d68@?76@?84
@?128@0:8{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}16{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}72
v24@0:8f16f20
d48@0:8{?=dd}16{?=dd}32
d40@0:8d16d24d32
v56@0:8d16@?24{Matrix<int, 2, 1>=[2i]}32@?40@?48
{CameraManager="_vptr$CameraManager"^^?"_panBegin"B"_panInProgress"B"_panEnd"B"_panCurrentCursor"{Matrix<int, 2, 1>="_e"[2i]}"_panPreviousCursor"{Matrix<int, 2, 1>="_e"[2i]}"_panStartCursor"{Matrix<int, 2, 1>="_e"[2i]}"_panStartPosition"{Coordinate3D<Radians, double>="latitude"{Unit<RadianUnitDescription, double>="_value"d}"longitude"{Unit<RadianUnitDescription, double>="_value"d}"altitude"{Unit<MeterUnitDescription, double>="_value"d}}"_panDistance"d"_panAtStartPosition"B"_rotateBegin"B"_rotateInProgress"B"_rotateEnd"B"_rotateStartPosition"{Coordinate3D<Radians, double>="latitude"{Unit<RadianUnitDescription, double>="_value"d}"longitude"{Unit<RadianUnitDescription, double>="_value"d}"altitude"{Unit<MeterUnitDescription, double>="_value"d}}"_rotateCurrentCursor"{Matrix<int, 2, 1>="_e"[2i]}"_rotateAngle"d"_tiltBegin"B"_tiltInProgress"B"_tiltEnd"B"_tiltStartPosition"{Coordinate3D<Radians, double>="latitude"{Unit<RadianUnitDescription, double>="_value"d}"longitude"{Unit<RadianUnitDescription, double>="_value"d}"altitude"{Unit<MeterUnitDescription, double>="_value"d}}"_tiltCurrentCursor"{Matrix<int, 2, 1>="_e"[2i]}"_tiltPreviousCursor"{Matrix<int, 2, 1>="_e"[2i]}"_tiltAngle"d"_zoomBegin"B"_zoomInProgress"B"_zoomEnd"B"_zoomStartPosition"{Coordinate3D<Radians, double>="latitude"{Unit<RadianUnitDescription, double>="_value"d}"longitude"{Unit<RadianUnitDescription, double>="_value"d}"altitude"{Unit<MeterUnitDescription, double>="_value"d}}"_zoomCurrentCursor"{Matrix<int, 2, 1>="_e"[2i]}"_zoomFactor"d"_zoomStartDistance"d"_zoomRotateToNorth"B"_useTiltLimit"B"_tiltLimitMode"i"_tiltLimitPushDownEnabled"B"_tiltLimitTransferInProgress"B"_tiltLimitPushDown"B"_startPushDownTilt"d"_tiltLimitTransferFraction"d"_startTiltLimitTilt"d"_startTiltLimitPosition"{Geocentric<double>="_e"[3d]}"_startTiltLimitDirection"{Matrix<double, 3, 1>="_e"[3d]}"_fullZoomTiltLimitFactor"d"_singleRestriction"{Box<double, 2>="_minimum"{Matrix<double, 2, 1>="_e"[2d]}"_maximum"{Matrix<double, 2, 1>="_e"[2d]}}"_westOfDatelineRestriction"{Box<double, 2>="_minimum"{Matrix<double, 2, 1>="_e"[2d]}"_maximum"{Matrix<double, 2, 1>="_e"[2d]}}"_eastOfDatelineRestriction"{Box<double, 2>="_minimum"{Matrix<double, 2, 1>="_e"[2d]}"_maximum"{Matrix<double, 2, 1>="_e"[2d]}}}
^{vector<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> > >=^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> > >=^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}}}16@0:8
r^{MeshVendor<ggl::BuildingFacade::BuildingMesh>={vector<std::__1::unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> >, geo::StdAllocator<std::__1::unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> >, ggl::Allocator> >=^{unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> >}^{unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> >}{__compressed_pair<std::__1::unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> > *, geo::StdAllocator<std::__1::unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> >, ggl::Allocator> >=^{unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> >}{StdAllocator<std::__1::unique_ptr<ggl::BuildingFacade::BuildingMesh, std::__1::default_delete<ggl::BuildingFacade::BuildingMesh> >, ggl::Allocator>=^{Allocator}}}}}16@0:8
r^{MeshVendor<ggl::PrefilteredLine::PrefilteredLineMesh>={vector<std::__1::unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> >, geo::StdAllocator<std::__1::unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> >, ggl::Allocator> >=^{unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> >}^{unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> >}{__compressed_pair<std::__1::unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> > *, geo::StdAllocator<std::__1::unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> >, ggl::Allocator> >=^{unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> >}{StdAllocator<std::__1::unique_ptr<ggl::PrefilteredLine::PrefilteredLineMesh, std::__1::default_delete<ggl::PrefilteredLine::PrefilteredLineMesh> >, ggl::Allocator>=^{Allocator}}}}}16@0:8
r^{MeshVendor<ggl::BuildingPointyRoof::BuildingMesh>={vector<std::__1::unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> >, geo::StdAllocator<std::__1::unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> >, ggl::Allocator> >=^{unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> >}^{unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> >}{__compressed_pair<std::__1::unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> > *, geo::StdAllocator<std::__1::unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> >, ggl::Allocator> >=^{unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> >}{StdAllocator<std::__1::unique_ptr<ggl::BuildingPointyRoof::BuildingMesh, std::__1::default_delete<ggl::BuildingPointyRoof::BuildingMesh> >, ggl::Allocator>=^{Allocator}}}}}16@0:8
^{vector<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> >, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >=^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}{__compressed_pair<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > *, std::__1::allocator<std::__1::shared_ptr<gss::StylesheetQuery<gss::PropertyID> > > >=^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >}}}24@0:8B16B20
v32@0:8^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}QQBB}16C24f28
v68@0:8^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}QQBB}16Q24Q32^{ResourceAccessor=^^?}40^{Triangulator<float>={Triangulator<float, unsigned short>={NodePool={stack<geo::Triangulator<float, unsigned short>::Node *, std::__1::vector<geo::Triangulator<float, unsigned short>::Node *, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> > >={vector<geo::Triangulator<float, unsigned short>::Node *, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> >=^^{Node}^^{Node}{__compressed_pair<geo::Triangulator<float, unsigned short>::Node **, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> >=^^{Node}}}}}{GeometricHasher={AABB=[2f][2f]}f}Qi}{vector<unsigned short, std::__1::allocator<unsigned short> >=^S^S{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >=^S}}}48B56C60f64
v40@0:8^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}QQBB}16Q24Q32
B40@0:8^{?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}16^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}QQBB}24C32f36
B36@0:8^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}QQBB}16C24f28f32
v24@0:8r^{shared_ptr<gss::StylesheetManager<gss::PropertyID> >=^{StylesheetManager<gss::PropertyID>}^{__shared_weak_count}}16
{optional<md::MeshSet<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh, ggl::BuildingFlatStroke::DefaultVbo> >="_hasValue"B"_value"(ValueUnion="data"[152C]"type"{MeshSet<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh, ggl::BuildingFlatStroke::DefaultVbo>="_vertexAndIndexCounts"{vector<std::__1::pair<unsigned short, unsigned int>, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__begin_"^{pair<unsigned short, unsigned int>}"__end_"^{pair<unsigned short, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<unsigned short, unsigned int> *, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__value_"^{pair<unsigned short, unsigned int>}}}"_meshes"{vector<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> > >="__begin_"^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}"__end_"^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> > >="__value_"^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}}}"_vertexDataWrite"{DataWrite<ggl::BuildingFlatStroke::DefaultVbo>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_indexDataWrite"{DataWrite<unsigned short>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_meshIndex"C"_meshVertexOffset"S"_meshIndexOffset"I})}
{vector<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> > >="__begin_"^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}"__end_"^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh> > >="__value_"^{shared_ptr<ggl::BuildingFlatStroke::BuildingFlatStrokeMesh>}}}
{unique_ptr<ggl::MeshVendor<ggl::BuildingFacade::BuildingMesh>, std::__1::default_delete<ggl::MeshVendor<ggl::BuildingFacade::BuildingMesh> > >="__ptr_"{__compressed_pair<ggl::MeshVendor<ggl::BuildingFacade::BuildingMesh> *, std::__1::default_delete<ggl::MeshVendor<ggl::BuildingFacade::BuildingMesh> > >="__value_"^{MeshVendor<ggl::BuildingFacade::BuildingMesh>}}}
{unique_ptr<ggl::MeshVendor<ggl::PrefilteredLine::PrefilteredLineMesh>, std::__1::default_delete<ggl::MeshVendor<ggl::PrefilteredLine::PrefilteredLineMesh> > >="__ptr_"{__compressed_pair<ggl::MeshVendor<ggl::PrefilteredLine::PrefilteredLineMesh> *, std::__1::default_delete<ggl::MeshVendor<ggl::PrefilteredLine::PrefilteredLineMesh> > >="__value_"^{MeshVendor<ggl::PrefilteredLine::PrefilteredLineMesh>}}}
{unique_ptr<ggl::MeshVendor<ggl::BuildingPointyRoof::BuildingMesh>, std::__1::default_delete<ggl::MeshVendor<ggl::BuildingPointyRoof::BuildingMesh> > >="__ptr_"{__compressed_pair<ggl::MeshVendor<ggl::BuildingPointyRoof::BuildingMesh> *, std::__1::default_delete<ggl::MeshVendor<ggl::BuildingPointyRoof::BuildingMesh> > >="__value_"^{MeshVendor<ggl::BuildingPointyRoof::BuildingMesh>}}}
@"NSObject<OS_xpc_object>"
@"VKMapView"
@40@0:8^{?=II^{?}}16{PolylineCoordinate=If}24r^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}}32
@44@0:8r^{?=^{?}QQQQ^{?}^{?}}16B24{PolylineCoordinate=If}28r^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}}36
v28@0:8r^{VKLabelNavRouteRoadEdge={PolylineCoordinate=If}{PolylineCoordinate=If}^{?}}16B24
C20@0:8B16
{Matrix<double, 3, 1>=[3d]}20@0:8C16
v36@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16B24^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}28
r^{?=II^{?}}16@0:8
@"VKLabelNavRoad"
^{?={?=@*QQQQIQBQfQ@i}{?=ff}f{?=ff}QQQQssCffIICCBBBBB}
v40@0:8@16@24d32
v24@0:8^{Texture=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiII}16
v32@0:8^{Texture=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiII}16^{RenderQueue={PassDescriptor=[4{AttachmentActions=ii}]{AttachmentActions=ii}{AttachmentActions=ii}}{vector<ggl::RenderQueue::Pass, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}^{Pass}{__compressed_pair<ggl::RenderQueue::Pass *, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}{StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ComputeQueue *, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}^^{ComputeQueue}{__compressed_pair<ggl::ComputeQueue **, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}{StdAllocator<ggl::ComputeQueue *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::CommandBuffer *, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}^^{CommandBuffer}{__compressed_pair<ggl::CommandBuffer **, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}{StdAllocator<ggl::CommandBuffer *, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::RenderTransaction>=^{RenderTransaction}^{__shared_weak_count}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}}24
^{DebugConsole=^^?{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}iiQ{unique_ptr<ggl::RenderItem, std::__1::default_delete<ggl::RenderItem> >={__compressed_pair<ggl::RenderItem *, std::__1::default_delete<ggl::RenderItem> >=^{RenderItem}}}{unique_ptr<ggl::RenderItem, std::__1::default_delete<ggl::RenderItem> >={__compressed_pair<ggl::RenderItem *, std::__1::default_delete<ggl::RenderItem> >=^{RenderItem}}}{unique_ptr<ggl::DataWrite<ggl::ColoredText::My>, std::__1::default_delete<ggl::DataWrite<ggl::ColoredText::My> > >={__compressed_pair<ggl::DataWrite<ggl::ColoredText::My> *, std::__1::default_delete<ggl::DataWrite<ggl::ColoredText::My> > >=^{DataWrite<ggl::ColoredText::My>}}}Q^{Matrix<float, 2, 1>}{Color<unsigned char, 4, geo::ColorSpace::Linear>={Matrix<unsigned char, 4, 1>=[4C]}}{Color<unsigned char, 4, geo::ColorSpace::Linear>={Matrix<unsigned char, 4, 1>=[4C]}}f^{CommonLibrary}{RenderTargetFormat=[4i]QIi}}20@0:8i16
@60@0:8d16B24r^{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}28^{Device=i{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{unique_ptr<md::SharedDeviceResources, std::__1::default_delete<md::SharedDeviceResources> >={__compressed_pair<md::SharedDeviceResources *, std::__1::default_delete<md::SharedDeviceResources> >=^{SharedDeviceResources}}}}36@44Q52
^{RenderQueue={PassDescriptor=[4{AttachmentActions=ii}]{AttachmentActions=ii}{AttachmentActions=ii}}{vector<ggl::RenderQueue::Pass, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}^{Pass}{__compressed_pair<ggl::RenderQueue::Pass *, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}{StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ComputeQueue *, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}^^{ComputeQueue}{__compressed_pair<ggl::ComputeQueue **, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}{StdAllocator<ggl::ComputeQueue *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::CommandBuffer *, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}^^{CommandBuffer}{__compressed_pair<ggl::CommandBuffer **, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}{StdAllocator<ggl::CommandBuffer *, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::RenderTransaction>=^{RenderTransaction}^{__shared_weak_count}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}}32@0:8d16@?24
v40@0:8^{Texture=^^?^{ResourceManager}^{RenderResource}^^?*iiiiIiII}16^{RenderQueue={PassDescriptor=[4{AttachmentActions=ii}]{AttachmentActions=ii}{AttachmentActions=ii}}{vector<ggl::RenderQueue::Pass, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}^{Pass}{__compressed_pair<ggl::RenderQueue::Pass *, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}{StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ComputeQueue *, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}^^{ComputeQueue}{__compressed_pair<ggl::ComputeQueue **, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}{StdAllocator<ggl::ComputeQueue *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::CommandBuffer *, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}^^{CommandBuffer}{__compressed_pair<ggl::CommandBuffer **, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}{StdAllocator<ggl::CommandBuffer *, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::RenderTransaction>=^{RenderTransaction}^{__shared_weak_count}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}}24@?32
v24@0:8^{CGColor=}16
v24@0:8^{shared_ptr<ggl::BitmapDataBase>=^{BitmapDataBase}^{__shared_weak_count}}16
@"CALayer<GGLLayer>"
^{RenderQueue={PassDescriptor=[4{AttachmentActions=ii}]{AttachmentActions=ii}{AttachmentActions=ii}}{vector<ggl::RenderQueue::Pass, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}^{Pass}{__compressed_pair<ggl::RenderQueue::Pass *, geo::StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator> >=^{Pass}{StdAllocator<ggl::RenderQueue::Pass, ggl::Allocator>=^{Allocator}}}}{vector<ggl::ComputeQueue *, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}^^{ComputeQueue}{__compressed_pair<ggl::ComputeQueue **, geo::StdAllocator<ggl::ComputeQueue *, ggl::Allocator> >=^^{ComputeQueue}{StdAllocator<ggl::ComputeQueue *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::CommandBuffer *, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}^^{CommandBuffer}{__compressed_pair<ggl::CommandBuffer **, geo::StdAllocator<ggl::CommandBuffer *, ggl::Allocator> >=^^{CommandBuffer}{StdAllocator<ggl::CommandBuffer *, ggl::Allocator>=^{Allocator}}}}{shared_ptr<ggl::RenderTransaction>=^{RenderTransaction}^{__shared_weak_count}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}{vector<ggl::Texture *, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}^^{Texture}{__compressed_pair<ggl::Texture **, geo::StdAllocator<ggl::Texture *, ggl::Allocator> >=^^{Texture}{StdAllocator<ggl::Texture *, ggl::Allocator>=^{Allocator}}}}}
{_retain_ptr<VKSharedResources *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"VKSharedResources""_retain"{_retain_objc=}"_release"{_release_objc=}}
{deque<std::__1::function<void ()>, std::__1::allocator<std::__1::function<void ()> > >="__map_"{__split_buffer<std::__1::function<void ()> *, std::__1::allocator<std::__1::function<void ()> *> >="__first_"^^{function<void ()>}"__begin_"^^{function<void ()>}"__end_"^^{function<void ()>}"__end_cap_"{__compressed_pair<std::__1::function<void ()> **, std::__1::allocator<std::__1::function<void ()> *> >="__value_"^^{function<void ()>}}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::function<void ()> > >="__value_"Q}}
^{Device=i{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{unique_ptr<md::SharedDeviceResources, std::__1::default_delete<md::SharedDeviceResources> >={__compressed_pair<md::SharedDeviceResources *, std::__1::default_delete<md::SharedDeviceResources> >=^{SharedDeviceResources}}}}
{unique_ptr<md::DebugConsoleManager, std::__1::default_delete<md::DebugConsoleManager> >="__ptr_"{__compressed_pair<md::DebugConsoleManager *, std::__1::default_delete<md::DebugConsoleManager> >="__value_"^{DebugConsoleManager}}}
[3{unique_ptr<ggl::RenderBuffer, std::__1::default_delete<ggl::RenderBuffer> >="__ptr_"{__compressed_pair<ggl::RenderBuffer *, std::__1::default_delete<ggl::RenderBuffer> >="__value_"^{RenderBuffer}}}]
^{CGContext=}
d24@0:8^{Anchor=^^?^{AnchorManager}{Mercator3<double>=[3d]}{Coordinate2D<Degrees, double>={Unit<DegreeUnitDescription, double>=d}{Unit<DegreeUnitDescription, double>=d}}@}16
v24@0:8^{Anchor=^^?^{AnchorManager}{Mercator3<double>=[3d]}{Coordinate2D<Degrees, double>={Unit<DegreeUnitDescription, double>=d}{Unit<DegreeUnitDescription, double>=d}}@}16
v24@0:8r^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16
@"<VKMercatorTerrainHeightProvider>"
{map<md::Anchor *, float, std::__1::less<md::Anchor *>, std::__1::allocator<std::__1::pair<md::Anchor *const, float> > >="__tree_"{__tree<std::__1::__value_type<md::Anchor *, float>, std::__1::__map_value_compare<md::Anchor *, std::__1::__value_type<md::Anchor *, float>, std::__1::less<md::Anchor *>, true>, std::__1::allocator<std::__1::__value_type<md::Anchor *, float> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<md::Anchor *, float>, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<md::Anchor *, std::__1::__value_type<md::Anchor *, float>, std::__1::less<md::Anchor *>, true> >="__value_"Q}}}
@"<VKVectorOverlayDelegate>"
@32@0:8r^{?=dd}16Q24
{shared_ptr<std::__1::vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > > >=^{vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > >}^{__shared_weak_count}}20@0:8C16
{Range<signed char>=cc}16@0:8
{vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > >="__begin_"^{Mercator2<double>}"__end_"^{Mercator2<double>}"__end_cap_"{__compressed_pair<geo::Mercator2<double> *, std::__1::allocator<geo::Mercator2<double> > >="__value_"^{Mercator2<double>}}}
{Range<signed char>="_min"c"_max"c}
{unique_ptr<geo::Cache<unsigned char, std::__1::shared_ptr<std::__1::vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > > >, std::__1::hash<unsigned char>, LRUPolicy>, std::__1::default_delete<geo::Cache<unsigned char, std::__1::shared_ptr<std::__1::vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > > >, std::__1::hash<unsigned char>, LRUPolicy> > >="__ptr_"{__compressed_pair<geo::Cache<unsigned char, std::__1::shared_ptr<std::__1::vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > > >, std::__1::hash<unsigned char>, LRUPolicy> *, std::__1::default_delete<geo::Cache<unsigned char, std::__1::shared_ptr<std::__1::vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > > >, std::__1::hash<unsigned char>, LRUPolicy> > >="__value_"^{Cache<unsigned char, std::__1::shared_ptr<std::__1::vector<geo::Mercator2<double>, std::__1::allocator<geo::Mercator2<double> > > >, std::__1::hash<unsigned char>, LRUPolicy>}}}
{unfair_lock="_lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}}
{shared_ptr<md::PolylineOverlayStyle>=^{PolylineOverlayStyle}^{__shared_weak_count}}16@0:8
^{CGColor=}
{shared_ptr<md::PolylineOverlayStyle>="__ptr_"^{PolylineOverlayStyle}"__cntrl_"^{__shared_weak_count}}
@80@0:8{?={?=dd}{?=dd}}16d48^{CGColor=}56^{CGColor=}64d72
{shared_ptr<md::CircleOverlayRenderable>=^{CircleOverlayRenderable}^{__shared_weak_count}}16@0:8
{?="origin"{?="x"d"y"d}"size"{?="width"d"height"d}}
{shared_ptr<md::CircleOverlayRenderable>="__ptr_"^{CircleOverlayRenderable}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<md::CircleOverlayRenderable::Style>="__ptr_"^{Style}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<geo::Polygon2<double> >=^{Polygon2<double>}^{__shared_weak_count}}16@0:8
{shared_ptr<geo::Polygon2<double> >="__ptr_"^{Polygon2<double>}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<md::PolygonOverlayRenderable::Style>=^{Style}^{__shared_weak_count}}16@0:8
{shared_ptr<md::PolygonOverlayRenderable::Style>="__ptr_"^{Style}"__cntrl_"^{__shared_weak_count}}
{?="variantType"b1}
@36@0:8@16r^{shared_ptr<md::NavLabel>=^{NavLabel}^{__shared_weak_count}}24i32
r^{shared_ptr<md::NavLabel>=^{NavLabel}^{__shared_weak_count}}16@0:8
{shared_ptr<md::NavLabel>="__ptr_"^{NavLabel}"__cntrl_"^{__shared_weak_count}}
@"<VKLabelNavFeature>"
@24@0:8r^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}}16
@24@0:8^{?=II^{?}}16
@24@0:8{Matrix<float, 2, 1>=[2f]}16
v32@0:8r^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16@24
v32@0:8^{unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature>, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, geo::StdAllocator<std::__1::pair<const std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, mdm::Allocator> >={__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::__unordered_map_hasher<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true>, geo::StdAllocator<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>}}{StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true> >=f}}}16d24
{vector<LabelNavJunctionInfo, geo::StdAllocator<LabelNavJunctionInfo, mdm::Allocator> >="__begin_"^{LabelNavJunctionInfo}"__end_"^{LabelNavJunctionInfo}"__end_cap_"{__compressed_pair<LabelNavJunctionInfo *, geo::StdAllocator<LabelNavJunctionInfo, mdm::Allocator> >="__value_"^{LabelNavJunctionInfo}"__value_"{StdAllocator<LabelNavJunctionInfo, mdm::Allocator>="_allocator"^{Allocator}}}}
v32@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16{PolylineCoordinate=If}24
v24@0:8r^{unordered_set<std::__1::shared_ptr<md::LabelTile>, std::__1::hash<std::__1::shared_ptr<md::LabelTile> >, std::__1::equal_to<std::__1::shared_ptr<md::LabelTile> >, geo::StdAllocator<std::__1::shared_ptr<md::LabelTile>, mdm::Allocator> >={__hash_table<std::__1::shared_ptr<md::LabelTile>, std::__1::hash<std::__1::shared_ptr<md::LabelTile> >, std::__1::equal_to<std::__1::shared_ptr<md::LabelTile> >, geo::StdAllocator<std::__1::shared_ptr<md::LabelTile>, mdm::Allocator> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>}{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> >={__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> >=Q{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>=^{Allocator}}}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *>, mdm::Allocator> >={__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *> *>}}{StdAllocator<std::__1::__hash_node<std::__1::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>=^{Allocator}}}{__compressed_pair<unsigned long, std::__1::hash<std::__1::shared_ptr<md::LabelTile> > >=Q}{__compressed_pair<float, std::__1::equal_to<std::__1::shared_ptr<md::LabelTile> > >=f}}}16
@32@0:8@16B24B28
{unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature>, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, geo::StdAllocator<std::__1::pair<const std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, mdm::Allocator> >="__table_"{__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::__unordered_map_hasher<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true>, geo::StdAllocator<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, mdm::Allocator> >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *[], std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> **, std::__1::__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>}"__value_"{__bucket_list_deallocator<geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> >="__data_"{__compressed_pair<unsigned long, geo::StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator> >="__value_"Q"__value_"{StdAllocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *> *, mdm::Allocator>="_allocator"^{Allocator}}}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>, geo::StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *>, mdm::Allocator> >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *> *>}}"__value_"{StdAllocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, void *>, mdm::Allocator>="_allocator"^{Allocator}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> >, std::__1::shared_ptr<NavRoadFeature> >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, geo::StdAllocator<char, mdm::Allocator> > >, true> >="__value_"f}}}
{vector<RouteSegment, geo::StdAllocator<RouteSegment, mdm::Allocator> >="__begin_"^{RouteSegment}"__end_"^{RouteSegment}"__end_cap_"{__compressed_pair<RouteSegment *, geo::StdAllocator<RouteSegment, mdm::Allocator> >="__value_"^{RouteSegment}"__value_"{StdAllocator<RouteSegment, mdm::Allocator>="_allocator"^{Allocator}}}}
v48@0:8r^{VKLabelNavRouteRoadEdge={PolylineCoordinate=If}{PolylineCoordinate=If}^{?}}16B24B28r^{shared_ptr<md::LabelTile>=^{LabelTile}^{__shared_weak_count}}32@40
B44@0:8@16@24@32B40
@36@0:8^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16Q24B32
B28@0:8@16f24
B40@0:8@16^f24^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}32
v24@0:8r^{vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}16
{?={?=dd}{?=dd}}16@0:8
{vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >="__begin_"^{Matrix<double, 2, 1>}"__end_"^{Matrix<double, 2, 1>}"__end_cap_"{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >="__value_"^{Matrix<double, 2, 1>}}}
@44@0:8^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}16f24i28Q32f40
r^{vector<std::__1::shared_ptr<ggl::VenueWall::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >=^{shared_ptr<ggl::VenueWall::MeshMesh>}^{shared_ptr<ggl::VenueWall::MeshMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >=^{shared_ptr<ggl::VenueWall::MeshMesh>}}}16@0:8
r^{vector<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >=^{shared_ptr<ggl::VenueWall::EndCapMesh>}^{shared_ptr<ggl::VenueWall::EndCapMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >=^{shared_ptr<ggl::VenueWall::EndCapMesh>}}}16@0:8
r^{vector<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}}}16@0:8
r^{vector<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >=^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}}}16@0:8
r^{vector<Edge, std::__1::allocator<Edge> >=^{Edge}^{Edge}{__compressed_pair<Edge *, std::__1::allocator<Edge> >=^{Edge}}}32@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16r^{pair<void *, unsigned long>=^vQ}24
Q40@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16r^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}24r^{vector<Edge, std::__1::allocator<Edge> >=^{Edge}^{Edge}{__compressed_pair<Edge *, std::__1::allocator<Edge> >=^{Edge}}}32
{StrokeBufferSizing=QQQQ}40@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16r^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}24r^{vector<Edge, std::__1::allocator<Edge> >=^{Edge}^{Edge}{__compressed_pair<Edge *, std::__1::allocator<Edge> >=^{Edge}}}32
v40@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}24r^{vector<Edge, std::__1::allocator<Edge> >=^{Edge}^{Edge}{__compressed_pair<Edge *, std::__1::allocator<Edge> >=^{Edge}}}32
v40@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16r^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}24r^{vector<Edge, std::__1::allocator<Edge> >=^{Edge}^{Edge}{__compressed_pair<Edge *, std::__1::allocator<Edge> >=^{Edge}}}32
v44@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16r^{pair<void *, unsigned long>=^vQ}24^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}32I40
v60@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16r^{vector<Edge, std::__1::allocator<Edge> >=^{Edge}^{Edge}{__compressed_pair<Edge *, std::__1::allocator<Edge> >=^{Edge}}}24@32^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}40I48^{ResourceAccessor=^^?}52
v72@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16I24{pair<void *, unsigned long>=^vQ}28@44^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}52I60^{ResourceAccessor=^^?}64
v28@0:8C16^{shared_ptr<md::TextureManager>=}20
{optional<md::MeshSet<ggl::VenueWall::MeshMesh, ggl::VenueWall::DefaultVbo> >="_hasValue"B"_value"(ValueUnion="data"[152C]"type"{MeshSet<ggl::VenueWall::MeshMesh, ggl::VenueWall::DefaultVbo>="_vertexAndIndexCounts"{vector<std::__1::pair<unsigned short, unsigned int>, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__begin_"^{pair<unsigned short, unsigned int>}"__end_"^{pair<unsigned short, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<unsigned short, unsigned int> *, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__value_"^{pair<unsigned short, unsigned int>}}}"_meshes"{vector<std::__1::shared_ptr<ggl::VenueWall::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >="__begin_"^{shared_ptr<ggl::VenueWall::MeshMesh>}"__end_"^{shared_ptr<ggl::VenueWall::MeshMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >="__value_"^{shared_ptr<ggl::VenueWall::MeshMesh>}}}"_vertexDataWrite"{DataWrite<ggl::VenueWall::DefaultVbo>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_indexDataWrite"{DataWrite<unsigned short>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_meshIndex"C"_meshVertexOffset"S"_meshIndexOffset"I})}
{optional<md::MeshSet<ggl::VenueWall::EndCapMesh, ggl::VenueWall::EndCapVbo> >="_hasValue"B"_value"(ValueUnion="data"[152C]"type"{MeshSet<ggl::VenueWall::EndCapMesh, ggl::VenueWall::EndCapVbo>="_vertexAndIndexCounts"{vector<std::__1::pair<unsigned short, unsigned int>, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__begin_"^{pair<unsigned short, unsigned int>}"__end_"^{pair<unsigned short, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<unsigned short, unsigned int> *, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__value_"^{pair<unsigned short, unsigned int>}}}"_meshes"{vector<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >="__begin_"^{shared_ptr<ggl::VenueWall::EndCapMesh>}"__end_"^{shared_ptr<ggl::VenueWall::EndCapMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >="__value_"^{shared_ptr<ggl::VenueWall::EndCapMesh>}}}"_vertexDataWrite"{DataWrite<ggl::VenueWall::EndCapVbo>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_indexDataWrite"{DataWrite<unsigned short>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_meshIndex"C"_meshVertexOffset"S"_meshIndexOffset"I})}
{optional<md::MeshSet<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh, ggl::Venue3DStroke::HorizontalDefaultVbo> >="_hasValue"B"_value"(ValueUnion="data"[152C]"type"{MeshSet<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh, ggl::Venue3DStroke::HorizontalDefaultVbo>="_vertexAndIndexCounts"{vector<std::__1::pair<unsigned short, unsigned int>, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__begin_"^{pair<unsigned short, unsigned int>}"__end_"^{pair<unsigned short, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<unsigned short, unsigned int> *, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__value_"^{pair<unsigned short, unsigned int>}}}"_meshes"{vector<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >="__begin_"^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}"__end_"^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >="__value_"^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}}}"_vertexDataWrite"{DataWrite<ggl::Venue3DStroke::HorizontalDefaultVbo>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_indexDataWrite"{DataWrite<unsigned short>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_meshIndex"C"_meshVertexOffset"S"_meshIndexOffset"I})}
{optional<md::MeshSet<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh, ggl::Venue3DStroke::VerticalDefaultVbo> >="_hasValue"B"_value"(ValueUnion="data"[152C]"type"{MeshSet<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh, ggl::Venue3DStroke::VerticalDefaultVbo>="_vertexAndIndexCounts"{vector<std::__1::pair<unsigned short, unsigned int>, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__begin_"^{pair<unsigned short, unsigned int>}"__end_"^{pair<unsigned short, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<unsigned short, unsigned int> *, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__value_"^{pair<unsigned short, unsigned int>}}}"_meshes"{vector<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >="__begin_"^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}"__end_"^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >="__value_"^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}}}"_vertexDataWrite"{DataWrite<ggl::Venue3DStroke::VerticalDefaultVbo>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_indexDataWrite"{DataWrite<unsigned short>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_meshIndex"C"_meshVertexOffset"S"_meshIndexOffset"I})}
{vector<std::__1::shared_ptr<ggl::VenueWall::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >="__begin_"^{shared_ptr<ggl::VenueWall::MeshMesh>}"__end_"^{shared_ptr<ggl::VenueWall::MeshMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::MeshMesh> > >="__value_"^{shared_ptr<ggl::VenueWall::MeshMesh>}}}
{vector<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >="__begin_"^{shared_ptr<ggl::VenueWall::EndCapMesh>}"__end_"^{shared_ptr<ggl::VenueWall::EndCapMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::VenueWall::EndCapMesh> > >="__value_"^{shared_ptr<ggl::VenueWall::EndCapMesh>}}}
{vector<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >="__begin_"^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}"__end_"^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh> > >="__value_"^{shared_ptr<ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh>}}}
{vector<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >="__begin_"^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}"__end_"^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh> > >="__value_"^{shared_ptr<ggl::Venue3DStroke::VerticalVenue3DStrokeMesh>}}}
{shared_ptr<ggl::Texture2D>="__ptr_"^{Texture2D}"__cntrl_"^{__shared_weak_count}}
{Matrix<int, 2, 1>=[2i]}16@0:8
^{Anchor=i{Coordinate2D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}{Geocentric<double>=[3d]}d{MercatorTile=Cii}^{AnchorManager}B}
v40@0:8@16Q24Q32
@24@0:8r^{MuninJunction=^^?^{?}{Mercator2<double>=[2d]}{Matrix<float, 2, 1>=[2f]}{vector<const md::MuninRoadEdge *, std::__1::allocator<const md::MuninRoadEdge *> >=^^{MuninRoadEdge}^^{MuninRoadEdge}{__compressed_pair<const md::MuninRoadEdge **, std::__1::allocator<const md::MuninRoadEdge *> >=^^{MuninRoadEdge}}}iCC}16
@"VKCustomFeature"16@0:8
@64@0:8^{ClusterTreeClusterNode=^^?{Range<float>=ff}{Mercator2<double>=[2d]}^{ClusterTreeClusterNode}IICB{_retain_ptr<id<VKCustomFeatureAnnotation>, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}[2^{ClusterTreeNode}]^{ClusterTreeFeatureNode}dIBB}16r^{shared_ptr<md::LabelClusterTree>=^{LabelClusterTree}^{__shared_weak_count}}24@32@40@48@56
@"VKCustomFeature"
v24@0:8@"GEOExperimentConfiguration"16
{function<void (GEOResourceManifestManager *)>={__value_func<void (GEOResourceManifestManager *)>={type=[32C]}^{__base<void (GEOResourceManifestManager *)>}}}16@0:8
v64@0:8{function<void (GEOResourceManifestManager *)>={__value_func<void (GEOResourceManifestManager *)>={type=[32C]}^{__base<void (GEOResourceManifestManager *)>}}}16
{function<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>={__value_func<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>={type=[32C]}^{__base<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>}}}16@0:8
v64@0:8{function<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>={__value_func<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>={type=[32C]}^{__base<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>}}}16
{function<void (GEOExperimentConfiguration *)>={__value_func<void (GEOExperimentConfiguration *)>={type=[32C]}^{__base<void (GEOExperimentConfiguration *)>}}}16@0:8
v64@0:8{function<void (GEOExperimentConfiguration *)>={__value_func<void (GEOExperimentConfiguration *)>={type=[32C]}^{__base<void (GEOExperimentConfiguration *)>}}}16
{function<void (GEOResourceManifestManager *)>="__f_"{__value_func<void (GEOResourceManifestManager *)>="__buf_"{type="__lx"[32C]}"__f_"^{__base<void (GEOResourceManifestManager *)>}}}
{function<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>="__f_"{__value_func<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>="__buf_"{type="__lx"[32C]}"__f_"^{__base<void (GEOResourceManifestManager *, GEOActiveTileGroup *, GEOActiveTileGroup *)>}}}
{function<void (GEOExperimentConfiguration *)>="__f_"{__value_func<void (GEOExperimentConfiguration *)>="__buf_"{type="__lx"[32C]}"__f_"^{__base<void (GEOExperimentConfiguration *)>}}}
^i16@0:8
i24@0:8Q16
v32@0:8^i16Q24
{?="list"^i"count"Q"size"Q}
^{RunLoopController=^{MapEngine}qq}16@0:8
v32@0:8@"VKPuckAnimator"16@"VKAnimation"24
v40@0:8@"VKPuckAnimator"16r^{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}24r^{Unit<RadianUnitDescription, double>=d}32
v24@0:8@"VKPuckAnimator"16
v32@0:8@"VKPuckAnimator"16r^{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}24
v52@0:8B16{?=dd}20d36@?44
v52@0:8B16{?=dd}20d36@?<v@?B>44
@"VKScreenCanvas<VKInteractiveMap>"16@0:8
v24@0:8@"VKScreenCanvas<VKInteractiveMap>"16
@"VKSceneConfiguration"16@0:8
v24@0:8@"VKSceneConfiguration"16
v24@0:8@"VKNavContext"16
@72@0:8{shared_ptr<md::TaskContext>=^{TaskContext}^{__shared_weak_count}}16^{Device=i{shared_ptr<ggl::Device>=^{Device}^{__shared_weak_count}}{unique_ptr<md::SharedDeviceResources, std::__1::default_delete<md::SharedDeviceResources> >={__compressed_pair<md::SharedDeviceResources *, std::__1::default_delete<md::SharedDeviceResources> >=^{SharedDeviceResources}}}}32^{MapDataAccess=^{World}C@^{CameraAccessInternal}{unique_ptr<md::CameraAccessCartographic, std::__1::default_delete<md::CameraAccessCartographic> >={__compressed_pair<md::CameraAccessCartographic *, std::__1::default_delete<md::CameraAccessCartographic> >=^{CameraAccessCartographic}}}{unique_ptr<md::CameraAccessGlobe, std::__1::default_delete<md::CameraAccessGlobe> >={__compressed_pair<md::CameraAccessGlobe *, std::__1::default_delete<md::CameraAccessGlobe> >=^{CameraAccessGlobe}}}{unique_ptr<md::CameraAccessMunin, std::__1::default_delete<md::CameraAccessMunin> >={__compressed_pair<md::CameraAccessMunin *, std::__1::default_delete<md::CameraAccessMunin> >=^{CameraAccessMunin}}}}40^{AnimationRunner=^{MapEngine}}48^{RunLoopController=^{MapEngine}qq}56@64
v32@0:8r^{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}16r^{Unit<RadianUnitDescription, double>=d}24
@24@0:8B16B20
{Matrix<double, 2, 1>=[2d]}16@0:8
v36@0:8f16r^{CameraFrame<geo::Radians, double>={Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}{Unit<MeterUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}}20@?28
{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}32@0:8{VKEdgeInsets=ffff}16
d24@0:8Q16
{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}32@0:8d16Q24
{Coordinate3D<Radians, double>={Unit<RadianUnitDescription, double>=d}{Unit<RadianUnitDescription, double>=d}{Unit<MeterUnitDescription, double>=d}}24@0:8d16
v24@0:8^{vector<geo::Coordinate3D<Radians, double>, std::__1::allocator<geo::Coordinate3D<Radians, double> > >=^{Coordinate3D<Radians, double>}^{Coordinate3D<Radians, double>}{__compressed_pair<geo::Coordinate3D<Radians, double> *, std::__1::allocator<geo::Coordinate3D<Radians, double> > >=^{Coordinate3D<Radians, double>}}}16
{Spring<double, 1, mdc::SpringType::Linear>="_position"d"_velocity"d"_restingPosition"d"_kSpring"d"_kDamper"d}
{Spring<double, 2, mdc::SpringType::Linear>="_position"{Matrix<double, 2, 1>="_e"[2d]}"_velocity"{Matrix<double, 2, 1>="_e"[2d]}"_restingPosition"{Matrix<double, 2, 1>="_e"[2d]}"_kSpring"d"_kDamper"d}
{Unit<MeterUnitDescription, double>="_value"d}
@"VKGestureCameraBehavior<VKNavGestureCameraBehavior>"
@"VKAttachedNavGestureCameraBehavior"
@"VKDetachedNavGestureCameraBehavior"
{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >="__r_"{__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}
{vector<geo::Coordinate3D<Radians, double>, std::__1::allocator<geo::Coordinate3D<Radians, double> > >="__begin_"^{Coordinate3D<Radians, double>}"__end_"^{Coordinate3D<Radians, double>}"__end_cap_"{__compressed_pair<geo::Coordinate3D<Radians, double> *, std::__1::allocator<geo::Coordinate3D<Radians, double> > >="__value_"^{Coordinate3D<Radians, double>}}}
@"VKScreenCanvas<VKInteractiveMap>"
@"VKSceneConfiguration"
@"<VKTrackableAnnotationPresentation>"24@0:8@"<VKTrackableAnnotation>"16
@32@0:8{shared_ptr<md::StylesheetVendor>=^{StylesheetVendor}^{__shared_weak_count}}16
{weak_ptr<md::StylesheetVendor>="__ptr_"^{StylesheetVendor}"__cntrl_"^{__shared_weak_count}}
{?="shieldType"b1}
@40@0:8r*16r*24I32{Color<unsigned char, 4, geo::ColorSpace::Linear>={Matrix<unsigned char, 4, 1>=[4C]}}36
@44@0:8r*16r*24r*32{Color<unsigned char, 4, geo::ColorSpace::Linear>={Matrix<unsigned char, 4, 1>=[4C]}}40
@24@0:8I16I20
@24@0:8r*16
@24@0:8r^{shared_ptr<md::LabelImageKey>=^{LabelImageKey}^{__shared_weak_count}}16
{Color<unsigned char, 4, geo::ColorSpace::Linear>="_backing"{Matrix<unsigned char, 4, 1>="_e"[4C]}}
B32@0:8{?=dd}16
{?=dd}32@0:8{?=dd}16
{Matrix<double, 2, 1>=[2d]}32@0:8{Matrix<double, 2, 1>=[2d]}16
{Matrix<double, 2, 1>=[2d]}144@0:8{Matrix<double, 2, 1>=[2d]}16{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}32{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}64{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}96{Range<double>=dd}128
{Matrix<double, 2, 1>=[2d]}48@0:8{Matrix<double, 2, 1>=[2d]}16{Matrix<double, 2, 1>=[2d]}32
v40@0:8^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}16^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}24^{Box<double, 2>={Matrix<double, 2, 1>=[2d]}{Matrix<double, 2, 1>=[2d]}}32
I24@0:8r^{_GEOTileKey=b7b1(?={_GEOStandardTileKey=b40b6b26b26b14b4b4}{_GEORegionalResourceKey=b32b8b6b8b8}{_GEOSputnikMetadataKey=b32b24b14b8}{_GEOFlyoverKey=b6b26b26b8b24b14b8b8}{_GEOTransitLineSelectionKey=b6b25b25b64}{_GEOTileOverlayKey=b6b26b26b8b32}{_GEOIdentifiedResourceKey=ICC}{_GEOMuninMeshKey=b64b32b16b5b3})}16
{unique_ptr<md::GlobeAdapter, std::__1::default_delete<md::GlobeAdapter> >="__ptr_"{__compressed_pair<md::GlobeAdapter *, std::__1::default_delete<md::GlobeAdapter> >="__value_"^{GlobeAdapter}}}
v24@0:8r^{PolylineCoordinate=If}16
v40@0:8{Matrix<double, 3, 1>=[3d]}16
@"GEOLatLng"
@24@0:8@"VKNavCameraController"16
v40@0:8d16d24@?32
^{?=IfIIi{?=b1b1b1b1b1}}16@0:8
v40@0:8{?=IfIIi{?=b1b1b1b1b1}}16
{?=IfIIi{?=b1b1b1b1b1}}24@0:8Q16
v32@0:8^{?=IfIIi{?=b1b1b1b1b1}}16Q24
^{?=IfIIi{?=b1b1b1b1b1}}
{?="fontSize"b1"leftCapWidth"b1"leftPadding"b1"lineSpacing"b1"numberOfLines"b1"rightCapWidth"b1"rightPadding"b1"textBaseline"b1}
@40@0:8{?=dd}16@?32
B36@0:8@16B24@?28
B44@0:8@16d24B32@?36
v28@0:8@"VKVectorOverlayData"16B24
v40@0:8r^{?={?=dd}{?=dd}}16q24Q32
B24@0:8r^{?=IIII}16
v32@0:8r^{?=IIII}16^{CGContext=}24
{weak_ptr<md::GlobeOverlayContainer>=^{GlobeOverlayContainer}^{__shared_weak_count}}16@0:8
v32@0:8{weak_ptr<md::GlobeOverlayContainer>=^{GlobeOverlayContainer}^{__shared_weak_count}}16
{weak_ptr<md::OverlayContainer>=^{OverlayContainer}^{__shared_weak_count}}16@0:8
v32@0:8{weak_ptr<md::OverlayContainer>=^{OverlayContainer}^{__shared_weak_count}}16
v48@0:8{?={?=dd}{?=dd}}16
v24@0:8^{RunLoopController=^{MapEngine}qq}16
@"<VKOverlayDelegate>"
{weak_ptr<md::GlobeOverlayContainer>="__ptr_"^{GlobeOverlayContainer}"__cntrl_"^{__shared_weak_count}}
{weak_ptr<md::OverlayContainer>="__ptr_"^{OverlayContainer}"__cntrl_"^{__shared_weak_count}}
@"VKVectorOverlayData"
{shared_ptr<ggl::Texture2D>=^{Texture2D}^{__shared_weak_count}}32@0:8r^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}16^{shared_ptr<md::TextureManager>=^{TextureManager}^{__shared_weak_count}}24
{FeatureAttributeSet={vector<gss::FeatureAttributePair, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >=^{FeatureAttributePair}^{FeatureAttributePair}{__compressed_pair<gss::FeatureAttributePair *, geo::StdAllocator<gss::FeatureAttributePair, gss::Allocator> >=^{FeatureAttributePair}{StdAllocator<gss::FeatureAttributePair, gss::Allocator>=^{Allocator}}}}}16@0:8
v28@0:8f16^{shared_ptr<md::TextureManager>=^{TextureManager}^{__shared_weak_count}}20
^{vector<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >=^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}{__compressed_pair<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >=^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}}}16@0:8
I40@0:8^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}{?=ff}BBCQQ{?=ff}Q}16Q24^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}32
v28@0:8^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}{?=ff}BBCQQ{?=ff}Q}16B24
v32@0:8^{Matrix<float, 2, 1>=[2f]}16Q24
v24@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16
v44@0:8^{?={?={?=@*QQQQIQBQfQ@i}QQiiiQQ(?={?={?=ff}{?=ff}}{?=ffff})^{?}{?=[2S][2S]}CBCBBCBS{_NSRange=QQ}BI}{?=ff}BBCQQ{?=ff}Q}16B24^{ResourceAccessor=^^?}28^{Triangulator<float>={Triangulator<float, unsigned short>={NodePool={stack<geo::Triangulator<float, unsigned short>::Node *, std::__1::vector<geo::Triangulator<float, unsigned short>::Node *, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> > >={vector<geo::Triangulator<float, unsigned short>::Node *, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> >=^^{Node}^^{Node}{__compressed_pair<geo::Triangulator<float, unsigned short>::Node **, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> >=^^{Node}}}}}{GeometricHasher={AABB=[2f][2f]}f}Qi}{vector<unsigned short, std::__1::allocator<unsigned short> >=^S^S{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >=^S}}}36
B52@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16C24I28I32^{ResourceAccessor=^^?}36^{Triangulator<float>={Triangulator<float, unsigned short>={NodePool={stack<geo::Triangulator<float, unsigned short>::Node *, std::__1::vector<geo::Triangulator<float, unsigned short>::Node *, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> > >={vector<geo::Triangulator<float, unsigned short>::Node *, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> >=^^{Node}^^{Node}{__compressed_pair<geo::Triangulator<float, unsigned short>::Node **, std::__1::allocator<geo::Triangulator<float, unsigned short>::Node *> >=^^{Node}}}}}{GeometricHasher={AABB=[2f][2f]}f}Qi}{vector<unsigned short, std::__1::allocator<unsigned short> >=^S^S{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >=^S}}}44
C32@0:8@16r^{?=Ii}24
C40@0:8r^{PolygonSection=^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^{Matrix<float, 2, 1>}^BQQQ{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}f}16@24r^{vector<std::__1::pair<bool, GEOFeatureStylePair>, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}^{pair<bool, GEOFeatureStylePair>}{__compressed_pair<std::__1::pair<bool, GEOFeatureStylePair> *, std::__1::allocator<std::__1::pair<bool, GEOFeatureStylePair> > >=^{pair<bool, GEOFeatureStylePair>}}}32
v28@0:8C16^{shared_ptr<md::TextureManager>=^{TextureManager}^{__shared_weak_count}}20
{optional<md::MeshSet<ggl::PolygonCommonStroke::MeshMesh, ggl::PolygonCommonStroke::DefaultVbo> >="_hasValue"B"_value"(ValueUnion="data"[152C]"type"{MeshSet<ggl::PolygonCommonStroke::MeshMesh, ggl::PolygonCommonStroke::DefaultVbo>="_vertexAndIndexCounts"{vector<std::__1::pair<unsigned short, unsigned int>, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__begin_"^{pair<unsigned short, unsigned int>}"__end_"^{pair<unsigned short, unsigned int>}"__end_cap_"{__compressed_pair<std::__1::pair<unsigned short, unsigned int> *, std::__1::allocator<std::__1::pair<unsigned short, unsigned int> > >="__value_"^{pair<unsigned short, unsigned int>}}}"_meshes"{vector<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >="__begin_"^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}"__end_"^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >="__value_"^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}}}"_vertexDataWrite"{DataWrite<ggl::PolygonCommonStroke::DefaultVbo>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_indexDataWrite"{DataWrite<unsigned short>="_memory"{BufferMemory="_accessor"^{ResourceAccessor}"_user"^{BufferData}"_range"{Range<unsigned long>="_min"Q"_max"Q}"_access"i"_sync"i"_data"*}}"_meshIndex"C"_meshVertexOffset"S"_meshIndexOffset"I})}
{vector<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh>, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >="__begin_"^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}"__end_"^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}"__end_cap_"{__compressed_pair<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> *, std::__1::allocator<std::__1::shared_ptr<ggl::PolygonCommonStroke::MeshMesh> > >="__value_"^{shared_ptr<ggl::PolygonCommonStroke::MeshMesh>}}}
d40@0:8{Matrix<double, 3, 1>=[3d]}16
@64@0:8@16r^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}24{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}32C48^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}52B60
{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}40@0:8r^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16B24B28C32C36
C20@0:8C16
@32@0:8@16{PolylineCoordinate=If}24
v48@0:8r^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16C24@28B36^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}40
{Box<float, 2>={Matrix<float, 2, 1>=[2f]}{Matrix<float, 2, 1>=[2f]}}52@0:8C16r^{shared_ptr<gss::StylesheetQuery<gss::PropertyID> >=^{StylesheetQuery<gss::PropertyID>}^{__shared_weak_count}}20r^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}28{Matrix<float, 2, 1>=[2f]}36^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}44
{_retain_ptr<VKLabelNavRoadLabel *, geo::_retain_objc, geo::_release_objc, geo::_hash_objc, geo::_equal_objc>=^^?@{_retain_objc=}{_release_objc=}}32@0:8r^{NavContext=^^?^{LabelManager}^{MapNavLabeler}^{LabelLayoutContext}^{LabelNavLayoutContext}}16^{VKLabelNavArtworkCache={unique_ptr<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, VKRoadSignArtwork *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}{unique_ptr<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >={__compressed_pair<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > *, std::__1::default_delete<geo::LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> > > >=^{LRUCache<unsigned long, CGImage *, std::__1::hash<unsigned long> >}}}^{CGColor}^{CGColor}{VKGuidanceManeuverArrowMetrics={CGSize=dd}ddd{CGSize=dd}dddCddddddddddddddddBdddBB}}24
@28@0:8r^{VenueBuilding={vector<md::VenueLevel, std::__1::allocator<md::VenueLevel> >=^{VenueLevel}^{VenueLevel}{__compressed_pair<md::VenueLevel *, std::__1::allocator<md::VenueLevel> >=^{VenueLevel}}}QQQQs{Matrix<double, 2, 1>=[2d]}{ConvexHull2<double>={vector<gm::Matrix<double, 2, 1>, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}^{Matrix<double, 2, 1>}{__compressed_pair<gm::Matrix<double, 2, 1> *, std::__1::allocator<gm::Matrix<double, 2, 1> > >=^{Matrix<double, 2, 1>}}}}}16B24
r^{shared_ptr<md::VenueBuildingFeatureMarker>=^{VenueBuildingFeatureMarker}^{__shared_weak_count}}16@0:8
@"<GGLLayerDelegate>"16@0:8
v24@0:8@"<GGLLayerDelegate>"16
@32@0:8{shared_ptr<ggl::OESDevice>=^{OESDevice}^{__shared_weak_count}}16
@"<GGLLayerDelegate>"
{shared_ptr<ggl::OESDevice>="__ptr_"^{OESDevice}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<ggl::OESContext, std::__1::default_delete<ggl::OESContext> >="__ptr_"{__compressed_pair<ggl::OESContext *, std::__1::default_delete<ggl::OESContext> >="__value_"^{OESContext}}}
@32@0:8{weak_ptr<ggl::RunLoop::_RunLoopCallbacker>=^{_RunLoopCallbacker}^{__shared_weak_count}}16
{weak_ptr<ggl::RunLoop::_RunLoopCallbacker>="__ptr_"^{_RunLoopCallbacker}"__cntrl_"^{__shared_weak_count}}
@36@0:8{shared_ptr<ggl::MetalDevice>=^{MetalDevice}^{__shared_weak_count}}16B32
v32@0:8d16d24
{shared_ptr<ggl::MetalDevice>="__ptr_"^{MetalDevice}"__cntrl_"^{__shared_weak_count}}
 6"@
 I0%
0C0n
0E0o
 G0&
