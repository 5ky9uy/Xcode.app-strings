UUUUUU
V?UUUUUU
\@333333
UUUUUU
=fff?
@UUUUUU
?UUUUUU
v?UUUUUU
UUUUUU
?UUUUUU
?UUUUUU
.ppm
.pgm
< %-8s > 
Verbose
Info
Warning
Error
Fatal
-- %s
^(.+) \(([0-9]+)\)$
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarAdditionFunction, double, double, double>, double, double, double>]
Scalar(
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarAdditionFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarNegationFunction, double, double>, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarNegationFunction, double, double>, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSubtractionFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSubtractionFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarMultiplicationFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarMultiplicationFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarDivisionFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarDivisionFunction, double, double, double>, double, double, double>]
'sin'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSineFunction, double, double>, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSineFunction, double, double>, double, double>]
'cos'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarCosineFunction, double, double>, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarCosineFunction, double, double>, double, double>]
'tan'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarTangentFunction, double, double>, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarTangentFunction, double, double>, double, double>]
'atan2'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarArcTangentFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarArcTangentFunction, double, double, double>, double, double, double>]
'softMin'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSoftMinimumFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSoftMinimumFunction, double, double, double>, double, double, double>]
'softMax'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSoftMaximumFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSoftMaximumFunction, double, double, double>, double, double, double>]
'sqrt'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSquareRootFunction, double, double>, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarSquareRootFunction, double, double>, double, double>]
'pow'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarPowerFunction, double, double>, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarPowerFunction, double, double>, double, double>]
'modDiff'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarModuloDifferenceFunction, double, double, double>, double, double, double>]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::ScalarModuloDifferenceFunction, double, double, double>, double, double, double>]
error: roundoff will occur
Matrix
Factored->symbolicFactorization
%s does not match that used for symbolic factorization stored in %s.
symbolicFactor
Failed to allocate factor storage of size %ld bytes.
Failed to allocate workspace of size %ld bytes.
%s does not hold a completed matrix factorization.
Factored
%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).
{offset: 
, size
max_parameter_dimension: 
max_residual_dimension: 
num_jacobian_blocks: 
num_jacobian_nonzeros: 
max_workspace_elements: 
{regularized: 
{function: 
, gradient: [
Ariadne custom signpost plist:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
  <dict>
    <key>Name</key>
    <string>AppleCVA</string>
    <key>Children</key>
    <array>
    </array>
  </dict>
</array>
</plist>
      <dict>
        <key>Name</key>
        <string>
</string>
        <key>Type</key>
        <string>Interval</string>
        <key>Component</key>
        <key>CodeBegin</key>
        <key>CodeEnd</key>
      </dict>
Command 
 is required!
Not enough arguments for command 
Too many arguments for command 
Unexpected switch: 
 while parsing token 
Unexpected argument 
 while parsing command 
Could not parse commandline:
BRIEF:
SYNOPSIS:
DESCRIPTION:
OPTIONS:
 [ --
leastsquares::ComputationalExpression<
'compose'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationCompositionFunction, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >]
{storage: 
, traces: [
{tag: 
UNDEFINED
CONSTANT
VARIABLE, key: 
COMPUTATIONAL, record: 
null
{value: 
Rotation3(
, jacobians: [
   ]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationCompositionFunction, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >]
VARIABLE
leastsquares::ConstantExpression<
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ConstantExpressionNode<true, cva::Rotation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ConstantExpressionNode<false, cva::Rotation3<double> >]
'inverseCompose'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationInverseCompositionFunction, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationInverseCompositionFunction, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >, cva::Rotation3<double>, cva::Rotation3<double>, cva::Rotation3<double> >]
'inverse'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationInverseFunction, cva::Rotation3<double>, cva::Rotation3<double> >, cva::Rotation3<double>, cva::Rotation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationInverseFunction, cva::Rotation3<double>, cva::Rotation3<double> >, cva::Rotation3<double>, cva::Rotation3<double> >]
'rotate'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
Vector(
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ConstantExpressionNode<true, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ConstantExpressionNode<false, cva::Matrix<double, 3, 1, false> >]
'inverseRotate'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::InverseRotationFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::InverseRotationFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
'log'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationLogarithmFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationLogarithmFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double> >]
'exp'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationExponentialFunction, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::RotationExponentialFunction, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationCompositionFunction, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >]
Transformation3(
, Translation(
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationCompositionFunction, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ConstantExpressionNode<true, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ConstantExpressionNode<false, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationInverseCompositionFunction, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationInverseCompositionFunction, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >, cva::Transformation3<double>, cva::Transformation3<double>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationInverseFunction, cva::Transformation3<double>, cva::Transformation3<double> >, cva::Transformation3<double>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationInverseFunction, cva::Transformation3<double>, cva::Transformation3<double> >, cva::Transformation3<double>, cva::Transformation3<double> >]
'transform'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationFunction, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationFunction, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >]
'inverseTransform'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::InverseTransformationFunction, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::InverseTransformationFunction, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationLogarithmFunction, cva::Matrix<double, 6, 1, false>, cva::Transformation3<double> >, cva::Matrix<double, 6, 1, false>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationLogarithmFunction, cva::Matrix<double, 6, 1, false>, cva::Transformation3<double> >, cva::Matrix<double, 6, 1, false>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationExponentialFunction, cva::Transformation3<double>, cva::Matrix<double, 6, 1, false> >, cva::Transformation3<double>, cva::Matrix<double, 6, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationExponentialFunction, cva::Transformation3<double>, cva::Matrix<double, 6, 1, false> >, cva::Transformation3<double>, cva::Matrix<double, 6, 1, false> >]
'getRotation'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationRotationalComponentFunction, cva::Rotation3<double>, cva::Transformation3<double> >, cva::Rotation3<double>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationRotationalComponentFunction, cva::Rotation3<double>, cva::Transformation3<double> >, cva::Rotation3<double>, cva::Transformation3<double> >]
'getTranslation'
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationTranslationalComponentFunction, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double> >, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformationTranslationalComponentFunction, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double> >, cva::Matrix<double, 3, 1, false>, cva::Transformation3<double> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformLinearVelocityFunction, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformLinearVelocityFunction, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<true, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformLinearVelocityFrameFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
const char *cva::TypeNameDetail::prettyFunName() [T = leastsquares::internal::ComputationalExpressionNode<false, leastsquares::internal::FunctionalOperator<leastsquares::internal::TransformLinearVelocityFrameFunction, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >, cva::Matrix<double, 3, 1, false>, cva::Rotation3<double>, cva::Matrix<double, 3, 1, false> >]
CGImageSourceCreateWithURL() failed!
CGImageSourceCreateImageAtIndex() failed!
%d %d
%d %d
65535
{factorization: 
TMPDIR
/tmp
TEMP
TEMPDIR
%04x-%04x-%04x-%04x
SparseMatrix(offsets: {
}, rows: {
}, values: {
, ...
%s (%d)
< %-8s > %s
.structure.columnCount must be greater than 0.
Requested symmetric factorization of unsymmetric matrix.
Matrix purports to be symmetric, but rowCount != columnCount.
%s does not match that used for symbolic factorization stored in %s.
Bad symbolic factor.
Failed to allocate factor storage of size %ld bytes.
Failed to allocate workspace of size %ld bytes.
Factored does not hold a completed matrix factorization.
%s does not hold a completed matrix factorization.
%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).
initWithCapacity:
addObject:
objectForKey:
setValue:forKey:
removeObjectForKey:
initWithUTF8String:
initWithFileAtPath:
open
streamError
JSONObjectWithStream:options:error:
keyEnumerator
close
mutableCopy
writeToFile:atomically:
initWithContentsOfFile:
isValidJSONObject:
count
objectAtIndex:
replaceObjectAtIndex:withObject:
intValue
unsignedIntValue
nextObject
longLongValue
unsignedLongLongValue
floatValue
doubleValue
boolValue
initWithInt:
initWithUnsignedInt:
initWithLongLong:
initWithUnsignedLongLong:
UTF8String
initWithFloat:
initWithDouble:
initWithBool:
initToMemory
writeJSONObject:toStream:options:error:
initToFileAtPath:append:
propertyForKey:
writeToFile:options:error:
valueForKey:
defaultCStringEncoding
stringWithCString:encoding:
unsignedIntegerValue
integerValue
length
bytes
