-[MTLDebugIndirectComputeCommand setComputePipelineState:]
Setting the pipeline state of indirect command buffers created with inheritPipelineState = YES is invalid
Setting a pipeline that does not have supportIndirectCommandBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand setKernelBuffer:offset:atIndex:]
index(%lu) must be < %lu.
Setting buffers on a indirect command buffer created with inheritBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand concurrentDispatchThreadgroups:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatch is not enabled on this indirect command buffer
-[MTLDebugIndirectComputeCommand concurrentDispatchThreads:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatchThreads is not enabled on this indirect command buffer
index
TQ,R
indirectCommandBuffer
T@"<MTLIndirectCommandBuffer>",R
hash
superclass
T#,R
description
T@"NSString",R,C
debugDescription
label
T@"NSString",C
device
T@"<MTLDevice>",R
cpuCacheMode
storageMode
hazardTrackingMode
resourceOptions
heap
T@"<MTLHeap>",R
heapOffset
allocatedSize
size
uniqueIdentifier
resourceIndex
TQ,N
indirectComputeCommand
T@"MTLToolsPointerArray",R,N,V_indirectComputeCommand
indirectRenderCommand
T@"MTLToolsPointerArray",R,N,V_indirectRenderCommand
TQ,D,N
%@%@
label =
<none>
length
textures
T@"MTLToolsPointerArray",R,N,V_textures
ToolsCommandBuffer
v16@?0@"<MTLCommandBuffer>"8
commandQueue
T@"<MTLCommandQueue>",R
retainedReferences
TB,R
kernelStartTime
Td,R
kernelEndTime
GPUStartTime
GPUEndTime
status
error
T@"NSError",R
listIndex
TQ,N,GgetListIndex
profilingEnabled
TB,GisProfilingEnabled
profilingResults
T@"NSDictionary",R
userDictionary
T@"NSMutableDictionary",R,N
globalTraceObjectID
retainedObjectsLock
T^{ILayerLockingPolicy=^^?},N,V_retainedObjectsLock
retainedObjects
T@"NSMutableSet",R,N,V_retainedObjects
renderCommandEncoders
T@"MTLToolsPointerArray",R,N,V_renderCommandEncoders
computeCommandEncoders
T@"MTLToolsPointerArray",R,N,V_computeCommandEncoders
blitCommandEncoders
T@"MTLToolsPointerArray",R,N,V_blitCommandEncoders
parallelRenderCommandEncoders
T@"MTLToolsPointerArray",R,N,V_parallelRenderCommandEncoders
fragmentRenderCommandEncoders
T@"MTLToolsPointerArray",R,N,V_fragmentRenderCommandEncoders
resourceStateCommandEncoders
T@"MTLToolsPointerArray",R,N,V_resourceStateCommandEncoders
commandBuffer
T@"MTLToolsCommandBuffer",R,N,V_commandBuffer
v32@?0@"<MTLCommandBuffer>"8@"NSData"16Q24
backgroundTrackingPID
maxCommandBufferCount
qosLevel
commitQueue
T@"NSObject<OS_dispatch_queue>",R
commitSynchronously
completionQueue
disableCrossQueueHazardTracking
skipRender
executionEnabled
isOpenGLQueue
StatEnabled
TB,N,GisStatEnabled
StatOptions
TQ,N,GgetStatOptions
StatLocations
TQ,N,GgetStatLocations
commandBuffers
T@"MTLToolsPointerArray",R,N,V_commandBuffers
usedSize
currentAllocatedSize
type
Tq,R
unfilteredResourceOptions
buffers
T@"MTLToolsPointerArray",R,N,V_buffers
dispatchType
T@"NSString",R
maxTotalThreadsPerThreadgroup
threadExecutionWidth
staticThreadgroupMemoryLength
supportIndirectCommandBuffers
debugInstrumentationData
T@"MTLDebugInstrumentationData",R,&,N
readsDepth
writesDepth
readsStencil
writesStencil
v8@?0
com.apple.Metal
GPUDebug
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
v32@?0@"<MTLComputePipelineState>"8@"MTLComputePipelineReflection"16@"NSError"24
%@ -debug-info-kind=line-tables-only
-debug-info-kind=line-tables-only
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
@8@?0
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v24@?0@"<MTLComputePipelineState>"8@"NSError"16
ciKernelMain
v24@?0@"<MTLLibrary>"8@"NSError"16
name
registryID
maxThreadsPerThreadgroup
T{?=QQQ},R
lowPower
TB,R,GisLowPower
headless
TB,R,GisHeadless
removable
TB,R,GisRemovable
hasUnifiedMemory
recommendedMaxWorkingSetSize
depth24Stencil8PixelFormatSupported
TB,R,GisDepth24Stencil8PixelFormatSupported
readWriteTextureSupport
argumentBuffersSupport
rasterOrderGroupsSupported
TB,R,GareRasterOrderGroupsSupported
maxThreadgroupMemoryLength
maxArgumentBufferSamplerCount
programmableSamplePositionsSupported
TB,R,GareProgrammableSamplePositionsSupported
maxBufferLength
supportsQuadReduction
TB,R,N
supportsBufferlessClientStorageTexture
supportsArgumentBuffersTier2
supportsReadWriteTextureArgumentsTier2
supportsProgrammableSamplePositions
supportsBCTextureCompression
supports3DBCTextures
supportsLargeFramebufferConfigs
supportsCustomBorderColor
supportsSamplerAddressModeClampToHalfBorder
supports32bpcMSAATextures
supportsPlacementHeaps
supportsOpenCLTextureWriteSwizzles
supportsLimitedYUVFormats
supportsNonPrivateDepthStencilTextures
supportsNonPrivateMSAATextures
supportsLinearTextureFromSharedBuffer
supportsPipelineLibraries
supportsFragmentOnlyEncoders
supportsBufferWithIOSurface
supportsProgrammableBlending
supportsRenderToLinearTextures
supportsMemorylessRenderTargets
supportsFastMathInfNaNPropagation
supportsInvariantVertexPosition
supportsShaderLODAverage
supportsRelaxedTextureViewRequirements
supportsSeparateDepthStencil
supportsGPUStatistics
supportsASTCTextureCompression
supportsExtendedYUVFormats
supportsPublicXR10Formats
supportsSRGBwrites
supportsDepthClipMode
supportsPacked32TextureBufferWrites
supports3DASTCTextures
supportsExtendedXR10Formats
supportsFragmentBufferWrites
supportsCountingOcclusionQuery
supportsBaseVertexInstanceDrawing
supportsIndirectDrawAndDispatch
supportsTessellation
supportsReadWriteBufferArguments
supportsArrayOfTextures
supportsArrayOfSamplers
supportsCombinedMSAAStoreAndResolveAction
supportsMutableTier1ArgumentBuffers
supportsSamplerCompareFunction
supportsMSAADepthResolve
supportsMSAAStencilResolve
supportsMSAADepthResolveFilter
supportsGFXIndirectCommandBuffers
supportsCMPIndirectCommandBuffers
supportsIndirectStageInRegion
supportsIndirectTextures
supportsNorm16BCubicFiltering
supportsTextureOutOfBoundsReads
supportsTextureSwizzle
supportsAlphaYUVFormats
supportsMemoryOrderAtomics
supportsQuadGroup
supportsRenderTextureWrites
supportsImageBlocks
supportsTileShaders
supportsImageBlockSampleCoverageControl
supportsNativeHardwareFP16
supportsPostDepthCoverage
supportsMipLevelsSmallerThanBlockSize
supportsNonUniformThreadgroupSize
supportsReadWriteTextureArguments
supportsReadWriteTextureCubeArguments
supportsTextureCubeArray
supportsQuadShufflesAndBroadcast
supportsConcurrentComputeDispatch
supportsRenderPassWithoutRenderTarget
supportsRasterOrderGroups
supportsLinearTexture2DArray
supportsNonSquareTileShaders
supportsSeparateVisibilityAndShadingRate
supports2DLinearTexArraySPI
supportsLayeredRendering
supportsViewportAndScissorArray
supportsIndirectTessellation
supportsMSAAStencilResolveFilter
supportsStencilFeedback
supportsFP32TessFactors
supportsSIMDGroup
supportsShaderMinLODClamp
supportsSIMDShufflesAndBroadcast
supportsBlackOrWhiteSamplerBorderColors
supportsMirrorClampToEdgeSamplerMode
supportsSIMDReduction
supportsDepthClipModeClampExtended
supportsTexture2DMultisampleArray
supportsForceSeamsOnCubemaps
supportsFloat16BCubicFiltering
gpuAssertionsEnabled
TB,GareGPUAssertionsEnabled,SsetGPUAssertionsEnabled:
shaderDebugInfoCaching
targetDeviceInfo
Tr^{MTLTargetDeviceArch=II*},R
halfFPConfig
singleFPConfig
doubleFPConfig
metalAssertionsEnabled
TB,N
featureProfile
limits
Tr^{?=IIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ},R
maxColorAttachments
maxVertexAttributes
maxVertexBuffers
maxVertexTextures
maxVertexSamplers
maxVertexInlineDataSize
maxInterpolants
maxFragmentBuffers
maxFragmentTextures
maxFragmentSamplers
maxFragmentInlineDataSize
maxComputeBuffers
maxComputeTextures
maxComputeSamplers
maxComputeInlineDataSize
maxComputeLocalMemorySizes
maxTotalComputeThreadsPerThreadgroup
maxComputeThreadgroupMemory
maxLineWidth
Tf,R
maxPointSize
maxVisibilityQueryOffset
minConstantBufferAlignmentBytes
minBufferNoCopyAlignmentBytes
maxTextureWidth1D
maxTextureWidth2D
maxTextureHeight2D
maxTextureWidth3D
maxTextureHeight3D
maxTextureDepth3D
maxTextureDimensionCube
maxTextureLayers
linearTextureAlignmentBytes
iosurfaceTextureAlignmentBytes
iosurfaceReadOnlyTextureAlignmentBytes
deviceLinearTextureAlignmentBytes
deviceLinearReadOnlyTextureAlignmentBytes
maxFunctionConstantIndices
maxComputeThreadgroupMemoryAlignmentBytes
maxInterpolatedComponents
maxTessellationFactor
maxIndirectBuffers
maxIndirectTextures
maxIndirectSamplers
maxIndirectSamplersPerDevice
maxViewportCount
maxCustomSamplePositions
maxTextureBufferWidth
maxComputeAttributes
maxFramebufferStorageBits
linearTextureArrayAlignmentBytes
linearTextureArrayAlignmentSlice
maxTileBuffers
maxTileTextures
maxTileSamplers
maxTileInlineDataSize
minTilePixels
supportPriorityBand
sharedMemorySize
dedicatedMemorySize
indirectArgumentBufferCapabilities
T{IndirectArgumentBufferCapabilities=b1b1b1b29},R
quadDataSharingSupported
TB,R,GisQuadDataSharingSupported
resourceIndirectionEnabled
TB,N,GisResourceIndirectionEnabled
utilityBufferRequired
TB,R,GisUtilityBufferRequired
utilityBuffers
T@"NSArray",&,N
currentUtilityBufferIndex
placementHeapSupported
TB,R,GisPlacementHeapSupported
integrated
TB,R,GisIntegrated,V_integrated
memorySize
TQ,R,V_memorySize
heaps
T@"MTLToolsPointerArray",R,N,V_heaps
depthStencilStates
T@"MTLToolsPointerArray",R,N,V_depthStencilStates
textureLayouts
T@"MTLToolsPointerArray",R,N,V_textureLayouts
samplers
T@"MTLToolsPointerArray",R,N,V_samplers
commandQueues
T@"MTLToolsPointerArray",R,N,V_commandQueues
libraries
T@"MTLToolsPointerArray",R,N,V_libraries
pipelineStates
T@"MTLToolsPointerArray",R,N,V_pipelineStates
computePipelineStates
T@"MTLToolsPointerArray",R,N,V_computePipelineStates
functions
T@"MTLToolsPointerArray",R,N,V_functions
events
T@"MTLToolsPointerArray",R,N,V_events
pipelineLibraries
T@"MTLToolsPointerArray",R,N,V_pipelineLibraries
fences
T@"MTLToolsPointerArray",R,N,V_fences
indirectArgumentEncoders
T@"MTLToolsPointerArray",R,N,V_indirectArgumentEncoders
argumentEncoders
T@"MTLToolsPointerArray",R,N,V_argumentEncoders
indirectCommandBuffers
T@"MTLToolsPointerArray",R,N,V_indirectCommandBuffers
resourceGroups
T@"MTLToolsPointerArray",R,N,V_resourceGroups
v24@?0@"<MTLSharedEvent>"8Q16
signaledValue
functionType
patchType
patchControlPointCount
vertexAttributes
T@"NSArray",R
stageInputAttributes
functionConstantsDictionary
filePath
lineNumber
unpackedFilePath
renderTargetArrayIndexType
returnType
T@"MTLType",R
arguments
v24@?0@"<MTLFunction>"8@"NSError"16
functionNames
overrideTriple
externFunctionNames
-[MTLDebugPipelineLibrary newComputePipelineStateWithName:options:reflection:error:]
name must not be nil.
descriptor is not a NSString.
-[MTLDebugPipelineLibrary newRenderPipelineStateWithName:options:reflection:error:]
T@"NSString",C,N,V_filePath
vertexFunction
T@"MTLToolsFunction",R,N
fragmentFunction
reflection
T@"MTLRenderPipelineReflection",R,N
v24@?0@8^B16
%@ -> %@
lockingPolicy
T^{ILayerLockingPolicy=^^?},N,V_lockingPolicy
tracker
T@"MTLToolsPointerArray",N,V_tracker
baseObject
T@,&,N,V_baseObject
T@"<MTLDevice>",R,N
tileWidth
tileHeight
flags
TQ,R,N,V_flags
segment
T{_NSRange=QQ},R,N,V_segment
"version":"
0.908
,"handle":"
,"device":{
"handle":"
,"name":"
,"queue":{
,"events":{
,"methods":[
{"selector":"
,"flags":
,"commands":"
,"commandBufferLength":
,"encoders":[
{"flags":
,"segment":{"location":
,"length":
,"statistics":{"flags":
,"counters":[
{"name":"
],"samples":"
,"sampleBufferLength":
cb_%llu.json
Error saving file '%@' (%@)
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
fillBuffer:range:value
fillBuffer:range:pattern4
fillTexture:level:slice:region:data:size
fillTexture:level:slice:region:color
fillTexture:level:slice:region:color:pixelFormat
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount
copyFromTexture:toTexture
generateMipmapsForTexture
synchronizeResource
synchronizeTexture
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset
resetTextureAccessCounters:region:mipLevel:slice
dispatchThreadgroups:threadsPerThreadgroup
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
setBuffer:offset:atIndex
setBufferOffset:atIndex
setBuffers:offsets:withRange
setBytes:length:atIndex
setComputePipelineState
setSamplerState:atIndex
setSamplerState:lodMinClamps:lodMaxClamps:atIndex
setSamplerStates:withRange
setSamplerStates:lodMinClamps:lodMaxClamps:withRange
setStageInRegion
setTexture:atIndex
setTextures:withRange
setThreadgroupMemoryLength:atIndex
memoryBarrierWithScope
memoryBarrierWithResources:count
drawPrimitives:vertexStart:vertexCount
drawPrimitives:vertexStart:vertexCount:instanceCount
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance
drawPrimitives:indirectBuffer:indirectBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset
drawIndexedPatches:patchStart:patchCount:controlPointIndexBuffer:controlPointIndexBufferOffset:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset
setBlendColorRed:green:blue:alpha
setColorStoreAction:atIndex
setCullMode
setDepthBias:slopeScale:clamp
setDepthClipMode
setDepthStencilState
setDepthStoreAction
setFragmentBuffer:offset:atIndex
setFragmentBufferOffset:atIndex
setFragmentBuffers:offsets:withRange
setFragmentBytes:length:atIndex
setFragmentSamplerState:atIndex
setFragmentSamplerState:lodMinClamps:lodMaxClamps:atIndex
setFragmentSamplerStates:withRange
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange
setFragmentTexture:atIndex
setFragmentTextures:withRange
setFrontFaceWinding
setRenderPipelineState
setScissorRect
setScissorRects:count
setStencilFrontReferenceValue:backReferenceValue
setStencilReferenceValue
setStencilStoreAction
setTessellationFactorBuffer:offset:instanceStride
setTessellationFactorScale
setTriangleFillMode
setVertexBuffer:offset:atIndex
setVertexBufferOffset:atIndex
setVertexBuffers:offsets:withRange
setVertexBytes:length:atIndex
setVertexSamplerState:atIndex
setVertexSamplerState:lodMinClamps:lodMaxClamps:atIndex
setVertexSamplerStates:withRange
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange
setVertexTexture:atIndex
setVertexTextures:withRange
setViewport
setViewports:count
setVisibilityResultMode:offset
textureBarrier
memoryBarrierWithScope:afterStages:beforeStages
memoryBarrierWithResources:count:afterStages:beforeStages
insertDebugSignpost
pushDebugGroup
popDebugGroup
setLabel
updateFence
updateFence:afterStages
useHeap
useHeap:stages
useHeaps:count
useHeaps:count:stages
useResource:usage
useResource:usage:stages
useResources:count:usage
useResources:count:usage:stages
waitForFence
waitForFence:beforeStages
updateTextureMapping:mode:regions:mipLevel:slice
updateTextureMappings:mode:regions:mipLevels:numRegions:slices
updateTextureMappings:mode:indirectBuffer:indirectBufferOffset
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles
%llu
threadgroupSizeMatchesTileSize
imageblockSampleLength
vertexDebugInstrumentationData
fragmentDebugInstrumentationData
-[MTLToolsResource validateCPUReadable]
resourceOptions (0x%lx) specify MTLResourceStorageModePrivate, which is not CPU accessible.
resourceOptions (0x%lx) specify MTLStorageModeMemoryless, which is not CPU accessible.
-[MTLToolsResource validateCPUWriteable]
responsibleProcess
sharedAllocationInfo
T@"MTLResourceAllocationInfo",R
cachedAllocationInfo
protectionOptions
options
TQ,R,N,V_options
rootResource
T@"<MTLResource>",R
parentTexture
T@"<MTLTexture>",R
parentRelativeLevel
parentRelativeSlice
buffer
T@"<MTLBuffer>",R
bufferOffset
bufferBytesPerRow
iosurface
T^{__IOSurface=},R
iosurfacePlane
textureType
pixelFormat
width
height
depth
mipmapLevelCount
sampleCount
arrayLength
usage
framebufferOnly
TB,R,GisFramebufferOnly
allowGPUOptimizedContents
swizzle
T{?=CCCC},R,N
rotation
isCompressed
compressionFeedback
swizzleKey
TI,R
numFaces
isDrawable
views
T@"MTLToolsPointerArray",R,N,V_views
T@"<MTLTexture>",R,V_parentTexture
T@"<MTLBuffer>",R,V_buffer
alignment
copyGranularity
watermark
T{?=[2Q]},R
<UNKNOWN>
Vertex
Fragment
Compute
%llX
dispatch
draw
-[MTLDebugBlitCommandEncoder dealloc]
Command encoder released without endEncoding
-[MTLDebugBlitCommandEncoder internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
the combination of MTLBlitOptionDepthFromDepthStencil and MTLBlitOptionStencilFromDepthStencil is invalid.
invalid usage because encoding has ended.
sourceTexture must not be nil.
sourceTexture is not a MTLTexture.
sourceTexture is associated with a different device
sourceTexture is Memoryless and cannot be used for copy operations!
destinationTexture must not be nil.
destinationTexture is not a MTLTexture.
destinationTexture is associated with a different device
destinationTexture is Memoryless and cannot be used for copy operations!
(sourceSize.width(%lu) * sourceSize.height(%lu) * sourceSize.depth(%lu))(%lu) must not be 0.
sourceTexture != nil
destinationTexture != nil
[sourceTexture pixelFormat](%s) and [destinationTexture pixelFormat](%s) are not compatible for depth/stencil blits.
[sourceTexture pixelFormat](%s) must equal [destinationTexture pixelFormat](%s) 
[sourceTexture sampleCount](%lu) must equal [destinationTexture sampleCount](%lu).
sourceTexture must not be a framebufferOnly texture.
destinationTexture must not be a framebufferOnly texture.
sourceLevel(%lu) must be < [sourceTexture mipmapLevelCount](%lu).
sourceSlice(%lu) must be < (%lu).
destinationLevel(%lu) must be < [destinationTexture mipmapLevelCount](%lu).
destinationSlice(%lu) must be < (%lu).
(sourceOrigin.x + adjustedSourceSize.width)(%lu) must be <= paddedWidth(%lu).
(sourceOrigin.y + adjustedSourceSize.height)(%lu) must be <= paddedHeight(%lu).
(sourceOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(sourceOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(sourceOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(sourceOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
(destinationOrigin.x + adjustedDestinationSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedDestinationSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + destinationSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + destinationSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + destinationSize.depth)(%lu) must be <= depth(%lu).
sourceOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
sourceOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
sourceOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
size.width(%lu) must be a multiple of %s blockWidth(%lu).
size.height(%lu) must be a multiple of %s blockHeight(%lu).
size.depth(%lu) must be a multiple of %s blockDepth(%lu).
destinationOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
destinationOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
destinationOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
sourceOrigin.x must be 0 (full image) for %s.
sourceOrigin.y must be 0 (full image) for %s.
sourceOrigin.z must be 0 (full image) for %s.
sourceSize.width(%lu) must equal width(%lu) (full image) for %s.
sourceSize.height(%lu) must equal height(%lu) (full image) for %s.
sourceSize.depth(%lu) must equal depth(%lu) (full image) for %s.
destinationOrigin.x must be 0 (full image) for %s.
destinationOrigin.y must be 0 (full image) for %s.
destinationOrigin.z must be 0 (full image) for %s.
destinationSize.width(%lu) must equal width(%lu) (full image) for %s.
destinationSize.height(%lu) must equal height(%lu) (full image) for %s.
destinationSize.depth(%lu) must equal depth(%lu) (full image) for %s.
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s and destinationTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for destinationTexture with pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
sourceBuffer must not be nil.
sourceBuffer is not a MTLBuffer.
sourceBuffer is associated with a different device
destinationTexture cannot be Memoryless.
(destinationOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
sourceOffset (%lu) must be a multiple of %lu bytes.
%s disallowed unless MTLBlitOptionRowLinearPVRTC option is used.
%s is not allowed to use the MTLBlitOptionRowLinearPVRTC option.
sourceBytesPerRow(%lu) must be >= (%lu).
sourceBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [sourceBuffer length](%lu).
sourceBytesPerRow (%lu) must be a multiple of %lu bytes.
sourceBytesPerImage (%lu) must be a multiple of %lu bytes.
sourceBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
blits between texture with pixel format %s and buffer are not allowed.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
destinationBuffer must not be nil.
destinationBuffer is not a MTLBuffer.
destinationBuffer is associated with a different device
destinationOffset (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be >= (%lu).
destinationBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [destinationBuffer length](%lu).
destinationBytesPerRow (%lu) must be a multiple of %lu bytes.
destinationBytesPerImage (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:]
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
-[MTLDebugBlitCommandEncoder generateMipmapsForTexture:]
tex must not be nil.
tex is not a MTLTexture.
tex is associated with a different device
cannot generate mipmaps of Memoryless texture.
[tex mipmapLevelCount](%lu) must be > 1.
tex != nil
tex(%s) is not colorRenderable.
tex(%s) is not filterable.
-[MTLDebugBlitCommandEncoder fillBuffer:range:value:]
buffer must not be nil.
buffer is not a MTLBuffer.
buffer is associated with a different device
(range.location + range.length)(%lu) must be <= [buffer length](%lu).
range.length(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:]
(sourceOffset + size)(%lu) must be <= [sourceBuffer length](%lu).
(destinationOffset + size)(%lu) must be <= [destinationBuffer length](%lu).
size(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder waitForFence:]
MTLFence cannot be waited on after it has been updated within the same encoder.
-[MTLDebugBlitCommandEncoder endEncoding]
endEncoding without use.
-[MTLDebugBlitCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
firstBatch (%d) must be less than or equal to lastBatch(%d)
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:]
texture must not be nil.
texture is not a MTLTexture.
texture is associated with a different device
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:slice:level:]
level(%lu) must be < [texture mipmapLevelCount](%lu).
slice(%lu) must be < (%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:]
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:slice:level:]
-[MTLDebugBlitCommandEncoder optimizeIndirectCommandBuffer:withRange:]
Overlapping ranges are not allowed
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:]
sliceCount must not be 0.
levelCount must not be 0.
sourceTexture.width(%lu) at mip %lu must match destinationTexture.width(%lu) at mip level %lu.
sourceTexture.height(%lu) at mip %lu must match destinationTexture.height(%lu) at mip level %lu.
sourceTexture.depth(%lu) at mip %lu must match destinationTexture.depth(%lu) at mip level %lu.
sourceLevel(%lu) + levelCount(%lu) must not exceed sourceTexture.mipmapLevelCount(%lu).
destinationLevel(%lu) + levelCount(%lu) must not exceed destinationTexture.mipmapLevelCount(%lu).
sourceSlice(%lu) + sliceCount(%lu) must not exceed sourceTexture.arrayLength(%lu) x sourceTexture.numFaces(%lu).
destinationSlice(%lu) + sliceCount(%lu) must not exceed destinationTexture.arrayLength(%lu) x destinationTexture.numFaces(%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:toTexture:]
validateMTLBlitOption
option is not a valid MTLBlitOption.
texture
validateBlitProtectionOptions
Blit from %@ has protection options %016llx not set in command buffer protection options %016llx
Blit to %@ with protection options %016llx missing bits set in command buffer protection options %016llx
is illegal on a non-placement heap
is defined on a placement heap only when using a blit method copying entire texture surfaces, or when copying between buffers
is defined on a placement heap only when both textures have the same MTLTextureUsage flags
is defined on a placement heap only when both textures are linear and have the same bufferBytesPerRow value
is defined on a placement heap only when both top-level resources have the same layout
is defined on a placement heap when the texture views refer to the same sub-resources with the same texture type
top-level source and top-level destination resource dimensions must be identical when moving resources inside a placement heap
validateResourceAliasing
blitting between aliasing resources %s.
MTLBlitOptionNone
MTLBlitOptionDepthFromDepthStencil
MTLBlitOptionStencilFromDepthStencil
MTLBlitOptionRowLinearPVRTC
T@"NSString",C,N,V_label
range
T{_NSRange=QQ},N,V_range
-[MTLDebugBuffer makeAliasable]
This resource was not allocated on a heap.
-[MTLDebugBuffer newTextureWithDescriptor:offset:bytesPerRow:]
resourceOptions (0x%lx) must match backing buffer resource options (0x%lx).
linear texture depth(%ld) must be 1
linear texture mipmapLevelCount(%ld) must be 1
linear texture sampleCount(%ld) must be 1
linear texture arrayLength(%ld) must be 1
-[MTLDebugBuffer newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:]
2D linear texture array is not supported.
bytesPerImage must be aligned to %u bytes.
-[MTLDebugBuffer setPurgeableState:]
Setting purgeability state directly on heap sub-allocated resources is not allowed.
-[MTLDebugBuffer contents]
Cannot access contents of indirect command buffers
v24@?0@"MTLToolsObject"8^B16
common
T@"MTLDebugResource",R,N,V_common
pointer
Tr^v,R,N,V_pointer
purgeableState
TQ,R,N,V_purgeableState
purgeableStateHasBeenSet
TB,R,N,V_purgeableStateHasBeenSet
resourceTrackingEnabled
TB,R,D,N
resourceUsage
TI,R,D,N
indirectCommandBufferDescriptor
T@"MTLIndirectCommandBufferDescriptor",R,N,V_indirectCommandBufferDescriptor
maxIndirectCommandCount
TI,R,N,V_maxIndirectCommandCount
isContentsPointerExposed
TB,R,N,V_isContentsPointerExposed
checksum
TI,N,V_checksum
isContentExposedToCPU
TB,N,V_isContentExposedToCPU
validateNewTexture
Cannot create textures from indirect command buffers
descriptor must not be nil.
descriptor is not a MTLTextureDescriptor.
MTLTextureDescriptor.usage == MTLTextureUsageUnknown.
cannot create Memoryless texture from Buffer.
Textures with compressed pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with depth pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with stencil pixel formats cannot be created from a buffer and must be created as a standalone texture.
bytesPerRow(%lu) must be greater than (width * pixel_bytes)(%lu).
bytesPerRow must be non-zero.
Buffer-backed textures must have a texture type of MTLTextureType2D, MTLTextureTypeTextureBuffer or MTLTextureType2DArray, found %@.
Bytes required by texture offset, stride, height and array length (%lu) exceed buffer capacity(%lu).
Offset of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found offset(%lu)
BytesPerRow of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found bytesPerRow(%lu)
tracePath
T@"NSString",R,N,V_tracePath
-[MTLDebugCommandBuffer waitUntilScheduled]
waitUntilScheduled on uncommitted command buffer
-[MTLDebugCommandBuffer waitUntilCompleted]
waitUntilCompleted on uncommitted command buffer
-[MTLDebugCommandBuffer blitCommandEncoder]
encoding in progress
_MTLValidateResolveTexture
MSAA Resolve is only supported for color, depth, and stencil textures
MTLRenderPassDescriptor resolveTexture is associated with a different device
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1D.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType2DMultisample.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureTypeTextureBuffer.
MTLRenderPassDescriptor resolveTexture must not be Memoryless.
MTLRenderPassDescriptor texture and resolveTexture size mismatch.
PixelFormat %s cannot be a MSAA resolve target
Texture PixelFormat %s does not match Resolve PixelFormat %s
Slice is %lu, but the texture has only %lu slices
mipmap level is %lu, but the texture has only %lu levels
depth plane is %lu, but the texture has a depth of %lu at mip level %lu
resolveTexture sampleCount is %lu, but must be 1
_MTLValidateDepthStencilStoreState
%@: mixing %@ and %@ store actions for the depth and stencil render pass attachments is not allowed.
MTLDebugRenderPipeline
MTLDebugRenderCommandEncoder
%@: the stencil attachment resolve filter mode (MTLMultisampleStencilResolveFilterDepthResolvedSample) is not valid because the depth attachment store action (%@) does not contain a resolve.
-[MTLDebugCommandBuffer renderCommandEncoderWithDescriptor:]
renderPassDescriptor must not be nil.
renderPassDescriptor is not a MTLRenderPassDescriptor.
-[MTLDebugCommandBuffer fragmentRenderCommandEncoderWithDescriptor:]
-[MTLDebugCommandBuffer sampledFragmentRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer computeCommandEncoder]
-[MTLDebugCommandBuffer computeCommandEncoderWithDispatchType:]
-[MTLDebugCommandBuffer parallelRenderCommandEncoderWithDescriptor:]
-[MTLDebugCommandBuffer sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer encodeSignalEvent:value:]
Standard MTLEvents must signal events on the same device. Use MTLSharedEvent for cross-device events.
-[MTLDebugCommandBuffer encodeWaitForEvent:value:]
MTLStoreActionDontCare
MTLStoreActionStore
MTLStoreActionMultisampleResolve
MTLStoreActionStoreAndMultisampleResolve
MTLStoreActionUnknown
Unknown
validateRenderPassDescriptor
not a MTLDebugTexture.
Texture at colorAttachment[%lu] has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on color attachment %i includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
Attachment %u overlaps with attachment %u
This set of render targets requires %lu bytes of pixel storage. This device supports %lu bytes.
Texture at depthAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on the depth attachment includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
This render pass descriptor's clear depth (%f) is outside of the range [0..1]
Texture at stencilAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
renderTargetWidth (%lu) must be <= minimum attachment width (%lu).
renderTargetHeight (%lu) must be <= minimum attachment height (%lu).
No rendertargets set in RenderPassDescriptor.
Either set rendertargets in RenderPassDescriptor or set renderTargetWidth and renderTargetHeight.
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must be the same depth and stencil texture.
When depth and stencil are used together, the render pass has to write to the same level and slice for both.
When depth and stencil are used together, the resolve texture for the depth and stencil render pass attachments must be the same depth and stencil texture.
When both depth (%lu x %lu) and stencil (%lu x %lu) are used from separate textures, they must have identical dimensions.
defaultColorSampleCount (%lu) is not supported by device.
defaultRasterSampleCount (%lu) is not supported by device.
no sampleCount for color and raster available, either set defaultColorSampleCount or set defaultRasterSampleCount or set appropriate attachments
unexpected color and depth/stencil sample counts
defaultColorSampleCount should be zero.
Either set rendertargets in RenderPassDescriptor or set defaultRasterSampleCount.
defaultRasterSampleCount should be zero.
Per sample storage cannot be greater than 64B
Per pixel storage cannot be greater than 256B
Total allocated thread group memory (%lu) cannot be greater than (%lu)
4X MSAA does not support 32 x 32 tiles
MTLRenderPassDescriptor visibilityResultBuffer is associated with a different device
%lu custom sample positions were programmed, but this render pass uses %lu rasterizer sample(s). These counts must match.
validateAttachmentOnDevice
MTLRenderPassDescriptor texture is associated with a different device
Memoryless attachment need to be Texture2D or Texture2DMultisample.
Memoryless attachment cannot be loaded as it have no memory to load from.
Memoryless attachment content cannot be stored in memory.
PixelFormat %s is not color renderable
PixelFormat %s is not depth renderable
PixelFormat %s is not stencil renderable
false
MTLRenderPassDescriptor texture must not be MTLTextureType1D.
MTLRenderPassDescriptor texture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor texture must not be MTLTextureTypeTextureBuffer.
depth plane index is %lu, but the texture has a depth of %lu at mip level %lu
depth plane + renderTargetArrayLength is %lu, but the texture has a depth of %lu at mip level %lu.
slice + renderTargetArrayLength is %lu, but the texture only has %lu slices.
Mixing MTLTextureType3D with other attachment types is not allowed when renderTargetArrayLength is not zero
MTLRenderPassDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassDescriptor %s store action requires resolve texture
MTLRenderPassDescriptor %s depth resolve filter mode is not supported by device
MTLRenderPassDescriptor MTLMultisampleStencilResolveFilterDepthResolvedSample stencil resolve filter mode is not supported by device
MTLRenderPassDescriptor render targets have inconsistent sample counts.
MTLRenderPassDescriptor resolveTexture must have storeAction of MTLStoreActionMultisampleResolve, MTLStoreActionStoreAndMultisampleResolve or MTLStoreActionUnknown
MTLRenderPassDescriptor texture must be MTLTextureType2DMultisample when using a resolveTexture.
texture sampleCount is %lu, but must be > 1 when using a resolveTexture
the depth attachment
the stencil attachment
color attachment %lu
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, but Programmable Sample Positions is not supported on this device.
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, which does not apply to the store action (%@).
MTLMultisampleDepthResolveFilterSample0
MTLMultisampleDepthResolveFilterMin
MTLMultisampleDepthResolveFilterMax
validateTileDimensions
Invalid tile dimensions (%lu, %lu)
validateStoreLoadTransition
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. The results are undefined.
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. This is perfectly valid transition but it will result in reduced performance.
MTLLoadActionDontCare
MTLLoadActionLoad
computeFunction
T@"MTLComputePipelineReflection",R,N,V_reflection
-[MTLDebugCommandQueue insertDebugCaptureBoundary]
InsertDebugCaptureBoundary should not be called inside the completion handler
-[MTLDebugComputeCommandEncoder dealloc]
computePipelineState =
<null>
Set Buffers:
Buffer %lu:
Set Textures:
Texture %lu:
Set Samplers:
Sampler %lu:
Set ThreadgroupMemoryLengths:
Threadgroup %lu:
Image Block Size: %lu x %lu
-[MTLDebugComputeCommandEncoder setComputePipelineState:]
computePipelineState must not be nil.
computePipelineState is not a MTLComputePipelineState.
computePipelineState is associated with a different device
redundant setComputePipelineState.
previous setComputePipelineState was unused.
-[MTLDebugComputeCommandEncoder setBytes:length:atIndex:]
length(%lu) must be <= %lu.
-[MTLDebugComputeCommandEncoder setBuffer:offset:atIndex:]
offset(%lu) must be < [buffer length](%lu).
offset(%lu) must be 0.
-[MTLDebugComputeCommandEncoder setBufferOffset:atIndex:]
index(%lu) must have an existing buffer.
-[MTLDebugComputeCommandEncoder setBuffers:offsets:withRange:]
NSMaxRange(range)(%lu) must be <= %lu.
buffers[%lu] is not an MTLBuffer.
buffers[%lu] is associated with a different device
offset[%lu](%lu) must be < [buffers[%lu] length](%lu).
offsets[%lu](%lu) must be 0.
-[MTLDebugComputeCommandEncoder setTexture:atIndex:]
frameBufferOnly texture not supported for compute.
Memoryless texture not supported for compute.
-[MTLDebugComputeCommandEncoder setTextures:withRange:]
textures[%lu] is not an MTLTexture.
textures[%lu] is associated with a different device
frameBufferOnly textures[%lu] not supported for compute.
textures[%lu] is Memoryless and cannot be assigned.
-[MTLDebugComputeCommandEncoder setSamplerState:atIndex:]
sampler is not a MTLSamplerState.
sampler is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerStates:withRange:]
samplers[%lu] is not an MTLSamplerState.
samplers[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugComputeCommandEncoder setSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugComputeCommandEncoder setThreadgroupMemoryLength:atIndex:]
length(%lu) must be a multiple of %lu bytes.
-[MTLDebugComputeCommandEncoder setImageblockWidth:height:]
width(%lu) must be a power of 2.
height(%lu) must be a power of 2.
width(%lu)*height(%lu) must be less than or equal to 1024
-[MTLDebugComputeCommandEncoder validateStageInRegion:]
stage_in region (width(%lu) * height(%lu) * depth(%lu))(%lu) must not be 0.
stage_in region (width)(%lu) must be <= width(%lu).
stage_in region (height)(%lu) must be <= height(%lu).
stage_in region (depth)(%lu) must be <= depth(%lu).
-[MTLDebugComputeCommandEncoder setStageInRegionWithIndirectBuffer:indirectBufferOffset:]
indirectBufferOffset (%lu) must be a multiple of 4
-[MTLDebugComputeCommandEncoder _validateThreadsPerThreadgroup:]
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must not be 0.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (device threadgroup size limit)
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (kernel threadgroup size limit)
threadsPerThreadgroup.width(%lu) must be <= %lu.
threadsPerThreadgroup.height(%lu) must be <= %lu.
threadsPerThreadgroup.depth(%lu) must be <= %lu.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be multiples of %lu.
-[MTLDebugComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:]
threadgroupsPerGrid.width(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.height(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadgroupsPerGrid.width(%lu) * threadgroupsPerGrid.y(%lu) * threadgroupsPerGrid.depth(%lu))(%lu) must not be 0.
stage_in region was not set for compute pipeline
-[MTLDebugComputeCommandEncoder dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:]
indirectBuffer must not be nil.
indirectBuffer is not a MTLBuffer.
indirectBuffer is associated with a different device
(indirectBufferOffset + sizeof(MTLDispatchThreadgroupsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
indirectBufferOffset(%lu) must be a multiple of 4 bytes.
-[MTLDebugComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:]
threadsPerGrid.width(%lu) must be <= UINT32_MAX.
threadsPerGrid.height(%lu) must be <= UINT32_MAX.
threadsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadsPerGrid.width(%lu) * threadsPerGrid.y(%lu) * threadsPerGrid.depth(%lu))(%lu) must not be 0.
-[MTLDebugComputeCommandEncoder dispatchThreadsWithIndirectBuffer:indirectBufferOffset:]
(indirectBufferOffset + sizeof(MTLDispatchThreadsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
-[MTLDebugComputeCommandEncoder waitForFence:]
-[MTLDebugComputeCommandEncoder endEncoding]
endEncoding without dispatchThreadgroups.
-[MTLDebugComputeCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugComputeCommandEncoder useResource:usage:]
resource should not be nil
usage (0x%lx) has an invalid value
-[MTLDebugComputeCommandEncoder useResources:count:usage:]
resource (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder useHeap:]
heap should not be nil
-[MTLDebugComputeCommandEncoder useHeaps:count:]
heap (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder memoryBarrierWithScope:]
scope (0x%lx) has an invalid value for compute
-[MTLDebugComputeCommandEncoder memoryBarrierWithResources:count:]
resources should not be nil or empty array
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:withRange:]
Execution starts past the end of the buffer
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the compute pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
computePipelineState
T@"<MTLComputePipelineState>",R,N,V_computePipelineState
validateArg
unused binding in encoder at %s index %lu.
sampler
threadgroupMemory
MTLDebugFunctionArgumentInit
redundant setting of %@.
thread_position_in_grid
threads_per_grid
thread_position_in_threadgroup
thread_index_in_threadgroup
threads_per_threadgroup
threadgroup_position_in_grid
threadgroups_per_grid
validateBuiltinArguments
Invalid built-in argument %@
component %lu: %llu must be <= %llu for %@ [[ %@ ]]
validateComputeFunctionArguments
%@ Function(%@): missing %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu].
%@ Function(%@): the offset into the buffer %@ that is bound at %s index %lu must be a multiple of %lu but was set to %lu.
%@ Function(%@): argument %@[%lu] from %s(%lu) with offset(%lu) and length(%lu) has space for %lu bytes, but argument has a length(%lu).
%@ Function(%@): Bytes are being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): Reading from buffer bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to buffer bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): threadgroupMemoryLength(%lu) must be >= %lu at %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect type of texture (%@) bound at %s binding at index %lu (expect %@) for %@[%lu].
%@ Function(%@): Non-writeable texture format %s is being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): The pixel format (%s) of the %s (name:%@) bound at index %lu is incompatible with the data type (%@) of the %s parameter (%@ [[%s(%lu)]]). %s is compatible with the data type(s) %@.
%@ Function(%@): reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
%@ Function(%@): Shader uses texture(%@[%lu]) as read-write, but hardware does not support read-write texture of this pixel format.
%@ Function(%@): Reading from texture bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to texture bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
Functon(%@): total used threadgroupMemoryLength(%lu) must be <= %lu.
function
T@"<MTLFunction>",R,N,V_function
descriptor
T@"MTLComputePipelineDescriptor",R,N,V_descriptor
imageFilterFunctions
T@"NSArray",R,N,V_imageFilterFunctions
imageFilterFunctionInfo
T^{?=BQ^{?}},R,N,V_imageFilterFunctionInfo
-[MTLDebugIndirectCommandBuffer indirectRenderCommandAtIndex:]
CPU access for MTLIndirectCommandBuffer with MTLResourceStorageModePrivate storage mode is disallowed.
MTLIndirectCommandBuffer created with descriptor.commandTypes(%lu) = (MTLIndirectCommandTypeConcurrentDispatch) cannot be used to create MTLIndirectRenderCommands 
The requested command (%lu) is greater than the indirect command buffer size (%lu)
-[MTLDebugIndirectCommandBuffer indirectComputeCommandAtIndex:]
MTLIndirectCommandBuffer created with descriptor.commandTypes(%lu) different than (MTLIndirectCommandTypeConcurrentDispatch) cannot be used to create MTLIndirectComputeCommands 
optimizedRangeList
T@"NSMutableArray",R
T@"MTLIndirectCommandBufferDescriptor",R
MTL_XML_DUMP_COUNTERS
MTL_XML_SYNC_BEFORE_SAMPLE
MTL_XML_TRACE_PATH
xml_trace_%p
Error creating directory '%@' (%@)
MTL_XML_COUNTER_NAMES
MTLStat_nSec
Unsupported counter: %@
Failed to request counters
pipelineNames
disableRunTimeCompilation
pipelineCache
T@"<MTLPipelineCache>",R,N
functionCache
encodedLength
layout
T@"_MTLIndirectArgumentBufferLayout",R,N
findMemberContainingIndex
Index %u does not match any member of the argument buffer
indexRangeIsValueType
Index %u does not correspond to any valid member of the argument buffer
Trying to set a %@ at index %u but the argument buffer has a %@ at this index
index range (%lu, %lu) has indices that are outside of the valid index range [%u, %u]
indexIsValueType
index (%lu) is outside of the valid index range [%u, %u]
-[MTLDebugArgumentEncoder setArgumentBuffer:startOffset:elementIndex:]
buffer storage mode (%@) should be MTLStorageModeShared
offset (%lu) + encodedLength (%lu) should be smaller or equal to the buffer length (%lu)
-[MTLDebugArgumentEncoder setBuffer:offset:atIndex:]
No argument buffer is set
offset (%lu) should be smaller than the buffer lengh (%lu)
-[MTLDebugArgumentEncoder setBuffers:offsets:withRange:]
-[MTLDebugArgumentEncoder setTexture:atIndex:]
-[MTLDebugArgumentEncoder setTextures:withRange:]
-[MTLDebugArgumentEncoder setSamplerState:atIndex:]
Sampler state did not have supportArgumentBuffers flag set on creation, but is used with argument buffers
-[MTLDebugArgumentEncoder setSamplerStates:withRange:]
-[MTLDebugArgumentEncoder constantDataAtIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineState:atIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineStates:withRange:]
-[MTLDebugArgumentEncoder setComputePipelineState:atIndex:]
-[MTLDebugArgumentEncoder setComputePipelineStates:withRange:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffer:atIndex:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffers:withRange:]
-[MTLDebugArgumentEncoder newArgumentEncoderForBufferAtIndex:]
No indirect argument buffer at that index
Constant
Texture
Sampler
Buffer
Struct
RenderPipelineState
ComputePipelineState
IndirectCommandBuffer
METAL_DEBUG_RESOURCE_TRACK_CHECKSUMMING_DISABLE
Metal resource track checksumming is %s
enabled
disabled
METAL_DEBUG_RESOURCE_TRACK_CHECKSUMMING_FORCE_ALL
Metal resource track checksumming is forced on for all buffers
METAL_COMPLAIN_ABOUT_SLOPPY_TEXTURE_USAGE
-[MTLDebugDevice heapTextureSizeAndAlignWithDescriptor:]
-[MTLDebugDevice newHeapWithDescriptor:]
Heap needs to have a size.
Requested storage mode is not allowed for Heaps.
Requested CPU cache mode is not allowed for Heaps.
Requested hazard tracking mode is not allowed for Heaps.
-[MTLDebugDevice validateMemorylessResource:]
Memoryless texture need to have renderable PixelFormat.
Memoryless texture need to be of type Texture2D or Texture2DMultisample.
-[MTLDebugDevice validateResourceOptions:isTexture:isIOSurface:]
options 0x%lx conveys invalid cpuCacheMode of 0x%lx
options 0x%lx conveys invalid storageMode of 0x%lx
options 0x%lx conveys invalid hazardTrackingMode of 0x%lx
MTLResourceOptions options has unknown bits 0x%lx.
-[MTLDebugDevice validateNewBufferArgs:options:]
Cannot create buffer of zero length.
newBufferWith*:length 0x%lx must not exceed %llu MB.
-[MTLDebugDevice newBufferWithBytes:length:options:]
storageModePrivate incompatible with ...WithBytes variant of newBuffer
newBufferWithBytes:pointer must not be nil.
-[MTLDebugDevice newBufferWithBytesNoCopy:length:options:deallocator:]
storageModePrivate incompatible with ...WithBytesNoCopy variant of newBuffer
newBufferWithBytesNoCopy:pointer must not be nil.
newBufferWithBytesNoCopy:pointer %p is not %d byte aligned.
newBufferWithBytesNoCopy:length 0x%lx is not %d byte aligned.
-[MTLDebugDevice newArgumentEncoderWithArguments:]
arguments cannot be nil
arguments must have at least one element
-[MTLDebugDevice newTextureWithBytesNoCopy:length:descriptor:deallocator:]
MTLResourceStorageModeShared must be used.
newTextureWithBytesNoCopy:pointer must not be nil.
newTextureWithBytesNoCopy:pointer %p is not %d byte aligned.
-[MTLDebugDevice newDepthStencilStateWithDescriptor:]
descriptor is not a MTLDepthStencilDescriptor.
_validateTextureBufferDescriptor
texture buffer width (%llu) must be less than %llu
texture buffer height (%llu) must be 1
texture buffer depth (%llu) must be 1
texture buffer mipmapLevelCount (%llu) must be 1
texture buffer sampleCount (%llu) must be 1
texture buffer arrayLength (%llu) must be 1
usage must be set
MTLTextureUsageRenderTarget is not valid for a texture buffer
Texture buffer usage must contain read or write
texture buffer with pixel format (%s) cannot be written to from a shader
pixel format (%s) cannot be written to from a shader on this device
pixel format (%s) cannot be used for a texture buffer
-[MTLDebugDevice newTextureWithDescriptor:]
Cannot use an Xn format when creating a new texture
-[MTLDebugDevice newSamplerStateWithDescriptor:]
descriptor is not a MTLSamplerDescriptor.
default
metallib
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:reflection:error:]
descriptor is not a MTLRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:reflection:error:]
function must not be nil.
descriptor is not a MTLComputePipelineDescriptor.
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:reflection:error:]
descriptor is not a MTLTileRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:completionHandler:]
-[MTLDebugDevice newLibraryWithFile:error:]
filepath must not be nil.
filepath is not a NSString.
-[MTLDebugDevice newLibraryWithURL:error:]
url must not be nil.
url is not a NSURL.
Invalid file url
-[MTLDebugDevice newLibraryWithSource:options:error:]
source must not be nil.
source is not a NSString.
options is not a MTLCompileOptions.
-[MTLDebugDevice newLibraryWithSource:options:completionHandler:]
-[MTLDebugDevice newLibraryWithData:error:]
data must not be nil.
-[MTLDebugDevice newPipelineLibraryWithFilePath:error:]
-[MTLDebugDevice newTextureWithDescriptor:iosurface:plane:]
iosurface must not be nil.
-[MTLDebugDevice newBufferWithIOSurface:]
-[MTLDebugDevice minLinearTextureAlignmentForPixelFormat:]
%s is not supported on this device.
Linear textures do not support compressed pixel formats
Linear textures do not support depth/stencil pixel formats
-[MTLDebugDevice minimumLinearTextureAlignmentForPixelFormat:]
setDebugEvent:
TB,R,N,V_resourceTrackingEnabled
frameNum
TI,N,V_frameNum
resourceTrackingChecksummingEnabled
TB,R,N,V_resourceTrackingChecksummingEnabled
resourceTrackingChecksummingForceAll
TB,R,N,V_resourceTrackingChecksummingForceAll
T@"MTLDepthStencilDescriptor",R,N,V_descriptor
isStandardEvent
TB,N,V_isStandardEvent
-[MTLDebugFragmentRenderCommandEncoder dealloc]
descriptor =
depthBias =
depthBiasSlopeScale =
depthBiasClamp =
scissorRect =
renderPipelineState =
depthStencilState =
frontStencilRef =
0x%x
backStencilRef =
Blend Color =
%g %g %g %g
Set Fragment Buffers:
Set Fragment Textures:
Set Fragment Samplers:
-[MTLDebugFragmentRenderCommandEncoder validateFramebufferWithRenderPipelineState:]
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState colorSampleCount (%lu).
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For color attachment %d, the render pipeline's pixelFormat (%s) does not match the attachment's pixelFormat (%s).
For color attachment %d, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For depth attachment, the render pipeline's pixelFormat (%s) does not match the attachment's pixelFormat (%s).
For depth attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For stencil attachment, the render pipeline's pixelFormat (%s) does not match the attachment's pixelFormat (%s).
For stencil attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
When depth and stencil are used together, the texture bound to the depth and stencil attachments must be the same depth and stencil texture.
The color sample count (%lu) does not match the renderPipelineState's color sample count (%lu)
The raster sample count (%lu) does not match the renderPipelineState's raster sample count (%lu)
-[MTLDebugFragmentRenderCommandEncoder setRenderPipelineState:]
renderPipelineState must not be nil.
renderPipelineState is not a MTLRenderPipelineState.
renderPipelineState is associated with a different device
redundant setRenderPipelineState.
previous setRenderPipelineState was unused.
-[MTLDebugFragmentRenderCommandEncoder setFragmentBytes:length:atIndex:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentBuffer:offset:atIndex:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentBufferOffset:atIndex:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentBuffers:offsets:withRange:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentTexture:atIndex:]
texture is Memoryless, and cannot be assigned.
-[MTLDebugFragmentRenderCommandEncoder setFragmentTextures:withRange:]
textures[%lu] is Memoryless, and cannot be assigned.
-[MTLDebugFragmentRenderCommandEncoder setFragmentSamplerState:atIndex:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentSamplerStates:withRange:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugFragmentRenderCommandEncoder setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:]
textureIndex(%lu) must be < %lu.
samplerIndex(%lu) must be < %lu.
-[MTLDebugFragmentRenderCommandEncoder setDepthBias:slopeScale:clamp:]
redundant setDepthBias.
previous setDepthBias was unused.
-[MTLDebugFragmentRenderCommandEncoder setScissorRect:]
rect.width(%lu) must be non-zero
rect.height(%lu) must be non-zero
(rect.x(%lu) + rect.width(%lu))(%lu) must be <= render pass width(%lu)
(rect.y(%lu) + rect.height(%lu))(%lu) must be <= render pass height(%lu)
redundant setScissorRect.
previous setScissorRect was unused.
-[MTLDebugFragmentRenderCommandEncoder setDepthStencilState:]
depthStencilState must not be nil.
depthStencilState is not a MTLDepthStencilState.
depthStencilState is associated with a different device
redundant setDepthStencilState.
previous setDepthStencilState was unused.
-[MTLDebugFragmentRenderCommandEncoder setStencilReferenceValue:]
redundant setStencilReferenceValue.
previous setStencilReferenceValue was unused.
-[MTLDebugFragmentRenderCommandEncoder setStencilFrontReferenceValue:backReferenceValue:]
-[MTLDebugFragmentRenderCommandEncoder setBlendColorRed:green:blue:alpha:]
redundant setBlendColorRed.
previous setBlendColorRed was unused.
-[MTLDebugFragmentRenderCommandEncoder setColorStoreAction:atIndex:]
attachmentIndex(%lu) must be < %lu
-[MTLDebugFragmentRenderCommandEncoder setColorStoreActionOptions:atIndex:]
-[MTLDebugFragmentRenderCommandEncoder drawTrianglesWithPositions:vertexCount:triangleIndices:triangleCount:]
vertexCount(%lu) must be less than 64.
Too many triangles(%lu) encoded.
-[MTLDebugFragmentRenderCommandEncoder drawTrianglesWithPositions:vertexCount:vertexVaryings:varyingCountPerVertex:triangleIndices:triangleCount:]
varyingCount(%lu) must be less than 126.
-[MTLDebugFragmentRenderCommandEncoder drawTrianglesWithPositions:vertexCount:vertexVaryings:varyingCountPerVertex:]
vertexCount(%lu) must be a multiple of 3.
-[MTLDebugFragmentRenderCommandEncoder endEncoding]
endEncoding called with store action for color attachment index %u still set to MTLStoreActionUnknown
endEncoding called with store action for depth attachment still set to MTLStoreActionUnknown
endEncoding called with store action for stencil attachment still set to MTLStoreActionUnknown
endEncoding called with store action unsupported for Memoryless attachment.
endEncoding without draw.
-[MTLDebugFragmentRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
T@"MTLRenderPassDescriptor",R,C,N,V_descriptor
depthBias
Tf,R,N,V_depthBias
depthBiasSlopeScale
Tf,R,N,V_depthBiasSlopeScale
depthBiasClamp
Tf,R,N,V_depthBiasClamp
scissorRect
T{?=QQQQ},R,N,V_scissorRect
renderPipelineState
T@"<MTLRenderPipelineState>",R,N,V_renderPipelineState
depthStencilState
T@"<MTLDepthStencilState>",R,N,V_depthStencilState
defaultDepthStencilDescriptor
T@"MTLDepthStencilDescriptor",R,N,V_defaultDepthStencilDescriptor
frontStencilRef
TI,R,N,V_frontStencilRef
backStencilRef
TI,R,N,V_backStencilRef
blendColorRed
Tf,R,N,V_blendColorRed
blendColorGreen
Tf,R,N,V_blendColorGreen
blendColorBlue
Tf,R,N,V_blendColorBlue
blendColorAlpha
Tf,R,N,V_blendColorAlpha
TQ,R,V_width
TQ,R,V_height
%lu %lu %lu %lu
local memory
buffer =
bufferOffset =
texture =
baseLevel =
sampler =
lodMinClamp =
lodMaxClamp =
threadgroupMemoryLength =
newArgumentEncoder
Function %@ does not have a buffer argument with buffer index %lu
Buffer argument %@ (buffer index: %lu) of function %@ is not an indirect argument buffer
constantValues
T@"MTLFunctionConstantValues",&,N,V_constantValues
-[MTLDebugLibrary newFunctionWithName:]
name is not a NSString.
validateNewFunctionWithConstantArguments
functionName is not a NSString.
constantValues must not be nil.
TQ,N,V_type
code
T@,C,N,V_code
compileOptions
T@"MTLCompileOptions",C,N,V_compileOptions
-[MTLDebugParallelRenderCommandEncoder setColorStoreAction:atIndex:]
-[MTLDebugParallelRenderCommandEncoder setColorStoreActionOptions:atIndex:]
-[MTLDebugParallelRenderCommandEncoder endEncoding]
-[MTLDebugParallelRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
filterCounterRangeWithFirstBatch should not be called on ParallelRenderCommandEncoders
_MTLDebugValidateBuffer
%s must not be nil.
%s is not a MTLBuffer.
%s is associated with a different device
_MTLDebugValidateIndexBuffer
%sOffset(%lu) must be a multiple of %lu bytes.
%sOffset(%lu) + (indexCount(%lu) * %lu) must be <= [%s length](%lu).
indexCount(%lu) must be non-zero.
_MTLDebugValidatePatchIndexBuffer
%sOffset(%lu) + (patchIndicesUsed(%lu) * %lu) must be <= [%s length](%lu).
patchCount(%lu) must be non-zero.
instanceCount(%lu) must be non-zero.
%sOffset(%lu) must be 0.
v24@?0@"<MTLRenderCommandEncoderSPI>"8Q16
-[MTLDebugRenderCommandEncoder initWithRenderCommandEncoder:parent:descriptor:]_block_invoke
Exceeded HW limit of resources used by render encoder working in Memoryless mode.
Exceeded HW limit of scissor rectangles for render encoder working in Memoryless mode.
Exceeded HW limit of depth biases for render encoder working in Memoryless mode.
-[MTLDebugRenderCommandEncoder dealloc]
viewportCount =
viewports:
Viewport %lu:
frontFacingWinding =
cullMode =
lineWidth =
scissorRectCount =
scissorRects:
Scissor %lu:
triangleFillMode =
visibilityResultMode =
visibilityResultOffset =
Set Vertex Buffers:
Set Vertex Textures:
Set Vertex Samplers:
Set Tile Buffers:
Set Tile Textures:
Set Tile Samplers:
Set Tessellation Factor Buffer =
tessellationFactorBufferInstanceStride =
tessellationFactorScale =
-[MTLDebugRenderCommandEncoder validateFramebufferWithRenderPipelineState:]
For color attachment %d, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For depth attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For stencil attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
Device does not support separable raster/color shading rates
The sample count (%lu) does not match the renderPipelineState's sample count (%lu)
-[MTLDebugRenderCommandEncoder setRenderPipelineState:]
the pipelineState's per sample imageBlock usage(%lu) is greater than the encoder's perSample imageBlock usage(%lu)
The threadgroup memory consumed must be <= (%lu)
-[MTLDebugRenderCommandEncoder setVertexBytes:length:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexBufferOffset:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexBuffers:offsets:withRange:]
-[MTLDebugRenderCommandEncoder setVertexTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexTextures:withRange:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:withRange:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentBytes:length:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBufferOffset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBuffers:offsets:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentTextures:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:]
-[MTLDebugRenderCommandEncoder setTileBytes:length:atIndex:]
-[MTLDebugRenderCommandEncoder setTileBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setTileBufferOffset:atIndex:]
-[MTLDebugRenderCommandEncoder setTileBuffers:offsets:withRange:]
-[MTLDebugRenderCommandEncoder setTileTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setTileTextures:withRange:]
-[MTLDebugRenderCommandEncoder setTileSamplerState:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:withRange:]
-[MTLDebugRenderCommandEncoder setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder dispatchThreadsPerTile:]
the renderPipelineState was not created with a tileDescriptor
threadsPerTile (%lu, %lu) must equal tile size (%lu, %lu) when threadgroupSizeMatchesTileSize is true
threadsPerTile.width(%lu) and threadsPerTile.height(%lu) must match the tile size or threadsPerTile.width(%lu) must be equal to threadsPerTile.height(%lu)
roundup2(threadsPerTile.width(%lu)) * roundup2(threadsPerTile.height(%lu)) * threadsPerTile.depth(%lu) must be <= %lu, both width and height are rounded up to nearest even number 
tile shader input image-block layout must match the previous state's image-block layout
threadsPerTile.width(%lu) * threadsPerTile.height(%lu) * threadsPerTile.depth(%lu) must not be 0
threadsPerTile.width(%lu) must be <= %lu
threadsPerTile.depth(%lu) must be 1
Tile
-[MTLDebugRenderCommandEncoder setThreadgroupMemoryLength:offset:atIndex:]
A dispatch is required to reinterpret threadgroup memory.
offset + length(%lu) must be <= threadgroupMemoryLength(%lu).
offset(%lu) must be a multiple of %lu bytes.
-[MTLDebugRenderCommandEncoder useResource:usage:]
-[MTLDebugRenderCommandEncoder useResource:usage:stages:]
stages (0x%lx) has an invalid stage
'stages' does not specify any render stages. Specify at least one stage.
-[MTLDebugRenderCommandEncoder useResources:count:usage:]
-[MTLDebugRenderCommandEncoder useResources:count:usage:stages:]
-[MTLDebugRenderCommandEncoder useHeap:]
-[MTLDebugRenderCommandEncoder useHeap:stages:]
-[MTLDebugRenderCommandEncoder useHeaps:count:]
-[MTLDebugRenderCommandEncoder useHeaps:count:stages:]
-[MTLDebugRenderCommandEncoder setViewport:]
redundant setViewport.
previous setViewport was unused.
-[MTLDebugRenderCommandEncoder setViewports:count:]
viewports parameter cannot be nullptr
viewport count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setFrontFacingWinding:]
redundant setFrontFacingWinding.
previous setFrontFacingWinding was unused.
-[MTLDebugRenderCommandEncoder setCullMode:]
redundant setCullMode.
previous setCullMode was unused.
-[MTLDebugRenderCommandEncoder setDepthClipMode:]
redundant setDepthClipMode.
previous setDepthClipMode was unused.
-[MTLDebugRenderCommandEncoder setLineWidth:]
lineWidth(%g) must be between 1.0f and %.1ff
redundant setLineWidth.
previous setLineWidth was unused.
-[MTLDebugRenderCommandEncoder setDepthBias:slopeScale:clamp:]
-[MTLDebugRenderCommandEncoder setScissorRect:]
-[MTLDebugRenderCommandEncoder setScissorRects:count:]
scissorRects parameter cannot be nullptr
scissor rect count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setTriangleFrontFillMode:backFillMode:]
-[MTLDebugRenderCommandEncoder setTriangleFillMode:]
redundant setTriangleFillMode.
previous setTriangleFillMode was unused.
-[MTLDebugRenderCommandEncoder setDepthStencilState:]
-[MTLDebugRenderCommandEncoder setStencilReferenceValue:]
-[MTLDebugRenderCommandEncoder setStencilFrontReferenceValue:backReferenceValue:]
_MTLDebugValidateDeferredStoreActionOnDevice
storeAction must not be MTLStoreActionUnknown
store actions known at render command encoder init time may not be mutated
storeAction unsupported for Memoryless attachment.
Store action for color attachment index %u must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for depth attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for stencil attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
-[MTLDebugRenderCommandEncoder setColorStoreAction:atIndex:]
deferred color store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreAction:]
deferred depth store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreAction:]
deferred stencil store actions cannot be set on sub render command encoders
_MTLDebugValidateDeferredStoreActionOptionsOnDevice
-[MTLDebugRenderCommandEncoder setColorStoreActionOptions:atIndex:]
deferred color store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreActionOptions:]
deferred depth store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreActionOptions:]
deferred stencil store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setVisibilityResultMode:offset:]
offset(%lu) must be a multiple of 8 bytes.
offset(%lu) must be <= %lu.
using the same offset (%lu) in the visibility buffer twice in the same command encoder is not allowed.
framebuffer visibilityResultBuffer must not be nil.
offset(%lu) must be < [visibilityResultBuffer length](%lu).
redundant setVisibilityResultMode.
previous setVisibilityResultMode was unused.
-[MTLDebugRenderCommandEncoder setBlendColorRed:green:blue:alpha:]
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:atIndex:]
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:]
_MTLDebugValidateMTLPrimitiveType
primitiveType is not a valid MTLPrimitiveType.
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:]
renderPipelineState must be set.
renderPipelineState must be created using a MTLRenderPipelineDescriptor.
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassPoint but primitiveType is not MTLPrimitiveTypePoint
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassLine but primitiveType is neither MTLPrimitiveTypeLine nor MTLPrimitiveTypeLineStrip
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassTriangle but primitiveType is neither MTLPrimitiveTypeTriangle nor MTLPrimitiveTypeTriangleStrip
The scissor rectangle count (%lu) should be equal to the viewport count (%lu) or should be 1.
input image-block layout must match the previous state image-block layout
the renderPipelineState has a vertex shader that writes to render_target_array_index but renderTargetArrayLength is set to zero
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:]
indexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
indirectBuffer
sizeof(MTLDrawPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawPrimitives:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawIndexedPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder waitForFence:beforeStages:]
-[MTLDebugRenderCommandEncoder endEncoding]
-[MTLDebugRenderCommandEncoder setTessellationFactorBuffer:offset:instanceStride:]
offset(%lu) must be a multiple of 4 bytes.
instanceStride(%lu) must be a multiple of 4 bytes.
-[MTLDebugRenderCommandEncoder setTessellationFactorScale:]
scale(%g) must be a normal floating point value (not denormal, infinite, nor NaN) and must be > 0.0f.
-[MTLDebugRenderCommandEncoder drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:]
patchIndexBuffer
-[MTLDebugRenderCommandEncoder drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawPatchIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:]
controlPointIndexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugRenderCommandEncoder memoryBarrierWithScope:afterStages:beforeStages:]
memoryBarrierWithResources can only be used on MacOS
-[MTLDebugRenderCommandEncoder memoryBarrierWithResources:count:afterStages:beforeStages:]
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:withRange:]
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the render pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
viewports
T^{vector<MTLViewport, std::__1::allocator<MTLViewport> >=^{?}^{?}{__compressed_pair<MTLViewport *, std::__1::allocator<MTLViewport> >=^{?}}},R,N
scissorRects
T^{vector<MTLScissorRect, std::__1::allocator<MTLScissorRect> >=^{?}^{?}{__compressed_pair<MTLScissorRect *, std::__1::allocator<MTLScissorRect> >=^{?}}},R,N
viewport
T{?=dddddd},R,N
T{?=QQQQ},R,N
frontFacingWinding
TQ,R,N,V_frontFacingWinding
cullMode
TQ,R,N,V_cullMode
depthClipMode
TQ,R,N,V_depthClipMode
lineWidth
Tf,R,N,V_lineWidth
triangleFillMode
TQ,R,N,V_triangleFillMode
peakPerSampleStorage
TQ,R,N,V_peakPerSampleStorage
resolvedSampleCount
TQ,R,N,V_resolvedSampleCount
visibilityResultMode
TQ,R,N,V_visibilityResultMode
visibilityResultOffset
TQ,R,N,V_visibilityResultOffset
tessellationFactorBufferArgument
T{?=BBQ@QQQQQBff},R,N,V_tessellationFactorBufferArgument
tessellationFactorBufferInstanceStride
TQ,R,N,V_tessellationFactorBufferInstanceStride
tessellationFactorScale
Tf,R,N,V_tessellationFactorScale
MTLIndexTypeSize
indexType not valid MTLIndexType
%g %g %g %g %g %g
MTLWindingClockwise
MTLWindingCounterClockwise
MTLCullModeNone
MTLCullModeFront
MTLCullModeBack
MTLTriangleFillModeFill
MTLTriangleFillModeLines
MTLTriangleFillModePoint
MTLVisibilityResultModeDisabled
MTLVisibilityResultModeBoolean
MTLVisibilityResultModeCounting
validateMTLWinding
frontFacingWinding is not a valid MTLWinding.
validateMTLCullMode
cullMode is not a valid MTLCullMode.
validateMTLDepthClipMode
depthClipMode is not a valid MTLDepthClipMode.
validateMTLTransformFeedbackState
state(%u) is not a valid MTLTransformFeedbackState.
validateMTLTriangleFillMode
fillMode is not a valid MTLTriangleFillMode.
validateMTLVisibilityResultMode
mode is not a valid MTLVisibilityResultMode.
validateFunctionArguments
%@ Function(%@): Shader reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): Shader writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
q24@?0@8@16
%@ Function(%@): there is an overlap with the threadgroupMemoryArgument at offset (%lu) and at offset(%lu).
validateBuiltInArguments
vertex_id type is not big enough to draw this many vertices (%lu)
instance_id type is not big enough to draw this many instances (%lu)
validateVertexDescriptor
missing vertexDescriptor %s binding at index %lu.
incorrect vertexDescriptor %s binding at index %lu.
validateDepthStencilState
MTLDepthStencilDescriptor sets depth test but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor has depthWriteEnabled but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor uses frontFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
MTLDepthStencilDescriptor uses backFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
validateVertexFunction
%s requires a postTessellationVertexFunction but the vertexFunction of the renderPipelineState is not a postTessellationVertexFunction.
%s requires a normal vertexFunction but the vertexFunction of the renderPipelineState is a postTessellationVertexFunction.
validateIndirectBuffer
(%sOffset + %s)(%lu) must be <= [%s length](%lu).
%sOffset(%lu) must be a multiple of 4 bytes.
validateCommonTessellationErrors
missing tessellationFactorBuffer binding.
numberOfPatchControlPoints(%lu) must match the number of control points(%ld) set in the vertexFunction of the renderPipelineState.
numberOfPatchControlPoints(%lu) must be <= 32.
for drawIndexedPatches numberOfPatchControlPoints(%lu) must not be 0.
for MTLTessellationFactorStepFunctionConstant and MTLTessellationFactorStepFunctionPerPatch tessellationFactorBufferInstanceStride(%lu) must be zero.
for MTLTessellationFactorStepFunctionPerInstance and MTLTessellationFactorStepFunctionPerPatchAndPerInstance tessellationFactorBufferInstanceStride(%lu) must be non-zero.
tessellationFactorBufferInstanceStride(%lu) must be a multiple of %lu bytes.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeNone not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt16 not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt32 not valid for %s.
tessellationFactorBuffer
validateTessellationFactorBuffer
%sOffset(%lu) + tessellationFactorBytesUsed(%lu) must be <= [%s length](%lu).
_MTLTessellationFactorBytesUsed
(patchStart + patchCount)(%lu) * %lu must be <= tessellationFactorBufferInstanceStride(%lu).
MTL_XML_DUMP_EVENTS
MTLCommandBufferKernelStartTime
MTLCommandBufferKernelEndTime
MTLCommandBufferGPUStartTime
MTLCommandBufferGPUEndTime
traceBuffer
T@"MTLCountersTraceCommandBuffer",R,N,V_traceBuffer
-[MTLDebugResource doesAliasResource:]
Input resource was not allocated on the Heap.
-[MTLDebugResource doesAliasAllResources:count:]
Resources count cannot be zero.
Input resource %0lx was not allocated on a heap.
-[MTLDebugResource doesAliasAnyResources:count:]
T@,R,V_baseObject
hasTrackedMakeAliasable
TB,V_hasTrackedMakeAliasable
-[MTLDebugIndirectRenderCommand setVertexBuffer:offset:atIndex:]
-[MTLDebugIndirectRenderCommand setFragmentBuffer:offset:atIndex:]
-[MTLDebugIndirectRenderCommand drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
drawPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
drawIndexedPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setRenderPipelineState:]
-[MTLDebugIndirectRenderCommand drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawIndexedPatches is not enabled on this indirect command buffer
T@"MTLRenderPipelineDescriptor",R,N,V_descriptor
T@"MTLRenderPipelineReflection",R,N,V_reflection
tileDescriptor
T@"MTLTileRenderPipelineDescriptor",R,N,V_tileDescriptor
T@"MTLSamplerDescriptor",R,C,N,V_descriptor
validateMTLSamplerDescriptor
MTLSamplerDescriptor:non-normalized coords require MTLSamplerMipFilterNotMipmapped.
MTLSamplerDescriptor:non-normalized coords require MTLSamplerAddressModeClampToEdge, MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor.
MTLSamplerDescriptor:non-normalized coords require maxAnisotropy == 1.
MTLSamplerDescriptor:non-normalized coords require minFilter==magFilter of MTLSamplerMinMagFilterNearest or MTLSamplerMinMagFilterLinear
MTLSamplerDescriptor's min filter value (%lu) is invalid.
MTLSamplerDescriptor's mag filter value (%lu) is invalid.
MTLSamplerDescriptor's mip filter value (%lu) is invalid.
MTLSamplerDescriptor's max anisotropy value (%lu) is invalid.
MTLSamplerDescriptor's S texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's T texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's R texture coordinate address mode value (%lu) is invalid.
Exceeded the limit on number of unique samplers usable in argument buffers (which is %u)
-[MTLDebugHeap validateHeapResourceOptions:isTexture:isIOSurface:]
The requested hazard tracking mode does not match the heap's mode
The requested CPU cache mode does not match the heap's mode
The requested storage mode is not compatible with the heap's mode
MTLResourceOptions options have unknown bits 0x%lx.
-[MTLDebugHeap maxAvailableSizeWithAlignment:]
aligment needs to be power of two, or zero.
-[MTLDebugHeap newBufferWithLength:options:]
Requested length %lu must not exceed heap size %lu.
newBufferWithLength:options: cannot be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options:offset: instead.
-[MTLDebugHeap newTextureWithDescriptor:]
newTextureWithDescriptor: cannot be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor:offset: instead.
-[MTLDebugHeap validateOffset:withRequirements:]
Cannot place resource at offset %lu extending beyond the heap size %lu (resource size %lu)
Cannot place resource at offset %lu which is not aligned to %lu bytes
-[MTLDebugHeap newBufferWithLength:options:offset:]
newBufferWithLength:options:offset: can only be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options: instead.
-[MTLDebugHeap newTextureWithDescriptor:offset:]
newTextureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor: instead.
oldestEvent
T^{HeapHistoryEvent=^{HeapHistoryEvent}^vB},N,V_oldestEvent
latestEvent
T^{HeapHistoryEvent=^{HeapHistoryEvent}^vB},N,V_latestEvent
debugDevice
T@"MTLDebugDevice",R,N,V_debugDevice
-[MTLDebugTexture dealloc]
usageRequested 0x%lx != usageRequired 0x%lx
-[MTLDebugTexture makeAliasable]
Memoryless textures cannot be made aliasable.
Texture Views created from Textures, that are backed by the Heap, cannot be made aliasable.
-[MTLDebugTexture newTextureViewWithPixelFormat:]
cannot create View from Memoryless texture.
texture usage (0x%02lx) doesn't specify MTLTextureUsagePixelFormatView (0x%02lx)
invalid pixelFormat.
texture view creation not allowed from frameBufferOnly textures.
-[MTLDebugTexture newTextureViewWithPixelFormat:textureType:levels:slices:]
-[MTLDebugTexture newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:]
-[MTLDebugTexture newCompressedTextureViewWithPixelFormat:textureType:level:slice:]
-[MTLDebugTexture setPurgeableState:]
T@"MTLTextureDescriptor",R,C,N,V_descriptor
offset
TQ,R,N,V_offset
bytesPerRow
TQ,R,N,V_bytesPerRow
bytesPerImage
TQ,R,N,V_bytesPerImage
plane
TQ,R,N,V_plane
isLinearTexture
TB,R,N,V_isLinearTexture
textureUsage
TI,N,V_textureUsage
_validateReplaceRegion
(size.width(%lu) * size.height(%lu) * size.depth(%lu))(%lu) must not be 0.
CPU access for textures with MTLResourceStorageModePrivate storage mode is disallowed.
CPU access for textures with MTLStorageModeMemoryless is disallowed.
texture must not be a framebufferOnly texture.
mipmapLevel(%lu) must be < [texture mipmapLevelCount](%lu).
(origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(origin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(origin.x + size.width)(%lu) must be <= width(%lu).
(origin.y + size.height)(%lu) must be <= height(%lu).
(origin.z + size.depth)(%lu) must be <= depth(%lu).
origin.x(%lu) must be a multiple of %s blockWidth(%lu).
origin.y(%lu) must be a multiple of %s blockHeight(%lu).
origin.z(%lu) must be a multiple of %s blockDepth(%lu).
origin.x must be 0 (full image) for %s.
origin.y must be 0 (full image) for %s.
origin.z must be 0 (full image) for %s.
size.width(%lu) must equal width(%lu) (full image) for %s.
size.height(%lu) must equal height(%lu) (full image) for %s.
size.depth(%lu) must equal depth(%lu) (full image) for %s.
rowBytes must be 0 for %s.
imageBytes must be 0 for %s.
rowBytes(%lu) must be >= (%lu).
imageBytes(%lu) must be >= (%lu).
rowBytes(%lu) must be a multiple of %s %s bytes(%lu).
block
pixel
imageBytes(%lu) must be a multiple of %s %s bytes(%lu).
CPU access for this texture with pixel format %s is disallowed.
_validateGetBytes
333?24UniqueMutexLockingPolicy
C12StringBuffer
12AppendBuffer
12BinaryBuffer
19ILayerLockingPolicy
20NoLayerLockingPolicy
Failed to instrument all instructions in vertex function '%s', some invalid loads or stores may be missed
Failed to instrument all instructions in fragment function '%s', some invalid loads or stores may be missed
Failed to instrument all instructions in compute function '%s', some invalid loads or stores may be missed
OOB %s: %s encoder: %s %s: %u, location: %u, offset: %llu 
MTLDebugIndirectComputeCommand
MTLGPUDebugRenderCommandEncoder
MTLToolsIndirectCommandBuffer
MTLIndirectCommandBufferSPI
MTLIndirectCommandBuffer
MTLResource
NSObject
MTLDebugResourceAccessTracker
MTLToolsBlitCommandEncoder
MTLBlitCommandEncoder
MTLCommandEncoder
MTLToolsFence
MTLFence
MTLCountersRenderCommandEncoder
MTLToolsBuffer
MTLBuffer
MTLToolsCommandBuffer
MTLCommandBufferSPI
MTLCommandBuffer
MTLParallelRenderCommandEncoder
MTLToolsCommandEncoder
MTLToolsCommandQueue
MTLCommandQueueSPI
MTLCommandQueue
MTLToolsHeap
MTLHeapSPI
MTLHeap
MTLToolsComputeCommandEncoder
MTLComputeCommandEncoderSPI
MTLComputeCommandEncoder
MTLToolsComputePipelineState
MTLComputePipelineStateSPI
MTLComputePipelineState
MTLToolsDepthStencilState
MTLDepthStencilStateSPI
MTLDepthStencilState
MTLToolsIndirectComputeCommand
MTLIndirectComputeCommandSPI
MTLIndirectComputeCommand
MTLGPUDebugDevice
MTLToolsDevice
MTLDeviceSPI
MTLDevice
MTLToolsFragmentRenderCommandEncoder
MTLFragmentRenderCommandEncoder
MTLToolsEvent
MTLEvent
MTLToolsSharedEvent
MTLSharedEvent
MTLToolsFunction
MTLFunctionSPI
MTLFunction
MTLToolsLibrary
MTLLibrarySPI
MTLLibrary
MTLDebugPipelineLibrary
MTLCountersComputeCommandEncoder
MTLGPUDebugRenderPipelineState
MTLToolsObject
MTLToolsParallelRenderCommandEncoder
MTLToolsRenderCommandEncoder
MTLRenderCommandEncoderSPI
MTLRenderCommandEncoder
MTLGPUDebugIndirectComputeCommand
MTLCountersTraceCommandEncoder
MTLCountersTraceBlitCommandEncoder
MTLCountersTraceComputeCommandEncoder
MTLCountersTraceRenderCommandEncoder
MTLCountersTraceResourceStateCommandEncoder
MTLCountersTraceCommandBuffer
MTLToolsRenderPipelineState
MTLRenderPipelineStateSPI
MTLRenderPipelineState
MTLToolsResource
MTLResourceSPI
MTLToolsResourceGroupSPI
MTLResourceGroupSPI
MTLGPUDebugIndirectRenderCommand
MTLToolsSamplerState
MTLSamplerState
MTLSamplerStateSPI
MTLToolsTexture
MTLTextureImplementation
MTLTextureSPI
MTLTexture
MTLToolsTextureLayout
MTLTextureLayout
MTLCountersParallelRenderCommandEncoder
MTLGPUDebugCommandBuffer
MTLGPUDebugBufferEncoder
MTLToolsPointerArray
MTLDebugBlitCommandEncoder
MTLDebugBufferMarker
MTLDebugBuffer
MTLGPUDebugCommandQueue
MTLDebugCommandBuffer
MTLToolsIndirectRenderCommand
MTLIndirectRenderCommandSPI
MTLIndirectRenderCommand
MTLCountersDevice
MTLGPUDebugFragmentRenderCommandEncoder
MTLGPUDebugComputePipelineState
MTLDebugCommandQueue
MTLDebugComputeCommandEncoder
MTLDebugComputePipelineState
MTLDebugIndirectCommandBuffer
MTLCountersCommandQueue
MTLToolsPipelineLibrary
MTLPipelineLibrarySPI
MTLPipelineLibrary
MTLToolsArgumentEncoder
MTLArgumentEncoderSPI
MTLArgumentEncoder
MTLDebugArgumentEncoder
MTLDebugDevice
MTLDebugDepthStencilState
MTLGPUDebugIndirectCommandBuffer
MTLDebugSharedEvent
MTLGPUDebugParallelRenderCommandEncoder
MTLDebugFragmentRenderCommandEncoder
MTLDebugFunction
MTLDebugLibrary
MTLDebugParallelRenderCommandEncoder
MTLDebugRenderCommandEncoder
MTLCountersCommandBuffer
MTLDebugResource
MTLGPUDebugComputeCommandEncoder
MTLDebugIndirectRenderCommand
MTLDebugRenderPipelineState
MTLDebugSamplerState
MTLDebugHeap
MTLDebugTexture
MTLDebugTextureLayout
MTLCountersBlitCommandEncoder
initWithBaseObject:parent:
dealloc
lockingPolicy
inheritPipelineState
baseObject
supportIndirectCommandBuffers
setComputePipelineState:
maxKernelBufferBindCount
inheritBuffers
setKernelBuffer:offset:atIndex:
commandTypes
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
initWithBaseObject:descriptor:indexCount:indirectCommandBuffer:
index
indirectCommandBuffer
_desc
_index
_iCB
initWithRenderCommandEncoder:parent:descriptor:
setVertexBytes:length:atIndex:
setFragmentBytes:length:atIndex:
setTileBytes:length:atIndex:
commandBuffer
onDraw
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
dispatchThreadsPerTile:
onExecuteWithRenderEncoder:
executeCommandsInBuffer:withRange:
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
setRenderPipelineState:
onEncoderEnd:type:
endEncoding
initWithRenderCommandEncoder:commandBuffer:descriptor:encoderID:
initWithRenderCommandEncoder:parallelEncoder:descriptor:encoderID:
setVertexBuffer:offset:atIndex:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setTileBuffer:offset:atIndex:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
.cxx_construct
_vertexBuffers
_fragmentBuffers
_tileBuffers
_pipelineStateID
_encoderID
_currentDrawID
length
useResource:usage:
addRetainedObject:
setBytes:length:
visitIndirectCommandBuffer:
visitObjects:withVisitor:
initWithOptions:
indirectComputeCommandAtIndex:
addPointer:
indirectRenderCommandAtIndex:
size
storageMode
getHeader:headerSize:
resetWithRange:
uniqueIdentifier
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
setPurgeableState:
makeAliasable
isAliasable
label
setLabel:
device
cpuCacheMode
hazardTrackingMode
resourceOptions
heap
heapOffset
allocatedSize
resourceIndex
setResourceIndex:
acceptVisitor:
indirectComputeCommand
indirectRenderCommand
_indirectComputeCommand
_indirectRenderCommand
init
reset
countByEnumeratingWithState:objects:count:
isActive
type
access
accessedByGPU
addObject:
textureUsage
setTextureUsage:
descriptor
realRootResource
isRasterizationEnabled
recordResourceAccessesForColorAttachmentsWithDescriptor:renderPipelineState:forEndEncoding:deferredAttachments:
isDepthWriteEnabled
recordResourceAccessesForDepthAttachmentWithDescriptor:forEndEncoding:deferredAttachments:
frontFaceStencil
backFaceStencil
readMask
writeMask
recordResourceAccessesForStencilAttachmentWithDescriptor:forEndEncoding:deferredAttachments:
colorAttachments
_descriptorAtIndex:
_descriptorPrivate
recordResourceAccessesForAttachment:withStoreAction:
_recordResourceAccessesForRenderTargetTexture:
resourceTrackingRecordAccessesToArguments:bufferFuncArgsPtr:textureFuncArgsPtr:buffersBoundForWrite:texturesBoundForWrite:
hasValidViewports:viewportCount:scissorRects:scissorRectCount:
recordRenderTargetAccessesForEndEncoding:descriptor:renderPipelineState:depthStencilState:deferredAttachments:
processDeferredAttachments:
accessedBy:frame:accessTypes:
conclude
_accessedByGPUFrameCount
_accessedByCPUFrameCount
_prevFrameNumGPUAccessed
_prevFrameNumCPUAccessed
_firstAccessFrameByCPU
_stateMask
visitBlitCommandEncoder:
updateFence:
waitForFence:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
generateMipmapsForTexture:
fillBuffer:range:value:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
resetCommandsInBuffer:withRange:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
optimizeIndirectCommandBuffer:withRange:
insertDebugSignpost:
pushDebugGroup:
popDebugGroup
synchronizeResource:
synchronizeTexture:slice:level:
visitFence:
traceBuffer
renderCommandEncoder
setVertexTexture:atIndex:
setVertexTextures:withRange:
setVertexSamplerState:atIndex:
setVertexSamplerStates:withRange:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setFragmentSamplerState:atIndex:
setFragmentSamplerStates:withRange:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:
setTileTexture:atIndex:
setTileTextures:withRange:
setTileSamplerState:atIndex:
setTileSamplerStates:withRange:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setThreadgroupMemoryLength:offset:atIndex:
useResources:count:usage:
useResource:usage:stages:
useResources:count:usage:stages:
useHeap:
useHeaps:count:
setViewport:
setViewports:count:
setFrontFacingWinding:
setCullMode:
setDepthClipMode:
setLineWidth:
setDepthBias:slopeScale:clamp:
setScissorRect:
setScissorRects:count:
setTriangleFillMode:
setDepthStencilState:
setStencilReferenceValue:
setStencilFrontReferenceValue:backReferenceValue:
setColorStoreAction:atIndex:
setDepthStoreAction:
setStencilStoreAction:
setVisibilityResultMode:offset:
setBlendColorRed:green:blue:alpha:
setColorResolveTexture:slice:depthPlane:level:atIndex:
setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:
setDepthResolveTexture:slice:depthPlane:level:
setDepthResolveTexture:slice:depthPlane:level:yInvert:
setStencilResolveTexture:slice:depthPlane:level:
setStencilResolveTexture:slice:depthPlane:level:yInvert:
updateFence:afterStages:
waitForFence:beforeStages:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorScale:
memoryBarrierWithScope:afterStages:beforeStages:
memoryBarrierWithResources:count:afterStages:beforeStages:
_traceEncoder
stringByPaddingToLength:withString:startingAtIndex:
formattedDescription:
arrayWithObjects:count:
componentsJoinedByString:
stringWithFormat:
visitBuffer:
contents
didModifyRange:
newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:
addDebugMarker:range:
removeAllDebugMarkers
newTextureWithDescriptor:offset:bytesPerRow:
initWithBaseObject:parent:buffer:
iosurface
textures
_textures
retainedReferences
userDictionary
setObject:forKeyedSubscript:
removeObjectForKey:
addCompletedHandler:
clearRetainedObjects
setRetainedObjectsLock:
visitCommandBuffer:
removeAllObjects
originalObject
commit
commitAndWaitUntilSubmitted
debugCommandEncoder
GPUStartTime
GPUEndTime
globalTraceObjectID
enqueue
presentDrawable:
presentDrawable:atTime:
presentDrawable:afterMinimumDuration:
waitUntilScheduled
waitUntilCompleted
status
error
blitCommandEncoder
computeCommandEncoder
kernelStartTime
kernelEndTime
debugBufferContentsWithLength:
copy
visibilityResultBuffer
setVisibilityResultBuffer:
texture
objectAtIndexedSubscript:
setTexture:
resolveTexture
setResolveTexture:
depthAttachment
stencilAttachment
addScheduledHandler:
unwrapMTLRenderPassDescriptor:
renderCommandEncoderWithDescriptor:
fragmentRenderCommandEncoderWithDescriptor:
sampledFragmentRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:
parallelRenderCommandEncoderWithDescriptor:
sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:
computeCommandEncoderWithDispatchType:
encodeSignalEvent:value:
encodeWaitForEvent:value:
encodeWaitForEvent:value:timeout:
addPurgedResource:
addPurgedHeap:
sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:
isProfilingEnabled
setProfilingEnabled:
profilingResults
getListIndex
addSynchronizationNotification:
executeSynchronizationNotifications:
executeSynchronizationNotifications:scope:resources:count:
setResourceGroups:count:
dropResourceGroups:count:
encodeCacheHintTag:resourceGroups:count:
encodeCacheHintFinalize:resourceGroups:count:
setProtectionOptions:
protectionOptions
commandQueue
commitAndHold
setListIndex:
willEncodeSignalEvent:value:writeableResources:
retainedObjects
renderCommandEncoders
computeCommandEncoders
blitCommandEncoders
parallelRenderCommandEncoders
fragmentRenderCommandEncoders
resourceStateCommandEncoders
retainedObjectsLock
_flags
_retainedObjects
_renderCommandEncoders
_computeCommandEncoders
_blitCommandEncoders
_parallelRenderCommandEncoders
_fragmentRenderCommandEncoders
_resourceStateCommandEncoders
_retainedObjectsLock
initWithBaseObject:parent:lockingPolicy:
filterCounterRangeWithFirstBatch:lastBatch:filterIndex:
_commandBuffer
visitCommandQueue:
commandBufferWithUnretainedReferences
insertDebugCaptureBoundary
getGPUPriority
setGPUPriority:
setGPUPriority:offset:
getBackgroundGPUPriority
setBackgroundGPUPriority:
setBackgroundGPUPriority:offset:
maxCommandBufferCount
backgroundTrackingPID
setBackgroundTrackingPID:
finish
skipRender
setSkipRender:
executionEnabled
setExecutionEnabled:
setCompletionQueue:
setSubmissionQueue:
isOpenGLQueue
setIsOpenGLQueue:
requestCounters:
objectForKeyedSubscript:
addPerfSampleHandler:
requestCounters:withIndex:
subdivideCounterList:
qosLevel
commitQueue
commitSynchronously
completionQueue
disableCrossQueueHazardTracking
availableCounters
getRequestedCounters
isStatEnabled
setStatEnabled:
getStatOptions
setStatOptions:
getStatLocations
setStatLocations:
counterInfo
availableCountersAndDict
commandBuffers
_commandBuffers
visitHeap:
unfilteredResourceOptions
usedSize
maxAvailableSizeWithAlignment:
currentAllocatedSize
initWithBaseObject:parent:heap:
newBufferWithLength:options:
_wrapBuffer:
newBufferWithLength:options:offset:
newTextureWithDescriptor:
_wrapTexture:
newTextureWithDescriptor:offset:
buffers
_buffers
visitComputeCommandEncoder:
setBytes:length:atIndex:
setBufferOffset:atIndex:
setBuffer:offset:atIndex:
setBuffers:offsets:withRange:
setTexture:atIndex:
setTextures:withRange:
setSamplerState:atIndex:
setSamplerStates:withRange:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setThreadgroupMemoryLength:atIndex:
dispatchThreadgroups:threadsPerThreadgroup:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
setImageblockWidth:height:
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
newKernelDebugInfo
dispatchType
memoryBarrierWithScope:
memoryBarrierWithResources:count:
visitComputePipelineState:
maxTotalThreadsPerThreadgroup
threadExecutionWidth
staticThreadgroupMemoryLength
imageblockMemoryLengthForDimensions:
debugInstrumentationData
_function
visitDepthStencilState:
depthStencilStates
removeObjectAssociatedWithBaseObject:
readsDepth
writesDepth
readsStencil
writesStencil
visitIndirectComputeCommand:
getThreadgroupMemoryLengthAtIndex:
getStageInRegion
hasBarrier
setBarrier
clearBarrier
dispatchThreadgroupsArguments
dispatchThreadsArguments
getPipelineStateUniqueIdentifier
getKernelBufferAtIndex:
getCommandType
setDataType:
setArrayLength:
setIndex:
setAccess:
newArgumentEncoderWithArguments:
vertexDebugInstrumentationData
hasBacktrackingFailures
vertexFunction
name
UTF8String
fragmentDebugInstrumentationData
fragmentFunction
computeFunction
newCommandQueueWithDescriptor:
initWithCommandQueue:device:
commandQueueDescriptor
setMaxCommandBufferCount:
newRenderPipelineStateWithDescriptor:options:reflection:error:
_modifyCompileOptions:
setForceSoftwareVertexFetch:
unwrapMTLRenderPipelineDescriptor:
initWithRenderPipelineState:descriptor:reflection:device:
onRenderPipelineCreated:
newRenderPipelineStateWithDescriptor:options:completionHandler:
unwrapMTLTileRenderPipelineDescriptor:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
initWithRenderPipelineState:tileDescriptor:reflection:device:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newComputePipelineStateWithDescriptor:options:reflection:error:
unwrapMTLComputePipelineDescriptor:
initWithComputePipelineState:descriptor:reflection:device:
onComputePipelineCreated:
newComputePipelineStateWithDescriptor:options:completionHandler:
setComputeFunction:
newComputePipelineStateWithDescriptor:error:
newComputePipelineStateWithDescriptor:completionHandler:
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
initWithIndirectCommandBuffer:descriptor:maxCommandCount:resourceOptions:device:
additionalCompilerArguments
setAdditionalCompilerArguments:
newLibraryWithSource:options:error:
newStageBufferArgumentEncoder
newStageArgumentBuffer
newCommandQueue
newCommandQueueWithMaxCommandBufferCount:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:error:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
.cxx_destruct
bufferHeap
_argumentDescriptors
_enableBoundsChecking
_setDeviceWrapper:
visitDevice:
newFunctionWithGLIR:functionType:
initWithBaseObject:parent:functions:
newFunctionWithGLIR:inputsDescription:functionType:
shaderDebugInfoCaching
setShaderDebugInfoCaching:
mapShaderSampleBufferWithBuffer:capacity:size:
unmapShaderSampleBuffer
reportLeaks
registryID
vendorName
familyName
productName
areGPUAssertionsEnabled
setGPUAssertionsEnabled:
isResourceIndirectionEnabled
setResourceIndirectionEnabled:
currentUtilityBufferIndex
setCurrentUtilityBufferIndex:
utilityBuffers
setUtilityBuffers:
isUtilityBufferRequired
useDeviceResourceTableForType:
createNewUtilityBuffer
utilityBufferForComputeCommandEncoder:
utilityBufferForRenderCommandEncoder:
newBufferWithLength:options:atResourceIndex:
newBufferWithBytes:length:options:atResourceIndex:
newBufferWithBytesNoCopy:length:options:atResourceIndex:deallocator:
requiresIndirectionForAllResourceTypes
addBufferToGlobalResourceTable:
addTextureToGlobalResourceTable:
addSamplerStateToGlobalResourceTable:
addComputePipelineStateToGlobalResourceTable:
addRenderPipelineStateToGlobalResourceTable:
addIndirectCommandBufferToGlobalResourceTable:
removeResourceFromGlobalResourceTable:resourceType:
indirectBufferAddressForResourceIndex:offset:
resourceIndexFromIndirectBufferAddress:
offsetFromIndirectBufferAddress:
maxThreadsPerThreadgroup
isLowPower
isHeadless
isRemovable
hasUnifiedMemory
recommendedMaxWorkingSetSize
sharedMemorySize
dedicatedMemorySize
isDepth24Stencil8PixelFormatSupported
unloadShaderCaches
libraryCacheStats
pipelineCacheStats
copyShaderCacheToPath:
getShaderCacheKeys
compilerPropagatesThreadPriority:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newIndirectCommandBufferWithDescriptor:maxCount:options:
newIndirectRenderCommandEncoderWithBuffer:
newIndirectComputeCommandEncoderWithBuffer:
newTextureWithBytesNoCopy:length:descriptor:deallocator:
newDepthStencilStateWithDescriptor:
newObjectAssociatedWithBaseObject:usingBlock:
newSamplerStateWithDescriptor:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newLibraryWithFile:error:
newLibraryWithURL:error:
newLibraryWithData:error:
startCollectingPipelineDescriptors
endCollectingPipelineDescriptors
newPipelineLibraryWithFilePath:error:
serializeRenderPipelineDescriptor:
newRenderPipelineDescriptorWithSerializedData:deserializationContext:
newComputePipelineDescriptorWithSerializedData:deserializationContext:
serializeStructType:
heapTextureSizeAndAlignWithDescriptor:
heapBufferSizeAndAlignWithLength:options:
newHeapWithDescriptor:
newFence
indirectArgumentBufferCapabilities
newIndirectArgumentBufferLayoutWithStructType:
newIndirectArgumentEncoderWithLayout:
newArgumentEncoderWithLayout:
maxThreadgroupMemoryLength
maxArgumentBufferSamplerCount
setVertexFunction:
setFragmentFunction:
pipelineLibrary
setPipelineLibrary:
tileFunction
setTileFunction:
newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newFunctionWithName:
newLibraryWithCIFilters:imageFilterFunctionInfo:error:
newLibraryWithSource:options:completionHandler:
deviceSupportsFeatureSet:
deviceOrFeatureProfileSupportsFeatureSet:
supportsFeatureSet:
supportsFamily:
supportsTextureSampleCount:
supportsSampleCount:
minLinearTextureAlignmentForPixelFormat:
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
areProgrammableSamplePositionsSupported
getDefaultSamplePositions:count:
_deviceWrapper
newBufferWithIOSurface:
resourcePatchingTypeForResourceType:
reserveResourceIndicesForResourceType:indices:indexCount:
halfFPConfig
singleFPConfig
doubleFPConfig
featureProfile
limits
supportPriorityBand
maxColorAttachments
maxVertexAttributes
maxVertexBuffers
maxVertexTextures
maxVertexSamplers
maxVertexInlineDataSize
maxInterpolants
maxFragmentBuffers
maxFragmentTextures
maxFragmentSamplers
maxFragmentInlineDataSize
maxComputeBuffers
maxComputeTextures
maxComputeSamplers
maxComputeInlineDataSize
maxComputeLocalMemorySizes
maxTotalComputeThreadsPerThreadgroup
maxComputeThreadgroupMemory
maxLineWidth
maxPointSize
maxVisibilityQueryOffset
minConstantBufferAlignmentBytes
minBufferNoCopyAlignmentBytes
maxTextureWidth1D
maxTextureWidth2D
maxTextureHeight2D
maxTextureWidth3D
maxTextureHeight3D
maxTextureDepth3D
maxTextureDimensionCube
maxTextureLayers
linearTextureAlignmentBytes
iosurfaceTextureAlignmentBytes
iosurfaceReadOnlyTextureAlignmentBytes
deviceLinearTextureAlignmentBytes
deviceLinearReadOnlyTextureAlignmentBytes
maxFunctionConstantIndices
maxComputeThreadgroupMemoryAlignmentBytes
maxInterpolatedComponents
maxTessellationFactor
maxIndirectBuffers
maxIndirectTextures
maxIndirectSamplers
maxIndirectSamplersPerDevice
maxViewportCount
maxCustomSamplePositions
maxTextureBufferWidth
maxComputeAttributes
maxFramebufferStorageBits
linearTextureArrayAlignmentBytes
linearTextureArrayAlignmentSlice
maxTileBuffers
maxTileTextures
maxTileSamplers
maxTileInlineDataSize
minTilePixels
maxBufferLength
readWriteTextureSupport
argumentBuffersSupport
areRasterOrderGroupsSupported
isQuadDataSharingSupported
newResourceGroupFromResources:count:
metalAssertionsEnabled
setMetalAssertionsEnabled:
newTextureWithDescriptor:iosurface:plane:
newEvent
newSharedEvent
newSharedEventWithMachPort:
newSharedEventWithHandle:
newTextureLayoutWithDescriptor:isHeapOrBufferBacked:
setupMPSFunctionTable:
allowLibrariesFromOtherPlatforms
setResourcesPurgeableState:newState:oldState:count:
isPlacementHeapSupported
supportsQuadReduction
supportsBufferlessClientStorageTexture
supportsArgumentBuffersTier2
supportsReadWriteTextureArgumentsTier2
supportsProgrammableSamplePositions
supportsBCTextureCompression
supports3DBCTextures
supportsLargeFramebufferConfigs
supportsCustomBorderColor
supportsSamplerAddressModeClampToHalfBorder
supports32bpcMSAATextures
supportsPlacementHeaps
supportsOpenCLTextureWriteSwizzles
supportsLimitedYUVFormats
supportsNonPrivateDepthStencilTextures
supportsNonPrivateMSAATextures
supportsLinearTextureFromSharedBuffer
supportsPipelineLibraries
supportsFragmentOnlyEncoders
supportsBufferWithIOSurface
supportsProgrammableBlending
supportsRenderToLinearTextures
supportsMemorylessRenderTargets
supportsFastMathInfNaNPropagation
supportsInvariantVertexPosition
supportsShaderLODAverage
supportsRelaxedTextureViewRequirements
supportsSeparateDepthStencil
supportsGPUStatistics
supportsASTCTextureCompression
supportsExtendedYUVFormats
supportsPublicXR10Formats
supportsSRGBwrites
supportsDepthClipMode
supportsPacked32TextureBufferWrites
supports3DASTCTextures
supportsExtendedXR10Formats
supportsFragmentBufferWrites
supportsCountingOcclusionQuery
supportsBaseVertexInstanceDrawing
supportsIndirectDrawAndDispatch
supportsTessellation
supportsReadWriteBufferArguments
supportsArrayOfTextures
supportsArrayOfSamplers
supportsCombinedMSAAStoreAndResolveAction
supportsMutableTier1ArgumentBuffers
supportsSamplerCompareFunction
supportsMSAADepthResolve
supportsMSAAStencilResolve
supportsMSAADepthResolveFilter
supportsGFXIndirectCommandBuffers
supportsCMPIndirectCommandBuffers
supportsIndirectStageInRegion
supportsIndirectTextures
supportsNorm16BCubicFiltering
supportsTextureOutOfBoundsReads
supportsTextureSwizzle
supportsAlphaYUVFormats
supportsMemoryOrderAtomics
supportsQuadGroup
supportsRenderTextureWrites
supportsImageBlocks
supportsTileShaders
supportsImageBlockSampleCoverageControl
supportsNativeHardwareFP16
supportsPostDepthCoverage
supportsMipLevelsSmallerThanBlockSize
supportsNonUniformThreadgroupSize
supportsReadWriteTextureArguments
supportsReadWriteTextureCubeArguments
supportsTextureCubeArray
supportsQuadShufflesAndBroadcast
supportsConcurrentComputeDispatch
supportsRenderPassWithoutRenderTarget
supportsRasterOrderGroups
supportsLinearTexture2DArray
supportsNonSquareTileShaders
supportsSeparateVisibilityAndShadingRate
supports2DLinearTexArraySPI
supportsLayeredRendering
supportsViewportAndScissorArray
supportsIndirectTessellation
supportsMSAAStencilResolveFilter
supportsStencilFeedback
supportsFP32TessFactors
supportsSIMDGroup
supportsShaderMinLODClamp
supportsSIMDShufflesAndBroadcast
supportsBlackOrWhiteSamplerBorderColors
supportsMirrorClampToEdgeSamplerMode
supportsSIMDReduction
supportsDepthClipModeClampExtended
supportsTexture2DMultisampleArray
supportsForceSeamsOnCubemaps
supportsFloat16BCubicFiltering
registerDevices
supportsPrimitiveType:
indirectArgumentBufferDecodingData
setIndirectArgumentBufferDecodingData:
newIndirectArgumentEncoderWithArguments:
newComputePipelineStateWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithCIFiltersForComputePipeline:imageFilterFunctionInfo:error:
startCollectingPipelineDescriptorsUsingPrefixForNames:
serializeComputePipelineDescriptor:
serializeStructType:version:
targetDeviceInfo
eventSignaled:value:
isIntegrated
memorySize
heaps
textureLayouts
samplers
commandQueues
libraries
pipelineStates
computePipelineStates
functions
events
pipelineLibraries
fences
indirectArgumentEncoders
argumentEncoders
indirectCommandBuffers
resourceGroups
_integrated
_memorySize
_heaps
_depthStencilStates
_textureLayouts
_samplers
_commandQueues
_libraries
_pipelineStates
_computePipelineStates
_functions
_events
_pipelineLibraries
_fences
_indirectArgumentEncoders
_argumentEncoders
_indirectCommandBuffers
_resourceGroups
visitFragmentRenderCommandEncoder:
setColorStoreActionOptions:atIndex:
setDepthStoreActionOptions:
setStencilStoreActionOptions:
drawTrianglesWithPositions:vertexCount:triangleIndices:triangleCount:
drawTrianglesWithPositions:vertexCount:vertexVaryings:varyingCountPerVertex:triangleIndices:triangleCount:
drawTrianglesWithPositions:vertexCount:vertexVaryings:varyingCountPerVertex:
visitEvent:
notifyListener:atValue:block:
newSharedEventHandle
signaledValue
setSignaledValue:
visitFunction:
functionType
vertexAttributes
returnType
arguments
stageInputAttributes
filePath
lineNumber
unpackedFilePath
renderTargetArrayIndexType
functionConstantsDictionary
patchType
patchControlPointCount
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:reflection:
bitcodeData
reflectionWithOptions:
reflectionWithOptions:completionHandler:
bitCodeHash
newFunctionWithPluginData:bitcodeType:
visitLibrary:
overrideTriple
setOverrideTriple:
newExternFunctionWithName:
newFunctionWithName:constantValues:error:
newFunctionWithName:constantValues:pipelineLibrary:error:
objectAssociatedWithBaseObject:usingBlock:
newFunctionWithName:constantValues:completionHandler:
newFunctionWithName:constantValues:pipelineLibrary:completionHandler:
functionNames
externFunctionNames
newComputePipelineStateWithName:options:reflection:error:
newComputePipelineDescriptorWithName:error:
initWithComputePipelineState:reflection:parent:descriptor:
traceBufferIndex
validateTraceBuffer:maxBufferCount:options:
newRenderPipelineStateWithName:options:reflection:error:
newRenderPipelineDescriptorWithName:error:
initWithPipelineState:reflection:parent:descriptor:
initWithLibrary:parent:filePath:
setFilePath:
_filePath
setImageBlockWidth:height:
initWithComputeCommandEncoder:commandBuffer:
vertexLibrary
fragmentLibrary
reflection
_descriptor
_tileDescriptor
_reflection
enumeratePointersUsingBlock:
removePointer:
doesNotRecognizeSelector:
dispatchQueue
setLockingPolicy:
baseObjectWithClass:
setOriginalObject:
parent
strongParent
setBaseObject:
tracker
setTracker:
_parent
_tracker
_baseObject
_device
_lockingPolicy
visitParallelRenderCommandEncoder:
isMemorylessRender
visitRenderCommandEncoder:
setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setDepthClipModeSPI:
setCommandDataCorruptModeSPI:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setDepthCleared
setStencilCleared
setAlphaTestReferenceValue:
setPointSize:
setClipPlane:p2:p3:p4:atIndex:
setViewportTransformEnabled:
setProvokingVertexMode:
setPrimitiveRestartEnabled:
setPrimitiveRestartEnabled:index:
setTriangleFrontFillMode:backFillMode:
setTransformFeedbackState:
addSplitHandler:
useRenderPipelineState:
useRenderPipelineStates:count:
useHeap:stages:
useHeaps:count:stages:
tileWidth
tileHeight
textureBarrier
setColorResolveTexture:slice:depthPlane:level:atIndex:yInvert:
setBuffer:offset:atIndex:forStage:commandIndex:
onDispatch
initWithIndirectComputeCommand:commandIndex:indirectCommandBuffer:
_commandIndex
init:flags:
flags
segment
_stream
_segment
init:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
resetTextureAccessCounters:region:mipLevel:slice:
objectForKey:
unsignedIntegerValue
count
tracePath
stringByAppendingPathComponent:
writeToFile:options:error:
localizedDescription
resourceStateCommandEncoder
appendSamples:length:
saveCommandBuffer:queue:profilingResults:
_commands
_encoders
_samples
_timestamp
dataWithLength:
bytes
setLength:
base64EncodedDataWithOptions:
dataWithBytesNoCopy:length:freeWhenDone:
lengthOfBytesUsingEncoding:
visitRenderPipelineState:
threadgroupSizeMatchesTileSize
newVertexShaderDebugInfo
newFragmentShaderDebugInfo
imageblockSampleLength
isPurgeable
responsibleProcess
setResponsibleProcess:
sharedAllocationInfo
cachedAllocationInfo
doesAliasResource:
doesAliasAllResources:count:
doesAliasAnyResources:count:
isComplete
waitUntilComplete
validateCPUReadable
validateCPUWriteable
options
_options
_heap
containsResource:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
initWithIndirectRenderCommand:commandIndex:indirectCommandBuffer:
visitSamplerState:
buffer
visitTexture:
parentTexture
parentRelativeLevel
parentRelativeSlice
bufferOffset
bufferBytesPerRow
swizzle
swizzleKey
isCompressed
compressionFeedback
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
textureType
pixelFormat
usage
width
height
depth
mipmapLevelCount
sampleCount
arrayLength
isFramebufferOnly
allowGPUOptimizedContents
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:options:
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:options:
newTextureViewWithPixelFormat:
initWithBaseObject:parent:parentTexture:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newCompressedTextureViewWithPixelFormat:textureType:level:slice:
canGenerateMipmapLevels
generateMipmapLevel:slice:
rotation
iosurfacePlane
numFaces
isDrawable
getBytes:bytesPerRow:fromRegion:mipmapLevel:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
rootResource
copyFromSlice:mipmapLevel:origin:size:toPixels:rowBytes:imageBytes:
copyFromPixels:rowBytes:imageBytes:toSlice:mipmapLevel:origin:size:
views
_views
_parentTexture
_buffer
alignment
copyGranularity
watermark
visitTextureLayout:
initializeTextureMemory:
copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:
copyFromTextureMemory:textureSlice:textureLevel:textureRegion:toLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:
finalizeTextureMemory:
sampledRenderCommandEncoderWithProgramInfoBuffer:capacity:
initWithBaseRenderPass:commandBuffer:descriptor:
_newReportBuffer
_temporaryBufferWithLength:
vertexArguments
fragmentArguments
debugLocationForID:
_encodeReportBuffer:type:
encodedLength
setArgumentBuffer:offset:
_allocReportEntryStorageForType:
onEncoderBegin:type:
initWithParallelRenderCommandEncoder:parent:descriptor:encoderID:
initWithComputeCommandEncoder:parent:encoderID:
initWithFragmentRenderCommandEncoder:commandBuffer:descriptor:encoderID:
_checkReportBuffers
encodeBuffers:offsets:withRange:resultOffset:
initWithCommandBuffer:commandQueue:
_stageArgumentEncoder
_vertexComputeReportBuffer
_vertexComputeReportOffset
_fragmentReportBuffer
_fragmentReportOffset
_usedBuffers
_currentPooledBuffer
_currentPooledBufferOffset
_currentEncoderID
_currentReportID
_reportBufferList
_reportEntryList
_encoderLabels
_allocationLock
_addPointer:
_objectAssociatedWithBaseObject:usingBlock:
_pointerAdditions
_pointerSet
_semaphore
_setDefaults
internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:move:
resourceTrackingEnabled
_resourceTrackingRecordBlitFromTex:toTex:
cStringUsingEncoding:
validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
_resourceTrackingRecordBlitFromBuf:toTex:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
_resourceTrackingRecordBlitFromTex:toBuf:
trackUseResource:usage:
optimizedRangeList
rangeValue
valueWithRange:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceSize:toTexture:destinationSlice:destinationLevel:options:sliceCount:levelCount:
initWithBlitCommandEncoder:commandBuffer:
_resourceTrackingRecordBlitFromBuf:toBuf:
canDealloc
canEndEncoding
hasEndEncoding
updatedFences
string
appendString:
range
setRange:
_label
_range
_initResourceTrackingWithDevice:
resourceTrackingChecksummingForceAll
resourceTrackingChecksummingEnabled
initWithBuffer:device:options:
checksumBuffer:
removeResourceFromHistory:
hasTrackedMakeAliasable
addResourceToHistory:madeAliasable:
setHasTrackedMakeAliasable:
initWithBaseTexture:device:buffer:descriptor:offset:bytesPerRow:
initWithBaseTexture:device:buffer:descriptor:offset:bytesPerRow:bytesPerImage:
accessedByCPU
indirectCommandBufferDescriptor
frameNum
initWithBuffer:heap:device:options:
initWithBuffer:device:bytes:options:
initWithIndirectCommandBuffer:descriptor:maxCount:device:options:
resourceUsage
copyDebugMarkers
blitManagedToPrivate
blitManagedToShared
common
pointer
purgeableState
purgeableStateHasBeenSet
maxIndirectCommandCount
isContentsPointerExposed
checksum
setChecksum:
isContentExposedToCPU
setIsContentExposedToCPU:
_common
_length
_resourceAccessTracker
_debugDevice
_debugMarkers
_purgeableStateHasBeenSet
_isContentsPointerExposed
_isContentExposedToCPU
_maxIndirectCommandCount
_checksum
_pointer
_purgeableState
_indirectCommandBufferDescriptor
complainAboutSloppyTextureUsage
_tracePath
releaseWritableResourcesForValue:
_trackTexture:
unionSet:
isCommitted
storeAction
_trackRenderPassAttachmentDescriptor:
initWithFragmentRenderCommandEncoder:parent:descriptor:
bufferChecksummedInFrame:
isStandardEvent
setWritableResources:forValue:
sharedListener
retainWritableResourcesForValue:
trackUseResources:count:usage:
resourceTrackingRecordAccessesToArguments:bufferFuncArgsPtr:textureFuncArgsPtr:
trackRenderPassDescriptor:
onParallelRenderCommanderEndEncoding
validateStoreLoadTransition:atIndex:renderTargetArrayLength:
_currentEncoder
_buffersBoundForWrite
_texturesBoundForWrite
_unsignaledResources
_boundForWriteLockingPolicy
_waitEvents
_attachmentSet
_prevAttachments
_currAttachments
renderTargetArrayLength
requireUsage:
clearDepth
threadgroupMemoryLength
initWithFormat:
null
visitIndirectRenderCommand:
drawArguments
drawIndexedArguments
drawIndexedPatchesArguments
drawPatchesArguments
getTessellationFactorArguments
getFragmentBufferAtIndex:
getVertexBufferAtIndex:
_newRenderPipelineStateWithTileDescriptor:options:reflection:error:
_newRenderPipelineStateWithTileDescriptor:options:completionHandler:
arrayWithCapacity:
addObjectsFromArray:
threadGroupSizeIsMultipleOfThreadExecutionWidth
_validateThreadsPerThreadgroup:
function
validateStageInRegion:
_resourceTrackingRecordDispatchAccesses
_validateAllFunctionArguments
computePipelineState
enumerateBuffersUsingBlock:
enumerateTexturesUsingBlock:
enumerateSamplersUsingBlock:
enumerateThreadgroupMemoryLengthsUsingBlock:
_threadgroupMemoryLengths
_imageBlockSize
_limits
canSetComputePipelineState
hasSetComputePipelineState
hasSetStageInRegion
stageInRegion
hasIndirectSetStageInRegion
_computePipelineState
builtInArguments
builtInType
bufferAlignment
bufferDataSize
threadgroupMemoryDataSize
textureDataType
builtInDataType
getParameter:
setImageFilterFunctions:imageFilterFunctionInfo:
imageFilterFunctions
imageFilterFunctionInfo
_maxThreadPositionInGrid
_maxThreadsPerGrid
_maxThreadPositionInThreadgroup
_maxThreadIndexInThreadgroup
_maxThreadsPerThreadgroup
_maxThreadgroupPositionInGrid
_maxThreadgroupsPerGrid
_maxStageInGridSize
_maxStageInGridOrigin
_imageFilterFunctions
_imageFilterFunctionInfo
array
initWithIndirectCommandBuffer:device:descriptor:maxCommandCount:options:
_optimizedRangeList
_maxCommandCount
isRender
stringWithUTF8String:
stringByStandardizingPath
defaultManager
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
componentsSeparatedByString:
containsObject:
visitPipelineLibrary:
pipelineNames
disableRunTimeCompilation
setDisableRunTimeCompilation:
pipelineCache
functionCache
visitArgumentEncoder:
constantDataAtIndex:
layout
setArgumentBuffer:startOffset:arrayElement:
setRenderPipelineState:atIndex:
setComputePipelineState:atIndex:
setIndirectCommandBuffer:atIndex:
newArgumentEncoderForBufferAtIndex:
setRenderPipelineStates:withRange:
setComputePipelineStates:withRange:
setIndirectCommandBuffers:withRange:
elementType
elementStructType
elementArrayType
members
indirectArgumentIndex
dataType
structType
arrayType
pointerType
elementIsArgumentBuffer
setArgumentBuffer:startOffset:elementIndex:
supportArgumentBuffers
initWithBaseObject:structType:parent:
_currentBuffer
_currentOffset
_reflectionParser
initWithHeap:device:
validateResourceOptions:isTexture:isIOSurface:
validateNewBufferArgs:options:
newArgumentEncoderWithArguments:structType:
initWithBaseTexture:device:descriptor:
initWithBaseDepthStencilState:device:descriptor:
validateMemorylessResource:
initWithBaseSamplerState:device:descriptor:
pathForResource:ofType:
initWithLibrary:parent:type:code:options:
_newRenderPipelineStateWithDescriptor:options:reflection:error:
_newRenderPipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithDescriptor:options:reflection:error:
_newComputePipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithFunction:options:reflection:error:
_newComputePipelineStateWithFunction:options:completionHandler:
initWithPipelineState:reflection:parent:tileDescriptor:
arrayWithArray:
fileSystemRepresentation
initWithUTF8String:
initWithBaseTexture:device:descriptor:plane:
_resourceTrackingChecksummingEndOfFrame
initWithBaseTextureLayout:device:descriptor:
_newSharedEventWithParent:
setIsStandardEvent:
notifySamplerStateDeallocated:
resourceTrackingEndOfFrame
overrideResourceTrackingEnabled:
restoreResourceTrackingEnabled
setFrameNum:
_prevResourceTrackingEnabled
_buffersAlreadyChecksummedInFrame
_argumentBufferSamplers
_resourceTrackingEnabled
_resourceTrackingChecksummingEnabled
_resourceTrackingChecksummingForceAll
_frameNum
onExecuteWithComputeEncoder:
argumentBuffersStorage
argumentLengthsStorage
argumentGPUVAsStorage
_hasRender
_hasCompute
_argumentStride
_lengthStride
_virtualAddressStride
_setBufferMutex
_argumentEncoder
initWithKeyOptions:valueOptions:capacity:
setObject:forKey:
_retainWritableResourcesForValue:
removeWritableResourcesForValue:
_resourceMapLock
_valueToCountMap
_valueToResourcesMap
_isStandardEvent
validate:width:height:
numberWithFloat:
colorSampleCount
rasterSampleCount
defaultColorSampleCount
defaultRasterSampleCount
validateFramebufferWithRenderPipelineState:
setStoreAction:
setStoreActionOptions:
_resourceTrackingRecordDrawAccesses
loadAction
_resourceTrackingRecordBoundResourceAccesses
enumerateFragmentBuffersUsingBlock:
enumerateFragmentTexturesUsingBlock:
enumerateFragmentSamplersUsingBlock:
depthBias
depthBiasSlopeScale
depthBiasClamp
scissorRect
renderPipelineState
depthStencilState
defaultDepthStencilDescriptor
frontStencilRef
backStencilRef
blendColorRed
blendColorGreen
blendColorBlue
blendColorAlpha
_fragmentTextures
_fragmentSamplers
_unknownStoreActions
_encoderState
_deferredAttachments
_hasValidScissorRect
_depthBias
_depthBiasSlopeScale
_depthBiasClamp
_frontStencilRef
_backStencilRef
_blendColorRed
_blendColorGreen
_blendColorBlue
_blendColorAlpha
_renderPipelineState
_depthStencilState
_defaultDepthStencilDescriptor
_width
_height
_scissorRect
numberWithUnsignedInteger:
dataTypeDescription
elementIsIndirectArgumentBuffer
bufferStructType
constantValues
setConstantValues:
_constantValues
setType:
code
setCode:
compileOptions
setCompileOptions:
_type
_code
_compileOptions
openGLModeEnabled
numberWithUnsignedLong:
tileDescriptor
outputImageBlockData
isImageBlockLayoutInputCompatibleWithOutputOf:
tileArguments
inputPrimitiveTopology
updatePipelineData
validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:
validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:
validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:
_resourceTrackingRecordRenderTargetAccessesForEndEncoding:
tessellationControlPointIndexType
viewports
scissorRects
viewport
enumerateVertexBuffersUsingBlock:
enumerateVertexTexturesUsingBlock:
enumerateVertexSamplersUsingBlock:
enumerateTileBuffersUsingBlock:
enumerateTileTexturesUsingBlock:
enumerateTileSamplersUsingBlock:
enumerateThreadgroupMemoryUsingBlock:
frontFacingWinding
cullMode
depthClipMode
lineWidth
triangleFillMode
peakPerSampleStorage
resolvedSampleCount
visibilityResultMode
visibilityResultOffset
tessellationFactorBufferArgument
tessellationFactorBufferInstanceStride
tessellationFactorScale
_dirtyBits
_openGLModeEnabled
_vertexBuiltinArguments
_attachmentInfo
_previousRenderPipelineStateWithWritesToImageBlock
_resolvedRasterSampleCount
_vertexTextures
_vertexSamplers
_tileTextures
_tileSamplers
_threadgroupMemoryArguments
_visibilityOffsets
_viewports
_scissorRects
_updatedFences
_hasValidViewportsAndScissorRects
_lineWidth
_tessellationFactorScale
_frontFacingWinding
_cullMode
_depthClipMode
_triangleFillMode
_peakPerSampleStorage
_resolvedSampleCount
_visibilityResultMode
_visibilityResultOffset
_tessellationFactorBufferInstanceStride
_tessellationFactorBufferArgument
sortedArrayUsingComparator:
depthCompareFunction
stencilCompareFunction
depthStencilPassOperation
depthFailureOperation
stencilFailureOperation
tessellationFactorFormat
tessellationFactorStepFunction
mutableCopy
numberWithUnsignedLongLong:
_traceBuffer
_hasTrackedMakeAliasable
_currentDispatchID
_currentPipelineID
maxVertexBufferBindCount
maxFragmentBufferBindCount
_updateCachedPipelineState:
_updateCachedTilePipelineState:
imageBlockMasterStructMembers
imageBlockDataReturn
initWithObjects:
_findMasterStruct:includeImageBlockData:
isStructLayoutThreadSafeWith:
vertexDescriptor
layouts
stride
vertexBuiltInArguments
_maxVertexCount
_maxInstanceCount
_maxPatchCount
_rasterSampleCount
_colorPixelFormat
_depthPixelFormat
_stencilPixelFormat
_vertexDescriptorLayoutCount
_vertexDescriptorLayouts
_threadgroupSizeMatchesTileSize
normalizedCoordinates
mipFilter
sAddressMode
tAddressMode
rAddressMode
maxAnisotropy
minFilter
magFilter
compareFunction
descriptorPrivate
validateHeapResourceOptions:isTexture:isIOSurface:
validateHeapTextureUsage:options:
validatePixelFormatWithHeap:
initWithBaseTexture:heap:device:descriptor:
validateOffset:withRequirements:
accessHistoryEventsUsingBlock:
oldestEvent
setOldestEvent:
latestEvent
setLatestEvent:
debugDevice
_historyLock
_oldestEvent
_latestEvent
initWithBaseTexture:device:texture:descriptor:
setPixelFormat:
setTextureType:
setMipmapLevelCount:
setWidth:
setHeight:
setDepth:
initWithBaseTexture:device:texture:pixelFormat:
initWithBaseTexture:device:texture:pixelFormat:textureType:levels:slices:
setSwizzle:
_resourceHasMemory
offset
bytesPerRow
bytesPerImage
plane
isLinearTexture
_pixelFormatInfo
_usageRequired
_isLinearTexture
_textureUsage
_offset
_bytesPerRow
_bytesPerImage
_plane
@48@0:8@16@24Q32@40
Q16@0:8
@16@0:8
v16@0:8
v24@0:8@16
v40@0:8@16Q24Q32
v64@0:8{?=QQQ}16{?=QQQ}40
@"MTLIndirectCommandBufferDescriptor"
@"<MTLIndirectCommandBufferSPI>"
@44@0:8@16@24@32I40
v32@0:8Q16Q24
v48@0:8r^@16r^Q24{_NSRange=QQ}32
v40@0:8r^v16Q24Q32
v40@0:8Q16Q24Q32
v40@0:8Q16@24Q32
v48@0:8Q16Q24Q32Q40
v56@0:8Q16Q24Q32Q40Q48
v56@0:8Q16Q24Q32@40Q48
v64@0:8Q16Q24Q32@40Q48Q56
v64@0:8Q16Q24@32Q40@48Q56
v80@0:8Q16Q24Q32@40Q48Q56q64Q72
v56@0:8Q16@24Q32@40Q48
v72@0:8Q16Q24Q32@40Q48Q56Q64
v72@0:8Q16@24Q32@40Q48@56Q64
v88@0:8Q16Q24Q32@40Q48@56Q64Q72Q80
v40@0:8{?=QQQ}16
v40@0:8@16{_NSRange=QQ}24
v40@0:8@16@24Q32
{MTLGPUDebugBufferArgumentData="needsFlush"B"buffers"[31@"<MTLBuffer>"]"offsets"[31Q]"lengths"[31I]"gpu_address"[31[2Q]]}
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
Q24@0:8Q16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v32@0:8{_NSRange=QQ}16
@24@0:8Q16
@"<MTLIndirectRenderCommand>"24@0:8Q16
@"<MTLIndirectComputeCommand>"24@0:8Q16
v32@0:8^^v16^Q24
v24@0:8Q16
@32@0:8@16@24
@"MTLToolsPointerArray"
v56@0:8@16^{?=BBQ@QQQQQBff}24^{?=BBQ@QQQQQBff}32@40@48
B40@0:8^{?=dddddd}16I24^{?=QQQQ}28I36
v52@0:8B16@20@28@36^{ResourceTrackingDeferredAttachments=@@@}44
v44@0:8@16@24B32^{ResourceTrackingDeferredAttachments=@@@}36
v36@0:8@16B24^{ResourceTrackingDeferredAttachments=@@@}28
v24@0:8^{ResourceTrackingDeferredAttachments=@@@}16
v32@0:8r^{MTLRenderPassAttachmentDescriptorPrivate=@QQQQQQ{?=dddd}dIQ@QQQQQQB}16Q24
v28@0:8i16I20I24
I16@0:8
v136@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112
v120@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96
v128@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96Q120
v120@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112
v128@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112Q120
v44@0:8@16{_NSRange=QQ}24C40
v80@0:8@16Q24Q32@40Q48Q56Q64Q72
v32@0:8@16@24
v56@0:8@16Q24@32Q40Q48
v56@0:8@16{_NSRange=QQ}24@40Q48
v24@0:8@"<MTLResource>"16
v40@0:8@"<MTLTexture>"16Q24Q32
v136@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112
v120@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96
v128@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96Q120
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112
v128@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112Q120
v24@0:8@"<MTLTexture>"16
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24C40
v80@0:8@"<MTLTexture>"16Q24Q32@"<MTLTexture>"40Q48Q56Q64Q72
v32@0:8@"<MTLTexture>"16@"<MTLTexture>"24
v56@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40Q48
v24@0:8@"<MTLFence>"16
v40@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24
v56@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24@"<MTLIndirectCommandBuffer>"40Q48
v144@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136
@40@0:8@16@24@32
v32@0:8@16Q24
v40@0:8r^@16{_NSRange=QQ}24
v40@0:8@16f24f28Q32
v56@0:8r^@16r^f24r^f32{_NSRange=QQ}40
v48@0:8@16Q24@32Q40
v40@0:8r^@16Q24Q32
v48@0:8r^@16Q24Q32Q40
v32@0:8r^@16Q24
v64@0:8{?=dddddd}16
v32@0:8r^{?=dddddd}16Q24
v20@0:8f16
v28@0:8f16f20f24
v48@0:8{?=QQQQ}16
v32@0:8r^{?=QQQQ}16Q24
v20@0:8I16
v24@0:8I16I20
v32@0:8f16f20f24f28
v56@0:8@16Q24Q32Q40Q48
v60@0:8@16Q24Q32Q40B48Q52
v48@0:8@16Q24Q32Q40
v52@0:8@16Q24Q32Q40B48
@"MTLCountersTraceRenderCommandEncoder"
^v16@0:8
@40@0:8@16Q24Q32
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@48@0:8@16Q24Q32Q40
^{__IOSurface=}16@0:8
v24@0:8@?16
v32@0:8@16d24
@24@0:8@16
d16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
v24@0:8@"<MTLDrawable>"16
v32@0:8@"<MTLDrawable>"16d24
@"<MTLBlitCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLComputeCommandEncoder>"16@0:8
@"<MTLComputeCommandEncoder>"24@0:8Q16
v32@0:8@"<MTLEvent>"16Q24
@"<MTLParallelRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLCommandQueue>"16@0:8
@"NSError"16@0:8
v20@0:8B16
^v24@0:8^Q16
@40@0:8@16^{?=b8b24IQQ}24Q32
@32@0:8^{?=b8b24IQQ}16Q24
@40@0:8Q16^{?=b8b24IQQ}24Q32
v36@0:8@16Q24I32
v40@0:8Q16r^@24Q32
v24@0:8@"<MTLHeap>"16
@"NSDictionary"16@0:8
@"NSMutableDictionary"16@0:8
@"<MTLRenderCommandEncoder>"40@0:8@"MTLRenderPassDescriptor"16^{?=b8b24IQQ}24Q32
@"<MTLComputeCommandEncoder>"32@0:8^{?=b8b24IQQ}16Q24
@"<MTLComputeCommandEncoder>"40@0:8Q16^{?=b8b24IQQ}24Q32
@"<MTLDebugCommandEncoder>"16@0:8
@"<MTLFragmentRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLFragmentRenderCommandEncoder>"40@0:8@"MTLRenderPassDescriptor"16^{?=b8b24IQQ}24Q32
v36@0:8@"<MTLEvent>"16Q24I32
v24@0:8^{ILayerLockingPolicy=^^?}16
v40@0:8@16Q24@32
v20@0:8i16
v44@0:8i16Q20r^@28Q36
^{ILayerLockingPolicy=^^?}16@0:8
{?="hasCommit"b1"addedCompletedHandler"b1"addedScheduledHandler"b1"padding"b29}
@"NSMutableSet"
^{ILayerLockingPolicy=^^?}
@40@0:8@16@24^{ILayerLockingPolicy=^^?}32
v28@0:8I16I20I24
@"MTLToolsCommandBuffer"
@"<MTLCommandBuffer>"16@0:8
B24@0:8Q16
B28@0:8Q16S24
i16@0:8
i24@0:8@16
i32@0:8@16Q24
v24@0:8@"NSObject<OS_dispatch_queue>"16
@"NSObject<OS_dispatch_queue>"16@0:8
@"NSArray"16@0:8
i24@0:8@"NSArray"16
i32@0:8@"NSArray"16Q24
@"NSArray"24@0:8@"NSArray"16
v24@0:8@?<v@?@"<MTLCommandBuffer>"@"NSData"Q>16
@32@0:8Q16Q24
@40@0:8Q16Q24Q32
@32@0:8@16Q24
q16@0:8
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLBuffer>"40@0:8Q16Q24Q32
@"<MTLTexture>"32@0:8@"MTLTextureDescriptor"16Q24
@"NSString"24@0:8Q16
v64@0:8{?={?=QQQ}{?=QQQ}}16
v56@0:8@16Q24{?=QQQ}32
v24@0:8@"<MTLComputePipelineState>"16
v40@0:8@"<MTLBuffer>"16Q24Q32
v32@0:8@"<MTLTexture>"16Q24
v32@0:8@"<MTLSamplerState>"16Q24
v40@0:8@"<MTLSamplerState>"16f24f28Q32
v32@0:8@"<MTLBuffer>"16Q24
v56@0:8@"<MTLBuffer>"16Q24{?=QQQ}32
v32@0:8@"<MTLResource>"16Q24
v40@0:8@"<MTLIndirectCommandBuffer>"16@"<MTLBuffer>"24Q32
@"NSData"16@0:8
Q40@0:8{?=QQQ}16
@"MTLDebugInstrumentationData"16@0:8
@"<MTLFunction>"
^v24@0:8Q16
{?={?=QQQ}{?=QQQ}}16@0:8
@"_MTLIndirectDispatchThreadgroupsArguments"16@0:8
@"_MTLIndirectDispatchThreadsArguments"16@0:8
v24@0:8^Q16
@32@0:8@16^@24
@48@0:8@16Q24^@32^@40
v32@0:8@16@?24
v40@0:8@16Q24@?32
@40@0:8@16@24^@32
{MetalBufferHeap="_mutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_buffers"{vector<id<MTLBuffer>, std::__1::allocator<id<MTLBuffer> > >="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::__1::allocator<id<MTLBuffer> > >="__value_"^@}}"_freeList"{vector<unsigned int, std::__1::allocator<unsigned int> >="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >="__value_"^I}}"_currentFreeIndex"i"_totalMemoryAllocated"Q"_totalMemoryInUse"Q"device"@"<MTLDevice>""bufferLength"Q}
@"NSMutableArray"
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@40@0:8@16^{__IOSurface=}24Q32
v40@0:8@16@24@?32
B24@0:8q16
v32@0:8^{?=ff}16Q24
{?=QQQ}16@0:8
@"<MTLCommandQueue>"24@0:8Q16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@24@0:8^{__IOSurface=}16
{?=II}16@0:8
@20@0:8I16
B44@0:8^@16Q24^Q32i40
@48@0:8r^v16Q24Q32Q40
@56@0:8^v16Q24Q32Q40@?48
Q32@0:8Q16Q24
r^{?=IIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ}16@0:8
f16@0:8
{IndirectArgumentBufferCapabilities=b1b1b1b29}16@0:8
v24@0:8^{MPSFunctionTable=}16
v40@0:8Q16^Q24Q32
B40@0:8^{?=III}16Q24Q32
@32@0:8^v16Q24
@40@0:8^v16@24Q32
@40@0:8@16r^{?=BQ^{?}}24^@32
@28@0:8@16I24
@48@0:8^v16Q24@32@?40
@28@0:8@16B24
@32@0:8r^@16Q24
r^{MTLTargetDeviceArch=II*}16@0:8
v24@0:8@"<MTLDeviceSPI>"16
@"<MTLBuffer>"24@0:8^{__IOSurface=}16
B24@0:8@"NSString"16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
@"_MTLIndirectArgumentBufferLayout"24@0:8@"MTLStructType"16
@"<MTLArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLIndirectRenderCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLIndirectComputeCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLSharedEvent>"20@0:8I16
@"<MTLBuffer>"24@0:8@"<MTLComputeCommandEncoder>"16
@"<MTLBuffer>"24@0:8@"<MTLRenderCommandEncoder>"16
@"<MTLBuffer>"48@0:8r^v16Q24Q32Q40
@"<MTLBuffer>"56@0:8^v16Q24Q32Q40@?<v@?^vQ>48
v24@0:8@"<MTLBuffer>"16
v24@0:8@"<MTLSamplerState>"16
v24@0:8@"<MTLRenderPipelineState>"16
v24@0:8@"<MTLIndirectCommandBuffer>"16
v24@0:8@"NSArray"16
@"NSObject<OS_dispatch_data>"16@0:8
v24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLComputePipelineState>"32@0:8@"MTLComputePipelineDescriptor"16^@24
v32@0:8@"MTLComputePipelineDescriptor"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
v32@0:8@"MTLTileRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLFunction>"32@0:8^v16Q24
@"<MTLFunction>"40@0:8^v16@"NSObject<OS_dispatch_data>"24Q32
@"<MTLIndirectArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLComputePipelineState>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLLibrary>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLPipelineLibrarySPI>"32@0:8@"NSString"16^@24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLRenderPipelineDescriptor"16
@"NSObject<OS_dispatch_data>"24@0:8@"MTLComputePipelineDescriptor"16
@"MTLRenderPipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"MTLComputePipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLStructType"16
@"NSObject<OS_dispatch_data>"28@0:8@"MTLStructType"16I24
@"<MTLTexture>"48@0:8^v16Q24@"MTLTextureDescriptor"32@?<v@?^vQ>40
@"<MTLTextureLayout>"28@0:8@"MTLTextureDescriptor"16B24
@"<MTLIndirectArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLResourceGroupSPI>"32@0:8r^@16Q24
@"<MTLDeviceSPI>"
v48@0:8r^f16Q24r*32Q40
v64@0:8r^f16Q24r^f32Q40r*48Q56
v48@0:8r^f16Q24r^f32Q40
v48@0:8@"<MTLTexture>"16Q24@"<MTLSamplerState>"32Q40
v24@0:8@"<MTLDepthStencilState>"16
v40@0:8@"MTLSharedEventListener"16Q24@?<v@?@"<MTLSharedEvent>"Q>32
@"MTLSharedEventHandle"16@0:8
@32@0:8Q16^@24
@"<MTLArgumentEncoder>"24@0:8Q16
@"<MTLArgumentEncoder>"32@0:8Q16^@24
v32@0:8Q16@?24
r^{?=[32C]}16@0:8
@28@0:8@16C24
@"MTLFunctionReflection"24@0:8Q16
v32@0:8Q16@?<v@?@"MTLFunctionReflection">24
@"<MTLFunction>"28@0:8@"NSData"16C24
@"MTLType"16@0:8
@"<MTLFunction>"24@0:8@"NSString"16
@"<MTLFunction>"40@0:8@"NSString"16@"MTLFunctionConstantValues"24^@32
v40@0:8@"NSString"16@"MTLFunctionConstantValues"24@?<v@?@"<MTLFunction>"@"NSError">32
@48@0:8@16@24@32^@40
v48@0:8@16@24@32@?40
@"<MTLFunction>"48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32^@40
v48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32@?<v@?@"<MTLFunction>"@"NSError">40
@"NSString"
@"MTLCountersTraceComputeCommandEncoder"
@48@0:8@16@24@32@40
@"MTLRenderPipelineDescriptor"
@"MTLTileRenderPipelineDescriptor"
@"MTLRenderPipelineReflection"
@24@0:8#16
@"MTLToolsObject"
@"MTLToolsDevice"
@"<MTLRenderCommandEncoder>"16@0:8
v64@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56
v56@0:8Q16Q24Q32@"<MTLBuffer>"40Q48
v80@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56q64Q72
v40@0:8Q16@"<MTLBuffer>"24Q32
v64@0:8Q16Q24@"<MTLBuffer>"32Q40@"<MTLBuffer>"48Q56
v32@0:8@"<MTLFence>"16Q24
v72@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64
v56@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48
v88@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80
v72@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64
v40@0:8@"<MTLResource>"16Q24Q32
v32@0:8@"<MTLHeap>"16Q24
v40@0:8f16f20f24f28Q32
v44@0:8@16f24f28f32Q36
v28@0:8B16Q20
v24@0:8@?<v@?@"<MTLRenderCommandEncoderSPI>"Q>16
v44@0:8@"<MTLSamplerState>"16f24f28f32Q36
v56@0:8@"<MTLTexture>"16Q24Q32Q40Q48
v60@0:8@"<MTLTexture>"16Q24Q32Q40B48Q52
v48@0:8@"<MTLTexture>"16Q24Q32Q40
v52@0:8@"<MTLTexture>"16Q24Q32Q40B48
v60@0:8@16Q24Q32Q40Q48B56
@40@0:8@16Q24@32
@32@0:8^{BinaryBuffer=^^?{StreamBuffer=***}}16Q24
{_NSRange=QQ}16@0:8
^{BinaryBuffer=^^?{StreamBuffer=***}}
{_NSRange="location"Q"length"Q}
@24@0:8^{BinaryBuffer=^^?{StreamBuffer=***}}16
v108@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@92Q100
v88@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80
v80@0:8Q16Q24Q32@40Q48Q56Q64Q72
@20@0:8B16
v32@0:8r^v16Q24
v40@0:8r^v16@24@32
{BinaryBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}}
{AppendBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}}
B32@0:8r^@16Q24
B24@0:8@"<MTLResource>"16
@"MTLResourceAllocationInfo"16@0:8
@"MTLToolsHeap"
v96@0:8Q16Q24Q32@40Q48Q56Q64@72Q80Q88
v112@0:8Q16Q24Q32@40Q48@56Q64Q72Q80@88Q96Q104
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLResource>"16@0:8
@"<MTLTexture>"16@0:8
@"<MTLBuffer>"16@0:8
v112@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96Q104
v112@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96Q104
@48@0:8Q16Q24Q32Q40
@"<MTLTexture>"48@0:8Q16Q24Q32Q40
v104@0:8Q16Q24{?=QQQ}32{?=QQQ}56^v80Q88Q96
v104@0:8r^v16Q24Q32Q40Q48{?=QQQ}56{?=QQQ}80
@"<MTLTexture>"
@"<MTLBuffer>"
v120@0:8r^v16Q24Q32Q40^v48Q56Q64{?={?=QQQ}{?=QQQ}}72
v120@0:8r^v16Q24Q32{?={?=QQQ}{?=QQQ}}40^v88Q96Q104Q112
v24@0:8^v16
{?=[2Q]}16@0:8
@"MTLRenderPassDescriptor"
@56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
@"<MTLBuffer>"56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
{pair<id<MTLBuffer>, unsigned long>=@Q}24@0:8Q16
{pair<id<MTLBuffer>, unsigned long>=@Q}32@0:8r^v16Q24
{ReportBufferEntry=Q@Q}24@0:8Q16
@"<MTLArgumentEncoder>"
{vector<MetalBuffer, std::__1::allocator<MetalBuffer> >="__begin_"^{MetalBuffer}"__end_"^{MetalBuffer}"__end_cap_"{__compressed_pair<MetalBuffer *, std::__1::allocator<MetalBuffer> >="__value_"^{MetalBuffer}}}
{MetalBuffer="heap"^{MetalBufferHeap}"index"I}
{vector<id<MTLBuffer>, std::__1::allocator<id<MTLBuffer> > >="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::__1::allocator<id<MTLBuffer> > >="__value_"^@}}
{vector<ReportBufferEntry, std::__1::allocator<ReportBufferEntry> >="__begin_"^{ReportBufferEntry}"__end_"^{ReportBufferEntry}"__end_cap_"{__compressed_pair<ReportBufferEntry *, std::__1::allocator<ReportBufferEntry> >="__value_"^{ReportBufferEntry}}}
{vector<NSString *, std::__1::allocator<NSString *> >="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<NSString **, std::__1::allocator<NSString *> >="__value_"^@}}
{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
@32@0:8@16@?24
{unordered_set<void *, std::__1::hash<void *>, std::__1::equal_to<void *>, std::__1::allocator<void *> >="__table_"{__hash_table<void *, std::__1::hash<void *>, std::__1::equal_to<void *>, std::__1::allocator<void *> >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<void *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<void *, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<void *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<void *, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<void *, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<void *, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<void *, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<void *, void *> *>, std::__1::allocator<std::__1::__hash_node<void *, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<void *, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<void *, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::hash<void *> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::equal_to<void *> >="__value_"f}}}
@"NSObject<OS_dispatch_semaphore>"
v148@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136B144
v112@0:8@16Q24Q32{?=QQQ}40@64Q72Q80Q88Q96Q104
{deque<id, std::__1::allocator<id> >="__map_"{__split_buffer<id *, std::__1::allocator<id *> >="__first_"^^@"__begin_"^^@"__end_"^^@"__end_cap_"{__compressed_pair<id **, std::__1::allocator<id *> >="__value_"^^@}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::__1::allocator<id> >="__value_"Q}}
@40@0:8@16@24Q32
@48@0:8@16@24@32Q40
@48@0:8@16@24r^v32Q40
@56@0:8@16@24Q32@40Q48
r^v16@0:8
@"MTLDebugResource"
@"MTLDebugResourceAccessTracker"
@"MTLDebugDevice"
v40@0:8@16^{?=BBQ@QQQQQBff}24^{?=BBQ@QQQQQBff}32
@"_MTLCommandEncoder"
{unique_ptr<ILayerLockingPolicy, std::__1::default_delete<ILayerLockingPolicy> >="__ptr_"{__compressed_pair<ILayerLockingPolicy *, std::__1::default_delete<ILayerLockingPolicy> >="__value_"^{ILayerLockingPolicy}}}
{vector<std::__1::pair<MTLDebugSharedEvent *, unsigned long long>, std::__1::allocator<std::__1::pair<MTLDebugSharedEvent *, unsigned long long> > >="__begin_"^{pair<MTLDebugSharedEvent *, unsigned long long>}"__end_"^{pair<MTLDebugSharedEvent *, unsigned long long>}"__end_cap_"{__compressed_pair<std::__1::pair<MTLDebugSharedEvent *, unsigned long long> *, std::__1::allocator<std::__1::pair<MTLDebugSharedEvent *, unsigned long long> > >="__value_"^{pair<MTLDebugSharedEvent *, unsigned long long>}}}
{unordered_multiset<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::__1::allocator<AttachmentDescriptorSimple> >="__table_"{__hash_table<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::__1::allocator<AttachmentDescriptorSimple> >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>, std::__1::allocator<std::__1::__hash_node<AttachmentDescriptorSimple, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, AttachmentDescriptorSimple::hash_t>="__value_"Q}"__p3_"{__compressed_pair<float, AttachmentDescriptorSimple::equal_t>="__value_"f}}}
{array<AttachmentDescriptorSimple, 8>="__elems_"[8{AttachmentDescriptorSimple="texture"^v"level"Q"sliceRange"{_NSRange="location"Q"length"Q}"depthPlaneRange"{_NSRange="location"Q"length"Q}"storeAction"Q}]}
v96@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64@"<MTLBuffer>"72Q80Q88
v112@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80@"<MTLBuffer>"88Q96Q104
@"_MTLIndirectDrawArguments"16@0:8
@"_MTLIndirectDrawIndexedArguments"16@0:8
@"_MTLIndirectDrawPatchesArguments"16@0:8
@"_MTLIndirectDrawIndexedPatchesArguments"16@0:8
@"_MTLIndirectTessellationFactorArguments"16@0:8
@"MTLComputePipelineDescriptor"
@"MTLComputePipelineReflection"
[31{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[96{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[16{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{?="width"Q"height"Q"depth"Q}
r^{?=IIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ}
{?="origin"{?="x"Q"y"Q"z"Q}"size"{?="width"Q"height"Q"depth"Q}}
@"<MTLComputePipelineState>"
v32@0:8@16r^{?=BQ^{?}}24
^{?=BQ^{?}}16@0:8
[3Q]
@"NSArray"
^{?=BQ^{?}}
@56@0:8@16@24@32Q40Q48
@"<MTLIndirectCommandBuffer>"
@"<MTLComputePipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"<MTLRenderPipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"MTLComputePipelineDescriptor"32@0:8@"NSString"16^@24
@"MTLRenderPipelineDescriptor"32@0:8@"NSString"16^@24
@"<MTLPipelineCache>"16@0:8
v32@0:8@"<MTLRenderPipelineState>"16Q24
v32@0:8@"<MTLComputePipelineState>"16Q24
v32@0:8@"<MTLIndirectCommandBuffer>"16Q24
@"_MTLIndirectArgumentBufferLayout"16@0:8
^{StructType={vector<MemberRef, std::__1::allocator<MemberRef> >=^{MemberRef}^{MemberRef}{__compressed_pair<MemberRef *, std::__1::allocator<MemberRef> >=^{MemberRef}}}}
v32@0:8Q16B24B28
B20@0:8B16
I24@0:8@16
{MTLSamplerDescriptorHashMap="_map"{unordered_map<std::__1::array<unsigned long long, 3>, unsigned int, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, std::__1::allocator<std::__1::pair<const std::__1::array<unsigned long long, 3>, unsigned int> > >="__table_"{__hash_table<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, std::__1::__unordered_map_hasher<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, true>, std::__1::__unordered_map_equal<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int> > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, true> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, true> >="__value_"f}}}"_limit"I}
@"MTLDepthStencilDescriptor"
@56@0:8@16@24Q32Q40@48
{unordered_map<unsigned long long, unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, unsigned long long> > >="__table_"{__hash_table<std::__1::__hash_value_type<unsigned long long, unsigned long long>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned long long>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned long long>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, unsigned long long> > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned long long>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned long long>, std::__1::hash<unsigned long long>, true> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned long long>, std::__1::equal_to<unsigned long long>, true> >="__value_"f}}}
@"NSMapTable"
{?=QQQQ}16@0:8
{ResourceTrackingDeferredAttachments="colorAttachments"@"NSMutableArray""depthAttachment"@"MTLRenderPassDepthAttachmentDescriptorInternal""stencilAttachment"@"MTLRenderPassStencilAttachmentDescriptorInternal"}
@"<MTLRenderPipelineState>"
@"<MTLDepthStencilState>"
{?="x"Q"y"Q"width"Q"height"Q}
@"MTLFunctionConstantValues"
@56@0:8@16@24Q32@40@48
@"MTLCompileOptions"
^{vector<MTLViewport, std::__1::allocator<MTLViewport> >=^{?}^{?}{__compressed_pair<MTLViewport *, std::__1::allocator<MTLViewport> >=^{?}}}16@0:8
^{vector<MTLScissorRect, std::__1::allocator<MTLScissorRect> >=^{?}^{?}{__compressed_pair<MTLScissorRect *, std::__1::allocator<MTLScissorRect> >=^{?}}}16@0:8
{?=dddddd}16@0:8
v56@0:8Q16Q24Q32Q40r*48
v72@0:8Q16Q24Q32@40Q48Q56r*64
{?=BBQ@QQQQQBff}16@0:8
^{?=QQ}
[10{?="pixelFormat"Q"sampleCount"Q}]
[36{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{?="maxColorAttachments"I"maxVertexAttributes"I"maxVertexBuffers"I"maxVertexTextures"I"maxVertexSamplers"I"maxVertexInlineDataSize"I"maxInterpolants"I"maxFragmentBuffers"I"maxFragmentTextures"I"maxFragmentSamplers"I"maxFragmentInlineDataSize"I"maxComputeBuffers"I"maxComputeTextures"I"maxComputeSamplers"I"maxComputeInlineDataSize"I"maxComputeLocalMemorySizes"I"maxTotalComputeThreadsPerThreadgroup"I"maxComputeThreadgroupMemory"I"maxLineWidth"f"maxPointSize"f"maxVisibilityQueryOffset"I"padmaxBufferLength"I"minConstantBufferAlignmentBytes"I"minBufferNoCopyAlignmentBytes"I"maxTextureWidth1D"I"maxTextureWidth2D"I"maxTextureHeight2D"I"maxTextureWidth3D"I"maxTextureHeight3D"I"maxTextureDepth3D"I"maxTextureDimensionCube"I"maxTextureLayers"I"linearTextureAlignmentBytes"I"iosurfaceTextureAlignmentBytes"I"iosurfaceReadOnlyTextureAlignmentBytes"I"deviceLinearTextureAlignmentBytes"I"deviceLinearReadOnlyTextureAlignmentBytes"I"maxFunctionConstantIndices"I"maxComputeThreadgroupMemoryAlignmentBytes"I"maxInterpolatedComponents"I"maxTessellationFactor"I"maxIndirectBuffers"I"maxIndirectTextures"I"maxIndirectSamplers"I"maxIndirectSamplersPerDevice"I"maxViewportCount"I"maxCustomSamplePositions"I"maxTextureBufferWidth"I"maxComputeAttributes"I"maxFramebufferStorageBits"I"linearTextureArrayAlignmentBytes"I"linearTextureArrayAlignmentSlice"I"maxTileBuffers"I"maxTileTextures"I"maxTileSamplers"I"maxTileInlineDataSize"I"minTilePixels"I"maxBufferLength"Q}
^{set<unsigned int, std::__1::less<unsigned int>, std::__1::allocator<unsigned int> >={__tree<unsigned int, std::__1::less<unsigned int>, std::__1::allocator<unsigned int> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned int, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned int> >=Q}}}
{vector<MTLViewport, std::__1::allocator<MTLViewport> >="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLViewport *, std::__1::allocator<MTLViewport> >="__value_"^{?}}}
{vector<MTLScissorRect, std::__1::allocator<MTLScissorRect> >="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLScissorRect *, std::__1::allocator<MTLScissorRect> >="__value_"^{?}}}
{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}
@"MTLCountersTraceCommandBuffer"
@"MTLDebugHeap"
@36@0:8@16@24I32
[8Q]
[31{?="bufferIndex"Q"bufferStride"Q}]
@"MTLSamplerDescriptor"
v28@0:8@16B24
v40@0:8Q16{?=QQ}24
^{HeapHistoryEvent=^{HeapHistoryEvent}^vB}16@0:8
v24@0:8^{HeapHistoryEvent=^{HeapHistoryEvent}^vB}16
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
^{HeapHistoryEvent=^{HeapHistoryEvent}^vB}
@64@0:8@16@24@32@40Q48Q56
@72@0:8@16@24@32@40Q48Q56Q64
@88@0:8@16@24@32Q40Q48{_NSRange=QQ}56{_NSRange=QQ}72
{MTLPixelFormatInfo="name"*"flags"I"castClass"Q"type"(?="normal"{MTLNormalPixelFormatInfo="pixelBytes"Q"componentCount"C"alignment"C"pixelBytesRender"Q"pixelBytesRenderMSAA"Q}"compressed"{MTLCompressedPixelFormatInfo="blockBytes"Q"blockWidth"Q"blockHeight"Q"blockDepth"Q})}
@"MTLTextureDescriptor"
@"MTLCountersTraceBlitCommandEncoder"
