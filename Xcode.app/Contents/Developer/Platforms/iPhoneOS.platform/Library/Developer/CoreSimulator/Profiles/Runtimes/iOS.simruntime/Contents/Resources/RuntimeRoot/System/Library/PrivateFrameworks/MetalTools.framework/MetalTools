-[MTLDebugIndirectComputeCommand setComputePipelineState:]
Setting the pipeline state of indirect command buffers created with inheritPipelineState = YES is invalid
Setting a pipeline that does not have supportIndirectCommandBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand setKernelBuffer:offset:atIndex:]
index(%lu) must be < %lu.
Setting buffers on a indirect command buffer created with inheritBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand concurrentDispatchThreadgroups:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatch is not enabled on this indirect command buffer
-[MTLDebugIndirectComputeCommand concurrentDispatchThreads:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatchThreads is not enabled on this indirect command buffer
<unknown>
<unnamed>
<nil>
Unknown
Read Only
Write Only
Read Write
%@, length:%llu, resident:%@
%@, length:%llu
Invalid %@ %@ executing %@ function "%@" encoder: "%@", %@: %lu, at offset %llu
device
threadgroup
buffer: %@
Null texture access
Texture usage flags mismatch
%@ executing %@ function "%@" encoder: "%@", %@: %lu
Stack Overflow executing function "%@", %@ function "%@" encoder: "%@", %@: %u
Trap hit in function "%@", %@ function "%@", encoder: "%@", %@: %u
kernel
dispatch
vertex
draw
fragment
visible
intersection
object
mesh
%@(%@)
%llX
.xctoolchain/
v24@?0@"<MTLFunction>"8@"NSError"16
%@%@
label =
<none>
v16@?0@"<MTLCommandBuffer>"8
vector
v32@?0@"<MTLCommandBuffer>"8@"NSData"16Q24
-[MTLDebugVisibleFunctionTable setPurgeableState:]
Setting purgeability state directly on heap sub-allocated resources is not allowed.
Cannot set purgeability state to volatile while resource is in use by a command buffer.
-[MTLDebugVisibleFunctionTable setFunction:atIndex:]
Visible Function Tables are not supported by the device.
function stage %@ does not match intersection table stage %@
pipelineState must be MTLComputePipelineState or MTLRenderPipelineState
-[MTLDebugVisibleFunctionTable setFunctions:withRange:]
NSMaxRange(range)(%lu) must be <= %lu.
functionCount =
mtl.global_constants_handle
mtl.current_image_id
v8@?0
com.apple.Metal
GPUDebug
v40@?0r^v8{_NSRange=QQ}16^B32
MTL_BOUNDS_ACCURATE_MODE
MTL_SHADER_VALIDATION_CPUOPT_FORCE_INIT
MTLBoundsCheck::Options
MTLBoundsCheck::RenderPipelineData
MTLBoundsCheck::ComputePipelineData
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
MetalShaderValidation
Metal Shader Validation does not support mesh shaders in this release. To use mesh shaders in this release, disable Metal Shader Validation in the Xcode scheme settings.
v32@?0@"<MTLComputePipelineState>"8@"MTLComputePipelineReflection"16@"NSError"24
-[MTLGPUDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
Indirect Command Buffers are not currently supported with Shader Validation
v24@?0@"<MTLLibrary>"8@"NSError"16
-[MTLGPUDebugDevice validateRaytracing]
ray tracing is not currently supported with Shader Validation
@"MTLToolsDynamicLibrary"8@?0
@"MTLToolsFunction"8@?0
MTL_SHADER_VALIDATION_MODE
Tier1
Tier2
MTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING
MTL_SHADER_VALIDATION_GLOBAL_MEMORY
MTL_SHADER_VALIDATION_THREADGROUP_MEMORY
MTL_SHADER_VALIDATION_TEXTURE_USAGE
MTL_SHADER_VALIDATION_RESOURCE_USAGE
MTL_SHADER_VALIDATION_STACK_OVERFLOW
MTL_SHADER_VALIDATION_REPORT_TO_STDERR
MTL_SHADER_VALIDATION_COMPILER_INLINING
none
full
partial
default
MTL_SHADER_VALIDATION_FAIL_MODE
zerofill
allow
MTL_SHADER_VALIDATION_GPUOPT_FORCE_INLINE
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_PACK_POINTER_ADDRESSES
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_BACKTRACK
MTL_SHADER_VALIDATION_GPUOPT_CONST_DEREF
MTL_SHADER_VALIDATION_GPUOPT_GEP
MTL_SHADER_VALIDATION_GPUOPT_GENERIC
MTL_SHADER_VALIDATION_GPUOPT_SKIP_VFETCH
MTL_SHADER_VALIDATION_GPUOPT_BACKTRACK_FAIL_ASSUME_SAFE
MTL_SHADER_VALIDATION_GPUOPT_MERGE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_USE_LENGTH_ONLY
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_TRIVIAL
MTL_SHADER_VALIDATION_GPUOPT_DEMOTE_GLOBALS_CONSTANTS_TO_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_POINTER_INDIRECTION
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_GLOBALS
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_JUMP_THREADING
MTL_SHADER_VALIDATION_GPUOPT_USE_RELOCATIONS
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_REFELECTION
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_TRAP
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_FUNCTIONS
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_RAY_TRACING
MTL_SHADER_VALIDATION_ABORT_ON_FAULT
MTL_SHADER_VALIDATION_MAX_TRACKED_RESOURCES_MULTIPLIER
Invalid option for %s, valid options are:
com.apple.gpusw.MetalTools
MTLGPUDebugICBSupport
metallib
ICB_Inherit_PSO_Vertex
ICB_Inherit_None_Vertex
ICB_Inherit_Buffers_Vertex
ICB_Inherit_PSO_Kernel
ICB_Inherit_None_Kernel
ICB_Inherit_Buffers_Kernel
ICB_Inherit_Both_Kernel
Faults from argument buffers will not be detected.
Faults from reading global constant variables will not be detected.
%@ -debug-info-kind=line-tables-only
-debug-info-kind=line-tables-only
@"MTLToolsLibrary"8@?0
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v24@?0@"<MTLComputePipelineState>"8@"NSError"16
ciKernelMain
-[MTLToolsDevice unwrapMTLCommandBufferDescriptor:alwaysCopy:]
Incorrect object type in %s: expected %s, found %s
@"MTLToolsDepthStencilState"8@?0
@"MTLToolsSamplerState"8@?0
v24@?0@"<MTLSharedEvent>"8Q16
-[MTLDebugPipelineLibrary newComputePipelineStateWithName:options:reflection:error:]
name must not be nil.
descriptor is not a NSString.
-[MTLDebugPipelineLibrary newRenderPipelineStateWithName:options:reflection:error:]
@"MTLToolsFunctionHandle"8@?0
%@ -> %@
-[MTLDebugIntersectionFunctionTable setPurgeableState:]
-[MTLDebugIntersectionFunctionTable setFunction:atIndex:]
-[MTLDebugIntersectionFunctionTable setFunctions:withRange:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:withRange:]
"version":"
0.908
,"handle":"
"handle":"
,"name":"
{"selector":"
,"flags":
,"commands":"
,"commandBufferLength":
{"flags":
,"segment":{"location":
,"length":
,"statistics":{"flags":
,"counters":[
{"name":"
],"samples":"
,"sampleBufferLength":
cb_%llu.json
Error saving file '%@' (%@)
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
fillBuffer:range:value
fillBuffer:range:pattern4
fillTexture:level:slice:region:data:size
fillTexture:level:slice:region:color
fillTexture:level:slice:region:color:pixelFormat
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount
copyFromTexture:toTexture
generateMipmapsForTexture
synchronizeResource
synchronizeTexture
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset
resetTextureAccessCounters:region:mipLevel:slice
dispatchThreadgroups:threadsPerThreadgroup
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
setBuffer:offset:atIndex
setBufferOffset:atIndex
setBuffers:offsets:withRange
setBytes:length:atIndex
setComputePipelineState
setSamplerState:atIndex
setSamplerState:lodMinClamps:lodMaxClamps:atIndex
setSamplerStates:withRange
setSamplerStates:lodMinClamps:lodMaxClamps:withRange
setStageInRegion
setTexture:atIndex
setTextures:withRange
setThreadgroupMemoryLength:atIndex
memoryBarrierWithScope
memoryBarrierWithResources:count
drawPrimitives:vertexStart:vertexCount
drawPrimitives:vertexStart:vertexCount:instanceCount
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance
drawPrimitives:indirectBuffer:indirectBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset
drawIndexedPatches:patchStart:patchCount:controlPointIndexBuffer:controlPointIndexBufferOffset:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset
dispatchThreadsPerTile
setBlendColorRed:green:blue:alpha
setColorStoreAction:atIndex
setCullMode
setDepthBias:slopeScale:clamp
setDepthClipMode
setDepthStencilState
setDepthStoreAction
setFragmentBuffer:offset:atIndex
setFragmentBufferOffset:atIndex
setFragmentBuffers:offsets:withRange
setFragmentBytes:length:atIndex
setFragmentSamplerState:atIndex
setFragmentSamplerState:lodMinClamps:lodMaxClamps:atIndex
setFragmentSamplerStates:withRange
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange
setFragmentTexture:atIndex
setFragmentTextures:withRange
setFrontFaceWinding
setRenderPipelineState
setScissorRect
setScissorRects:count
setStencilFrontReferenceValue:backReferenceValue
setStencilReferenceValue
setStencilStoreAction
setTessellationFactorBuffer:offset:instanceStride
setTessellationFactorScale
setTriangleFillMode
setVertexBuffer:offset:atIndex
setVertexBufferOffset:atIndex
setVertexBuffers:offsets:withRange
setVertexBytes:length:atIndex
setVertexSamplerState:atIndex
setVertexSamplerState:lodMinClamps:lodMaxClamps:atIndex
setVertexSamplerStates:withRange
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange
setVertexTexture:atIndex
setVertexTextures:withRange
setTileBuffer:offset:atIndex
setTileBufferOffset:atIndex
setTileBuffers:offsets:withRange
setTileBytes:length:atIndex
setTileSamplerState:atIndex
setTileSamplerState:lodMinClamps:lodMaxClamps:atIndex
setTileSamplerStates:withRange
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange
setTileTexture:atIndex
setTileTextures:withRange
setViewport
setViewports:count
setVisibilityResultMode:offset
textureBarrier
memoryBarrierWithScope:afterStages:beforeStages
memoryBarrierWithResources:count:afterStages:beforeStages
setVisibleFunctionTable:atBufferIndex
setVisibleFunctionTables:withBufferRange
setIntersectionFunctionTable:atBufferIndex
setIntersectionFunctionTables:withBufferRange
insertDebugSignpost
pushDebugGroup
popDebugGroup
setLabel
updateFence
updateFence:afterStages
useHeap
useHeap:stages
useHeaps:count
useHeaps:count:stages
useResource:usage
useResource:usage:stages
useResources:count:usage
useResources:count:usage:stages
waitForFence
waitForFence:beforeStages
updateTextureMapping:mode:regions:mipLevel:slice
updateTextureMappings:mode:regions:mipLevels:numRegions:slices
updateTextureMappings:mode:indirectBuffer:indirectBufferOffset
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
%llu
-[MTLToolsResource validateCPUReadable]
resourceOptions (0x%lx) specify MTLResourceStorageModePrivate, which is not CPU accessible.
resourceOptions (0x%lx) specify MTLStorageModeMemoryless, which is not CPU accessible.
-[MTLToolsResource validateCPUWriteable]
%@:%@
v20@?0^I8I16
-[MTLDebugBlitCommandEncoder dealloc]
Command encoder released without endEncoding.
-[MTLDebugBlitCommandEncoder internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Encoder Copy From Texture Validation
the combination of MTLBlitOptionDepthFromDepthStencil and MTLBlitOptionStencilFromDepthStencil is invalid.
invalid usage because encoding has ended.
sourceTexture must not be nil.
sourceTexture is not a MTLTexture.
sourceTexture is associated with a different device
sourceTexture is Memoryless and cannot be used for copy operations!
destinationTexture must not be nil.
destinationTexture is not a MTLTexture.
destinationTexture is associated with a different device
destinationTexture is Memoryless and cannot be used for copy operations!
(sourceSize.width(%lu) * sourceSize.height(%lu) * sourceSize.depth(%lu))(%lu) must not be 0.
sourceTexture != nil
destinationTexture != nil
Copy From Texture Validation
[sourceTexture pixelFormat](%s) and [destinationTexture pixelFormat](%s) are not compatible for depth/stencil blits.
[sourceTexture pixelFormat](%s) must be compatible with [destinationTexture pixelFormat](%s).
[sourceTexture sampleCount](%lu) must equal [destinationTexture sampleCount](%lu).
sourceTexture must not be a framebufferOnly texture.
destinationTexture must not be a framebufferOnly texture.
sourceLevel(%lu) must be < [sourceTexture mipmapLevelCount](%lu).
sourceSlice(%lu) must be < (%lu).
destinationLevel(%lu) must be < [destinationTexture mipmapLevelCount](%lu).
destinationSlice(%lu) must be < (%lu).
(sourceOrigin.x + adjustedSourceSize.width)(%lu) must be <= paddedWidth(%lu).
(sourceOrigin.y + adjustedSourceSize.height)(%lu) must be <= paddedHeight(%lu).
(sourceOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(sourceOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(sourceOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(sourceOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
(destinationOrigin.x + adjustedDestinationSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedDestinationSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + destinationSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + destinationSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + destinationSize.depth)(%lu) must be <= depth(%lu).
sourceOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
sourceOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
sourceOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
size.width(%lu) must be a multiple of %s blockWidth(%lu).
size.height(%lu) must be a multiple of %s blockHeight(%lu).
size.depth(%lu) must be a multiple of %s blockDepth(%lu).
destinationOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
destinationOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
destinationOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
sourceOrigin.x must be 0 (full image) for %s.
sourceOrigin.y must be 0 (full image) for %s.
sourceOrigin.z must be 0 (full image) for %s.
sourceSize.width(%lu) must equal width(%lu) (full image) for %s.
sourceSize.height(%lu) must equal height(%lu) (full image) for %s.
sourceSize.depth(%lu) must equal depth(%lu) (full image) for %s.
destinationOrigin.x must be 0 (full image) for %s.
destinationOrigin.y must be 0 (full image) for %s.
destinationOrigin.z must be 0 (full image) for %s.
destinationSize.width(%lu) must equal width(%lu) (full image) for %s.
destinationSize.height(%lu) must equal height(%lu) (full image) for %s.
destinationSize.depth(%lu) must equal depth(%lu) (full image) for %s.
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s and destinationTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for destinationTexture with pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Copy From Buffer Validation
sourceBuffer must not be nil.
sourceBuffer is not a MTLBuffer.
sourceBuffer is associated with a different device
destinationTexture cannot be Memoryless.
(destinationOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
sourceOffset (%lu) must be a multiple of %lu bytes.
%s disallowed unless MTLBlitOptionRowLinearPVRTC option is used.
%s is not allowed to use the MTLBlitOptionRowLinearPVRTC option.
sourceBytesPerRow(%lu) must be >= (%lu).
sourceBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [sourceBuffer length](%lu).
sourceBytesPerRow (%lu) must be a multiple of %lu bytes.
sourceBytesPerImage (%lu) must be a multiple of %lu bytes.
sourceBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
blits between texture with pixel format %s and buffer are not allowed.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
destinationBuffer must not be nil.
destinationBuffer is not a MTLBuffer.
destinationBuffer is associated with a different device
destinationOffset (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be >= (%lu).
destinationBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [destinationBuffer length](%lu).
destinationBytesPerRow (%lu) must be a multiple of %lu bytes.
destinationBytesPerImage (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:]
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
-[MTLDebugBlitCommandEncoder generateMipmapsForTexture:]
Generate Mipmaps For Texture Validation
tex must not be nil.
tex is not a MTLTexture.
tex is associated with a different device
cannot generate mipmaps of Memoryless texture.
[tex mipmapLevelCount](%lu) must be > 1.
tex(%s) is not colorRenderable.
tex(%s) is not filterable.
tex != nil
-[MTLDebugBlitCommandEncoder fillBuffer:range:value:]
Fill Buffer Validation
buffer must not be nil.
buffer is not a MTLBuffer.
buffer is associated with a different device
(range.location + range.length)(%lu) must be <= [buffer length](%lu).
range.length(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder fillBuffer:range:pattern4:]
range.location(%lu) must be a multiple of 4 bytes.
range.length(%lu) must be a multiple of 4 bytes.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:]
(sourceOffset + size)(%lu) must be <= [sourceBuffer length](%lu).
(destinationOffset + size)(%lu) must be <= [destinationBuffer length](%lu).
size(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder waitForFence:]
MTLFence cannot be waited on after it has been updated within the same encoder.
-[MTLDebugBlitCommandEncoder endEncoding]
endEncoding without use.
-[MTLDebugBlitCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
firstBatch (%d) must be less than or equal to lastBatch(%d)
-[MTLDebugBlitCommandEncoder getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:]
Get Texture Access Counters Validation
countersBuffer must not be nil.
countersBuffer is not a MTLBuffer.
countersBuffer is associated with a different device
(countersBufferOffset)(%lu) must be < [countersBuffer length](%lu).
Only sparse textures support access counters.
-[MTLDebugBlitCommandEncoder resetTextureAccessCounters:region:mipLevel:slice:]
-[MTLDebugBlitCommandEncoder validateTextureAccess:region:mipLevel:slice:]
Validate Texture Access Validation
slice(%lu) must be lower than arrayLength(%lu)
mipLevel(%lu) must be lower or equal to min(mipmapLevelCount-1,firstMipmapInTail)(%lu)
texture != nil
(region.origin.x + region.width)(%lu) must be <= widthInTiles(%lu).
(region.origin.y + region.height)(%lu) must be <= heightInTiles(%lu).
(region.origin.z + size.depth)(%lu) must be <= depthInTiles(%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:]
Optimize Contents For GPU Access Validation
texture must not be nil.
texture is not a MTLTexture.
texture is associated with a different device
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:slice:level:]
level(%lu) must be < [texture mipmapLevelCount](%lu).
slice(%lu) must be < (%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:]
Optimize Contents For CPU Access Validation
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:slice:level:]
-[MTLDebugBlitCommandEncoder resetCommandsInBuffer:withRange:]
Specified range (loc=%lu, len=%lu) is not inside the command buffer with size %lu.
-[MTLDebugBlitCommandEncoder copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:]
Copy Indirect Command Buffer Validation
source is not a MTLIndirectCommandBuffer.
destination is not a MTLIndirectCommandBuffer.
Specified source range (loc=%lu, len=%lu) is not inside the source command buffer with size %lu.
Specified destination range (loc=%lu, len=%lu) is not inside the destination command buffer with size %lu.
source commandTypes (%lu) are not equal to destination commandTypes (%lu).
source inheritPipelineState (%s) is not equal to destination inheritPipelineState (%s).
source inheritBuffers (%s) is not equal to destination inheritBuffers (%s).
source maxVertexBufferBindCount (%lu) is not equal to destination maxVertexBufferBindCount (%lu).
source maxFragmentBufferBindCount (%lu) is not equal to destination maxFragmentBufferBindCount (%lu).
source maxKernelBufferBindCount (%lu) is not equal to destination maxKernelBufferBindCount (%lu).
source maxObjectBufferBindCount (%lu) is not equal to destination maxObjectBufferBindCount (%lu).
source maxMeshBufferBindCount (%lu) is not equal to destination maxMeshBufferBindCount (%lu).
-[MTLDebugBlitCommandEncoder optimizeIndirectCommandBuffer:withRange:]
Optimize Indirect Command Buffer Validation
Overlapping ranges are not allowed
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:bytes:length:]
Fill Texture Validation
bytes must not be nil.
texture must have a color format, but is %s.
region.origin.x must be 0 (full image) for %s.
region.origin.y must be 0 (full image) for %s.
region.origin.z must be 0 (full image) for %s.
region.size.width(%lu) must equal width(%lu) (full image) for %s.
region.size.height(%lu) must equal height(%lu) (full image) for %s.
region.size.depth(%lu) must equal depth(%lu) (full image) for %s.
buffer length for format %s must be at least %lu, but %lu was specified.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:]
format(%s) must be a color format.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:pixelFormat:]
format(%s) is not compatible with the texture format (%s).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:]
sliceCount must not be 0.
levelCount must not be 0.
sourceTexture.width(%lu) at mip %lu must match destinationTexture.width(%lu) at mip level %lu.
sourceTexture.height(%lu) at mip %lu must match destinationTexture.height(%lu) at mip level %lu.
sourceTexture.depth(%lu) at mip %lu must match destinationTexture.depth(%lu) at mip level %lu.
sourceLevel(%lu) + levelCount(%lu) must not exceed sourceTexture.mipmapLevelCount(%lu).
destinationLevel(%lu) + levelCount(%lu) must not exceed destinationTexture.mipmapLevelCount(%lu).
sourceSlice(%lu) + sliceCount(%lu) must not exceed sourceTexture.arrayLength(%lu) x sourceTexture.numFaces(%lu).
destinationSlice(%lu) + sliceCount(%lu) must not exceed destinationTexture.arrayLength(%lu) x destinationTexture.numFaces(%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:toTexture:]
-[MTLDebugBlitCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
Sample Counters In Buffer Validation
buffer must no be nil
Sample buffer is not a MTLCounterSampleBuffer.
Sample buffer is associated with a different device.
sampleIndex(%lu) must be < sampleCount(%lu).
MTLCounterSamplingPointAtBlitBoundary is not supported.
-[MTLDebugBlitCommandEncoder resolveCounters:inRange:destinationBuffer:destinationOffset:]
Resolve Counters Validation
MTLCounterSampleBuffer must be provided
Destination buffer is not a MTLBuffer.
Destination buffer is associated with a different device.
Destination offset (%llu) must be multiple of minimum constant buffer alignment (%llu).
NSMaxRange(range)(%lu) must be <= sampleCount(%lu).
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:]
Invalidate Compressed Texture Validation
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:slice:level:]
option is not a valid MTLBlitOption.
texture
Blit from %@ has protection options %016llx not set in command buffer protection options %016llx
Blit to %@ with protection options %016llx missing bits set in command buffer protection options %016llx
is illegal on a non-placement heap
is defined on a placement heap only when using a blit method copying entire texture surfaces, or when copying between buffers
is defined on a placement heap only when both textures have the same MTLTextureUsage flags
is defined on a placement heap only when both textures are linear and have the same bufferBytesPerRow value
is defined on a placement heap only when both top-level resources have the same layout
is defined on a placement heap when the texture views refer to the same sub-resources with the same texture type
top-level source and top-level destination resource dimensions must be identical when moving resources inside a placement heap
validateResourceAliasing
blitting between aliasing resources %s.
MTLBlitOptionNone
MTLBlitOptionDepthFromDepthStencil
MTLBlitOptionStencilFromDepthStencil
MTLBlitOptionRowLinearPVRTC
buffer
validateTextureRegion
region.size(%lu, %lu, %lu) must not be empty.
(region.origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(region.origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(region.origin.z + adjustedSize.depth)(%lu) must be <= paddedDepth(%lu).
region.origin.x(%lu) must be a multiple of %s blockWidth(%lu).
region.origin.y(%lu) must be a multiple of %s blockHeight(%lu).
region.origin.z(%lu) must be a multiple of %s blockDepth(%lu).
-[MTLDebugResourceStateCommandEncoder dealloc]
Command encoder released without endEncoding
-[MTLDebugResourceStateCommandEncoder validateSparseTextureMappingMode:]
Invalid mapping mode (%lu)
-[MTLDebugResourceStateCommandEncoder validateTextureAccess:region:mipLevel:slice:]
-[MTLDebugResourceStateCommandEncoder updateTextureMappings:mode:regions:mipLevels:slices:numRegions:]
Cannot update texture mapping: Encoder has ended encoding
Only sparse textures support mapping modifications.
mipLevels[%i](%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:region:mipLevel:slice:]
mipLevel(%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:]
-[MTLDebugResourceStateCommandEncoder moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
Resource State Encoder Validation
Only sparse textures (source) support mapping modifications.
Only sparse textures (destination) support mapping modifications.
The textures must have the same pixel format.
The source and destination texture must be created from the same heap.
destinationLevel(%lu) must be <= [destinationTexture firstMipmapInTail](%lu).
sourceLevel(%lu) must be <= [sourceTexture firstMipmapInTail](%lu).
-[MTLDebugResourceStateCommandEncoder waitForFence:]
-[MTLDebugResourceStateCommandEncoder endEncoding]
Can't end encoding for this encoder, already ended encoding
Ending encoding with no commands encoded.
-[MTLDebugBuffer makeAliasable]
This resource was not allocated on a heap.
-[MTLDebugBuffer newTextureWithDescriptor:offset:bytesPerRow:]
New Texture With Descriptor Validation
descriptor must not be nil.
descriptor is not a MTLTextureDescriptor.
resourceOptions (0x%lx) must match backing buffer resource options (0x%lx).
linear texture depth(%ld) must be 1
linear texture mipmapLevelCount(%ld) must be 1
linear texture sampleCount(%ld) must be 1
linear texture arrayLength(%ld) must be 1
compressionType must be set to lossless for linear textures
compressionFootprint must be set to lossless for linear textures
linear textures cannot be created with usage MTLTextureUsageRenderTarget
-[MTLDebugBuffer newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:]
Texture Descriptor Validation
2D linear texture array is not supported.
bytesPerImage must be aligned to %u bytes.
-[MTLDebugBuffer setPurgeableState:]
validateNewTexture
MTLTextureDescriptor.usage == MTLTextureUsageUnknown.
cannot create Memoryless texture from Buffer.
Textures with compressed pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with depth pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with stencil pixel formats cannot be created from a buffer and must be created as a standalone texture.
bytesPerRow(%lu) must be greater than (width * pixel_bytes)(%lu).
bytesPerRow must be non-zero.
Buffer-backed textures must have a texture type of MTLTextureType2D, MTLTextureTypeTextureBuffer or MTLTextureType2DArray, found %@.
Length required by texture offset, bytes per row, height and array length(%lu) exceed buffer capacity(%lu).
Offset of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found offset(%lu)
BytesPerRow of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found bytesPerRow(%lu)
-[MTLDebugDeadlineProfile validateCommandQueue:]
Deadline Profiles cannot be reused across command queues
-[MTLDebugCommandBuffer dealloc]
MTLCommandBuffer is in an invalid status when being destroyed; is it being over-released?
-[MTLDebugCommandBuffer encodeWaitForEvent:value:]
Standard MTLEvents must signal events on the same device. Use MTLSharedEvent for cross-device events.
-[MTLDebugCommandBuffer encodeWaitForEvent:value:timeout:]
-[MTLDebugCommandBuffer encodeSignalEvent:value:]
-[MTLDebugCommandBuffer waitUntilScheduled]
waitUntilScheduled on uncommitted command buffer
-[MTLDebugCommandBuffer waitUntilCompleted]
waitUntilCompleted on uncommitted command buffer
-[MTLDebugCommandBuffer blitCommandEncoder]
encoding in progress
-[MTLDebugCommandBuffer resourceStateCommandEncoder]
MSAA Resolve is only supported for color, depth, and stencil textures
MTLRenderPassDescriptor resolveTexture is associated with a different device
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1D.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType2DMultisample.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureTypeTextureBuffer.
MTLRenderPassDescriptor resolveTexture must not be Memoryless.
MTLRenderPassDescriptor texture and resolveTexture size mismatch.
PixelFormat %s cannot be a MSAA resolve target
Texture PixelFormat %s does not match Resolve PixelFormat %s
Slice is %lu, but the texture has only %lu slices
mipmap level is %lu, but the texture has only %lu levels
depth plane is %lu, but the texture has a depth of %lu at mip level %lu
resolveTexture sampleCount is %lu, but must be 1
resolveTexture must not be buffer-backed.
_MTLValidateDepthStencilStoreState
%@: mixing %@ and %@ store actions for the depth and stencil render pass attachments is not allowed.
MTLDebugRenderPipeline
MTLDebugRenderCommandEncoder
%@: the stencil attachment resolve filter mode (MTLMultisampleStencilResolveFilterDepthResolvedSample) is not valid because the depth attachment store action (%@) does not contain a resolve.
-[MTLDebugCommandBuffer addCompletedHandler:]
block cannot be nil
-[MTLDebugCommandBuffer addScheduledHandler:]
-[MTLDebugCommandBuffer unwrapMTLRenderPassDescriptor:]
colorAttachment[%lu].loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
depthAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
stencilAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
-[MTLDebugCommandBuffer renderCommandEncoderWithDescriptor:]
RenderCommandEncoder Validation
renderPassDescriptor must not be nil.
renderPassDescriptor is not a MTLRenderPassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoder]
-[MTLDebugCommandBuffer computeCommandEncoderWithDescriptor:]
ComputeCommandEncoder Validation
computePassDescriptor must not be nil.
computePassDescriptor is not a MTLComputePassDescriptor.
-[MTLDebugCommandBuffer blitCommandEncoderWithDescriptor:]
blitPassDescriptor must not be nil.
blitPassDescriptor is not a MTLBlitPassDescriptor.
-[MTLDebugCommandBuffer resourceStateCommandEncoderWithDescriptor:]
resourceStatePassDescriptor must not be nil.
resourceStatePassDescriptor is not a MTLResourceStatePassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoderWithDispatchType:]
-[MTLDebugCommandBuffer parallelRenderCommandEncoderWithDescriptor:]
ParallelRenderCommandEncoder Validation
-[MTLDebugCommandBuffer preCommit]
command buffer references deallocated object which previously existed at address %p.
-[MTLDebugCommandBuffer sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledRenderCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledComputeCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer lockPurgeableObjects]
MTLResource %p (label: %@), referenced in cmd buffer %p (label: %@) is in volatile or empty purgeable state at commit
-[MTLDebugCommandBuffer accelerationStructureCommandEncoder]
-[MTLDebugCommandBuffer accelerationStructureCommandEncoderWithDescriptor:]
Acceleration Structure Command Encoder Validation
accelerationStructurePassDescriptor must not be nil.
accelerationStructurePassDescriptor is not a MTLAccelerationStructurePassDescriptor.
-[MTLDebugCommandBuffer encodeDashboardTagForResourceGroup:]
Streaming Codec SPI
resourceGroup must be non-nil
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:]
dashboard(%llu) is not a valid MTLDashboard value
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:]
-[MTLDebugCommandBuffer commitWithDeadline:]
%s SPI should only be used with Deadline Aware Command Buffers
MTLStoreActionDontCare
MTLStoreActionStore
MTLStoreActionMultisampleResolve
MTLStoreActionStoreAndMultisampleResolve
MTLStoreActionUnknown
validateRenderPassDescriptor
RenderPass Descriptor Validation
not a MTLDebugTexture.
Texture at colorAttachment[%lu] has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions at color attachment %i includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
Attachment %u overlaps with attachment %u
MTLRenderPassDescriptor render targets have inconsistent sample counts.
Mixing MTLTextureType3D with other attachment types is not allowed when renderTargetArrayLength is not zero
This set of render targets requires %lu bytes of pixel storage. This device supports %lu bytes.
Texture at depthAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on the depth attachment includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
This render pass descriptor's clear depth (%f) is outside of the range [0..1]
Texture at stencilAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
rasterizationRateMap must be an MTLRasterizationRateMap instance.
rasterizationRateMap.device must match the current device.
renderTargetWidth (%lu) must be <= rasterizationRateMap.screenSize.width (%lu).
renderTargetHeight (%lu) must be <= rasterizationRateMap.screenSize.height (%lu).
renderTargetArrayLength (%lu) must be <= rasterizationRateMap.layerCount (%lu).
maximum physical rendering width (%lu) must be <= minimum attachment width (%lu).
maximum physical rendering height (%lu) must be <= minimum attachment height (%lu).
renderTargetWidth (%lu) must be <= minimum attachment width (%lu).
renderTargetHeight (%lu) must be <= minimum attachment height (%lu).
No rendertargets set in RenderPassDescriptor.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's renderTarget{Width|Height} properties to nonzero values.
Sparse textures are not supported as depth attachments on this device
Sparse textures are not supported as stencil attachments on this device
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must have a combined depth+stencil pixel format.
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must be the same depth and stencil texture.
When depth and stencil are used together, the render pass has to write to the same level and slice for both.
When depth and stencil are used together, the resolve texture for the depth and stencil render pass attachments must be the same depth and stencil texture.
When both depth (%lu x %lu) and stencil (%lu x %lu) are used from separate textures, they must have identical dimensions.
defaultColorSampleCount (%lu) is not supported by device.
defaultRasterSampleCount (%lu) is not supported by device.
no sampleCount for color and raster available, either set defaultColorSampleCount or set defaultRasterSampleCount or set appropriate attachments
unexpected color and depth/stencil sample counts
defaultColorSampleCount should be zero.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's defaultRasterSampleCount property to a nonzero value.
defaultRasterSampleCount should be zero.
Per sample storage cannot be greater than 64B
Per pixel storage cannot be greater than 256B
Total allocated thread group memory (%lu) cannot be greater than (%lu)
4X MSAA does not support 32 x 32 tiles
MTLRenderPassDescriptor visibilityResultBuffer is associated with a different device
%lu custom sample positions were programmed, but this render pass uses %lu rasterizer sample(s). These counts must match.
startOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
startOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfFragmentSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfFragmentSampleIndex must be MTLCounterDontSample
MTLRenderPassAttachmentDescriptor texture is associated with a different device
Memoryless attachment need to be Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
Memoryless attachment cannot be loaded as it have no memory to load from.
Memoryless attachment content cannot be stored in memory.
PixelFormat %s at color attachment %lu is not color renderable
PixelFormat %s is not depth renderable
PixelFormat %s is not stencil renderable
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1D.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1DArray.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureTypeTextureBuffer.
Slice is %lu, but the texture at attachment %lu has only %lu slices
mipmap level is %lu, but the texture at attachment %lu has only %lu levels
depth plane index is %lu, but the texture has a depth of %lu at mip level %lu
depth plane + renderTargetArrayLength is %lu, but the texture has a depth of %lu at mip level %lu.
slice + renderTargetArrayLength is %lu, but the texture only has %lu slices.
MTLRenderPassAttachmentDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action at attachment %lu requires resolve texture
MTLRenderPassAttachmentDescriptor %s depth resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor MTLMultisampleStencilResolveFilterDepthResolvedSample stencil resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor texture at attachment %lu must not be buffer-backed.
MTLRenderPassAttachmentDescriptor resolveTexture must have storeAction of MTLStoreActionMultisampleResolve, MTLStoreActionStoreAndMultisampleResolve or MTLStoreActionUnknown
MTLRenderPassAttachmentDescriptor texture must be MTLTextureType2DMultisample or MTLTextureType2DMultisampleArray when using a resolveTexture.
texture sampleCount is %lu, but must be > 1 when using a resolveTexture
the depth attachment
the stencil attachment
color attachment %lu
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, but Programmable Sample Positions is not supported on this device.
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, which does not apply to the store action (%@).
MTLMultisampleDepthResolveFilterSample0
MTLMultisampleDepthResolveFilterMin
MTLMultisampleDepthResolveFilterMax
validateTileDimensions
Invalid tile dimensions (%lu, %lu)
startOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfEncoderSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfEncoderSampleIndex must be MTLCounterDontSample
validateStoreLoadTransition
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. The results are undefined.
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. This is perfectly valid transition but it will result in reduced performance.
MTLLoadActionDontCare
MTLLoadActionLoad
MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES
-[MTLDebugDynamicLibrary serializeToURL:error:]
url must not be nil.
url must be a file URL.
-[MTLDebugDynamicLibrary serializeToURL:options:error:]
-[MTLDebugCounterSampleBuffer resolveCounterRange:]
NSMaxRange(indexRange)(%lu) must be <= sampleCount(%lu).
CPU access not allowed for sample buffers with MTLResourceStorageModePrivate.
-[MTLDebugBinaryArchive addComputePipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLComputePipelineDescriptor object.
descriptor.computeFunction must not be nil.
Linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLRenderPipelineDescriptor object.
Vertex linked functions cannot be added to this archive.
Fragment linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addMeshRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLMeshRenderPipelineDescriptor object.
Object linked functions cannot be added to this archive.
Mesh linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addTileRenderPipelineFunctionsWithDescriptor:options:error:]
device does not support tile shaders
descriptor is not a MTLTileRenderPipelineDescriptor object.
-[MTLDebugBinaryArchive serializeToURL:error:]
-[MTLDebugBinaryArchive serializeToURL:options:error:]
MTL_COUNTERS_LAYER_API_TIMING
-[MTLDebugCommandQueue insertDebugCaptureBoundary]
InsertDebugCaptureBoundary should not be called inside the completion handler
-[MTLDebugCommandQueue validateDeadlineAwareness:]
All commandBuffers from this commandQueue must have a deadlineProfile associated with it
Only MTLCommandQueues with MTLGPUPriorityRealTime can contain a deadline profile
-[MTLDebugComputeCommandEncoder dealloc]
computePipelineState =
<null>
Set Buffers:
Buffer %lu:
Set Textures:
Texture %lu:
Set Samplers:
Sampler %lu:
Set ThreadgroupMemoryLengths:
Threadgroup %lu:
Image Block Size: %lu x %lu
-[MTLDebugComputeCommandEncoder setComputePipelineState:]
computePipelineState must not be nil.
computePipelineState is not a MTLComputePipelineState.
computePipelineState is associated with a different device
redundant setComputePipelineState.
previous setComputePipelineState was unused.
-[MTLDebugComputeCommandEncoder setBytes:length:atIndex:]
length(%lu) must be <= %lu.
-[MTLDebugComputeCommandEncoder setBuffer:offset:atIndex:]
offset(%lu) must be < [buffer length](%lu).
offset(%lu) must be 0.
-[MTLDebugComputeCommandEncoder setBufferOffset:atIndex:]
index(%lu) must have an existing buffer.
-[MTLDebugComputeCommandEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an MTLBuffer.
buffers[%lu] is associated with a different device
offset[%lu](%lu) must be < [buffers[%lu] length](%lu).
offsets[%lu](%lu) must be 0.
-[MTLDebugComputeCommandEncoder setTexture:atIndex:]
frameBufferOnly texture not supported for compute.
Memoryless texture not supported for compute.
-[MTLDebugComputeCommandEncoder setTextures:withRange:]
textures[%lu] is not an MTLTexture.
textures[%lu] is associated with a different device
frameBufferOnly textures[%lu] not supported for compute.
textures[%lu] is Memoryless and cannot be assigned.
-[MTLDebugComputeCommandEncoder setSamplerState:atIndex:]
sampler is not a MTLSamplerState.
sampler is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerStates:withRange:]
samplers[%lu] is not an MTLSamplerState.
samplers[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugComputeCommandEncoder setSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugComputeCommandEncoder setThreadgroupMemoryLength:atIndex:]
length(%lu) must be a multiple of %lu bytes.
-[MTLDebugComputeCommandEncoder setImageblockWidth:height:]
width(%lu) must be a power of 2.
height(%lu) must be a power of 2.
width(%lu)*height(%lu) must be less than or equal to 1024
-[MTLDebugComputeCommandEncoder validateStageInRegion:]
stage_in region (width(%lu) * height(%lu) * depth(%lu))(%lu) must not be 0.
stage_in region (width)(%lu) must be <= width(%lu).
stage_in region (height)(%lu) must be <= height(%lu).
stage_in region (depth)(%lu) must be <= depth(%lu).
-[MTLDebugComputeCommandEncoder setStageInRegionWithIndirectBuffer:indirectBufferOffset:]
indirectBufferOffset (%lu) must be a multiple of 4
-[MTLDebugComputeCommandEncoder _validateThreadsPerThreadgroup:]
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must not be 0.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (device threadgroup size limit)
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (kernel threadgroup size limit)
threadsPerThreadgroup.width(%lu) must be <= %lu.
threadsPerThreadgroup.height(%lu) must be <= %lu.
threadsPerThreadgroup.depth(%lu) must be <= %lu.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be multiples of %lu.
-[MTLDebugComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:]
threadgroupsPerGrid.width(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.height(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadgroupsPerGrid.width(%lu) * threadgroupsPerGrid.y(%lu) * threadgroupsPerGrid.depth(%lu))(%lu) must not be 0.
Compute
stage_in region was not set for compute pipeline
-[MTLDebugComputeCommandEncoder dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:]
indirectBuffer must not be nil.
indirectBuffer is not a MTLBuffer.
indirectBuffer is associated with a different device
(indirectBufferOffset + sizeof(MTLDispatchThreadgroupsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
indirectBufferOffset(%lu) must be a multiple of 4 bytes.
-[MTLDebugComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:]
threadsPerGrid.width(%lu) must be <= UINT32_MAX.
threadsPerGrid.height(%lu) must be <= UINT32_MAX.
threadsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadsPerGrid.width(%lu) * threadsPerGrid.y(%lu) * threadsPerGrid.depth(%lu))(%lu) must not be 0.
-[MTLDebugComputeCommandEncoder dispatchThreadsWithIndirectBuffer:indirectBufferOffset:]
(indirectBufferOffset + sizeof(MTLDispatchThreadsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
-[MTLDebugComputeCommandEncoder waitForFence:]
-[MTLDebugComputeCommandEncoder endEncoding_private]
endEncoding without dispatchThreadgroups.
-[MTLDebugComputeCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
MTLVisibleFunctionTable
MTLIntersectionFunctionTable
-[MTLDebugComputeCommandEncoder useResource:usage:]
resource should not be nil
usage (0x%lx) has an invalid value
useResource:usage:
-[MTLDebugComputeCommandEncoder useResources:count:usage:]
resource (at index: %lu) should not be nil
useResources:count:usage: (index = %lu)
-[MTLDebugComputeCommandEncoder useHeap:]
heap should not be nil
-[MTLDebugComputeCommandEncoder useHeaps:count:]
heap (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder memoryBarrierWithScope:]
scope (0x%lx) has an invalid value for compute
compute memoryBarrierWithScope is not supported on this device
-[MTLDebugComputeCommandEncoder memoryBarrierWithResources:count:]
resources should not be nil or empty array
compute memoryBarrierWithResources is not supported on this device
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:withRange:]
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the compute pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugComputeCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDispatchBoundary is not supported.
-[MTLDebugComputeCommandEncoder setAccelerationStructure:atBufferIndex:]
Acceleration structure
-[MTLDebugComputeCommandEncoder setVisibleFunctionTable:atBufferIndex:]
functionTable is not a MTLVisibleFunctionTable.
functionTable is associated with a different device
-[MTLDebugComputeCommandEncoder setVisibleFunctionTables:withBufferRange:]
visibleFunctionTables[%lu] is not a MTLVisibleFunctionTable.
visibleFunctionTables[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTable:atBufferIndex:]
functionTable is not a MTLIntersectionFunctionTable.
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTables:withBufferRange:]
intersectionFunctionTables[%lu] is not a MTLIntersectionFunctionTable.
intersectionFunctionTables[%lu] is associated with a different device
validateArg
unused binding in encoder at %s index %lu.
sampler
threadgroupMemory
visibleFunctionTable
primitiveAccelerationStructure
instanceAccelerationStructure
intersectionFunctionTable
MTLDebugFunctionArgumentInit
redundant setting of %@.
thread_position_in_grid
threads_per_grid
thread_position_in_threadgroup
thread_index_in_threadgroup
threads_per_threadgroup
threadgroup_position_in_grid
threadgroups_per_grid
validateBuiltinArguments
Invalid built-in argument %@
component %lu: %llu must be <= %llu for %@ [[ %@ ]]
validateComputeFunctionArguments
%@ Function(%@): missing %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu].
%@ Function(%@): the offset into the buffer %@ that is bound at %s index %lu must be a multiple of %lu but was set to %lu.
%@ Function(%@): argument %@[%lu] from %s(%lu) with offset(%lu) and length(%lu) has space for %lu bytes, but argument has a length(%lu).
%@ Function(%@): Read-only bytes are being bound at index %lu to a shader argument with write access enabled (did you mean to use const or constant in the shader?).
%@ Function(%@): Reading from buffer bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to buffer bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): threadgroupMemoryLength(%lu) must be >= %lu at %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect type of texture (%@) bound at %s binding at index %lu (expect %@) for %@[%lu].
%@ Function(%@): Non-writeable texture format %s is being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): A sparse texture is being bound at index %lu to a shader argument with write access enabled. Sparse textures do not support writes from shaders.
%@ Function(%@): The pixel format (%s) of the %s (name:%@) bound at index %lu is incompatible with the data type (%@) of the %s parameter (%@ [[%s(%lu)]]). %s is compatible with the data type(s) %@.
%@ Function(%@): reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
%@ Function(%@): Shader uses texture(%@[%lu]) as read-write, but hardware does not support read-write texture of this pixel format.
%@ Function(%@): Reading from texture bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to texture bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu] - found %@.
Functon(%@): total used threadgroupMemoryLength(%lu) must be <= %lu.
validateTableStage
%@ called with a %s resource created for stage %@ rather than Compute
checkBuffer
%@ is not an MTLBuffer.
%@ is associated with a different device
%@ offset (%lu) must be < %@ length (%lu).
%@ must not be nil
%@ offset (%lu) must be 0.
checkAccelerationStructure
%@ is not an MTLAccelerationStructure.
checkMotionParameter
Acceleration descriptor is using primitive motion blur which is not supported by the device.
Primitive motion start time (%f) must be before or at the same time with motion end time (%f)
primitiveDataBuffer
checkPrimitiveData
primitiveDataElementSize must be non-zero
primitiveDataElementSize (%lu) cannot be larger than primitiveDataStride (%lu)
primitiveDataBufferOffset (%lu) exceeds primitiveDataBuffer.length (%lu)
primitiveDataBuffer.length (%lu) is not large enough to contain %lu primitives with primitiveDataBufferOffset (%lu), primitiveDataStride (%lu), and primitiveDataElementSize (%lu).
primitiveDataBufferOffset requires 4 byte alignment, found offset %lu.
primitiveDataStride requires 4 byte alignment, found offset %lu.
checkAccelerationStructureDescriptorWithRefitOptions
Number of geometry descriptors (%lu) must be less than 2^30
Number of geometry descriptors (%lu) must be less than 2^24
All geometry descriptors in a primitive acceleration structure descriptor must be the same type
Geometry descriptor intersection function table offset (%lu) must be less than 2^24
vertex buffer
Vertex buffer offset (%lu) must be a multiple of %lu bytes
index buffer
Index buffer offset (%lu) must be a multiple of the index data type stride (%lu)
Number of indices to read (triangle count multiplied by 3) (%lu) times index stride (%lu) plus index buffer offset (%lu) must be less than or equal to index buffer length (%lu)
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) must be less than or equal to vertex buffer length (%lu)
Motion keyframe count (%lu) must match vertexBuffers count (%lu)
Vertex buffer offset (%lu) in keyframe data must be a multiple of %lu bytes
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) in keyframe data must be less than or equal to vertex buffer length (%lu)
Bounding box stride (%lu) must be at least %lu bytes
Bounding box stride (%lu) must be a multiple of %lu bytes
bounding box buffer
Bounding box buffer offset (%lu) must be a multiple of %lu bytes
Bounding box buffer size (%lu) must be at least the bounding box buffer offset (%lu) plus the bounding box stride (%lu) times the number of bounding boxes (%lu)
Motion keyframe count (%lu) must match boundingBoxBuffers count (%lu)
Geometry descriptor must be a MTLAccelerationStructureTriangleGeometryDescriptor, a MTLAccelerationStructureMotionTriangleGeometryDescriptor, a MTLAccelerationStructureBoundingBoxGeometryDescriptor or a MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor
Number of primitives (%lu) must be less than 2^30
Number of primitives (%lu) must be less than 2^28
Number of instances (%lu) must be less than 2^30
Number of instances (%lu) must be less than 2^24
Instance descriptor type (%lu) is not a valid MTLAccelerationStructureInstanceDescriptorType
Instance descriptor stride (%lu) must be at least %lu bytes
Instance descriptor stride (%lu) must be a multiple of %lu bytes
instance descriptor buffer
Instance descriptor buffer offset (%lu) must be a multiple of %lu bytes
Instance descriptor buffer size (%lu) must be at least the instance descriptor buffer offset (%lu) plus the instance descriptor stride (%lu) times the number of instances (%lu)
Instanced acceleration structure
Must have at least 1 instanced acceleration structure if instance count > 0
Acceleration structure descriptor must be a MTLPrimitiveAccelerationStructureDescriptor or a MTLInstanceAccelerationStructureDescriptor
Acceleration structure descriptor must not be nil
-[MTLDebugAccelerationStructureCommandEncoder buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:]
Cannot build acceleration structure because encoder has ended encoding
Scratch buffer
Acceleration structure size (%lu) must be at least %lu bytes
Scratch buffer size (%lu) must be at least scratch buffer offset (%lu) plus required scratch buffer size (%lu)
-[MTLDebugAccelerationStructureCommandEncoder validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:]
Cannot refit acceleration structure because encoder has ended encoding
No options specified on refit
Source acceleration structure
Destination acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder copyAccelerationStructure:toAccelerationStructure:]
Cannot copy acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:]
Cannot write compacted acceleration structure because encoder has ended encoding
Size buffer
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:]
sizeDataType must be MTLDataTypeUInt or MTLDataTypeULong
-[MTLDebugAccelerationStructureCommandEncoder copyAndCompactAccelerationStructure:toAccelerationStructure:]
Cannot copy and compact acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:]
Cannot write serialized acceleration structure size because encoder has ended encoding
The size buffer is not big enough to hold the size (64 bits required)
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:]
Cannot write deserialized acceleration structure size because encoder has ended encoding
Serialized acceleration structure buffer
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:]
Cannot write deserialized primitive acceleration structure sizes because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:]
serializePrimitiveAccelerationStructure validation
Cannot serialize acceleration structure because encoder has ended encoding
Buffer
-[MTLDebugAccelerationStructureCommandEncoder serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:]
serializeInstanceAccelerationStructure validation
Primitive acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:]
deserializePrimitiveAccelerationStructure validation
Cannot deserialize acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
deserializeInstanceAccelerationStructure validation
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder serializeAccelerationStructure:toBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:]
Cannot write geometry size of acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:]
Cannot write geometry of acceleration structure because encoder has ended encoding
Geometry buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:into:]
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:into:]
Header buffer
Inner node buffer
Leaf node buffer
Primitive buffer
Instance transform buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:]
Sizes buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeAccelerationStructureSerializationData:toBuffer:offset:]
Output buffer
MTLAccelerationStructureSerializationData exceeds end of buffer from offset (%lu) with length (%lu).
Buffer requires 4 byte alignment, found offset %lu.
validateVertexFormatAndStride
Single component vertex formats are not supported
Vertex stride (%lu) must be at least %lu bytes
Vertex stride (%lu) must be a multiple of %lu bytes
Transformation buffer
validateTransformationBuffer
MTLPackedFloat4x3 exceeds end of transformation buffer from offset (%lu) with length (%lu).
Transformation buffer requires 4 byte alignment, found offset %lu.
None
Vertex
Fragment
Tile
Object
Mesh
-[MTLDebugComputePipelineState functionHandleWithFunction:]
function must not be nil.
function is not a MTLFunction.
-[MTLDebugComputePipelineState newComputePipelineStateWithAdditionalBinaryFunctions:error:]
Pipeline state is adding functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding functions which is not supported by the device
Function '%s' was found in functions array but is not precompiled.
Unable to create new compute pipeline state with additional binary functions: %@
-[MTLDebugComputePipelineState newVisibleFunctionTableWithDescriptor:]
descriptor is not a MTLVisibleFunctionTableDescriptor.
-[MTLDebugComputePipelineState newIntersectionFunctionTableWithDescriptor:]
descriptor is not a MTLIntersectionFunctionTableDescriptor.
-[MTLDebugComputePipelineState validateHandleForSetFunction:]
The function handle for function '%s' was not created from the pipeline state that created this MTLVisibleFunctionTable.
-[MTLDebugIndirectCommandBuffer indirectRenderCommandAtIndex:]
Indirect Command Buffer Validation
CPU access for MTLIndirectCommandBuffer with MTLResourceStorageModePrivate storage mode is disallowed.
MTLIndirectCommandBuffer created without any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectRenderCommands 
The requested command (%lu) is greater than the indirect command buffer size (%lu)
-[MTLDebugIndirectCommandBuffer indirectComputeCommandAtIndex:]
MTLIndirectCommandBuffer created with any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectComputeCommands 
-[MTLDebugIndirectCommandBuffer setPurgeableState:]
-[MTLDebugIndirectCommandBuffer resetWithRange:]
MTL_XML_DUMP_COUNTERS
MTL_XML_SYNC_BEFORE_SAMPLE
MTL_XML_TRACE_PATH
xml_trace_%p
Error creating directory '%@' (%@)
MTL_XML_COUNTER_NAMES
MTLStat_nSec
Unsupported counter: %@
Failed to request counters
Index %u does not match any member of the argument buffer
Index %u does not correspond to any valid member of the argument buffer
Trying to set a %@ at index %u but the argument buffer has a %@ at this index
index range (%lu, %lu) has indices that are outside of the valid index range [%u, %u]
index (%lu) is outside of the valid index range [%u, %u]
-[MTLDebugArgumentEncoder setArgumentBuffer:startOffset:elementIndex:]
Argument Buffer Validation
buffer is not a MTLBuffer
buffer storage mode (%@) should be MTLStorageModeShared
offset (%lu) + encodedLength (%lu) should be smaller or equal to the buffer length (%lu)
-[MTLDebugArgumentEncoder setBuffer:offset:atIndex:]
No argument buffer is set
buffer is not a valid MTLBuffer
offset (%lu) should be smaller than the buffer length (%lu)
offset(%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an valid MTLBuffer.
offsets[%lu](%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setTexture:atIndex:]
-[MTLDebugArgumentEncoder setTextures:withRange:]
-[MTLDebugArgumentEncoder setSamplerState:atIndex:]
Sampler state did not have supportArgumentBuffers flag set on creation, but is used with argument buffers
-[MTLDebugArgumentEncoder setSamplerStates:withRange:]
-[MTLDebugArgumentEncoder constantDataAtIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineState:atIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineStates:withRange:]
-[MTLDebugArgumentEncoder setComputePipelineState:atIndex:]
-[MTLDebugArgumentEncoder setComputePipelineStates:withRange:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffer:atIndex:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffers:withRange:]
-[MTLDebugArgumentEncoder newArgumentEncoderForBufferAtIndex:]
No argument buffer at that index
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withRange:]
Constant
Texture
Sampler
Struct
RenderPipelineState
ComputePipelineState
IndirectCommandBuffer
VisibleFunctionTable
IntersectionFunctionTable
PrimitiveAccelerationStructure
InstanceAccelerationStructure
METAL_COMPLAIN_ABOUT_SLOPPY_TEXTURE_USAGE
MTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS
MTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS
-[MTLDebugDevice heapTextureSizeAndAlignWithDescriptor:]
-[MTLDebugDevice newHeapWithDescriptor:]
New Heap With Descriptor Validation
Sparse heaps are not supported on this device
Heap needs to have a size.
Requested storage mode is not allowed for Heaps.
Requested CPU cache mode is not allowed for Heaps.
Requested hazard tracking mode is not allowed for Heaps.
Storage mode must be MTLStorageModePrivate for heap type MTLHeapTypeSparse
Memoryless texture need to have renderable PixelFormat.
Memoryless texture need to be of type Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
options 0x%lx conveys invalid cpuCacheMode of 0x%lx
IOSurface textures must use MTLStorageModeShared
MTLStorageModeShared not allowed for textures
MTLStorageModeMemoryless can only be used with textures
MTLStorageModeMemoryless is not supported on this device
Illegal MTLStorageMode 0x%lx
options 0x%lx conveys invalid hazardTrackingMode of 0x%lx
MTLResourceOptions options has unknown bits 0x%lx.
Cannot create buffer of zero length.
newBufferWith*:length 0x%lx must not exceed %llu MB.
-[MTLDebugDevice newBufferWithLength:options:]
Buffer Validation
-[MTLDebugDevice newBufferWithBytes:length:options:]
storageModePrivate incompatible with ...WithBytes variant of newBuffer
newBufferWithBytes:pointer must not be nil.
-[MTLDebugDevice newBufferWithBytesNoCopy:length:options:deallocator:]
storageModePrivate incompatible with ...WithBytesNoCopy variant of newBuffer
newBufferWithBytesNoCopy:pointer must not be nil.
newBufferWithBytesNoCopy:pointer %p is not %d byte aligned.
newBufferWithBytesNoCopy:length 0x%lx is not %d byte aligned.
-[MTLDebugDevice newBufferWithDescriptor:]
MTLResourceStorageModeShared should be used with noCopy=YES or contents being set
contents must not be nil when noCopy is set to YES
MTLBufferDescriptor.contents %p is not %d byte aligned.
MTLBufferDescriptor.length 0x%lx is not multiple of %d.
-[MTLDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
maximum vertex buffer bind count (%lu) must be <= %lu.
maximum fragment buffer bind count (%lu) must be <= %lu.
maximum kernel buffer bind count (%lu) must be <= %lu.
-[MTLDebugDevice newArgumentEncoderWithArguments:]
arguments cannot be nil
arguments must have at least one element
-[MTLDebugDevice newTextureWithBytesNoCopy:length:descriptor:deallocator:]
MTLResourceStorageModeShared must be used.
newTextureWithBytesNoCopy:pointer must not be nil.
newTextureWithBytesNoCopy:pointer %p is not %d byte aligned.
-[MTLDebugDevice newDepthStencilStateWithDescriptor:]
descriptor is not a MTLDepthStencilDescriptor.
texture buffer width (%llu) must be less than %llu
texture buffer height (%llu) must be 1
texture buffer depth (%llu) must be 1
texture buffer mipmapLevelCount (%llu) must be 1
texture buffer sampleCount (%llu) must be 1
texture buffer arrayLength (%llu) must be 1
usage must be set
MTLTextureUsageRenderTarget is not valid for a texture buffer
Texture buffer usage must contain read or write
texture buffer with pixel format (%s) cannot be written to from a shader
pixel format (%s) cannot be written to from a shader on this device
pixel format (%s) cannot be used for a texture buffer
-[MTLDebugDevice newTextureWithDescriptor:]
Cannot use an Xn format when creating a new texture
-[MTLDebugDevice newSamplerStateWithDescriptor:]
descriptor is not a MTLSamplerDescriptor.
-[MTLDebugDevice newBinaryArchiveWithDescriptor:error:]
Binary Archive with Descriptor Validation
descriptor is not a MTLBinaryArchiveDescriptor object.
url, if not nil, must be a file URL.
-[MTLDebugDevice newBinaryLibraryWithOptions:url:error:]
-[MTLDebugDevice newDynamicLibraryWithURL:options:error:]
Dynamic Library with URL Validation
device does not support dynamic libraries
-[MTLDebugDevice newDynamicLibrary:computeDescriptor:error:]
Dynamic Library Validation
library must not be nil.
library is not a MTLLibrary object.
-[MTLDebugDevice newDynamicLibrary:error:]
-[MTLDebugDevice loadDynamicLibrariesForComputeDescriptor:options:error:]
-[MTLDebugDevice loadDynamicLibrariesForFunction:insertLibraries:options:error:]
insertLibaries must not be nil.
-[MTLDebugDevice validateDynamicLibrary:state:error:]
-[MTLDebugDevice validateDynamicLibraryURL:error:]
Pipeline descriptor is using MTLLinkedFunctions functions which is not supported by the device.
Function '%s' in group '%s' was not found in functions array.
Pipeline descriptor is using MTLLinkedFunctions groups which is not supported by the device.
Pipeline descriptor is using MTLLinkedFunctions %@ which is not supported by the device.
Function '%s' was found in %@ array but is not precompiled.
functions
privateFunctions
binaryFunctions
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:reflection:error:]
Render Pipeline State Descriptor Validation
descriptor is not a MTLRenderPipelineDescriptor.
vertexPreloadedLibraries is not empty but device does not support render dynamic libraries
fragmentPreloadedLibraries is not empty but device does not support render dynamic libraries
objectPreloadedLibraries is not empty but device does not support render dynamic libraries
meshPreloadedLibraries is not empty but device does not support render dynamic libraries
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:reflection:error:]
Compute Pipeline State Descriptor Validation
descriptor is not a MTLComputePipelineDescriptor.
preloadedLibraries is not empty but device does not support dynamic libraries
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:reflection:error:]
Tile Render Pipeline State Descriptor Validation
descriptor is not a MTLTileRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:reflection:error:]
Mesh Pipeline State Descriptor Validation
descriptor is not a MTLMeshRenderPipelineDescriptor.
device does not support mesh shaders.
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:completionHandler:]
-[MTLDebugDevice newLibraryWithFile:error:]
filepath must not be nil.
filepath is not a NSString.
-[MTLDebugDevice newLibraryWithURL:error:]
url is not a NSURL.
Invalid file url
-[MTLDebugDevice newLibraryWithSource:options:error:]
Library with Source Validation
options is not a MTLCompileOptions.
options.libraries contains an object that is not a MTLDynamicLibrary at index %lu.
source must not be nil.
source is not a NSString.
-[MTLDebugDevice newLibraryWithSource:options:completionHandler:]
-[MTLDebugDevice newLibraryWithData:error:]
data must not be nil.
-[MTLDebugDevice newPipelineLibraryWithFilePath:error:]
-[MTLDebugDevice newTextureWithDescriptor:iosurface:plane:]
iosurface must not be nil.
-[MTLDebugDevice newBufferWithIOSurface:]
-[MTLDebugDevice minLinearTextureAlignmentForPixelFormat:]
minLinearTextureAlignment Validation
%s is not supported on this device.
Linear textures do not support compressed pixel formats
Linear textures do not support depth/stencil pixel formats
-[MTLDebugDevice minimumLinearTextureAlignmentForPixelFormat:]
-[MTLDebugDevice newCounterSampleBufferWithDescriptor:error:]
MTLCounterSampleBufferDescriptor must be provided
descriptor is not a MTLCounterSampleBufferDescriptor.
-[MTLDebugDevice newLateEvalEvent]
Event Creation Validation
Late Eval Events not supported on this device
-[MTLDebugDevice newFence]
Attempt to create new fence over the fence instance limit (%lu).
The following Metal object is being destroyed while still required to be alive by the command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
The following Metal object has been over-released by the application and is being destroyed while still retained by command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
-[MTLDebugDevice notifyExternalReferencesNonZeroOnDealloc:]
<no label set>
-[MTLDebugDevice validateRaytracing]
device does not support ray tracing
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:]
buffer offset (%lu) must be < buffer length (%lu).
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:resourceIndex:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:]
-[MTLDebugDevice deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:]
accelerationStructure must not be nil.
-[MTLDebugDevice deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice newVisibleFunctionTableWithDescriptor:]
-[MTLDebugDevice newIntersectionFunctionTableWithDescriptor:]
MTLDebugShaders
simple_vertex
_validateRasterizationRateMapLayers
RasterizationRateMap Layers Validation
device must support variable rasterization rate feature.
screenSize.width (%lu) must be >0 and <=%lu.
screenSize.height (%lu) must be >0 and <=%lu.
layerCount (%lu) must be >0 and <=%lu.
layers must not be nil.
layers[%lu] must not be nil.
layers[%lu] must be a MTLRasterizationRateLayerDescriptor instance.
fill_checkboard_fragment
threadgroupMemoryLength
functionTable
accelerationStructure
buffer =
bufferOffset =
texture =
baseLevel =
sampler =
lodMinClamp =
lodMaxClamp =
threadgroupMemoryLength =
newArgumentEncoder
Function %@ does not have a buffer argument with buffer index %lu
Buffer argument %@ (buffer index: %lu) of function %@ is not an indirect argument buffer. If %@ is expected to be an argument buffer, this could be a shader bug. Argument buffers can be distinguished from regular buffers if they contain buffers, textures, samplers, or any element with the [[id]] attribute
-[MTLDebugLibrary newFunctionWithName:]
name is not a NSString.
validateNewFunctionWithConstantArguments
functionName is not a NSString.
constantValues must not be nil.
-[MTLDebugLibrary validateDescriptor:expectedClass:]
descriptor is not a %@.
Requesting binary compilation which is not supported by the device - supportsFunctionPointers = NO.
All linked functions must have unique names. Function '%s' is a duplicate symbol in %s, symbol first found in %s.
_validateUniqueNames
basic_string
-[MTLDebugParallelRenderCommandEncoder setColorStoreAction:atIndex:]
attachmentIndex(%lu) must be < %lu
-[MTLDebugParallelRenderCommandEncoder setColorStoreActionOptions:atIndex:]
-[MTLDebugParallelRenderCommandEncoder endEncoding_private]
endEncoding called with store action for color attachment index %u still set to MTLStoreActionUnknown
endEncoding called with store action for depth attachment still set to MTLStoreActionUnknown
endEncoding called with store action for stencil attachment still set to MTLStoreActionUnknown
endEncoding called with store action unsupported for Memoryless attachment.
-[MTLDebugParallelRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
filterCounterRangeWithFirstBatch should not be called on ParallelRenderCommandEncoders
%s must not be nil.
%s is not a MTLBuffer.
%s is associated with a different device
%sOffset(%lu) + (indexCount(%lu) * %lu) must be <= [%s length](%lu).
indexCount(%lu) must be non-zero.
%sOffset(%lu) must be a multiple of %lu bytes.
_MTLDebugValidatePatchIndexBuffer
Patch Index Buffer Validation
%sOffset(%lu) + (patchIndicesUsed(%lu) * %lu) must be <= [%s length](%lu).
patchCount(%lu) must be non-zero.
instanceCount(%lu) must be non-zero.
%sOffset(%lu) must be 0.
v24@?0@"<MTLRenderCommandEncoderSPI>"8Q16
-[MTLDebugRenderCommandEncoder _init]_block_invoke
Exceeded HW limit of resources used by render encoder working in Memoryless mode.
Exceeded HW limit of scissor rectangles for render encoder working in Memoryless mode.
Exceeded HW limit of depth biases for render encoder working in Memoryless mode.
Internal error preventing the usage of memoryless for this render encoder.
-[MTLDebugRenderCommandEncoder dealloc]
descriptor =
viewportCount =
viewports:
Viewport %lu:
frontFacingWinding =
cullMode =
depthClipMode =
lineWidth =
depthBias =
depthBiasSlopeScale =
depthBiasClamp =
scissorRectCount =
scissorRects:
Scissor %lu:
amplificationMode =
amplificationValue =
vertexAmplificationCount =
triangleFillMode =
renderPipelineState =
depthStencilState =
frontStencilRef =
0x%x
backStencilRef =
visibilityResultMode =
visibilityResultOffset =
Blend Color =
%g %g %g %g
Set Vertex Buffers:
Set Vertex Textures:
Set Vertex Samplers:
Set Fragment Buffers:
Set Fragment Textures:
Set Fragment Samplers:
Set Tile Buffers:
Set Tile Textures:
Set Tile Samplers:
Set Tessellation Factor Buffer =
tessellationFactorBufferInstanceStride =
tessellationFactorScale =
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState colorSampleCount (%lu).
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For color attachment %d, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For color attachment %d, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For depth attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For depth attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For stencil attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For stencil attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
The color sample count (%lu) does not match the renderPipelineState's color sample count (%lu)
The raster sample count (%lu) does not match the renderPipelineState's raster sample count (%lu)
Device does not support separable raster/color shading rates
The sample count (%lu) does not match the renderPipelineState's sample count (%lu)
-[MTLDebugRenderCommandEncoder setRenderPipelineState:]
Set Render Pipeline State Validation
renderPipelineState must not be nil.
redundant setRenderPipelineState.
previous setRenderPipelineState was unused.
renderPipelineState is not a MTLRenderPipelineState.
renderPipelineState is associated with a different device
the pipelineState's per sample imageBlock usage(%lu) is greater than the encoder's perSample imageBlock usage(%lu)
The threadgroup memory consumed must be <= (%lu)
-[MTLDebugRenderCommandEncoder setVertexBytes:length:atIndex:]
Set Vertex Bytes Validation
-[MTLDebugRenderCommandEncoder setVertexBuffer:offset:atIndex:]
Set Vertex Buffer Validation
-[MTLDebugRenderCommandEncoder setVertexBufferOffset:atIndex:]
Set Vertex Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setVertexBuffers:offsets:withRange:]
Set Vertex Buffers Offset Validation
-[MTLDebugRenderCommandEncoder setVertexTexture:atIndex:]
Set Vertex Texture Validation
texture is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexTextures:withRange:]
Set Vertex Textures Validation
textures[%lu] is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexSamplerState:atIndex:]
Set Vertex Sampler State Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:withRange:]
Set Vertex Sampler States Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentBytes:length:atIndex:]
Set Fragment Bytes Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBufferOffset:atIndex:]
Set Fragment Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffers:offsets:withRange:]
Set Fragment Buffers Validation
-[MTLDebugRenderCommandEncoder setFragmentTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentTextures:withRange:]
Set Fragment Textures Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:atIndex:]
Set Fragment Sampler State Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:withRange:]
Set Fragment Sampler States Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:]
textureIndex(%lu) must be < %lu.
samplerIndex(%lu) must be < %lu.
-[MTLDebugRenderCommandEncoder setTileBytes:length:atIndex:]
Set Tile Bytes Validation
-[MTLDebugRenderCommandEncoder setTileBuffer:offset:atIndex:]
Set Tile Buffer Validation
-[MTLDebugRenderCommandEncoder setTileBufferOffset:atIndex:]
Set Tile Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setTileBuffers:offsets:withRange:]
Set Tile Buffers Validation
-[MTLDebugRenderCommandEncoder setTileTexture:atIndex:]
Set Tile Texture Validation
-[MTLDebugRenderCommandEncoder setTileTextures:withRange:]
Set Tile Textures Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:atIndex:]
Set Tile Sampler State Validation
-[MTLDebugRenderCommandEncoder setTileSamplerStates:withRange:]
Set Tile Sampler States Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder _dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:]
Dispatch Threads Per Tile Validation
the renderPipelineState was not created with a tileDescriptor
threadsPerTile (%lu, %lu) must equal tile size (%lu, %lu) when threadgroupSizeMatchesTileSize is true
threadsPerTile.width(%lu) and threadsPerTile.height(%lu) must match the tile size or threadsPerTile.width(%lu) must be equal to threadsPerTile.height(%lu)
roundup2(threadsPerTile.width(%lu)) * roundup2(threadsPerTile.height(%lu)) * threadsPerTile.depth(%lu) must be <= %lu, both width and height are rounded up to nearest even number 
tile shader input image-block layout must match the previous state's image-block layout
threadsPerTile.width(%lu) * threadsPerTile.height(%lu) * threadsPerTile.depth(%lu) must not be 0
threadsPerTile.width(%lu) must be <= %lu
threadsPerTile.depth(%lu) must be 1
-[MTLDebugRenderCommandEncoder setThreadgroupMemoryLength:offset:atIndex:]
Set Threadgroup Memory Length Validation
A dispatch is required to reinterpret threadgroup memory.
offset + length(%lu) must be <= threadgroupMemoryLength(%lu).
offset(%lu) must be a multiple of %lu bytes.
-[MTLDebugRenderCommandEncoder useResource:usage:]
Use Resource Validation
-[MTLDebugRenderCommandEncoder useResource:usage:stages:]
stages (0x%lx) has an invalid stage
'stages' does not specify any render stages. Specify at least one stage.
useResource:usage:stages:
-[MTLDebugRenderCommandEncoder useResources:count:usage:]
Use Resources Validation
-[MTLDebugRenderCommandEncoder useResources:count:usage:stages:]
useResources:count:usage:stages: (index = %lu)
-[MTLDebugRenderCommandEncoder useHeap:]
-[MTLDebugRenderCommandEncoder useHeap:stages:]
Use Heap Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:]
Use Heaps Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:stages:]
-[MTLDebugRenderCommandEncoder setViewport:]
Viewport Validation
redundant setViewport.
previous setViewport was unused.
-[MTLDebugRenderCommandEncoder setViewports:count:]
viewports parameter cannot be nullptr
viewport count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setFrontFacingWinding:]
Set Front Facing Winding Validation
redundant setFrontFacingWinding.
previous setFrontFacingWinding was unused.
-[MTLDebugRenderCommandEncoder setCullMode:]
Set Cull Mode Validation
redundant setCullMode.
previous setCullMode was unused.
-[MTLDebugRenderCommandEncoder setDepthClipMode:]
Set Depth Clip Mode Validation
redundant setDepthClipMode.
previous setDepthClipMode was unused.
-[MTLDebugRenderCommandEncoder setLineWidth:]
Set Line Width Validation
lineWidth(%g) must be between 1.0f and %.1ff
redundant setLineWidth.
previous setLineWidth was unused.
-[MTLDebugRenderCommandEncoder setDepthBias:slopeScale:clamp:]
Set Depth Bias Validation
redundant setDepthBias.
previous setDepthBias was unused.
-[MTLDebugRenderCommandEncoder setScissorRect:]
Set Scissor Rect Validation
redundant setScissorRect.
previous setScissorRect was unused.
-[MTLDebugRenderCommandEncoder setScissorRects:count:]
Set Scissor Rects Validation
scissorRects parameter cannot be nullptr
scissor rect count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setTransformFeedbackState:]
Set Transform Feedback State Validation
-[MTLDebugRenderCommandEncoder setVertexAmplificationMode:value:]
Set Vertex Amplification Mode Validation
vertexAmplificationMode is not a valid MTLVertexAmplificationMode.
the number of bits set to 1 in value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
redundant setVertexAmplificationMode.
previous setVertexAmplificationMode was unused.
-[MTLDebugRenderCommandEncoder setVertexAmplificationCount:viewMappings:]
invalid usage because device does not support vertex amplification.
count(%u) is not supported on this device. See supportsVertexAmplificationCount:(NSUInteger).
redundant setVertexAmplificationCount.
previous setVertexAmplificationCount was unused.
-[MTLDebugRenderCommandEncoder setTriangleFrontFillMode:backFillMode:]
Set Triangle Front Fill Mode Validation
-[MTLDebugRenderCommandEncoder setTriangleFillMode:]
Set Triangle Fill Mode Validation
redundant setTriangleFillMode.
previous setTriangleFillMode was unused.
-[MTLDebugRenderCommandEncoder setDepthStencilState:]
Set Depth Stencil State Validation
depthStencilState must not be nil.
depthStencilState is not a MTLDepthStencilState.
depthStencilState is associated with a different device
redundant setDepthStencilState.
previous setDepthStencilState was unused.
-[MTLDebugRenderCommandEncoder setStencilReferenceValue:]
Set Stencil Reference Value Validation
redundant setStencilReferenceValue.
previous setStencilReferenceValue was unused.
-[MTLDebugRenderCommandEncoder setStencilFrontReferenceValue:backReferenceValue:]
Set Stencil Front Reference Value Validation
_MTLDebugValidateDeferredStoreActionOnDevice
Deferred Store Action Validation
storeAction must not be MTLStoreActionUnknown
store actions known at render command encoder init time may not be mutated
storeAction unsupported for Memoryless attachment.
MTLRenderPassDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassDescriptor %s store action requires resolve texture
Store action for color attachment index %u must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for depth attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for stencil attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
-[MTLDebugRenderCommandEncoder setColorStoreAction:atIndex:]
Set Color Store Action Validation
deferred color store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreAction:]
deferred depth store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreAction:]
deferred stencil store actions cannot be set on sub render command encoders
_MTLDebugValidateDeferredStoreActionOptionsOnDevice
Deferred Store Action Options on Device Validation
-[MTLDebugRenderCommandEncoder setColorStoreActionOptions:atIndex:]
Set Color Store Action Options Validation
deferred color store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreActionOptions:]
deferred depth store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreActionOptions:]
deferred stencil store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setVisibilityResultMode:offset:]
Set Visibility Result Mode Validation
offset(%lu) must be a multiple of result-size(%u) bytes.
offset(%lu) must be <= %lu.
using the same offset (%lu) in the visibility buffer twice in the same command encoder is not allowed.
framebuffer visibilityResultBuffer must not be nil.
offset(%lu) + result-size(%u) must be <= [visibilityResultBuffer length](%lu).
redundant setVisibilityResultMode.
previous setVisibilityResultMode was unused.
-[MTLDebugRenderCommandEncoder setBlendColorRed:green:blue:alpha:]
Set Blend Color Validation
redundant setBlendColorRed.
previous setBlendColorRed was unused.
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:atIndex:]
Set Color Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:]
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:]
Set Depth Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:yInvert:]
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:]
Set Stencil Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:yInvert:]
primitiveType is not a valid MTLPrimitiveType.
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:]
Draw Errors Validation
only triangles may be drawn when using a rasterization rate map.
renderPipelineState must be set.
renderPipelineState must be created using a MTLRenderPipelineDescriptor.
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassPoint but primitiveType is not MTLPrimitiveTypePoint
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassLine but primitiveType is neither MTLPrimitiveTypeLine nor MTLPrimitiveTypeLineStrip
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassTriangle but primitiveType is neither MTLPrimitiveTypeTriangle nor MTLPrimitiveTypeTriangleStrip
renderPipelineState is a mesh shader pipeline, which cannot be used for this draw command
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:]
The scissor rectangle count (%lu) should be equal to the viewport count (%lu) or should be 1.
input image-block layout must match the previous state image-block layout
the renderPipelineState has a vertex shader that writes to render_target_array_index but renderTargetArrayLength is set to zero
renderPipelineState is not a mesh shader pipeline
Vertex Amplification Count (%u) must be between (inclusive) 1 and the maximum vertex amplification count specified in the pipeline state (%u)
-[MTLDebugRenderCommandEncoder validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:]
Draw Primitives Validation
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:]
-[MTLDebugRenderCommandEncoder validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:]
Draw Indexed Primitives Validation
indexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
-[MTLDebugRenderCommandEncoder drawPrimitives:indirectBuffer:indirectBufferOffset:]
indirectBuffer
sizeof(MTLDrawPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawIndexedPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder setObjectBytes:length:atIndex:]
Set Object Bytes Validation
-[MTLDebugRenderCommandEncoder setObjectBuffer:offset:atIndex:]
Set Object Buffer Validation
-[MTLDebugRenderCommandEncoder setObjectBufferOffset:atIndex:]
Set Object Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setObjectBuffers:offsets:withRange:]
Set Object Buffers Validation
-[MTLDebugRenderCommandEncoder setObjectTexture:atIndex:]
Set Object Texture Validation
-[MTLDebugRenderCommandEncoder setObjectTextures:withRange:]
Set Object Textures Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:atIndex:]
Set Object Sampler State Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:withRange:]
Set Object Sampler States Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
Set Object Threadgroup Memory Length Validation
-[MTLDebugRenderCommandEncoder setObjectThreadgroupMemoryLength:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshBytes:length:atIndex:]
Set Mesh Bytes Validation
-[MTLDebugRenderCommandEncoder setMeshBuffer:offset:atIndex:]
Set Mesh Buffer Validation
-[MTLDebugRenderCommandEncoder setMeshBufferOffset:atIndex:]
Set Mesh Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setMeshBuffers:offsets:withRange:]
Set Mesh Buffers Validation
-[MTLDebugRenderCommandEncoder setMeshTexture:atIndex:]
Set Mesh Texture Validation
-[MTLDebugRenderCommandEncoder setMeshTextures:withRange:]
Set Mesh Textures Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:atIndex:]
Set Mesh Sampler State Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:withRange:]
Set Mesh Sampler States Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
Draw Mesh Threadgroups With Indirect Buffer Validation
sizeof(MTLDispatchThreadgroupsIndirectArguments)
-[MTLDebugRenderCommandEncoder updateFence:afterStages:]
Cannot set the (MTLRenderStages)afterStages to 0. The parameter should be set to a valid MTLRenderStages value.
-[MTLDebugRenderCommandEncoder waitForFence:beforeStages:]
Cannot set the (MTLRenderStages)beforeStages to 0. The parameter should be set to a valid MTLRenderStages value.
Wait for Fence Validation
-[MTLDebugRenderCommandEncoder endEncoding_private]
End Encoding Validation
endEncoding without draw.
-[MTLDebugRenderCommandEncoder setTessellationFactorBuffer:offset:instanceStride:]
Set Tessellation Factor Buffer Validation
offset(%lu) must be a multiple of 4 bytes.
instanceStride(%lu) must be a multiple of 4 bytes.
-[MTLDebugRenderCommandEncoder setTessellationFactorScale:]
scale(%g) must be a normal floating point value (not denormal, infinite, nor NaN) and must be > 0.0f.
-[MTLDebugRenderCommandEncoder drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:]
patchIndexBuffer
-[MTLDebugRenderCommandEncoder drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
Draw Patches Validation
sizeof(MTLDrawPatchIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:]
Draw Indexed Patches Validation
controlPointIndexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugRenderCommandEncoder textureBarrier]
-textureBarrier is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithScope:afterStages:beforeStages:]
Memory Barrier With Scope Validation
render memoryBarrierWithScope is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithResources:count:afterStages:beforeStages:]
Memory Barrier With Resources Validation
render memoryBarrierWithResources is not supported on this device
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:withRange:]
Execute Commands In Buffer Validation
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the render pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDrawBoundary is not supported.
-[MTLDebugRenderCommandEncoder setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Table Validation
-[MTLDebugRenderCommandEncoder setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Tables Validation
intersectionFunctionTable is associated with a different stage (%@, expected %@)
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Table Validation
intersectionFunctionTable is not a MTLIntersectionFunctionTable.
intersectionFunctionTable is associated with a different device
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Tables Validation
-[MTLDebugRenderCommandEncoder setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Acceleration Structure Validation
indexType not valid MTLIndexType
%g %g %g %g %g %g
MTLWindingClockwise
MTLWindingCounterClockwise
MTLCullModeNone
MTLCullModeFront
MTLCullModeBack
MTLDepthClipModeClip
MTLDepthClipModeClamp
%lu %lu %lu %lu
MTLTriangleFillModeFill
MTLTriangleFillModeLines
MTLTriangleFillModePoint
MTLVisibilityResultModeDisabled
MTLVisibilityResultModeBoolean
MTLVisibilityResultModeCounting
local memory
%s must not be infinite or NaN.
viewport.originX
viewport.originY
viewport.width
viewport.height
viewport.znear
viewport.zfar
frontFacingWinding is not a valid MTLWinding.
cullMode is not a valid MTLCullMode.
depthClipMode is not a valid MTLDepthClipMode.
(rect.x(%lu) + rect.width(%lu))(%lu) must be <= render pass width(%lu)
(rect.y(%lu) + rect.height(%lu))(%lu) must be <= render pass height(%lu)
state(%u) is not a valid MTLTransformFeedbackState.
fillMode is not a valid MTLTriangleFillMode.
mode is not a valid MTLVisibilityResultMode.
%@ Function(%@): binding at index %lu is not a MTLDebugTexture.
%@ Function(%@): Shader reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): Shader writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
q24@?0@8@16
%@ Function(%@): there is an overlap with the threadgroupMemoryArgument at offset (%lu) and at offset(%lu).
validateDisjointRenderTargetsAndTexture
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also a %s attachment at index %lu. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and writeMask != MTLColorWriteMaskNone.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and depth writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and stencil writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is currently being written to in this render pass. This may be a conflict.
resolve
color
depth
stencil
vertex_id type is not big enough to draw this many vertices (%lu)
instance_id type is not big enough to draw this many instances (%lu)
missing vertexDescriptor %s binding at index %lu.
incorrect vertexDescriptor %s binding at index %lu.
MTLDepthStencilDescriptor sets depth test but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor has depthWriteEnabled but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor uses frontFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
MTLDepthStencilDescriptor uses backFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
%s requires a postTessellationVertexFunction but the vertexFunction of the renderPipelineState is not a postTessellationVertexFunction.
%s requires a normal vertexFunction but the vertexFunction of the renderPipelineState is a postTessellationVertexFunction.
(%sOffset + %s)(%lu) must be <= [%s length](%lu).
%sOffset(%lu) must be a multiple of 4 bytes.
validateCommonTessellationErrors
Common Tessellation Errors Validation
missing tessellationFactorBuffer binding.
numberOfPatchControlPoints(%lu) must match the number of control points(%ld) set in the vertexFunction of the renderPipelineState.
numberOfPatchControlPoints(%lu) must be <= 32.
for drawIndexedPatches numberOfPatchControlPoints(%lu) must not be 0.
for MTLTessellationFactorStepFunctionConstant and MTLTessellationFactorStepFunctionPerPatch tessellationFactorBufferInstanceStride(%lu) must be zero.
for MTLTessellationFactorStepFunctionPerInstance and MTLTessellationFactorStepFunctionPerPatchAndPerInstance tessellationFactorBufferInstanceStride(%lu) must be non-zero.
tessellationFactorBufferInstanceStride(%lu) must be a multiple of %lu bytes.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeNone not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt16 not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt32 not valid for %s.
tessellationFactorBuffer
%sOffset(%lu) + tessellationFactorBytesUsed(%lu) must be <= [%s length](%lu).
(patchStart + patchCount)(%lu) * %lu must be <= tessellationFactorBufferInstanceStride(%lu).
%@ called with stages (0x%lx), but %s resource was created for stage %@
MTL_XML_DUMP_EVENTS
MTLCommandBufferKernelStartTime
MTLCommandBufferKernelEndTime
MTLCommandBufferGPUStartTime
MTLCommandBufferGPUEndTime
-[MTLDebugResource doesAliasResource:]
Resource Validation
Input resource was not allocated on a heap.
-[MTLDebugResource doesAliasAllResources:count:]
Resources count cannot be zero.
resources must not be nil
Input resource %0lx was not allocated on a heap.
-[MTLDebugResource doesAliasAnyResources:count:]
v24@?0@"MTLStructType"8Q16
-[MTLDebugIndirectRenderCommand setVertexBuffer:offset:atIndex:]
Vertex Buffer Validation
-[MTLDebugIndirectRenderCommand setFragmentBuffer:offset:atIndex:]
Fragment Buffer Validation
-[MTLDebugIndirectRenderCommand drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
drawPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
drawIndexedPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setRenderPipelineState:]
Render Pipeline State Validation
-[MTLDebugIndirectRenderCommand drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawIndexedPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setObjectBuffer:offset:atIndex:]
Object Buffer Validation
index(%lu) must be < maxObjectBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setMeshBuffer:offset:atIndex:]
Mesh Buffer Validation
index(%lu) must be < maxMeshBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setBarrier]
setBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand clearBarrier]
clearBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreadgroups is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreads is not enabled on this indirect command buffer
-[MTLDebugRenderPipelineState validateHandleForSetFunction:]
-[MTLDebugRenderPipelineState validateBinaryFunctions:stage:]
Pipeline state is adding %@ functions which is not supported by the device
Function '%s' was found in %@ functions array but is not precompiled.
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:]
Pipeline state is adding vertex functions but it was created with supportAddingVertexBinaryFunctions=NO
Pipeline state is adding fragment functions but it was created with supportAddingFragmentBinaryFunctions=NO
Unable to create new render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:]
Unable to create new tile render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:error:]
cannot specify both tile and render pipeline additional functions simultaneously.
Pipeline state is adding tile functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding object functions but it was created with supportAddingObjectBinaryFunctions=NO
Pipeline state is adding mesh functions but it was created with supportAddingMeshBinaryFunctions=NO
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:selector:]
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:]
stage invalid.
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:selector:]
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:withStage:selector:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:stage:]
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) cannot exceed maxTotalThreadsPer%sThreadgroup (%lu)
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) must be multiple of %sThreadExecutionWidth (%lu)
validateMTLSamplerDescriptor
Sampler Descriptor Validation
MTLSamplerDescriptor:non-normalized coords require MTLSamplerMipFilterNotMipmapped.
MTLSamplerDescriptor:non-normalized coords require MTLSamplerAddressModeClampToEdge, MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor.
MTLSamplerDescriptor:non-normalized coords require maxAnisotropy == 1.
MTLSamplerDescriptor:non-normalized coords require minFilter==magFilter of MTLSamplerMinMagFilterNearest or MTLSamplerMinMagFilterLinear, to be portable to all Metal devices.
MTLSamplerDescriptor's min filter value (%lu) is invalid.
MTLSamplerDescriptor's mag filter value (%lu) is invalid.
MTLSamplerDescriptor's mip filter value (%lu) is invalid.
MTLSamplerDescriptor's max anisotropy value (%lu) is invalid. Clamping to [%i, %i] range.
MTLSamplerDescriptor's S texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's T texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's R texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's texture coordinate address modes must either contain MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor modes but not both.
MTLSamplerDescriptor: pixelFormat(%s) must be MTLPixelFormatInvalid when supportsArgumentBuffers == YES
MTLSamplerAddressModeMirrorClampToEdge is not supported on this device
MTLSamplerAddressModeClampToHalfBorderColor is not supported on this device
Custom border colors are not supported on this device
%@ is not supported on this device
Exceeded the limit on number of unique samplers usable in argument buffers (which is %u)
Sparse textures cannot be created with dual-plane texture formats
The requested hazard tracking mode does not match the heap's mode
The requested CPU cache mode does not match the heap's mode
The requested storage mode is not compatible with the heap's mode
Shared textures created via heaps are not supported on this device
MTLResourceOptions options have unknown bits 0x%lx.
MTLTextureUsageShaderWrite is not supported for MTLHeapTypeSparse on this platform
-[MTLDebugHeap maxAvailableSizeWithAlignment:]
aligment needs to be power of two, or zero.
-[MTLDebugHeap newBufferWithLength:options:]
Requested length %lu must not exceed heap size %lu.
Cannot create buffer from sparse heap.
newBufferWithLength:options: cannot be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options:offset: instead.
-[MTLDebugHeap newTextureWithDescriptor:]
newTextureWithDescriptor: cannot be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor:offset: instead.
Sparse textures are not supported on this device
MTLHeapTypeSparse does not support MTLTextureType1D and MTLTextureType1DArray
MTLHeapTypeSparse does not support MTLTextureTypeTextureBuffer
MTLUnmappedDepthValueOne is only supported for MTLPixelFormatDepth32Float
-[MTLDebugHeap setPurgeableState:]
-[MTLDebugHeap validateOffset:withRequirements:]
Offset Validation
Cannot place resource at offset %lu extending beyond the heap size %lu (resource size %lu)
Cannot place resource at offset %lu which is not aligned to %lu bytes
-[MTLDebugHeap newBufferWithLength:options:offset:]
newBufferWithLength:options:offset: can only be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options: instead.
-[MTLDebugHeap newTextureWithDescriptor:offset:]
newTextureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor: instead.
-[MTLDebugHeap validateRaytracingHeap]
Heap must be MTLStorageModePrivate to allocate acceleration structures
-[MTLDebugHeap newAccelerationStructureWithSize:]
Cannot create acceleration structure of zero size.
Requested size %lu must not exceed heap size %lu.
-[MTLDebugHeap newAccelerationStructureWithSize:offset:]
newAccelerationStructureWithSize:offset can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize: instead.
-[MTLDebugHeap newAccelerationStructureWithDescriptor:offset:]
newAccelerationStructureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithDescriptor: instead.
-[MTLDebugHeap newAccelerationStructureWithSize:resourceIndex:]
-[MTLDebugHeap newAccelerationStructureWithSize:offset:resourceIndex:]
newAccelerationStructureWithSize:offset:resourceIndex can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize:resourceIndex: instead.
-[MTLDebugTexture dealloc]
usageRequested 0x%lx != usageRequired 0x%lx
-[MTLDebugTexture makeAliasable]
Sparse textures cannot be made aliasable.
Memoryless textures cannot be made aliasable.
Texture Views created from Textures, that are backed by the Heap, cannot be made aliasable.
-[MTLDebugTexture setPurgeableState:]
Set Purgeable Stage Validation
_validateReplaceRegion
Replace Region Validation
(size.width(%lu) * size.height(%lu) * size.depth(%lu))(%lu) must not be 0.
CPU access for textures with MTLResourceStorageModePrivate storage mode is disallowed.
CPU access for textures with MTLStorageModeMemoryless is disallowed.
texture must not be a framebufferOnly texture.
mipmapLevel(%lu) must be < [texture mipmapLevelCount](%lu).
(origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(origin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(origin.x + size.width)(%lu) must be <= width(%lu).
(origin.y + size.height)(%lu) must be <= height(%lu).
(origin.z + size.depth)(%lu) must be <= depth(%lu).
origin.x(%lu) must be a multiple of %s blockWidth(%lu).
origin.y(%lu) must be a multiple of %s blockHeight(%lu).
origin.z(%lu) must be a multiple of %s blockDepth(%lu).
origin.x must be 0 (full image) for %s.
origin.y must be 0 (full image) for %s.
origin.z must be 0 (full image) for %s.
size.width(%lu) must equal width(%lu) (full image) for %s.
size.height(%lu) must equal height(%lu) (full image) for %s.
size.depth(%lu) must equal depth(%lu) (full image) for %s.
rowBytes must be 0 for %s.
imageBytes must be 0 for %s.
rowBytes(%lu) must be >= (%lu).
imageBytes(%lu) must be >= (%lu).
rowBytes(%lu) must be a multiple of %s %s bytes(%lu).
block
pixel
imageBytes(%lu) must be a multiple of %s %s bytes(%lu).
CPU access for this texture with pixel format %s is disallowed.
Replacing region on slice(%u) on mipmapLevel(%u) that is currently attached as a writeable render target.
_validateGetBytes
Get Bytes Validation
GetBytes Validation
_validateTextureView
Texture View Validation
cannot create View from Memoryless texture.
texture usage (0x%02lx) doesn't specify MTLTextureUsagePixelFormatView (0x%02lx)
invalid pixelFormat.
texture view creation not allowed from frameBufferOnly textures.
textureType %@ cannot be used for buffer-backed textures.
-[MTLDebugAccelerationStructure setPurgeableState:]
Intel
12StringBuffer
12AppendBuffer
12BinaryBuffer
BufferHeap::MemoryAllocated (MB) - %.2f
BufferHeap::MemoryUsed (MB) - %.2f/%.2f
DescriptorHeapSize (MB) - %.2f
DescriptorHeapNewHandle - %llu
ConstantBufferCache::TotalMemory - %llu
Device Alloc - %s, %p
Device Dealloc - %s, %p
Fatal failure when instrumenting %s "%s":
Function is not instrumented and faults will not be detected.
Partial failure when instrumenting %s "%s":%s%s
MTLDebugIndirectComputeCommand
MTLGPUDebugRenderCommandEncoder
MTLGPUDebugCommandEncoder
NSObject
MTLToolsIndirectCommandBuffer
MTLIndirectCommandBufferSPI
MTLIndirectCommandBuffer
MTLResource
MTLGPUDebugGPULog
MTLFunctionLog
MTLGPUDebugBufferErrorLog
MTLGPUDebugTextureErrorLog
MTLGPUDebugStackOverflowErrorLog
MTLGPUDebugTrapErrorLog
MTLToolsBlitCommandEncoder
MTLBlitCommandEncoderSPI
MTLCommandEncoderSPI
MTLCommandEncoder
MTLBlitCommandEncoder
MTLToolsFence
MTLFenceSPI
MTLFence
MTLCountersRenderCommandEncoder
MTLToolsCounterSampleBuffer
MTLCounterSampleBuffer
MTLGPUDebugLibrary
MTLToolsBuffer
MTLBufferSPI
MTLResourceSPI
MTLBuffer
MTLToolsCommandBuffer
MTLCommandBufferSPI
MTLCommandBuffer
MTLToolsRetainingContainer
MTLToolsCommandEncoder
MTLToolsPerfCounterMailbox
MTLToolsCommandQueue
MTLCommandQueueSPI
MTLCommandQueue
MTLDebugVisibleFunctionTable
MTLDebugResourcePurgeable
MTLToolsDynamicLibrary
MTLDynamicLibrarySPI
MTLDynamicLibrary
MTLToolsBinaryArchive
MTLBinaryArchiveSPI
MTLBinaryArchive
MTLToolsHeap
MTLHeapSPI
MTLHeap
MTLToolsComputeCommandEncoder
MTLComputeCommandEncoderSPI
MTLComputeCommandEncoder
MTLGPUDebugImageData
MTLToolsAccelerationStructureCommandEncoder
MTLAccelerationStructureCommandEncoderSPI
MTLAccelerationStructureCommandEncoder
MTLToolsComputePipelineState
MTLComputePipelineStateSPI
MTLComputePipelineState
MTLPipelineStateWithProgramAddressTable
MTLGPUDebugAccelerationStructure
MTLGPUDebugResource
MTLGPUDebugBuffer
MTLToolsDepthStencilState
MTLDepthStencilStateSPI
MTLDepthStencilState
MTLToolsIndirectComputeCommand
MTLIndirectComputeCommandSPI
MTLIndirectComputeCommand
MTLGPUDebugDevice
MTLToolsDevice
MTLDeviceSPI
MTLDevice
MTLToolsEvent
MTLEventSPI
MTLEvent
MTLToolsSharedEvent
MTLSharedEventSPI
MTLSharedEvent
MTLToolsLateEvalEvent
MTLLateEvalEvent
MTLToolsFunction
MTLFunctionSPI
MTLFunction
MTLToolsLibrary
MTLLibrarySPI
MTLLibrary
MTLToolsVisibleFunctionTable
MTLVisibleFunctionTableSPI
MTLVisibleFunctionTable
MTLDebugPipelineLibrary
MTLCountersComputeCommandEncoder
MTLGPUDebugRenderPipelineState
MTLGPUDebugAccelerationStructureCommandEncoder
MTLToolsObject
MTLToolsParallelRenderCommandEncoder
MTLParallelRenderCommandEncoderSPI
MTLParallelRenderCommandEncoder
MTLToolsIntersectionFunctionTable
MTLIntersectionFunctionTableSPI
MTLIntersectionFunctionTable
MTLToolsRenderCommandEncoder
MTLRenderCommandEncoderSPI
MTLRenderCommandEncoder
MTLGPUDebugIntersectionFunctionTable
MTLGPUDebugIndirectComputeCommand
MTLToolsRasterizationRateMap
MTLRasterizationRateMapSPI
MTLRasterizationRateMap
MTLDebugIntersectionFunctionTable
MTLCountersTraceCommandEncoder
MTLCountersTraceBlitCommandEncoder
MTLCountersTraceComputeCommandEncoder
MTLCountersTraceRenderCommandEncoder
MTLCountersTraceResourceStateCommandEncoder
MTLCountersTraceCommandBuffer
MTLToolsRenderPipelineState
MTLRenderPipelineStateSPI
MTLRenderPipelineState
MTLToolsResource
MTLToolsResourceGroupSPI
MTLResourceGroupSPI
MTLGPUDebugIndirectRenderCommand
MTLToolsSamplerState
MTLSamplerState
MTLSamplerStateSPI
MTLToolsTexture
MTLTextureImplementation
MTLTextureSPI
MTLTexture
MTLToolsTextureLayout
MTLTextureLayout
MTLCountersParallelRenderCommandEncoder
MTLGPUDebugCommandBuffer
MTLGPUDebugBufferEncoder
MTLToolsResourceStateCommandEncoder
MTLResourceStateCommandEncoderSPI
MTLResourceStateCommandEncoder
MTLDebugBlitCommandEncoder
MTLDebugResourceStateCommandEncoder
MTLDebugBufferMarker
MTLDebugBuffer
MTLDebugDeadlineProfile
MTLGPUDebugCommandQueue
MTLDebugCommandBuffer
MTLGPUDebugBinaryArchive
MTLGPUDebugPipelineStateInfoEncoder
MTLDebugDynamicLibrary
MTLToolsIndirectRenderCommand
MTLIndirectRenderCommandSPI
MTLIndirectRenderCommand
MTLDebugCounterSampleBuffer
MTLDebugBinaryArchive
MTLCountersDevice
MTLGPUDebugArgumentEncoder
MTLGPUDebugComputePipelineState
MTLDebugCommandQueue
MTLDebugComputeCommandEncoder
MTLAccelerationStructure
MTLDebugAccelerationStructureCommandEncoder
MTLDebugFunctionHandle
MTLFunctionHandle
MTLDebugComputePipelineState
MTLDebugIndirectCommandBuffer
MTLCountersCommandQueue
MTLToolsPipelineLibrary
MTLPipelineLibrarySPI
MTLPipelineLibrary
MTLToolsArgumentEncoder
MTLArgumentEncoderSPI
MTLArgumentEncoder
MTLGPUDebugHeap
MTLDebugArgumentEncoder
MTLDebugDevice
MTLDebugDepthStencilState
MTLGPUDebugIndirectCommandBuffer
MTLDebugEvent
MTLDebugSharedEvent
MTLDebugLateEvalEvent
MTLGPUDebugFunctionHandle
MTLGPUDebugParallelRenderCommandEncoder
MTLCountersResourceStateCommandEncoder
MTLToolsAccelerationStructure
MTLAccelerationStructureSPI
MTLToolsObjectCache
MTLDebugFunction
MTLDebugLibrary
MTLDebugParallelRenderCommandEncoder
MTLDebugRenderTargetAttachmentInfo
MTLDebugRenderCommandEncoder
MTLToolsDeadlineProfile
MTLDeadlineProfile
MTLCountersCommandBuffer
MTLGPUDebugBlitCommandEncoder
MTLGPUDebugVisibleFunctionTable
MTLDebugResource
MTLGPUDebugComputeCommandEncoder
MTLToolsFunctionHandle
MTLGPUDebugFunction
MTLDebugIndirectRenderCommand
MTLDebugRenderPipelineState
MTLDebugSamplerState
MTLDebugHeap
MTLDebugTexture
MTLDebugTextureLayout
MTLGPUDebugDynamicLibrary
MTLDebugAccelerationStructure
MTLGPUDebugTexture
MTLCountersBlitCommandEncoder
T@"<MTLHeap>",R
.cxx_destruct
T@"NSArray",C,N
AnisoSampleFixSupported
T@"NSString",&,N,V_functionName
ClampToHalfBorderSupported
TB,R,GisIntegrated,V_integrated
FixedLinePointFillDepthGradientSupported
TQ,R,N,V_visibilityResultOffset
GPUEndTime
T{?=dddddd},R,N
ICB_DepthStencilState
_activeSubViews
ICB_Inherit_Buffers_ComputePipelineState
_attachmentInfo
ICB_Inherit_None_ComputePipelineState
_blendColorBlue
ICB_Inherit_PSO_ComputePipelineState
_common
RGB10A2GammaSupported
_constantOffset
StatEnabled
_currentEncoder
StatOptions
_descriptorHeap
T@"<MTLAccelerationStructure>",&,D,N
_deviceInitFlag
T@"<MTLBuffer>",&,N
_dynamicLibrary
T@"<MTLBuffer>",R
_height
T@"<MTLBuffer>",R,V_buffer
_imageBlockSize
T@"<MTLComputePipelineState>",R,N
_length
T@"<MTLComputePipelineState>",R,N,V_computePipelineState
_maxVertexCount
T@"<MTLDepthStencilState>",R,N
_newComputePipelineStateWithFunction:options:completionHandler:
T@"<MTLDevice>",R
_newRenderPipelineStateWithDescriptor:options:reflection:error:
T@"<MTLFunction>",R,N
_objectSamplers
T@"<MTLFunctionHandle>",R,N
_objectThreadgroupMemoryLengths
T@"<MTLFunctionLogDebugLocation>",R,N
_parent
T@"<MTLIndirectCommandBufferSPI>",&,D,N
_specifiedUsage
T@"<MTLLogContainer>",R
_subViewUseLock
T@"<MTLRenderPipelineState>",R,N
_textureIndices
T@"<MTLResource>",R
_tileDescriptor
T@"<MTLTexture>",R
_validateThreadsPerThreadgroup:
T@"<MTLTexture>",R,N,V_baseResolveTexture
_vertexSamplers
T@"<MTLTexture>",R,V_parentTexture
addLibraryWithDescriptor:error:
T@"<MTLToolsRetainingContainer>",R,N,V_commandBuffer
arrayWithArray:
T@"MTLAccelerationStructureDescriptor",&,N
baseLevelOffset
T@"MTLArgument",&,N,V_argument
binaryFunctions
T@"MTLComputePipelineDescriptor",R,N,V_descriptor
blendColorGreen
T@"MTLComputePipelineReflection",R,N,V_reflection
builtInDataType
T@"MTLCountersTraceCommandBuffer",R,N,V_traceBuffer
complainAboutSloppyTextureUsage
T@"MTLDebugInstrumentationData",&,N
compressionType
T@"MTLDebugInstrumentationData",R,N
containsObject:
T@"MTLDepthStencilDescriptor",R,N,V_defaultDepthStencilDescriptor
copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:
T@"MTLFunctionConstantValues",&,V_constantValues
copyGranularity
T@"MTLGPUDebugBuffer",R,N
deadlineProfile
T@"MTLGPUDebugDevice",R,D
defaultTextureWriteRoundingMode
T@"MTLGPUDebugFunction",R,W,N
didModifyRange:
T@"MTLGPUDebugImageData",R,N
elementIsIndirectArgumentBuffer
T@"MTLIndirectCommandBufferDescriptor",R
enqueue
T@"MTLRenderPassDescriptor",R,C,N,V_descriptor
errorStackTrace
T@"MTLRenderPipelineReflection",R,N
frontStencilRef
T@"MTLSamplerDescriptor",R,C,N,V_descriptor
importedSymbols
T@"MTLTextureDescriptor",R,C,N,V_descriptor
initWithBaseObject:descriptor:indexCount:indirectCommandBuffer:
T@"MTLToolsFunction",R,V_function
initWithDevice:
T@"NSArray",&,N,V_errorStackTrace
initWithHeap:descriptor:device:
T@"NSArray",R,N,V_binaryFunctionData
innerNodeBuffer
T@"NSData",R
intersectionFunctionTableOffset
T@"NSDictionary",R
isLinearTexture
T@"NSMutableArray",R
kernelStartTime
T@"NSMutableSet",R,N
library
T@"NSObject<OS_dispatch_data>",R
loadedImageName
T@"NSString",C
maxInterpolants
T@"NSString",C,N,V_label
maxTileSamplers
T@"NSString",R,C
maxTotalThreadgroupsPerMeshGrid
T@"NSString",R,N,V_tracePath
meshFunctionHandleWithFunction:
T@"_MTLIndirectArgumentBufferLayout",R,N
motionStartTime
T@,C,N,V_code
newCommandQueue
newDynamicLibraryFromURL:error:
TB,GisProfilingEnabled
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
TB,N,GisStatEnabled
newRenderPipelineStateWithDescriptor:options:completionHandler:
TB,R
objectArguments
TB,R,GareProgrammableSamplePositionsSupported
pipelineLibrary
TB,R,GisBCTextureCompressionSupported
pointer
TB,R,GisCustomBorderColorSupported
primitiveBuffer
TB,R,GisFixedLinePointFillDepthGradientSupported
pushDebugGroup:
TB,R,GisFramebufferOnly
resetWithRange:
TB,R,GisLargeMRTSupported
retainedObjects
TB,R,GisMeshShaderPipeline
separateCommits
TB,R,GisPlacementHeapSupported
setAdditionalCompilerArguments:
TB,R,GisRGB10A2GammaSupported
setBufferIndex:
TB,R,GisRemovable
setDepthCleared
TB,R,N,V_APITimingEnabled
setFragmentReportBuffer:offset:
TB,R,V_loadValidationEnabled
setIndexBuffer:
TB,V_useRetainedObjectsLock
setKernelBuffer:offset:atIndex:
TI,R
setObjectBuffer:offset:atIndex:
TI,R,N,V_backStencilRef
setRelocations:
TI,R,V_encoderID
setScissorRect:
TQ,N
setStatOptions:
TQ,N,GgetStatOptions
setThreadgroupDistributionMode:
TQ,N,V_debugType
setVertexBuffer:offset:atIndex:
TQ,N,V_type
standardizedURL
TQ,R,D,N
stringByAppendingPathComponent:
TQ,R,N,GgetListIndex
supportsFamily:
TQ,R,N,V_attachmentWriteMask
supportsInvariantVertexPosition
TQ,R,N,V_bytesPerImage
supportsMemorylessRenderTargets
TQ,R,N,V_cullMode
supportsStreamingCodecSignaling
TQ,R,N,V_flags
supportsViewportAndScissorArray
TQ,R,N,V_options
swizzle
TQ,R,N,V_plane
tailSizeInBytes
TQ,R,N,V_resolveLevelOffset
textureDataType
TQ,R,N,V_storageMode
tileSizeWithSparsePageSize:textureType:pixelFormat:sampleCount:
TQ,R,N,V_triangleFillMode
updateTextureMappings:mode:regions:mipLevels:slices:numRegions:
TQ,R,V_functionCount
useHeap:stages:
TQ,R,V_memorySize
valueWithRange:
TQ,R,V_width
vertexAdditionalBinaryFunctions
T^{__IOSurface=},R
.cxx_construct
T@"MTLToolsCommandBuffer",R,D,N
APITimingEnabled
T@"NSString",&,N,V_encoderLabel
BCTextureCompressionSupported
TB,R,GisAnisoSampleFixSupported
CustomBorderColorSupported
TQ,R,N,V_offset
GPUBVHBuilder
T^v,R,N
GPUStartTime
ICB_Inherit_Both_ComputePipelineState
_allocationLock
ICB_Inherit_Buffers_VertexPipelineState
_backStencilRef
ICB_Inherit_None_VertexPipelineState
_buffer
ICB_Inherit_PSO_VertexPipelineState
_compileOptions
RTZRoundingSupported
_constantValues
StatLocations
_depthBiasClamp
T#,R
_device
T@"<MTLBuffer>",&,D,N
_drawID
T@"<MTLBuffer>",&,N,V_buffer
_heapUsageTable
T@"<MTLBuffer>",R,N
_icbInheritComputePipelineState
T@"<MTLCommandQueue>",R
_layout
T@"<MTLComputePipelineState>",R,N,V_accelerationStructureComputePipelineState
_maxThreadPositionInThreadgroup
T@"<MTLDeadlineProfile>",R,&
_meshDescriptor
T@"<MTLDepthStencilState>",R,N,V_depthStencilState
_newDebugAccelerationStructure:
T@"<MTLFunction>",&,N,V_function
_newToolsAccelerationStructure:
T@"<MTLFunction>",R,N,V_function
_objectTextures
T@"<MTLFunctionLogDebugLocation>",&,N,V_debugLocation
_offset
T@"<MTLIndirectCommandBuffer>",R
_removeUsedRenderTargetsExcept:
T@"<MTLIntersectionFunctionTable>",&,D,N
_stream
T@"<MTLPipelineCache>",R,N
_supportsIndirectCommandBuffers
T@"<MTLRenderPipelineState>",R,N,V_renderPipelineState
_threadgroupSizeMatchesTileSize
T@"<MTLResource>",R,N
_userReflection
T@"<MTLTexture>",R,N,V_attachmentTexture
_vertexAmpState
T@"<MTLTexture>",R,N,V_baseTexture
_vertexTextures
T@"<MTLTextureSPI>",&,D,N
addSynchronizationNotification:
T@"<MTLVisibleFunctionTable>",&,D,N
backFaceStencil
T@"MTLArchitecture",R
beginUseOfMeshShadersInEncoder:
T@"MTLCompileOptions",C,N,V_compileOptions
blendColorAlpha
T@"MTLComputePipelineReflection",R,N
bufferAlignment
T@"MTLCounterSampleBufferDescriptor",R,N,V_descriptor
compareFunction
T@"MTLDebugDevice",R,N,V_debugDevice
completionQueue
T@"MTLDebugInstrumentationData",R,&,N
computeFunction
T@"MTLDebugResource",R,N,V_common
containsString:
T@"MTLDepthStencilDescriptor",R,N,V_descriptor
copyFromTextureMemory:textureSlice:textureLevel:textureRegion:toLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:
T@"MTLGPUBVHBuilder",R
dataWithLength:
T@"MTLGPUDebugCommandBuffer",R,D
dealloc
T@"MTLGPUDebugDynamicLibrary",R,W,N
depthAttachment
T@"MTLGPUDebugImageData",&,N,V_image
disableCrossQueueHazardTracking
T@"MTLGPUDebugImageData",R,N,V_imageData
encodeStartElse
T@"MTLMeshRenderPipelineDescriptor",R,N,V_meshDescriptor
enumerateTileBuffersUsingBlock:
T@"MTLRenderPipelineDescriptor",R,N,V_descriptor
framebufferOnly
T@"MTLRenderPipelineReflection",R,N,V_reflection
getDynamicLibraryForBaseObject:
T@"MTLTargetDeviceArchitecture",R
inheritsBuffers
T@"MTLTileRenderPipelineDescriptor",R,N,V_tileDescriptor
initWithBaseObject:parent:heap:
T@"MTLType",R
initWithFormat:
T@"NSArray",R
initWithLength:
T@"NSArray",R,N,V_imageFilterFunctions
instancedAccelerationStructures
T@"NSDictionary",C,N
isBCTextureCompressionSupported
T@"NSError",R
isProxy
T@"NSMutableDictionary",R,N
layouts
T@"NSMutableSet",R,N,V_retainedObjects
linkedFunctions
T@"NSObject<OS_dispatch_queue>",R
maxBufferLength
T@"NSString",C,N,V_filePath
maxMeshBindings
T@"NSString",R
maxTileTextures
T@"NSString",R,N
members
T@"NSUUID",R,C
minConstantBufferAlignmentBytes
T@,&,N,V_baseObject
newBufferWithBytesNoCopy:length:options:gpuAddress:deallocator:
T@,R,V_baseObject
newComputePipelineStateWithDescriptor:options:reflection:error:
TB,GareGPUAssertionsEnabled,SsetGPUAssertionsEnabled:
newDynamicLibraryWithURL:error:
TB,N
newLibraryWithDescriptor:error:
TB,N,V_isContentExposedToCPU
objectAdditionalBinaryFunctions
TB,R,GareBarycentricCoordsSupported
options
TB,R,GareRasterOrderGroupsSupported
pipelineOptions
TB,R,GisClampToHalfBorderSupported
prepareForUsage
TB,R,GisDepth24Stencil8PixelFormatSupported
purgeableStateValidForRendering
TB,R,GisFloat32FilteringSupported
release
TB,R,GisHeadless
resourceOptions
TB,R,GisLowPower
segment
TB,R,GisMsaa32bSupported
serializeAccelerationStructure:toBuffer:serializedBufferOffset:
TB,R,GisQuadDataSharingSupported
setArrayLength:
TB,R,GisRTZRoundingSupported
setComputePipelineStateBuffers:
TB,R,N
setErrorReason:
TB,R,N,V_isLinearTexture
setGPUPriority:
TB,R,V_storeValidationEnabled
setIndirectArgumentIndexStride:
TC,R,N,V_attachmentWriteMask
setMeshSamplerStates:withRange:
TI,R,N
setPixelFormat:
TI,R,N,V_frontStencilRef
setRenderPipelineState:atIndex:
setStatEnabled:
TQ,N,GgetStatLocations
setStoreAction:
TQ,N,V_callIndex
setTileSamplerStates:withRange:
TQ,N,V_offset
setVisibilityResultMode:offset:
TQ,R
storeComputePipelineDescriptor:
TQ,R,N
supportsBGR10A2
TQ,R,N,V_accelerationStructureHandle
supportsIndirectDrawAndDispatch
TQ,R,N,V_baseLevelOffset
supportsLargeFramebufferConfigs
TQ,R,N,V_bytesPerRow
supportsResourceUsageValidation
TQ,R,N,V_depthClipMode
supportsTextureOutOfBoundsReads
TQ,R,N,V_frontFacingWinding
supportsWritableArrayOfTextures
TQ,R,N,V_peakPerSampleStorage
synchronizeTexture:slice:level:
TQ,R,N,V_renderTargetArrayLength
texture
TQ,R,N,V_resolvedSampleCount
tileFunctionHandleWithFunction:
TQ,R,N,V_tessellationFactorBufferInstanceStride
unwrapMTLComputePassDescriptor:
TQ,R,N,V_visibilityResultMode
TQ,R,V_height
useHeaps:count:
TQ,R,V_stage
version
T^{?=BQ^{?}},R,N,V_imageFilterFunctionInfo
vertexArguments
Td,R
Tf,R
Tf,R,N
Tf,R,N,V_blendColorAlpha
Tf,R,N,V_blendColorBlue
Tf,R,N,V_blendColorGreen
Tf,R,N,V_blendColorRed
Tf,R,N,V_depthBias
Tf,R,N,V_depthBiasClamp
Tf,R,N,V_depthBiasSlopeScale
Tf,R,N,V_lineWidth
Tf,R,N,V_tessellationFactorScale
Ti,N,V_addressSpace
Ti,N,V_errorReason
Ti,N,V_operation
Ti,N,V_specifiedUsage
Ti,R,N
Ti,R,N,V_fragmentMaxCallStackDepth
Ti,R,N,V_maxCallStackDepth
Ti,R,N,V_meshMaxCallStackDepth
Ti,R,N,V_objectMaxCallStackDepth
Ti,R,N,V_tileMaxCallStackDepth
Ti,R,N,V_vertexMaxCallStackDepth
Tq,R
Tr^v,R,N,V_pointer
Tr^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ},R
Tr^{?=[32C]},R
Tr^{MTLTargetDeviceArch=QI*},R
T{?=BBQ@QQQQQBff},R,N,V_tessellationFactorBufferArgument
T{?=CCCC},R,N
T{?=QQQQ},R,N
T{?=QQQ},R
T{?=QQ},R
T{?=[2Q]},R
T{IndirectArgumentBufferCapabilities=b1b1b1b29},R
T{MTLResourceID=Q},R
T{_NSRange=QQ},N,V_range
T{_NSRange=QQ},R,N,V_baseSliceRangeOffset
T{_NSRange=QQ},R,N,V_resolveSliceRangeOffset
T{_NSRange=QQ},R,N,V_segment
URLForResource:withExtension:
UTF8String
_APITimingEnabled
_StatEnabled
_accelerationStructureComputePipelineState
_accelerationStructureHandle
_accelerationStructureIndices
_accelerationStructureLock
_activeThreadgroupMask
_addressSpace
_allocReportEntryStorageForType:
_amplificationMode
_amplificationValue
_aneIOSurface
_applyConstantRelocation
_applyConstantRelocation:
_applyImageIDRelocation:
_argument
_argumentBufferSamplers
_argumentDescriptors
_argumentEncoder
_argumentLayouts
_argumentLayoutsMutex
_argumentStorage
_attachmentSet
_attachmentTexture
_attachmentWriteMask
_baseLevelOffset
_baseObject
_baseResolveTexture
_baseSliceRangeOffset
_baseTexture
_binaryFunctionData
_blendColorAlpha
_blendColorGreen
_blendColorRed
_boundsCheckOptionsData
_bufferIndex
_bufferIndices
_bufferLock
_bufferUsageTable
_bufferUsageTables
_buffers
_bytesPerImage
_bytesPerRow
_callIndex
_checkReportBuffers
_checkerboardRTPipelineCache
_code
_colorPixelFormat
_commandBuffer
_commandBufferJumpNestingLevel
_commandByteStride
_commandIndex
_commandQueue
_commands
_completedHandlers
_computePipelineState
_constantDataBufferIndex
_constantDataKeyPair
_constantDataMutex
_cullMode
_currAttachments
_currentBuffer
_currentDepthStencil
_currentEncoderID
_currentOffset
_currentPipeline
_currentPooledBuffer
_currentPooledBufferOffset
_currentReportID
_data
_deadlineAwareState
_deadlineProfile
_debugBuf
_debugBuffer
_debugDevice
_debugInstrumentationData
_debugLocation
_debugMarkers
_debugType
_defaultDepthStencilDescriptor
_depthBias
_depthBiasSlopeScale
_depthClipMode
_depthPixelFormat
_depthStencilState
_desc
_descriptor
_descriptorAtIndex:
_descriptorPrivate
_deviceWrapper
_didAddRenderTargetAttachments
_didInvokeHandlers
_dirtyBits
_dispatchID
_dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
_drawOrDispatchIDBuffer
_enableResourceUsageValidation
_enableUseResourceValidation
_encodeReportBuffer:type:
_encodeResourceTableBuffers:type:
_encoderID
_encoderLabel
_encoderLabels
_encoderState
_encoderType
_encoders
_errorReason
_errorStackTrace
_externalReferences
_externallyRetainedObjects
_filePath
_findMasterStruct:includeImageBlockData:
_flags
_fragmentBufferUsageTable
_fragmentBuffers
_fragmentFunctionData
_fragmentHandles
_fragmentMaxCallStackDepth
_fragmentReportBuffer
_fragmentReportOffset
_fragmentSamplers
_fragmentStageActive
_fragmentTextureUsageTable
_fragmentTextures
_frontFacingWinding
_frontStencilRef
_function
_functionCount
_functionName
_functionType
_globalBuffer
_gpuIdentifier
_handleBuffer
_handlerLock
_handles
_hasCompute
_hasDeferredBindingObjectAndMeshReportBuffers
_hasRender
_heap
_iCB
_icbDepthStencilState
_icbInheritBothComputePipelineState
_icbInheritBuffersComputePipelineState
_icbInheritBuffersVertexPipelineState
_icbInheritNoneComputePipelineState
_icbInheritNoneVertexPipelineState
_icbInheritVertexPipelineState
_icbPipelineInit
_identifier
_image
_imageData
_imageFilterFunctionInfo
_imageFilterFunctions
_imageID
_imageType
_index
_indirectStateBuffer
_inheritsBuffers
_inheritsPipelineState
_init
_initBufferArgumentData:
_initConstantsBuffer:device:
_initImageData
_initWithCommandBuffer:
_initialized
_integrated
_internalReflection
_internallyRetainedObjects
_isContentExposedToCPU
_isLinearTexture
_isRender
_iterator
_kernelFunctionData
_keyRemoveList
_label
_lateInit
_lineWidth
_listLock
_loadValidationEnabled
_loadedImageName
_lock
_map
_maxCallStackDepth
_maxCommandCount
_maxCommands
_maxFragmentBindings
_maxInstanceCount
_maxKernelBindings
_maxMeshBindings
_maxObjectBindings
_maxPatchCount
_maxStageInGridOrigin
_maxStageInGridSize
_maxThreadIndexInThreadgroup
_maxThreadPositionInGrid
_maxThreadgroupBindings
_maxThreadgroupPositionInGrid
_maxThreadgroupsPerGrid
_maxThreadsPerGrid
_maxThreadsPerThreadgroup
_maxVertexBindings
_maxVertexBuffers
_mayContainDrawMeshes
_memorySize
_meshBuffers
_meshFunctionData
_meshHandles
_meshMaxCallStackDepth
_meshReportBuffer
_meshSamplers
_meshStageActive
_meshTextures
_meshThreadsPerTG
_modifyCompileOptions:
_modifyComputePipelineDescriptor:
_modifyMeshRenderPipelineDescriptor:
_modifyPluginData:
_modifyRenderPipelineDescriptor:
_modifyTilePipelineDescriptor:
_newComputePipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithDescriptor:options:reflection:error:
_newComputePipelineStateWithFunction:options:reflection:error:
_newGPUDebugAccelerationStructure:
_newRenderPipelineStateWithDescriptor:options:completionHandler:
_newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
_newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
_newRenderPipelineStateWithTileDescriptor:options:completionHandler:
_newRenderPipelineStateWithTileDescriptor:options:reflection:error:
_newReportBuffer
_newToolsBuffer:
_newToolsTexture:
_objectBuffers
_objectFunctionData
_objectHandles
_objectMaxCallStackDepth
_objectReportBuffer
_objectStageActive
_objectThreadsPerTG
_openGLModeEnabled
_operation
_optimizedRangeList
_options
_originalResourceOptions
_parentTexture
_peakPerSampleStorage
_perfHandlerLock
_perfSampleHandlerBlock
_perfSampleMailbox
_pipelineState
_pixelFormatInfo
_plane
_pointer
_prepareBinaryLinkedFunctions:
_prepareInsertLibraries:
_prevAttachments
_previousRenderPipelineStateWithWritesToImageBlock
_purgeableObjectsLock
_purgeableStateHasBeenSet
_purgeableStateToken
_range
_rasterSampleCount
_referenceTrackingCommandBufferLock
_referenceTrackingCommandBuffers
_referencedDeadObject
_referencedPurgeableObjects
_reflection
_reflectionParser
_relocations
_renderPipelineState
_renderTargetArrayLength
_renderTargetAttachmentLock
_renderTargetAttachments
_reportBuffer
_reportBufferList
_reportEntryList
_requester
_resolveLevelOffset
_resolveSliceRangeOffset
_resolvedRasterSampleCount
_resolvedSampleCount
_retainedFunctions
_retainedObjects
_retainedObjectsLock
_samplers
_samples
_scheduledHandlers
_scissorRects
_segment
_setDefaults
_setDeviceWrapper:
_setupCommon
_setupIdentifier
_stage
_stageArgumentEncoder
_stencilPixelFormat
_storageMode
_storeValidationEnabled
_storingRenderTargets
_supportsMeshStage
_supportsTileStage
_tempBufLock
_temporaryBufferWithLength:
_tessellationFactorBufferArgument
_tessellationFactorBufferInstanceStride
_tessellationFactorScale
_textureLock
_textureUsageTable
_textureUsageTables
_textures
_threadgroup
_threadgroupArgumentOffset
_threadgroupMemoryArguments
_threadgroupMemoryLengths
_tileBuffers
_tileFunctionData
_tileHandles
_tileMaxCallStackDepth
_tileReportBuffer
_tileSamplers
_tileStageActive
_tileStageUsed
_tileTextures
_timer
_timestamp
_toolsBuffer
_traceBuffer
_traceEncoder
_tracePath
_triangleFillMode
_type
_unknownStoreActions
_updateCachedMeshPipelineState
_updateCachedPipelineState
_updateCachedTilePipelineState
_updatedFences
_usageRequired
_useResourceCommon:usage:stages:
_useRetainedObjectsLock
_usedBuffers
_validateAllFunctionArguments
_validateAllFunctionArguments:
_validateThreadgroupSize:stage:context:
_vertexAmplificationCount
_vertexBufferUsageTable
_vertexBuffers
_vertexBuiltinArguments
_vertexComputeReportBuffer
_vertexComputeReportOffset
_vertexDescriptorLayoutCount
_vertexDescriptorLayouts
_vertexFunctionData
_vertexHandles
_vertexMaxCallStackDepth
_vertexReportBuffer
_vertexStageActive
_vertexTextureUsageTable
_viewports
_visibilityOffsets
_visibilityResultMode
_visibilityResultOffset
_width
accelerationStructureCommandEncoder
accelerationStructureCommandEncoderWithDescriptor:
accelerationStructureComputePipelineState
accelerationStructureHandle
accelerationStructureSizesWithDescriptor:
access
activeThreadgroupMask
addActiveRenderTargets:
addArchiveEntry:forKey:
addBinaryEntry:forKey:
addCompletedHandler:
addComputePipelineFunctionsWithDescriptor:error:
addComputePipelineFunctionsWithDescriptor:options:error:
addDebugMarker:range:
addFunctionWithDescriptor:library:error:
addMeshRenderPipelineFunctionsWithDescriptor:error:
addMeshRenderPipelineFunctionsWithDescriptor:options:error:
addObject:
addObject:retained:purgeable:
addObjectsFromArray:
addPerfSampleHandler:
addPurgeableObject:
addPurgedHeap:
addPurgedResource:
addReferenceTrackingCommandBuffer:
addReferencedObject:internallyRetained:
addRenderPipelineFunctionsWithDescriptor:error:
addRenderPipelineFunctionsWithDescriptor:options:error:
addRetainedObject:
addScheduledHandler:
addSplitHandler:
addTileRenderPipelineFunctionsWithDescriptor:error:
addTileRenderPipelineFunctionsWithDescriptor:options:error:
addUsedRenderTarget:slices:
additionalCompilerArguments
addressSpace
alignment
allObjects
allocatedSize
allocationID
allowGPUOptimizedContents
allowLibrariesFromOtherPlatforms
allowsNullBufferBinds
appendData:
appendSamples:length:
appendString:
architecture
archiveFunctionIds
areBarycentricCoordsSupported
areGPUAssertionsEnabled
areProgrammableSamplePositionsSupported
areRasterOrderGroupsSupported
argument
argumentBuffersSupport
argumentIndex
arguments
array
arrayLength
arrayType
arrayWithCapacity:
arrayWithObjects:count:
attachmentTexture
attachmentWriteMask
autorelease
availableCounters
availableCountersAndDict
backStencilRef
backgroundTrackingPID
barycentricCoordsSupported
base64EncodedDataWithOptions:
baseObject
baseResolveTexture
baseSliceRangeOffset
baseTexture
beginingEncoder:type:
binaryArchives
binaryData
binaryFunctionData
bindings
bitCodeHash
bitcodeData
blendColorBlue
blendColorRed
blitCommandEncoder
blitCommandEncoderWithDescriptor:
borderColor
borderColorSPI
boundingBoxBuffer
boundingBoxBufferOffset
boundingBoxBuffers
boundingBoxCount
boundingBoxStride
boundsCheckOptions
buffer
bufferAccessMask
bufferBytesPerRow
bufferDataSize
bufferHeap
bufferIndex
bufferOffset
bufferRobustnessSupport
bufferStructType
buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:
builtInArguments
builtInType
bundleWithIdentifier:
bytes
bytesPerImage
bytesPerRow
cStringUsingEncoding:
callIndex
canDealloc
canEndEncoding
canGenerateMipmapLevels
canSetComputePipelineState
checkEncoderState
class
clearBarrier
clearDepth
clearRenderEncoder:writeMask:withCheckerboard:
clearRetainedObjects
code
colorAttachments
colorSampleCount
commandBuffer
commandBufferErrorOptions
commandBufferWithDescriptor:
commandBufferWithUnretainedReferences
commandByteStride
commandQueue
commandQueueDescriptor
commandTypes
commit
commitAndHold
commitAndWaitUntilSubmitted
commitAndWaitUntilSubmittedWithDeadline:
commitQueue
commitSynchronously
commitWithDeadline:
common
compileOptions
compileVisibleFunction:withDescriptor:completionHandler:
compileVisibleFunction:withDescriptor:destinationBinaryArchive:error:
compileVisibleFunction:withDescriptor:error:
compilerPropagatesThreadPriority:
componentsJoinedByString:
componentsSeparatedByString:
compressionFeedback
compressionFootprint
computeCommandEncoder
computeCommandEncoderWithDescriptor:
computeCommandEncoderWithDispatchType:
computePipelineState
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
conformsToProtocol:
constantBlockAlignment
constantBufferCache
constantDataAtIndex:
constantDataBuffer
constantOffset
constantValues
containsResource:
contents
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
convertUserType:
copy
copyAccelerationStructure:toAccelerationStructure:
copyAndCompactAccelerationStructure:toAccelerationStructure:
copyConstantValues:
copyDebugMarkers
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromPixels:rowBytes:imageBytes:toSlice:mipmapLevel:origin:size:
copyFromSlice:mipmapLevel:origin:size:toPixels:rowBytes:imageBytes:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles:
copyParameterDataToBuffer:offset:
copyShaderCacheToPath:
count
countByEnumeratingWithState:objects:count:
counterInfo
counterSets
cpuCacheMode
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
cullMode
currentAllocatedSize
data
dataType
dataTypeDescription
dataWithBytesNoCopy:length:freeWhenDone:
debugBufferContentsWithLength:
debugCommandEncoder
debugDescription
debugDevice
debugInstrumentationData
debugLocation
debugLocationForID:
debugPipelineOptions:includePipelinePerfStats:
debugType
dedicatedMemorySize
defaultColorSampleCount
defaultDepthStencilDescriptor
defaultManager
defaultRasterSampleCount
depth
depth24Stencil8PixelFormatSupported
depthBias
depthBiasClamp
depthBiasSlopeScale
depthClipMode
depthCompareFunction
depthFailureOperation
depthStencilObjectCache
depthStencilPassOperation
depthStencilState
description
descriptor
descriptorPrivate
deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
deserializeCompileTimeStats:addToDictionary:
deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:
deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:
deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:
deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:
device
deviceCreationFlags
deviceLinearReadOnlyTextureAlignmentBytes
deviceLinearTextureAlignmentBytes
deviceOptions
deviceOrFeatureProfileSupportsFeatureSet:
deviceSupportsFeatureSet:
dictionary
dictionaryWithObjects:forKeys:count:
disableRunTimeCompilation
dispatchAvailableCompletionNotifications
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreadgroupsArguments
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
dispatchThreadsArguments
dispatchThreadsPerTile:
dispatchThreadsPerTile:inRegion:
dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
dispatchType
doesAliasAllResources:count:
doesAliasAnyResources:count:
doesAliasResource:
doubleFPConfig
drawArguments
drawIndexedArguments
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawIndexedPatchesArguments
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawMeshArguments
drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawPatchesArguments
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
dropResourceGroups:count:
dynamicLibrary
dynamicLibraryObjectCache
elementArrayType
elementIsArgumentBuffer
elementStructType
elementType
enableBarrier
enableNullBufferBinds:
encodeBuffers:offsets:withRange:resultOffset:
encodeCacheHintFinalize:resourceGroups:count:
encodeCacheHintTag:resourceGroups:count:
encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:
encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:
encodeDashboardTagForResourceGroup:
encodeEndDoWhile:offset:comparison:referenceValue:
encodeEndIf
encodeEndWhile
encodeSignalEvent:value:
encodeStartDoWhile
encodeStartIf:offset:comparison:referenceValue:
encodeStartWhile:offset:comparison:referenceValue:
encodeWaitForEvent:value:
encodeWaitForEvent:value:timeout:
encodedLength
encoderID
encoderIdentifierForEncoderIndex:
encoderLabel
endCollectingPipelineDescriptors
endEncoding
endEncodingAndRetrieveProgramAddressTable
endEncoding_private
endOfEncoderSampleIndex
endOfFragmentSampleIndex
endOfVertexSampleIndex
endingEncoder:type:
enumerateArchivesFromBackingFile:
enumerateArchivesFromPipelineCollection:
enumerateBufferIndices:
enumerateBuffersUsingBlock:
enumerateByteRangesUsingBlock:
enumerateFragmentBuffersUsingBlock:
enumerateFragmentSamplersUsingBlock:
enumerateFragmentTexturesUsingBlock:
enumerateSamplersUsingBlock:
enumerateTextureIndices:
enumerateTexturesUsingBlock:
enumerateThreadgroupMemoryLengthsUsingBlock:
enumerateThreadgroupMemoryUsingBlock:
enumerateTileSamplersUsingBlock:
enumerateTileTexturesUsingBlock:
enumerateVertexBuffersUsingBlock:
enumerateVertexSamplersUsingBlock:
enumerateVertexTexturesUsingBlock:
error
errorOptions
errorReason
errorWithDomain:code:userInfo:
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
executeCommandsInBuffer:withRange:
executeSynchronizationNotifications:
executeSynchronizationNotifications:scope:resources:count:
executionEnabled
explicitVisibilityGroupID
exportedFunctions
exportedVariables
externFunctionNames
extractDataAndNumSamples:forRequester:isLast:
familyName
featureProfile
filePath
fileSystemRepresentation
fillBuffer:range:pattern4:
fillBuffer:range:value:
fillTexture:level:slice:region:bytes:length:
fillTexture:level:slice:region:color:
fillTexture:level:slice:region:color:pixelFormat:
filterCounterRangeWithFirstBatch:lastBatch:filterIndex:
finalizeTextureMemory:
finish
firstMipmapInTail
flags
float32FilteringSupported
flushBindings
formattedDescription:
fragmentAdditionalBinaryFunctions
fragmentArguments
fragmentConstantsBuffer
fragmentDebugInstrumentationData
fragmentFunction
fragmentFunctionData
fragmentFunctionHandleWithFunction:
fragmentLinkedFunctions
fragmentMaxCallStackDepth
fragmentPreloadedLibraries
frontFaceStencil
frontFacingWinding
function
functionCache
functionConstantsDictionary
functionCount
functionHandle
functionHandleObjectCache
functionHandleToDebugFunctionHandle:parentFunction:
functionHandleToDebugFunctionHandle:parentFunction:stage:
functionHandleWithFunction:
functionHandleWithFunction:stage:
functionHandleWithFunction:stage:selector:
functionInputs
functionName
functionNames
functionObjectCache
functionPointers
functionType
functions
generateMipmapLevel:slice:
generateMipmapsForTexture:
geometryBuffer
geometryBufferOffset
geometryDescriptors
getArchiveDataForKey:
getArchiveIDWithError:
getBVHBuilderLock
getBackgroundGPUPriority
getBinaryDataForKey:
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
getCachedObjectForKey:
getCachedObjectForKey:onMiss:
getCommandType
getCompilerConnectionManager:
getDefaultSamplePositions:count:
getDepthStencilStateForBaseObject:descriptor:
getFragmentBufferAtIndex:
getFunctionForBaseObject:library:
getGPUPriority
getHeader:headerSize:
getImageBlockSize
getKernelBufferAtIndex:
getListIndex
getMeshBufferAtIndex:
getMostCompatibleArchitecture:
getObjectBufferAtIndex:
getOptimizedStatus
getParameter:
getPipelineStateUniqueIdentifier
getRawBVHBuilderPtr
getRequestedCounters
getSPIStats
getSamplerStateForBaseObject:descriptor:
getShaderCacheKeys
getStageInRegion
getStatLocations
getStatOptions
getSupportedCommandBufferErrorOptions
getTessellationFactorArguments
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
getThreadgroupMemoryLengthAtIndex:
getVertexBufferAtIndex:
globalBuffer
globalBufferHeap
globalBufferOffset
globalConstantsBuffer
globalConstantsData
globalICBBufferResidentList
globalTraceObjectID
gpuAddress
gpuAssertionsEnabled
gpuHandle
gpuIdentifier
gpuResourceID
groups
halfFPConfig
handleForOffset:
hasArgumentBufferInstrumentationFailures
hasArgumentLimitsInstrumentationFailures
hasBarrier
hasEndEncoding
hasEndedEncoding
hasGlobalConstantsInstrumentationFailures
hasIndirectSetStageInRegion
hasSetComputePipelineState
hasSetStageInRegion
hasUnifiedMemory
hash
hazardTrackingMode
headerBuffer
headerBufferOffset
headless
heap
heapAccelerationStructureSizeAndAlignWithDescriptor:
heapAccelerationStructureSizeAndAlignWithSize:
heapBufferSizeAndAlignWithLength:options:
heapOffset
heapTextureSizeAndAlignWithDescriptor:
height
image
imageBlockDataReturn
imageBlockMasterStructMembers
imageData
imageFilterFunctionInfo
imageFilterFunctions
imageType
imageblockMemoryLengthForDimensions:
imageblockSampleLength
importedLibraries
index
indexBuffer
indexBufferOffset
indexType
indirectArgumentBufferCapabilities
indirectArgumentBufferDecodingData
indirectArgumentIndex
indirectArgumentIndexStride
indirectCommandBuffer
indirectComputeCommandAtIndex:
indirectRenderCommandAtIndex:
indirectStateBuffer
inheritBuffers
inheritPipelineState
inheritsPipelineState
init
init:
init:flags:
initMetalScriptWithArchive:
initWithAccelerationStructure:device:
initWithAccelerationStructure:heap:
initWithAccelerationStructureCommandEncoder:parent:
initWithAccelerationStructureCommandEncoder:parent:descriptor:
initWithArgumentEncoder:layout:device:
initWithArray:
initWithArrayLength:elementType:stride:pixelFormat:aluType:details:
initWithBaseObject:
initWithBaseObject:parallelRenderCommandEncoder:
initWithBaseObject:parent:
initWithBaseObject:parent:buffer:
initWithBaseObject:parent:function:
initWithBaseObject:parent:function:stage:
initWithBaseObject:parent:parentTexture:
initWithBaseObject:structType:parent:
initWithBaseRenderPass:commandBuffer:descriptor:
initWithBaseTexture:device:
initWithBaseTexture:device:buffer:offset:bytesPerRow:
initWithBaseTexture:device:buffer:offset:bytesPerRow:bytesPerImage:
initWithBaseTexture:device:plane:
initWithBaseTexture:device:texture:
initWithBaseTexture:device:texture:pixelFormat:
initWithBaseTexture:device:texture:pixelFormat:textureType:levels:slices:
initWithBaseTexture:heap:device:
initWithBaseTextureLayout:device:descriptor:
initWithBinaryArchive:device:
initWithBlitCommandEncoder:commandBuffer:descriptor:
initWithBlitCommandEncoder:parent:descriptor:
initWithBlitCommandEncoder:parent:descriptor:encoderID:
initWithBuffer:device:
initWithBuffer:device:bytes:options:
initWithBuffer:device:offset:length:
initWithBuffer:device:offset:length:track:
initWithBuffer:device:options:
initWithBuffer:heap:device:
initWithBuffer:heap:device:offset:length:track:
initWithBuffer:heap:device:options:
initWithBytesNoCopy:length:freeWhenDone:
initWithCapacity:
initWithCommandBuffer:commandQueue:descriptor:
initWithCommandBuffer:parent:descriptor:
initWithCommandQueue:device:
initWithComputeCommandEncoder:commandBuffer:descriptor:
initWithComputeCommandEncoder:commandBuffer:descriptor:encoderID:
initWithComputeCommandEncoder:parent:descriptor:
initWithComputeCommandEncoder:parent:encoderID:
initWithComputePipelineState:binaryFunctions:withState:device:
initWithComputePipelineState:descriptor:unwrappedDescriptor:reflection:device:
initWithComputePipelineState:reflection:parent:descriptor:
initWithCounterSampleBuffer:device:descriptor:
initWithDebugLocation:
initWithDepthStencilState:descriptor:device:
initWithDesc:renderTargetArrayLength:
initWithDictionary:
initWithDynamicLibrary:
initWithDynamicLibrary:device:
initWithFunction:
initWithFunction:debugInstrumentationData:
initWithFunction:library:
initWithFunctionHandle:computePiplineState:function:
initWithFunctionHandle:renderPipelineState:stage:function:
initWithHeap:device:
initWithIndirectCommandBuffer:descriptor:maxCommandCount:resourceOptions:device:
initWithIndirectCommandBuffer:device:descriptor:maxCommandCount:options:
initWithIndirectComputeCommand:commandIndex:indirectCommandBuffer:
initWithIndirectRenderCommand:commandIndex:indirectCommandBuffer:
initWithIntersectionFunctionTable:device:descriptor:
initWithIntersectionFunctionTable:device:descriptor:computePipelineState:
initWithIntersectionFunctionTable:device:descriptor:renderPipelineState:
initWithIntersectionFunctionTable:parent:descriptor:pipelineState:stage:
initWithIntersectionFunctionTable:parent:descriptor:stage:
initWithKeyOptions:valueOptions:capacity:
initWithLibrary:device:
initWithLibrary:parent:filePath:
initWithLibrary:parent:type:code:options:
initWithName:offset:dataType:pixelFormat:aluType:indirectArgumentIndex:render_target:raster_order_group:details:
initWithName:type:access:isActive:locationIndex:dataType:pixelFormat:aluType:dataSize:alignment:
initWithObjectData:meshData:fragmentData:device:options:flags:
initWithObjects:
initWithParallelRenderCommandEncoder:parent:descriptor:
initWithParallelRenderCommandEncoder:parent:descriptor:encoderID:
initWithPipelineState:reflection:parent:descriptor:
initWithPipelineState:reflection:parent:meshDescriptor:
initWithPipelineState:reflection:parent:tileDescriptor:
initWithRenderCommandEncoder:commandBuffer:descriptor:encoderID:
initWithRenderCommandEncoder:parallelEncoder:encoderID:
initWithRenderCommandEncoder:parallelRenderCommandEncoder:descriptor:
initWithRenderCommandEncoder:parent:
initWithRenderCommandEncoder:parent:descriptor:
initWithRenderPipelineState:descriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
initWithRenderPipelineState:meshDescriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
initWithRenderPipelineState:tileDescriptor:reflection:device:
initWithRenderPipelineState:vertexBinaryFunctions:fragmentBinaryFunctions:tileBinaryFunctions:objectBinaryFunctions:meshBinaryFunctions:withState:device:
initWithResourceStateCommandEncoder:commandBuffer:descriptor:
initWithResourceStateCommandEncoder:parent:descriptor:
initWithSamplerState:descriptor:device:
initWithSerializedData:serializedStageInputDescriptor:device:options:flags:
initWithSymbolName:buffer:offset:
initWithSymbolName:bytes:length:
initWithTexture:heap:device:
initWithTextureView:parentBuffer:heap:device:
initWithTextureView:parentTexture:heap:device:
initWithTileData:functionType:device:options:flags:
initWithUTF8String:
initWithVersion:
initWithVertexData:fragmentData:serializedVertexDescriptor:device:options:flags:
initWithVisibleFunctionTable:descriptor:computePipeline:
initWithVisibleFunctionTable:descriptor:device:
initWithVisibleFunctionTable:descriptor:renderPipeline:
initWithVisibleFunctionTable:parent:descriptor:pipelineState:stage:
initWithVisibleFunctionTable:parent:descriptor:stage:
initializeTextureMemory:
inlinedAt
innerNodeBufferOffset
inputPrimitiveTopology
insertData:andNumSamples:forRequester:
insertDebugCaptureBoundary
insertDebugSignpost:
insertObject:atIndex:
installName
instanceCount
instanceDescriptorBuffer
instanceDescriptorBufferOffset
instanceDescriptorStride
instanceDescriptorType
instanceTransformBuffer
instanceTransformBufferOffset
integrated
internalArrayTypeFromUserArrayType:
internalDrawOrDispatchIDBuffer
internalICBBuffer
internalReflection
internalStructTypeFromUserStructType:
internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
intersectsTexture:
invalidateCompressedTexture:
invalidateCompressedTexture:slice:level:
invokeCompletedHandlers
invokeScheduledHandlers
iosurface
iosurfacePlane
iosurfaceReadOnlyTextureAlignmentBytes
iosurfaceTextureAlignmentBytes
isActive
isAliasable
isAlphaToCoverageEnabled
isAncestorOf:
isAnisoSampleFixSupported
isClampToHalfBorderSupported
isCommitted
isCompatibleWithAccelerationStructure:
isComplete
isCompressed
isContentExposedToCPU
isCustomBorderColorSupported
isDepth24Stencil8PixelFormatSupported
isDepthWriteEnabled
isDrawable
isEqual:
isFileURL
isFixedLinePointFillDepthGradientSupported
isFloat32FilteringSupported
isFramebufferOnly
isHeadless
isImageBlockLayoutInputCompatibleWithOutputOf:
isIntegrated
isKindOfClass:
isLargeMRTSupported
isLowPower
isMemberOfClass:
isMemorylessRender
isMeshShaderPipeline
isMsaa32bSupported
isOpenGLQueue
isPlacementHeapSupported
isProfilingEnabled
isPurgeable
isQuadDataSharingSupported
isRGB10A2GammaSupported
isRTZRoundingSupported
isRasterizationEnabled
isRemovable
isSparse
isStatEnabled
isStructLayoutThreadSafeWith:
isSubclassOfClass:
isTracked
kernelEndTime
kernelFunctionData
keys
label
largeMRTSupported
layerCount
layerPointer:
layout
leafNodeBuffer
leafNodeBufferOffset
length
lengthOfBytesUsingEncoding:
libraries
libraryCacheStats
libraryIdentifier
libraryPath
libraryUUID
limits
lineNumber
lineWidth
linearTextureAlignmentBytes
linearTextureArrayAlignmentBytes
linearTextureArrayAlignmentSlice
listIndex
loadAction
loadDynamicLibrariesForComputeDescriptor:error:
loadDynamicLibrariesForComputeDescriptor:options:error:
loadDynamicLibrariesForFunction:insertLibraries:error:
loadDynamicLibrariesForFunction:insertLibraries:options:error:
loadValidationEnabled
localizedDescription
lockPurgeableObjects
lockPurgeableState
logs
lookupRecompiledBinaryArchive:
lowPower
magFilter
makeAliasable
mapPhysicalToScreenCoordinates:forLayer:
mapScreenToPhysicalCoordinates:forLayer:
mapShaderSampleBufferWithBuffer:capacity:size:
markAccelerationStructure:usage:stages:
markBuffer:usage:stages:
markHeap:stages:
markTexture:usage:stages:
maxAnisotropy
maxArgumentBufferSamplerCount
maxAvailableSizeWithAlignment:
maxCallStackDepth
maxColorAttachments
maxCommandBufferCount
maxCommands
maxComputeAttributes
maxComputeBuffers
maxComputeInlineDataSize
maxComputeLocalMemorySizes
maxComputeSamplers
maxComputeTextures
maxComputeThreadgroupMemory
maxComputeThreadgroupMemoryAlignmentBytes
maxConcurrentExecutingCompilationTasks
maxConstantBufferArguments
maxCustomSamplePositions
maxFenceInstances
maxFragmentBindings
maxFragmentBufferBindCount
maxFragmentBuffers
maxFragmentCallStackDepth
maxFragmentInlineDataSize
maxFragmentSamplers
maxFragmentTextures
maxFramebufferStorageBits
maxFunctionConstantIndices
maxIndirectBuffers
maxIndirectSamplers
maxIndirectSamplersPerDevice
maxIndirectTextures
maxInterpolatedComponents
maxKernelBindings
maxKernelBufferBindCount
maxLineWidth
maxMeshBufferBindCount
maxMeshCallStackDepth
maxObjectBindings
maxObjectBufferBindCount
maxObjectCallStackDepth
maxPointSize
maxPredicatedNestingDepth
maxRasterizationRateLayerCount
maxTessellationFactor
maxTextureBufferWidth
maxTextureDepth3D
maxTextureDimensionCube
maxTextureHeight2D
maxTextureHeight3D
maxTextureLayers
maxTextureWidth1D
maxTextureWidth2D
maxTextureWidth3D
maxThreadgroupMemoryLength
maxThreadsPerThreadgroup
maxTileBuffers
maxTileInlineDataSize
maxTotalComputeThreadsPerThreadgroup
maxTotalThreadsPerMeshThreadgroup
maxTotalThreadsPerObjectThreadgroup
maxTotalThreadsPerThreadgroup
maxVertexAmplificationCount
maxVertexAmplificationFactor
maxVertexAttributes
maxVertexBindings
maxVertexBufferBindCount
maxVertexBuffers
maxVertexCallStackDepth
maxVertexInlineDataSize
maxVertexSamplers
maxVertexTextures
maxViewportCount
maxVisibilityQueryOffset
mayContainDrawMeshes
memoryBarrierWithResources:count:
memoryBarrierWithResources:count:afterStages:beforeStages:
memoryBarrierWithScope:
memoryBarrierWithScope:afterStages:beforeStages:
memorySize
mergeAttachmentWriteMask:
meshAdditionalBinaryFunctions
meshArguments
meshConstantsBuffer
meshDebugInstrumentationData
meshDescriptor
meshFunction
meshFunctionData
meshLinkedFunctions
meshMaxCallStackDepth
meshPreloadedLibraries
meshShaderPipeline
meshThreadExecutionWidth
meshThreadgroupSizeIsMultipleOfThreadExecutionWidth
meshThreadsPerThreadgroup
metalAssertionsEnabled
minBufferNoCopyAlignmentBytes
minFactor
minFilter
minLinearTextureAlignmentForPixelFormat:
minTilePixels
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
mipFilter
mipmapLevelCount
modifyFunctionDescriptor:
motionEndTime
motionKeyframeCount
motionTransformBuffer
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
msaa32bSupported
mutability
mutableCopy
name
newAccelerationStructureWithBuffer:offset:
newAccelerationStructureWithBuffer:offset:resourceIndex:
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithDescriptor:offset:
newAccelerationStructureWithSize:
newAccelerationStructureWithSize:offset:
newAccelerationStructureWithSize:offset:resourceIndex:
newAccelerationStructureWithSize:resourceIndex:
newAccelerationStructureWithSize:withDescriptor:
newArgumentEncoderForBufferAtIndex:
newArgumentEncoderWithArguments:
newArgumentEncoderWithArguments:structType:
newArgumentEncoderWithBufferBinding:
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:
newArgumentEncoderWithBufferIndex:reflection:binaryArchives:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:binaryArchives:
newArgumentEncoderWithLayout:
newBinaryArchiveWithDescriptor:error:
newBinaryLibraryWithOptions:url:error:
newBufferWithBytes:length:options:
newBufferWithBytes:length:options:gpuAddress:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithDescriptor:
newBufferWithIOSurface:
newBufferWithLength:options:
newBufferWithLength:options:gpuAddress:
newBufferWithLength:options:offset:
newCommandQueueWithDescriptor:
newCommandQueueWithMaxCommandBufferCount:
newCompressedTextureViewWithPixelFormat:textureType:level:slice:
newComputePipelineDescriptorWithName:error:
newComputePipelineDescriptorWithSerializedData:deserializationContext:
newComputePipelineStateWithAdditionalBinaryFunctions:
newComputePipelineStateWithAdditionalBinaryFunctions:error:
newComputePipelineStateWithDescriptor:completionHandler:
newComputePipelineStateWithDescriptor:error:
newComputePipelineStateWithDescriptor:options:completionHandler:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newComputePipelineStateWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newComputePipelineStateWithName:options:reflection:error:
newCounterSampleBufferWithDescriptor:error:
newDagStringWithGraphs:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newDepthStencilStateWithDescriptor:
newDynamicLibrary:computeDescriptor:error:
newDynamicLibrary:error:
newDynamicLibraryWithDescriptor:error:
newDynamicLibraryWithURL:options:error:
newEvent
newExternFunctionWithName:
newFence
newFragmentIntersectionFunctionTableWithDescriptor:
newFragmentShaderDebugInfo
newFunctionWithDescriptor:completionHandler:
newFunctionWithDescriptor:destinationArchive:error:
newFunctionWithDescriptor:error:
newFunctionWithGLCoreIR:functionType:
newFunctionWithGLCoreIR:inputsDescription:functionType:
newFunctionWithGLESIR:functionType:
newFunctionWithGLESIR:inputsDescription:functionType:
newFunctionWithGLIR:functionType:
newFunctionWithGLIR:inputsDescription:functionType:
newFunctionWithName:
newFunctionWithName:constantValues:completionHandler:
newFunctionWithName:constantValues:error:
newFunctionWithName:constantValues:functionCache:error:
newFunctionWithName:constantValues:pipelineLibrary:completionHandler:
newFunctionWithName:constantValues:pipelineLibrary:error:
newFunctionWithPluginData:bitcodeType:
newHeapWithDescriptor:
newIndirectArgumentBufferLayoutWithStructType:
newIndirectArgumentEncoderWithArguments:
newIndirectArgumentEncoderWithLayout:
newIndirectCommandBufferWithDescriptor:maxCount:options:
newIndirectComputeCommandEncoderWithBuffer:
newIndirectRenderCommandEncoderWithBuffer:
newInternalBufferWithLength:options:
newIntersectionFunctionTableWithDescriptor:
newIntersectionFunctionTableWithDescriptor:selector:
newIntersectionFunctionTableWithDescriptor:stage:
newIntersectionFunctionTableWithDescriptor:withStage:selector:
newIntersectionFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:error:
newKernelDebugInfo
newLateEvalEvent
newLibraryWithCIFilters:imageFilterFunctionInfo:error:
newLibraryWithCIFiltersForComputePipeline:imageFilterFunctionInfo:error:
newLibraryWithDAG:functions:error:
newLibraryWithData:error:
newLibraryWithDescriptor:completionHandler:
newLibraryWithDescriptorSPI:error:
newLibraryWithFile:error:
newLibraryWithGraphs:functions:error:
newLibraryWithGraphsSPI:functions:error:
newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithSource:options:completionHandler:
newLibraryWithSource:options:error:
newLibraryWithStitchedDescriptor:completionHandler:
newLibraryWithStitchedDescriptor:error:
newLibraryWithStitchedDescriptorSPI:error:
newLibraryWithURL:error:
newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:
newMeshIntersectionFunctionTableWithDescriptor:
newObjectIntersectionFunctionTableWithDescriptor:
newPipelineDescriptorAtIndex:pipelineType:error:
newPipelineLibraryWithFilePath:error:
newProfileWithExecutionSize:
newRasterizationRateMapWithDescriptor:
newRenderPipelineDescriptorWithName:error:
newRenderPipelineDescriptorWithSerializedData:deserializationContext:
newRenderPipelineStateWithAdditionalBinaryFunctions:error:
newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithMeshDescriptor:completionHandler:
newRenderPipelineStateWithMeshDescriptor:error:
newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
newRenderPipelineStateWithName:options:reflection:error:
newRenderPipelineStateWithTileDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:error:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
newResourceGroupFromResources:count:
newSamplerStateWithDescriptor:
newSerializedComputeDataWithFlags:options:
newSerializedVertexDataWithFlags:options:error:
newSharedEvent
newSharedEventHandle
newSharedEventWithHandle:
newSharedEventWithMachPort:
newStageArgumentBuffer
newStageBufferArgumentEncoder
newStructTypeWithSerializedData:
newTextureLayoutWithDescriptor:isHeapOrBufferBacked:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:
newTextureWithBytesNoCopy:length:descriptor:deallocator:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
newTextureWithDescriptor:offset:
newTextureWithDescriptor:offset:bytesPerRow:
newTileIntersectionFunctionTableWithDescriptor:
newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:
newVertexIntersectionFunctionTableWithDescriptor:
newVertexShaderDebugInfo
newVisibleFunctionTableFromFragmentStageWithDescriptor:
newVisibleFunctionTableFromMeshStageWithDescriptor:
newVisibleFunctionTableFromObjectStageWithDescriptor:
newVisibleFunctionTableFromTileStageWithDescriptor:
newVisibleFunctionTableFromVertexStageWithDescriptor:
newVisibleFunctionTableWithDescriptor:
newVisibleFunctionTableWithDescriptor:selector:
newVisibleFunctionTableWithDescriptor:stage:
newVisibleFunctionTableWithDescriptor:stage:selector:
noCopy
normalizedCoordinates
notifyExternalReferencesNonZeroOnDealloc:
notifyListener:atValue:block:
notifyResourceReleasing:
notifySamplerStateDeallocated:
null
numFaces
numberWithFloat:
numberWithUnsignedInteger:
numberWithUnsignedLong:
numberWithUnsignedLongLong:
objectAtIndexedSubscript:
objectConstantsBuffer
objectDebugInstrumentationData
objectForKey:
objectForKeyedSubscript:
objectFunction
objectFunctionData
objectFunctionHandleWithFunction:
objectLinkedFunctions
objectMaxCallStackDepth
objectPreloadedLibraries
objectThreadExecutionWidth
objectThreadgroupSizeIsMultipleOfThreadExecutionWidth
objectThreadsPerThreadgroup
offset
onComputePipelineCreated:
onExecuteWithComputeEncoder:
onExecuteWithRenderEncoder:
onRenderPipelineCreated:
openGLModeEnabled
operation
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeIndirectCommandBuffer:withRange:
optimizedRangeList
originalObject
outputImageBlockData
overrideTriple
parallelRenderCommandEncoderWithDescriptor:
parameterBufferSizeAndAlign
parent
parentGPUAddress
parentGPUSize
parentRelativeLevel
parentRelativeSlice
parentTexture
patchControlPointCount
patchType
path
pathForResource:ofType:
peakPerSampleStorage
perPrimitiveDataBuffer
perPrimitiveDataBufferOffset
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
performanceStatistics
physicalGranularity
physicalSizeForLayer:
pipelineBinaries
pipelineCache
pipelineCacheStats
pipelineCollection
pipelineNames
pixelFormat
placementHeapSupported
plane
pluginData
pointerType
popDebugGroup
postCompletionHandlers
postScheduledHandlers
preCommit
preCompletionHandlers
preScheduledHandlers
precompiledOutput
preloadedLibraries
prepareForBinaryFunctionUsage
prepareForComputePipelineUsage
prepareForRenderPipelineUsage
presentDrawable:
presentDrawable:atTime:
presentDrawable:options:
primitiveBufferOffset
primitiveDataBuffer
primitiveDataBufferOffset
primitiveDataElementSize
primitiveDataStride
privateFunctions
productName
profilingEnabled
profilingResults
programmableSamplePositionsSupported
protectionOptions
qosLevel
quadDataSharingSupported
rAddressMode
range
rangeValue
rasterOrderGroupsSupported
rasterSampleCount
rasterizationEnabled
rasterizationRateMap
readMask
readWriteTextureSupport
readsDepth
readsStencil
realRootResource
recommendedMaxWorkingSetSize
recompilablePipelineCount
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
reflection
reflectionWithOptions:
reflectionWithOptions:binaryArchives:
reflectionWithOptions:completionHandler:
reflectionWithOptions:pipelineLibrary:
registryID
releaseReflection
relocations
removable
removeAllDebugMarkers
removeAllObjects
removeAllReferencedObjects:
removeKey:
removeObject:
removeObjectAtIndex:
removeObjectForKey:
removeReferenceTrackingCommandBuffer:
removeUsedRenderTarget:slices:
renderCommandEncoder
renderCommandEncoderWithDescriptor:
renderPipelineState
renderTargetArrayIndexType
renderTargetArrayLength
renderTargetHeight
renderTargetWidth
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
reportLeaks
requestCounters:
requestCounters:withIndex:
requireUsage:
requiresRaytracingEmulation
reserveGPUAddressRange:
reserveResourceIndicesForResourceType:indices:indexCount:
reset
resetAtIndex:
resetCommandsInBuffer:withRange:
resetTextureAccessCounters:region:mipLevel:slice:
resetUsingDescriptor:
resolveCounterRange:
resolveCounters:inRange:destinationBuffer:destinationOffset:
resolveLevelOffset
resolveSliceRangeOffset
resolveTexture
resolvedSampleCount
resourceIndex
resourcePatchingTypeForResourceType:
resourceStateCommandEncoder
resourceStateCommandEncoderWithDescriptor:
resourceUsageForBuffer:stage:
resourceUsageForTexture:stage:
respondsToSelector:
responsibleProcess
retain
retainCount
retainObjectsFromRenderPassDescriptor:
retainedReferences
returnType
rootResource
rotation
sAddressMode
sampleBuffer
sampleBufferAttachments
sampleCount
sampleCountersInBuffer:atSampleIndex:withBarrier:
sampleTimestamps:gpuTimestamp:
sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:
sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledRenderCommandEncoderWithProgramInfoBuffer:capacity:
samplerObjectCache
saveCommandBuffer:queue:profilingResults:
scissorRect
scissorRects
screenSize
self
serializeComputePipelineDescriptor:
serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:
serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:
serializeRenderPipelineDescriptor:
serializeStructType:
serializeStructType:version:
serializeToURL:error:
serializeToURL:options:error:
setAccelerationStructure:atBufferIndex:
setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setAccelerationStructure:atBufferIndex:stage:
setAccelerationStructure:atIndex:
setAccelerationStructures:withBufferRange:
setAccess:
setAddressSpace:
setAlphaTestReferenceValue:
setApplyFunctionConstants:
setArgument:
setArgumentBuffer:offset:
setArgumentBuffer:startOffset:arrayElement:
setArgumentBuffer:startOffset:elementIndex:
setBackgroundGPUPriority:
setBackgroundGPUPriority:offset:
setBackgroundTrackingPID:
setBarrier
setBaseObject:
setBinaryArchives:
setBinaryFunctions:
setBlendColorRed:green:blue:alpha:
setBoundingBoxBuffer:
setBuffer:
setBuffer:offset:atIndex:
setBuffer:offset:atIndex:forStage:commandIndex:
setBufferOffset:atIndex:
setBufferUsageTable:textureUsageTable:
setBufferUsageTable:textureUsageTable:forStage:
setBuffers:offsets:withRange:
setBytes:length:atIndex:
setCallIndex:
setClearColor:
setClearDepth:
setClearStencil:
setClipPlane:p2:p3:p4:atIndex:
setCode:
setColorResolveTexture:slice:depthPlane:level:atIndex:
setColorResolveTexture:slice:depthPlane:level:atIndex:yInvert:
setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:
setColorStoreAction:atIndex:
setColorStoreActionOptions:atIndex:
setCommandBufferErrorOptions:
setCommandDataCorruptModeSPI:
setCompileOptions:
setCompilerProcessesCount:
setCompletionQueue:
setComputeFunction:
setComputePipelineState:
setComputePipelineState:atIndex:
setComputePipelineStateBuffers:commandIndex:
setComputePipelineStates:withRange:
setConstantBlockAlignment:
setConstantData:
setConstantValue:type:atIndex:
setConstantValues:
setCullMode:
setDataType:
setDeadlineProfile:
setDebugInstrumentationData:
setDebugLocation:
setDebugType:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthClipMode:
setDepthClipModeSPI:
setDepthCompareFunction:
setDepthResolveTexture:slice:depthPlane:level:
setDepthResolveTexture:slice:depthPlane:level:yInvert:
setDepthStencilState:
setDepthStoreAction:
setDepthStoreActionOptions:
setDepthWriteEnabled:
setDescriptor:
setDisableRunTimeCompilation:
setEnableBarrier:
setEncoderLabel:
setErrorStackTrace:
setExecutionEnabled:
setFilePath:
setForceSoftwareVertexFetch:
setFragmentAccelerationStructure:atBufferIndex:
setFragmentAdditionalBinaryFunctions:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setFragmentBytes:length:atIndex:
setFragmentDebugInstrumentationData:
setFragmentFunction:
setFragmentIntersectionFunctionTable:atBufferIndex:
setFragmentIntersectionFunctionTables:withBufferRange:
setFragmentLinkedFunctions:
setFragmentPreloadedLibraries:
setFragmentSamplerState:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentSamplerStates:withRange:
setFragmentTexture:atIndex:
setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:
setFragmentTextures:withRange:
setFragmentVisibleFunctionTable:atBufferIndex:
setFragmentVisibleFunctionTables:withBufferRange:
setFrontFacingWinding:
setFunction:
setFunction:atIndex:
setFunctionName:
setFunctionPointers:
setFunctions:
setFunctions:withRange:
setGPUAssertionsEnabled:
setGPUPriority:offset:
setGeometryBuffer:
setGeometryBufferOffset:
setGlobalBuffer:
setGlobalBufferOffset:
setGroups:
setHeaderBuffer:
setHeaderBufferOffset:
setImage:
setImageBlockWidth:height:
setImageFilterFunctions:imageFilterFunctionInfo:
setImageblockWidth:height:
setIndex:
setIndirectArgumentBufferDecodingData:
setIndirectCommandBuffer:atIndex:
setIndirectCommandBuffers:withRange:
setInheritBuffers:
setInnerNodeBuffer:
setInnerNodeBufferOffset:
setInstanceDescriptorBuffer:
setInstanceTransformBuffer:
setInstanceTransformBufferOffset:
setIntersectionFunctionTable:atBufferIndex:
setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTable:atBufferIndex:stage:
setIntersectionFunctionTable:atIndex:
setIntersectionFunctionTables:withBufferRange:
setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTables:withBufferRange:stage:
setIntersectionFunctionTables:withRange:
setIsContentExposedToCPU:
setKernelReportBuffer:offset:
setLabel:
setLeafNodeBuffer:
setLeafNodeBufferOffset:
setLength:
setLibraries:
setLibrary:
setLineWidth:
setLinkedFunctions:
setLoadAction:
setLogs:
setMaxAnisotropy:
setMaxCommandBufferCount:
setMaxFragmentBufferBindCount:
setMaxKernelBufferBindCount:
setMaxVertexBufferBindCount:
setMembers:count:
setMeshAccelerationStructure:atBufferIndex:
setMeshAdditionalBinaryFunctions:
setMeshBuffer:offset:atIndex:
setMeshBufferOffset:atIndex:
setMeshBuffers:offsets:withRange:
setMeshBytes:length:atIndex:
setMeshDebugInstrumentationData:
setMeshFunction:
setMeshIntersectionFunctionTable:atBufferIndex:
setMeshIntersectionFunctionTables:withBufferRange:
setMeshLinkedFunctions:
setMeshPreloadedLibraries:
setMeshReportBuffer:offset:
setMeshSamplerState:atIndex:
setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setMeshTexture:atIndex:
setMeshTextures:withRange:
setMeshVisibleFunctionTable:atBufferIndex:
setMeshVisibleFunctionTables:withBufferRange:
setMetalAssertionsEnabled:
setMotionTransformBuffer:
setName:
setObject:atIndexedSubscript:
setObject:forKey:
setObject:forKeyedSubscript:
setObjectAccelerationStructure:atBufferIndex:
setObjectAdditionalBinaryFunctions:
setObjectBufferOffset:atIndex:
setObjectBuffers:offsets:withRange:
setObjectBytes:length:atIndex:
setObjectDebugInstrumentationData:
setObjectFunction:
setObjectIntersectionFunctionTable:atBufferIndex:
setObjectIntersectionFunctionTables:withBufferRange:
setObjectLinkedFunctions:
setObjectPreloadedLibraries:
setObjectReportBuffer:offset:
setObjectSamplerState:atIndex:
setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setObjectSamplerStates:withRange:
setObjectTexture:atIndex:
setObjectTextures:withRange:
setObjectThreadgroupMemoryLength:atIndex:
setObjectVisibleFunctionTable:atBufferIndex:
setObjectVisibleFunctionTables:withBufferRange:
setOffset:
setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:
setOpaqueTriangleIntersectionFunctionWithSignature:withRange:
setOperation:
setOriginalObject:
setOverrideTriple:
setOwnerWithIdentity:
setParentGPUAddress:
setParentGPUSize:
setPerPrimitiveDataBuffer:
setPerPrimitiveDataBufferOffset:
setPerformanceStatistics:
setPipelineLibrary:
setPipelineOptions:
setPluginData:
setPointSize:
setPreloadedLibraries:
setPrimitiveBuffer:
setPrimitiveBufferOffset:
setPrimitiveDataBuffer:
setPrimitiveRestartEnabled:
setPrimitiveRestartEnabled:index:
setPrivateFunctions:
setProfilingEnabled:
setProtectionOptions:
setProvokingVertexMode:
setPurgeableState:
setRange:
setRasterizationEnabled:
setRasterizationRateMap:
setRawBVHBuilderPtr:
setReadMask:
setRenderPipelineState:
setRenderPipelineStateBuffers:
setRenderPipelineStateBuffers:commandIndex:
setRenderPipelineStates:withRange:
setResolveTexture:
setResourceGroups:count:
setResponsibleProcess:
setRetainedReferences:
setSampleBuffer:
setSamplerState:atIndex:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setSamplerStates:withRange:
setScissorRects:count:
setSeparateCommits:
setShaderDebugInfoCaching:
setShaderValidationEnabled:
setSignaledValue:
setSkipRender:
setSpecifiedUsage:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
setStatLocations:
setStencilCleared
setStencilFrontReferenceValue:backReferenceValue:
setStencilReferenceValue:
setStencilResolveTexture:slice:depthPlane:level:
setStencilResolveTexture:slice:depthPlane:level:yInvert:
setStencilStoreAction:
setStencilStoreActionOptions:
setStoreActionOptions:
setStructType:withDevice:
setSubmissionQueue:
setSupportIndirectCommandBuffers:
setTessellationControlPointIndexBuffer:offset:
setTessellationControlPointIndexBuffer:offset:commandIndex:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorScale:
setTexture:
setTexture:atIndex:
setTextures:withRange:
setThreadgroupDistributionModeWithClusterGroupIndex:
setThreadgroupMemoryLength:atIndex:
setThreadgroupMemoryLength:atIndex:commandIndex:
setThreadgroupMemoryLength:offset:atIndex:
setThreadgroupPackingDisabled:
setTileAccelerationStructure:atBufferIndex:
setTileAdditionalBinaryFunctions:
setTileBuffer:offset:atIndex:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
setTileBytes:length:atIndex:
setTileDebugInstrumentationData:
setTileFunction:
setTileIntersectionFunctionTable:atBufferIndex:
setTileIntersectionFunctionTables:withBufferRange:
setTileReportBuffer:offset:
setTileSamplerState:atIndex:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setTileTexture:atIndex:
setTileTextures:withRange:
setTileVisibleFunctionTable:atBufferIndex:
setTileVisibleFunctionTables:withBufferRange:
setTransformFeedbackState:
setTransformationMatrixBuffer:
setTriangleFillMode:
setTriangleFrontFillMode:backFillMode:
setType:
setUseRetainedObjectsLock:
setValue:atIndex:
setValue:forKey:
setValue:withRange:
setVertexAccelerationStructure:atBufferIndex:
setVertexAdditionalBinaryFunctions:
setVertexAmplificationCount:viewMappings:
setVertexAmplificationMode:value:
setVertexBuffer:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setVertexBytes:length:atIndex:
setVertexDebugInstrumentationData:
setVertexFunction:
setVertexIntersectionFunctionTable:atBufferIndex:
setVertexIntersectionFunctionTables:withBufferRange:
setVertexLinkedFunctions:
setVertexPreloadedLibraries:
setVertexReportBuffer:offset:
setVertexSamplerState:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setVertexSamplerStates:withRange:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setVertexVisibleFunctionTable:atBufferIndex:
setVertexVisibleFunctionTables:withBufferRange:
setViewport:
setViewportTransformEnabled:
setViewports:count:
setVisibilityResultBuffer:
setVisibleFunctionTable:atBufferIndex:
setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setVisibleFunctionTable:atBufferIndex:stage:
setVisibleFunctionTable:atIndex:
setVisibleFunctionTables:withBufferRange:
setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setVisibleFunctionTables:withBufferRange:stage:
setVisibleFunctionTables:withRange:
setWriteMask:
setupMPSFunctionTable:
shaderDebugInfoCaching
shaderValidationEnabled
sharedMemorySize
signaledValue
simulatorHostFeatureProfile
singleFPConfig
size
skipRender
snapshotPerfSampleHandlerAndStatEnabled:forCommandBuffer:
sortedArrayUsingComparator:
sourceLibraryObjectCache
sparseSurfaceDefaultValue
sparseTexturesSupport
sparseTileSizeInBytes
sparseTileSizeInBytesForSparsePageSize:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:
specifiedUsage
stage
stageInRegion
stageInputAttributes
startCollectingPipelineDescriptors
startCollectingPipelineDescriptorsUsingPrefixForNames:
startOfEncoderSampleIndex
startOfFragmentSampleIndex
startOfVertexSampleIndex
staticThreadgroupMemoryLength
status
stencilAttachment
stencilCompareFunction
stencilFailureOperation
storageMode
storeAction
storeMeshRenderPipelineDescriptor:
storeRenderPipelineDescriptor:
storeTileRenderPipelineDescriptor:
storeValidationEnabled
stride
string
stringByPaddingToLength:withString:startingAtIndex:
stringByStandardizingPath
stringForID:
stringWithFormat:
stringWithUTF8String:
strongParent
structType
subdivideCounterList:
superclass
supportAddingBinaryFunctions
supportAddingFragmentBinaryFunctions
supportAddingMeshBinaryFunctions
supportAddingObjectBinaryFunctions
supportAddingVertexBinaryFunctions
supportArgumentBuffers
supportIndirectCommandBuffers
supportPriorityBand
supports2DLinearTexArraySPI
supports32BitFloatFiltering
supports32BitMSAA
supports32bpcMSAATextures
supports3DASTCTextures
supports3DBCTextures
supportsASTCHDRTextureCompression
supportsASTCTextureCompression
supportsAlphaYUVFormats
supportsAnisoSampleFix
supportsArgumentBuffersTier2
supportsArrayOfSamplers
supportsArrayOfTextures
supportsAtomicUlongVoidMinMax
supportsBCTextureCompression
supportsBaseVertexInstanceDrawing
supportsBfloat16Format
supportsBinaryArchives
supportsBinaryLibraries
supportsBlackOrWhiteSamplerBorderColors
supportsBufferBoundsChecking
supportsBufferPrefetchStatistics
supportsBufferWithIOSurface
supportsBufferlessClientStorageTexture
supportsCMPIndirectCommandBuffers
supportsCombinedMSAAStoreAndResolveAction
supportsCommandBufferJump
supportsCompressedTextureViewSPI
supportsComputeCompressedTextureWrite
supportsComputeMemoryBarrier
supportsConcurrentComputeDispatch
supportsCounterSampling:
supportsCountingOcclusionQuery
supportsCustomBorderColor
supportsDeadlineProfile
supportsDepthClipMode
supportsDepthClipModeClampExtended
supportsDevicePartitioning
supportsDynamicControlPointCount
supportsDynamicLibraries
supportsExplicitVisibilityGroups
supportsExtendedVertexFormats
supportsExtendedXR10Formats
supportsExtendedYUVFormats
supportsFP32TessFactors
supportsFastMathInfNaNPropagation
supportsFeatureSet:
supportsFillTexture
supportsFixedLinePointFillDepthGradient
supportsFloat16BCubicFiltering
supportsFloat16InfNanFiltering
supportsForceSeamsOnCubemaps
supportsForkJoin
supportsFragmentBufferWrites
supportsFragmentOnlyEncoders
supportsFunctionPointers
supportsFunctionPointersFromMesh
supportsFunctionPointersFromRender
supportsGFXIndirectCommandBuffers
supportsGPUStatistics
supportsGlobalVariableRelocation
supportsGlobalVariableRelocationCompute
supportsGlobalVariableRelocationRender
supportsHeapAccelerationStructureAllocation
supportsIABHashForTools
supportsImageBlockSampleCoverageControl
supportsImageBlocks
supportsIndirectStageInRegion
supportsIndirectTessellation
supportsIndirectTextures
supportsIndirectWritableTextures
supportsInt64
supportsInterchangeTiled
supportsLateEvalEvent
supportsLayeredRendering
supportsLimitedYUVFormats
supportsLinearTexture2DArray
supportsLinearTextureFromSharedBuffer
supportsLossyCompression
supportsMSAADepthResolve
supportsMSAADepthResolveFilter
supportsMSAAStencilResolve
supportsMSAAStencilResolveFilter
supportsMemoryOrderAtomics
supportsMeshShaders
supportsMeshShadersInICB
supportsMipLevelsSmallerThanBlockSize
supportsMirrorClampToEdgeSamplerMode
supportsMutableTier1ArgumentBuffers
supportsNativeHardwareFP16
supportsNonPrivateDepthStencilTextures
supportsNonPrivateMSAATextures
supportsNonSquareTileShaders
supportsNonUniformThreadgroupSize
supportsNonZeroTextureWriteLOD
supportsNorm16BCubicFiltering
supportsOpenCLTextureWriteSwizzles
supportsPacked32TextureBufferWrites
supportsPipelineLibraries
supportsPlacementHeaps
supportsPostDepthCoverage
supportsPrimitiveMotionBlur
supportsPrimitiveRestartOverride
supportsPrimitiveType:
supportsProgrammableBlending
supportsProgrammableSamplePositions
supportsPublicXR10Formats
supportsPullModelInterpolation
supportsQuadGroup
supportsQuadReduction
supportsQuadShufflesAndBroadcast
supportsQueryTextureLOD
supportsRGBA10A2Gamma
supportsRTZRounding
supportsRasterOrderGroups
supportsRasterOrderGroupsColorAttachment
supportsRasterizationRateMapWithLayerCount:
supportsRayTracingAccelerationStructureCPUDeserialization
supportsRayTracingBuffersFromTables
supportsRayTracingExtendedVertexFormats
supportsRayTracingICBs
supportsRayTracingPerPrimitiveData
supportsRaytracing
supportsRaytracingFromRender
supportsReadWriteBufferArguments
supportsReadWriteTextureArguments
supportsReadWriteTextureArgumentsTier2
supportsReadWriteTextureCubeArguments
supportsRelaxedTextureViewRequirements
supportsRenderDynamicLibraries
supportsRenderMemoryBarrier
supportsRenderPassWithoutRenderTarget
supportsRenderTargetTextureRotation
supportsRenderTextureWrites
supportsRenderToLinearTextures
supportsSIMDGroup
supportsSIMDGroupMatrix
supportsSIMDReduction
supportsSIMDShuffleAndFill
supportsSIMDShufflesAndBroadcast
supportsSRGBwrites
supportsSampleCount:
supportsSamplerAddressModeClampToHalfBorder
supportsSamplerCompareFunction
supportsSeparateDepthStencil
supportsSeparateVisibilityAndShadingRate
supportsSetThreadgroupPackingDisabled
supportsShaderBarycentricCoordinates
supportsShaderLODAverage
supportsShaderMinLODClamp
supportsSharedFunctionTables
supportsSharedStorageHeapResources
supportsSharedStorageTextures
supportsSharedTextureHandles
supportsSparseDepthAttachments
supportsSparseHeaps
supportsSparseTextures
supportsStackOverflowErrorCode
supportsStatefulDynamicLibraries
supportsStencilFeedback
supportsTLS
supportsTessellation
supportsTexture2DMultisampleArray
supportsTextureCubeArray
supportsTextureSampleCount:
supportsTextureSwizzle
supportsTextureWriteFPRoundingMode:
supportsTextureWriteRoundingMode:
supportsTileShaders
supportsUnalignedVertexFetch
supportsVariableRateRasterization
supportsVertexAmplification
supportsVertexAmplificationCount:
supportsYCBCRFormats
supportsYCBCRFormats12
supportsYCBCRFormatsPQ
supportsYCBCRFormatsXR
supportsYCBCRPackedFormats12
supportsYCBCRPackedFormatsPQ
supportsYCBCRPackedFormatsXR
swizzleKey
symbolName
synchronizeResource:
tAddressMode
tailSize
targetDeviceArchitecture
targetDeviceInfo
temporaryBufferWithBytes:length:
temporaryBufferWithLength:
tessellationControlPointIndexType
tessellationFactorBufferArgument
tessellationFactorBufferInstanceStride
tessellationFactorFormat
tessellationFactorScale
tessellationFactorStepFunction
testObjectReferenced:wasInternallyRetained:
textureBarrier
textureType
textureWriteRoundingMode
threadExecutionWidth
threadGroupSizeIsMultipleOfThreadExecutionWidth
threadgroupArgumentOffset
threadgroupMemoryDataSize
threadgroupMemoryLength
threadgroupSizeMatchesTileSize
tileAdditionalBinaryFunctions
tileArguments
tileConstantsBuffer
tileDebugInstrumentationData
tileDescriptor
tileFunction
tileFunctionData
tileHeight
tileMaxCallStackDepth
tileWidth
traceBuffer
tracePath
transformationMatrixBuffer
transformationMatrixBufferOffset
triangleCount
triangleFillMode
type
underlyingGPUAddress
unfilteredResourceOptions
unionSet:
uniqueIdentifier
unloadShaderCaches
unlockPurgeableObjects
unlockPurgeableState
unmapShaderSampleBuffer
unpackedFilePath
unsignedIntegerValue
unwrapAndModifyComputePipelineDescriptor:options:
unwrapAndModifyMeshRenderPipelineDescriptor:options:
unwrapAndModifyRenderPipelineDescriptor:options:
unwrapAndModifyTileRenderPipelineDescriptor:options:
unwrapBinaryFunctions:
unwrapMTLAccelerationStructurePassDescriptor:
unwrapMTLBlitPassDescriptor:
unwrapMTLCommandBufferDescriptor:alwaysCopy:
unwrapMTLCompileOptions:
unwrapMTLComputePassDescriptorInternal:
unwrapMTLComputePipelineDescriptor:
unwrapMTLDynamicLibraryDescriptorSPI:
unwrapMTLFunctionDescriptor:
unwrapMTLMeshRenderPipelineDescriptor:
unwrapMTLRelocations:
unwrapMTLRenderPassDescriptor:
unwrapMTLRenderPipelineDescriptor:
unwrapMTLResourceStatePassDescriptor:
unwrapMTLStitchedLibraryDescriptor:
unwrapMTLTileRenderPipelineDescriptor:
unwrapStitchedLibraryDescriptor:
updateFence:
updateFence:afterStages:
updatePipelineData
updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:
updateTextureMapping:mode:region:mipLevel:slice:
updatedFences
usage
useHeap:
useHeaps:count:stages:
useRenderPipelineState:
useRenderPipelineStates:count:
useResource:usage:
useResource:usage:stages:
useResourceGroup:usage:
useResourceGroup:usage:stages:
useResourceInternal:usage:
useResourceInternal:usage:stages:
useResourceIteration
useResources:count:usage:
useResources:count:usage:stages:
useRetainedObjectsLock
useWithComputeEncoder:usage:
useWithRenderEncoder:usage:stages:
usedSize
userDictionary
userReflection
userReflectionData
validate:width:height:
validateBinaryFunctions:stage:
validateCPUReadable
validateCPUWriteable
validateCommandQueue:
validateCommonDrawErrors:
validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:
validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:move:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceSize:toTexture:destinationSlice:destinationLevel:options:sliceCount:levelCount:
validateDeadlineAwareness:
validateDescriptor:expectedClass:
validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:
validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:
validateDynamicLibrary:state:error:
validateDynamicLibraryDescriptor:error:
validateDynamicLibraryURL:error:
validateFramebufferWithRenderPipelineState:context:
validateFunctionTableUseResource:selectorName:
validateFunctionTableUseResource:stages:context:selectorName:
validateHandleForSetFunction:
validateHeapResourceOptions:isTexture:isIOSurface:context:
validateHeapTextureUsage:options:context:
validateLinkedFunctions:context:
validateMemorylessResource:context:
validateNewBufferArgs:options:context:
validateOffset:withRequirements:
validatePixelFormatWithHeap:context:
validateRaytracing
validateRaytracingHeap
validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
validateResourceOptions:isTexture:isIOSurface:context:
validateSparseTextureMappingMode:
validateStageInRegion:
validateStoreLoadTransition:atIndex:renderTargetArrayLength:
validateTextureAccess:region:mipLevel:slice:
vendorName
vertexAttributes
vertexBuffer
vertexBufferOffset
vertexBuffers
vertexBuiltInArguments
vertexConstantsBuffer
vertexDebugInstrumentationData
vertexFormat
vertexFunction
vertexFunctionData
vertexFunctionHandleWithFunction:
vertexLinkedFunctions
vertexMaxCallStackDepth
vertexPreloadedLibraries
vertexStride
viewport
viewports
visibilityResultBuffer
visibilityResultMode
visibilityResultOffset
waitForFence:
waitForFence:beforeStages:
waitUntilComplete
waitUntilCompleted
waitUntilScheduled
waitUntilSignaledValue:timeoutMS:
watermark
width
willEncodeSignalEvent:value:writeableResources:
writeAccelerationStructureSerializationData:toBuffer:offset:
writeCompactedAccelerationStructureSize:toBuffer:offset:
writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:
writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:
writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:
writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:
writeGenericBVHStructureOfAccelerationStructure:into:
writeGenericBVHStructureSizesOfAccelerationStructure:into:
writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:
writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:
writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:
writeMask
writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:
writeToFile:options:error:
writesDepth
writesStencil
zone
@48@0:8@16@24Q32@40
Q16@0:8
@16@0:8
v16@0:8
v24@0:8@16
v40@0:8@16Q24Q32
v64@0:8{?=QQQ}16{?=QQQ}40
@"MTLIndirectCommandBufferDescriptor"
@"<MTLIndirectCommandBufferSPI>"
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@32@0:8r^v16Q24
@24@0:8Q16
I16@0:8
@"MTLGPUDebugBuffer"32@0:8r^v16Q24
@"MTLGPUDebugBuffer"24@0:8Q16
@44@0:8@16@24@32I40
@36@0:8@16@24I32
v32@0:8@16Q24
v40@0:8@16@24Q32
v32@0:8Q16Q24
v48@0:8r^@16r^Q24{_NSRange=QQ}32
v40@0:8r^v16Q24Q32
v40@0:8Q16Q24Q32
v40@0:8r^@16{_NSRange=QQ}24
v40@0:8Q16@24Q32
v48@0:8Q16Q24Q32Q40
v56@0:8Q16Q24Q32Q40Q48
v56@0:8Q16Q24Q32@40Q48
v64@0:8Q16Q24Q32@40Q48Q56
v64@0:8Q16Q24@32Q40@48Q56
v80@0:8Q16Q24Q32@40Q48Q56q64Q72
v56@0:8Q16@24Q32@40Q48
v72@0:8Q16Q24Q32@40Q48Q56Q64
v72@0:8Q16@24Q32@40Q48@56Q64
v88@0:8Q16Q24Q32@40Q48@56Q64Q72Q80
v40@0:8{?=QQQ}16
v88@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40
v92@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40I88
v88@0:8{?=QQQ}16{?=QQQ}40{?=QQQ}64
v80@0:8@16Q24{?=QQQ}32{?=QQQ}56
v40@0:8@16{_NSRange=QQ}24
v32@0:8Q16r^{?=II}24
v48@0:8@16Q24{optional<unsigned long>=(?=cQ)B}32
v40@0:8r^@16Q24Q32
v48@0:8r^@16Q24Q32Q40
v32@0:8r^@16Q24
@"MTLGPUDebugCommandBuffer"
{MTLGPUDebugStageBufferHandles="handles"[31Q]"resources"[31@"<MTLGPUDebugResource>"]"offsets"[31Q]"lengths"[31I]"gpu_address"[31[2Q]]"needsFlush"B}
{MTLGPUDebugTileThreadgroup="entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
^{Options=IiiiiI{?=b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1}}
{GPUDebugEventUUIDPacket="pipelineStateID"Q"entryPointImageID"Q"encoderID"I"eventID"I}
@"MTLGPUDebugRenderPipelineState"
@"MTLToolsDepthStencilState"
{MTLGPUDebugBufferSubAlloc="buffer"@"<MTLBuffer>""offset"Q}
{?="count"C"mappingsValid"B"mappings"[2{?="viewportArrayIndexOffset"I"renderTargetArrayIndexOffset"I}]}
@"<MTLBuffer>"
Q24@0:8Q16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v32@0:8{_NSRange=QQ}16
{MTLResourceID=Q}16@0:8
@"<MTLIndirectRenderCommand>"24@0:8Q16
@"<MTLIndirectComputeCommand>"24@0:8Q16
v32@0:8^^v16^Q24
@"<MTLFunction>"16@0:8
@"<MTLFunctionLogDebugLocation>"16@0:8
v24@0:8Q16
@"MTLGPUDebugImageData"
@"NSArray"
@"NSString"
@"<MTLFunction>"
@"<MTLFunctionLogDebugLocation>"
i16@0:8
v20@0:8i16
@"MTLArgument"
@"<MTLProgramAddressTable>"16@0:8
v136@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112
v120@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96
v128@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96Q120
v120@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112
v128@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112Q120
v44@0:8@16{_NSRange=QQ}24C40
v80@0:8@16Q24Q32@40Q48Q56Q64Q72
v32@0:8@16@24
v56@0:8@16Q24@32Q40Q48
v108@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@92Q100
v88@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80
v56@0:8@16{_NSRange=QQ}24@40Q48
v36@0:8@16Q24B32
v24@0:8@"<MTLResource>"16
v40@0:8@"<MTLTexture>"16Q24Q32
v136@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112
v120@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96
v128@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96Q120
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112
v128@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112Q120
v24@0:8@"<MTLTexture>"16
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24C40
v80@0:8@"<MTLTexture>"16Q24Q32@"<MTLTexture>"40Q48Q56Q64Q72
v32@0:8@"<MTLTexture>"16@"<MTLTexture>"24
v56@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40Q48
v24@0:8@"<MTLFence>"16
v108@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@"<MTLBuffer>"92Q100
v88@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80
v40@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24
v56@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24@"<MTLIndirectCommandBuffer>"40Q48
v36@0:8@"<MTLCounterSampleBuffer>"16Q24B32
v56@0:8@"<MTLCounterSampleBuffer>"16{_NSRange=QQ}24@"<MTLBuffer>"40Q48
v144@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136
v44@0:8@16{_NSRange=QQ}24I40
v104@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
v144@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112Q136
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24I40
v104@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
@32@0:8@16@24
@40@0:8@16@24@32
v40@0:8@16f24f28Q32
v56@0:8r^@16r^f24r^f32{_NSRange=QQ}40
v48@0:8@16Q24@32Q40
v64@0:8{?=dddddd}16
v32@0:8r^{?=dddddd}16Q24
v20@0:8f16
v28@0:8f16f20f24
v48@0:8{?=QQQQ}16
v32@0:8r^{?=QQQQ}16Q24
v20@0:8I16
v24@0:8I16I20
v32@0:8f16f20f24f28
v56@0:8@16Q24Q32Q40Q48
v60@0:8@16Q24Q32Q40B48Q52
v48@0:8@16Q24Q32Q40
v52@0:8@16Q24Q32Q40B48
@"MTLCountersTraceRenderCommandEncoder"
@32@0:8{_NSRange=QQ}16
@"NSData"32@0:8{_NSRange=QQ}16
@32@0:8@16^@24
v32@0:8@16@?24
@24@0:8@16
@40@0:8@16@24^@32
v40@0:8@16@24@?32
@48@0:8@16@24@32^@40
v48@0:8@16@24@32@?40
B32@0:8r^@16Q24
i20@0:8I16
B24@0:8@"<MTLResource>"16
^v16@0:8
@40@0:8@16Q24Q32
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@48@0:8@16Q24Q32Q40
^{__IOSurface=}16@0:8
@"<MTLTexture>"48@0:8@"MTLTextureDescriptor"16Q24Q32Q40
v24@0:8@?16
v32@0:8@16d24
d16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
v24@0:8@"<MTLDrawable>"16
v32@0:8@"<MTLDrawable>"16d24
@"<MTLBlitCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLComputeCommandEncoder>"24@0:8@"MTLComputePassDescriptor"16
@"<MTLBlitCommandEncoder>"24@0:8@"MTLBlitPassDescriptor"16
@"<MTLComputeCommandEncoder>"16@0:8
@"<MTLComputeCommandEncoder>"24@0:8Q16
v32@0:8@"<MTLEvent>"16Q24
@"<MTLParallelRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLResourceStateCommandEncoder>"16@0:8
@"<MTLResourceStateCommandEncoder>"24@0:8@"MTLResourceStatePassDescriptor"16
@"<MTLAccelerationStructureCommandEncoder>"16@0:8
@"<MTLAccelerationStructureCommandEncoder>"24@0:8@"MTLAccelerationStructurePassDescriptor"16
@"<MTLCommandQueue>"16@0:8
@"<MTLLogContainer>"16@0:8
@"NSError"16@0:8
v56@0:8@16Q24r^Q32r^Q40Q48
B24@0:8Q16
v20@0:8B16
^v24@0:8^Q16
@40@0:8@16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
v36@0:8@16Q24I32
v40@0:8Q16r^@24Q32
v24@0:8@"<MTLResourceGroupSPI>"16
v48@0:8@"<MTLResourceGroupSPI>"16Q24Q32Q40
v56@0:8@"<MTLResourceGroupSPI>"16Q24r^Q32r^Q40Q48
v24@0:8@"<MTLHeap>"16
v24@0:8@"NSArray"16
v32@0:8@"<MTLDrawable>"16@"NSDictionary"24
@"NSDictionary"16@0:8
@"NSMutableDictionary"16@0:8
@"<MTLDeadlineProfile>"16@0:8
@"<MTLRenderCommandEncoder>"40@0:8@"MTLRenderPassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@"<MTLComputeCommandEncoder>"40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"40@0:8@"MTLComputePassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLDebugCommandEncoder>"16@0:8
v36@0:8@"<MTLEvent>"16Q24I32
B24@0:8@"MTLToolsObject"16
@"NSMutableSet"16@0:8
v40@0:8@16Q24@32
v44@0:8i16Q20r^@28Q36
{?="hasCommit"b1"addedCompletedHandler"b1"addedScheduledHandler"b1"padding"b29}
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
{vector<void (^)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__begin_"^@?"__end_"^@?"__end_cap_"{__compressed_pair<void (^*)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__value_"^@?}}
@"MTLToolsDeadlineProfile"
@"NSMutableSet"
v28@0:8I16I20I24
@"<MTLToolsRetainingContainer>"
v40@0:8@16Q24^v32
@40@0:8^Q16^v24^B32
{vector<std::pair<NSData *, unsigned long>, std::allocator<std::pair<NSData *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<NSData *, unsigned long> *, std::allocator<std::pair<NSData *, unsigned long>>>="__value_"^v}}
{__wrap_iter<std::pair<NSData *, unsigned long> *>="__i"^v}
@"<MTLCommandBuffer>"16@0:8
@"<MTLCommandBuffer>"24@0:8@"MTLCommandBufferDescriptor"16
B28@0:8Q16S24
i24@0:8@16
i32@0:8@16Q24
v24@0:8@"NSObject<OS_dispatch_queue>"16
@"NSObject<OS_dispatch_queue>"16@0:8
@"MTLCommandQueueSPIStats"16@0:8
@"NSArray"16@0:8
i24@0:8@"NSArray"16
i32@0:8@"NSArray"16Q24
@"NSArray"24@0:8@"NSArray"16
v24@0:8@?<v@?@"<MTLCommandBuffer>"@"NSData"Q>16
@?32@0:8^B16@24
@"MTLToolsPerfCounterMailbox"
@48@0:8@16@24@32Q40
@56@0:8@16@24@32@40Q48
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__cxx_atomic_base_impl<int>>="__a_value"Ai}}
@"MTLToolsObject"
B32@0:8@16^@24
B32@0:8@"NSURL"16^@24
B40@0:8@16Q24^@32
r^{?=[32C]}16@0:8
B40@0:8@"NSURL"16Q24^@32
@"NSString"24@0:8Q16
@"NSObject<OS_dispatch_data>"16@0:8
@"MTLDebugInstrumentationData"16@0:8
v24@0:8@"MTLDebugInstrumentationData"16
B40@0:8@16@24^@32
B32@0:8@"MTLComputePipelineDescriptor"16^@24
B32@0:8@"MTLRenderPipelineDescriptor"16^@24
B32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
B40@0:8@"MTLFunctionDescriptor"16@"<MTLLibrary>"24^@32
@24@0:8^@16
@40@0:8Q16^I24^@32
v32@0:8@16r^{?=[32C]}24
@24@0:8r^{?=[32C]}16
^{MTLPipelineCollection=}16@0:8
B24@0:8@?16
v32@0:8@"MTLBinaryEntry"16@"MTLBinaryKey"24
@"MTLBinaryEntry"24@0:8@"MTLBinaryKey"16
@"NSString"24@0:8^@16
@"<NSObject>"40@0:8Q16^I24^@32
v24@0:8@"<MTLBinaryArchive>"16
@"NSMutableArray"16@0:8
B40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
B40@0:8@"MTLRenderPipelineDescriptor"16Q24^@32
B40@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32
B32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
B40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32
v32@0:8@"NSObject<OS_dispatch_data>"16r^{?=[32C]}24
@"NSObject<OS_dispatch_data>"24@0:8r^{?=[32C]}16
B32@0:8@"MTLStitchedLibraryDescriptor"16^@24
B24@0:8@"MTLComputePipelineDescriptor"16
B24@0:8@"MTLRenderPipelineDescriptor"16
B24@0:8@"MTLTileRenderPipelineDescriptor"16
B24@0:8@"MTLMeshRenderPipelineDescriptor"16
B24@0:8@?<B@?^{?=[32C]}@"NSObject<OS_dispatch_data>">16
@32@0:8Q16Q24
@40@0:8Q16Q24Q32
@32@0:8@16Q24
q16@0:8
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLBuffer>"40@0:8Q16Q24Q32
@"<MTLTexture>"32@0:8@"MTLTextureDescriptor"16Q24
@"<MTLAccelerationStructure>"24@0:8Q16
@"<MTLAccelerationStructure>"24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLAccelerationStructure>"32@0:8Q16Q24
@"<MTLAccelerationStructure>"32@0:8@"MTLAccelerationStructureDescriptor"16Q24
@"<MTLAccelerationStructure>"40@0:8Q16Q24Q32
v64@0:8{?={?=QQQ}{?=QQQ}}16
v56@0:8@16Q24{?=QQQ}32
v24@0:8@"<MTLComputePipelineState>"16
v40@0:8@"<MTLBuffer>"16Q24Q32
v32@0:8@"<MTLVisibleFunctionTable>"16Q24
v32@0:8@"<MTLIntersectionFunctionTable>"16Q24
v32@0:8@"<MTLAccelerationStructure>"16Q24
v32@0:8@"<MTLTexture>"16Q24
v32@0:8@"<MTLSamplerState>"16Q24
v40@0:8@"<MTLSamplerState>"16f24f28Q32
v32@0:8@"<MTLBuffer>"16Q24
v56@0:8@"<MTLBuffer>"16Q24{?=QQQ}32
v32@0:8@"<MTLResource>"16Q24
v40@0:8@"<MTLIndirectCommandBuffer>"16@"<MTLBuffer>"24Q32
v24@0:8q16
B44@0:8@16Q24Q32I40
v44@0:8@16Q24Q32I40
@"NSData"16@0:8
v32@0:8@"<MTLResourceGroupSPI>"16Q24
B44@0:8@"<MTLBuffer>"16Q24Q32I40
v44@0:8@"<MTLBuffer>"16Q24Q32I40
@"MTLGPUDebugBuffer"
@"MTLGPUDebugDevice"
{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{KeyBufferPair="key"{Key="hash"{?="key"[32C]}"data"@"NSData"}"buffer"@"<MTLBuffer>"}
@"MTLDebugInstrumentationData"
@"MTLGPUDebugFunction"
@"MTLGPUDebugDynamicLibrary"
v48@0:8@16@24@32Q40
v56@0:8@16@24@32@40Q48
v64@0:8@16@24@32@40Q48Q56
v48@0:8@16@24Q32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLBuffer>"32Q40
v56@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48
v64@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48Q56
v32@0:8@"<MTLAccelerationStructure>"16@"<MTLAccelerationStructure>"24
v40@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32Q40
v48@0:8@16@24Q32@40
v56@0:8@16@24@32Q40@48
B32@0:8@16@24
v120@0:8@16@24Q32@40Q48@56Q64@72Q80@88Q96@104Q112
v48@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"MTLAccelerationStructureDescriptor"40
v56@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40@"MTLAccelerationStructureDescriptor"48
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBufferSizesSPI"24
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBuffersSPI"24
v120@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64@"<MTLBuffer>"72Q80@"<MTLBuffer>"88Q96@"<MTLBuffer>"104Q112
Q40@0:8{?=QQQ}16
@"<MTLFunctionHandle>"24@0:8@"<MTLFunction>"16
@"<MTLComputePipelineState>"32@0:8@"NSArray"16^@24
@"<MTLVisibleFunctionTable>"24@0:8@"MTLVisibleFunctionTableDescriptor"16
@"<MTLIntersectionFunctionTable>"24@0:8@"MTLIntersectionFunctionTableDescriptor"16
v32@0:8@"MTLGPUDebugComputeCommandEncoder"16Q24
v48@0:8@"MTLGPUDebugRenderCommandEncoder"16Q24{optional<unsigned long>=(?=cQ)B}32
@"<MTLResource>"16@0:8
@48@0:8@16@24Q32Q40
@52@0:8@16@24Q32Q40B48
@60@0:8@16@24@32Q40Q48B56
^v24@0:8Q16
{?={?=QQQ}{?=QQQ}}16@0:8
@"_MTLIndirectDispatchThreadgroupsArguments"16@0:8
@"_MTLIndirectDispatchThreadsArguments"16@0:8
@"_MTLImageBlockArguments"16@0:8
v24@0:8^Q16
@32@0:8^@16^Q24
@32@0:8@16^Q24
@48@0:8@16Q24^@32^@40
v40@0:8@16Q24@?32
@40@0:8@16r^{?=BQ^{?}}24^@32
@40@0:8@16Q24^@32
@48@0:8@16@24Q32^@40
@40@0:8Q16@24^@32
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@24@0:8^{__IOSurface=}16
@48@0:8r^v16Q24Q32Q40
@56@0:8^v16Q24Q32Q40@?48
@40@0:8@16^{__IOSurface=}24Q32
@48@0:8^v16Q24@32@?40
{?=QQQ}24@0:8@16
@32@0:8^v16@24
@40@0:8^v16@24@32
@32@0:8Q16@24
{MetalBufferHeap="_mutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_buffers"{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}"_freeList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_currentFreeIndex"i"_totalMemoryAllocated"Q"_totalMemoryInUse"Q"_bufferLength"Q"_device"@"MTLGPUDebugDevice"}
{Options="version"I"mode"i"programTypes"i"accessTypes"i"failMode"i"maxTrackedResourcesMultiplier"I""{?="enableReporting"b1"packPointerAddresses"b1"unpackPointerAddress"b1"forceInline"b1"enableBacktracking"b1"optimizeConstantDeref"b1"skipVertexFetchLoads"b1"enableGEPOptimization"b1"emitBoundsChecking"b1"runStandardOptimizations"b1"backtrackFailuresAssumeSafe"b1"pageDataIs32bitLength"b1"forceUnrollLoops"b1"mergeAccessChecks"b1"convertToAB"b1"arraysOfBuffersAB"b1"noInlineTrivialFunctions"b1"unrollMemCpyWA"b1"checkGlobalConstants"b1"enableTextureChecks"b1"demoteGlobalConstantsToArg"b1"argumentPointerIndirection"b1"enableThreadgroupMemoryChecks"b1"mergeThreadgroupGlobals"b1"mergeThreadgroupArguments"b1"tagThreadgroupPointers"b1"noInlineCheckFunctions"b1"enableJumpThreading"b1"enableICBSupport"b1"enableGlobalRelocations"b1"enableTrapReporting"b1"enableRaytracing"b1"enableResourceUsageValidation"b1"enableStackOverflow"b1"enableDumpToStderr"b1}}
{GPUDebugDeviceOptions="retainReflection"b1"retainPSOFunctions"b1"abortOnFault"b1}
{GPUDebugBufferDescriptorHeap="s"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_freeIndexList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_bufferList"{vector<MTLGPUDebugBuffer *, std::allocator<MTLGPUDebugBuffer *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<MTLGPUDebugBuffer **, std::allocator<MTLGPUDebugBuffer *>>="__value_"^@}}"_freeIndex"Q"_argumentEncoder"@"<MTLArgumentEncoder>""_descriptorHeap"@"<MTLBuffer>"}
{GPUDebugConstantBufferCache="_totalUsedMemory"Q"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_cache"{unordered_map<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, std::allocator<std::pair<const GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__table_"{__hash_table<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>, std::allocator<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>>="__value_"f}}}"_device"@"MTLGPUDebugDevice"}
{GlobalResidentBufferList="_iteration"I"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_bufferList"{list<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__end_"{__list_node_base<id<MTLBuffer>, void *>="__prev_"^v"__next_"^v}"__size_alloc_"{__compressed_pair<unsigned long, std::allocator<std::__list_node<id<MTLBuffer>, void *>>>="__value_"Q}}}
@"NSData"
@"NSMutableArray"
{once_flag="__state_"Q}
@"<MTLRenderPipelineState>"
@"<MTLDepthStencilState>"
@"<MTLComputePipelineState>"
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
B24@0:8q16
v32@0:8^{?=ff}16Q24
{?=QQQ}40@0:8Q16Q24Q32
Q24@0:8q16
{?=QQQ}48@0:8Q16Q24Q32q40
v32@0:8^Q16^Q24
{?=QQ}24@0:8Q16
{?=QQQ}16@0:8
v72@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56Q64
v64@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56
@"<MTLCommandQueue>"24@0:8Q16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptor"16^@24
v32@0:8@"MTLStitchedLibraryDescriptor"16@?<v@?@"<MTLLibrary>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLRenderPipelineState>"48@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLRasterizationRateMap>"24@0:8@"MTLRasterizationRateMapDescriptor"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@"<MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
@"<MTLArgumentEncoder>"24@0:8@"<MTLBufferBinding>"16
@"<MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
@"<MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
@"<MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
{?=QQQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=QQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=II}16@0:8
@20@0:8I16
B24@0:8{?=II}16
v40@0:8@16r^v24@32
v48@0:8@16r^v24@32@40
B36@0:8@16B24^@28
^{MTLCompilerConnectionManager=}20@0:8i16
B20@0:8i16
r^{MTLTargetDeviceArch=QI*}16@0:8
r^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ}16@0:8
f16@0:8
{IndirectArgumentBufferCapabilities=b1b1b1b29}16@0:8
v24@0:8^{MPSFunctionTable=}16
v40@0:8Q16^Q24Q32
B32@0:8{_NSRange=QQ}16
B40@0:8^{?=III}16Q24Q32
@32@0:8^v16Q24
@40@0:8^v16@24Q32
^{os_unfair_lock_s=I}16@0:8
@28@0:8@16I24
@28@0:8@16B24
{?=QQQ}48@0:8q16Q24Q32Q40
v48@0:8@16@24@32^@40
v40@0:8@16@24^@32
@32@0:8r^@16Q24
@"MTLArchitecture"24@0:8@"NSArray"16
v24@0:8@"<MTLDeviceSPI>"16
@"<MTLBuffer>"24@0:8^{__IOSurface=}16
B24@0:8@"NSString"16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
@"_MTLIndirectArgumentBufferLayout"24@0:8@"MTLStructType"16
@"<MTLArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLIndirectRenderCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLIndirectComputeCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLSharedEvent>"20@0:8I16
@"<MTLAccelerationStructure>"32@0:8@"<MTLBuffer>"16Q24
@"<MTLAccelerationStructure>"40@0:8@"<MTLBuffer>"16Q24Q32
@"<MTLAccelerationStructure>"32@0:8^v16@"MTLAccelerationStructureDescriptor"24
@"<MTLAccelerationStructure>"40@0:8^v16@"NSArray"24@"MTLAccelerationStructureDescriptor"32
@"<MTLAccelerationStructure>"32@0:8Q16@"MTLAccelerationStructureAllocationDescriptor"24
v40@0:8@"<MTLAccelerationStructure>"16r^v24@"MTLAccelerationStructureDescriptor"32
v48@0:8@"<MTLAccelerationStructure>"16r^v24@"NSArray"32@"MTLAccelerationStructureDescriptor"40
@"<MTLDynamicLibrary>"40@0:8@"<MTLLibrary>"16@"MTLComputePipelineDescriptor"24^@32
B32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"40@0:8@"NSURL"16Q24^@32
@"NSArray"32@0:8@"MTLComputePipelineDescriptor"16^@24
@"NSArray"40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
@"NSArray"40@0:8@"MTLFunction"16@"NSArray"24^@32
@"NSArray"48@0:8@"MTLFunction"16@"NSArray"24Q32^@40
B36@0:8@"<MTLLibrary>"16B24^@28
@"<MTLBinaryArchive>"40@0:8Q16@"NSURL"24^@32
@"<MTLRenderPipelineState>"32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
v32@0:8@"MTLMeshRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLDeadlineProfile>"24@0:8Q16
@"MTLTargetDeviceArchitecture"16@0:8
@"MTLArchitecture"16@0:8
@"MTLGPUBVHBuilder"16@0:8
v24@0:8@"NSDictionary"16
v24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLBuffer>"48@0:8r^v16Q24Q32Q40
@"<MTLBuffer>"56@0:8^v16Q24Q32Q40@?<v@?^vQ>48
@"<MTLBuffer>"24@0:8@"MTLBufferDescriptor"16
@"<MTLLateEvalEvent>"16@0:8
@"<MTLComputePipelineState>"32@0:8@"MTLComputePipelineDescriptor"16^@24
v32@0:8@"MTLComputePipelineDescriptor"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
v32@0:8@"MTLTileRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLFunction>"32@0:8^v16Q24
@"<MTLFunction>"40@0:8^v16@"NSObject<OS_dispatch_data>"24Q32
v24@0:8@"MTLGPUBVHBuilder"16
@"<MTLIndirectArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLComputePipelineState>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLLibrary>"40@0:8@"NSString"16@"NSArray"24^@32
@"<MTLLibrary>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptorSPI"16^@24
@"NSString"24@0:8@"NSArray"16
@"<MTLLibrary>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLPipelineLibrarySPI>"32@0:8@"NSString"16^@24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLRenderPipelineDescriptor"16
@"NSObject<OS_dispatch_data>"24@0:8@"MTLComputePipelineDescriptor"16
@"MTLRenderPipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"MTLComputePipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLStructType"16
@"NSObject<OS_dispatch_data>"28@0:8@"MTLStructType"16I24
@"MTLStructType"24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLTexture>"48@0:8^v16Q24@"MTLTextureDescriptor"32@?<v@?^vQ>40
@"<MTLTextureLayout>"28@0:8@"MTLTextureDescriptor"16B24
@"<MTLIndirectArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
v48@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@"<MTLBinaryArchive>"32^@40
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24^@32
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@?<v@?@"NSError">32
@"<MTLResourceGroupSPI>"32@0:8r^@16Q24
v32@0:8@"NSObject<OS_dispatch_data>"16@"NSMutableDictionary"24
Q28@0:8Q16B24
@"<MTLDeviceSPI>"
@"MTLToolsObjectCache"
v40@0:8@"MTLSharedEventListener"16Q24@?<v@?@"<MTLSharedEvent>"Q>32
@"MTLSharedEventHandle"16@0:8
B32@0:8Q16Q24
@32@0:8Q16^@24
@"<MTLArgumentEncoder>"24@0:8Q16
@"<MTLArgumentEncoder>"32@0:8Q16^@24
v32@0:8Q16@?24
@40@0:8Q16^@24@32
@28@0:8@16C24
@"MTLFunctionReflection"24@0:8Q16
@"MTLFunctionReflection"32@0:8Q16@"<MTLPipelineLibrary>"24
@"MTLFunctionReflection"32@0:8Q16@"NSArray"24
v32@0:8Q16@?<v@?@"MTLFunctionReflection">24
@"<MTLArgumentEncoder>"32@0:8Q16@"<MTLPipelineLibrary>"24
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"<MTLPipelineLibrary>"32
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"NSArray"32
@"<MTLFunction>"28@0:8@"NSData"16C24
@"MTLType"16@0:8
@"<MTLFunctionHandle>"16@0:8
@"<MTLFunction>"24@0:8@"NSString"16
@"<MTLFunction>"40@0:8@"NSString"16@"MTLFunctionConstantValues"24^@32
v40@0:8@"NSString"16@"MTLFunctionConstantValues"24@?<v@?@"<MTLFunction>"@"NSError">32
v32@0:8@"MTLFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLFunctionDescriptor"16^@24
v32@0:8@"MTLIntersectionFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLIntersectionFunctionDescriptor"16^@24
@"<MTLFunction>"48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32^@40
v48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32@?<v@?@"<MTLFunction>"@"NSError">40
@"<MTLFunction>"40@0:8@"MTLFunctionDescriptor"16@"<MTLBinaryArchive>"24^@32
@"NSUUID"16@0:8
v32@0:8@"<MTLFunctionHandle>"16Q24
v40@0:8Q16{_NSRange=QQ}24
@"<MTLBuffer>"16@0:8
v24@0:8@"<MTLBuffer>"16
@"MTLCountersTraceComputeCommandEncoder"
@64@0:8@16@24@32@40@48Q56
@80@0:8@16@24@32@40@48@56@64@72
@48@0:8@16@24@32@40
@"MTLRenderPipelineReflection"
@"MTLToolsDevice"
@"<MTLRenderCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
v24@0:8@"<MTLRenderPipelineState>"16
v24@0:8@"<MTLDepthStencilState>"16
v80@0:8@"<MTLBuffer>"16Q24{?=QQQ}32{?=QQQ}56
v64@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56
v56@0:8Q16Q24Q32@"<MTLBuffer>"40Q48
v80@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56q64Q72
v40@0:8Q16@"<MTLBuffer>"24Q32
v64@0:8Q16Q24@"<MTLBuffer>"32Q40@"<MTLBuffer>"48Q56
v32@0:8@"<MTLFence>"16Q24
v72@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64
v56@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48
v88@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80
v72@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64
v40@0:8@"<MTLResource>"16Q24Q32
v32@0:8@"<MTLHeap>"16Q24
v40@0:8f16f20f24f28Q32
v44@0:8@16f24f28f32Q36
v28@0:8B16Q20
v24@0:8@?<v@?@"<MTLRenderCommandEncoderSPI>"Q>16
v48@0:8@"<MTLTexture>"16Q24@"<MTLSamplerState>"32Q40
v44@0:8@"<MTLSamplerState>"16f24f28f32Q36
v56@0:8@"<MTLTexture>"16Q24Q32Q40Q48
v60@0:8@"<MTLTexture>"16Q24Q32Q40B48Q52
v48@0:8@"<MTLTexture>"16Q24Q32Q40
v52@0:8@"<MTLTexture>"16Q24Q32Q40B48
v40@0:8@"<MTLResourceGroupSPI>"16Q24Q32
v60@0:8@16Q24Q32Q40Q48B56
v48@0:8r^@16{_NSRange=QQ}24Q40
@"MTLGPUDebugComputePipelineState"
@40@0:8@16Q24@32
{?=QQQ}24@0:8Q16
{?=ff}32@0:8{?=ff}16Q24
{?=QQ}16@0:8
v24@0:8@"MTLRasterizationRateMapDescriptor"16
@32@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16Q24
{_NSRange=QQ}16@0:8
^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}
{_NSRange="location"Q"length"Q}
@24@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16
v80@0:8Q16Q24Q32@40Q48Q56Q64Q72
v64@0:8@16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v64@0:8@16Q24Q32@40Q48Q56
@20@0:8B16
v32@0:8r^v16Q24
v40@0:8r^v16@24@32
{BinaryBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}"_timebase"{mach_timebase_info="numer"I"denom"I}}
{AppendBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}}
@"<MTLFunctionHandle>"32@0:8@"<MTLFunction>"16Q24
@"<MTLVisibleFunctionTable>"32@0:8@"MTLVisibleFunctionTableDescriptor"16Q24
@"<MTLIntersectionFunctionTable>"32@0:8@"MTLIntersectionFunctionTableDescriptor"16Q24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineFunctionsDescriptor"16^@24
@"<MTLRenderPipelineState>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLRenderPipelineState>"32@0:8@"NSArray"16^@24
@32@0:8@16:24
@"MTLToolsHeap"
v112@0:8Q16Q24Q32@40Q48@56Q64Q72Q80@88Q96Q104
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLTexture>"16@0:8
@48@0:8Q16Q24Q32Q40
@72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
@"<MTLTexture>"48@0:8Q16Q24Q32Q40
@"<MTLTexture>"32@0:8Q16Q24
@"<MTLTexture>"72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@"<MTLTexture>"76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
v104@0:8Q16Q24{?=QQQ}32{?=QQQ}56^v80Q88Q96
v104@0:8r^v16Q24Q32Q40Q48{?=QQQ}56{?=QQQ}80
@"<MTLTexture>"
v120@0:8r^v16Q24Q32Q40^v48Q56Q64{?={?=QQQ}{?=QQQ}}72
v120@0:8r^v16Q24Q32{?={?=QQQ}{?=QQQ}}40^v88Q96Q104Q112
v24@0:8^v16
{?=[2Q]}16@0:8
@56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
@"<MTLBuffer>"56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
{pair<id<MTLBuffer>, unsigned long>=@Q}24@0:8Q16
{ReportBufferEntry=Q@Q}24@0:8Q16
@"<MTLArgumentEncoder>"
{vector<MetalBuffer, std::allocator<MetalBuffer>>="__begin_"^{MetalBuffer}"__end_"^{MetalBuffer}"__end_cap_"{__compressed_pair<MetalBuffer *, std::allocator<MetalBuffer>>="__value_"^{MetalBuffer}}}
{MetalBuffer="heap"^{MetalBufferHeap}"index"I}
{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}
{vector<ReportBufferEntry, std::allocator<ReportBufferEntry>>="__begin_"^{ReportBufferEntry}"__end_"^{ReportBufferEntry}"__end_cap_"{__compressed_pair<ReportBufferEntry *, std::allocator<ReportBufferEntry>>="__value_"^{ReportBufferEntry}}}
{vector<NSString *, std::allocator<NSString *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<NSString **, std::allocator<NSString *>>="__value_"^@}}
[2{BufferUsageTable="_backingMemory"@"<MTLBuffer>"}]
[2{TextureUsageTable="_backingMemory"@"<MTLBuffer>"}]
{HeapUsageTable="_heapStages"{vector<std::pair<MTLGPUDebugHeap *, unsigned long>, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<MTLGPUDebugHeap *, unsigned long> *, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__value_"^v}}}
v64@0:8@"<MTLTexture>"16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@"<MTLTexture>"16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v48@0:8@"<MTLTexture>"16Q24@"<MTLBuffer>"32Q40
v64@0:8@"<MTLTexture>"16Q24Q32@"<MTLBuffer>"40Q48Q56
v148@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136B144
v112@0:8@16Q24Q32{?=QQQ}40@64Q72Q80Q88Q96Q104
{deque<id, std::allocator<id>>="__map_"{__split_buffer<id *, std::allocator<id *>>="__first_"^^@"__begin_"^^@"__end_"^^@"__end_cap_"{__compressed_pair<id **, std::allocator<id *>>="__value_"^^@}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<id>>="__value_"Q}}
@"MTLDebugCommandBuffer"
@40@0:8@16@24Q32
@48@0:8@16@24r^v32Q40
r^v16@0:8
@"MTLDebugResource"
@"MTLDebugDevice"
@"MTLDebugCommandQueue"
v32@0:8@16B24B28
v28@0:8@16B24
B32@0:8@16^B24
@"_MTLCommandEncoder"
{unordered_multiset<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__table_"{__hash_table<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>, std::allocator<std::__hash_node<AttachmentDescriptorSimple, void *>>>="__value_"{__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, AttachmentDescriptorSimple::hash_t>="__value_"Q}"__p3_"{__compressed_pair<float, AttachmentDescriptorSimple::equal_t>="__value_"f}}}
{array<AttachmentDescriptorSimple, 8UL>="__elems_"[8{AttachmentDescriptorSimple="texture"^v"level"Q"sliceRange"{_NSRange="location"Q"length"Q}"depthPlaneRange"{_NSRange="location"Q"length"Q}"storeAction"Q}]}
{unordered_set<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__table_"{__hash_table<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>, std::allocator<std::__hash_node<id<MTLDebugResourcePurgeable>, void *>>>="__value_"{__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<id<MTLDebugResourcePurgeable>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<id<MTLDebugResourcePurgeable>>>="__value_"f}}}
{unordered_set<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__table_"{__hash_table<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>, std::allocator<std::__hash_node<MTLToolsObject *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLToolsObject *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLToolsObject *>>="__value_"f}}}
v96@0:8Q16Q24Q32@40Q48Q56Q64@72Q80Q88
v96@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64@"<MTLBuffer>"72Q80Q88
v112@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80@"<MTLBuffer>"88Q96Q104
^{?=[3I]}16@0:8
@"_MTLIndirectDrawArguments"16@0:8
@"_MTLIndirectDrawIndexedArguments"16@0:8
@"_MTLIndirectDrawPatchesArguments"16@0:8
@"_MTLIndirectDrawIndexedPatchesArguments"16@0:8
@"_MTLIndirectTessellationFactorArguments"16@0:8
@"MTLCounterSampleBufferDescriptor"
@40@0:8@16r^v24@32
@56@0:8@16@24@32@40@48
@"MTLComputePipelineReflection"
[31{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[128{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[16{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{?="width"Q"height"Q"depth"Q}
{?="origin"{?="x"Q"y"Q"z"Q}"size"{?="width"Q"height"Q"depth"Q}}
[3Q]
@"MTLComputePipelineDescriptor"
@56@0:8@16@24@32Q40Q48
@"<MTLIndirectCommandBuffer>"
@"<MTLComputePipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"<MTLRenderPipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"MTLComputePipelineDescriptor"32@0:8@"NSString"16^@24
@"MTLRenderPipelineDescriptor"32@0:8@"NSString"16^@24
@"<MTLPipelineCache>"16@0:8
v32@0:8@"<MTLRenderPipelineState>"16Q24
v32@0:8@"<MTLComputePipelineState>"16Q24
v32@0:8@"<MTLIndirectCommandBuffer>"16Q24
@"_MTLIndirectArgumentBufferLayout"16@0:8
{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}
v32@0:8@16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16B24B28^{_MTLMessageContext=q*I@q@*}32
v40@0:8Q16Q24^{_MTLMessageContext=q*I@q@*}32
v40@0:8@16Q24^f32
{MTLSamplerDescriptorHashMap="_map"{unordered_map<std::array<unsigned long long, 3>, unsigned int, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, std::allocator<std::pair<const std::array<unsigned long long, 3>, unsigned int>>>="__table_"{__hash_table<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>, std::allocator<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>>="__value_"f}}}"_limit"I}
{unordered_set<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__table_"{__hash_table<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>, std::allocator<std::__hash_node<MTLDebugCommandBuffer *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLDebugCommandBuffer *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLDebugCommandBuffer *>>="__value_"f}}}
{CheckerboardRenderTargetPipelineCache="_cacheLock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"_library"@"<MTLLibrary>""_vertexFunction"@"<MTLFunction>""_depthStencilState"[2@"<MTLDepthStencilState>"]"_fConstants"@"MTLFunctionConstantValues""_cache"{unordered_map<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, std::allocator<std::pair<const MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__table_"{__hash_table<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>, std::allocator<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>>="__value_"f}}}}
C16@0:8
@"MTLDepthStencilDescriptor"
@56@0:8@16@24Q32Q40@48
@"MTLCountersTraceResourceStateCommandEncoder"
@"MTLAccelerationStructureDescriptor"16@0:8
v24@0:8@"MTLAccelerationStructureDescriptor"16
@"MTLToolsBuffer"
@32@0:8@16@?24
@"NSMapTable"
{recursive_mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{vector<id, std::allocator<id>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id *, std::allocator<id>>="__value_"^@}}
@"MTLFunctionConstantValues"
@56@0:8@16@24Q32@40@48
v32@0:8@16#24
v32@0:8@16r^{?=BQ^{?}}24
^{?=BQ^{?}}16@0:8
@"MTLCompileOptions"
^{?=BQ^{?}}
{atomic<unsigned long long>="__a_"{__cxx_atomic_impl<unsigned long long, std::__cxx_atomic_base_impl<unsigned long long>>="__a_value"AQ}}
@"MTLRenderPassDescriptor"
@32@0:8r^{MTLRenderPassAttachmentDescriptorPrivate=@QQQQQQ{?=dddd}dIQ@QQQQQQB}16Q24
Q24@0:8@16
{?=dddddd}16@0:8
{?=QQQQ}16@0:8
v56@0:8{?=QQQ}16^{?={?=QQQ}{?=QQQ}}40^I48
v48@0:8@16Q24^{_MTLMessageContext=q*I@q@*}32@40
v24@0:8^{_MTLMessageContext=q*I@q@*}16
v56@0:8Q16Q24Q32Q40r*48
v72@0:8Q16Q24Q32@40Q48Q56r*64
v64@0:8@16Q24Q32^{?=BBQ@QQQQQBff}40Q48Q56
v72@0:8r^@16{_NSRange=QQ}24Q40^{?=BBQ@QQQQQBff}48Q56Q64
{?=BBQ@QQQQQBff}16@0:8
^{?=QQ}
[10{?="pixelFormat"Q"sampleCount"Q}]
[36{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{vector<MTLViewport, std::allocator<MTLViewport>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLViewport *, std::allocator<MTLViewport>>="__value_"^{?}}}
{vector<MTLScissorRect, std::allocator<MTLScissorRect>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLScissorRect *, std::allocator<MTLScissorRect>>="__value_"^{?}}}
{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}
@"MTLCountersTraceCommandBuffer"
{MTLGPUDebugThreadgroupLengths="threadgroupSizes"[31I]"entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
@"MTLToolsFunction"
@48@0:8Q16^@24@32@40
{unordered_map<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__table_"{__hash_table<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>, std::allocator<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>>="__value_"f}}}
@40@0:8@16Q24:32
v40@0:8r^{?=QQQ}16Q24^{_MTLMessageContext=q*I@q@*}32
[8Q]
[31{?="bufferIndex"Q"bufferStride"Q}]
@"MTLRenderPipelineDescriptor"
@"MTLTileRenderPipelineDescriptor"
@"MTLMeshRenderPipelineDescriptor"
@"MTLSamplerDescriptor"
v32@0:8Q16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16{?=QQ}24
@64@0:8@16@24@32Q40Q48Q56
@88@0:8@16@24@32Q40Q48{_NSRange=QQ}56{_NSRange=QQ}72
{MTLPixelFormatInfo="name"*"flags"I"castClass"Q"type"(?="normal"{MTLNormalPixelFormatInfo="pixelBytes"Q"componentCount"C"alignment"C"pixelBytesRender"Q"pixelBytesRenderMSAA"Q}"compressed"{MTLCompressedPixelFormatInfo="blockBytes"Q"blockWidth"Q"blockHeight"Q"blockDepth"Q})}
{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::allocator<std::pair<const SubView, unsigned long>>>="__table_"{__hash_table<std::__hash_value_type<SubView, unsigned long>, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>, std::allocator<std::__hash_value_type<SubView, unsigned long>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>>="__value_"f}}}
@"MTLTextureDescriptor"
@"MTLDebugBuffer"
@"MTLCountersTraceBlitCommandEncoder"
-[MTLDebugIndirectComputeCommand setComputePipelineState:]
Setting the pipeline state of indirect command buffers created with inheritPipelineState = YES is invalid
Setting a pipeline that does not have supportIndirectCommandBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand setKernelBuffer:offset:atIndex:]
index(%lu) must be < %lu.
Setting buffers on a indirect command buffer created with inheritBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand concurrentDispatchThreadgroups:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatch is not enabled on this indirect command buffer
-[MTLDebugIndirectComputeCommand concurrentDispatchThreads:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatchThreads is not enabled on this indirect command buffer
<unknown>
<unnamed>
<nil>
Unknown
Read Only
Write Only
Read Write
%@, length:%llu, resident:%@
%@, length:%llu
Invalid %@ %@ executing %@ function "%@" encoder: "%@", %@: %lu, at offset %llu
device
threadgroup
buffer: %@
Null texture access
Texture usage flags mismatch
%@ executing %@ function "%@" encoder: "%@", %@: %lu
Stack Overflow executing function "%@", %@ function "%@" encoder: "%@", %@: %u
Trap hit in function "%@", %@ function "%@", encoder: "%@", %@: %u
kernel
dispatch
vertex
draw
fragment
visible
intersection
object
mesh
%@(%@)
%llX
.xctoolchain/
v24@?0@"<MTLFunction>"8@"NSError"16
%@%@
label =
<none>
v16@?0@"<MTLCommandBuffer>"8
vector
v32@?0@"<MTLCommandBuffer>"8@"NSData"16Q24
-[MTLDebugVisibleFunctionTable setPurgeableState:]
Setting purgeability state directly on heap sub-allocated resources is not allowed.
Cannot set purgeability state to volatile while resource is in use by a command buffer.
-[MTLDebugVisibleFunctionTable setFunction:atIndex:]
Visible Function Tables are not supported by the device.
function stage %@ does not match intersection table stage %@
pipelineState must be MTLComputePipelineState or MTLRenderPipelineState
-[MTLDebugVisibleFunctionTable setFunctions:withRange:]
NSMaxRange(range)(%lu) must be <= %lu.
functionCount =
mtl.global_constants_handle
mtl.current_image_id
v8@?0
com.apple.Metal
GPUDebug
v40@?0r^v8{_NSRange=QQ}16^B32
MTL_BOUNDS_ACCURATE_MODE
MTL_SHADER_VALIDATION_CPUOPT_FORCE_INIT
MTLBoundsCheck::Options
MTLBoundsCheck::RenderPipelineData
MTLBoundsCheck::ComputePipelineData
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
MetalShaderValidation
Metal Shader Validation does not support mesh shaders in this release. To use mesh shaders in this release, disable Metal Shader Validation in the Xcode scheme settings.
v32@?0@"<MTLComputePipelineState>"8@"MTLComputePipelineReflection"16@"NSError"24
-[MTLGPUDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
Indirect Command Buffers are not currently supported with Shader Validation
v24@?0@"<MTLLibrary>"8@"NSError"16
-[MTLGPUDebugDevice validateRaytracing]
ray tracing is not currently supported with Shader Validation
@"MTLToolsDynamicLibrary"8@?0
@"MTLToolsFunction"8@?0
MTL_SHADER_VALIDATION_MODE
Tier1
Tier2
MTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING
MTL_SHADER_VALIDATION_GLOBAL_MEMORY
MTL_SHADER_VALIDATION_THREADGROUP_MEMORY
MTL_SHADER_VALIDATION_TEXTURE_USAGE
MTL_SHADER_VALIDATION_RESOURCE_USAGE
MTL_SHADER_VALIDATION_STACK_OVERFLOW
MTL_SHADER_VALIDATION_REPORT_TO_STDERR
MTL_SHADER_VALIDATION_COMPILER_INLINING
none
full
partial
default
MTL_SHADER_VALIDATION_FAIL_MODE
zerofill
allow
MTL_SHADER_VALIDATION_GPUOPT_FORCE_INLINE
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_PACK_POINTER_ADDRESSES
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_BACKTRACK
MTL_SHADER_VALIDATION_GPUOPT_CONST_DEREF
MTL_SHADER_VALIDATION_GPUOPT_GEP
MTL_SHADER_VALIDATION_GPUOPT_GENERIC
MTL_SHADER_VALIDATION_GPUOPT_SKIP_VFETCH
MTL_SHADER_VALIDATION_GPUOPT_BACKTRACK_FAIL_ASSUME_SAFE
MTL_SHADER_VALIDATION_GPUOPT_MERGE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_USE_LENGTH_ONLY
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_TRIVIAL
MTL_SHADER_VALIDATION_GPUOPT_DEMOTE_GLOBALS_CONSTANTS_TO_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_POINTER_INDIRECTION
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_GLOBALS
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_JUMP_THREADING
MTL_SHADER_VALIDATION_GPUOPT_USE_RELOCATIONS
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_REFELECTION
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_TRAP
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_FUNCTIONS
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_RAY_TRACING
MTL_SHADER_VALIDATION_ABORT_ON_FAULT
MTL_SHADER_VALIDATION_MAX_TRACKED_RESOURCES_MULTIPLIER
Invalid option for %s, valid options are:
com.apple.gpusw.MetalTools
MTLGPUDebugICBSupport
metallib
ICB_Inherit_PSO_Vertex
ICB_Inherit_None_Vertex
ICB_Inherit_Buffers_Vertex
ICB_Inherit_PSO_Kernel
ICB_Inherit_None_Kernel
ICB_Inherit_Buffers_Kernel
ICB_Inherit_Both_Kernel
Faults from argument buffers will not be detected.
Faults from reading global constant variables will not be detected.
%@ -debug-info-kind=line-tables-only
-debug-info-kind=line-tables-only
@"MTLToolsLibrary"8@?0
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v24@?0@"<MTLComputePipelineState>"8@"NSError"16
ciKernelMain
-[MTLToolsDevice unwrapMTLCommandBufferDescriptor:alwaysCopy:]
Incorrect object type in %s: expected %s, found %s
@"MTLToolsDepthStencilState"8@?0
@"MTLToolsSamplerState"8@?0
v24@?0@"<MTLSharedEvent>"8Q16
-[MTLDebugPipelineLibrary newComputePipelineStateWithName:options:reflection:error:]
name must not be nil.
descriptor is not a NSString.
-[MTLDebugPipelineLibrary newRenderPipelineStateWithName:options:reflection:error:]
@"MTLToolsFunctionHandle"8@?0
%@ -> %@
-[MTLDebugIntersectionFunctionTable setPurgeableState:]
-[MTLDebugIntersectionFunctionTable setFunction:atIndex:]
-[MTLDebugIntersectionFunctionTable setFunctions:withRange:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:withRange:]
"version":"
0.908
,"handle":"
,"device":{
"handle":"
,"name":"
,"queue":{
,"events":{
,"methods":[
{"selector":"
,"flags":
,"commands":"
,"commandBufferLength":
,"encoders":[
{"flags":
,"segment":{"location":
,"length":
,"statistics":{"flags":
,"counters":[
{"name":"
],"samples":"
,"sampleBufferLength":
cb_%llu.json
Error saving file '%@' (%@)
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
fillBuffer:range:value
fillBuffer:range:pattern4
fillTexture:level:slice:region:data:size
fillTexture:level:slice:region:color
fillTexture:level:slice:region:color:pixelFormat
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount
copyFromTexture:toTexture
generateMipmapsForTexture
synchronizeResource
synchronizeTexture
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset
resetTextureAccessCounters:region:mipLevel:slice
dispatchThreadgroups:threadsPerThreadgroup
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
setBuffer:offset:atIndex
setBufferOffset:atIndex
setBuffers:offsets:withRange
setBytes:length:atIndex
setComputePipelineState
setSamplerState:atIndex
setSamplerState:lodMinClamps:lodMaxClamps:atIndex
setSamplerStates:withRange
setSamplerStates:lodMinClamps:lodMaxClamps:withRange
setStageInRegion
setTexture:atIndex
setTextures:withRange
setThreadgroupMemoryLength:atIndex
memoryBarrierWithScope
memoryBarrierWithResources:count
drawPrimitives:vertexStart:vertexCount
drawPrimitives:vertexStart:vertexCount:instanceCount
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance
drawPrimitives:indirectBuffer:indirectBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset
drawIndexedPatches:patchStart:patchCount:controlPointIndexBuffer:controlPointIndexBufferOffset:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset
dispatchThreadsPerTile
setBlendColorRed:green:blue:alpha
setColorStoreAction:atIndex
setCullMode
setDepthBias:slopeScale:clamp
setDepthClipMode
setDepthStencilState
setDepthStoreAction
setFragmentBuffer:offset:atIndex
setFragmentBufferOffset:atIndex
setFragmentBuffers:offsets:withRange
setFragmentBytes:length:atIndex
setFragmentSamplerState:atIndex
setFragmentSamplerState:lodMinClamps:lodMaxClamps:atIndex
setFragmentSamplerStates:withRange
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange
setFragmentTexture:atIndex
setFragmentTextures:withRange
setFrontFaceWinding
setRenderPipelineState
setScissorRect
setScissorRects:count
setStencilFrontReferenceValue:backReferenceValue
setStencilReferenceValue
setStencilStoreAction
setTessellationFactorBuffer:offset:instanceStride
setTessellationFactorScale
setTriangleFillMode
setVertexBuffer:offset:atIndex
setVertexBufferOffset:atIndex
setVertexBuffers:offsets:withRange
setVertexBytes:length:atIndex
setVertexSamplerState:atIndex
setVertexSamplerState:lodMinClamps:lodMaxClamps:atIndex
setVertexSamplerStates:withRange
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange
setVertexTexture:atIndex
setVertexTextures:withRange
setTileBuffer:offset:atIndex
setTileBufferOffset:atIndex
setTileBuffers:offsets:withRange
setTileBytes:length:atIndex
setTileSamplerState:atIndex
setTileSamplerState:lodMinClamps:lodMaxClamps:atIndex
setTileSamplerStates:withRange
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange
setTileTexture:atIndex
setTileTextures:withRange
setViewport
setViewports:count
setVisibilityResultMode:offset
textureBarrier
memoryBarrierWithScope:afterStages:beforeStages
memoryBarrierWithResources:count:afterStages:beforeStages
setVisibleFunctionTable:atBufferIndex
setVisibleFunctionTables:withBufferRange
setIntersectionFunctionTable:atBufferIndex
setIntersectionFunctionTables:withBufferRange
insertDebugSignpost
pushDebugGroup
popDebugGroup
setLabel
updateFence
updateFence:afterStages
useHeap
useHeap:stages
useHeaps:count
useHeaps:count:stages
useResource:usage
useResource:usage:stages
useResources:count:usage
useResources:count:usage:stages
waitForFence
waitForFence:beforeStages
updateTextureMapping:mode:regions:mipLevel:slice
updateTextureMappings:mode:regions:mipLevels:numRegions:slices
updateTextureMappings:mode:indirectBuffer:indirectBufferOffset
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
%llu
-[MTLToolsResource validateCPUReadable]
resourceOptions (0x%lx) specify MTLResourceStorageModePrivate, which is not CPU accessible.
resourceOptions (0x%lx) specify MTLStorageModeMemoryless, which is not CPU accessible.
-[MTLToolsResource validateCPUWriteable]
%@:%@
v20@?0^I8I16
-[MTLDebugBlitCommandEncoder dealloc]
Command encoder released without endEncoding.
-[MTLDebugBlitCommandEncoder internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Encoder Copy From Texture Validation
the combination of MTLBlitOptionDepthFromDepthStencil and MTLBlitOptionStencilFromDepthStencil is invalid.
invalid usage because encoding has ended.
sourceTexture must not be nil.
sourceTexture is not a MTLTexture.
sourceTexture is associated with a different device
sourceTexture is Memoryless and cannot be used for copy operations!
destinationTexture must not be nil.
destinationTexture is not a MTLTexture.
destinationTexture is associated with a different device
destinationTexture is Memoryless and cannot be used for copy operations!
(sourceSize.width(%lu) * sourceSize.height(%lu) * sourceSize.depth(%lu))(%lu) must not be 0.
sourceTexture != nil
destinationTexture != nil
Copy From Texture Validation
[sourceTexture pixelFormat](%s) and [destinationTexture pixelFormat](%s) are not compatible for depth/stencil blits.
[sourceTexture pixelFormat](%s) must be compatible with [destinationTexture pixelFormat](%s).
[sourceTexture sampleCount](%lu) must equal [destinationTexture sampleCount](%lu).
sourceTexture must not be a framebufferOnly texture.
destinationTexture must not be a framebufferOnly texture.
sourceLevel(%lu) must be < [sourceTexture mipmapLevelCount](%lu).
sourceSlice(%lu) must be < (%lu).
destinationLevel(%lu) must be < [destinationTexture mipmapLevelCount](%lu).
destinationSlice(%lu) must be < (%lu).
(sourceOrigin.x + adjustedSourceSize.width)(%lu) must be <= paddedWidth(%lu).
(sourceOrigin.y + adjustedSourceSize.height)(%lu) must be <= paddedHeight(%lu).
(sourceOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(sourceOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(sourceOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(sourceOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
(destinationOrigin.x + adjustedDestinationSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedDestinationSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + destinationSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + destinationSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + destinationSize.depth)(%lu) must be <= depth(%lu).
sourceOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
sourceOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
sourceOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
size.width(%lu) must be a multiple of %s blockWidth(%lu).
size.height(%lu) must be a multiple of %s blockHeight(%lu).
size.depth(%lu) must be a multiple of %s blockDepth(%lu).
destinationOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
destinationOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
destinationOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
sourceOrigin.x must be 0 (full image) for %s.
sourceOrigin.y must be 0 (full image) for %s.
sourceOrigin.z must be 0 (full image) for %s.
sourceSize.width(%lu) must equal width(%lu) (full image) for %s.
sourceSize.height(%lu) must equal height(%lu) (full image) for %s.
sourceSize.depth(%lu) must equal depth(%lu) (full image) for %s.
destinationOrigin.x must be 0 (full image) for %s.
destinationOrigin.y must be 0 (full image) for %s.
destinationOrigin.z must be 0 (full image) for %s.
destinationSize.width(%lu) must equal width(%lu) (full image) for %s.
destinationSize.height(%lu) must equal height(%lu) (full image) for %s.
destinationSize.depth(%lu) must equal depth(%lu) (full image) for %s.
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s and destinationTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for destinationTexture with pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Copy From Buffer Validation
sourceBuffer must not be nil.
sourceBuffer is not a MTLBuffer.
sourceBuffer is associated with a different device
destinationTexture cannot be Memoryless.
(destinationOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
sourceOffset (%lu) must be a multiple of %lu bytes.
%s disallowed unless MTLBlitOptionRowLinearPVRTC option is used.
%s is not allowed to use the MTLBlitOptionRowLinearPVRTC option.
sourceBytesPerRow(%lu) must be >= (%lu).
sourceBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [sourceBuffer length](%lu).
sourceBytesPerRow (%lu) must be a multiple of %lu bytes.
sourceBytesPerImage (%lu) must be a multiple of %lu bytes.
sourceBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
blits between texture with pixel format %s and buffer are not allowed.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
destinationBuffer must not be nil.
destinationBuffer is not a MTLBuffer.
destinationBuffer is associated with a different device
destinationOffset (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be >= (%lu).
destinationBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [destinationBuffer length](%lu).
destinationBytesPerRow (%lu) must be a multiple of %lu bytes.
destinationBytesPerImage (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:]
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
-[MTLDebugBlitCommandEncoder generateMipmapsForTexture:]
Generate Mipmaps For Texture Validation
tex must not be nil.
tex is not a MTLTexture.
tex is associated with a different device
cannot generate mipmaps of Memoryless texture.
[tex mipmapLevelCount](%lu) must be > 1.
tex(%s) is not colorRenderable.
tex(%s) is not filterable.
tex != nil
-[MTLDebugBlitCommandEncoder fillBuffer:range:value:]
Fill Buffer Validation
buffer must not be nil.
buffer is not a MTLBuffer.
buffer is associated with a different device
(range.location + range.length)(%lu) must be <= [buffer length](%lu).
range.length(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder fillBuffer:range:pattern4:]
range.location(%lu) must be a multiple of 4 bytes.
range.length(%lu) must be a multiple of 4 bytes.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:]
(sourceOffset + size)(%lu) must be <= [sourceBuffer length](%lu).
(destinationOffset + size)(%lu) must be <= [destinationBuffer length](%lu).
size(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder waitForFence:]
MTLFence cannot be waited on after it has been updated within the same encoder.
-[MTLDebugBlitCommandEncoder endEncoding]
endEncoding without use.
-[MTLDebugBlitCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
firstBatch (%d) must be less than or equal to lastBatch(%d)
-[MTLDebugBlitCommandEncoder getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:]
Get Texture Access Counters Validation
countersBuffer must not be nil.
countersBuffer is not a MTLBuffer.
countersBuffer is associated with a different device
(countersBufferOffset)(%lu) must be < [countersBuffer length](%lu).
Only sparse textures support access counters.
-[MTLDebugBlitCommandEncoder resetTextureAccessCounters:region:mipLevel:slice:]
-[MTLDebugBlitCommandEncoder validateTextureAccess:region:mipLevel:slice:]
Validate Texture Access Validation
slice(%lu) must be lower than arrayLength(%lu)
mipLevel(%lu) must be lower or equal to min(mipmapLevelCount-1,firstMipmapInTail)(%lu)
texture != nil
(region.origin.x + region.width)(%lu) must be <= widthInTiles(%lu).
(region.origin.y + region.height)(%lu) must be <= heightInTiles(%lu).
(region.origin.z + size.depth)(%lu) must be <= depthInTiles(%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:]
Optimize Contents For GPU Access Validation
texture must not be nil.
texture is not a MTLTexture.
texture is associated with a different device
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:slice:level:]
level(%lu) must be < [texture mipmapLevelCount](%lu).
slice(%lu) must be < (%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:]
Optimize Contents For CPU Access Validation
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:slice:level:]
-[MTLDebugBlitCommandEncoder resetCommandsInBuffer:withRange:]
Specified range (loc=%lu, len=%lu) is not inside the command buffer with size %lu.
-[MTLDebugBlitCommandEncoder copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:]
Copy Indirect Command Buffer Validation
source is not a MTLIndirectCommandBuffer.
destination is not a MTLIndirectCommandBuffer.
Specified source range (loc=%lu, len=%lu) is not inside the source command buffer with size %lu.
Specified destination range (loc=%lu, len=%lu) is not inside the destination command buffer with size %lu.
source commandTypes (%lu) are not equal to destination commandTypes (%lu).
source inheritPipelineState (%s) is not equal to destination inheritPipelineState (%s).
source inheritBuffers (%s) is not equal to destination inheritBuffers (%s).
source maxVertexBufferBindCount (%lu) is not equal to destination maxVertexBufferBindCount (%lu).
source maxFragmentBufferBindCount (%lu) is not equal to destination maxFragmentBufferBindCount (%lu).
source maxKernelBufferBindCount (%lu) is not equal to destination maxKernelBufferBindCount (%lu).
source maxObjectBufferBindCount (%lu) is not equal to destination maxObjectBufferBindCount (%lu).
source maxMeshBufferBindCount (%lu) is not equal to destination maxMeshBufferBindCount (%lu).
-[MTLDebugBlitCommandEncoder optimizeIndirectCommandBuffer:withRange:]
Optimize Indirect Command Buffer Validation
Overlapping ranges are not allowed
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:bytes:length:]
Fill Texture Validation
bytes must not be nil.
texture must have a color format, but is %s.
region.origin.x must be 0 (full image) for %s.
region.origin.y must be 0 (full image) for %s.
region.origin.z must be 0 (full image) for %s.
region.size.width(%lu) must equal width(%lu) (full image) for %s.
region.size.height(%lu) must equal height(%lu) (full image) for %s.
region.size.depth(%lu) must equal depth(%lu) (full image) for %s.
buffer length for format %s must be at least %lu, but %lu was specified.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:]
format(%s) must be a color format.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:pixelFormat:]
format(%s) is not compatible with the texture format (%s).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:]
sliceCount must not be 0.
levelCount must not be 0.
sourceTexture.width(%lu) at mip %lu must match destinationTexture.width(%lu) at mip level %lu.
sourceTexture.height(%lu) at mip %lu must match destinationTexture.height(%lu) at mip level %lu.
sourceTexture.depth(%lu) at mip %lu must match destinationTexture.depth(%lu) at mip level %lu.
sourceLevel(%lu) + levelCount(%lu) must not exceed sourceTexture.mipmapLevelCount(%lu).
destinationLevel(%lu) + levelCount(%lu) must not exceed destinationTexture.mipmapLevelCount(%lu).
sourceSlice(%lu) + sliceCount(%lu) must not exceed sourceTexture.arrayLength(%lu) x sourceTexture.numFaces(%lu).
destinationSlice(%lu) + sliceCount(%lu) must not exceed destinationTexture.arrayLength(%lu) x destinationTexture.numFaces(%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:toTexture:]
-[MTLDebugBlitCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
Sample Counters In Buffer Validation
buffer must no be nil
Sample buffer is not a MTLCounterSampleBuffer.
Sample buffer is associated with a different device.
sampleIndex(%lu) must be < sampleCount(%lu).
MTLCounterSamplingPointAtBlitBoundary is not supported.
-[MTLDebugBlitCommandEncoder resolveCounters:inRange:destinationBuffer:destinationOffset:]
Resolve Counters Validation
MTLCounterSampleBuffer must be provided
Destination buffer is not a MTLBuffer.
Destination buffer is associated with a different device.
Destination offset (%llu) must be multiple of minimum constant buffer alignment (%llu).
NSMaxRange(range)(%lu) must be <= sampleCount(%lu).
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:]
Invalidate Compressed Texture Validation
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:slice:level:]
option is not a valid MTLBlitOption.
texture
Blit from %@ has protection options %016llx not set in command buffer protection options %016llx
Blit to %@ with protection options %016llx missing bits set in command buffer protection options %016llx
is illegal on a non-placement heap
is defined on a placement heap only when using a blit method copying entire texture surfaces, or when copying between buffers
is defined on a placement heap only when both textures have the same MTLTextureUsage flags
is defined on a placement heap only when both textures are linear and have the same bufferBytesPerRow value
is defined on a placement heap only when both top-level resources have the same layout
is defined on a placement heap when the texture views refer to the same sub-resources with the same texture type
top-level source and top-level destination resource dimensions must be identical when moving resources inside a placement heap
validateResourceAliasing
blitting between aliasing resources %s.
MTLBlitOptionNone
MTLBlitOptionDepthFromDepthStencil
MTLBlitOptionStencilFromDepthStencil
MTLBlitOptionRowLinearPVRTC
buffer
validateTextureRegion
region.size(%lu, %lu, %lu) must not be empty.
(region.origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(region.origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(region.origin.z + adjustedSize.depth)(%lu) must be <= paddedDepth(%lu).
region.origin.x(%lu) must be a multiple of %s blockWidth(%lu).
region.origin.y(%lu) must be a multiple of %s blockHeight(%lu).
region.origin.z(%lu) must be a multiple of %s blockDepth(%lu).
-[MTLDebugResourceStateCommandEncoder dealloc]
Command encoder released without endEncoding
-[MTLDebugResourceStateCommandEncoder validateSparseTextureMappingMode:]
Invalid mapping mode (%lu)
-[MTLDebugResourceStateCommandEncoder validateTextureAccess:region:mipLevel:slice:]
-[MTLDebugResourceStateCommandEncoder updateTextureMappings:mode:regions:mipLevels:slices:numRegions:]
Cannot update texture mapping: Encoder has ended encoding
Only sparse textures support mapping modifications.
mipLevels[%i](%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:region:mipLevel:slice:]
mipLevel(%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:]
-[MTLDebugResourceStateCommandEncoder moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
Resource State Encoder Validation
Only sparse textures (source) support mapping modifications.
Only sparse textures (destination) support mapping modifications.
The textures must have the same pixel format.
The source and destination texture must be created from the same heap.
destinationLevel(%lu) must be <= [destinationTexture firstMipmapInTail](%lu).
sourceLevel(%lu) must be <= [sourceTexture firstMipmapInTail](%lu).
-[MTLDebugResourceStateCommandEncoder waitForFence:]
-[MTLDebugResourceStateCommandEncoder endEncoding]
Can't end encoding for this encoder, already ended encoding
Ending encoding with no commands encoded.
-[MTLDebugBuffer makeAliasable]
This resource was not allocated on a heap.
-[MTLDebugBuffer newTextureWithDescriptor:offset:bytesPerRow:]
New Texture With Descriptor Validation
descriptor must not be nil.
descriptor is not a MTLTextureDescriptor.
resourceOptions (0x%lx) must match backing buffer resource options (0x%lx).
linear texture depth(%ld) must be 1
linear texture mipmapLevelCount(%ld) must be 1
linear texture sampleCount(%ld) must be 1
linear texture arrayLength(%ld) must be 1
compressionType must be set to lossless for linear textures
compressionFootprint must be set to lossless for linear textures
linear textures cannot be created with usage MTLTextureUsageRenderTarget
-[MTLDebugBuffer newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:]
Texture Descriptor Validation
2D linear texture array is not supported.
bytesPerImage must be aligned to %u bytes.
-[MTLDebugBuffer setPurgeableState:]
validateNewTexture
MTLTextureDescriptor.usage == MTLTextureUsageUnknown.
cannot create Memoryless texture from Buffer.
Textures with compressed pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with depth pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with stencil pixel formats cannot be created from a buffer and must be created as a standalone texture.
bytesPerRow(%lu) must be greater than (width * pixel_bytes)(%lu).
bytesPerRow must be non-zero.
Buffer-backed textures must have a texture type of MTLTextureType2D, MTLTextureTypeTextureBuffer or MTLTextureType2DArray, found %@.
Length required by texture offset, bytes per row, height and array length(%lu) exceed buffer capacity(%lu).
Offset of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found offset(%lu)
BytesPerRow of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found bytesPerRow(%lu)
-[MTLDebugDeadlineProfile validateCommandQueue:]
Deadline Profiles cannot be reused across command queues
-[MTLDebugCommandBuffer dealloc]
MTLCommandBuffer is in an invalid status when being destroyed; is it being over-released?
-[MTLDebugCommandBuffer encodeWaitForEvent:value:]
Standard MTLEvents must signal events on the same device. Use MTLSharedEvent for cross-device events.
-[MTLDebugCommandBuffer encodeWaitForEvent:value:timeout:]
-[MTLDebugCommandBuffer encodeSignalEvent:value:]
-[MTLDebugCommandBuffer waitUntilScheduled]
waitUntilScheduled on uncommitted command buffer
-[MTLDebugCommandBuffer waitUntilCompleted]
waitUntilCompleted on uncommitted command buffer
-[MTLDebugCommandBuffer blitCommandEncoder]
encoding in progress
-[MTLDebugCommandBuffer resourceStateCommandEncoder]
MSAA Resolve is only supported for color, depth, and stencil textures
MTLRenderPassDescriptor resolveTexture is associated with a different device
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1D.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType2DMultisample.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureTypeTextureBuffer.
MTLRenderPassDescriptor resolveTexture must not be Memoryless.
MTLRenderPassDescriptor texture and resolveTexture size mismatch.
PixelFormat %s cannot be a MSAA resolve target
Texture PixelFormat %s does not match Resolve PixelFormat %s
Slice is %lu, but the texture has only %lu slices
mipmap level is %lu, but the texture has only %lu levels
depth plane is %lu, but the texture has a depth of %lu at mip level %lu
resolveTexture sampleCount is %lu, but must be 1
resolveTexture must not be buffer-backed.
_MTLValidateDepthStencilStoreState
%@: mixing %@ and %@ store actions for the depth and stencil render pass attachments is not allowed.
MTLDebugRenderPipeline
MTLDebugRenderCommandEncoder
%@: the stencil attachment resolve filter mode (MTLMultisampleStencilResolveFilterDepthResolvedSample) is not valid because the depth attachment store action (%@) does not contain a resolve.
-[MTLDebugCommandBuffer addCompletedHandler:]
block cannot be nil
-[MTLDebugCommandBuffer addScheduledHandler:]
-[MTLDebugCommandBuffer unwrapMTLRenderPassDescriptor:]
colorAttachment[%lu].loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
depthAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
stencilAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
-[MTLDebugCommandBuffer renderCommandEncoderWithDescriptor:]
RenderCommandEncoder Validation
renderPassDescriptor must not be nil.
renderPassDescriptor is not a MTLRenderPassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoder]
-[MTLDebugCommandBuffer computeCommandEncoderWithDescriptor:]
ComputeCommandEncoder Validation
computePassDescriptor must not be nil.
computePassDescriptor is not a MTLComputePassDescriptor.
-[MTLDebugCommandBuffer blitCommandEncoderWithDescriptor:]
blitPassDescriptor must not be nil.
blitPassDescriptor is not a MTLBlitPassDescriptor.
-[MTLDebugCommandBuffer resourceStateCommandEncoderWithDescriptor:]
resourceStatePassDescriptor must not be nil.
resourceStatePassDescriptor is not a MTLResourceStatePassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoderWithDispatchType:]
-[MTLDebugCommandBuffer parallelRenderCommandEncoderWithDescriptor:]
ParallelRenderCommandEncoder Validation
-[MTLDebugCommandBuffer preCommit]
command buffer references deallocated object which previously existed at address %p.
-[MTLDebugCommandBuffer sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledRenderCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledComputeCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer lockPurgeableObjects]
MTLResource %p (label: %@), referenced in cmd buffer %p (label: %@) is in volatile or empty purgeable state at commit
-[MTLDebugCommandBuffer accelerationStructureCommandEncoder]
-[MTLDebugCommandBuffer accelerationStructureCommandEncoderWithDescriptor:]
Acceleration Structure Command Encoder Validation
accelerationStructurePassDescriptor must not be nil.
accelerationStructurePassDescriptor is not a MTLAccelerationStructurePassDescriptor.
-[MTLDebugCommandBuffer encodeDashboardTagForResourceGroup:]
Streaming Codec SPI
resourceGroup must be non-nil
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:]
dashboard(%llu) is not a valid MTLDashboard value
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:]
-[MTLDebugCommandBuffer commitWithDeadline:]
%s SPI should only be used with Deadline Aware Command Buffers
MTLStoreActionDontCare
MTLStoreActionStore
MTLStoreActionMultisampleResolve
MTLStoreActionStoreAndMultisampleResolve
MTLStoreActionUnknown
validateRenderPassDescriptor
RenderPass Descriptor Validation
not a MTLDebugTexture.
Texture at colorAttachment[%lu] has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions at color attachment %i includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
Attachment %u overlaps with attachment %u
MTLRenderPassDescriptor render targets have inconsistent sample counts.
Mixing MTLTextureType3D with other attachment types is not allowed when renderTargetArrayLength is not zero
This set of render targets requires %lu bytes of pixel storage. This device supports %lu bytes.
Texture at depthAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on the depth attachment includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
This render pass descriptor's clear depth (%f) is outside of the range [0..1]
Texture at stencilAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
rasterizationRateMap must be an MTLRasterizationRateMap instance.
rasterizationRateMap.device must match the current device.
renderTargetWidth (%lu) must be <= rasterizationRateMap.screenSize.width (%lu).
renderTargetHeight (%lu) must be <= rasterizationRateMap.screenSize.height (%lu).
renderTargetArrayLength (%lu) must be <= rasterizationRateMap.layerCount (%lu).
maximum physical rendering width (%lu) must be <= minimum attachment width (%lu).
maximum physical rendering height (%lu) must be <= minimum attachment height (%lu).
renderTargetWidth (%lu) must be <= minimum attachment width (%lu).
renderTargetHeight (%lu) must be <= minimum attachment height (%lu).
No rendertargets set in RenderPassDescriptor.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's renderTarget{Width|Height} properties to nonzero values.
Sparse textures are not supported as depth attachments on this device
Sparse textures are not supported as stencil attachments on this device
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must have a combined depth+stencil pixel format.
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must be the same depth and stencil texture.
When depth and stencil are used together, the render pass has to write to the same level and slice for both.
When depth and stencil are used together, the resolve texture for the depth and stencil render pass attachments must be the same depth and stencil texture.
When both depth (%lu x %lu) and stencil (%lu x %lu) are used from separate textures, they must have identical dimensions.
defaultColorSampleCount (%lu) is not supported by device.
defaultRasterSampleCount (%lu) is not supported by device.
no sampleCount for color and raster available, either set defaultColorSampleCount or set defaultRasterSampleCount or set appropriate attachments
unexpected color and depth/stencil sample counts
defaultColorSampleCount should be zero.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's defaultRasterSampleCount property to a nonzero value.
defaultRasterSampleCount should be zero.
Per sample storage cannot be greater than 64B
Per pixel storage cannot be greater than 256B
Total allocated thread group memory (%lu) cannot be greater than (%lu)
4X MSAA does not support 32 x 32 tiles
MTLRenderPassDescriptor visibilityResultBuffer is associated with a different device
%lu custom sample positions were programmed, but this render pass uses %lu rasterizer sample(s). These counts must match.
startOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
startOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfFragmentSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfFragmentSampleIndex must be MTLCounterDontSample
MTLRenderPassAttachmentDescriptor texture is associated with a different device
Memoryless attachment need to be Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
Memoryless attachment cannot be loaded as it have no memory to load from.
Memoryless attachment content cannot be stored in memory.
PixelFormat %s at color attachment %lu is not color renderable
PixelFormat %s is not depth renderable
PixelFormat %s is not stencil renderable
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1D.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1DArray.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureTypeTextureBuffer.
Slice is %lu, but the texture at attachment %lu has only %lu slices
mipmap level is %lu, but the texture at attachment %lu has only %lu levels
depth plane index is %lu, but the texture has a depth of %lu at mip level %lu
depth plane + renderTargetArrayLength is %lu, but the texture has a depth of %lu at mip level %lu.
slice + renderTargetArrayLength is %lu, but the texture only has %lu slices.
MTLRenderPassAttachmentDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action at attachment %lu requires resolve texture
MTLRenderPassAttachmentDescriptor %s depth resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor MTLMultisampleStencilResolveFilterDepthResolvedSample stencil resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor texture at attachment %lu must not be buffer-backed.
MTLRenderPassAttachmentDescriptor resolveTexture must have storeAction of MTLStoreActionMultisampleResolve, MTLStoreActionStoreAndMultisampleResolve or MTLStoreActionUnknown
MTLRenderPassAttachmentDescriptor texture must be MTLTextureType2DMultisample or MTLTextureType2DMultisampleArray when using a resolveTexture.
texture sampleCount is %lu, but must be > 1 when using a resolveTexture
the depth attachment
the stencil attachment
color attachment %lu
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, but Programmable Sample Positions is not supported on this device.
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, which does not apply to the store action (%@).
MTLMultisampleDepthResolveFilterSample0
MTLMultisampleDepthResolveFilterMin
MTLMultisampleDepthResolveFilterMax
validateTileDimensions
Invalid tile dimensions (%lu, %lu)
startOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfEncoderSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfEncoderSampleIndex must be MTLCounterDontSample
validateStoreLoadTransition
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. The results are undefined.
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. This is perfectly valid transition but it will result in reduced performance.
MTLLoadActionDontCare
MTLLoadActionLoad
MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES
-[MTLDebugDynamicLibrary serializeToURL:error:]
url must not be nil.
url must be a file URL.
-[MTLDebugDynamicLibrary serializeToURL:options:error:]
-[MTLDebugCounterSampleBuffer resolveCounterRange:]
NSMaxRange(indexRange)(%lu) must be <= sampleCount(%lu).
CPU access not allowed for sample buffers with MTLResourceStorageModePrivate.
-[MTLDebugBinaryArchive addComputePipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLComputePipelineDescriptor object.
descriptor.computeFunction must not be nil.
Linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLRenderPipelineDescriptor object.
Vertex linked functions cannot be added to this archive.
Fragment linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addMeshRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLMeshRenderPipelineDescriptor object.
Object linked functions cannot be added to this archive.
Mesh linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addTileRenderPipelineFunctionsWithDescriptor:options:error:]
device does not support tile shaders
descriptor is not a MTLTileRenderPipelineDescriptor object.
-[MTLDebugBinaryArchive serializeToURL:error:]
-[MTLDebugBinaryArchive serializeToURL:options:error:]
MTL_COUNTERS_LAYER_API_TIMING
-[MTLDebugCommandQueue insertDebugCaptureBoundary]
InsertDebugCaptureBoundary should not be called inside the completion handler
-[MTLDebugCommandQueue validateDeadlineAwareness:]
All commandBuffers from this commandQueue must have a deadlineProfile associated with it
Only MTLCommandQueues with MTLGPUPriorityRealTime can contain a deadline profile
-[MTLDebugComputeCommandEncoder dealloc]
computePipelineState =
<null>
Set Buffers:
Buffer %lu:
Set Textures:
Texture %lu:
Set Samplers:
Sampler %lu:
Set ThreadgroupMemoryLengths:
Threadgroup %lu:
Image Block Size: %lu x %lu
-[MTLDebugComputeCommandEncoder setComputePipelineState:]
computePipelineState must not be nil.
computePipelineState is not a MTLComputePipelineState.
computePipelineState is associated with a different device
redundant setComputePipelineState.
previous setComputePipelineState was unused.
-[MTLDebugComputeCommandEncoder setBytes:length:atIndex:]
length(%lu) must be <= %lu.
-[MTLDebugComputeCommandEncoder setBuffer:offset:atIndex:]
offset(%lu) must be < [buffer length](%lu).
offset(%lu) must be 0.
-[MTLDebugComputeCommandEncoder setBufferOffset:atIndex:]
index(%lu) must have an existing buffer.
-[MTLDebugComputeCommandEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an MTLBuffer.
buffers[%lu] is associated with a different device
offset[%lu](%lu) must be < [buffers[%lu] length](%lu).
offsets[%lu](%lu) must be 0.
-[MTLDebugComputeCommandEncoder setTexture:atIndex:]
frameBufferOnly texture not supported for compute.
Memoryless texture not supported for compute.
-[MTLDebugComputeCommandEncoder setTextures:withRange:]
textures[%lu] is not an MTLTexture.
textures[%lu] is associated with a different device
frameBufferOnly textures[%lu] not supported for compute.
textures[%lu] is Memoryless and cannot be assigned.
-[MTLDebugComputeCommandEncoder setSamplerState:atIndex:]
sampler is not a MTLSamplerState.
sampler is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerStates:withRange:]
samplers[%lu] is not an MTLSamplerState.
samplers[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugComputeCommandEncoder setSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugComputeCommandEncoder setThreadgroupMemoryLength:atIndex:]
length(%lu) must be a multiple of %lu bytes.
-[MTLDebugComputeCommandEncoder setImageblockWidth:height:]
width(%lu) must be a power of 2.
height(%lu) must be a power of 2.
width(%lu)*height(%lu) must be less than or equal to 1024
-[MTLDebugComputeCommandEncoder validateStageInRegion:]
stage_in region (width(%lu) * height(%lu) * depth(%lu))(%lu) must not be 0.
stage_in region (width)(%lu) must be <= width(%lu).
stage_in region (height)(%lu) must be <= height(%lu).
stage_in region (depth)(%lu) must be <= depth(%lu).
-[MTLDebugComputeCommandEncoder setStageInRegionWithIndirectBuffer:indirectBufferOffset:]
indirectBufferOffset (%lu) must be a multiple of 4
-[MTLDebugComputeCommandEncoder _validateThreadsPerThreadgroup:]
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must not be 0.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (device threadgroup size limit)
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (kernel threadgroup size limit)
threadsPerThreadgroup.width(%lu) must be <= %lu.
threadsPerThreadgroup.height(%lu) must be <= %lu.
threadsPerThreadgroup.depth(%lu) must be <= %lu.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be multiples of %lu.
-[MTLDebugComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:]
threadgroupsPerGrid.width(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.height(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadgroupsPerGrid.width(%lu) * threadgroupsPerGrid.y(%lu) * threadgroupsPerGrid.depth(%lu))(%lu) must not be 0.
Compute
stage_in region was not set for compute pipeline
-[MTLDebugComputeCommandEncoder dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:]
indirectBuffer must not be nil.
indirectBuffer is not a MTLBuffer.
indirectBuffer is associated with a different device
(indirectBufferOffset + sizeof(MTLDispatchThreadgroupsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
indirectBufferOffset(%lu) must be a multiple of 4 bytes.
-[MTLDebugComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:]
threadsPerGrid.width(%lu) must be <= UINT32_MAX.
threadsPerGrid.height(%lu) must be <= UINT32_MAX.
threadsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadsPerGrid.width(%lu) * threadsPerGrid.y(%lu) * threadsPerGrid.depth(%lu))(%lu) must not be 0.
-[MTLDebugComputeCommandEncoder dispatchThreadsWithIndirectBuffer:indirectBufferOffset:]
(indirectBufferOffset + sizeof(MTLDispatchThreadsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
-[MTLDebugComputeCommandEncoder waitForFence:]
-[MTLDebugComputeCommandEncoder endEncoding_private]
endEncoding without dispatchThreadgroups.
-[MTLDebugComputeCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
MTLVisibleFunctionTable
MTLIntersectionFunctionTable
-[MTLDebugComputeCommandEncoder useResource:usage:]
resource should not be nil
usage (0x%lx) has an invalid value
useResource:usage:
-[MTLDebugComputeCommandEncoder useResources:count:usage:]
resource (at index: %lu) should not be nil
useResources:count:usage: (index = %lu)
-[MTLDebugComputeCommandEncoder useHeap:]
heap should not be nil
-[MTLDebugComputeCommandEncoder useHeaps:count:]
heap (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder memoryBarrierWithScope:]
scope (0x%lx) has an invalid value for compute
compute memoryBarrierWithScope is not supported on this device
-[MTLDebugComputeCommandEncoder memoryBarrierWithResources:count:]
resources should not be nil or empty array
compute memoryBarrierWithResources is not supported on this device
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:withRange:]
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the compute pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugComputeCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDispatchBoundary is not supported.
-[MTLDebugComputeCommandEncoder setAccelerationStructure:atBufferIndex:]
Acceleration structure
-[MTLDebugComputeCommandEncoder setVisibleFunctionTable:atBufferIndex:]
functionTable is not a MTLVisibleFunctionTable.
functionTable is associated with a different device
-[MTLDebugComputeCommandEncoder setVisibleFunctionTables:withBufferRange:]
visibleFunctionTables[%lu] is not a MTLVisibleFunctionTable.
visibleFunctionTables[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTable:atBufferIndex:]
functionTable is not a MTLIntersectionFunctionTable.
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTables:withBufferRange:]
intersectionFunctionTables[%lu] is not a MTLIntersectionFunctionTable.
intersectionFunctionTables[%lu] is associated with a different device
validateArg
unused binding in encoder at %s index %lu.
sampler
threadgroupMemory
visibleFunctionTable
primitiveAccelerationStructure
instanceAccelerationStructure
intersectionFunctionTable
MTLDebugFunctionArgumentInit
redundant setting of %@.
thread_position_in_grid
threads_per_grid
thread_position_in_threadgroup
thread_index_in_threadgroup
threads_per_threadgroup
threadgroup_position_in_grid
threadgroups_per_grid
validateBuiltinArguments
Invalid built-in argument %@
component %lu: %llu must be <= %llu for %@ [[ %@ ]]
validateComputeFunctionArguments
%@ Function(%@): missing %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu].
%@ Function(%@): the offset into the buffer %@ that is bound at %s index %lu must be a multiple of %lu but was set to %lu.
%@ Function(%@): argument %@[%lu] from %s(%lu) with offset(%lu) and length(%lu) has space for %lu bytes, but argument has a length(%lu).
%@ Function(%@): Read-only bytes are being bound at index %lu to a shader argument with write access enabled (did you mean to use const or constant in the shader?).
%@ Function(%@): Reading from buffer bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to buffer bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): threadgroupMemoryLength(%lu) must be >= %lu at %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect type of texture (%@) bound at %s binding at index %lu (expect %@) for %@[%lu].
%@ Function(%@): Non-writeable texture format %s is being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): A sparse texture is being bound at index %lu to a shader argument with write access enabled. Sparse textures do not support writes from shaders.
%@ Function(%@): The pixel format (%s) of the %s (name:%@) bound at index %lu is incompatible with the data type (%@) of the %s parameter (%@ [[%s(%lu)]]). %s is compatible with the data type(s) %@.
%@ Function(%@): reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
%@ Function(%@): Shader uses texture(%@[%lu]) as read-write, but hardware does not support read-write texture of this pixel format.
%@ Function(%@): Reading from texture bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to texture bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu] - found %@.
Functon(%@): total used threadgroupMemoryLength(%lu) must be <= %lu.
validateTableStage
%@ called with a %s resource created for stage %@ rather than Compute
checkBuffer
%@ is not an MTLBuffer.
%@ is associated with a different device
%@ offset (%lu) must be < %@ length (%lu).
%@ must not be nil
%@ offset (%lu) must be 0.
checkAccelerationStructure
%@ is not an MTLAccelerationStructure.
checkMotionParameter
Acceleration descriptor is using primitive motion blur which is not supported by the device.
Primitive motion start time (%f) must be before or at the same time with motion end time (%f)
primitiveDataBuffer
checkPrimitiveData
primitiveDataElementSize must be non-zero
primitiveDataElementSize (%lu) cannot be larger than primitiveDataStride (%lu)
primitiveDataBufferOffset (%lu) exceeds primitiveDataBuffer.length (%lu)
primitiveDataBuffer.length (%lu) is not large enough to contain %lu primitives with primitiveDataBufferOffset (%lu), primitiveDataStride (%lu), and primitiveDataElementSize (%lu).
primitiveDataBufferOffset requires 4 byte alignment, found offset %lu.
primitiveDataStride requires 4 byte alignment, found offset %lu.
checkAccelerationStructureDescriptorWithRefitOptions
Number of geometry descriptors (%lu) must be less than 2^30
Number of geometry descriptors (%lu) must be less than 2^24
All geometry descriptors in a primitive acceleration structure descriptor must be the same type
Geometry descriptor intersection function table offset (%lu) must be less than 2^24
vertex buffer
Vertex buffer offset (%lu) must be a multiple of %lu bytes
index buffer
Index buffer offset (%lu) must be a multiple of the index data type stride (%lu)
Number of indices to read (triangle count multiplied by 3) (%lu) times index stride (%lu) plus index buffer offset (%lu) must be less than or equal to index buffer length (%lu)
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) must be less than or equal to vertex buffer length (%lu)
Motion keyframe count (%lu) must match vertexBuffers count (%lu)
Vertex buffer offset (%lu) in keyframe data must be a multiple of %lu bytes
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) in keyframe data must be less than or equal to vertex buffer length (%lu)
Bounding box stride (%lu) must be at least %lu bytes
Bounding box stride (%lu) must be a multiple of %lu bytes
bounding box buffer
Bounding box buffer offset (%lu) must be a multiple of %lu bytes
Bounding box buffer size (%lu) must be at least the bounding box buffer offset (%lu) plus the bounding box stride (%lu) times the number of bounding boxes (%lu)
Motion keyframe count (%lu) must match boundingBoxBuffers count (%lu)
Geometry descriptor must be a MTLAccelerationStructureTriangleGeometryDescriptor, a MTLAccelerationStructureMotionTriangleGeometryDescriptor, a MTLAccelerationStructureBoundingBoxGeometryDescriptor or a MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor
Number of primitives (%lu) must be less than 2^30
Number of primitives (%lu) must be less than 2^28
Number of instances (%lu) must be less than 2^30
Number of instances (%lu) must be less than 2^24
Instance descriptor type (%lu) is not a valid MTLAccelerationStructureInstanceDescriptorType
Instance descriptor stride (%lu) must be at least %lu bytes
Instance descriptor stride (%lu) must be a multiple of %lu bytes
instance descriptor buffer
Instance descriptor buffer offset (%lu) must be a multiple of %lu bytes
Instance descriptor buffer size (%lu) must be at least the instance descriptor buffer offset (%lu) plus the instance descriptor stride (%lu) times the number of instances (%lu)
Instanced acceleration structure
Must have at least 1 instanced acceleration structure if instance count > 0
Acceleration structure descriptor must be a MTLPrimitiveAccelerationStructureDescriptor or a MTLInstanceAccelerationStructureDescriptor
Acceleration structure descriptor must not be nil
-[MTLDebugAccelerationStructureCommandEncoder buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:]
Cannot build acceleration structure because encoder has ended encoding
Scratch buffer
Acceleration structure size (%lu) must be at least %lu bytes
Scratch buffer size (%lu) must be at least scratch buffer offset (%lu) plus required scratch buffer size (%lu)
-[MTLDebugAccelerationStructureCommandEncoder validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:]
Cannot refit acceleration structure because encoder has ended encoding
No options specified on refit
Source acceleration structure
Destination acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder copyAccelerationStructure:toAccelerationStructure:]
Cannot copy acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:]
Cannot write compacted acceleration structure because encoder has ended encoding
Size buffer
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:]
sizeDataType must be MTLDataTypeUInt or MTLDataTypeULong
-[MTLDebugAccelerationStructureCommandEncoder copyAndCompactAccelerationStructure:toAccelerationStructure:]
Cannot copy and compact acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:]
Cannot write serialized acceleration structure size because encoder has ended encoding
The size buffer is not big enough to hold the size (64 bits required)
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:]
Cannot write deserialized acceleration structure size because encoder has ended encoding
Serialized acceleration structure buffer
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:]
Cannot write deserialized primitive acceleration structure sizes because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:]
serializePrimitiveAccelerationStructure validation
Cannot serialize acceleration structure because encoder has ended encoding
Buffer
-[MTLDebugAccelerationStructureCommandEncoder serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:]
serializeInstanceAccelerationStructure validation
Primitive acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:]
deserializePrimitiveAccelerationStructure validation
Cannot deserialize acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
deserializeInstanceAccelerationStructure validation
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder serializeAccelerationStructure:toBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:]
Cannot write geometry size of acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:]
Cannot write geometry of acceleration structure because encoder has ended encoding
Geometry buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:into:]
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:into:]
Header buffer
Inner node buffer
Leaf node buffer
Primitive buffer
Instance transform buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:]
Sizes buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeAccelerationStructureSerializationData:toBuffer:offset:]
Output buffer
MTLAccelerationStructureSerializationData exceeds end of buffer from offset (%lu) with length (%lu).
Buffer requires 4 byte alignment, found offset %lu.
validateVertexFormatAndStride
Single component vertex formats are not supported
Vertex stride (%lu) must be at least %lu bytes
Vertex stride (%lu) must be a multiple of %lu bytes
Transformation buffer
validateTransformationBuffer
MTLPackedFloat4x3 exceeds end of transformation buffer from offset (%lu) with length (%lu).
Transformation buffer requires 4 byte alignment, found offset %lu.
None
Vertex
Fragment
Tile
Object
Mesh
-[MTLDebugComputePipelineState functionHandleWithFunction:]
function must not be nil.
function is not a MTLFunction.
-[MTLDebugComputePipelineState newComputePipelineStateWithAdditionalBinaryFunctions:error:]
Pipeline state is adding functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding functions which is not supported by the device
Function '%s' was found in functions array but is not precompiled.
Unable to create new compute pipeline state with additional binary functions: %@
-[MTLDebugComputePipelineState newVisibleFunctionTableWithDescriptor:]
descriptor is not a MTLVisibleFunctionTableDescriptor.
-[MTLDebugComputePipelineState newIntersectionFunctionTableWithDescriptor:]
descriptor is not a MTLIntersectionFunctionTableDescriptor.
-[MTLDebugComputePipelineState validateHandleForSetFunction:]
The function handle for function '%s' was not created from the pipeline state that created this MTLVisibleFunctionTable.
-[MTLDebugIndirectCommandBuffer indirectRenderCommandAtIndex:]
Indirect Command Buffer Validation
CPU access for MTLIndirectCommandBuffer with MTLResourceStorageModePrivate storage mode is disallowed.
MTLIndirectCommandBuffer created without any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectRenderCommands 
The requested command (%lu) is greater than the indirect command buffer size (%lu)
-[MTLDebugIndirectCommandBuffer indirectComputeCommandAtIndex:]
MTLIndirectCommandBuffer created with any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectComputeCommands 
-[MTLDebugIndirectCommandBuffer setPurgeableState:]
-[MTLDebugIndirectCommandBuffer resetWithRange:]
MTL_XML_DUMP_COUNTERS
MTL_XML_SYNC_BEFORE_SAMPLE
MTL_XML_TRACE_PATH
xml_trace_%p
Error creating directory '%@' (%@)
MTL_XML_COUNTER_NAMES
MTLStat_nSec
Unsupported counter: %@
Failed to request counters
Index %u does not match any member of the argument buffer
Index %u does not correspond to any valid member of the argument buffer
Trying to set a %@ at index %u but the argument buffer has a %@ at this index
index range (%lu, %lu) has indices that are outside of the valid index range [%u, %u]
index (%lu) is outside of the valid index range [%u, %u]
-[MTLDebugArgumentEncoder setArgumentBuffer:startOffset:elementIndex:]
Argument Buffer Validation
buffer is not a MTLBuffer
buffer storage mode (%@) should be MTLStorageModeShared
offset (%lu) + encodedLength (%lu) should be smaller or equal to the buffer length (%lu)
-[MTLDebugArgumentEncoder setBuffer:offset:atIndex:]
No argument buffer is set
buffer is not a valid MTLBuffer
offset (%lu) should be smaller than the buffer length (%lu)
offset(%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an valid MTLBuffer.
offsets[%lu](%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setTexture:atIndex:]
-[MTLDebugArgumentEncoder setTextures:withRange:]
-[MTLDebugArgumentEncoder setSamplerState:atIndex:]
Sampler state did not have supportArgumentBuffers flag set on creation, but is used with argument buffers
-[MTLDebugArgumentEncoder setSamplerStates:withRange:]
-[MTLDebugArgumentEncoder constantDataAtIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineState:atIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineStates:withRange:]
-[MTLDebugArgumentEncoder setComputePipelineState:atIndex:]
-[MTLDebugArgumentEncoder setComputePipelineStates:withRange:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffer:atIndex:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffers:withRange:]
-[MTLDebugArgumentEncoder newArgumentEncoderForBufferAtIndex:]
No argument buffer at that index
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withRange:]
Constant
Texture
Sampler
Struct
RenderPipelineState
ComputePipelineState
IndirectCommandBuffer
VisibleFunctionTable
IntersectionFunctionTable
PrimitiveAccelerationStructure
InstanceAccelerationStructure
METAL_COMPLAIN_ABOUT_SLOPPY_TEXTURE_USAGE
MTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS
MTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS
-[MTLDebugDevice heapTextureSizeAndAlignWithDescriptor:]
-[MTLDebugDevice newHeapWithDescriptor:]
New Heap With Descriptor Validation
Sparse heaps are not supported on this device
Heap needs to have a size.
Requested storage mode is not allowed for Heaps.
Requested CPU cache mode is not allowed for Heaps.
Requested hazard tracking mode is not allowed for Heaps.
Storage mode must be MTLStorageModePrivate for heap type MTLHeapTypeSparse
Memoryless texture need to have renderable PixelFormat.
Memoryless texture need to be of type Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
options 0x%lx conveys invalid cpuCacheMode of 0x%lx
IOSurface textures must use MTLStorageModeShared
MTLStorageModeShared not allowed for textures
MTLStorageModeMemoryless can only be used with textures
MTLStorageModeMemoryless is not supported on this device
Illegal MTLStorageMode 0x%lx
options 0x%lx conveys invalid hazardTrackingMode of 0x%lx
MTLResourceOptions options has unknown bits 0x%lx.
Cannot create buffer of zero length.
newBufferWith*:length 0x%lx must not exceed %llu MB.
-[MTLDebugDevice newBufferWithLength:options:]
Buffer Validation
-[MTLDebugDevice newBufferWithBytes:length:options:]
storageModePrivate incompatible with ...WithBytes variant of newBuffer
newBufferWithBytes:pointer must not be nil.
-[MTLDebugDevice newBufferWithBytesNoCopy:length:options:deallocator:]
storageModePrivate incompatible with ...WithBytesNoCopy variant of newBuffer
newBufferWithBytesNoCopy:pointer must not be nil.
newBufferWithBytesNoCopy:pointer %p is not %d byte aligned.
newBufferWithBytesNoCopy:length 0x%lx is not %d byte aligned.
-[MTLDebugDevice newBufferWithDescriptor:]
MTLResourceStorageModeShared should be used with noCopy=YES or contents being set
contents must not be nil when noCopy is set to YES
MTLBufferDescriptor.contents %p is not %d byte aligned.
MTLBufferDescriptor.length 0x%lx is not multiple of %d.
-[MTLDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
maximum vertex buffer bind count (%lu) must be <= %lu.
maximum fragment buffer bind count (%lu) must be <= %lu.
maximum kernel buffer bind count (%lu) must be <= %lu.
-[MTLDebugDevice newArgumentEncoderWithArguments:]
arguments cannot be nil
arguments must have at least one element
-[MTLDebugDevice newTextureWithBytesNoCopy:length:descriptor:deallocator:]
MTLResourceStorageModeShared must be used.
newTextureWithBytesNoCopy:pointer must not be nil.
newTextureWithBytesNoCopy:pointer %p is not %d byte aligned.
-[MTLDebugDevice newDepthStencilStateWithDescriptor:]
descriptor is not a MTLDepthStencilDescriptor.
texture buffer width (%llu) must be less than %llu
texture buffer height (%llu) must be 1
texture buffer depth (%llu) must be 1
texture buffer mipmapLevelCount (%llu) must be 1
texture buffer sampleCount (%llu) must be 1
texture buffer arrayLength (%llu) must be 1
usage must be set
MTLTextureUsageRenderTarget is not valid for a texture buffer
Texture buffer usage must contain read or write
texture buffer with pixel format (%s) cannot be written to from a shader
pixel format (%s) cannot be written to from a shader on this device
pixel format (%s) cannot be used for a texture buffer
-[MTLDebugDevice newTextureWithDescriptor:]
Cannot use an Xn format when creating a new texture
-[MTLDebugDevice newSamplerStateWithDescriptor:]
descriptor is not a MTLSamplerDescriptor.
-[MTLDebugDevice newBinaryArchiveWithDescriptor:error:]
Binary Archive with Descriptor Validation
descriptor is not a MTLBinaryArchiveDescriptor object.
url, if not nil, must be a file URL.
-[MTLDebugDevice newBinaryLibraryWithOptions:url:error:]
-[MTLDebugDevice newDynamicLibraryWithURL:options:error:]
Dynamic Library with URL Validation
device does not support dynamic libraries
-[MTLDebugDevice newDynamicLibrary:computeDescriptor:error:]
Dynamic Library Validation
library must not be nil.
library is not a MTLLibrary object.
-[MTLDebugDevice newDynamicLibrary:error:]
-[MTLDebugDevice loadDynamicLibrariesForComputeDescriptor:options:error:]
-[MTLDebugDevice loadDynamicLibrariesForFunction:insertLibraries:options:error:]
insertLibaries must not be nil.
-[MTLDebugDevice validateDynamicLibrary:state:error:]
-[MTLDebugDevice validateDynamicLibraryURL:error:]
Pipeline descriptor is using MTLLinkedFunctions functions which is not supported by the device.
Function '%s' in group '%s' was not found in functions array.
Pipeline descriptor is using MTLLinkedFunctions groups which is not supported by the device.
Pipeline descriptor is using MTLLinkedFunctions %@ which is not supported by the device.
Function '%s' was found in %@ array but is not precompiled.
functions
privateFunctions
binaryFunctions
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:reflection:error:]
Render Pipeline State Descriptor Validation
descriptor is not a MTLRenderPipelineDescriptor.
vertexPreloadedLibraries is not empty but device does not support render dynamic libraries
fragmentPreloadedLibraries is not empty but device does not support render dynamic libraries
objectPreloadedLibraries is not empty but device does not support render dynamic libraries
meshPreloadedLibraries is not empty but device does not support render dynamic libraries
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:reflection:error:]
Compute Pipeline State Descriptor Validation
descriptor is not a MTLComputePipelineDescriptor.
preloadedLibraries is not empty but device does not support dynamic libraries
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:reflection:error:]
Tile Render Pipeline State Descriptor Validation
descriptor is not a MTLTileRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:reflection:error:]
Mesh Pipeline State Descriptor Validation
descriptor is not a MTLMeshRenderPipelineDescriptor.
device does not support mesh shaders.
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:completionHandler:]
-[MTLDebugDevice newLibraryWithFile:error:]
filepath must not be nil.
filepath is not a NSString.
-[MTLDebugDevice newLibraryWithURL:error:]
url is not a NSURL.
Invalid file url
-[MTLDebugDevice newLibraryWithSource:options:error:]
Library with Source Validation
options is not a MTLCompileOptions.
options.libraries contains an object that is not a MTLDynamicLibrary at index %lu.
source must not be nil.
source is not a NSString.
-[MTLDebugDevice newLibraryWithSource:options:completionHandler:]
-[MTLDebugDevice newLibraryWithData:error:]
data must not be nil.
-[MTLDebugDevice newPipelineLibraryWithFilePath:error:]
-[MTLDebugDevice newTextureWithDescriptor:iosurface:plane:]
iosurface must not be nil.
-[MTLDebugDevice newBufferWithIOSurface:]
-[MTLDebugDevice minLinearTextureAlignmentForPixelFormat:]
minLinearTextureAlignment Validation
%s is not supported on this device.
Linear textures do not support compressed pixel formats
Linear textures do not support depth/stencil pixel formats
-[MTLDebugDevice minimumLinearTextureAlignmentForPixelFormat:]
-[MTLDebugDevice newCounterSampleBufferWithDescriptor:error:]
MTLCounterSampleBufferDescriptor must be provided
descriptor is not a MTLCounterSampleBufferDescriptor.
-[MTLDebugDevice newLateEvalEvent]
Event Creation Validation
Late Eval Events not supported on this device
-[MTLDebugDevice newFence]
Attempt to create new fence over the fence instance limit (%lu).
The following Metal object is being destroyed while still required to be alive by the command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
The following Metal object has been over-released by the application and is being destroyed while still retained by command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
-[MTLDebugDevice notifyExternalReferencesNonZeroOnDealloc:]
<no label set>
-[MTLDebugDevice validateRaytracing]
device does not support ray tracing
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:]
buffer offset (%lu) must be < buffer length (%lu).
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:resourceIndex:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:]
-[MTLDebugDevice deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:]
accelerationStructure must not be nil.
-[MTLDebugDevice deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice newVisibleFunctionTableWithDescriptor:]
-[MTLDebugDevice newIntersectionFunctionTableWithDescriptor:]
MTLDebugShaders
simple_vertex
_validateRasterizationRateMapLayers
RasterizationRateMap Layers Validation
device must support variable rasterization rate feature.
screenSize.width (%lu) must be >0 and <=%lu.
screenSize.height (%lu) must be >0 and <=%lu.
layerCount (%lu) must be >0 and <=%lu.
layers must not be nil.
layers[%lu] must not be nil.
layers[%lu] must be a MTLRasterizationRateLayerDescriptor instance.
fill_checkboard_fragment
threadgroupMemoryLength
functionTable
accelerationStructure
buffer =
bufferOffset =
texture =
baseLevel =
sampler =
lodMinClamp =
lodMaxClamp =
threadgroupMemoryLength =
newArgumentEncoder
Function %@ does not have a buffer argument with buffer index %lu
Buffer argument %@ (buffer index: %lu) of function %@ is not an indirect argument buffer. If %@ is expected to be an argument buffer, this could be a shader bug. Argument buffers can be distinguished from regular buffers if they contain buffers, textures, samplers, or any element with the [[id]] attribute
-[MTLDebugLibrary newFunctionWithName:]
name is not a NSString.
validateNewFunctionWithConstantArguments
functionName is not a NSString.
constantValues must not be nil.
-[MTLDebugLibrary validateDescriptor:expectedClass:]
descriptor is not a %@.
Requesting binary compilation which is not supported by the device - supportsFunctionPointers = NO.
All linked functions must have unique names. Function '%s' is a duplicate symbol in %s, symbol first found in %s.
_validateUniqueNames
basic_string
-[MTLDebugParallelRenderCommandEncoder setColorStoreAction:atIndex:]
attachmentIndex(%lu) must be < %lu
-[MTLDebugParallelRenderCommandEncoder setColorStoreActionOptions:atIndex:]
-[MTLDebugParallelRenderCommandEncoder endEncoding_private]
endEncoding called with store action for color attachment index %u still set to MTLStoreActionUnknown
endEncoding called with store action for depth attachment still set to MTLStoreActionUnknown
endEncoding called with store action for stencil attachment still set to MTLStoreActionUnknown
endEncoding called with store action unsupported for Memoryless attachment.
-[MTLDebugParallelRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
filterCounterRangeWithFirstBatch should not be called on ParallelRenderCommandEncoders
%s must not be nil.
%s is not a MTLBuffer.
%s is associated with a different device
%sOffset(%lu) + (indexCount(%lu) * %lu) must be <= [%s length](%lu).
indexCount(%lu) must be non-zero.
%sOffset(%lu) must be a multiple of %lu bytes.
_MTLDebugValidatePatchIndexBuffer
Patch Index Buffer Validation
%sOffset(%lu) + (patchIndicesUsed(%lu) * %lu) must be <= [%s length](%lu).
patchCount(%lu) must be non-zero.
instanceCount(%lu) must be non-zero.
%sOffset(%lu) must be 0.
v24@?0@"<MTLRenderCommandEncoderSPI>"8Q16
-[MTLDebugRenderCommandEncoder _init]_block_invoke
Exceeded HW limit of resources used by render encoder working in Memoryless mode.
Exceeded HW limit of scissor rectangles for render encoder working in Memoryless mode.
Exceeded HW limit of depth biases for render encoder working in Memoryless mode.
Internal error preventing the usage of memoryless for this render encoder.
-[MTLDebugRenderCommandEncoder dealloc]
descriptor =
viewportCount =
viewports:
Viewport %lu:
frontFacingWinding =
cullMode =
depthClipMode =
lineWidth =
depthBias =
depthBiasSlopeScale =
depthBiasClamp =
scissorRectCount =
scissorRects:
Scissor %lu:
amplificationMode =
amplificationValue =
vertexAmplificationCount =
triangleFillMode =
renderPipelineState =
depthStencilState =
frontStencilRef =
0x%x
backStencilRef =
visibilityResultMode =
visibilityResultOffset =
Blend Color =
%g %g %g %g
Set Vertex Buffers:
Set Vertex Textures:
Set Vertex Samplers:
Set Fragment Buffers:
Set Fragment Textures:
Set Fragment Samplers:
Set Tile Buffers:
Set Tile Textures:
Set Tile Samplers:
Set Tessellation Factor Buffer =
tessellationFactorBufferInstanceStride =
tessellationFactorScale =
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState colorSampleCount (%lu).
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For color attachment %d, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For color attachment %d, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For depth attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For depth attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For stencil attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For stencil attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
The color sample count (%lu) does not match the renderPipelineState's color sample count (%lu)
The raster sample count (%lu) does not match the renderPipelineState's raster sample count (%lu)
Device does not support separable raster/color shading rates
The sample count (%lu) does not match the renderPipelineState's sample count (%lu)
-[MTLDebugRenderCommandEncoder setRenderPipelineState:]
Set Render Pipeline State Validation
renderPipelineState must not be nil.
redundant setRenderPipelineState.
previous setRenderPipelineState was unused.
renderPipelineState is not a MTLRenderPipelineState.
renderPipelineState is associated with a different device
the pipelineState's per sample imageBlock usage(%lu) is greater than the encoder's perSample imageBlock usage(%lu)
The threadgroup memory consumed must be <= (%lu)
-[MTLDebugRenderCommandEncoder setVertexBytes:length:atIndex:]
Set Vertex Bytes Validation
-[MTLDebugRenderCommandEncoder setVertexBuffer:offset:atIndex:]
Set Vertex Buffer Validation
-[MTLDebugRenderCommandEncoder setVertexBufferOffset:atIndex:]
Set Vertex Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setVertexBuffers:offsets:withRange:]
Set Vertex Buffers Offset Validation
-[MTLDebugRenderCommandEncoder setVertexTexture:atIndex:]
Set Vertex Texture Validation
texture is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexTextures:withRange:]
Set Vertex Textures Validation
textures[%lu] is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexSamplerState:atIndex:]
Set Vertex Sampler State Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:withRange:]
Set Vertex Sampler States Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentBytes:length:atIndex:]
Set Fragment Bytes Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBufferOffset:atIndex:]
Set Fragment Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffers:offsets:withRange:]
Set Fragment Buffers Validation
-[MTLDebugRenderCommandEncoder setFragmentTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentTextures:withRange:]
Set Fragment Textures Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:atIndex:]
Set Fragment Sampler State Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:withRange:]
Set Fragment Sampler States Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:]
textureIndex(%lu) must be < %lu.
samplerIndex(%lu) must be < %lu.
-[MTLDebugRenderCommandEncoder setTileBytes:length:atIndex:]
Set Tile Bytes Validation
-[MTLDebugRenderCommandEncoder setTileBuffer:offset:atIndex:]
Set Tile Buffer Validation
-[MTLDebugRenderCommandEncoder setTileBufferOffset:atIndex:]
Set Tile Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setTileBuffers:offsets:withRange:]
Set Tile Buffers Validation
-[MTLDebugRenderCommandEncoder setTileTexture:atIndex:]
Set Tile Texture Validation
-[MTLDebugRenderCommandEncoder setTileTextures:withRange:]
Set Tile Textures Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:atIndex:]
Set Tile Sampler State Validation
-[MTLDebugRenderCommandEncoder setTileSamplerStates:withRange:]
Set Tile Sampler States Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder _dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:]
Dispatch Threads Per Tile Validation
the renderPipelineState was not created with a tileDescriptor
threadsPerTile (%lu, %lu) must equal tile size (%lu, %lu) when threadgroupSizeMatchesTileSize is true
threadsPerTile.width(%lu) and threadsPerTile.height(%lu) must match the tile size or threadsPerTile.width(%lu) must be equal to threadsPerTile.height(%lu)
roundup2(threadsPerTile.width(%lu)) * roundup2(threadsPerTile.height(%lu)) * threadsPerTile.depth(%lu) must be <= %lu, both width and height are rounded up to nearest even number 
tile shader input image-block layout must match the previous state's image-block layout
threadsPerTile.width(%lu) * threadsPerTile.height(%lu) * threadsPerTile.depth(%lu) must not be 0
threadsPerTile.width(%lu) must be <= %lu
threadsPerTile.depth(%lu) must be 1
-[MTLDebugRenderCommandEncoder setThreadgroupMemoryLength:offset:atIndex:]
Set Threadgroup Memory Length Validation
A dispatch is required to reinterpret threadgroup memory.
offset + length(%lu) must be <= threadgroupMemoryLength(%lu).
offset(%lu) must be a multiple of %lu bytes.
-[MTLDebugRenderCommandEncoder useResource:usage:]
Use Resource Validation
-[MTLDebugRenderCommandEncoder useResource:usage:stages:]
stages (0x%lx) has an invalid stage
'stages' does not specify any render stages. Specify at least one stage.
useResource:usage:stages:
-[MTLDebugRenderCommandEncoder useResources:count:usage:]
Use Resources Validation
-[MTLDebugRenderCommandEncoder useResources:count:usage:stages:]
useResources:count:usage:stages: (index = %lu)
-[MTLDebugRenderCommandEncoder useHeap:]
-[MTLDebugRenderCommandEncoder useHeap:stages:]
Use Heap Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:]
Use Heaps Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:stages:]
-[MTLDebugRenderCommandEncoder setViewport:]
Viewport Validation
redundant setViewport.
previous setViewport was unused.
-[MTLDebugRenderCommandEncoder setViewports:count:]
viewports parameter cannot be nullptr
viewport count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setFrontFacingWinding:]
Set Front Facing Winding Validation
redundant setFrontFacingWinding.
previous setFrontFacingWinding was unused.
-[MTLDebugRenderCommandEncoder setCullMode:]
Set Cull Mode Validation
redundant setCullMode.
previous setCullMode was unused.
-[MTLDebugRenderCommandEncoder setDepthClipMode:]
Set Depth Clip Mode Validation
redundant setDepthClipMode.
previous setDepthClipMode was unused.
-[MTLDebugRenderCommandEncoder setLineWidth:]
Set Line Width Validation
lineWidth(%g) must be between 1.0f and %.1ff
redundant setLineWidth.
previous setLineWidth was unused.
-[MTLDebugRenderCommandEncoder setDepthBias:slopeScale:clamp:]
Set Depth Bias Validation
redundant setDepthBias.
previous setDepthBias was unused.
-[MTLDebugRenderCommandEncoder setScissorRect:]
Set Scissor Rect Validation
redundant setScissorRect.
previous setScissorRect was unused.
-[MTLDebugRenderCommandEncoder setScissorRects:count:]
Set Scissor Rects Validation
scissorRects parameter cannot be nullptr
scissor rect count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setTransformFeedbackState:]
Set Transform Feedback State Validation
-[MTLDebugRenderCommandEncoder setVertexAmplificationMode:value:]
Set Vertex Amplification Mode Validation
vertexAmplificationMode is not a valid MTLVertexAmplificationMode.
the number of bits set to 1 in value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
redundant setVertexAmplificationMode.
previous setVertexAmplificationMode was unused.
-[MTLDebugRenderCommandEncoder setVertexAmplificationCount:viewMappings:]
invalid usage because device does not support vertex amplification.
count(%u) is not supported on this device. See supportsVertexAmplificationCount:(NSUInteger).
redundant setVertexAmplificationCount.
previous setVertexAmplificationCount was unused.
-[MTLDebugRenderCommandEncoder setTriangleFrontFillMode:backFillMode:]
Set Triangle Front Fill Mode Validation
-[MTLDebugRenderCommandEncoder setTriangleFillMode:]
Set Triangle Fill Mode Validation
redundant setTriangleFillMode.
previous setTriangleFillMode was unused.
-[MTLDebugRenderCommandEncoder setDepthStencilState:]
Set Depth Stencil State Validation
depthStencilState must not be nil.
depthStencilState is not a MTLDepthStencilState.
depthStencilState is associated with a different device
redundant setDepthStencilState.
previous setDepthStencilState was unused.
-[MTLDebugRenderCommandEncoder setStencilReferenceValue:]
Set Stencil Reference Value Validation
redundant setStencilReferenceValue.
previous setStencilReferenceValue was unused.
-[MTLDebugRenderCommandEncoder setStencilFrontReferenceValue:backReferenceValue:]
Set Stencil Front Reference Value Validation
_MTLDebugValidateDeferredStoreActionOnDevice
Deferred Store Action Validation
storeAction must not be MTLStoreActionUnknown
store actions known at render command encoder init time may not be mutated
storeAction unsupported for Memoryless attachment.
MTLRenderPassDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassDescriptor %s store action requires resolve texture
Store action for color attachment index %u must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for depth attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for stencil attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
-[MTLDebugRenderCommandEncoder setColorStoreAction:atIndex:]
Set Color Store Action Validation
deferred color store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreAction:]
deferred depth store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreAction:]
deferred stencil store actions cannot be set on sub render command encoders
_MTLDebugValidateDeferredStoreActionOptionsOnDevice
Deferred Store Action Options on Device Validation
-[MTLDebugRenderCommandEncoder setColorStoreActionOptions:atIndex:]
Set Color Store Action Options Validation
deferred color store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreActionOptions:]
deferred depth store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreActionOptions:]
deferred stencil store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setVisibilityResultMode:offset:]
Set Visibility Result Mode Validation
offset(%lu) must be a multiple of result-size(%u) bytes.
offset(%lu) must be <= %lu.
using the same offset (%lu) in the visibility buffer twice in the same command encoder is not allowed.
framebuffer visibilityResultBuffer must not be nil.
offset(%lu) + result-size(%u) must be <= [visibilityResultBuffer length](%lu).
redundant setVisibilityResultMode.
previous setVisibilityResultMode was unused.
-[MTLDebugRenderCommandEncoder setBlendColorRed:green:blue:alpha:]
Set Blend Color Validation
redundant setBlendColorRed.
previous setBlendColorRed was unused.
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:atIndex:]
Set Color Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:]
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:]
Set Depth Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:yInvert:]
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:]
Set Stencil Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:yInvert:]
primitiveType is not a valid MTLPrimitiveType.
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:]
Draw Errors Validation
only triangles may be drawn when using a rasterization rate map.
renderPipelineState must be set.
renderPipelineState must be created using a MTLRenderPipelineDescriptor.
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassPoint but primitiveType is not MTLPrimitiveTypePoint
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassLine but primitiveType is neither MTLPrimitiveTypeLine nor MTLPrimitiveTypeLineStrip
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassTriangle but primitiveType is neither MTLPrimitiveTypeTriangle nor MTLPrimitiveTypeTriangleStrip
renderPipelineState is a mesh shader pipeline, which cannot be used for this draw command
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:]
The scissor rectangle count (%lu) should be equal to the viewport count (%lu) or should be 1.
input image-block layout must match the previous state image-block layout
the renderPipelineState has a vertex shader that writes to render_target_array_index but renderTargetArrayLength is set to zero
renderPipelineState is not a mesh shader pipeline
Vertex Amplification Count (%u) must be between (inclusive) 1 and the maximum vertex amplification count specified in the pipeline state (%u)
-[MTLDebugRenderCommandEncoder validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:]
Draw Primitives Validation
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:]
-[MTLDebugRenderCommandEncoder validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:]
Draw Indexed Primitives Validation
indexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
-[MTLDebugRenderCommandEncoder drawPrimitives:indirectBuffer:indirectBufferOffset:]
indirectBuffer
sizeof(MTLDrawPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawIndexedPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder setObjectBytes:length:atIndex:]
Set Object Bytes Validation
-[MTLDebugRenderCommandEncoder setObjectBuffer:offset:atIndex:]
Set Object Buffer Validation
-[MTLDebugRenderCommandEncoder setObjectBufferOffset:atIndex:]
Set Object Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setObjectBuffers:offsets:withRange:]
Set Object Buffers Validation
-[MTLDebugRenderCommandEncoder setObjectTexture:atIndex:]
Set Object Texture Validation
-[MTLDebugRenderCommandEncoder setObjectTextures:withRange:]
Set Object Textures Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:atIndex:]
Set Object Sampler State Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:withRange:]
Set Object Sampler States Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
Set Object Threadgroup Memory Length Validation
-[MTLDebugRenderCommandEncoder setObjectThreadgroupMemoryLength:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshBytes:length:atIndex:]
Set Mesh Bytes Validation
-[MTLDebugRenderCommandEncoder setMeshBuffer:offset:atIndex:]
Set Mesh Buffer Validation
-[MTLDebugRenderCommandEncoder setMeshBufferOffset:atIndex:]
Set Mesh Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setMeshBuffers:offsets:withRange:]
Set Mesh Buffers Validation
-[MTLDebugRenderCommandEncoder setMeshTexture:atIndex:]
Set Mesh Texture Validation
-[MTLDebugRenderCommandEncoder setMeshTextures:withRange:]
Set Mesh Textures Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:atIndex:]
Set Mesh Sampler State Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:withRange:]
Set Mesh Sampler States Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
Draw Mesh Threadgroups With Indirect Buffer Validation
sizeof(MTLDispatchThreadgroupsIndirectArguments)
-[MTLDebugRenderCommandEncoder updateFence:afterStages:]
Cannot set the (MTLRenderStages)afterStages to 0. The parameter should be set to a valid MTLRenderStages value.
-[MTLDebugRenderCommandEncoder waitForFence:beforeStages:]
Cannot set the (MTLRenderStages)beforeStages to 0. The parameter should be set to a valid MTLRenderStages value.
Wait for Fence Validation
-[MTLDebugRenderCommandEncoder endEncoding_private]
End Encoding Validation
endEncoding without draw.
-[MTLDebugRenderCommandEncoder setTessellationFactorBuffer:offset:instanceStride:]
Set Tessellation Factor Buffer Validation
offset(%lu) must be a multiple of 4 bytes.
instanceStride(%lu) must be a multiple of 4 bytes.
-[MTLDebugRenderCommandEncoder setTessellationFactorScale:]
scale(%g) must be a normal floating point value (not denormal, infinite, nor NaN) and must be > 0.0f.
-[MTLDebugRenderCommandEncoder drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:]
patchIndexBuffer
-[MTLDebugRenderCommandEncoder drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
Draw Patches Validation
sizeof(MTLDrawPatchIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:]
Draw Indexed Patches Validation
controlPointIndexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugRenderCommandEncoder textureBarrier]
-textureBarrier is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithScope:afterStages:beforeStages:]
Memory Barrier With Scope Validation
render memoryBarrierWithScope is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithResources:count:afterStages:beforeStages:]
Memory Barrier With Resources Validation
render memoryBarrierWithResources is not supported on this device
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:withRange:]
Execute Commands In Buffer Validation
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the render pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDrawBoundary is not supported.
-[MTLDebugRenderCommandEncoder setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Table Validation
-[MTLDebugRenderCommandEncoder setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Tables Validation
intersectionFunctionTable is associated with a different stage (%@, expected %@)
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Table Validation
intersectionFunctionTable is not a MTLIntersectionFunctionTable.
intersectionFunctionTable is associated with a different device
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Tables Validation
-[MTLDebugRenderCommandEncoder setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Acceleration Structure Validation
indexType not valid MTLIndexType
%g %g %g %g %g %g
MTLWindingClockwise
MTLWindingCounterClockwise
MTLCullModeNone
MTLCullModeFront
MTLCullModeBack
MTLDepthClipModeClip
MTLDepthClipModeClamp
%lu %lu %lu %lu
MTLTriangleFillModeFill
MTLTriangleFillModeLines
MTLTriangleFillModePoint
MTLVisibilityResultModeDisabled
MTLVisibilityResultModeBoolean
MTLVisibilityResultModeCounting
local memory
%s must not be infinite or NaN.
viewport.originX
viewport.originY
viewport.width
viewport.height
viewport.znear
viewport.zfar
frontFacingWinding is not a valid MTLWinding.
cullMode is not a valid MTLCullMode.
depthClipMode is not a valid MTLDepthClipMode.
(rect.x(%lu) + rect.width(%lu))(%lu) must be <= render pass width(%lu)
(rect.y(%lu) + rect.height(%lu))(%lu) must be <= render pass height(%lu)
state(%u) is not a valid MTLTransformFeedbackState.
fillMode is not a valid MTLTriangleFillMode.
mode is not a valid MTLVisibilityResultMode.
%@ Function(%@): binding at index %lu is not a MTLDebugTexture.
%@ Function(%@): Shader reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): Shader writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
q24@?0@8@16
%@ Function(%@): there is an overlap with the threadgroupMemoryArgument at offset (%lu) and at offset(%lu).
validateDisjointRenderTargetsAndTexture
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also a %s attachment at index %lu. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and writeMask != MTLColorWriteMaskNone.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and depth writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and stencil writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is currently being written to in this render pass. This may be a conflict.
resolve
color
depth
stencil
vertex_id type is not big enough to draw this many vertices (%lu)
instance_id type is not big enough to draw this many instances (%lu)
missing vertexDescriptor %s binding at index %lu.
incorrect vertexDescriptor %s binding at index %lu.
MTLDepthStencilDescriptor sets depth test but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor has depthWriteEnabled but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor uses frontFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
MTLDepthStencilDescriptor uses backFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
%s requires a postTessellationVertexFunction but the vertexFunction of the renderPipelineState is not a postTessellationVertexFunction.
%s requires a normal vertexFunction but the vertexFunction of the renderPipelineState is a postTessellationVertexFunction.
(%sOffset + %s)(%lu) must be <= [%s length](%lu).
%sOffset(%lu) must be a multiple of 4 bytes.
validateCommonTessellationErrors
Common Tessellation Errors Validation
missing tessellationFactorBuffer binding.
numberOfPatchControlPoints(%lu) must match the number of control points(%ld) set in the vertexFunction of the renderPipelineState.
numberOfPatchControlPoints(%lu) must be <= 32.
for drawIndexedPatches numberOfPatchControlPoints(%lu) must not be 0.
for MTLTessellationFactorStepFunctionConstant and MTLTessellationFactorStepFunctionPerPatch tessellationFactorBufferInstanceStride(%lu) must be zero.
for MTLTessellationFactorStepFunctionPerInstance and MTLTessellationFactorStepFunctionPerPatchAndPerInstance tessellationFactorBufferInstanceStride(%lu) must be non-zero.
tessellationFactorBufferInstanceStride(%lu) must be a multiple of %lu bytes.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeNone not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt16 not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt32 not valid for %s.
tessellationFactorBuffer
%sOffset(%lu) + tessellationFactorBytesUsed(%lu) must be <= [%s length](%lu).
(patchStart + patchCount)(%lu) * %lu must be <= tessellationFactorBufferInstanceStride(%lu).
%@ called with stages (0x%lx), but %s resource was created for stage %@
MTL_XML_DUMP_EVENTS
MTLCommandBufferKernelStartTime
MTLCommandBufferKernelEndTime
MTLCommandBufferGPUStartTime
MTLCommandBufferGPUEndTime
-[MTLDebugResource doesAliasResource:]
Resource Validation
Input resource was not allocated on a heap.
-[MTLDebugResource doesAliasAllResources:count:]
Resources count cannot be zero.
resources must not be nil
Input resource %0lx was not allocated on a heap.
-[MTLDebugResource doesAliasAnyResources:count:]
v24@?0@"MTLStructType"8Q16
-[MTLDebugIndirectRenderCommand setVertexBuffer:offset:atIndex:]
Vertex Buffer Validation
-[MTLDebugIndirectRenderCommand setFragmentBuffer:offset:atIndex:]
Fragment Buffer Validation
-[MTLDebugIndirectRenderCommand drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
drawPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
drawIndexedPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setRenderPipelineState:]
Render Pipeline State Validation
-[MTLDebugIndirectRenderCommand drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawIndexedPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setObjectBuffer:offset:atIndex:]
Object Buffer Validation
index(%lu) must be < maxObjectBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setMeshBuffer:offset:atIndex:]
Mesh Buffer Validation
index(%lu) must be < maxMeshBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setBarrier]
setBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand clearBarrier]
clearBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreadgroups is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreads is not enabled on this indirect command buffer
-[MTLDebugRenderPipelineState validateHandleForSetFunction:]
-[MTLDebugRenderPipelineState validateBinaryFunctions:stage:]
Pipeline state is adding %@ functions which is not supported by the device
Function '%s' was found in %@ functions array but is not precompiled.
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:]
Pipeline state is adding vertex functions but it was created with supportAddingVertexBinaryFunctions=NO
Pipeline state is adding fragment functions but it was created with supportAddingFragmentBinaryFunctions=NO
Unable to create new render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:]
Unable to create new tile render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:error:]
cannot specify both tile and render pipeline additional functions simultaneously.
Pipeline state is adding tile functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding object functions but it was created with supportAddingObjectBinaryFunctions=NO
Pipeline state is adding mesh functions but it was created with supportAddingMeshBinaryFunctions=NO
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:selector:]
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:]
stage invalid.
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:selector:]
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:withStage:selector:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:stage:]
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) cannot exceed maxTotalThreadsPer%sThreadgroup (%lu)
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) must be multiple of %sThreadExecutionWidth (%lu)
validateMTLSamplerDescriptor
Sampler Descriptor Validation
MTLSamplerDescriptor:non-normalized coords require MTLSamplerMipFilterNotMipmapped.
MTLSamplerDescriptor:non-normalized coords require MTLSamplerAddressModeClampToEdge, MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor.
MTLSamplerDescriptor:non-normalized coords require maxAnisotropy == 1.
MTLSamplerDescriptor:non-normalized coords require minFilter==magFilter of MTLSamplerMinMagFilterNearest or MTLSamplerMinMagFilterLinear, to be portable to all Metal devices.
MTLSamplerDescriptor's min filter value (%lu) is invalid.
MTLSamplerDescriptor's mag filter value (%lu) is invalid.
MTLSamplerDescriptor's mip filter value (%lu) is invalid.
MTLSamplerDescriptor's max anisotropy value (%lu) is invalid. Clamping to [%i, %i] range.
MTLSamplerDescriptor's S texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's T texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's R texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's texture coordinate address modes must either contain MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor modes but not both.
MTLSamplerDescriptor: pixelFormat(%s) must be MTLPixelFormatInvalid when supportsArgumentBuffers == YES
MTLSamplerAddressModeMirrorClampToEdge is not supported on this device
MTLSamplerAddressModeClampToHalfBorderColor is not supported on this device
Custom border colors are not supported on this device
%@ is not supported on this device
Exceeded the limit on number of unique samplers usable in argument buffers (which is %u)
Sparse textures cannot be created with dual-plane texture formats
The requested hazard tracking mode does not match the heap's mode
The requested CPU cache mode does not match the heap's mode
The requested storage mode is not compatible with the heap's mode
Shared textures created via heaps are not supported on this device
MTLResourceOptions options have unknown bits 0x%lx.
MTLTextureUsageShaderWrite is not supported for MTLHeapTypeSparse on this platform
-[MTLDebugHeap maxAvailableSizeWithAlignment:]
aligment needs to be power of two, or zero.
-[MTLDebugHeap newBufferWithLength:options:]
Requested length %lu must not exceed heap size %lu.
Cannot create buffer from sparse heap.
newBufferWithLength:options: cannot be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options:offset: instead.
-[MTLDebugHeap newTextureWithDescriptor:]
newTextureWithDescriptor: cannot be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor:offset: instead.
Sparse textures are not supported on this device
MTLHeapTypeSparse does not support MTLTextureType1D and MTLTextureType1DArray
MTLHeapTypeSparse does not support MTLTextureTypeTextureBuffer
MTLUnmappedDepthValueOne is only supported for MTLPixelFormatDepth32Float
-[MTLDebugHeap setPurgeableState:]
-[MTLDebugHeap validateOffset:withRequirements:]
Offset Validation
Cannot place resource at offset %lu extending beyond the heap size %lu (resource size %lu)
Cannot place resource at offset %lu which is not aligned to %lu bytes
-[MTLDebugHeap newBufferWithLength:options:offset:]
newBufferWithLength:options:offset: can only be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options: instead.
-[MTLDebugHeap newTextureWithDescriptor:offset:]
newTextureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor: instead.
-[MTLDebugHeap validateRaytracingHeap]
Heap must be MTLStorageModePrivate to allocate acceleration structures
-[MTLDebugHeap newAccelerationStructureWithSize:]
Cannot create acceleration structure of zero size.
Requested size %lu must not exceed heap size %lu.
-[MTLDebugHeap newAccelerationStructureWithSize:offset:]
newAccelerationStructureWithSize:offset can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize: instead.
-[MTLDebugHeap newAccelerationStructureWithDescriptor:offset:]
newAccelerationStructureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithDescriptor: instead.
-[MTLDebugHeap newAccelerationStructureWithSize:resourceIndex:]
-[MTLDebugHeap newAccelerationStructureWithSize:offset:resourceIndex:]
newAccelerationStructureWithSize:offset:resourceIndex can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize:resourceIndex: instead.
-[MTLDebugTexture dealloc]
usageRequested 0x%lx != usageRequired 0x%lx
-[MTLDebugTexture makeAliasable]
Sparse textures cannot be made aliasable.
Memoryless textures cannot be made aliasable.
Texture Views created from Textures, that are backed by the Heap, cannot be made aliasable.
-[MTLDebugTexture setPurgeableState:]
Set Purgeable Stage Validation
_validateReplaceRegion
Replace Region Validation
(size.width(%lu) * size.height(%lu) * size.depth(%lu))(%lu) must not be 0.
CPU access for textures with MTLResourceStorageModePrivate storage mode is disallowed.
CPU access for textures with MTLStorageModeMemoryless is disallowed.
texture must not be a framebufferOnly texture.
mipmapLevel(%lu) must be < [texture mipmapLevelCount](%lu).
(origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(origin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(origin.x + size.width)(%lu) must be <= width(%lu).
(origin.y + size.height)(%lu) must be <= height(%lu).
(origin.z + size.depth)(%lu) must be <= depth(%lu).
origin.x(%lu) must be a multiple of %s blockWidth(%lu).
origin.y(%lu) must be a multiple of %s blockHeight(%lu).
origin.z(%lu) must be a multiple of %s blockDepth(%lu).
origin.x must be 0 (full image) for %s.
origin.y must be 0 (full image) for %s.
origin.z must be 0 (full image) for %s.
size.width(%lu) must equal width(%lu) (full image) for %s.
size.height(%lu) must equal height(%lu) (full image) for %s.
size.depth(%lu) must equal depth(%lu) (full image) for %s.
rowBytes must be 0 for %s.
imageBytes must be 0 for %s.
rowBytes(%lu) must be >= (%lu).
imageBytes(%lu) must be >= (%lu).
rowBytes(%lu) must be a multiple of %s %s bytes(%lu).
block
pixel
imageBytes(%lu) must be a multiple of %s %s bytes(%lu).
CPU access for this texture with pixel format %s is disallowed.
Replacing region on slice(%u) on mipmapLevel(%u) that is currently attached as a writeable render target.
_validateGetBytes
Get Bytes Validation
GetBytes Validation
_validateTextureView
Texture View Validation
cannot create View from Memoryless texture.
texture usage (0x%02lx) doesn't specify MTLTextureUsagePixelFormatView (0x%02lx)
invalid pixelFormat.
texture view creation not allowed from frameBufferOnly textures.
textureType %@ cannot be used for buffer-backed textures.
-[MTLDebugAccelerationStructure setPurgeableState:]
Intel
12StringBuffer
12AppendBuffer
12BinaryBuffer
(6TbF
 .8"B
JMPSVY\_be
BufferHeap::MemoryAllocated (MB) - %.2f
BufferHeap::MemoryUsed (MB) - %.2f/%.2f
DescriptorHeapSize (MB) - %.2f
DescriptorHeapNewHandle - %llu
ConstantBufferCache::TotalMemory - %llu
Device Alloc - %s, %p
Device Dealloc - %s, %p
Fatal failure when instrumenting %s "%s":
Function is not instrumented and faults will not be detected.
Partial failure when instrumenting %s "%s":%s%s
MTLDebugIndirectComputeCommand
MTLGPUDebugRenderCommandEncoder
MTLGPUDebugCommandEncoder
NSObject
MTLToolsIndirectCommandBuffer
MTLIndirectCommandBufferSPI
MTLIndirectCommandBuffer
MTLResource
MTLGPUDebugGPULog
MTLFunctionLog
MTLGPUDebugBufferErrorLog
MTLGPUDebugTextureErrorLog
MTLGPUDebugStackOverflowErrorLog
MTLGPUDebugTrapErrorLog
MTLToolsBlitCommandEncoder
MTLBlitCommandEncoderSPI
MTLCommandEncoderSPI
MTLCommandEncoder
MTLBlitCommandEncoder
MTLToolsFence
MTLFenceSPI
MTLFence
MTLCountersRenderCommandEncoder
MTLToolsCounterSampleBuffer
MTLCounterSampleBuffer
MTLGPUDebugLibrary
MTLToolsBuffer
MTLBufferSPI
MTLResourceSPI
MTLBuffer
MTLToolsCommandBuffer
MTLCommandBufferSPI
MTLCommandBuffer
MTLToolsRetainingContainer
MTLToolsCommandEncoder
MTLToolsPerfCounterMailbox
MTLToolsCommandQueue
MTLCommandQueueSPI
MTLCommandQueue
MTLDebugVisibleFunctionTable
MTLDebugResourcePurgeable
MTLToolsDynamicLibrary
MTLDynamicLibrarySPI
MTLDynamicLibrary
MTLToolsBinaryArchive
MTLBinaryArchiveSPI
MTLBinaryArchive
MTLToolsHeap
MTLHeapSPI
MTLHeap
MTLToolsComputeCommandEncoder
MTLComputeCommandEncoderSPI
MTLComputeCommandEncoder
MTLGPUDebugImageData
MTLToolsAccelerationStructureCommandEncoder
MTLAccelerationStructureCommandEncoderSPI
MTLAccelerationStructureCommandEncoder
MTLToolsComputePipelineState
MTLComputePipelineStateSPI
MTLComputePipelineState
MTLPipelineStateWithProgramAddressTable
MTLGPUDebugAccelerationStructure
MTLGPUDebugResource
MTLGPUDebugBuffer
MTLToolsDepthStencilState
MTLDepthStencilStateSPI
MTLDepthStencilState
MTLToolsIndirectComputeCommand
MTLIndirectComputeCommandSPI
MTLIndirectComputeCommand
MTLGPUDebugDevice
MTLToolsDevice
MTLDeviceSPI
MTLDevice
MTLToolsEvent
MTLEventSPI
MTLEvent
MTLToolsSharedEvent
MTLSharedEventSPI
MTLSharedEvent
MTLToolsLateEvalEvent
MTLLateEvalEvent
MTLToolsFunction
MTLFunctionSPI
MTLFunction
MTLToolsLibrary
MTLLibrarySPI
MTLLibrary
MTLToolsVisibleFunctionTable
MTLVisibleFunctionTableSPI
MTLVisibleFunctionTable
MTLDebugPipelineLibrary
MTLCountersComputeCommandEncoder
MTLGPUDebugRenderPipelineState
MTLGPUDebugAccelerationStructureCommandEncoder
MTLToolsObject
MTLToolsParallelRenderCommandEncoder
MTLParallelRenderCommandEncoderSPI
MTLParallelRenderCommandEncoder
MTLToolsIntersectionFunctionTable
MTLIntersectionFunctionTableSPI
MTLIntersectionFunctionTable
MTLToolsRenderCommandEncoder
MTLRenderCommandEncoderSPI
MTLRenderCommandEncoder
MTLGPUDebugIntersectionFunctionTable
MTLGPUDebugIndirectComputeCommand
MTLToolsRasterizationRateMap
MTLRasterizationRateMapSPI
MTLRasterizationRateMap
MTLDebugIntersectionFunctionTable
MTLCountersTraceCommandEncoder
MTLCountersTraceBlitCommandEncoder
MTLCountersTraceComputeCommandEncoder
MTLCountersTraceRenderCommandEncoder
MTLCountersTraceResourceStateCommandEncoder
MTLCountersTraceCommandBuffer
MTLToolsRenderPipelineState
MTLRenderPipelineStateSPI
MTLRenderPipelineState
MTLToolsResource
MTLToolsResourceGroupSPI
MTLResourceGroupSPI
MTLGPUDebugIndirectRenderCommand
MTLToolsSamplerState
MTLSamplerState
MTLSamplerStateSPI
MTLToolsTexture
MTLTextureImplementation
MTLTextureSPI
MTLTexture
MTLToolsTextureLayout
MTLTextureLayout
MTLCountersParallelRenderCommandEncoder
MTLGPUDebugCommandBuffer
MTLGPUDebugBufferEncoder
MTLToolsResourceStateCommandEncoder
MTLResourceStateCommandEncoderSPI
MTLResourceStateCommandEncoder
MTLDebugBlitCommandEncoder
MTLDebugResourceStateCommandEncoder
MTLDebugBufferMarker
MTLDebugBuffer
MTLDebugDeadlineProfile
MTLGPUDebugCommandQueue
MTLDebugCommandBuffer
MTLGPUDebugBinaryArchive
MTLGPUDebugPipelineStateInfoEncoder
MTLDebugDynamicLibrary
MTLToolsIndirectRenderCommand
MTLIndirectRenderCommandSPI
MTLIndirectRenderCommand
MTLDebugCounterSampleBuffer
MTLDebugBinaryArchive
MTLCountersDevice
MTLGPUDebugArgumentEncoder
MTLGPUDebugComputePipelineState
MTLDebugCommandQueue
MTLDebugComputeCommandEncoder
MTLAccelerationStructure
MTLDebugAccelerationStructureCommandEncoder
MTLDebugFunctionHandle
MTLFunctionHandle
MTLDebugComputePipelineState
MTLDebugIndirectCommandBuffer
MTLCountersCommandQueue
MTLToolsPipelineLibrary
MTLPipelineLibrarySPI
MTLPipelineLibrary
MTLToolsArgumentEncoder
MTLArgumentEncoderSPI
MTLArgumentEncoder
MTLGPUDebugHeap
MTLDebugArgumentEncoder
MTLDebugDevice
MTLDebugDepthStencilState
MTLGPUDebugIndirectCommandBuffer
MTLDebugEvent
MTLDebugSharedEvent
MTLDebugLateEvalEvent
MTLGPUDebugFunctionHandle
MTLGPUDebugParallelRenderCommandEncoder
MTLCountersResourceStateCommandEncoder
MTLToolsAccelerationStructure
MTLAccelerationStructureSPI
MTLToolsObjectCache
MTLDebugFunction
MTLDebugLibrary
MTLDebugParallelRenderCommandEncoder
MTLDebugRenderTargetAttachmentInfo
MTLDebugRenderCommandEncoder
MTLToolsDeadlineProfile
MTLDeadlineProfile
MTLCountersCommandBuffer
MTLGPUDebugBlitCommandEncoder
MTLGPUDebugVisibleFunctionTable
MTLDebugResource
MTLGPUDebugComputeCommandEncoder
MTLToolsFunctionHandle
MTLGPUDebugFunction
MTLDebugIndirectRenderCommand
MTLDebugRenderPipelineState
MTLDebugSamplerState
MTLDebugHeap
MTLDebugTexture
MTLDebugTextureLayout
MTLGPUDebugDynamicLibrary
MTLDebugAccelerationStructure
MTLGPUDebugTexture
MTLCountersBlitCommandEncoder
T@"<MTLHeap>",R
.cxx_destruct
T@"NSArray",C,N
AnisoSampleFixSupported
T@"NSString",&,N,V_functionName
ClampToHalfBorderSupported
TB,R,GisIntegrated,V_integrated
FixedLinePointFillDepthGradientSupported
TQ,R,N,V_visibilityResultOffset
GPUEndTime
T{?=dddddd},R,N
ICB_DepthStencilState
_activeSubViews
ICB_Inherit_Buffers_ComputePipelineState
_attachmentInfo
ICB_Inherit_None_ComputePipelineState
_blendColorBlue
ICB_Inherit_PSO_ComputePipelineState
_common
RGB10A2GammaSupported
_constantOffset
StatEnabled
_currentEncoder
StatOptions
_descriptorHeap
T@"<MTLAccelerationStructure>",&,D,N
_deviceInitFlag
T@"<MTLBuffer>",&,N
_dynamicLibrary
T@"<MTLBuffer>",R
_height
T@"<MTLBuffer>",R,V_buffer
_imageBlockSize
T@"<MTLComputePipelineState>",R,N
_length
T@"<MTLComputePipelineState>",R,N,V_computePipelineState
_maxVertexCount
T@"<MTLDepthStencilState>",R,N
_newComputePipelineStateWithFunction:options:completionHandler:
T@"<MTLDevice>",R
_newRenderPipelineStateWithDescriptor:options:reflection:error:
T@"<MTLFunction>",R,N
_objectSamplers
T@"<MTLFunctionHandle>",R,N
_objectThreadgroupMemoryLengths
T@"<MTLFunctionLogDebugLocation>",R,N
_parent
T@"<MTLIndirectCommandBufferSPI>",&,D,N
_specifiedUsage
T@"<MTLLogContainer>",R
_subViewUseLock
T@"<MTLRenderPipelineState>",R,N
_textureIndices
T@"<MTLResource>",R
_tileDescriptor
T@"<MTLTexture>",R
_validateThreadsPerThreadgroup:
T@"<MTLTexture>",R,N,V_baseResolveTexture
_vertexSamplers
T@"<MTLTexture>",R,V_parentTexture
addLibraryWithDescriptor:error:
T@"<MTLToolsRetainingContainer>",R,N,V_commandBuffer
arrayWithArray:
T@"MTLAccelerationStructureDescriptor",&,N
baseLevelOffset
T@"MTLArgument",&,N,V_argument
binaryFunctions
T@"MTLComputePipelineDescriptor",R,N,V_descriptor
blendColorGreen
T@"MTLComputePipelineReflection",R,N,V_reflection
builtInDataType
T@"MTLCountersTraceCommandBuffer",R,N,V_traceBuffer
complainAboutSloppyTextureUsage
T@"MTLDebugInstrumentationData",&,N
compressionType
T@"MTLDebugInstrumentationData",R,N
containsObject:
T@"MTLDepthStencilDescriptor",R,N,V_defaultDepthStencilDescriptor
copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:
T@"MTLFunctionConstantValues",&,V_constantValues
copyGranularity
T@"MTLGPUDebugBuffer",R,N
deadlineProfile
T@"MTLGPUDebugDevice",R,D
defaultTextureWriteRoundingMode
T@"MTLGPUDebugFunction",R,W,N
didModifyRange:
T@"MTLGPUDebugImageData",R,N
elementIsIndirectArgumentBuffer
T@"MTLIndirectCommandBufferDescriptor",R
enqueue
T@"MTLRenderPassDescriptor",R,C,N,V_descriptor
errorStackTrace
T@"MTLRenderPipelineReflection",R,N
frontStencilRef
T@"MTLSamplerDescriptor",R,C,N,V_descriptor
importedSymbols
T@"MTLTextureDescriptor",R,C,N,V_descriptor
initWithBaseObject:descriptor:indexCount:indirectCommandBuffer:
T@"MTLToolsFunction",R,V_function
initWithDevice:
T@"NSArray",&,N,V_errorStackTrace
initWithHeap:descriptor:device:
T@"NSArray",R,N,V_binaryFunctionData
innerNodeBuffer
T@"NSData",R
intersectionFunctionTableOffset
T@"NSDictionary",R
isLinearTexture
T@"NSMutableArray",R
kernelStartTime
T@"NSMutableSet",R,N
library
T@"NSObject<OS_dispatch_data>",R
loadedImageName
T@"NSString",C
maxInterpolants
T@"NSString",C,N,V_label
maxTileSamplers
T@"NSString",R,C
maxTotalThreadgroupsPerMeshGrid
T@"NSString",R,N,V_tracePath
meshFunctionHandleWithFunction:
T@"_MTLIndirectArgumentBufferLayout",R,N
motionStartTime
T@,C,N,V_code
newCommandQueue
newDynamicLibraryFromURL:error:
TB,GisProfilingEnabled
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
TB,N,GisStatEnabled
newRenderPipelineStateWithDescriptor:options:completionHandler:
TB,R
objectArguments
TB,R,GareProgrammableSamplePositionsSupported
pipelineLibrary
TB,R,GisBCTextureCompressionSupported
pointer
TB,R,GisCustomBorderColorSupported
primitiveBuffer
TB,R,GisFixedLinePointFillDepthGradientSupported
pushDebugGroup:
TB,R,GisFramebufferOnly
resetWithRange:
TB,R,GisLargeMRTSupported
retainedObjects
TB,R,GisMeshShaderPipeline
separateCommits
TB,R,GisPlacementHeapSupported
setAdditionalCompilerArguments:
TB,R,GisRGB10A2GammaSupported
setBufferIndex:
TB,R,GisRemovable
setDepthCleared
TB,R,N,V_APITimingEnabled
setFragmentReportBuffer:offset:
TB,R,V_loadValidationEnabled
setIndexBuffer:
TB,V_useRetainedObjectsLock
setKernelBuffer:offset:atIndex:
TI,R
setObjectBuffer:offset:atIndex:
TI,R,N,V_backStencilRef
setRelocations:
TI,R,V_encoderID
setScissorRect:
TQ,N
setStatOptions:
TQ,N,GgetStatOptions
setThreadgroupDistributionMode:
TQ,N,V_debugType
setVertexBuffer:offset:atIndex:
TQ,N,V_type
standardizedURL
TQ,R,D,N
stringByAppendingPathComponent:
TQ,R,N,GgetListIndex
supportsFamily:
TQ,R,N,V_attachmentWriteMask
supportsInvariantVertexPosition
TQ,R,N,V_bytesPerImage
supportsMemorylessRenderTargets
TQ,R,N,V_cullMode
supportsStreamingCodecSignaling
TQ,R,N,V_flags
supportsViewportAndScissorArray
TQ,R,N,V_options
swizzle
TQ,R,N,V_plane
tailSizeInBytes
TQ,R,N,V_resolveLevelOffset
textureDataType
TQ,R,N,V_storageMode
tileSizeWithSparsePageSize:textureType:pixelFormat:sampleCount:
TQ,R,N,V_triangleFillMode
updateTextureMappings:mode:regions:mipLevels:slices:numRegions:
TQ,R,V_functionCount
useHeap:stages:
TQ,R,V_memorySize
valueWithRange:
TQ,R,V_width
vertexAdditionalBinaryFunctions
T^{__IOSurface=},R
.cxx_construct
T@"MTLToolsCommandBuffer",R,D,N
APITimingEnabled
T@"NSString",&,N,V_encoderLabel
BCTextureCompressionSupported
TB,R,GisAnisoSampleFixSupported
CustomBorderColorSupported
TQ,R,N,V_offset
GPUBVHBuilder
T^v,R,N
GPUStartTime
ICB_Inherit_Both_ComputePipelineState
_allocationLock
ICB_Inherit_Buffers_VertexPipelineState
_backStencilRef
ICB_Inherit_None_VertexPipelineState
_buffer
ICB_Inherit_PSO_VertexPipelineState
_compileOptions
RTZRoundingSupported
_constantValues
StatLocations
_depthBiasClamp
T#,R
_device
T@"<MTLBuffer>",&,D,N
_drawID
T@"<MTLBuffer>",&,N,V_buffer
_heapUsageTable
T@"<MTLBuffer>",R,N
_icbInheritComputePipelineState
T@"<MTLCommandQueue>",R
_layout
T@"<MTLComputePipelineState>",R,N,V_accelerationStructureComputePipelineState
_maxThreadPositionInThreadgroup
T@"<MTLDeadlineProfile>",R,&
_meshDescriptor
T@"<MTLDepthStencilState>",R,N,V_depthStencilState
_newDebugAccelerationStructure:
T@"<MTLFunction>",&,N,V_function
_newToolsAccelerationStructure:
T@"<MTLFunction>",R,N,V_function
_objectTextures
T@"<MTLFunctionLogDebugLocation>",&,N,V_debugLocation
_offset
T@"<MTLIndirectCommandBuffer>",R
_removeUsedRenderTargetsExcept:
T@"<MTLIntersectionFunctionTable>",&,D,N
_stream
T@"<MTLPipelineCache>",R,N
_supportsIndirectCommandBuffers
T@"<MTLRenderPipelineState>",R,N,V_renderPipelineState
_threadgroupSizeMatchesTileSize
T@"<MTLResource>",R,N
_userReflection
T@"<MTLTexture>",R,N,V_attachmentTexture
_vertexAmpState
T@"<MTLTexture>",R,N,V_baseTexture
_vertexTextures
T@"<MTLTextureSPI>",&,D,N
addSynchronizationNotification:
T@"<MTLVisibleFunctionTable>",&,D,N
backFaceStencil
T@"MTLArchitecture",R
beginUseOfMeshShadersInEncoder:
T@"MTLCompileOptions",C,N,V_compileOptions
blendColorAlpha
T@"MTLComputePipelineReflection",R,N
bufferAlignment
T@"MTLCounterSampleBufferDescriptor",R,N,V_descriptor
compareFunction
T@"MTLDebugDevice",R,N,V_debugDevice
completionQueue
T@"MTLDebugInstrumentationData",R,&,N
computeFunction
T@"MTLDebugResource",R,N,V_common
containsString:
T@"MTLDepthStencilDescriptor",R,N,V_descriptor
copyFromTextureMemory:textureSlice:textureLevel:textureRegion:toLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:
T@"MTLGPUBVHBuilder",R
dataWithLength:
T@"MTLGPUDebugCommandBuffer",R,D
dealloc
T@"MTLGPUDebugDynamicLibrary",R,W,N
depthAttachment
T@"MTLGPUDebugImageData",&,N,V_image
disableCrossQueueHazardTracking
T@"MTLGPUDebugImageData",R,N,V_imageData
encodeStartElse
T@"MTLMeshRenderPipelineDescriptor",R,N,V_meshDescriptor
enumerateTileBuffersUsingBlock:
T@"MTLRenderPipelineDescriptor",R,N,V_descriptor
framebufferOnly
T@"MTLRenderPipelineReflection",R,N,V_reflection
getDynamicLibraryForBaseObject:
T@"MTLTargetDeviceArchitecture",R
inheritsBuffers
T@"MTLTileRenderPipelineDescriptor",R,N,V_tileDescriptor
initWithBaseObject:parent:heap:
T@"MTLType",R
initWithFormat:
T@"NSArray",R
initWithLength:
T@"NSArray",R,N,V_imageFilterFunctions
instancedAccelerationStructures
T@"NSDictionary",C,N
isBCTextureCompressionSupported
T@"NSError",R
isProxy
T@"NSMutableDictionary",R,N
layouts
T@"NSMutableSet",R,N,V_retainedObjects
linkedFunctions
T@"NSObject<OS_dispatch_queue>",R
maxBufferLength
T@"NSString",C,N,V_filePath
maxMeshBindings
T@"NSString",R
maxTileTextures
T@"NSString",R,N
members
T@"NSUUID",R,C
minConstantBufferAlignmentBytes
T@,&,N,V_baseObject
newBufferWithBytesNoCopy:length:options:gpuAddress:deallocator:
T@,R,V_baseObject
newComputePipelineStateWithDescriptor:options:reflection:error:
TB,GareGPUAssertionsEnabled,SsetGPUAssertionsEnabled:
newDynamicLibraryWithURL:error:
TB,N
newLibraryWithDescriptor:error:
TB,N,V_isContentExposedToCPU
objectAdditionalBinaryFunctions
TB,R,GareBarycentricCoordsSupported
options
TB,R,GareRasterOrderGroupsSupported
pipelineOptions
TB,R,GisClampToHalfBorderSupported
prepareForUsage
TB,R,GisDepth24Stencil8PixelFormatSupported
purgeableStateValidForRendering
TB,R,GisFloat32FilteringSupported
release
TB,R,GisHeadless
resourceOptions
TB,R,GisLowPower
segment
TB,R,GisMsaa32bSupported
serializeAccelerationStructure:toBuffer:serializedBufferOffset:
TB,R,GisQuadDataSharingSupported
setArrayLength:
TB,R,GisRTZRoundingSupported
setComputePipelineStateBuffers:
TB,R,N
setErrorReason:
TB,R,N,V_isLinearTexture
setGPUPriority:
TB,R,V_storeValidationEnabled
setIndirectArgumentIndexStride:
TC,R,N,V_attachmentWriteMask
setMeshSamplerStates:withRange:
TI,R,N
setPixelFormat:
TI,R,N,V_frontStencilRef
setRenderPipelineState:atIndex:
setStatEnabled:
TQ,N,GgetStatLocations
setStoreAction:
TQ,N,V_callIndex
setTileSamplerStates:withRange:
TQ,N,V_offset
setVisibilityResultMode:offset:
TQ,R
storeComputePipelineDescriptor:
TQ,R,N
supportsBGR10A2
TQ,R,N,V_accelerationStructureHandle
supportsIndirectDrawAndDispatch
TQ,R,N,V_baseLevelOffset
supportsLargeFramebufferConfigs
TQ,R,N,V_bytesPerRow
supportsResourceUsageValidation
TQ,R,N,V_depthClipMode
supportsTextureOutOfBoundsReads
TQ,R,N,V_frontFacingWinding
supportsWritableArrayOfTextures
TQ,R,N,V_peakPerSampleStorage
synchronizeTexture:slice:level:
TQ,R,N,V_renderTargetArrayLength
texture
TQ,R,N,V_resolvedSampleCount
tileFunctionHandleWithFunction:
TQ,R,N,V_tessellationFactorBufferInstanceStride
unwrapMTLComputePassDescriptor:
TQ,R,N,V_visibilityResultMode
TQ,R,V_height
useHeaps:count:
TQ,R,V_stage
version
T^{?=BQ^{?}},R,N,V_imageFilterFunctionInfo
vertexArguments
Td,R
Tf,R
Tf,R,N
Tf,R,N,V_blendColorAlpha
Tf,R,N,V_blendColorBlue
Tf,R,N,V_blendColorGreen
Tf,R,N,V_blendColorRed
Tf,R,N,V_depthBias
Tf,R,N,V_depthBiasClamp
Tf,R,N,V_depthBiasSlopeScale
Tf,R,N,V_lineWidth
Tf,R,N,V_tessellationFactorScale
Ti,N,V_addressSpace
Ti,N,V_errorReason
Ti,N,V_operation
Ti,N,V_specifiedUsage
Ti,R,N
Ti,R,N,V_fragmentMaxCallStackDepth
Ti,R,N,V_maxCallStackDepth
Ti,R,N,V_meshMaxCallStackDepth
Ti,R,N,V_objectMaxCallStackDepth
Ti,R,N,V_tileMaxCallStackDepth
Ti,R,N,V_vertexMaxCallStackDepth
Tq,R
Tr^v,R,N,V_pointer
Tr^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ},R
Tr^{?=[32C]},R
Tr^{MTLTargetDeviceArch=QI*},R
T{?=BBQ@QQQQQBff},R,N,V_tessellationFactorBufferArgument
T{?=CCCC},R,N
T{?=QQQQ},R,N
T{?=QQQ},R
T{?=QQ},R
T{?=[2Q]},R
T{IndirectArgumentBufferCapabilities=b1b1b1b29},R
T{MTLResourceID=Q},R
T{_NSRange=QQ},N,V_range
T{_NSRange=QQ},R,N,V_baseSliceRangeOffset
T{_NSRange=QQ},R,N,V_resolveSliceRangeOffset
T{_NSRange=QQ},R,N,V_segment
URLForResource:withExtension:
UTF8String
_APITimingEnabled
_StatEnabled
_accelerationStructureComputePipelineState
_accelerationStructureHandle
_accelerationStructureIndices
_accelerationStructureLock
_activeThreadgroupMask
_addressSpace
_allocReportEntryStorageForType:
_amplificationMode
_amplificationValue
_aneIOSurface
_applyConstantRelocation
_applyConstantRelocation:
_applyImageIDRelocation:
_argument
_argumentBufferSamplers
_argumentDescriptors
_argumentEncoder
_argumentLayouts
_argumentLayoutsMutex
_argumentStorage
_attachmentSet
_attachmentTexture
_attachmentWriteMask
_baseLevelOffset
_baseObject
_baseResolveTexture
_baseSliceRangeOffset
_baseTexture
_binaryFunctionData
_blendColorAlpha
_blendColorGreen
_blendColorRed
_boundsCheckOptionsData
_bufferIndex
_bufferIndices
_bufferLock
_bufferUsageTable
_bufferUsageTables
_buffers
_bytesPerImage
_bytesPerRow
_callIndex
_checkReportBuffers
_checkerboardRTPipelineCache
_code
_colorPixelFormat
_commandBuffer
_commandBufferJumpNestingLevel
_commandByteStride
_commandIndex
_commandQueue
_commands
_completedHandlers
_computePipelineState
_constantDataBufferIndex
_constantDataKeyPair
_constantDataMutex
_cullMode
_currAttachments
_currentBuffer
_currentDepthStencil
_currentEncoderID
_currentOffset
_currentPipeline
_currentPooledBuffer
_currentPooledBufferOffset
_currentReportID
_data
_deadlineAwareState
_deadlineProfile
_debugBuf
_debugBuffer
_debugDevice
_debugInstrumentationData
_debugLocation
_debugMarkers
_debugType
_defaultDepthStencilDescriptor
_depthBias
_depthBiasSlopeScale
_depthClipMode
_depthPixelFormat
_depthStencilState
_desc
_descriptor
_descriptorAtIndex:
_descriptorPrivate
_deviceWrapper
_didAddRenderTargetAttachments
_didInvokeHandlers
_dirtyBits
_dispatchID
_dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
_drawOrDispatchIDBuffer
_enableResourceUsageValidation
_enableUseResourceValidation
_encodeReportBuffer:type:
_encodeResourceTableBuffers:type:
_encoderID
_encoderLabel
_encoderLabels
_encoderState
_encoderType
_encoders
_errorReason
_errorStackTrace
_externalReferences
_externallyRetainedObjects
_filePath
_findMasterStruct:includeImageBlockData:
_flags
_fragmentBufferUsageTable
_fragmentBuffers
_fragmentFunctionData
_fragmentHandles
_fragmentMaxCallStackDepth
_fragmentReportBuffer
_fragmentReportOffset
_fragmentSamplers
_fragmentStageActive
_fragmentTextureUsageTable
_fragmentTextures
_frontFacingWinding
_frontStencilRef
_function
_functionCount
_functionName
_functionType
_globalBuffer
_gpuIdentifier
_handleBuffer
_handlerLock
_handles
_hasCompute
_hasDeferredBindingObjectAndMeshReportBuffers
_hasRender
_heap
_iCB
_icbDepthStencilState
_icbInheritBothComputePipelineState
_icbInheritBuffersComputePipelineState
_icbInheritBuffersVertexPipelineState
_icbInheritNoneComputePipelineState
_icbInheritNoneVertexPipelineState
_icbInheritVertexPipelineState
_icbPipelineInit
_identifier
_image
_imageData
_imageFilterFunctionInfo
_imageFilterFunctions
_imageID
_imageType
_index
_indirectStateBuffer
_inheritsBuffers
_inheritsPipelineState
_init
_initBufferArgumentData:
_initConstantsBuffer:device:
_initImageData
_initWithCommandBuffer:
_initialized
_integrated
_internalReflection
_internallyRetainedObjects
_isContentExposedToCPU
_isLinearTexture
_isRender
_iterator
_kernelFunctionData
_keyRemoveList
_label
_lateInit
_lineWidth
_listLock
_loadValidationEnabled
_loadedImageName
_lock
_map
_maxCallStackDepth
_maxCommandCount
_maxCommands
_maxFragmentBindings
_maxInstanceCount
_maxKernelBindings
_maxMeshBindings
_maxObjectBindings
_maxPatchCount
_maxStageInGridOrigin
_maxStageInGridSize
_maxThreadIndexInThreadgroup
_maxThreadPositionInGrid
_maxThreadgroupBindings
_maxThreadgroupPositionInGrid
_maxThreadgroupsPerGrid
_maxThreadsPerGrid
_maxThreadsPerThreadgroup
_maxVertexBindings
_maxVertexBuffers
_mayContainDrawMeshes
_memorySize
_meshBuffers
_meshFunctionData
_meshHandles
_meshMaxCallStackDepth
_meshReportBuffer
_meshSamplers
_meshStageActive
_meshTextures
_meshThreadsPerTG
_modifyCompileOptions:
_modifyComputePipelineDescriptor:
_modifyMeshRenderPipelineDescriptor:
_modifyPluginData:
_modifyRenderPipelineDescriptor:
_modifyTilePipelineDescriptor:
_newComputePipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithDescriptor:options:reflection:error:
_newComputePipelineStateWithFunction:options:reflection:error:
_newGPUDebugAccelerationStructure:
_newRenderPipelineStateWithDescriptor:options:completionHandler:
_newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
_newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
_newRenderPipelineStateWithTileDescriptor:options:completionHandler:
_newRenderPipelineStateWithTileDescriptor:options:reflection:error:
_newReportBuffer
_newToolsBuffer:
_newToolsTexture:
_objectBuffers
_objectFunctionData
_objectHandles
_objectMaxCallStackDepth
_objectReportBuffer
_objectStageActive
_objectThreadsPerTG
_openGLModeEnabled
_operation
_optimizedRangeList
_options
_originalResourceOptions
_parentTexture
_peakPerSampleStorage
_perfHandlerLock
_perfSampleHandlerBlock
_perfSampleMailbox
_pipelineState
_pixelFormatInfo
_plane
_pointer
_prepareBinaryLinkedFunctions:
_prepareInsertLibraries:
_prevAttachments
_previousRenderPipelineStateWithWritesToImageBlock
_purgeableObjectsLock
_purgeableStateHasBeenSet
_purgeableStateToken
_range
_rasterSampleCount
_referenceTrackingCommandBufferLock
_referenceTrackingCommandBuffers
_referencedDeadObject
_referencedPurgeableObjects
_reflection
_reflectionParser
_relocations
_renderPipelineState
_renderTargetArrayLength
_renderTargetAttachmentLock
_renderTargetAttachments
_reportBuffer
_reportBufferList
_reportEntryList
_requester
_resolveLevelOffset
_resolveSliceRangeOffset
_resolvedRasterSampleCount
_resolvedSampleCount
_retainedFunctions
_retainedObjects
_retainedObjectsLock
_samplers
_samples
_scheduledHandlers
_scissorRects
_segment
_setDefaults
_setDeviceWrapper:
_setupCommon
_setupIdentifier
_stage
_stageArgumentEncoder
_stencilPixelFormat
_storageMode
_storeValidationEnabled
_storingRenderTargets
_supportsMeshStage
_supportsTileStage
_tempBufLock
_temporaryBufferWithLength:
_tessellationFactorBufferArgument
_tessellationFactorBufferInstanceStride
_tessellationFactorScale
_textureLock
_textureUsageTable
_textureUsageTables
_textures
_threadgroup
_threadgroupArgumentOffset
_threadgroupMemoryArguments
_threadgroupMemoryLengths
_tileBuffers
_tileFunctionData
_tileHandles
_tileMaxCallStackDepth
_tileReportBuffer
_tileSamplers
_tileStageActive
_tileStageUsed
_tileTextures
_timer
_timestamp
_toolsBuffer
_traceBuffer
_traceEncoder
_tracePath
_triangleFillMode
_type
_unknownStoreActions
_updateCachedMeshPipelineState
_updateCachedPipelineState
_updateCachedTilePipelineState
_updatedFences
_usageRequired
_useResourceCommon:usage:stages:
_useRetainedObjectsLock
_usedBuffers
_validateAllFunctionArguments
_validateAllFunctionArguments:
_validateThreadgroupSize:stage:context:
_vertexAmplificationCount
_vertexBufferUsageTable
_vertexBuffers
_vertexBuiltinArguments
_vertexComputeReportBuffer
_vertexComputeReportOffset
_vertexDescriptorLayoutCount
_vertexDescriptorLayouts
_vertexFunctionData
_vertexHandles
_vertexMaxCallStackDepth
_vertexReportBuffer
_vertexStageActive
_vertexTextureUsageTable
_viewports
_visibilityOffsets
_visibilityResultMode
_visibilityResultOffset
_width
accelerationStructureCommandEncoder
accelerationStructureCommandEncoderWithDescriptor:
accelerationStructureComputePipelineState
accelerationStructureHandle
accelerationStructureSizesWithDescriptor:
access
activeThreadgroupMask
addActiveRenderTargets:
addArchiveEntry:forKey:
addBinaryEntry:forKey:
addCompletedHandler:
addComputePipelineFunctionsWithDescriptor:error:
addComputePipelineFunctionsWithDescriptor:options:error:
addDebugMarker:range:
addFunctionWithDescriptor:library:error:
addMeshRenderPipelineFunctionsWithDescriptor:error:
addMeshRenderPipelineFunctionsWithDescriptor:options:error:
addObject:
addObject:retained:purgeable:
addObjectsFromArray:
addPerfSampleHandler:
addPurgeableObject:
addPurgedHeap:
addPurgedResource:
addReferenceTrackingCommandBuffer:
addReferencedObject:internallyRetained:
addRenderPipelineFunctionsWithDescriptor:error:
addRenderPipelineFunctionsWithDescriptor:options:error:
addRetainedObject:
addScheduledHandler:
addSplitHandler:
addTileRenderPipelineFunctionsWithDescriptor:error:
addTileRenderPipelineFunctionsWithDescriptor:options:error:
addUsedRenderTarget:slices:
additionalCompilerArguments
addressSpace
alignment
allObjects
allocatedSize
allocationID
allowGPUOptimizedContents
allowLibrariesFromOtherPlatforms
allowsNullBufferBinds
appendData:
appendSamples:length:
appendString:
architecture
archiveFunctionIds
areBarycentricCoordsSupported
areGPUAssertionsEnabled
areProgrammableSamplePositionsSupported
areRasterOrderGroupsSupported
argument
argumentBuffersSupport
argumentIndex
arguments
array
arrayLength
arrayType
arrayWithCapacity:
arrayWithObjects:count:
attachmentTexture
attachmentWriteMask
autorelease
availableCounters
availableCountersAndDict
backStencilRef
backgroundTrackingPID
barycentricCoordsSupported
base64EncodedDataWithOptions:
baseObject
baseResolveTexture
baseSliceRangeOffset
baseTexture
beginingEncoder:type:
binaryArchives
binaryData
binaryFunctionData
bindings
bitCodeHash
bitcodeData
blendColorBlue
blendColorRed
blitCommandEncoder
blitCommandEncoderWithDescriptor:
borderColor
borderColorSPI
boundingBoxBuffer
boundingBoxBufferOffset
boundingBoxBuffers
boundingBoxCount
boundingBoxStride
boundsCheckOptions
buffer
bufferAccessMask
bufferBytesPerRow
bufferDataSize
bufferHeap
bufferIndex
bufferOffset
bufferRobustnessSupport
bufferStructType
buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:
builtInArguments
builtInType
bundleWithIdentifier:
bytes
bytesPerImage
bytesPerRow
cStringUsingEncoding:
callIndex
canDealloc
canEndEncoding
canGenerateMipmapLevels
canSetComputePipelineState
checkEncoderState
class
clearBarrier
clearDepth
clearRenderEncoder:writeMask:withCheckerboard:
clearRetainedObjects
code
colorAttachments
colorSampleCount
commandBuffer
commandBufferErrorOptions
commandBufferWithDescriptor:
commandBufferWithUnretainedReferences
commandByteStride
commandQueue
commandQueueDescriptor
commandTypes
commit
commitAndHold
commitAndWaitUntilSubmitted
commitAndWaitUntilSubmittedWithDeadline:
commitQueue
commitSynchronously
commitWithDeadline:
common
compileOptions
compileVisibleFunction:withDescriptor:completionHandler:
compileVisibleFunction:withDescriptor:destinationBinaryArchive:error:
compileVisibleFunction:withDescriptor:error:
compilerPropagatesThreadPriority:
componentsJoinedByString:
componentsSeparatedByString:
compressionFeedback
compressionFootprint
computeCommandEncoder
computeCommandEncoderWithDescriptor:
computeCommandEncoderWithDispatchType:
computePipelineState
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
conformsToProtocol:
constantBlockAlignment
constantBufferCache
constantDataAtIndex:
constantDataBuffer
constantOffset
constantValues
containsResource:
contents
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
convertUserType:
copy
copyAccelerationStructure:toAccelerationStructure:
copyAndCompactAccelerationStructure:toAccelerationStructure:
copyConstantValues:
copyDebugMarkers
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromPixels:rowBytes:imageBytes:toSlice:mipmapLevel:origin:size:
copyFromSlice:mipmapLevel:origin:size:toPixels:rowBytes:imageBytes:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles:
copyParameterDataToBuffer:offset:
copyShaderCacheToPath:
count
countByEnumeratingWithState:objects:count:
counterInfo
counterSets
cpuCacheMode
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
cullMode
currentAllocatedSize
data
dataType
dataTypeDescription
dataWithBytesNoCopy:length:freeWhenDone:
debugBufferContentsWithLength:
debugCommandEncoder
debugDescription
debugDevice
debugInstrumentationData
debugLocation
debugLocationForID:
debugPipelineOptions:includePipelinePerfStats:
debugType
dedicatedMemorySize
defaultColorSampleCount
defaultDepthStencilDescriptor
defaultManager
defaultRasterSampleCount
depth
depth24Stencil8PixelFormatSupported
depthBias
depthBiasClamp
depthBiasSlopeScale
depthClipMode
depthCompareFunction
depthFailureOperation
depthStencilObjectCache
depthStencilPassOperation
depthStencilState
description
descriptor
descriptorPrivate
deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
deserializeCompileTimeStats:addToDictionary:
deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:
deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:
deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:
deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:
device
deviceCreationFlags
deviceLinearReadOnlyTextureAlignmentBytes
deviceLinearTextureAlignmentBytes
deviceOptions
deviceOrFeatureProfileSupportsFeatureSet:
deviceSupportsFeatureSet:
dictionary
dictionaryWithObjects:forKeys:count:
disableRunTimeCompilation
dispatchAvailableCompletionNotifications
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreadgroupsArguments
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
dispatchThreadsArguments
dispatchThreadsPerTile:
dispatchThreadsPerTile:inRegion:
dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
dispatchType
doesAliasAllResources:count:
doesAliasAnyResources:count:
doesAliasResource:
doubleFPConfig
drawArguments
drawIndexedArguments
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawIndexedPatchesArguments
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawMeshArguments
drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawPatchesArguments
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
dropResourceGroups:count:
dynamicLibrary
dynamicLibraryObjectCache
elementArrayType
elementIsArgumentBuffer
elementStructType
elementType
enableBarrier
enableNullBufferBinds:
encodeBuffers:offsets:withRange:resultOffset:
encodeCacheHintFinalize:resourceGroups:count:
encodeCacheHintTag:resourceGroups:count:
encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:
encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:
encodeDashboardTagForResourceGroup:
encodeEndDoWhile:offset:comparison:referenceValue:
encodeEndIf
encodeEndWhile
encodeSignalEvent:value:
encodeStartDoWhile
encodeStartIf:offset:comparison:referenceValue:
encodeStartWhile:offset:comparison:referenceValue:
encodeWaitForEvent:value:
encodeWaitForEvent:value:timeout:
encodedLength
encoderID
encoderIdentifierForEncoderIndex:
encoderLabel
endCollectingPipelineDescriptors
endEncoding
endEncodingAndRetrieveProgramAddressTable
endEncoding_private
endOfEncoderSampleIndex
endOfFragmentSampleIndex
endOfVertexSampleIndex
endingEncoder:type:
enumerateArchivesFromBackingFile:
enumerateArchivesFromPipelineCollection:
enumerateBufferIndices:
enumerateBuffersUsingBlock:
enumerateByteRangesUsingBlock:
enumerateFragmentBuffersUsingBlock:
enumerateFragmentSamplersUsingBlock:
enumerateFragmentTexturesUsingBlock:
enumerateSamplersUsingBlock:
enumerateTextureIndices:
enumerateTexturesUsingBlock:
enumerateThreadgroupMemoryLengthsUsingBlock:
enumerateThreadgroupMemoryUsingBlock:
enumerateTileSamplersUsingBlock:
enumerateTileTexturesUsingBlock:
enumerateVertexBuffersUsingBlock:
enumerateVertexSamplersUsingBlock:
enumerateVertexTexturesUsingBlock:
error
errorOptions
errorReason
errorWithDomain:code:userInfo:
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
executeCommandsInBuffer:withRange:
executeSynchronizationNotifications:
executeSynchronizationNotifications:scope:resources:count:
executionEnabled
explicitVisibilityGroupID
exportedFunctions
exportedVariables
externFunctionNames
extractDataAndNumSamples:forRequester:isLast:
familyName
featureProfile
filePath
fileSystemRepresentation
fillBuffer:range:pattern4:
fillBuffer:range:value:
fillTexture:level:slice:region:bytes:length:
fillTexture:level:slice:region:color:
fillTexture:level:slice:region:color:pixelFormat:
filterCounterRangeWithFirstBatch:lastBatch:filterIndex:
finalizeTextureMemory:
finish
firstMipmapInTail
flags
float32FilteringSupported
flushBindings
formattedDescription:
fragmentAdditionalBinaryFunctions
fragmentArguments
fragmentConstantsBuffer
fragmentDebugInstrumentationData
fragmentFunction
fragmentFunctionData
fragmentFunctionHandleWithFunction:
fragmentLinkedFunctions
fragmentMaxCallStackDepth
fragmentPreloadedLibraries
frontFaceStencil
frontFacingWinding
function
functionCache
functionConstantsDictionary
functionCount
functionHandle
functionHandleObjectCache
functionHandleToDebugFunctionHandle:parentFunction:
functionHandleToDebugFunctionHandle:parentFunction:stage:
functionHandleWithFunction:
functionHandleWithFunction:stage:
functionHandleWithFunction:stage:selector:
functionInputs
functionName
functionNames
functionObjectCache
functionPointers
functionType
functions
generateMipmapLevel:slice:
generateMipmapsForTexture:
geometryBuffer
geometryBufferOffset
geometryDescriptors
getArchiveDataForKey:
getArchiveIDWithError:
getBVHBuilderLock
getBackgroundGPUPriority
getBinaryDataForKey:
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
getCachedObjectForKey:
getCachedObjectForKey:onMiss:
getCommandType
getCompilerConnectionManager:
getDefaultSamplePositions:count:
getDepthStencilStateForBaseObject:descriptor:
getFragmentBufferAtIndex:
getFunctionForBaseObject:library:
getGPUPriority
getHeader:headerSize:
getImageBlockSize
getKernelBufferAtIndex:
getListIndex
getMeshBufferAtIndex:
getMostCompatibleArchitecture:
getObjectBufferAtIndex:
getOptimizedStatus
getParameter:
getPipelineStateUniqueIdentifier
getRawBVHBuilderPtr
getRequestedCounters
getSPIStats
getSamplerStateForBaseObject:descriptor:
getShaderCacheKeys
getStageInRegion
getStatLocations
getStatOptions
getSupportedCommandBufferErrorOptions
getTessellationFactorArguments
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
getThreadgroupMemoryLengthAtIndex:
getVertexBufferAtIndex:
globalBuffer
globalBufferHeap
globalBufferOffset
globalConstantsBuffer
globalConstantsData
globalICBBufferResidentList
globalTraceObjectID
gpuAddress
gpuAssertionsEnabled
gpuHandle
gpuIdentifier
gpuResourceID
groups
halfFPConfig
handleForOffset:
hasArgumentBufferInstrumentationFailures
hasArgumentLimitsInstrumentationFailures
hasBarrier
hasEndEncoding
hasEndedEncoding
hasGlobalConstantsInstrumentationFailures
hasIndirectSetStageInRegion
hasSetComputePipelineState
hasSetStageInRegion
hasUnifiedMemory
hash
hazardTrackingMode
headerBuffer
headerBufferOffset
headless
heap
heapAccelerationStructureSizeAndAlignWithDescriptor:
heapAccelerationStructureSizeAndAlignWithSize:
heapBufferSizeAndAlignWithLength:options:
heapOffset
heapTextureSizeAndAlignWithDescriptor:
height
image
imageBlockDataReturn
imageBlockMasterStructMembers
imageData
imageFilterFunctionInfo
imageFilterFunctions
imageType
imageblockMemoryLengthForDimensions:
imageblockSampleLength
importedLibraries
index
indexBuffer
indexBufferOffset
indexType
indirectArgumentBufferCapabilities
indirectArgumentBufferDecodingData
indirectArgumentIndex
indirectArgumentIndexStride
indirectCommandBuffer
indirectComputeCommandAtIndex:
indirectRenderCommandAtIndex:
indirectStateBuffer
inheritBuffers
inheritPipelineState
inheritsPipelineState
init
init:
init:flags:
initMetalScriptWithArchive:
initWithAccelerationStructure:device:
initWithAccelerationStructure:heap:
initWithAccelerationStructureCommandEncoder:parent:
initWithAccelerationStructureCommandEncoder:parent:descriptor:
initWithArgumentEncoder:layout:device:
initWithArray:
initWithArrayLength:elementType:stride:pixelFormat:aluType:details:
initWithBaseObject:
initWithBaseObject:parallelRenderCommandEncoder:
initWithBaseObject:parent:
initWithBaseObject:parent:buffer:
initWithBaseObject:parent:function:
initWithBaseObject:parent:function:stage:
initWithBaseObject:parent:parentTexture:
initWithBaseObject:structType:parent:
initWithBaseRenderPass:commandBuffer:descriptor:
initWithBaseTexture:device:
initWithBaseTexture:device:buffer:offset:bytesPerRow:
initWithBaseTexture:device:buffer:offset:bytesPerRow:bytesPerImage:
initWithBaseTexture:device:plane:
initWithBaseTexture:device:texture:
initWithBaseTexture:device:texture:pixelFormat:
initWithBaseTexture:device:texture:pixelFormat:textureType:levels:slices:
initWithBaseTexture:heap:device:
initWithBaseTextureLayout:device:descriptor:
initWithBinaryArchive:device:
initWithBlitCommandEncoder:commandBuffer:descriptor:
initWithBlitCommandEncoder:parent:descriptor:
initWithBlitCommandEncoder:parent:descriptor:encoderID:
initWithBuffer:device:
initWithBuffer:device:bytes:options:
initWithBuffer:device:offset:length:
initWithBuffer:device:offset:length:track:
initWithBuffer:device:options:
initWithBuffer:heap:device:
initWithBuffer:heap:device:offset:length:track:
initWithBuffer:heap:device:options:
initWithBytesNoCopy:length:freeWhenDone:
initWithCapacity:
initWithCommandBuffer:commandQueue:descriptor:
initWithCommandBuffer:parent:descriptor:
initWithCommandQueue:device:
initWithComputeCommandEncoder:commandBuffer:descriptor:
initWithComputeCommandEncoder:commandBuffer:descriptor:encoderID:
initWithComputeCommandEncoder:parent:descriptor:
initWithComputeCommandEncoder:parent:encoderID:
initWithComputePipelineState:binaryFunctions:withState:device:
initWithComputePipelineState:descriptor:unwrappedDescriptor:reflection:device:
initWithComputePipelineState:reflection:parent:descriptor:
initWithCounterSampleBuffer:device:descriptor:
initWithDebugLocation:
initWithDepthStencilState:descriptor:device:
initWithDesc:renderTargetArrayLength:
initWithDictionary:
initWithDynamicLibrary:
initWithDynamicLibrary:device:
initWithFunction:
initWithFunction:debugInstrumentationData:
initWithFunction:library:
initWithFunctionHandle:computePiplineState:function:
initWithFunctionHandle:renderPipelineState:stage:function:
initWithHeap:device:
initWithIndirectCommandBuffer:descriptor:maxCommandCount:resourceOptions:device:
initWithIndirectCommandBuffer:device:descriptor:maxCommandCount:options:
initWithIndirectComputeCommand:commandIndex:indirectCommandBuffer:
initWithIndirectRenderCommand:commandIndex:indirectCommandBuffer:
initWithIntersectionFunctionTable:device:descriptor:
initWithIntersectionFunctionTable:device:descriptor:computePipelineState:
initWithIntersectionFunctionTable:device:descriptor:renderPipelineState:
initWithIntersectionFunctionTable:parent:descriptor:pipelineState:stage:
initWithIntersectionFunctionTable:parent:descriptor:stage:
initWithKeyOptions:valueOptions:capacity:
initWithLibrary:device:
initWithLibrary:parent:filePath:
initWithLibrary:parent:type:code:options:
initWithName:offset:dataType:pixelFormat:aluType:indirectArgumentIndex:render_target:raster_order_group:details:
initWithName:type:access:isActive:locationIndex:dataType:pixelFormat:aluType:dataSize:alignment:
initWithObjectData:meshData:fragmentData:device:options:flags:
initWithObjects:
initWithParallelRenderCommandEncoder:parent:descriptor:
initWithParallelRenderCommandEncoder:parent:descriptor:encoderID:
initWithPipelineState:reflection:parent:descriptor:
initWithPipelineState:reflection:parent:meshDescriptor:
initWithPipelineState:reflection:parent:tileDescriptor:
initWithRenderCommandEncoder:commandBuffer:descriptor:encoderID:
initWithRenderCommandEncoder:parallelEncoder:encoderID:
initWithRenderCommandEncoder:parallelRenderCommandEncoder:descriptor:
initWithRenderCommandEncoder:parent:
initWithRenderCommandEncoder:parent:descriptor:
initWithRenderPipelineState:descriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
initWithRenderPipelineState:meshDescriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
initWithRenderPipelineState:tileDescriptor:reflection:device:
initWithRenderPipelineState:vertexBinaryFunctions:fragmentBinaryFunctions:tileBinaryFunctions:objectBinaryFunctions:meshBinaryFunctions:withState:device:
initWithResourceStateCommandEncoder:commandBuffer:descriptor:
initWithResourceStateCommandEncoder:parent:descriptor:
initWithSamplerState:descriptor:device:
initWithSerializedData:serializedStageInputDescriptor:device:options:flags:
initWithSymbolName:buffer:offset:
initWithSymbolName:bytes:length:
initWithTexture:heap:device:
initWithTextureView:parentBuffer:heap:device:
initWithTextureView:parentTexture:heap:device:
initWithTileData:functionType:device:options:flags:
initWithUTF8String:
initWithVersion:
initWithVertexData:fragmentData:serializedVertexDescriptor:device:options:flags:
initWithVisibleFunctionTable:descriptor:computePipeline:
initWithVisibleFunctionTable:descriptor:device:
initWithVisibleFunctionTable:descriptor:renderPipeline:
initWithVisibleFunctionTable:parent:descriptor:pipelineState:stage:
initWithVisibleFunctionTable:parent:descriptor:stage:
initializeTextureMemory:
inlinedAt
innerNodeBufferOffset
inputPrimitiveTopology
insertData:andNumSamples:forRequester:
insertDebugCaptureBoundary
insertDebugSignpost:
insertObject:atIndex:
installName
instanceCount
instanceDescriptorBuffer
instanceDescriptorBufferOffset
instanceDescriptorStride
instanceDescriptorType
instanceTransformBuffer
instanceTransformBufferOffset
integrated
internalArrayTypeFromUserArrayType:
internalDrawOrDispatchIDBuffer
internalICBBuffer
internalReflection
internalStructTypeFromUserStructType:
internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
intersectsTexture:
invalidateCompressedTexture:
invalidateCompressedTexture:slice:level:
invokeCompletedHandlers
invokeScheduledHandlers
iosurface
iosurfacePlane
iosurfaceReadOnlyTextureAlignmentBytes
iosurfaceTextureAlignmentBytes
isActive
isAliasable
isAlphaToCoverageEnabled
isAncestorOf:
isAnisoSampleFixSupported
isClampToHalfBorderSupported
isCommitted
isCompatibleWithAccelerationStructure:
isComplete
isCompressed
isContentExposedToCPU
isCustomBorderColorSupported
isDepth24Stencil8PixelFormatSupported
isDepthWriteEnabled
isDrawable
isEqual:
isFileURL
isFixedLinePointFillDepthGradientSupported
isFloat32FilteringSupported
isFramebufferOnly
isHeadless
isImageBlockLayoutInputCompatibleWithOutputOf:
isIntegrated
isKindOfClass:
isLargeMRTSupported
isLowPower
isMemberOfClass:
isMemorylessRender
isMeshShaderPipeline
isMsaa32bSupported
isOpenGLQueue
isPlacementHeapSupported
isProfilingEnabled
isPurgeable
isQuadDataSharingSupported
isRGB10A2GammaSupported
isRTZRoundingSupported
isRasterizationEnabled
isRemovable
isSparse
isStatEnabled
isStructLayoutThreadSafeWith:
isSubclassOfClass:
isTracked
kernelEndTime
kernelFunctionData
keys
label
largeMRTSupported
layerCount
layerPointer:
layout
leafNodeBuffer
leafNodeBufferOffset
length
lengthOfBytesUsingEncoding:
libraries
libraryCacheStats
libraryIdentifier
libraryPath
libraryUUID
limits
lineNumber
lineWidth
linearTextureAlignmentBytes
linearTextureArrayAlignmentBytes
linearTextureArrayAlignmentSlice
listIndex
loadAction
loadDynamicLibrariesForComputeDescriptor:error:
loadDynamicLibrariesForComputeDescriptor:options:error:
loadDynamicLibrariesForFunction:insertLibraries:error:
loadDynamicLibrariesForFunction:insertLibraries:options:error:
loadValidationEnabled
localizedDescription
lockPurgeableObjects
lockPurgeableState
logs
lookupRecompiledBinaryArchive:
lowPower
magFilter
makeAliasable
mapPhysicalToScreenCoordinates:forLayer:
mapScreenToPhysicalCoordinates:forLayer:
mapShaderSampleBufferWithBuffer:capacity:size:
markAccelerationStructure:usage:stages:
markBuffer:usage:stages:
markHeap:stages:
markTexture:usage:stages:
maxAnisotropy
maxArgumentBufferSamplerCount
maxAvailableSizeWithAlignment:
maxCallStackDepth
maxColorAttachments
maxCommandBufferCount
maxCommands
maxComputeAttributes
maxComputeBuffers
maxComputeInlineDataSize
maxComputeLocalMemorySizes
maxComputeSamplers
maxComputeTextures
maxComputeThreadgroupMemory
maxComputeThreadgroupMemoryAlignmentBytes
maxConcurrentExecutingCompilationTasks
maxConstantBufferArguments
maxCustomSamplePositions
maxFenceInstances
maxFragmentBindings
maxFragmentBufferBindCount
maxFragmentBuffers
maxFragmentCallStackDepth
maxFragmentInlineDataSize
maxFragmentSamplers
maxFragmentTextures
maxFramebufferStorageBits
maxFunctionConstantIndices
maxIndirectBuffers
maxIndirectSamplers
maxIndirectSamplersPerDevice
maxIndirectTextures
maxInterpolatedComponents
maxKernelBindings
maxKernelBufferBindCount
maxLineWidth
maxMeshBufferBindCount
maxMeshCallStackDepth
maxObjectBindings
maxObjectBufferBindCount
maxObjectCallStackDepth
maxPointSize
maxPredicatedNestingDepth
maxRasterizationRateLayerCount
maxTessellationFactor
maxTextureBufferWidth
maxTextureDepth3D
maxTextureDimensionCube
maxTextureHeight2D
maxTextureHeight3D
maxTextureLayers
maxTextureWidth1D
maxTextureWidth2D
maxTextureWidth3D
maxThreadgroupMemoryLength
maxThreadsPerThreadgroup
maxTileBuffers
maxTileInlineDataSize
maxTotalComputeThreadsPerThreadgroup
maxTotalThreadsPerMeshThreadgroup
maxTotalThreadsPerObjectThreadgroup
maxTotalThreadsPerThreadgroup
maxVertexAmplificationCount
maxVertexAmplificationFactor
maxVertexAttributes
maxVertexBindings
maxVertexBufferBindCount
maxVertexBuffers
maxVertexCallStackDepth
maxVertexInlineDataSize
maxVertexSamplers
maxVertexTextures
maxViewportCount
maxVisibilityQueryOffset
mayContainDrawMeshes
memoryBarrierWithResources:count:
memoryBarrierWithResources:count:afterStages:beforeStages:
memoryBarrierWithScope:
memoryBarrierWithScope:afterStages:beforeStages:
memorySize
mergeAttachmentWriteMask:
meshAdditionalBinaryFunctions
meshArguments
meshConstantsBuffer
meshDebugInstrumentationData
meshDescriptor
meshFunction
meshFunctionData
meshLinkedFunctions
meshMaxCallStackDepth
meshPreloadedLibraries
meshShaderPipeline
meshThreadExecutionWidth
meshThreadgroupSizeIsMultipleOfThreadExecutionWidth
meshThreadsPerThreadgroup
metalAssertionsEnabled
minBufferNoCopyAlignmentBytes
minFactor
minFilter
minLinearTextureAlignmentForPixelFormat:
minTilePixels
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
mipFilter
mipmapLevelCount
modifyFunctionDescriptor:
motionEndTime
motionKeyframeCount
motionTransformBuffer
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
msaa32bSupported
mutability
mutableCopy
name
newAccelerationStructureWithBuffer:offset:
newAccelerationStructureWithBuffer:offset:resourceIndex:
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithDescriptor:offset:
newAccelerationStructureWithSize:
newAccelerationStructureWithSize:offset:
newAccelerationStructureWithSize:offset:resourceIndex:
newAccelerationStructureWithSize:resourceIndex:
newAccelerationStructureWithSize:withDescriptor:
newArgumentEncoderForBufferAtIndex:
newArgumentEncoderWithArguments:
newArgumentEncoderWithArguments:structType:
newArgumentEncoderWithBufferBinding:
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:
newArgumentEncoderWithBufferIndex:reflection:binaryArchives:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:binaryArchives:
newArgumentEncoderWithLayout:
newBinaryArchiveWithDescriptor:error:
newBinaryLibraryWithOptions:url:error:
newBufferWithBytes:length:options:
newBufferWithBytes:length:options:gpuAddress:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithDescriptor:
newBufferWithIOSurface:
newBufferWithLength:options:
newBufferWithLength:options:gpuAddress:
newBufferWithLength:options:offset:
newCommandQueueWithDescriptor:
newCommandQueueWithMaxCommandBufferCount:
newCompressedTextureViewWithPixelFormat:textureType:level:slice:
newComputePipelineDescriptorWithName:error:
newComputePipelineDescriptorWithSerializedData:deserializationContext:
newComputePipelineStateWithAdditionalBinaryFunctions:
newComputePipelineStateWithAdditionalBinaryFunctions:error:
newComputePipelineStateWithDescriptor:completionHandler:
newComputePipelineStateWithDescriptor:error:
newComputePipelineStateWithDescriptor:options:completionHandler:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newComputePipelineStateWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newComputePipelineStateWithName:options:reflection:error:
newCounterSampleBufferWithDescriptor:error:
newDagStringWithGraphs:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newDepthStencilStateWithDescriptor:
newDynamicLibrary:computeDescriptor:error:
newDynamicLibrary:error:
newDynamicLibraryWithDescriptor:error:
newDynamicLibraryWithURL:options:error:
newEvent
newExternFunctionWithName:
newFence
newFragmentIntersectionFunctionTableWithDescriptor:
newFragmentShaderDebugInfo
newFunctionWithDescriptor:completionHandler:
newFunctionWithDescriptor:destinationArchive:error:
newFunctionWithDescriptor:error:
newFunctionWithGLCoreIR:functionType:
newFunctionWithGLCoreIR:inputsDescription:functionType:
newFunctionWithGLESIR:functionType:
newFunctionWithGLESIR:inputsDescription:functionType:
newFunctionWithGLIR:functionType:
newFunctionWithGLIR:inputsDescription:functionType:
newFunctionWithName:
newFunctionWithName:constantValues:completionHandler:
newFunctionWithName:constantValues:error:
newFunctionWithName:constantValues:functionCache:error:
newFunctionWithName:constantValues:pipelineLibrary:completionHandler:
newFunctionWithName:constantValues:pipelineLibrary:error:
newFunctionWithPluginData:bitcodeType:
newHeapWithDescriptor:
newIndirectArgumentBufferLayoutWithStructType:
newIndirectArgumentEncoderWithArguments:
newIndirectArgumentEncoderWithLayout:
newIndirectCommandBufferWithDescriptor:maxCount:options:
newIndirectComputeCommandEncoderWithBuffer:
newIndirectRenderCommandEncoderWithBuffer:
newInternalBufferWithLength:options:
newIntersectionFunctionTableWithDescriptor:
newIntersectionFunctionTableWithDescriptor:selector:
newIntersectionFunctionTableWithDescriptor:stage:
newIntersectionFunctionTableWithDescriptor:withStage:selector:
newIntersectionFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:error:
newKernelDebugInfo
newLateEvalEvent
newLibraryWithCIFilters:imageFilterFunctionInfo:error:
newLibraryWithCIFiltersForComputePipeline:imageFilterFunctionInfo:error:
newLibraryWithDAG:functions:error:
newLibraryWithData:error:
newLibraryWithDescriptor:completionHandler:
newLibraryWithDescriptorSPI:error:
newLibraryWithFile:error:
newLibraryWithGraphs:functions:error:
newLibraryWithGraphsSPI:functions:error:
newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithSource:options:completionHandler:
newLibraryWithSource:options:error:
newLibraryWithStitchedDescriptor:completionHandler:
newLibraryWithStitchedDescriptor:error:
newLibraryWithStitchedDescriptorSPI:error:
newLibraryWithURL:error:
newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:
newMeshIntersectionFunctionTableWithDescriptor:
newObjectIntersectionFunctionTableWithDescriptor:
newPipelineDescriptorAtIndex:pipelineType:error:
newPipelineLibraryWithFilePath:error:
newProfileWithExecutionSize:
newRasterizationRateMapWithDescriptor:
newRenderPipelineDescriptorWithName:error:
newRenderPipelineDescriptorWithSerializedData:deserializationContext:
newRenderPipelineStateWithAdditionalBinaryFunctions:error:
newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithMeshDescriptor:completionHandler:
newRenderPipelineStateWithMeshDescriptor:error:
newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
newRenderPipelineStateWithName:options:reflection:error:
newRenderPipelineStateWithTileDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:error:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
newResourceGroupFromResources:count:
newSamplerStateWithDescriptor:
newSerializedComputeDataWithFlags:options:
newSerializedVertexDataWithFlags:options:error:
newSharedEvent
newSharedEventHandle
newSharedEventWithHandle:
newSharedEventWithMachPort:
newStageArgumentBuffer
newStageBufferArgumentEncoder
newStructTypeWithSerializedData:
newTextureLayoutWithDescriptor:isHeapOrBufferBacked:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:
newTextureWithBytesNoCopy:length:descriptor:deallocator:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
newTextureWithDescriptor:offset:
newTextureWithDescriptor:offset:bytesPerRow:
newTileIntersectionFunctionTableWithDescriptor:
newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:
newVertexIntersectionFunctionTableWithDescriptor:
newVertexShaderDebugInfo
newVisibleFunctionTableFromFragmentStageWithDescriptor:
newVisibleFunctionTableFromMeshStageWithDescriptor:
newVisibleFunctionTableFromObjectStageWithDescriptor:
newVisibleFunctionTableFromTileStageWithDescriptor:
newVisibleFunctionTableFromVertexStageWithDescriptor:
newVisibleFunctionTableWithDescriptor:
newVisibleFunctionTableWithDescriptor:selector:
newVisibleFunctionTableWithDescriptor:stage:
newVisibleFunctionTableWithDescriptor:stage:selector:
noCopy
normalizedCoordinates
notifyExternalReferencesNonZeroOnDealloc:
notifyListener:atValue:block:
notifyResourceReleasing:
notifySamplerStateDeallocated:
null
numFaces
numberWithFloat:
numberWithUnsignedInteger:
numberWithUnsignedLong:
numberWithUnsignedLongLong:
objectAtIndexedSubscript:
objectConstantsBuffer
objectDebugInstrumentationData
objectForKey:
objectForKeyedSubscript:
objectFunction
objectFunctionData
objectFunctionHandleWithFunction:
objectLinkedFunctions
objectMaxCallStackDepth
objectPreloadedLibraries
objectThreadExecutionWidth
objectThreadgroupSizeIsMultipleOfThreadExecutionWidth
objectThreadsPerThreadgroup
offset
onComputePipelineCreated:
onExecuteWithComputeEncoder:
onExecuteWithRenderEncoder:
onRenderPipelineCreated:
openGLModeEnabled
operation
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeIndirectCommandBuffer:withRange:
optimizedRangeList
originalObject
outputImageBlockData
overrideTriple
parallelRenderCommandEncoderWithDescriptor:
parameterBufferSizeAndAlign
parent
parentGPUAddress
parentGPUSize
parentRelativeLevel
parentRelativeSlice
parentTexture
patchControlPointCount
patchType
path
pathForResource:ofType:
peakPerSampleStorage
perPrimitiveDataBuffer
perPrimitiveDataBufferOffset
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
performanceStatistics
physicalGranularity
physicalSizeForLayer:
pipelineBinaries
pipelineCache
pipelineCacheStats
pipelineCollection
pipelineNames
pixelFormat
placementHeapSupported
plane
pluginData
pointerType
popDebugGroup
postCompletionHandlers
postScheduledHandlers
preCommit
preCompletionHandlers
preScheduledHandlers
precompiledOutput
preloadedLibraries
prepareForBinaryFunctionUsage
prepareForComputePipelineUsage
prepareForRenderPipelineUsage
presentDrawable:
presentDrawable:atTime:
presentDrawable:options:
primitiveBufferOffset
primitiveDataBuffer
primitiveDataBufferOffset
primitiveDataElementSize
primitiveDataStride
privateFunctions
productName
profilingEnabled
profilingResults
programmableSamplePositionsSupported
protectionOptions
qosLevel
quadDataSharingSupported
rAddressMode
range
rangeValue
rasterOrderGroupsSupported
rasterSampleCount
rasterizationEnabled
rasterizationRateMap
readMask
readWriteTextureSupport
readsDepth
readsStencil
realRootResource
recommendedMaxWorkingSetSize
recompilablePipelineCount
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
reflection
reflectionWithOptions:
reflectionWithOptions:binaryArchives:
reflectionWithOptions:completionHandler:
reflectionWithOptions:pipelineLibrary:
registryID
releaseReflection
relocations
removable
removeAllDebugMarkers
removeAllObjects
removeAllReferencedObjects:
removeKey:
removeObject:
removeObjectAtIndex:
removeObjectForKey:
removeReferenceTrackingCommandBuffer:
removeUsedRenderTarget:slices:
renderCommandEncoder
renderCommandEncoderWithDescriptor:
renderPipelineState
renderTargetArrayIndexType
renderTargetArrayLength
renderTargetHeight
renderTargetWidth
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
reportLeaks
requestCounters:
requestCounters:withIndex:
requireUsage:
requiresRaytracingEmulation
reserveGPUAddressRange:
reserveResourceIndicesForResourceType:indices:indexCount:
reset
resetAtIndex:
resetCommandsInBuffer:withRange:
resetTextureAccessCounters:region:mipLevel:slice:
resetUsingDescriptor:
resolveCounterRange:
resolveCounters:inRange:destinationBuffer:destinationOffset:
resolveLevelOffset
resolveSliceRangeOffset
resolveTexture
resolvedSampleCount
resourceIndex
resourcePatchingTypeForResourceType:
resourceStateCommandEncoder
resourceStateCommandEncoderWithDescriptor:
resourceUsageForBuffer:stage:
resourceUsageForTexture:stage:
respondsToSelector:
responsibleProcess
retain
retainCount
retainObjectsFromRenderPassDescriptor:
retainedReferences
returnType
rootResource
rotation
sAddressMode
sampleBuffer
sampleBufferAttachments
sampleCount
sampleCountersInBuffer:atSampleIndex:withBarrier:
sampleTimestamps:gpuTimestamp:
sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:
sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledRenderCommandEncoderWithProgramInfoBuffer:capacity:
samplerObjectCache
saveCommandBuffer:queue:profilingResults:
scissorRect
scissorRects
screenSize
self
serializeComputePipelineDescriptor:
serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:
serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:
serializeRenderPipelineDescriptor:
serializeStructType:
serializeStructType:version:
serializeToURL:error:
serializeToURL:options:error:
setAccelerationStructure:atBufferIndex:
setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setAccelerationStructure:atBufferIndex:stage:
setAccelerationStructure:atIndex:
setAccelerationStructures:withBufferRange:
setAccess:
setAddressSpace:
setAlphaTestReferenceValue:
setApplyFunctionConstants:
setArgument:
setArgumentBuffer:offset:
setArgumentBuffer:startOffset:arrayElement:
setArgumentBuffer:startOffset:elementIndex:
setBackgroundGPUPriority:
setBackgroundGPUPriority:offset:
setBackgroundTrackingPID:
setBarrier
setBaseObject:
setBinaryArchives:
setBinaryFunctions:
setBlendColorRed:green:blue:alpha:
setBoundingBoxBuffer:
setBuffer:
setBuffer:offset:atIndex:
setBuffer:offset:atIndex:forStage:commandIndex:
setBufferOffset:atIndex:
setBufferUsageTable:textureUsageTable:
setBufferUsageTable:textureUsageTable:forStage:
setBuffers:offsets:withRange:
setBytes:length:atIndex:
setCallIndex:
setClearColor:
setClearDepth:
setClearStencil:
setClipPlane:p2:p3:p4:atIndex:
setCode:
setColorResolveTexture:slice:depthPlane:level:atIndex:
setColorResolveTexture:slice:depthPlane:level:atIndex:yInvert:
setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:
setColorStoreAction:atIndex:
setColorStoreActionOptions:atIndex:
setCommandBufferErrorOptions:
setCommandDataCorruptModeSPI:
setCompileOptions:
setCompilerProcessesCount:
setCompletionQueue:
setComputeFunction:
setComputePipelineState:
setComputePipelineState:atIndex:
setComputePipelineStateBuffers:commandIndex:
setComputePipelineStates:withRange:
setConstantBlockAlignment:
setConstantData:
setConstantValue:type:atIndex:
setConstantValues:
setCullMode:
setDataType:
setDeadlineProfile:
setDebugInstrumentationData:
setDebugLocation:
setDebugType:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthClipMode:
setDepthClipModeSPI:
setDepthCompareFunction:
setDepthResolveTexture:slice:depthPlane:level:
setDepthResolveTexture:slice:depthPlane:level:yInvert:
setDepthStencilState:
setDepthStoreAction:
setDepthStoreActionOptions:
setDepthWriteEnabled:
setDescriptor:
setDisableRunTimeCompilation:
setEnableBarrier:
setEncoderLabel:
setErrorStackTrace:
setExecutionEnabled:
setFilePath:
setForceSoftwareVertexFetch:
setFragmentAccelerationStructure:atBufferIndex:
setFragmentAdditionalBinaryFunctions:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setFragmentBytes:length:atIndex:
setFragmentDebugInstrumentationData:
setFragmentFunction:
setFragmentIntersectionFunctionTable:atBufferIndex:
setFragmentIntersectionFunctionTables:withBufferRange:
setFragmentLinkedFunctions:
setFragmentPreloadedLibraries:
setFragmentSamplerState:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentSamplerStates:withRange:
setFragmentTexture:atIndex:
setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:
setFragmentTextures:withRange:
setFragmentVisibleFunctionTable:atBufferIndex:
setFragmentVisibleFunctionTables:withBufferRange:
setFrontFacingWinding:
setFunction:
setFunction:atIndex:
setFunctionName:
setFunctionPointers:
setFunctions:
setFunctions:withRange:
setGPUAssertionsEnabled:
setGPUPriority:offset:
setGeometryBuffer:
setGeometryBufferOffset:
setGlobalBuffer:
setGlobalBufferOffset:
setGroups:
setHeaderBuffer:
setHeaderBufferOffset:
setImage:
setImageBlockWidth:height:
setImageFilterFunctions:imageFilterFunctionInfo:
setImageblockWidth:height:
setIndex:
setIndirectArgumentBufferDecodingData:
setIndirectCommandBuffer:atIndex:
setIndirectCommandBuffers:withRange:
setInheritBuffers:
setInnerNodeBuffer:
setInnerNodeBufferOffset:
setInstanceDescriptorBuffer:
setInstanceTransformBuffer:
setInstanceTransformBufferOffset:
setIntersectionFunctionTable:atBufferIndex:
setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTable:atBufferIndex:stage:
setIntersectionFunctionTable:atIndex:
setIntersectionFunctionTables:withBufferRange:
setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTables:withBufferRange:stage:
setIntersectionFunctionTables:withRange:
setIsContentExposedToCPU:
setKernelReportBuffer:offset:
setLabel:
setLeafNodeBuffer:
setLeafNodeBufferOffset:
setLength:
setLibraries:
setLibrary:
setLineWidth:
setLinkedFunctions:
setLoadAction:
setLogs:
setMaxAnisotropy:
setMaxCommandBufferCount:
setMaxFragmentBufferBindCount:
setMaxKernelBufferBindCount:
setMaxVertexBufferBindCount:
setMembers:count:
setMeshAccelerationStructure:atBufferIndex:
setMeshAdditionalBinaryFunctions:
setMeshBuffer:offset:atIndex:
setMeshBufferOffset:atIndex:
setMeshBuffers:offsets:withRange:
setMeshBytes:length:atIndex:
setMeshDebugInstrumentationData:
setMeshFunction:
setMeshIntersectionFunctionTable:atBufferIndex:
setMeshIntersectionFunctionTables:withBufferRange:
setMeshLinkedFunctions:
setMeshPreloadedLibraries:
setMeshReportBuffer:offset:
setMeshSamplerState:atIndex:
setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setMeshTexture:atIndex:
setMeshTextures:withRange:
setMeshVisibleFunctionTable:atBufferIndex:
setMeshVisibleFunctionTables:withBufferRange:
setMetalAssertionsEnabled:
setMotionTransformBuffer:
setName:
setObject:atIndexedSubscript:
setObject:forKey:
setObject:forKeyedSubscript:
setObjectAccelerationStructure:atBufferIndex:
setObjectAdditionalBinaryFunctions:
setObjectBufferOffset:atIndex:
setObjectBuffers:offsets:withRange:
setObjectBytes:length:atIndex:
setObjectDebugInstrumentationData:
setObjectFunction:
setObjectIntersectionFunctionTable:atBufferIndex:
setObjectIntersectionFunctionTables:withBufferRange:
setObjectLinkedFunctions:
setObjectPreloadedLibraries:
setObjectReportBuffer:offset:
setObjectSamplerState:atIndex:
setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setObjectSamplerStates:withRange:
setObjectTexture:atIndex:
setObjectTextures:withRange:
setObjectThreadgroupMemoryLength:atIndex:
setObjectVisibleFunctionTable:atBufferIndex:
setObjectVisibleFunctionTables:withBufferRange:
setOffset:
setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:
setOpaqueTriangleIntersectionFunctionWithSignature:withRange:
setOperation:
setOriginalObject:
setOverrideTriple:
setOwnerWithIdentity:
setParentGPUAddress:
setParentGPUSize:
setPerPrimitiveDataBuffer:
setPerPrimitiveDataBufferOffset:
setPerformanceStatistics:
setPipelineLibrary:
setPipelineOptions:
setPluginData:
setPointSize:
setPreloadedLibraries:
setPrimitiveBuffer:
setPrimitiveBufferOffset:
setPrimitiveDataBuffer:
setPrimitiveRestartEnabled:
setPrimitiveRestartEnabled:index:
setPrivateFunctions:
setProfilingEnabled:
setProtectionOptions:
setProvokingVertexMode:
setPurgeableState:
setRange:
setRasterizationEnabled:
setRasterizationRateMap:
setRawBVHBuilderPtr:
setReadMask:
setRenderPipelineState:
setRenderPipelineStateBuffers:
setRenderPipelineStateBuffers:commandIndex:
setRenderPipelineStates:withRange:
setResolveTexture:
setResourceGroups:count:
setResponsibleProcess:
setRetainedReferences:
setSampleBuffer:
setSamplerState:atIndex:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setSamplerStates:withRange:
setScissorRects:count:
setSeparateCommits:
setShaderDebugInfoCaching:
setShaderValidationEnabled:
setSignaledValue:
setSkipRender:
setSpecifiedUsage:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
setStatLocations:
setStencilCleared
setStencilFrontReferenceValue:backReferenceValue:
setStencilReferenceValue:
setStencilResolveTexture:slice:depthPlane:level:
setStencilResolveTexture:slice:depthPlane:level:yInvert:
setStencilStoreAction:
setStencilStoreActionOptions:
setStoreActionOptions:
setStructType:withDevice:
setSubmissionQueue:
setSupportIndirectCommandBuffers:
setTessellationControlPointIndexBuffer:offset:
setTessellationControlPointIndexBuffer:offset:commandIndex:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorScale:
setTexture:
setTexture:atIndex:
setTextures:withRange:
setThreadgroupDistributionModeWithClusterGroupIndex:
setThreadgroupMemoryLength:atIndex:
setThreadgroupMemoryLength:atIndex:commandIndex:
setThreadgroupMemoryLength:offset:atIndex:
setThreadgroupPackingDisabled:
setTileAccelerationStructure:atBufferIndex:
setTileAdditionalBinaryFunctions:
setTileBuffer:offset:atIndex:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
setTileBytes:length:atIndex:
setTileDebugInstrumentationData:
setTileFunction:
setTileIntersectionFunctionTable:atBufferIndex:
setTileIntersectionFunctionTables:withBufferRange:
setTileReportBuffer:offset:
setTileSamplerState:atIndex:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setTileTexture:atIndex:
setTileTextures:withRange:
setTileVisibleFunctionTable:atBufferIndex:
setTileVisibleFunctionTables:withBufferRange:
setTransformFeedbackState:
setTransformationMatrixBuffer:
setTriangleFillMode:
setTriangleFrontFillMode:backFillMode:
setType:
setUseRetainedObjectsLock:
setValue:atIndex:
setValue:forKey:
setValue:withRange:
setVertexAccelerationStructure:atBufferIndex:
setVertexAdditionalBinaryFunctions:
setVertexAmplificationCount:viewMappings:
setVertexAmplificationMode:value:
setVertexBuffer:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setVertexBytes:length:atIndex:
setVertexDebugInstrumentationData:
setVertexFunction:
setVertexIntersectionFunctionTable:atBufferIndex:
setVertexIntersectionFunctionTables:withBufferRange:
setVertexLinkedFunctions:
setVertexPreloadedLibraries:
setVertexReportBuffer:offset:
setVertexSamplerState:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setVertexSamplerStates:withRange:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setVertexVisibleFunctionTable:atBufferIndex:
setVertexVisibleFunctionTables:withBufferRange:
setViewport:
setViewportTransformEnabled:
setViewports:count:
setVisibilityResultBuffer:
setVisibleFunctionTable:atBufferIndex:
setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setVisibleFunctionTable:atBufferIndex:stage:
setVisibleFunctionTable:atIndex:
setVisibleFunctionTables:withBufferRange:
setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setVisibleFunctionTables:withBufferRange:stage:
setVisibleFunctionTables:withRange:
setWriteMask:
setupMPSFunctionTable:
shaderDebugInfoCaching
shaderValidationEnabled
sharedMemorySize
signaledValue
simulatorHostFeatureProfile
singleFPConfig
size
skipRender
snapshotPerfSampleHandlerAndStatEnabled:forCommandBuffer:
sortedArrayUsingComparator:
sourceLibraryObjectCache
sparseSurfaceDefaultValue
sparseTexturesSupport
sparseTileSizeInBytes
sparseTileSizeInBytesForSparsePageSize:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:
specifiedUsage
stage
stageInRegion
stageInputAttributes
startCollectingPipelineDescriptors
startCollectingPipelineDescriptorsUsingPrefixForNames:
startOfEncoderSampleIndex
startOfFragmentSampleIndex
startOfVertexSampleIndex
staticThreadgroupMemoryLength
status
stencilAttachment
stencilCompareFunction
stencilFailureOperation
storageMode
storeAction
storeMeshRenderPipelineDescriptor:
storeRenderPipelineDescriptor:
storeTileRenderPipelineDescriptor:
storeValidationEnabled
stride
string
stringByPaddingToLength:withString:startingAtIndex:
stringByStandardizingPath
stringForID:
stringWithFormat:
stringWithUTF8String:
strongParent
structType
subdivideCounterList:
superclass
supportAddingBinaryFunctions
supportAddingFragmentBinaryFunctions
supportAddingMeshBinaryFunctions
supportAddingObjectBinaryFunctions
supportAddingVertexBinaryFunctions
supportArgumentBuffers
supportIndirectCommandBuffers
supportPriorityBand
supports2DLinearTexArraySPI
supports32BitFloatFiltering
supports32BitMSAA
supports32bpcMSAATextures
supports3DASTCTextures
supports3DBCTextures
supportsASTCHDRTextureCompression
supportsASTCTextureCompression
supportsAlphaYUVFormats
supportsAnisoSampleFix
supportsArgumentBuffersTier2
supportsArrayOfSamplers
supportsArrayOfTextures
supportsAtomicUlongVoidMinMax
supportsBCTextureCompression
supportsBaseVertexInstanceDrawing
supportsBfloat16Format
supportsBinaryArchives
supportsBinaryLibraries
supportsBlackOrWhiteSamplerBorderColors
supportsBufferBoundsChecking
supportsBufferPrefetchStatistics
supportsBufferWithIOSurface
supportsBufferlessClientStorageTexture
supportsCMPIndirectCommandBuffers
supportsCombinedMSAAStoreAndResolveAction
supportsCommandBufferJump
supportsCompressedTextureViewSPI
supportsComputeCompressedTextureWrite
supportsComputeMemoryBarrier
supportsConcurrentComputeDispatch
supportsCounterSampling:
supportsCountingOcclusionQuery
supportsCustomBorderColor
supportsDeadlineProfile
supportsDepthClipMode
supportsDepthClipModeClampExtended
supportsDevicePartitioning
supportsDynamicControlPointCount
supportsDynamicLibraries
supportsExplicitVisibilityGroups
supportsExtendedVertexFormats
supportsExtendedXR10Formats
supportsExtendedYUVFormats
supportsFP32TessFactors
supportsFastMathInfNaNPropagation
supportsFeatureSet:
supportsFillTexture
supportsFixedLinePointFillDepthGradient
supportsFloat16BCubicFiltering
supportsFloat16InfNanFiltering
supportsForceSeamsOnCubemaps
supportsForkJoin
supportsFragmentBufferWrites
supportsFragmentOnlyEncoders
supportsFunctionPointers
supportsFunctionPointersFromMesh
supportsFunctionPointersFromRender
supportsGFXIndirectCommandBuffers
supportsGPUStatistics
supportsGlobalVariableRelocation
supportsGlobalVariableRelocationCompute
supportsGlobalVariableRelocationRender
supportsHeapAccelerationStructureAllocation
supportsIABHashForTools
supportsImageBlockSampleCoverageControl
supportsImageBlocks
supportsIndirectStageInRegion
supportsIndirectTessellation
supportsIndirectTextures
supportsIndirectWritableTextures
supportsInt64
supportsInterchangeTiled
supportsLateEvalEvent
supportsLayeredRendering
supportsLimitedYUVFormats
supportsLinearTexture2DArray
supportsLinearTextureFromSharedBuffer
supportsLossyCompression
supportsMSAADepthResolve
supportsMSAADepthResolveFilter
supportsMSAAStencilResolve
supportsMSAAStencilResolveFilter
supportsMemoryOrderAtomics
supportsMeshShaders
supportsMeshShadersInICB
supportsMipLevelsSmallerThanBlockSize
supportsMirrorClampToEdgeSamplerMode
supportsMutableTier1ArgumentBuffers
supportsNativeHardwareFP16
supportsNonPrivateDepthStencilTextures
supportsNonPrivateMSAATextures
supportsNonSquareTileShaders
supportsNonUniformThreadgroupSize
supportsNonZeroTextureWriteLOD
supportsNorm16BCubicFiltering
supportsOpenCLTextureWriteSwizzles
supportsPacked32TextureBufferWrites
supportsPipelineLibraries
supportsPlacementHeaps
supportsPostDepthCoverage
supportsPrimitiveMotionBlur
supportsPrimitiveRestartOverride
supportsPrimitiveType:
supportsProgrammableBlending
supportsProgrammableSamplePositions
supportsPublicXR10Formats
supportsPullModelInterpolation
supportsQuadGroup
supportsQuadReduction
supportsQuadShufflesAndBroadcast
supportsQueryTextureLOD
supportsRGBA10A2Gamma
supportsRTZRounding
supportsRasterOrderGroups
supportsRasterOrderGroupsColorAttachment
supportsRasterizationRateMapWithLayerCount:
supportsRayTracingAccelerationStructureCPUDeserialization
supportsRayTracingBuffersFromTables
supportsRayTracingExtendedVertexFormats
supportsRayTracingICBs
supportsRayTracingPerPrimitiveData
supportsRaytracing
supportsRaytracingFromRender
supportsReadWriteBufferArguments
supportsReadWriteTextureArguments
supportsReadWriteTextureArgumentsTier2
supportsReadWriteTextureCubeArguments
supportsRelaxedTextureViewRequirements
supportsRenderDynamicLibraries
supportsRenderMemoryBarrier
supportsRenderPassWithoutRenderTarget
supportsRenderTargetTextureRotation
supportsRenderTextureWrites
supportsRenderToLinearTextures
supportsSIMDGroup
supportsSIMDGroupMatrix
supportsSIMDReduction
supportsSIMDShuffleAndFill
supportsSIMDShufflesAndBroadcast
supportsSRGBwrites
supportsSampleCount:
supportsSamplerAddressModeClampToHalfBorder
supportsSamplerCompareFunction
supportsSeparateDepthStencil
supportsSeparateVisibilityAndShadingRate
supportsSetThreadgroupPackingDisabled
supportsShaderBarycentricCoordinates
supportsShaderLODAverage
supportsShaderMinLODClamp
supportsSharedFunctionTables
supportsSharedStorageHeapResources
supportsSharedStorageTextures
supportsSharedTextureHandles
supportsSparseDepthAttachments
supportsSparseHeaps
supportsSparseTextures
supportsStackOverflowErrorCode
supportsStatefulDynamicLibraries
supportsStencilFeedback
supportsTLS
supportsTessellation
supportsTexture2DMultisampleArray
supportsTextureCubeArray
supportsTextureSampleCount:
supportsTextureSwizzle
supportsTextureWriteFPRoundingMode:
supportsTextureWriteRoundingMode:
supportsTileShaders
supportsUnalignedVertexFetch
supportsVariableRateRasterization
supportsVertexAmplification
supportsVertexAmplificationCount:
supportsYCBCRFormats
supportsYCBCRFormats12
supportsYCBCRFormatsPQ
supportsYCBCRFormatsXR
supportsYCBCRPackedFormats12
supportsYCBCRPackedFormatsPQ
supportsYCBCRPackedFormatsXR
swizzleKey
symbolName
synchronizeResource:
tAddressMode
tailSize
targetDeviceArchitecture
targetDeviceInfo
temporaryBufferWithBytes:length:
temporaryBufferWithLength:
tessellationControlPointIndexType
tessellationFactorBufferArgument
tessellationFactorBufferInstanceStride
tessellationFactorFormat
tessellationFactorScale
tessellationFactorStepFunction
testObjectReferenced:wasInternallyRetained:
textureBarrier
textureType
textureWriteRoundingMode
threadExecutionWidth
threadGroupSizeIsMultipleOfThreadExecutionWidth
threadgroupArgumentOffset
threadgroupMemoryDataSize
threadgroupMemoryLength
threadgroupSizeMatchesTileSize
tileAdditionalBinaryFunctions
tileArguments
tileConstantsBuffer
tileDebugInstrumentationData
tileDescriptor
tileFunction
tileFunctionData
tileHeight
tileMaxCallStackDepth
tileWidth
traceBuffer
tracePath
transformationMatrixBuffer
transformationMatrixBufferOffset
triangleCount
triangleFillMode
type
underlyingGPUAddress
unfilteredResourceOptions
unionSet:
uniqueIdentifier
unloadShaderCaches
unlockPurgeableObjects
unlockPurgeableState
unmapShaderSampleBuffer
unpackedFilePath
unsignedIntegerValue
unwrapAndModifyComputePipelineDescriptor:options:
unwrapAndModifyMeshRenderPipelineDescriptor:options:
unwrapAndModifyRenderPipelineDescriptor:options:
unwrapAndModifyTileRenderPipelineDescriptor:options:
unwrapBinaryFunctions:
unwrapMTLAccelerationStructurePassDescriptor:
unwrapMTLBlitPassDescriptor:
unwrapMTLCommandBufferDescriptor:alwaysCopy:
unwrapMTLCompileOptions:
unwrapMTLComputePassDescriptorInternal:
unwrapMTLComputePipelineDescriptor:
unwrapMTLDynamicLibraryDescriptorSPI:
unwrapMTLFunctionDescriptor:
unwrapMTLMeshRenderPipelineDescriptor:
unwrapMTLRelocations:
unwrapMTLRenderPassDescriptor:
unwrapMTLRenderPipelineDescriptor:
unwrapMTLResourceStatePassDescriptor:
unwrapMTLStitchedLibraryDescriptor:
unwrapMTLTileRenderPipelineDescriptor:
unwrapStitchedLibraryDescriptor:
updateFence:
updateFence:afterStages:
updatePipelineData
updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:
updateTextureMapping:mode:region:mipLevel:slice:
updatedFences
usage
useHeap:
useHeaps:count:stages:
useRenderPipelineState:
useRenderPipelineStates:count:
useResource:usage:
useResource:usage:stages:
useResourceGroup:usage:
useResourceGroup:usage:stages:
useResourceInternal:usage:
useResourceInternal:usage:stages:
useResourceIteration
useResources:count:usage:
useResources:count:usage:stages:
useRetainedObjectsLock
useWithComputeEncoder:usage:
useWithRenderEncoder:usage:stages:
usedSize
userDictionary
userReflection
userReflectionData
validate:width:height:
validateBinaryFunctions:stage:
validateCPUReadable
validateCPUWriteable
validateCommandQueue:
validateCommonDrawErrors:
validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:
validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:move:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceSize:toTexture:destinationSlice:destinationLevel:options:sliceCount:levelCount:
validateDeadlineAwareness:
validateDescriptor:expectedClass:
validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:
validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:
validateDynamicLibrary:state:error:
validateDynamicLibraryDescriptor:error:
validateDynamicLibraryURL:error:
validateFramebufferWithRenderPipelineState:context:
validateFunctionTableUseResource:selectorName:
validateFunctionTableUseResource:stages:context:selectorName:
validateHandleForSetFunction:
validateHeapResourceOptions:isTexture:isIOSurface:context:
validateHeapTextureUsage:options:context:
validateLinkedFunctions:context:
validateMemorylessResource:context:
validateNewBufferArgs:options:context:
validateOffset:withRequirements:
validatePixelFormatWithHeap:context:
validateRaytracing
validateRaytracingHeap
validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
validateResourceOptions:isTexture:isIOSurface:context:
validateSparseTextureMappingMode:
validateStageInRegion:
validateStoreLoadTransition:atIndex:renderTargetArrayLength:
validateTextureAccess:region:mipLevel:slice:
vendorName
vertexAttributes
vertexBuffer
vertexBufferOffset
vertexBuffers
vertexBuiltInArguments
vertexConstantsBuffer
vertexDebugInstrumentationData
vertexFormat
vertexFunction
vertexFunctionData
vertexFunctionHandleWithFunction:
vertexLinkedFunctions
vertexMaxCallStackDepth
vertexPreloadedLibraries
vertexStride
viewport
viewports
visibilityResultBuffer
visibilityResultMode
visibilityResultOffset
waitForFence:
waitForFence:beforeStages:
waitUntilComplete
waitUntilCompleted
waitUntilScheduled
waitUntilSignaledValue:timeoutMS:
watermark
width
willEncodeSignalEvent:value:writeableResources:
writeAccelerationStructureSerializationData:toBuffer:offset:
writeCompactedAccelerationStructureSize:toBuffer:offset:
writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:
writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:
writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:
writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:
writeGenericBVHStructureOfAccelerationStructure:into:
writeGenericBVHStructureSizesOfAccelerationStructure:into:
writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:
writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:
writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:
writeMask
writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:
writeToFile:options:error:
writesDepth
writesStencil
zone
@48@0:8@16@24Q32@40
Q16@0:8
@16@0:8
v16@0:8
v24@0:8@16
v40@0:8@16Q24Q32
v64@0:8{?=QQQ}16{?=QQQ}40
@"MTLIndirectCommandBufferDescriptor"
@"<MTLIndirectCommandBufferSPI>"
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@32@0:8r^v16Q24
@24@0:8Q16
I16@0:8
@"MTLGPUDebugBuffer"32@0:8r^v16Q24
@"MTLGPUDebugBuffer"24@0:8Q16
@44@0:8@16@24@32I40
@36@0:8@16@24I32
v32@0:8@16Q24
v40@0:8@16@24Q32
v32@0:8Q16Q24
v48@0:8r^@16r^Q24{_NSRange=QQ}32
v40@0:8r^v16Q24Q32
v40@0:8Q16Q24Q32
v40@0:8r^@16{_NSRange=QQ}24
v40@0:8Q16@24Q32
v48@0:8Q16Q24Q32Q40
v56@0:8Q16Q24Q32Q40Q48
v56@0:8Q16Q24Q32@40Q48
v64@0:8Q16Q24Q32@40Q48Q56
v64@0:8Q16Q24@32Q40@48Q56
v80@0:8Q16Q24Q32@40Q48Q56q64Q72
v56@0:8Q16@24Q32@40Q48
v72@0:8Q16Q24Q32@40Q48Q56Q64
v72@0:8Q16@24Q32@40Q48@56Q64
v88@0:8Q16Q24Q32@40Q48@56Q64Q72Q80
v40@0:8{?=QQQ}16
v88@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40
v92@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40I88
v88@0:8{?=QQQ}16{?=QQQ}40{?=QQQ}64
v80@0:8@16Q24{?=QQQ}32{?=QQQ}56
v40@0:8@16{_NSRange=QQ}24
v32@0:8Q16r^{?=II}24
v48@0:8@16Q24{optional<unsigned long>=(?=cQ)B}32
v40@0:8r^@16Q24Q32
v48@0:8r^@16Q24Q32Q40
v32@0:8r^@16Q24
@"MTLGPUDebugCommandBuffer"
{MTLGPUDebugStageBufferHandles="handles"[31Q]"resources"[31@"<MTLGPUDebugResource>"]"offsets"[31Q]"lengths"[31I]"gpu_address"[31[2Q]]"needsFlush"B}
{MTLGPUDebugTileThreadgroup="entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
^{Options=IiiiiI{?=b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1}}
{GPUDebugEventUUIDPacket="pipelineStateID"Q"entryPointImageID"Q"encoderID"I"eventID"I}
@"MTLGPUDebugRenderPipelineState"
@"MTLToolsDepthStencilState"
{MTLGPUDebugBufferSubAlloc="buffer"@"<MTLBuffer>""offset"Q}
{?="count"C"mappingsValid"B"mappings"[2{?="viewportArrayIndexOffset"I"renderTargetArrayIndexOffset"I}]}
@"<MTLBuffer>"
Q24@0:8Q16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v32@0:8{_NSRange=QQ}16
{MTLResourceID=Q}16@0:8
@"<MTLIndirectRenderCommand>"24@0:8Q16
@"<MTLIndirectComputeCommand>"24@0:8Q16
v32@0:8^^v16^Q24
@"<MTLFunction>"16@0:8
@"<MTLFunctionLogDebugLocation>"16@0:8
v24@0:8Q16
@"MTLGPUDebugImageData"
@"NSArray"
@"NSString"
@"<MTLFunction>"
@"<MTLFunctionLogDebugLocation>"
i16@0:8
v20@0:8i16
@"MTLArgument"
@"<MTLProgramAddressTable>"16@0:8
v136@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112
v120@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96
v128@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96Q120
v120@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112
v128@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112Q120
v44@0:8@16{_NSRange=QQ}24C40
v80@0:8@16Q24Q32@40Q48Q56Q64Q72
v32@0:8@16@24
v56@0:8@16Q24@32Q40Q48
v108@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@92Q100
v88@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80
v56@0:8@16{_NSRange=QQ}24@40Q48
v36@0:8@16Q24B32
v24@0:8@"<MTLResource>"16
v40@0:8@"<MTLTexture>"16Q24Q32
v136@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112
v120@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96
v128@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96Q120
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112
v128@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112Q120
v24@0:8@"<MTLTexture>"16
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24C40
v80@0:8@"<MTLTexture>"16Q24Q32@"<MTLTexture>"40Q48Q56Q64Q72
v32@0:8@"<MTLTexture>"16@"<MTLTexture>"24
v56@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40Q48
v24@0:8@"<MTLFence>"16
v108@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@"<MTLBuffer>"92Q100
v88@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80
v40@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24
v56@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24@"<MTLIndirectCommandBuffer>"40Q48
v36@0:8@"<MTLCounterSampleBuffer>"16Q24B32
v56@0:8@"<MTLCounterSampleBuffer>"16{_NSRange=QQ}24@"<MTLBuffer>"40Q48
v144@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136
v44@0:8@16{_NSRange=QQ}24I40
v104@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
v144@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112Q136
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24I40
v104@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
@32@0:8@16@24
@40@0:8@16@24@32
v40@0:8@16f24f28Q32
v56@0:8r^@16r^f24r^f32{_NSRange=QQ}40
v48@0:8@16Q24@32Q40
v64@0:8{?=dddddd}16
v32@0:8r^{?=dddddd}16Q24
v20@0:8f16
v28@0:8f16f20f24
v48@0:8{?=QQQQ}16
v32@0:8r^{?=QQQQ}16Q24
v20@0:8I16
v24@0:8I16I20
v32@0:8f16f20f24f28
v56@0:8@16Q24Q32Q40Q48
v60@0:8@16Q24Q32Q40B48Q52
v48@0:8@16Q24Q32Q40
v52@0:8@16Q24Q32Q40B48
@"MTLCountersTraceRenderCommandEncoder"
@32@0:8{_NSRange=QQ}16
@"NSData"32@0:8{_NSRange=QQ}16
@32@0:8@16^@24
v32@0:8@16@?24
@24@0:8@16
@40@0:8@16@24^@32
v40@0:8@16@24@?32
@48@0:8@16@24@32^@40
v48@0:8@16@24@32@?40
B32@0:8r^@16Q24
i20@0:8I16
B24@0:8@"<MTLResource>"16
^v16@0:8
@40@0:8@16Q24Q32
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@48@0:8@16Q24Q32Q40
^{__IOSurface=}16@0:8
@"<MTLTexture>"48@0:8@"MTLTextureDescriptor"16Q24Q32Q40
v24@0:8@?16
v32@0:8@16d24
d16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
v24@0:8@"<MTLDrawable>"16
v32@0:8@"<MTLDrawable>"16d24
@"<MTLBlitCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLComputeCommandEncoder>"24@0:8@"MTLComputePassDescriptor"16
@"<MTLBlitCommandEncoder>"24@0:8@"MTLBlitPassDescriptor"16
@"<MTLComputeCommandEncoder>"16@0:8
@"<MTLComputeCommandEncoder>"24@0:8Q16
v32@0:8@"<MTLEvent>"16Q24
@"<MTLParallelRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLResourceStateCommandEncoder>"16@0:8
@"<MTLResourceStateCommandEncoder>"24@0:8@"MTLResourceStatePassDescriptor"16
@"<MTLAccelerationStructureCommandEncoder>"16@0:8
@"<MTLAccelerationStructureCommandEncoder>"24@0:8@"MTLAccelerationStructurePassDescriptor"16
@"<MTLCommandQueue>"16@0:8
@"<MTLLogContainer>"16@0:8
@"NSError"16@0:8
v56@0:8@16Q24r^Q32r^Q40Q48
B24@0:8Q16
v20@0:8B16
^v24@0:8^Q16
@40@0:8@16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
v36@0:8@16Q24I32
v40@0:8Q16r^@24Q32
v24@0:8@"<MTLResourceGroupSPI>"16
v48@0:8@"<MTLResourceGroupSPI>"16Q24Q32Q40
v56@0:8@"<MTLResourceGroupSPI>"16Q24r^Q32r^Q40Q48
v24@0:8@"<MTLHeap>"16
v24@0:8@"NSArray"16
v32@0:8@"<MTLDrawable>"16@"NSDictionary"24
@"NSDictionary"16@0:8
@"NSMutableDictionary"16@0:8
@"<MTLDeadlineProfile>"16@0:8
@"<MTLRenderCommandEncoder>"40@0:8@"MTLRenderPassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@"<MTLComputeCommandEncoder>"40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"40@0:8@"MTLComputePassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLDebugCommandEncoder>"16@0:8
v36@0:8@"<MTLEvent>"16Q24I32
B24@0:8@"MTLToolsObject"16
@"NSMutableSet"16@0:8
v40@0:8@16Q24@32
v44@0:8i16Q20r^@28Q36
{?="hasCommit"b1"addedCompletedHandler"b1"addedScheduledHandler"b1"padding"b29}
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
{vector<void (^)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__begin_"^@?"__end_"^@?"__end_cap_"{__compressed_pair<void (^*)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__value_"^@?}}
@"MTLToolsDeadlineProfile"
@"NSMutableSet"
v28@0:8I16I20I24
@"<MTLToolsRetainingContainer>"
v40@0:8@16Q24^v32
@40@0:8^Q16^v24^B32
{vector<std::pair<NSData *, unsigned long>, std::allocator<std::pair<NSData *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<NSData *, unsigned long> *, std::allocator<std::pair<NSData *, unsigned long>>>="__value_"^v}}
{__wrap_iter<std::pair<NSData *, unsigned long> *>="__i"^v}
@"<MTLCommandBuffer>"16@0:8
@"<MTLCommandBuffer>"24@0:8@"MTLCommandBufferDescriptor"16
B28@0:8Q16S24
i24@0:8@16
i32@0:8@16Q24
v24@0:8@"NSObject<OS_dispatch_queue>"16
@"NSObject<OS_dispatch_queue>"16@0:8
@"MTLCommandQueueSPIStats"16@0:8
@"NSArray"16@0:8
i24@0:8@"NSArray"16
i32@0:8@"NSArray"16Q24
@"NSArray"24@0:8@"NSArray"16
v24@0:8@?<v@?@"<MTLCommandBuffer>"@"NSData"Q>16
@?32@0:8^B16@24
@"MTLToolsPerfCounterMailbox"
@48@0:8@16@24@32Q40
@56@0:8@16@24@32@40Q48
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__cxx_atomic_base_impl<int>>="__a_value"Ai}}
@"MTLToolsObject"
B32@0:8@16^@24
B32@0:8@"NSURL"16^@24
B40@0:8@16Q24^@32
r^{?=[32C]}16@0:8
B40@0:8@"NSURL"16Q24^@32
@"NSString"24@0:8Q16
@"NSObject<OS_dispatch_data>"16@0:8
@"MTLDebugInstrumentationData"16@0:8
v24@0:8@"MTLDebugInstrumentationData"16
B40@0:8@16@24^@32
B32@0:8@"MTLComputePipelineDescriptor"16^@24
B32@0:8@"MTLRenderPipelineDescriptor"16^@24
B32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
B40@0:8@"MTLFunctionDescriptor"16@"<MTLLibrary>"24^@32
@24@0:8^@16
@40@0:8Q16^I24^@32
v32@0:8@16r^{?=[32C]}24
@24@0:8r^{?=[32C]}16
^{MTLPipelineCollection=}16@0:8
B24@0:8@?16
v32@0:8@"MTLBinaryEntry"16@"MTLBinaryKey"24
@"MTLBinaryEntry"24@0:8@"MTLBinaryKey"16
@"NSString"24@0:8^@16
@"<NSObject>"40@0:8Q16^I24^@32
v24@0:8@"<MTLBinaryArchive>"16
@"NSMutableArray"16@0:8
B40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
B40@0:8@"MTLRenderPipelineDescriptor"16Q24^@32
B40@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32
B32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
B40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32
v32@0:8@"NSObject<OS_dispatch_data>"16r^{?=[32C]}24
@"NSObject<OS_dispatch_data>"24@0:8r^{?=[32C]}16
B32@0:8@"MTLStitchedLibraryDescriptor"16^@24
B24@0:8@"MTLComputePipelineDescriptor"16
B24@0:8@"MTLRenderPipelineDescriptor"16
B24@0:8@"MTLTileRenderPipelineDescriptor"16
B24@0:8@"MTLMeshRenderPipelineDescriptor"16
B24@0:8@?<B@?^{?=[32C]}@"NSObject<OS_dispatch_data>">16
@32@0:8Q16Q24
@40@0:8Q16Q24Q32
@32@0:8@16Q24
q16@0:8
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLBuffer>"40@0:8Q16Q24Q32
@"<MTLTexture>"32@0:8@"MTLTextureDescriptor"16Q24
@"<MTLAccelerationStructure>"24@0:8Q16
@"<MTLAccelerationStructure>"24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLAccelerationStructure>"32@0:8Q16Q24
@"<MTLAccelerationStructure>"32@0:8@"MTLAccelerationStructureDescriptor"16Q24
@"<MTLAccelerationStructure>"40@0:8Q16Q24Q32
v64@0:8{?={?=QQQ}{?=QQQ}}16
v56@0:8@16Q24{?=QQQ}32
v24@0:8@"<MTLComputePipelineState>"16
v40@0:8@"<MTLBuffer>"16Q24Q32
v32@0:8@"<MTLVisibleFunctionTable>"16Q24
v32@0:8@"<MTLIntersectionFunctionTable>"16Q24
v32@0:8@"<MTLAccelerationStructure>"16Q24
v32@0:8@"<MTLTexture>"16Q24
v32@0:8@"<MTLSamplerState>"16Q24
v40@0:8@"<MTLSamplerState>"16f24f28Q32
v32@0:8@"<MTLBuffer>"16Q24
v56@0:8@"<MTLBuffer>"16Q24{?=QQQ}32
v32@0:8@"<MTLResource>"16Q24
v40@0:8@"<MTLIndirectCommandBuffer>"16@"<MTLBuffer>"24Q32
v24@0:8q16
B44@0:8@16Q24Q32I40
v44@0:8@16Q24Q32I40
@"NSData"16@0:8
v32@0:8@"<MTLResourceGroupSPI>"16Q24
B44@0:8@"<MTLBuffer>"16Q24Q32I40
v44@0:8@"<MTLBuffer>"16Q24Q32I40
@"MTLGPUDebugBuffer"
@"MTLGPUDebugDevice"
{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{KeyBufferPair="key"{Key="hash"{?="key"[32C]}"data"@"NSData"}"buffer"@"<MTLBuffer>"}
@"MTLDebugInstrumentationData"
@"MTLGPUDebugFunction"
@"MTLGPUDebugDynamicLibrary"
v48@0:8@16@24@32Q40
v56@0:8@16@24@32@40Q48
v64@0:8@16@24@32@40Q48Q56
v48@0:8@16@24Q32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLBuffer>"32Q40
v56@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48
v64@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48Q56
v32@0:8@"<MTLAccelerationStructure>"16@"<MTLAccelerationStructure>"24
v40@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32Q40
v48@0:8@16@24Q32@40
v56@0:8@16@24@32Q40@48
B32@0:8@16@24
v120@0:8@16@24Q32@40Q48@56Q64@72Q80@88Q96@104Q112
v48@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"MTLAccelerationStructureDescriptor"40
v56@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40@"MTLAccelerationStructureDescriptor"48
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBufferSizesSPI"24
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBuffersSPI"24
v120@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64@"<MTLBuffer>"72Q80@"<MTLBuffer>"88Q96@"<MTLBuffer>"104Q112
Q40@0:8{?=QQQ}16
@"<MTLFunctionHandle>"24@0:8@"<MTLFunction>"16
@"<MTLComputePipelineState>"32@0:8@"NSArray"16^@24
@"<MTLVisibleFunctionTable>"24@0:8@"MTLVisibleFunctionTableDescriptor"16
@"<MTLIntersectionFunctionTable>"24@0:8@"MTLIntersectionFunctionTableDescriptor"16
v32@0:8@"MTLGPUDebugComputeCommandEncoder"16Q24
v48@0:8@"MTLGPUDebugRenderCommandEncoder"16Q24{optional<unsigned long>=(?=cQ)B}32
@"<MTLResource>"16@0:8
@48@0:8@16@24Q32Q40
@52@0:8@16@24Q32Q40B48
@60@0:8@16@24@32Q40Q48B56
^v24@0:8Q16
{?={?=QQQ}{?=QQQ}}16@0:8
@"_MTLIndirectDispatchThreadgroupsArguments"16@0:8
@"_MTLIndirectDispatchThreadsArguments"16@0:8
@"_MTLImageBlockArguments"16@0:8
v24@0:8^Q16
@32@0:8^@16^Q24
@32@0:8@16^Q24
@48@0:8@16Q24^@32^@40
v40@0:8@16Q24@?32
@40@0:8@16r^{?=BQ^{?}}24^@32
@40@0:8@16Q24^@32
@48@0:8@16@24Q32^@40
@40@0:8Q16@24^@32
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@24@0:8^{__IOSurface=}16
@48@0:8r^v16Q24Q32Q40
@56@0:8^v16Q24Q32Q40@?48
@40@0:8@16^{__IOSurface=}24Q32
@48@0:8^v16Q24@32@?40
{?=QQQ}24@0:8@16
@32@0:8^v16@24
@40@0:8^v16@24@32
@32@0:8Q16@24
{MetalBufferHeap="_mutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_buffers"{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}"_freeList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_currentFreeIndex"i"_totalMemoryAllocated"Q"_totalMemoryInUse"Q"_bufferLength"Q"_device"@"MTLGPUDebugDevice"}
{Options="version"I"mode"i"programTypes"i"accessTypes"i"failMode"i"maxTrackedResourcesMultiplier"I""{?="enableReporting"b1"packPointerAddresses"b1"unpackPointerAddress"b1"forceInline"b1"enableBacktracking"b1"optimizeConstantDeref"b1"skipVertexFetchLoads"b1"enableGEPOptimization"b1"emitBoundsChecking"b1"runStandardOptimizations"b1"backtrackFailuresAssumeSafe"b1"pageDataIs32bitLength"b1"forceUnrollLoops"b1"mergeAccessChecks"b1"convertToAB"b1"arraysOfBuffersAB"b1"noInlineTrivialFunctions"b1"unrollMemCpyWA"b1"checkGlobalConstants"b1"enableTextureChecks"b1"demoteGlobalConstantsToArg"b1"argumentPointerIndirection"b1"enableThreadgroupMemoryChecks"b1"mergeThreadgroupGlobals"b1"mergeThreadgroupArguments"b1"tagThreadgroupPointers"b1"noInlineCheckFunctions"b1"enableJumpThreading"b1"enableICBSupport"b1"enableGlobalRelocations"b1"enableTrapReporting"b1"enableRaytracing"b1"enableResourceUsageValidation"b1"enableStackOverflow"b1"enableDumpToStderr"b1}}
{GPUDebugDeviceOptions="retainReflection"b1"retainPSOFunctions"b1"abortOnFault"b1}
{GPUDebugBufferDescriptorHeap="s"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_freeIndexList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_bufferList"{vector<MTLGPUDebugBuffer *, std::allocator<MTLGPUDebugBuffer *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<MTLGPUDebugBuffer **, std::allocator<MTLGPUDebugBuffer *>>="__value_"^@}}"_freeIndex"Q"_argumentEncoder"@"<MTLArgumentEncoder>""_descriptorHeap"@"<MTLBuffer>"}
{GPUDebugConstantBufferCache="_totalUsedMemory"Q"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_cache"{unordered_map<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, std::allocator<std::pair<const GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__table_"{__hash_table<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>, std::allocator<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>>="__value_"f}}}"_device"@"MTLGPUDebugDevice"}
{GlobalResidentBufferList="_iteration"I"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_bufferList"{list<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__end_"{__list_node_base<id<MTLBuffer>, void *>="__prev_"^v"__next_"^v}"__size_alloc_"{__compressed_pair<unsigned long, std::allocator<std::__list_node<id<MTLBuffer>, void *>>>="__value_"Q}}}
@"NSData"
@"NSMutableArray"
{once_flag="__state_"Q}
@"<MTLRenderPipelineState>"
@"<MTLDepthStencilState>"
@"<MTLComputePipelineState>"
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
B24@0:8q16
v32@0:8^{?=ff}16Q24
{?=QQQ}40@0:8Q16Q24Q32
Q24@0:8q16
{?=QQQ}48@0:8Q16Q24Q32q40
v32@0:8^Q16^Q24
{?=QQ}24@0:8Q16
{?=QQQ}16@0:8
v72@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56Q64
v64@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56
@"<MTLCommandQueue>"24@0:8Q16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptor"16^@24
v32@0:8@"MTLStitchedLibraryDescriptor"16@?<v@?@"<MTLLibrary>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLRenderPipelineState>"48@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLRasterizationRateMap>"24@0:8@"MTLRasterizationRateMapDescriptor"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@"<MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
@"<MTLArgumentEncoder>"24@0:8@"<MTLBufferBinding>"16
@"<MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
@"<MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
@"<MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
{?=QQQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=QQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=II}16@0:8
@20@0:8I16
B24@0:8{?=II}16
v40@0:8@16r^v24@32
v48@0:8@16r^v24@32@40
B36@0:8@16B24^@28
^{MTLCompilerConnectionManager=}20@0:8i16
B20@0:8i16
r^{MTLTargetDeviceArch=QI*}16@0:8
r^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ}16@0:8
f16@0:8
{IndirectArgumentBufferCapabilities=b1b1b1b29}16@0:8
v24@0:8^{MPSFunctionTable=}16
v40@0:8Q16^Q24Q32
B32@0:8{_NSRange=QQ}16
B40@0:8^{?=III}16Q24Q32
@32@0:8^v16Q24
@40@0:8^v16@24Q32
^{os_unfair_lock_s=I}16@0:8
@28@0:8@16I24
@28@0:8@16B24
{?=QQQ}48@0:8q16Q24Q32Q40
v48@0:8@16@24@32^@40
v40@0:8@16@24^@32
@32@0:8r^@16Q24
@"MTLArchitecture"24@0:8@"NSArray"16
v24@0:8@"<MTLDeviceSPI>"16
@"<MTLBuffer>"24@0:8^{__IOSurface=}16
B24@0:8@"NSString"16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
@"_MTLIndirectArgumentBufferLayout"24@0:8@"MTLStructType"16
@"<MTLArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLIndirectRenderCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLIndirectComputeCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLSharedEvent>"20@0:8I16
@"<MTLAccelerationStructure>"32@0:8@"<MTLBuffer>"16Q24
@"<MTLAccelerationStructure>"40@0:8@"<MTLBuffer>"16Q24Q32
@"<MTLAccelerationStructure>"32@0:8^v16@"MTLAccelerationStructureDescriptor"24
@"<MTLAccelerationStructure>"40@0:8^v16@"NSArray"24@"MTLAccelerationStructureDescriptor"32
@"<MTLAccelerationStructure>"32@0:8Q16@"MTLAccelerationStructureAllocationDescriptor"24
v40@0:8@"<MTLAccelerationStructure>"16r^v24@"MTLAccelerationStructureDescriptor"32
v48@0:8@"<MTLAccelerationStructure>"16r^v24@"NSArray"32@"MTLAccelerationStructureDescriptor"40
@"<MTLDynamicLibrary>"40@0:8@"<MTLLibrary>"16@"MTLComputePipelineDescriptor"24^@32
B32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"40@0:8@"NSURL"16Q24^@32
@"NSArray"32@0:8@"MTLComputePipelineDescriptor"16^@24
@"NSArray"40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
@"NSArray"40@0:8@"MTLFunction"16@"NSArray"24^@32
@"NSArray"48@0:8@"MTLFunction"16@"NSArray"24Q32^@40
B36@0:8@"<MTLLibrary>"16B24^@28
@"<MTLBinaryArchive>"40@0:8Q16@"NSURL"24^@32
@"<MTLRenderPipelineState>"32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
v32@0:8@"MTLMeshRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLDeadlineProfile>"24@0:8Q16
@"MTLTargetDeviceArchitecture"16@0:8
@"MTLArchitecture"16@0:8
@"MTLGPUBVHBuilder"16@0:8
v24@0:8@"NSDictionary"16
v24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLBuffer>"48@0:8r^v16Q24Q32Q40
@"<MTLBuffer>"56@0:8^v16Q24Q32Q40@?<v@?^vQ>48
@"<MTLBuffer>"24@0:8@"MTLBufferDescriptor"16
@"<MTLLateEvalEvent>"16@0:8
@"<MTLComputePipelineState>"32@0:8@"MTLComputePipelineDescriptor"16^@24
v32@0:8@"MTLComputePipelineDescriptor"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
v32@0:8@"MTLTileRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLFunction>"32@0:8^v16Q24
@"<MTLFunction>"40@0:8^v16@"NSObject<OS_dispatch_data>"24Q32
v24@0:8@"MTLGPUBVHBuilder"16
@"<MTLIndirectArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLComputePipelineState>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLLibrary>"40@0:8@"NSString"16@"NSArray"24^@32
@"<MTLLibrary>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptorSPI"16^@24
@"NSString"24@0:8@"NSArray"16
@"<MTLLibrary>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLPipelineLibrarySPI>"32@0:8@"NSString"16^@24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLRenderPipelineDescriptor"16
@"NSObject<OS_dispatch_data>"24@0:8@"MTLComputePipelineDescriptor"16
@"MTLRenderPipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"MTLComputePipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLStructType"16
@"NSObject<OS_dispatch_data>"28@0:8@"MTLStructType"16I24
@"MTLStructType"24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLTexture>"48@0:8^v16Q24@"MTLTextureDescriptor"32@?<v@?^vQ>40
@"<MTLTextureLayout>"28@0:8@"MTLTextureDescriptor"16B24
@"<MTLIndirectArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
v48@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@"<MTLBinaryArchive>"32^@40
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24^@32
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@?<v@?@"NSError">32
@"<MTLResourceGroupSPI>"32@0:8r^@16Q24
v32@0:8@"NSObject<OS_dispatch_data>"16@"NSMutableDictionary"24
Q28@0:8Q16B24
@"<MTLDeviceSPI>"
@"MTLToolsObjectCache"
v40@0:8@"MTLSharedEventListener"16Q24@?<v@?@"<MTLSharedEvent>"Q>32
@"MTLSharedEventHandle"16@0:8
B32@0:8Q16Q24
@32@0:8Q16^@24
@"<MTLArgumentEncoder>"24@0:8Q16
@"<MTLArgumentEncoder>"32@0:8Q16^@24
v32@0:8Q16@?24
@40@0:8Q16^@24@32
@28@0:8@16C24
@"MTLFunctionReflection"24@0:8Q16
@"MTLFunctionReflection"32@0:8Q16@"<MTLPipelineLibrary>"24
@"MTLFunctionReflection"32@0:8Q16@"NSArray"24
v32@0:8Q16@?<v@?@"MTLFunctionReflection">24
@"<MTLArgumentEncoder>"32@0:8Q16@"<MTLPipelineLibrary>"24
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"<MTLPipelineLibrary>"32
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"NSArray"32
@"<MTLFunction>"28@0:8@"NSData"16C24
@"MTLType"16@0:8
@"<MTLFunctionHandle>"16@0:8
@"<MTLFunction>"24@0:8@"NSString"16
@"<MTLFunction>"40@0:8@"NSString"16@"MTLFunctionConstantValues"24^@32
v40@0:8@"NSString"16@"MTLFunctionConstantValues"24@?<v@?@"<MTLFunction>"@"NSError">32
v32@0:8@"MTLFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLFunctionDescriptor"16^@24
v32@0:8@"MTLIntersectionFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLIntersectionFunctionDescriptor"16^@24
@"<MTLFunction>"48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32^@40
v48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32@?<v@?@"<MTLFunction>"@"NSError">40
@"<MTLFunction>"40@0:8@"MTLFunctionDescriptor"16@"<MTLBinaryArchive>"24^@32
@"NSUUID"16@0:8
v32@0:8@"<MTLFunctionHandle>"16Q24
v40@0:8Q16{_NSRange=QQ}24
@"<MTLBuffer>"16@0:8
v24@0:8@"<MTLBuffer>"16
@"MTLCountersTraceComputeCommandEncoder"
@64@0:8@16@24@32@40@48Q56
@80@0:8@16@24@32@40@48@56@64@72
@48@0:8@16@24@32@40
@"MTLRenderPipelineReflection"
@"MTLToolsDevice"
@"<MTLRenderCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
v24@0:8@"<MTLRenderPipelineState>"16
v24@0:8@"<MTLDepthStencilState>"16
v80@0:8@"<MTLBuffer>"16Q24{?=QQQ}32{?=QQQ}56
v64@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56
v56@0:8Q16Q24Q32@"<MTLBuffer>"40Q48
v80@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56q64Q72
v40@0:8Q16@"<MTLBuffer>"24Q32
v64@0:8Q16Q24@"<MTLBuffer>"32Q40@"<MTLBuffer>"48Q56
v32@0:8@"<MTLFence>"16Q24
v72@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64
v56@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48
v88@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80
v72@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64
v40@0:8@"<MTLResource>"16Q24Q32
v32@0:8@"<MTLHeap>"16Q24
v40@0:8f16f20f24f28Q32
v44@0:8@16f24f28f32Q36
v28@0:8B16Q20
v24@0:8@?<v@?@"<MTLRenderCommandEncoderSPI>"Q>16
v48@0:8@"<MTLTexture>"16Q24@"<MTLSamplerState>"32Q40
v44@0:8@"<MTLSamplerState>"16f24f28f32Q36
v56@0:8@"<MTLTexture>"16Q24Q32Q40Q48
v60@0:8@"<MTLTexture>"16Q24Q32Q40B48Q52
v48@0:8@"<MTLTexture>"16Q24Q32Q40
v52@0:8@"<MTLTexture>"16Q24Q32Q40B48
v40@0:8@"<MTLResourceGroupSPI>"16Q24Q32
v60@0:8@16Q24Q32Q40Q48B56
v48@0:8r^@16{_NSRange=QQ}24Q40
@"MTLGPUDebugComputePipelineState"
@40@0:8@16Q24@32
{?=QQQ}24@0:8Q16
{?=ff}32@0:8{?=ff}16Q24
{?=QQ}16@0:8
v24@0:8@"MTLRasterizationRateMapDescriptor"16
@32@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16Q24
{_NSRange=QQ}16@0:8
^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}
{_NSRange="location"Q"length"Q}
@24@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16
v80@0:8Q16Q24Q32@40Q48Q56Q64Q72
v64@0:8@16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v64@0:8@16Q24Q32@40Q48Q56
@20@0:8B16
v32@0:8r^v16Q24
v40@0:8r^v16@24@32
{BinaryBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}"_timebase"{mach_timebase_info="numer"I"denom"I}}
{AppendBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}}
@"<MTLFunctionHandle>"32@0:8@"<MTLFunction>"16Q24
@"<MTLVisibleFunctionTable>"32@0:8@"MTLVisibleFunctionTableDescriptor"16Q24
@"<MTLIntersectionFunctionTable>"32@0:8@"MTLIntersectionFunctionTableDescriptor"16Q24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineFunctionsDescriptor"16^@24
@"<MTLRenderPipelineState>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLRenderPipelineState>"32@0:8@"NSArray"16^@24
@32@0:8@16:24
@"MTLToolsHeap"
v112@0:8Q16Q24Q32@40Q48@56Q64Q72Q80@88Q96Q104
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLTexture>"16@0:8
@48@0:8Q16Q24Q32Q40
@72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
@"<MTLTexture>"48@0:8Q16Q24Q32Q40
@"<MTLTexture>"32@0:8Q16Q24
@"<MTLTexture>"72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@"<MTLTexture>"76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
v104@0:8Q16Q24{?=QQQ}32{?=QQQ}56^v80Q88Q96
v104@0:8r^v16Q24Q32Q40Q48{?=QQQ}56{?=QQQ}80
@"<MTLTexture>"
v120@0:8r^v16Q24Q32Q40^v48Q56Q64{?={?=QQQ}{?=QQQ}}72
v120@0:8r^v16Q24Q32{?={?=QQQ}{?=QQQ}}40^v88Q96Q104Q112
v24@0:8^v16
{?=[2Q]}16@0:8
@56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
@"<MTLBuffer>"56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
{pair<id<MTLBuffer>, unsigned long>=@Q}24@0:8Q16
{ReportBufferEntry=Q@Q}24@0:8Q16
@"<MTLArgumentEncoder>"
{vector<MetalBuffer, std::allocator<MetalBuffer>>="__begin_"^{MetalBuffer}"__end_"^{MetalBuffer}"__end_cap_"{__compressed_pair<MetalBuffer *, std::allocator<MetalBuffer>>="__value_"^{MetalBuffer}}}
{MetalBuffer="heap"^{MetalBufferHeap}"index"I}
{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}
{vector<ReportBufferEntry, std::allocator<ReportBufferEntry>>="__begin_"^{ReportBufferEntry}"__end_"^{ReportBufferEntry}"__end_cap_"{__compressed_pair<ReportBufferEntry *, std::allocator<ReportBufferEntry>>="__value_"^{ReportBufferEntry}}}
{vector<NSString *, std::allocator<NSString *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<NSString **, std::allocator<NSString *>>="__value_"^@}}
[2{BufferUsageTable="_backingMemory"@"<MTLBuffer>"}]
[2{TextureUsageTable="_backingMemory"@"<MTLBuffer>"}]
{HeapUsageTable="_heapStages"{vector<std::pair<MTLGPUDebugHeap *, unsigned long>, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<MTLGPUDebugHeap *, unsigned long> *, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__value_"^v}}}
v64@0:8@"<MTLTexture>"16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@"<MTLTexture>"16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v48@0:8@"<MTLTexture>"16Q24@"<MTLBuffer>"32Q40
v64@0:8@"<MTLTexture>"16Q24Q32@"<MTLBuffer>"40Q48Q56
v148@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136B144
v112@0:8@16Q24Q32{?=QQQ}40@64Q72Q80Q88Q96Q104
{deque<id, std::allocator<id>>="__map_"{__split_buffer<id *, std::allocator<id *>>="__first_"^^@"__begin_"^^@"__end_"^^@"__end_cap_"{__compressed_pair<id **, std::allocator<id *>>="__value_"^^@}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<id>>="__value_"Q}}
@"MTLDebugCommandBuffer"
@40@0:8@16@24Q32
@48@0:8@16@24r^v32Q40
r^v16@0:8
@"MTLDebugResource"
@"MTLDebugDevice"
@"MTLDebugCommandQueue"
v32@0:8@16B24B28
v28@0:8@16B24
B32@0:8@16^B24
@"_MTLCommandEncoder"
{unordered_multiset<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__table_"{__hash_table<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>, std::allocator<std::__hash_node<AttachmentDescriptorSimple, void *>>>="__value_"{__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, AttachmentDescriptorSimple::hash_t>="__value_"Q}"__p3_"{__compressed_pair<float, AttachmentDescriptorSimple::equal_t>="__value_"f}}}
{array<AttachmentDescriptorSimple, 8UL>="__elems_"[8{AttachmentDescriptorSimple="texture"^v"level"Q"sliceRange"{_NSRange="location"Q"length"Q}"depthPlaneRange"{_NSRange="location"Q"length"Q}"storeAction"Q}]}
{unordered_set<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__table_"{__hash_table<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>, std::allocator<std::__hash_node<id<MTLDebugResourcePurgeable>, void *>>>="__value_"{__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<id<MTLDebugResourcePurgeable>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<id<MTLDebugResourcePurgeable>>>="__value_"f}}}
{unordered_set<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__table_"{__hash_table<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>, std::allocator<std::__hash_node<MTLToolsObject *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLToolsObject *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLToolsObject *>>="__value_"f}}}
v96@0:8Q16Q24Q32@40Q48Q56Q64@72Q80Q88
v96@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64@"<MTLBuffer>"72Q80Q88
v112@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80@"<MTLBuffer>"88Q96Q104
^{?=[3I]}16@0:8
@"_MTLIndirectDrawArguments"16@0:8
@"_MTLIndirectDrawIndexedArguments"16@0:8
@"_MTLIndirectDrawPatchesArguments"16@0:8
@"_MTLIndirectDrawIndexedPatchesArguments"16@0:8
@"_MTLIndirectTessellationFactorArguments"16@0:8
@"MTLCounterSampleBufferDescriptor"
@40@0:8@16r^v24@32
@56@0:8@16@24@32@40@48
@"MTLComputePipelineReflection"
[31{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[128{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[16{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{?="width"Q"height"Q"depth"Q}
{?="origin"{?="x"Q"y"Q"z"Q}"size"{?="width"Q"height"Q"depth"Q}}
[3Q]
@"MTLComputePipelineDescriptor"
@56@0:8@16@24@32Q40Q48
@"<MTLIndirectCommandBuffer>"
@"<MTLComputePipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"<MTLRenderPipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"MTLComputePipelineDescriptor"32@0:8@"NSString"16^@24
@"MTLRenderPipelineDescriptor"32@0:8@"NSString"16^@24
@"<MTLPipelineCache>"16@0:8
v32@0:8@"<MTLRenderPipelineState>"16Q24
v32@0:8@"<MTLComputePipelineState>"16Q24
v32@0:8@"<MTLIndirectCommandBuffer>"16Q24
@"_MTLIndirectArgumentBufferLayout"16@0:8
{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}
v32@0:8@16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16B24B28^{_MTLMessageContext=q*I@q@*}32
v40@0:8Q16Q24^{_MTLMessageContext=q*I@q@*}32
v40@0:8@16Q24^f32
{MTLSamplerDescriptorHashMap="_map"{unordered_map<std::array<unsigned long long, 3>, unsigned int, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, std::allocator<std::pair<const std::array<unsigned long long, 3>, unsigned int>>>="__table_"{__hash_table<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>, std::allocator<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>>="__value_"f}}}"_limit"I}
{unordered_set<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__table_"{__hash_table<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>, std::allocator<std::__hash_node<MTLDebugCommandBuffer *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLDebugCommandBuffer *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLDebugCommandBuffer *>>="__value_"f}}}
{CheckerboardRenderTargetPipelineCache="_cacheLock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"_library"@"<MTLLibrary>""_vertexFunction"@"<MTLFunction>""_depthStencilState"[2@"<MTLDepthStencilState>"]"_fConstants"@"MTLFunctionConstantValues""_cache"{unordered_map<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, std::allocator<std::pair<const MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__table_"{__hash_table<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>, std::allocator<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>>="__value_"f}}}}
C16@0:8
@"MTLDepthStencilDescriptor"
@56@0:8@16@24Q32Q40@48
@"MTLCountersTraceResourceStateCommandEncoder"
@"MTLAccelerationStructureDescriptor"16@0:8
v24@0:8@"MTLAccelerationStructureDescriptor"16
@"MTLToolsBuffer"
@32@0:8@16@?24
@"NSMapTable"
{recursive_mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{vector<id, std::allocator<id>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id *, std::allocator<id>>="__value_"^@}}
@"MTLFunctionConstantValues"
@56@0:8@16@24Q32@40@48
v32@0:8@16#24
v32@0:8@16r^{?=BQ^{?}}24
^{?=BQ^{?}}16@0:8
@"MTLCompileOptions"
^{?=BQ^{?}}
{atomic<unsigned long long>="__a_"{__cxx_atomic_impl<unsigned long long, std::__cxx_atomic_base_impl<unsigned long long>>="__a_value"AQ}}
@"MTLRenderPassDescriptor"
@32@0:8r^{MTLRenderPassAttachmentDescriptorPrivate=@QQQQQQ{?=dddd}dIQ@QQQQQQB}16Q24
Q24@0:8@16
{?=dddddd}16@0:8
{?=QQQQ}16@0:8
v56@0:8{?=QQQ}16^{?={?=QQQ}{?=QQQ}}40^I48
v48@0:8@16Q24^{_MTLMessageContext=q*I@q@*}32@40
v24@0:8^{_MTLMessageContext=q*I@q@*}16
v56@0:8Q16Q24Q32Q40r*48
v72@0:8Q16Q24Q32@40Q48Q56r*64
v64@0:8@16Q24Q32^{?=BBQ@QQQQQBff}40Q48Q56
v72@0:8r^@16{_NSRange=QQ}24Q40^{?=BBQ@QQQQQBff}48Q56Q64
{?=BBQ@QQQQQBff}16@0:8
^{?=QQ}
[10{?="pixelFormat"Q"sampleCount"Q}]
[36{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{vector<MTLViewport, std::allocator<MTLViewport>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLViewport *, std::allocator<MTLViewport>>="__value_"^{?}}}
{vector<MTLScissorRect, std::allocator<MTLScissorRect>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLScissorRect *, std::allocator<MTLScissorRect>>="__value_"^{?}}}
{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}
@"MTLCountersTraceCommandBuffer"
{MTLGPUDebugThreadgroupLengths="threadgroupSizes"[31I]"entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
@"MTLToolsFunction"
@48@0:8Q16^@24@32@40
{unordered_map<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__table_"{__hash_table<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>, std::allocator<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>>="__value_"f}}}
@40@0:8@16Q24:32
v40@0:8r^{?=QQQ}16Q24^{_MTLMessageContext=q*I@q@*}32
[8Q]
[31{?="bufferIndex"Q"bufferStride"Q}]
@"MTLRenderPipelineDescriptor"
@"MTLTileRenderPipelineDescriptor"
@"MTLMeshRenderPipelineDescriptor"
@"MTLSamplerDescriptor"
v32@0:8Q16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16{?=QQ}24
@64@0:8@16@24@32Q40Q48Q56
@88@0:8@16@24@32Q40Q48{_NSRange=QQ}56{_NSRange=QQ}72
{MTLPixelFormatInfo="name"*"flags"I"castClass"Q"type"(?="normal"{MTLNormalPixelFormatInfo="pixelBytes"Q"componentCount"C"alignment"C"pixelBytesRender"Q"pixelBytesRenderMSAA"Q}"compressed"{MTLCompressedPixelFormatInfo="blockBytes"Q"blockWidth"Q"blockHeight"Q"blockDepth"Q})}
{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::allocator<std::pair<const SubView, unsigned long>>>="__table_"{__hash_table<std::__hash_value_type<SubView, unsigned long>, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>, std::allocator<std::__hash_value_type<SubView, unsigned long>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>>="__value_"f}}}
@"MTLTextureDescriptor"
@"MTLDebugBuffer"
@"MTLCountersTraceBlitCommandEncoder"
