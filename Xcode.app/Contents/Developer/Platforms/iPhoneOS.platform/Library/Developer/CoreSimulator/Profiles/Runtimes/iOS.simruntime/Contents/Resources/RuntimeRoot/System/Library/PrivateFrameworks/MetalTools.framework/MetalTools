-[MTLDebugIndirectComputeCommand setComputePipelineState:]
Setting the pipeline state of indirect command buffers created with inheritPipelineState = YES is invalid
Setting a pipeline that does not have supportIndirectCommandBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand setKernelBuffer:offset:atIndex:]
index(%lu) must be < %lu.
Setting buffers on a indirect command buffer created with inheritBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand concurrentDispatchThreadgroups:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatch is not enabled on this indirect command buffer
-[MTLDebugIndirectComputeCommand concurrentDispatchThreads:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatchThreads is not enabled on this indirect command buffer
<unknown>
<unnamed>
<nil>
Unknown
Read Only
Write Only
Read Write
%@, length:%llu, resident:%@
%@, length:%llu
Invalid %@ %@ executing %@ function "%@" encoder: "%@", %@: %lu, at offset %llu
device
threadgroup
buffer: %@
Null texture access
Texture usage flags mismatch
%@ executing %@ function "%@" encoder: "%@", %@: %lu
Stack Overflow executing function "%@", %@ function "%@" encoder: "%@", %@: %u
Trap hit in function "%@", %@ function "%@", encoder: "%@", %@: %u
kernel
dispatch
vertex
draw
fragment
visible
intersection
object
mesh
%@(%@)
%llX
.xctoolchain/
v24@?0@"<MTLFunction>"8@"NSError"16
%@%@
label =
<none>
v16@?0@"<MTLCommandBuffer>"8
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
v32@?0@"<MTLCommandBuffer>"8@"NSData"16Q24
-[MTLDebugVisibleFunctionTable setPurgeableState:]
Setting purgeability state directly on heap sub-allocated resources is not allowed.
Cannot set purgeability state to volatile while resource is in use by a command buffer.
-[MTLDebugVisibleFunctionTable setFunction:atIndex:]
Visible Function Tables are not supported by the device.
function stage %@ does not match intersection table stage %@
pipelineState must be MTLComputePipelineState or MTLRenderPipelineState
-[MTLDebugVisibleFunctionTable setFunctions:withRange:]
NSMaxRange(range)(%lu) must be <= %lu.
functionCount =
mtl.global_constants_handle
mtl.current_image_id
v8@?0
com.apple.Metal
GPUDebug
v40@?0r^v8{_NSRange=QQ}16^B32
MTL_BOUNDS_ACCURATE_MODE
MTL_SHADER_VALIDATION_CPUOPT_FORCE_INIT
MTLBoundsCheck::Options
MTLBoundsCheck::RenderPipelineData
MTLBoundsCheck::ComputePipelineData
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
MetalShaderValidation
Metal Shader Validation does not support mesh shaders in this release. To use mesh shaders in this release, disable Metal Shader Validation in the Xcode scheme settings.
v32@?0@"<MTLComputePipelineState>"8@"MTLComputePipelineReflection"16@"NSError"24
-[MTLGPUDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
Indirect Command Buffers are not currently supported with Shader Validation
v24@?0@"<MTLLibrary>"8@"NSError"16
-[MTLGPUDebugDevice validateRaytracing]
ray tracing is not currently supported with Shader Validation
@"MTLToolsDynamicLibrary"8@?0
@"MTLToolsFunction"8@?0
MTL_SHADER_VALIDATION_MODE
Tier1
Tier2
MTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING
MTL_SHADER_VALIDATION_GLOBAL_MEMORY
MTL_SHADER_VALIDATION_THREADGROUP_MEMORY
MTL_SHADER_VALIDATION_TEXTURE_USAGE
MTL_SHADER_VALIDATION_RESOURCE_USAGE
MTL_SHADER_VALIDATION_STACK_OVERFLOW
MTL_SHADER_VALIDATION_COMPILER_INLINING
none
full
partial
default
MTL_SHADER_VALIDATION_FAIL_MODE
zerofill
allow
MTL_SHADER_VALIDATION_GPUOPT_FORCE_INLINE
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_PACK_POINTER_ADDRESSES
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_BACKTRACK
MTL_SHADER_VALIDATION_GPUOPT_CONST_DEREF
MTL_SHADER_VALIDATION_GPUOPT_GEP
MTL_SHADER_VALIDATION_GPUOPT_GENERIC
MTL_SHADER_VALIDATION_GPUOPT_SKIP_VFETCH
MTL_SHADER_VALIDATION_GPUOPT_BACKTRACK_FAIL_ASSUME_SAFE
MTL_SHADER_VALIDATION_GPUOPT_MERGE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_USE_LENGTH_ONLY
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_TRIVIAL
MTL_SHADER_VALIDATION_GPUOPT_DEMOTE_GLOBALS_CONSTANTS_TO_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_POINTER_INDIRECTION
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_GLOBALS
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_JUMP_THREADING
MTL_SHADER_VALIDATION_GPUOPT_USE_RELOCATIONS
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_REFELECTION
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_TRAP
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_FUNCTIONS
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_RAY_TRACING
MTL_SHADER_VALIDATION_ABORT_ON_FAULT
Invalid option for %s, valid options are:
com.apple.gpusw.MetalTools
MTLGPUDebugICBSupport
metallib
ICB_Inherit_PSO_Vertex
ICB_Inherit_None_Vertex
ICB_Inherit_Buffers_Vertex
ICB_Inherit_PSO_Kernel
ICB_Inherit_None_Kernel
ICB_Inherit_Buffers_Kernel
ICB_Inherit_Both_Kernel
Faults from argument buffers will not be detected.
Faults from reading global constant variables will not be detected.
%@ -debug-info-kind=line-tables-only
-debug-info-kind=line-tables-only
@"MTLToolsLibrary"8@?0
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v24@?0@"<MTLComputePipelineState>"8@"NSError"16
ciKernelMain
-[MTLToolsDevice unwrapMTLCommandBufferDescriptor:alwaysCopy:]
Incorrect object type in %s: expected %s, found %s
@"MTLToolsDepthStencilState"8@?0
@"MTLToolsSamplerState"8@?0
v24@?0@"<MTLSharedEvent>"8Q16
-[MTLDebugPipelineLibrary newComputePipelineStateWithName:options:reflection:error:]
name must not be nil.
descriptor is not a NSString.
-[MTLDebugPipelineLibrary newRenderPipelineStateWithName:options:reflection:error:]
@"MTLToolsFunctionHandle"8@?0
-[MTLGPUDebugAccelerationStructureCommandEncoder buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:]
Per Primitive Data is not supported with shader validation!
%@ -> %@
-[MTLDebugIntersectionFunctionTable setPurgeableState:]
-[MTLDebugIntersectionFunctionTable setFunction:atIndex:]
-[MTLDebugIntersectionFunctionTable setFunctions:withRange:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:withRange:]
"version":"
0.908
,"handle":"
,"device":{
"handle":"
,"name":"
,"queue":{
,"events":{
,"methods":[
{"selector":"
,"flags":
,"commands":"
,"commandBufferLength":
,"encoders":[
{"flags":
,"segment":{"location":
,"length":
,"statistics":{"flags":
,"counters":[
{"name":"
],"samples":"
,"sampleBufferLength":
cb_%llu.json
Error saving file '%@' (%@)
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
fillBuffer:range:value
fillBuffer:range:pattern4
fillTexture:level:slice:region:data:size
fillTexture:level:slice:region:color
fillTexture:level:slice:region:color:pixelFormat
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount
copyFromTexture:toTexture
generateMipmapsForTexture
synchronizeResource
synchronizeTexture
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset
resetTextureAccessCounters:region:mipLevel:slice
dispatchThreadgroups:threadsPerThreadgroup
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
setBuffer:offset:atIndex
setBufferOffset:atIndex
setBuffers:offsets:withRange
setBytes:length:atIndex
setComputePipelineState
setSamplerState:atIndex
setSamplerState:lodMinClamps:lodMaxClamps:atIndex
setSamplerStates:withRange
setSamplerStates:lodMinClamps:lodMaxClamps:withRange
setStageInRegion
setTexture:atIndex
setTextures:withRange
setThreadgroupMemoryLength:atIndex
memoryBarrierWithScope
memoryBarrierWithResources:count
drawPrimitives:vertexStart:vertexCount
drawPrimitives:vertexStart:vertexCount:instanceCount
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance
drawPrimitives:indirectBuffer:indirectBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset
drawIndexedPatches:patchStart:patchCount:controlPointIndexBuffer:controlPointIndexBufferOffset:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset
dispatchThreadsPerTile
setBlendColorRed:green:blue:alpha
setColorStoreAction:atIndex
setCullMode
setDepthBias:slopeScale:clamp
setDepthClipMode
setDepthStencilState
setDepthStoreAction
setFragmentBuffer:offset:atIndex
setFragmentBufferOffset:atIndex
setFragmentBuffers:offsets:withRange
setFragmentBytes:length:atIndex
setFragmentSamplerState:atIndex
setFragmentSamplerState:lodMinClamps:lodMaxClamps:atIndex
setFragmentSamplerStates:withRange
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange
setFragmentTexture:atIndex
setFragmentTextures:withRange
setFrontFaceWinding
setRenderPipelineState
setScissorRect
setScissorRects:count
setStencilFrontReferenceValue:backReferenceValue
setStencilReferenceValue
setStencilStoreAction
setTessellationFactorBuffer:offset:instanceStride
setTessellationFactorScale
setTriangleFillMode
setVertexBuffer:offset:atIndex
setVertexBufferOffset:atIndex
setVertexBuffers:offsets:withRange
setVertexBytes:length:atIndex
setVertexSamplerState:atIndex
setVertexSamplerState:lodMinClamps:lodMaxClamps:atIndex
setVertexSamplerStates:withRange
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange
setVertexTexture:atIndex
setVertexTextures:withRange
setTileBuffer:offset:atIndex
setTileBufferOffset:atIndex
setTileBuffers:offsets:withRange
setTileBytes:length:atIndex
setTileSamplerState:atIndex
setTileSamplerState:lodMinClamps:lodMaxClamps:atIndex
setTileSamplerStates:withRange
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange
setTileTexture:atIndex
setTileTextures:withRange
setViewport
setViewports:count
setVisibilityResultMode:offset
textureBarrier
memoryBarrierWithScope:afterStages:beforeStages
memoryBarrierWithResources:count:afterStages:beforeStages
setVisibleFunctionTable:atBufferIndex
setVisibleFunctionTables:withBufferRange
setIntersectionFunctionTable:atBufferIndex
setIntersectionFunctionTables:withBufferRange
insertDebugSignpost
pushDebugGroup
popDebugGroup
setLabel
updateFence
updateFence:afterStages
useHeap
useHeap:stages
useHeaps:count
useHeaps:count:stages
useResource:usage
useResource:usage:stages
useResources:count:usage
useResources:count:usage:stages
waitForFence
waitForFence:beforeStages
updateTextureMapping:mode:regions:mipLevel:slice
updateTextureMappings:mode:regions:mipLevels:numRegions:slices
updateTextureMappings:mode:indirectBuffer:indirectBufferOffset
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
%llu
-[MTLToolsResource validateCPUReadable]
resourceOptions (0x%lx) specify MTLResourceStorageModePrivate, which is not CPU accessible.
resourceOptions (0x%lx) specify MTLStorageModeMemoryless, which is not CPU accessible.
-[MTLToolsResource validateCPUWriteable]
%@:%@
v20@?0^I8I16
-[MTLDebugBlitCommandEncoder dealloc]
Command encoder released without endEncoding.
-[MTLDebugBlitCommandEncoder internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Encoder Copy From Texture Validation
the combination of MTLBlitOptionDepthFromDepthStencil and MTLBlitOptionStencilFromDepthStencil is invalid.
invalid usage because encoding has ended.
sourceTexture must not be nil.
sourceTexture is not a MTLTexture.
sourceTexture is associated with a different device
sourceTexture is Memoryless and cannot be used for copy operations!
destinationTexture must not be nil.
destinationTexture is not a MTLTexture.
destinationTexture is associated with a different device
destinationTexture is Memoryless and cannot be used for copy operations!
(sourceSize.width(%lu) * sourceSize.height(%lu) * sourceSize.depth(%lu))(%lu) must not be 0.
sourceTexture != nil
destinationTexture != nil
Copy From Texture Validation
[sourceTexture pixelFormat](%s) and [destinationTexture pixelFormat](%s) are not compatible for depth/stencil blits.
[sourceTexture pixelFormat](%s) must be compatible with [destinationTexture pixelFormat](%s).
[sourceTexture sampleCount](%lu) must equal [destinationTexture sampleCount](%lu).
sourceTexture must not be a framebufferOnly texture.
destinationTexture must not be a framebufferOnly texture.
sourceLevel(%lu) must be < [sourceTexture mipmapLevelCount](%lu).
sourceSlice(%lu) must be < (%lu).
destinationLevel(%lu) must be < [destinationTexture mipmapLevelCount](%lu).
destinationSlice(%lu) must be < (%lu).
(sourceOrigin.x + adjustedSourceSize.width)(%lu) must be <= paddedWidth(%lu).
(sourceOrigin.y + adjustedSourceSize.height)(%lu) must be <= paddedHeight(%lu).
(sourceOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(sourceOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(sourceOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(sourceOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
(destinationOrigin.x + adjustedDestinationSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedDestinationSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + destinationSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + destinationSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + destinationSize.depth)(%lu) must be <= depth(%lu).
sourceOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
sourceOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
sourceOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
size.width(%lu) must be a multiple of %s blockWidth(%lu).
size.height(%lu) must be a multiple of %s blockHeight(%lu).
size.depth(%lu) must be a multiple of %s blockDepth(%lu).
destinationOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
destinationOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
destinationOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
sourceOrigin.x must be 0 (full image) for %s.
sourceOrigin.y must be 0 (full image) for %s.
sourceOrigin.z must be 0 (full image) for %s.
sourceSize.width(%lu) must equal width(%lu) (full image) for %s.
sourceSize.height(%lu) must equal height(%lu) (full image) for %s.
sourceSize.depth(%lu) must equal depth(%lu) (full image) for %s.
destinationOrigin.x must be 0 (full image) for %s.
destinationOrigin.y must be 0 (full image) for %s.
destinationOrigin.z must be 0 (full image) for %s.
destinationSize.width(%lu) must equal width(%lu) (full image) for %s.
destinationSize.height(%lu) must equal height(%lu) (full image) for %s.
destinationSize.depth(%lu) must equal depth(%lu) (full image) for %s.
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s and destinationTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for destinationTexture with pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Copy From Buffer Validation
sourceBuffer must not be nil.
sourceBuffer is not a MTLBuffer.
sourceBuffer is associated with a different device
destinationTexture cannot be Memoryless.
(destinationOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
sourceOffset (%lu) must be a multiple of %lu bytes.
%s disallowed unless MTLBlitOptionRowLinearPVRTC option is used.
%s is not allowed to use the MTLBlitOptionRowLinearPVRTC option.
sourceBytesPerRow(%lu) must be >= (%lu).
sourceBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [sourceBuffer length](%lu).
sourceBytesPerRow (%lu) must be a multiple of %lu bytes.
sourceBytesPerImage (%lu) must be a multiple of %lu bytes.
sourceBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
blits between texture with pixel format %s and buffer are not allowed.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
destinationBuffer must not be nil.
destinationBuffer is not a MTLBuffer.
destinationBuffer is associated with a different device
destinationOffset (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be >= (%lu).
destinationBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [destinationBuffer length](%lu).
destinationBytesPerRow (%lu) must be a multiple of %lu bytes.
destinationBytesPerImage (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:]
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
-[MTLDebugBlitCommandEncoder generateMipmapsForTexture:]
Generate Mipmaps For Texture Validation
tex must not be nil.
tex is not a MTLTexture.
tex is associated with a different device
cannot generate mipmaps of Memoryless texture.
[tex mipmapLevelCount](%lu) must be > 1.
tex(%s) is not colorRenderable.
tex(%s) is not filterable.
tex != nil
-[MTLDebugBlitCommandEncoder fillBuffer:range:value:]
Fill Buffer Validation
buffer must not be nil.
buffer is not a MTLBuffer.
buffer is associated with a different device
(range.location + range.length)(%lu) must be <= [buffer length](%lu).
range.length(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder fillBuffer:range:pattern4:]
range.location(%lu) must be a multiple of 4 bytes.
range.length(%lu) must be a multiple of 4 bytes.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:]
(sourceOffset + size)(%lu) must be <= [sourceBuffer length](%lu).
(destinationOffset + size)(%lu) must be <= [destinationBuffer length](%lu).
size(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder waitForFence:]
MTLFence cannot be waited on after it has been updated within the same encoder.
-[MTLDebugBlitCommandEncoder endEncoding]
endEncoding without use.
-[MTLDebugBlitCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
firstBatch (%d) must be less than or equal to lastBatch(%d)
-[MTLDebugBlitCommandEncoder getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:]
Get Texture Access Counters Validation
countersBuffer must not be nil.
countersBuffer is not a MTLBuffer.
countersBuffer is associated with a different device
(countersBufferOffset)(%lu) must be < [countersBuffer length](%lu).
Only sparse textures support access counters.
-[MTLDebugBlitCommandEncoder resetTextureAccessCounters:region:mipLevel:slice:]
-[MTLDebugBlitCommandEncoder validateTextureAccess:region:mipLevel:slice:]
Validate Texture Access Validation
slice(%lu) must be lower than arrayLength(%lu)
mipLevel(%lu) must be lower or equal to min(mipmapLevelCount-1,firstMipmapInTail)(%lu)
texture != nil
(region.origin.x + region.width)(%lu) must be <= widthInTiles(%lu).
(region.origin.y + region.height)(%lu) must be <= heightInTiles(%lu).
(region.origin.z + size.depth)(%lu) must be <= depthInTiles(%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:]
Optimize Contents For GPU Access Validation
texture must not be nil.
texture is not a MTLTexture.
texture is associated with a different device
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:slice:level:]
level(%lu) must be < [texture mipmapLevelCount](%lu).
slice(%lu) must be < (%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:]
Optimize Contents For CPU Access Validation
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:slice:level:]
-[MTLDebugBlitCommandEncoder resetCommandsInBuffer:withRange:]
Specified range (loc=%lu, len=%lu) is not inside the command buffer with size %lu.
-[MTLDebugBlitCommandEncoder copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:]
Copy Indirect Command Buffer Validation
source is not a MTLIndirectCommandBuffer.
destination is not a MTLIndirectCommandBuffer.
Specified source range (loc=%lu, len=%lu) is not inside the source command buffer with size %lu.
Specified destination range (loc=%lu, len=%lu) is not inside the destination command buffer with size %lu.
source commandTypes (%lu) are not equal to destination commandTypes (%lu).
source inheritPipelineState (%s) is not equal to destination inheritPipelineState (%s).
source inheritBuffers (%s) is not equal to destination inheritBuffers (%s).
source maxVertexBufferBindCount (%lu) is not equal to destination maxVertexBufferBindCount (%lu).
source maxFragmentBufferBindCount (%lu) is not equal to destination maxFragmentBufferBindCount (%lu).
source maxKernelBufferBindCount (%lu) is not equal to destination maxKernelBufferBindCount (%lu).
source maxObjectBufferBindCount (%lu) is not equal to destination maxObjectBufferBindCount (%lu).
source maxMeshBufferBindCount (%lu) is not equal to destination maxMeshBufferBindCount (%lu).
-[MTLDebugBlitCommandEncoder optimizeIndirectCommandBuffer:withRange:]
Optimize Indirect Command Buffer Validation
Overlapping ranges are not allowed
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:bytes:length:]
Fill Texture Validation
bytes must not be nil.
texture must have a color format, but is %s.
region.origin.x must be 0 (full image) for %s.
region.origin.y must be 0 (full image) for %s.
region.origin.z must be 0 (full image) for %s.
region.size.width(%lu) must equal width(%lu) (full image) for %s.
region.size.height(%lu) must equal height(%lu) (full image) for %s.
region.size.depth(%lu) must equal depth(%lu) (full image) for %s.
buffer length for format %s must be at least %lu, but %lu was specified.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:]
format(%s) must be a color format.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:pixelFormat:]
format(%s) is not compatible with the texture format (%s).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:]
sliceCount must not be 0.
levelCount must not be 0.
sourceTexture.width(%lu) at mip %lu must match destinationTexture.width(%lu) at mip level %lu.
sourceTexture.height(%lu) at mip %lu must match destinationTexture.height(%lu) at mip level %lu.
sourceTexture.depth(%lu) at mip %lu must match destinationTexture.depth(%lu) at mip level %lu.
sourceLevel(%lu) + levelCount(%lu) must not exceed sourceTexture.mipmapLevelCount(%lu).
destinationLevel(%lu) + levelCount(%lu) must not exceed destinationTexture.mipmapLevelCount(%lu).
sourceSlice(%lu) + sliceCount(%lu) must not exceed sourceTexture.arrayLength(%lu) x sourceTexture.numFaces(%lu).
destinationSlice(%lu) + sliceCount(%lu) must not exceed destinationTexture.arrayLength(%lu) x destinationTexture.numFaces(%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:toTexture:]
-[MTLDebugBlitCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
Sample Counters In Buffer Validation
buffer must no be nil
Sample buffer is not a MTLCounterSampleBuffer.
Sample buffer is associated with a different device.
sampleIndex(%lu) must be < sampleCount(%lu).
MTLCounterSamplingPointAtBlitBoundary is not supported.
-[MTLDebugBlitCommandEncoder resolveCounters:inRange:destinationBuffer:destinationOffset:]
Resolve Counters Validation
MTLCounterSampleBuffer must be provided
Destination buffer is not a MTLBuffer.
Destination buffer is associated with a different device.
Destination offset (%llu) must be multiple of minimum constant buffer alignment (%llu).
NSMaxRange(range)(%lu) must be <= sampleCount(%lu).
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:]
Invalidate Compressed Texture Validation
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:slice:level:]
option is not a valid MTLBlitOption.
texture
Blit from %@ has protection options %016llx not set in command buffer protection options %016llx
Blit to %@ with protection options %016llx missing bits set in command buffer protection options %016llx
is illegal on a non-placement heap
is defined on a placement heap only when using a blit method copying entire texture surfaces, or when copying between buffers
is defined on a placement heap only when both textures have the same MTLTextureUsage flags
is defined on a placement heap only when both textures are linear and have the same bufferBytesPerRow value
is defined on a placement heap only when both top-level resources have the same layout
is defined on a placement heap when the texture views refer to the same sub-resources with the same texture type
top-level source and top-level destination resource dimensions must be identical when moving resources inside a placement heap
validateResourceAliasing
blitting between aliasing resources %s.
MTLBlitOptionNone
MTLBlitOptionDepthFromDepthStencil
MTLBlitOptionStencilFromDepthStencil
MTLBlitOptionRowLinearPVRTC
buffer
validateTextureRegion
region.size(%lu, %lu, %lu) must not be empty.
(region.origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(region.origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(region.origin.z + adjustedSize.depth)(%lu) must be <= paddedDepth(%lu).
region.origin.x(%lu) must be a multiple of %s blockWidth(%lu).
region.origin.y(%lu) must be a multiple of %s blockHeight(%lu).
region.origin.z(%lu) must be a multiple of %s blockDepth(%lu).
-[MTLDebugResourceStateCommandEncoder dealloc]
Command encoder released without endEncoding
-[MTLDebugResourceStateCommandEncoder validateSparseTextureMappingMode:]
Invalid mapping mode (%lu)
-[MTLDebugResourceStateCommandEncoder validateTextureAccess:region:mipLevel:slice:]
-[MTLDebugResourceStateCommandEncoder updateTextureMappings:mode:regions:mipLevels:slices:numRegions:]
Cannot update texture mapping: Encoder has ended encoding
Only sparse textures support mapping modifications.
mipLevels[%i](%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:region:mipLevel:slice:]
mipLevel(%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:]
-[MTLDebugResourceStateCommandEncoder moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
Resource State Encoder Validation
Only sparse textures (source) support mapping modifications.
Only sparse textures (destination) support mapping modifications.
The textures must have the same pixel format.
The source and destination texture must be created from the same heap.
destinationLevel(%lu) must be <= [destinationTexture firstMipmapInTail](%lu).
sourceLevel(%lu) must be <= [sourceTexture firstMipmapInTail](%lu).
-[MTLDebugResourceStateCommandEncoder waitForFence:]
-[MTLDebugResourceStateCommandEncoder endEncoding]
Can't end encoding for this encoder, already ended encoding
Ending encoding with no commands encoded.
-[MTLDebugBuffer makeAliasable]
This resource was not allocated on a heap.
-[MTLDebugBuffer newTextureWithDescriptor:offset:bytesPerRow:]
New Texture With Descriptor Validation
descriptor must not be nil.
descriptor is not a MTLTextureDescriptor.
resourceOptions (0x%lx) must match backing buffer resource options (0x%lx).
linear texture depth(%ld) must be 1
linear texture mipmapLevelCount(%ld) must be 1
linear texture sampleCount(%ld) must be 1
linear texture arrayLength(%ld) must be 1
compressionType must be set to lossless for linear textures
compressionFootprint must be set to lossless for linear textures
linear textures cannot be created with usage MTLTextureUsageRenderTarget
-[MTLDebugBuffer newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:]
Texture Descriptor Validation
2D linear texture array is not supported.
bytesPerImage must be aligned to %u bytes.
-[MTLDebugBuffer setPurgeableState:]
validateNewTexture
MTLTextureDescriptor.usage == MTLTextureUsageUnknown.
cannot create Memoryless texture from Buffer.
Textures with compressed pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with depth pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with stencil pixel formats cannot be created from a buffer and must be created as a standalone texture.
bytesPerRow(%lu) must be greater than (width * pixel_bytes)(%lu).
bytesPerRow must be non-zero.
Buffer-backed textures must have a texture type of MTLTextureType2D, MTLTextureTypeTextureBuffer or MTLTextureType2DArray, found %@.
Length required by texture offset, bytes per row, height and array length(%lu) exceed buffer capacity(%lu).
Offset of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found offset(%lu)
BytesPerRow of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found bytesPerRow(%lu)
-[MTLDebugDeadlineProfile validateCommandQueue:]
Deadline Profiles cannot be reused across command queues
-[MTLDebugCommandBuffer dealloc]
MTLCommandBuffer is in an invalid status when being destroyed; is it being over-released?
-[MTLDebugCommandBuffer encodeWaitForEvent:value:]
Standard MTLEvents must signal events on the same device. Use MTLSharedEvent for cross-device events.
-[MTLDebugCommandBuffer encodeWaitForEvent:value:timeout:]
-[MTLDebugCommandBuffer encodeSignalEvent:value:]
-[MTLDebugCommandBuffer waitUntilScheduled]
waitUntilScheduled on uncommitted command buffer
-[MTLDebugCommandBuffer waitUntilCompleted]
waitUntilCompleted on uncommitted command buffer
-[MTLDebugCommandBuffer blitCommandEncoder]
encoding in progress
-[MTLDebugCommandBuffer resourceStateCommandEncoder]
MSAA Resolve is only supported for color, depth, and stencil textures
MTLRenderPassDescriptor resolveTexture is associated with a different device
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1D.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType2DMultisample.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureTypeTextureBuffer.
MTLRenderPassDescriptor resolveTexture must not be Memoryless.
MTLRenderPassDescriptor texture and resolveTexture size mismatch.
PixelFormat %s cannot be a MSAA resolve target
Texture PixelFormat %s does not match Resolve PixelFormat %s
Slice is %lu, but the texture has only %lu slices
mipmap level is %lu, but the texture has only %lu levels
depth plane is %lu, but the texture has a depth of %lu at mip level %lu
resolveTexture sampleCount is %lu, but must be 1
resolveTexture must not be buffer-backed.
_MTLValidateDepthStencilStoreState
%@: mixing %@ and %@ store actions for the depth and stencil render pass attachments is not allowed.
MTLDebugRenderPipeline
MTLDebugRenderCommandEncoder
%@: the stencil attachment resolve filter mode (MTLMultisampleStencilResolveFilterDepthResolvedSample) is not valid because the depth attachment store action (%@) does not contain a resolve.
-[MTLDebugCommandBuffer addCompletedHandler:]
block cannot be nil
-[MTLDebugCommandBuffer addScheduledHandler:]
-[MTLDebugCommandBuffer unwrapMTLRenderPassDescriptor:]
colorAttachment[%lu].loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
depthAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
stencilAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
-[MTLDebugCommandBuffer renderCommandEncoderWithDescriptor:]
RenderCommandEncoder Validation
renderPassDescriptor must not be nil.
renderPassDescriptor is not a MTLRenderPassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoder]
-[MTLDebugCommandBuffer computeCommandEncoderWithDescriptor:]
ComputeCommandEncoder Validation
computePassDescriptor must not be nil.
computePassDescriptor is not a MTLComputePassDescriptor.
-[MTLDebugCommandBuffer blitCommandEncoderWithDescriptor:]
blitPassDescriptor must not be nil.
blitPassDescriptor is not a MTLBlitPassDescriptor.
-[MTLDebugCommandBuffer resourceStateCommandEncoderWithDescriptor:]
resourceStatePassDescriptor must not be nil.
resourceStatePassDescriptor is not a MTLResourceStatePassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoderWithDispatchType:]
-[MTLDebugCommandBuffer parallelRenderCommandEncoderWithDescriptor:]
ParallelRenderCommandEncoder Validation
-[MTLDebugCommandBuffer preCommit]
command buffer references deallocated object which previously existed at address %p.
-[MTLDebugCommandBuffer sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledRenderCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledComputeCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer lockPurgeableObjects]
MTLResource %p (label: %@), referenced in cmd buffer %p (label: %@) is in volatile or empty purgeable state at commit
-[MTLDebugCommandBuffer accelerationStructureCommandEncoder]
-[MTLDebugCommandBuffer accelerationStructureCommandEncoderWithDescriptor:]
Acceleration Structure Command Encoder Validation
accelerationStructurePassDescriptor must not be nil.
accelerationStructurePassDescriptor is not a MTLAccelerationStructurePassDescriptor.
-[MTLDebugCommandBuffer encodeDashboardTagForResourceGroup:]
Streaming Codec SPI
resourceGroup must be non-nil
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:]
dashboard(%llu) is not a valid MTLDashboard value
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:]
-[MTLDebugCommandBuffer commitWithDeadline:]
%s SPI should only be used with Deadline Aware Command Buffers
MTLStoreActionDontCare
MTLStoreActionStore
MTLStoreActionMultisampleResolve
MTLStoreActionStoreAndMultisampleResolve
MTLStoreActionUnknown
validateRenderPassDescriptor
RenderPass Descriptor Validation
not a MTLDebugTexture.
Texture at colorAttachment[%lu] has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions at color attachment %i includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
Attachment %u overlaps with attachment %u
MTLRenderPassDescriptor render targets have inconsistent sample counts.
Mixing MTLTextureType3D with other attachment types is not allowed when renderTargetArrayLength is not zero
This set of render targets requires %lu bytes of pixel storage. This device supports %lu bytes.
Texture at depthAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on the depth attachment includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
This render pass descriptor's clear depth (%f) is outside of the range [0..1]
Texture at stencilAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
rasterizationRateMap must be an MTLRasterizationRateMap instance.
rasterizationRateMap.device must match the current device.
renderTargetWidth (%lu) must be <= rasterizationRateMap.screenSize.width (%lu).
renderTargetHeight (%lu) must be <= rasterizationRateMap.screenSize.height (%lu).
renderTargetArrayLength (%lu) must be <= rasterizationRateMap.layerCount (%lu).
maximum physical rendering width (%lu) must be <= minimum attachment width (%lu).
maximum physical rendering height (%lu) must be <= minimum attachment height (%lu).
renderTargetWidth (%lu) must be <= minimum attachment width (%lu).
renderTargetHeight (%lu) must be <= minimum attachment height (%lu).
No rendertargets set in RenderPassDescriptor.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's renderTarget{Width|Height} properties to nonzero values.
Sparse textures are not supported as depth attachments on this device
Sparse textures are not supported as stencil attachments on this device
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must have a combined depth+stencil pixel format.
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must be the same depth and stencil texture.
When depth and stencil are used together, the render pass has to write to the same level and slice for both.
When depth and stencil are used together, the resolve texture for the depth and stencil render pass attachments must be the same depth and stencil texture.
When both depth (%lu x %lu) and stencil (%lu x %lu) are used from separate textures, they must have identical dimensions.
defaultColorSampleCount (%lu) is not supported by device.
defaultRasterSampleCount (%lu) is not supported by device.
no sampleCount for color and raster available, either set defaultColorSampleCount or set defaultRasterSampleCount or set appropriate attachments
unexpected color and depth/stencil sample counts
defaultColorSampleCount should be zero.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's defaultRasterSampleCount property to a nonzero value.
defaultRasterSampleCount should be zero.
Per sample storage cannot be greater than 64B
Per pixel storage cannot be greater than 256B
Total allocated thread group memory (%lu) cannot be greater than (%lu)
4X MSAA does not support 32 x 32 tiles
MTLRenderPassDescriptor visibilityResultBuffer is associated with a different device
%lu custom sample positions were programmed, but this render pass uses %lu rasterizer sample(s). These counts must match.
startOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
startOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfFragmentSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfFragmentSampleIndex must be MTLCounterDontSample
MTLRenderPassAttachmentDescriptor texture is associated with a different device
Memoryless attachment need to be Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
Memoryless attachment cannot be loaded as it have no memory to load from.
Memoryless attachment content cannot be stored in memory.
PixelFormat %s at color attachment %lu is not color renderable
PixelFormat %s is not depth renderable
PixelFormat %s is not stencil renderable
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1D.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1DArray.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureTypeTextureBuffer.
Slice is %lu, but the texture at attachment %lu has only %lu slices
mipmap level is %lu, but the texture at attachment %lu has only %lu levels
depth plane index is %lu, but the texture has a depth of %lu at mip level %lu
depth plane + renderTargetArrayLength is %lu, but the texture has a depth of %lu at mip level %lu.
slice + renderTargetArrayLength is %lu, but the texture only has %lu slices.
MTLRenderPassAttachmentDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action at attachment %lu requires resolve texture
MTLRenderPassAttachmentDescriptor %s depth resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor MTLMultisampleStencilResolveFilterDepthResolvedSample stencil resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor texture at attachment %lu must not be buffer-backed.
MTLRenderPassAttachmentDescriptor resolveTexture must have storeAction of MTLStoreActionMultisampleResolve, MTLStoreActionStoreAndMultisampleResolve or MTLStoreActionUnknown
MTLRenderPassAttachmentDescriptor texture must be MTLTextureType2DMultisample or MTLTextureType2DMultisampleArray when using a resolveTexture.
texture sampleCount is %lu, but must be > 1 when using a resolveTexture
the depth attachment
the stencil attachment
color attachment %lu
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, but Programmable Sample Positions is not supported on this device.
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, which does not apply to the store action (%@).
MTLMultisampleDepthResolveFilterSample0
MTLMultisampleDepthResolveFilterMin
MTLMultisampleDepthResolveFilterMax
validateTileDimensions
Invalid tile dimensions (%lu, %lu)
startOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfEncoderSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfEncoderSampleIndex must be MTLCounterDontSample
validateStoreLoadTransition
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. The results are undefined.
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. This is perfectly valid transition but it will result in reduced performance.
MTLLoadActionDontCare
MTLLoadActionLoad
MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES
-[MTLDebugDynamicLibrary serializeToURL:error:]
url must not be nil.
url must be a file URL.
-[MTLDebugDynamicLibrary serializeToURL:options:error:]
-[MTLDebugCounterSampleBuffer resolveCounterRange:]
NSMaxRange(indexRange)(%lu) must be <= sampleCount(%lu).
CPU access not allowed for sample buffers with MTLResourceStorageModePrivate.
-[MTLDebugBinaryArchive addComputePipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLComputePipelineDescriptor object.
descriptor.computeFunction must not be nil.
Linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLRenderPipelineDescriptor object.
Vertex linked functions cannot be added to this archive.
Fragment linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addMeshRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLMeshRenderPipelineDescriptor object.
Object linked functions cannot be added to this archive.
Mesh linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addTileRenderPipelineFunctionsWithDescriptor:options:error:]
device does not support tile shaders
descriptor is not a MTLTileRenderPipelineDescriptor object.
-[MTLDebugBinaryArchive serializeToURL:error:]
-[MTLDebugBinaryArchive serializeToURL:options:error:]
MTL_COUNTERS_LAYER_API_TIMING
-[MTLDebugCommandQueue insertDebugCaptureBoundary]
InsertDebugCaptureBoundary should not be called inside the completion handler
-[MTLDebugCommandQueue validateDeadlineAwareness:]
All commandBuffers from this commandQueue must have a deadlineProfile associated with it
Only MTLCommandQueues with MTLGPUPriorityRealTime can contain a deadline profile
-[MTLDebugComputeCommandEncoder dealloc]
computePipelineState =
<null>
Set Buffers:
Buffer %lu:
Set Textures:
Texture %lu:
Set Samplers:
Sampler %lu:
Set ThreadgroupMemoryLengths:
Threadgroup %lu:
Image Block Size: %lu x %lu
-[MTLDebugComputeCommandEncoder setComputePipelineState:]
computePipelineState must not be nil.
computePipelineState is not a MTLComputePipelineState.
computePipelineState is associated with a different device
redundant setComputePipelineState.
previous setComputePipelineState was unused.
-[MTLDebugComputeCommandEncoder setBytes:length:atIndex:]
length(%lu) must be <= %lu.
-[MTLDebugComputeCommandEncoder setBuffer:offset:atIndex:]
offset(%lu) must be < [buffer length](%lu).
offset(%lu) must be 0.
-[MTLDebugComputeCommandEncoder setBufferOffset:atIndex:]
index(%lu) must have an existing buffer.
-[MTLDebugComputeCommandEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an MTLBuffer.
buffers[%lu] is associated with a different device
offset[%lu](%lu) must be < [buffers[%lu] length](%lu).
offsets[%lu](%lu) must be 0.
-[MTLDebugComputeCommandEncoder setTexture:atIndex:]
frameBufferOnly texture not supported for compute.
Memoryless texture not supported for compute.
-[MTLDebugComputeCommandEncoder setTextures:withRange:]
textures[%lu] is not an MTLTexture.
textures[%lu] is associated with a different device
frameBufferOnly textures[%lu] not supported for compute.
textures[%lu] is Memoryless and cannot be assigned.
-[MTLDebugComputeCommandEncoder setSamplerState:atIndex:]
sampler is not a MTLSamplerState.
sampler is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerStates:withRange:]
samplers[%lu] is not an MTLSamplerState.
samplers[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugComputeCommandEncoder setSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugComputeCommandEncoder setThreadgroupMemoryLength:atIndex:]
length(%lu) must be a multiple of %lu bytes.
-[MTLDebugComputeCommandEncoder setImageblockWidth:height:]
width(%lu) must be a power of 2.
height(%lu) must be a power of 2.
width(%lu)*height(%lu) must be less than or equal to 1024
-[MTLDebugComputeCommandEncoder validateStageInRegion:]
stage_in region (width(%lu) * height(%lu) * depth(%lu))(%lu) must not be 0.
stage_in region (width)(%lu) must be <= width(%lu).
stage_in region (height)(%lu) must be <= height(%lu).
stage_in region (depth)(%lu) must be <= depth(%lu).
-[MTLDebugComputeCommandEncoder setStageInRegionWithIndirectBuffer:indirectBufferOffset:]
indirectBufferOffset (%lu) must be a multiple of 4
-[MTLDebugComputeCommandEncoder _validateThreadsPerThreadgroup:]
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must not be 0.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (device threadgroup size limit)
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (kernel threadgroup size limit)
threadsPerThreadgroup.width(%lu) must be <= %lu.
threadsPerThreadgroup.height(%lu) must be <= %lu.
threadsPerThreadgroup.depth(%lu) must be <= %lu.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be multiples of %lu.
-[MTLDebugComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:]
threadgroupsPerGrid.width(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.height(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadgroupsPerGrid.width(%lu) * threadgroupsPerGrid.y(%lu) * threadgroupsPerGrid.depth(%lu))(%lu) must not be 0.
Compute
stage_in region was not set for compute pipeline
-[MTLDebugComputeCommandEncoder dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:]
indirectBuffer must not be nil.
indirectBuffer is not a MTLBuffer.
indirectBuffer is associated with a different device
(indirectBufferOffset + sizeof(MTLDispatchThreadgroupsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
indirectBufferOffset(%lu) must be a multiple of 4 bytes.
-[MTLDebugComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:]
threadsPerGrid.width(%lu) must be <= UINT32_MAX.
threadsPerGrid.height(%lu) must be <= UINT32_MAX.
threadsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadsPerGrid.width(%lu) * threadsPerGrid.y(%lu) * threadsPerGrid.depth(%lu))(%lu) must not be 0.
-[MTLDebugComputeCommandEncoder dispatchThreadsWithIndirectBuffer:indirectBufferOffset:]
(indirectBufferOffset + sizeof(MTLDispatchThreadsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
-[MTLDebugComputeCommandEncoder waitForFence:]
-[MTLDebugComputeCommandEncoder endEncoding_private]
endEncoding without dispatchThreadgroups.
-[MTLDebugComputeCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
MTLVisibleFunctionTable
MTLIntersectionFunctionTable
-[MTLDebugComputeCommandEncoder useResource:usage:]
resource should not be nil
usage (0x%lx) has an invalid value
useResource:usage:
-[MTLDebugComputeCommandEncoder useResources:count:usage:]
resource (at index: %lu) should not be nil
useResources:count:usage: (index = %lu)
-[MTLDebugComputeCommandEncoder useHeap:]
heap should not be nil
-[MTLDebugComputeCommandEncoder useHeaps:count:]
heap (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder memoryBarrierWithScope:]
scope (0x%lx) has an invalid value for compute
compute memoryBarrierWithScope is not supported on this device
-[MTLDebugComputeCommandEncoder memoryBarrierWithResources:count:]
resources should not be nil or empty array
compute memoryBarrierWithResources is not supported on this device
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:withRange:]
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the compute pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugComputeCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDispatchBoundary is not supported.
-[MTLDebugComputeCommandEncoder setAccelerationStructure:atBufferIndex:]
Acceleration structure
-[MTLDebugComputeCommandEncoder setVisibleFunctionTable:atBufferIndex:]
functionTable is not a MTLVisibleFunctionTable.
functionTable is associated with a different device
-[MTLDebugComputeCommandEncoder setVisibleFunctionTables:withBufferRange:]
visibleFunctionTables[%lu] is not a MTLVisibleFunctionTable.
visibleFunctionTables[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTable:atBufferIndex:]
functionTable is not a MTLIntersectionFunctionTable.
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTables:withBufferRange:]
intersectionFunctionTables[%lu] is not a MTLIntersectionFunctionTable.
intersectionFunctionTables[%lu] is associated with a different device
validateArg
unused binding in encoder at %s index %lu.
sampler
threadgroupMemory
visibleFunctionTable
primitiveAccelerationStructure
instanceAccelerationStructure
intersectionFunctionTable
MTLDebugFunctionArgumentInit
redundant setting of %@.
thread_position_in_grid
threads_per_grid
thread_position_in_threadgroup
thread_index_in_threadgroup
threads_per_threadgroup
threadgroup_position_in_grid
threadgroups_per_grid
validateBuiltinArguments
Invalid built-in argument %@
component %lu: %llu must be <= %llu for %@ [[ %@ ]]
validateComputeFunctionArguments
%@ Function(%@): missing %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu].
%@ Function(%@): the offset into the buffer %@ that is bound at %s index %lu must be a multiple of %lu but was set to %lu.
%@ Function(%@): argument %@[%lu] from %s(%lu) with offset(%lu) and length(%lu) has space for %lu bytes, but argument has a length(%lu).
%@ Function(%@): Read-only bytes are being bound at index %lu to a shader argument with write access enabled (did you mean to use const or constant in the shader?).
%@ Function(%@): Reading from buffer bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to buffer bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): threadgroupMemoryLength(%lu) must be >= %lu at %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect type of texture (%@) bound at %s binding at index %lu (expect %@) for %@[%lu].
%@ Function(%@): Non-writeable texture format %s is being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): A sparse texture is being bound at index %lu to a shader argument with write access enabled. Sparse textures do not support writes from shaders.
%@ Function(%@): The pixel format (%s) of the %s (name:%@) bound at index %lu is incompatible with the data type (%@) of the %s parameter (%@ [[%s(%lu)]]). %s is compatible with the data type(s) %@.
%@ Function(%@): reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
%@ Function(%@): Shader uses texture(%@[%lu]) as read-write, but hardware does not support read-write texture of this pixel format.
%@ Function(%@): Reading from texture bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to texture bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu] - found %@.
Functon(%@): total used threadgroupMemoryLength(%lu) must be <= %lu.
validateTableStage
%@ called with a %s resource created for stage %@ rather than Compute
checkBuffer
%@ is not an MTLBuffer.
%@ is associated with a different device
%@ offset (%lu) must be < %@ length (%lu).
%@ must not be nil
%@ offset (%lu) must be 0.
checkAccelerationStructure
%@ is not an MTLAccelerationStructure.
checkMotionParameter
Acceleration descriptor is using primitive motion blur which is not supported by the device.
Primitive motion start time (%f) must be before or at the same time with motion end time (%f)
primitiveDataBuffer
checkPrimitiveData
primitiveDataElementSize must be non-zero
primitiveDataElementSize (%lu) cannot be larger than primitiveDataStride (%lu)
primitiveDataBufferOffset (%lu) exceeds primitiveDataBuffer.length (%lu)
primitiveDataBuffer.length (%lu) is not large enough to contain %lu primitives with primitiveDataBufferOffset (%lu), primitiveDataStride (%lu), and primitiveDataElementSize (%lu).
primitiveDataBufferOffset requires 4 byte alignment, found offset %lu.
primitiveDataStride requires 4 byte alignment, found offset %lu.
checkAccelerationStructureDescriptorWithRefitOptions
Number of geometry descriptors (%lu) must be less than 2^30
Number of geometry descriptors (%lu) must be less than 2^24
All geometry descriptors in a primitive acceleration structure descriptor must be the same type
Geometry descriptor intersection function table offset (%lu) must be less than 2^24
vertex buffer
Vertex buffer offset (%lu) must be a multiple of %lu bytes
index buffer
Index buffer offset (%lu) must be a multiple of the index data type stride (%lu)
Number of indices to read (triangle count multiplied by 3) (%lu) times index stride (%lu) plus index buffer offset (%lu) must be less than or equal to index buffer length (%lu)
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) must be less than or equal to vertex buffer length (%lu)
Motion keyframe count (%lu) must match vertexBuffers count (%lu)
Vertex buffer offset (%lu) in keyframe data must be a multiple of %lu bytes
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) in keyframe data must be less than or equal to vertex buffer length (%lu)
Bounding box stride (%lu) must be at least %lu bytes
Bounding box stride (%lu) must be a multiple of %lu bytes
bounding box buffer
Bounding box buffer offset (%lu) must be a multiple of %lu bytes
Bounding box buffer size (%lu) must be at least the bounding box buffer offset (%lu) plus the bounding box stride (%lu) times the number of bounding boxes (%lu)
Motion keyframe count (%lu) must match boundingBoxBuffers count (%lu)
Geometry descriptor must be a MTLAccelerationStructureTriangleGeometryDescriptor, a MTLAccelerationStructureMotionTriangleGeometryDescriptor, a MTLAccelerationStructureBoundingBoxGeometryDescriptor or a MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor
Number of primitives (%lu) must be less than 2^30
Number of primitives (%lu) must be less than 2^28
Number of instances (%lu) must be less than 2^30
Number of instances (%lu) must be less than 2^24
Instance descriptor type (%lu) is not a valid MTLAccelerationStructureInstanceDescriptorType
Instance descriptor stride (%lu) must be at least %lu bytes
Instance descriptor stride (%lu) must be a multiple of %lu bytes
instance descriptor buffer
Instance descriptor buffer offset (%lu) must be a multiple of %lu bytes
Instance descriptor buffer size (%lu) must be at least the instance descriptor buffer offset (%lu) plus the instance descriptor stride (%lu) times the number of instances (%lu)
Instanced acceleration structure
Must have at least 1 instanced acceleration structure if instance count > 0
Acceleration structure descriptor must be a MTLPrimitiveAccelerationStructureDescriptor or a MTLInstanceAccelerationStructureDescriptor
Acceleration structure descriptor must not be nil
-[MTLDebugAccelerationStructureCommandEncoder buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:]
Cannot build acceleration structure because encoder has ended encoding
Scratch buffer
Acceleration structure size (%lu) must be at least %lu bytes
Scratch buffer size (%lu) must be at least scratch buffer offset (%lu) plus required scratch buffer size (%lu)
-[MTLDebugAccelerationStructureCommandEncoder validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:]
Cannot refit acceleration structure because encoder has ended encoding
No options specified on refit
Source acceleration structure
Destination acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder copyAccelerationStructure:toAccelerationStructure:]
Cannot copy acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:]
Cannot write compacted acceleration structure because encoder has ended encoding
Size buffer
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:]
sizeDataType must be MTLDataTypeUInt or MTLDataTypeULong
-[MTLDebugAccelerationStructureCommandEncoder copyAndCompactAccelerationStructure:toAccelerationStructure:]
Cannot copy and compact acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:]
Cannot write serialized acceleration structure size because encoder has ended encoding
The size buffer is not big enough to hold the size (64 bits required)
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:]
Cannot write deserialized acceleration structure size because encoder has ended encoding
Serialized acceleration structure buffer
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:]
Cannot write deserialized primitive acceleration structure sizes because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:]
serializePrimitiveAccelerationStructure validation
Cannot serialize acceleration structure because encoder has ended encoding
Buffer
-[MTLDebugAccelerationStructureCommandEncoder serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:]
serializeInstanceAccelerationStructure validation
Primitive acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:]
deserializePrimitiveAccelerationStructure validation
Cannot deserialize acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
deserializeInstanceAccelerationStructure validation
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder serializeAccelerationStructure:toBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:]
Cannot write geometry size of acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:]
Cannot write geometry of acceleration structure because encoder has ended encoding
Geometry buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:into:]
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:into:]
Header buffer
Inner node buffer
Leaf node buffer
Primitive buffer
Instance transform buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:]
Sizes buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeAccelerationStructureSerializationData:toBuffer:offset:]
Output buffer
MTLAccelerationStructureSerializationData exceeds end of buffer from offset (%lu) with length (%lu).
Buffer requires 4 byte alignment, found offset %lu.
validateVertexFormatAndStride
Single component vertex formats are not supported
Vertex stride (%lu) must be at least %lu bytes
Vertex stride (%lu) must be a multiple of %lu bytes
Transformation buffer
validateTransformationBuffer
MTLPackedFloat4x3 exceeds end of transformation buffer from offset (%lu) with length (%lu).
Transformation buffer requires 4 byte alignment, found offset %lu.
None
Vertex
Fragment
Tile
Object
Mesh
-[MTLDebugComputePipelineState functionHandleWithFunction:]
function must not be nil.
function is not a MTLFunction.
-[MTLDebugComputePipelineState newComputePipelineStateWithAdditionalBinaryFunctions:error:]
Pipeline state is adding functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding functions which is not supported by the device
Function '%s' was found in functions array but is not precompiled.
Unable to create new compute pipeline state with additional binary functions: %@
-[MTLDebugComputePipelineState newVisibleFunctionTableWithDescriptor:]
descriptor is not a MTLVisibleFunctionTableDescriptor.
-[MTLDebugComputePipelineState newIntersectionFunctionTableWithDescriptor:]
descriptor is not a MTLIntersectionFunctionTableDescriptor.
-[MTLDebugComputePipelineState validateHandleForSetFunction:]
The function handle for function '%s' was not created from the pipeline state that created this MTLVisibleFunctionTable.
-[MTLDebugIndirectCommandBuffer indirectRenderCommandAtIndex:]
Indirect Command Buffer Validation
CPU access for MTLIndirectCommandBuffer with MTLResourceStorageModePrivate storage mode is disallowed.
MTLIndirectCommandBuffer created without any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectRenderCommands 
The requested command (%lu) is greater than the indirect command buffer size (%lu)
-[MTLDebugIndirectCommandBuffer indirectComputeCommandAtIndex:]
MTLIndirectCommandBuffer created with any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectComputeCommands 
-[MTLDebugIndirectCommandBuffer setPurgeableState:]
-[MTLDebugIndirectCommandBuffer resetWithRange:]
MTL_XML_DUMP_COUNTERS
MTL_XML_SYNC_BEFORE_SAMPLE
MTL_XML_TRACE_PATH
xml_trace_%p
Error creating directory '%@' (%@)
MTL_XML_COUNTER_NAMES
MTLStat_nSec
Unsupported counter: %@
Failed to request counters
Index %u does not match any member of the argument buffer
Index %u does not correspond to any valid member of the argument buffer
Trying to set a %@ at index %u but the argument buffer has a %@ at this index
index range (%lu, %lu) has indices that are outside of the valid index range [%u, %u]
index (%lu) is outside of the valid index range [%u, %u]
-[MTLDebugArgumentEncoder setArgumentBuffer:startOffset:elementIndex:]
Argument Buffer Validation
buffer is not a MTLBuffer
buffer storage mode (%@) should be MTLStorageModeShared
offset (%lu) + encodedLength (%lu) should be smaller or equal to the buffer length (%lu)
-[MTLDebugArgumentEncoder setBuffer:offset:atIndex:]
No argument buffer is set
buffer is not a valid MTLBuffer
offset (%lu) should be smaller than the buffer length (%lu)
offset(%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an valid MTLBuffer.
offsets[%lu](%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setTexture:atIndex:]
-[MTLDebugArgumentEncoder setTextures:withRange:]
-[MTLDebugArgumentEncoder setSamplerState:atIndex:]
Sampler state did not have supportArgumentBuffers flag set on creation, but is used with argument buffers
-[MTLDebugArgumentEncoder setSamplerStates:withRange:]
-[MTLDebugArgumentEncoder constantDataAtIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineState:atIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineStates:withRange:]
-[MTLDebugArgumentEncoder setComputePipelineState:atIndex:]
-[MTLDebugArgumentEncoder setComputePipelineStates:withRange:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffer:atIndex:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffers:withRange:]
-[MTLDebugArgumentEncoder newArgumentEncoderForBufferAtIndex:]
No argument buffer at that index
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withRange:]
Constant
Texture
Sampler
Struct
RenderPipelineState
ComputePipelineState
IndirectCommandBuffer
VisibleFunctionTable
IntersectionFunctionTable
PrimitiveAccelerationStructure
InstanceAccelerationStructure
METAL_COMPLAIN_ABOUT_SLOPPY_TEXTURE_USAGE
MTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS
MTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS
-[MTLDebugDevice heapTextureSizeAndAlignWithDescriptor:]
-[MTLDebugDevice newHeapWithDescriptor:]
New Heap With Descriptor Validation
Sparse heaps are not supported on this device
Heap needs to have a size.
Requested storage mode is not allowed for Heaps.
Requested CPU cache mode is not allowed for Heaps.
Requested hazard tracking mode is not allowed for Heaps.
Storage mode must be MTLStorageModePrivate for heap type MTLHeapTypeSparse
Memoryless texture need to have renderable PixelFormat.
Memoryless texture need to be of type Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
options 0x%lx conveys invalid cpuCacheMode of 0x%lx
IOSurface textures must use MTLStorageModeShared
MTLStorageModeShared not allowed for textures
MTLStorageModeMemoryless can only be used with textures
MTLStorageModeMemoryless is not supported on this device
Illegal MTLStorageMode 0x%lx
options 0x%lx conveys invalid hazardTrackingMode of 0x%lx
MTLResourceOptions options has unknown bits 0x%lx.
Cannot create buffer of zero length.
newBufferWith*:length 0x%lx must not exceed %llu MB.
-[MTLDebugDevice newBufferWithLength:options:]
Buffer Validation
-[MTLDebugDevice newBufferWithBytes:length:options:]
storageModePrivate incompatible with ...WithBytes variant of newBuffer
newBufferWithBytes:pointer must not be nil.
-[MTLDebugDevice newBufferWithBytesNoCopy:length:options:deallocator:]
storageModePrivate incompatible with ...WithBytesNoCopy variant of newBuffer
newBufferWithBytesNoCopy:pointer must not be nil.
newBufferWithBytesNoCopy:pointer %p is not %d byte aligned.
newBufferWithBytesNoCopy:length 0x%lx is not %d byte aligned.
-[MTLDebugDevice newBufferWithDescriptor:]
MTLResourceStorageModeShared should be used with noCopy=YES or contents being set
contents must not be nil when noCopy is set to YES
MTLBufferDescriptor.contents %p is not %d byte aligned.
MTLBufferDescriptor.length 0x%lx is not multiple of %d.
-[MTLDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
maximum vertex buffer bind count (%lu) must be <= %lu.
maximum fragment buffer bind count (%lu) must be <= %lu.
maximum kernel buffer bind count (%lu) must be <= %lu.
-[MTLDebugDevice newArgumentEncoderWithArguments:]
arguments cannot be nil
arguments must have at least one element
-[MTLDebugDevice newTextureWithBytesNoCopy:length:descriptor:deallocator:]
MTLResourceStorageModeShared must be used.
newTextureWithBytesNoCopy:pointer must not be nil.
newTextureWithBytesNoCopy:pointer %p is not %d byte aligned.
-[MTLDebugDevice newDepthStencilStateWithDescriptor:]
descriptor is not a MTLDepthStencilDescriptor.
texture buffer width (%llu) must be less than %llu
texture buffer height (%llu) must be 1
texture buffer depth (%llu) must be 1
texture buffer mipmapLevelCount (%llu) must be 1
texture buffer sampleCount (%llu) must be 1
texture buffer arrayLength (%llu) must be 1
usage must be set
MTLTextureUsageRenderTarget is not valid for a texture buffer
Texture buffer usage must contain read or write
texture buffer with pixel format (%s) cannot be written to from a shader
pixel format (%s) cannot be written to from a shader on this device
pixel format (%s) cannot be used for a texture buffer
-[MTLDebugDevice newTextureWithDescriptor:]
Cannot use an Xn format when creating a new texture
-[MTLDebugDevice newSamplerStateWithDescriptor:]
descriptor is not a MTLSamplerDescriptor.
-[MTLDebugDevice newBinaryArchiveWithDescriptor:error:]
Binary Archive with Descriptor Validation
descriptor is not a MTLBinaryArchiveDescriptor object.
url, if not nil, must be a file URL.
-[MTLDebugDevice newBinaryLibraryWithOptions:url:error:]
-[MTLDebugDevice newDynamicLibraryWithURL:options:error:]
Dynamic Library with URL Validation
device does not support dynamic libraries
-[MTLDebugDevice newDynamicLibrary:computeDescriptor:error:]
Dynamic Library Validation
library must not be nil.
library is not a MTLLibrary object.
-[MTLDebugDevice newDynamicLibrary:error:]
-[MTLDebugDevice loadDynamicLibrariesForComputeDescriptor:options:error:]
-[MTLDebugDevice loadDynamicLibrariesForFunction:insertLibraries:options:error:]
insertLibaries must not be nil.
-[MTLDebugDevice validateDynamicLibrary:state:error:]
-[MTLDebugDevice validateDynamicLibraryURL:error:]
Pipeline descriptor is using MTLLinkedFunctions functions which is not supported by the device.
Function '%s' in group '%s' was not found in functions array.
Pipeline descriptor is using MTLLinkedFunctions groups which is not supported by the device.
Pipeline descriptor is using MTLLinkedFunctions %@ which is not supported by the device.
Function '%s' was found in %@ array but is not precompiled.
functions
privateFunctions
binaryFunctions
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:reflection:error:]
Render Pipeline State Descriptor Validation
descriptor is not a MTLRenderPipelineDescriptor.
vertexPreloadedLibraries is not empty but device does not support render dynamic libraries
fragmentPreloadedLibraries is not empty but device does not support render dynamic libraries
objectPreloadedLibraries is not empty but device does not support render dynamic libraries
meshPreloadedLibraries is not empty but device does not support render dynamic libraries
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:reflection:error:]
Compute Pipeline State Descriptor Validation
descriptor is not a MTLComputePipelineDescriptor.
preloadedLibraries is not empty but device does not support dynamic libraries
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:reflection:error:]
Tile Render Pipeline State Descriptor Validation
descriptor is not a MTLTileRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:reflection:error:]
Mesh Pipeline State Descriptor Validation
descriptor is not a MTLMeshRenderPipelineDescriptor.
device does not support mesh shaders.
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:completionHandler:]
-[MTLDebugDevice newLibraryWithFile:error:]
filepath must not be nil.
filepath is not a NSString.
-[MTLDebugDevice newLibraryWithURL:error:]
url is not a NSURL.
Invalid file url
-[MTLDebugDevice newLibraryWithSource:options:error:]
Library with Source Validation
options is not a MTLCompileOptions.
options.libraries contains an object that is not a MTLDynamicLibrary at index %lu.
source must not be nil.
source is not a NSString.
-[MTLDebugDevice newLibraryWithSource:options:completionHandler:]
-[MTLDebugDevice newLibraryWithData:error:]
data must not be nil.
-[MTLDebugDevice newPipelineLibraryWithFilePath:error:]
-[MTLDebugDevice newTextureWithDescriptor:iosurface:plane:]
iosurface must not be nil.
-[MTLDebugDevice newBufferWithIOSurface:]
-[MTLDebugDevice minLinearTextureAlignmentForPixelFormat:]
minLinearTextureAlignment Validation
%s is not supported on this device.
Linear textures do not support compressed pixel formats
Linear textures do not support depth/stencil pixel formats
-[MTLDebugDevice minimumLinearTextureAlignmentForPixelFormat:]
-[MTLDebugDevice newCounterSampleBufferWithDescriptor:error:]
MTLCounterSampleBufferDescriptor must be provided
descriptor is not a MTLCounterSampleBufferDescriptor.
-[MTLDebugDevice newLateEvalEvent]
Event Creation Validation
Late Eval Events not supported on this device
-[MTLDebugDevice newFence]
Attempt to create new fence over the fence instance limit (%lu).
The following Metal object is being destroyed while still required to be alive by the command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
The following Metal object has been over-released by the application and is being destroyed while still retained by command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
-[MTLDebugDevice notifyExternalReferencesNonZeroOnDealloc:]
<no label set>
-[MTLDebugDevice validateRaytracing]
device does not support ray tracing
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:]
buffer offset (%lu) must be < buffer length (%lu).
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:resourceIndex:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:]
-[MTLDebugDevice deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:]
accelerationStructure must not be nil.
-[MTLDebugDevice deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice newVisibleFunctionTableWithDescriptor:]
-[MTLDebugDevice newIntersectionFunctionTableWithDescriptor:]
-[MTLDebugDevice newIOHandleWithURL:error:]
New IO Handle Validation
Invalid file url.
-[MTLDebugDevice newIOHandleWithURL:compressionType:error:]
compressionType must be one of MTLIOCompressionTypeZlib, MTLIOCompressionTypeLZFSE, MTLIOCompressionTypeLZ4, MTLIOCompressionTypeLZMA, or MTLIOCompressionTypeLZBitmap.
-[MTLDebugDevice newUncachedIOHandleWithURL:error:]
-[MTLDebugDevice newUncachedIOHandleWithURL:compressionType:error:]
-[MTLDebugDevice newIOCommandQueueWithDescriptor:error:]
New IO Command Queue Validation
descriptor is not a MTLIOCommandQueueDescriptor
descriptor.priority must be one of MTLIOPriorityHigh, MTLIOPriorityNormal, or MTLIOPriorityLow.
descriptor.type must be one of MTLIOCommandQueueTypeConcurrent, or MTLIOCommandQueueTypeSerial.
descriptor.scratchBufferAllocator is not a MTLIOScratchBufferAllocator.
MTLDebugShaders
simple_vertex
_validateRasterizationRateMapLayers
RasterizationRateMap Layers Validation
device must support variable rasterization rate feature.
screenSize.width (%lu) must be >0 and <=%lu.
screenSize.height (%lu) must be >0 and <=%lu.
layerCount (%lu) must be >0 and <=%lu.
layers must not be nil.
layers[%lu] must not be nil.
layers[%lu] must be a MTLRasterizationRateLayerDescriptor instance.
fill_checkboard_fragment
threadgroupMemoryLength
functionTable
accelerationStructure
buffer =
bufferOffset =
texture =
baseLevel =
sampler =
lodMinClamp =
lodMaxClamp =
threadgroupMemoryLength =
newArgumentEncoder
Function %@ does not have a buffer argument with buffer index %lu
Buffer argument %@ (buffer index: %lu) of function %@ is not an indirect argument buffer. If %@ is expected to be an argument buffer, this could be a shader bug. Argument buffers can be distinguished from regular buffers if they contain buffers, textures, samplers, or any element with the [[id]] attribute
-[MTLDebugLibrary newFunctionWithName:]
name is not a NSString.
validateNewFunctionWithConstantArguments
functionName is not a NSString.
constantValues must not be nil.
-[MTLDebugLibrary validateDescriptor:expectedClass:]
descriptor is not a %@.
Requesting binary compilation which is not supported by the device - supportsFunctionPointers = NO.
All linked functions must have unique names. Function '%s' is a duplicate symbol in %s, symbol first found in %s.
_validateUniqueNames
-[MTLDebugParallelRenderCommandEncoder setColorStoreAction:atIndex:]
attachmentIndex(%lu) must be < %lu
-[MTLDebugParallelRenderCommandEncoder setColorStoreActionOptions:atIndex:]
-[MTLDebugParallelRenderCommandEncoder endEncoding_private]
endEncoding called with store action for color attachment index %u still set to MTLStoreActionUnknown
endEncoding called with store action for depth attachment still set to MTLStoreActionUnknown
endEncoding called with store action for stencil attachment still set to MTLStoreActionUnknown
endEncoding called with store action unsupported for Memoryless attachment.
-[MTLDebugParallelRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
filterCounterRangeWithFirstBatch should not be called on ParallelRenderCommandEncoders
%s must not be nil.
%s is not a MTLBuffer.
%s is associated with a different device
%sOffset(%lu) + (indexCount(%lu) * %lu) must be <= [%s length](%lu).
indexCount(%lu) must be non-zero.
%sOffset(%lu) must be a multiple of %lu bytes.
_MTLDebugValidatePatchIndexBuffer
Patch Index Buffer Validation
%sOffset(%lu) + (patchIndicesUsed(%lu) * %lu) must be <= [%s length](%lu).
patchCount(%lu) must be non-zero.
instanceCount(%lu) must be non-zero.
%sOffset(%lu) must be 0.
v24@?0@"<MTLRenderCommandEncoderSPI>"8Q16
-[MTLDebugRenderCommandEncoder _init]_block_invoke
Exceeded HW limit of resources used by render encoder working in Memoryless mode.
Exceeded HW limit of scissor rectangles for render encoder working in Memoryless mode.
Exceeded HW limit of depth biases for render encoder working in Memoryless mode.
Internal error preventing the usage of memoryless for this render encoder.
-[MTLDebugRenderCommandEncoder dealloc]
descriptor =
viewportCount =
viewports:
Viewport %lu:
frontFacingWinding =
cullMode =
depthClipMode =
lineWidth =
depthBias =
depthBiasSlopeScale =
depthBiasClamp =
scissorRectCount =
scissorRects:
Scissor %lu:
amplificationMode =
amplificationValue =
vertexAmplificationCount =
triangleFillMode =
renderPipelineState =
depthStencilState =
frontStencilRef =
0x%x
backStencilRef =
visibilityResultMode =
visibilityResultOffset =
Blend Color =
%g %g %g %g
Set Vertex Buffers:
Set Vertex Textures:
Set Vertex Samplers:
Set Fragment Buffers:
Set Fragment Textures:
Set Fragment Samplers:
Set Tile Buffers:
Set Tile Textures:
Set Tile Samplers:
Set Tessellation Factor Buffer =
tessellationFactorBufferInstanceStride =
tessellationFactorScale =
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState colorSampleCount (%lu).
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For color attachment %d, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For color attachment %d, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For depth attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For depth attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For stencil attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For stencil attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
The color sample count (%lu) does not match the renderPipelineState's color sample count (%lu)
The raster sample count (%lu) does not match the renderPipelineState's raster sample count (%lu)
Device does not support separable raster/color shading rates
The sample count (%lu) does not match the renderPipelineState's sample count (%lu)
-[MTLDebugRenderCommandEncoder setRenderPipelineState:]
Set Render Pipeline State Validation
renderPipelineState must not be nil.
redundant setRenderPipelineState.
previous setRenderPipelineState was unused.
renderPipelineState is not a MTLRenderPipelineState.
renderPipelineState is associated with a different device
the pipelineState's per sample imageBlock usage(%lu) is greater than the encoder's perSample imageBlock usage(%lu)
The threadgroup memory consumed must be <= (%lu)
-[MTLDebugRenderCommandEncoder setVertexBytes:length:atIndex:]
Set Vertex Bytes Validation
-[MTLDebugRenderCommandEncoder setVertexBuffer:offset:atIndex:]
Set Vertex Buffer Validation
-[MTLDebugRenderCommandEncoder setVertexBufferOffset:atIndex:]
Set Vertex Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setVertexBuffers:offsets:withRange:]
Set Vertex Buffers Offset Validation
-[MTLDebugRenderCommandEncoder setVertexTexture:atIndex:]
Set Vertex Texture Validation
texture is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexTextures:withRange:]
Set Vertex Textures Validation
textures[%lu] is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexSamplerState:atIndex:]
Set Vertex Sampler State Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:withRange:]
Set Vertex Sampler States Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentBytes:length:atIndex:]
Set Fragment Bytes Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBufferOffset:atIndex:]
Set Fragment Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffers:offsets:withRange:]
Set Fragment Buffers Validation
-[MTLDebugRenderCommandEncoder setFragmentTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentTextures:withRange:]
Set Fragment Textures Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:atIndex:]
Set Fragment Sampler State Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:withRange:]
Set Fragment Sampler States Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:]
textureIndex(%lu) must be < %lu.
samplerIndex(%lu) must be < %lu.
-[MTLDebugRenderCommandEncoder setTileBytes:length:atIndex:]
Set Tile Bytes Validation
-[MTLDebugRenderCommandEncoder setTileBuffer:offset:atIndex:]
Set Tile Buffer Validation
-[MTLDebugRenderCommandEncoder setTileBufferOffset:atIndex:]
Set Tile Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setTileBuffers:offsets:withRange:]
Set Tile Buffers Validation
-[MTLDebugRenderCommandEncoder setTileTexture:atIndex:]
Set Tile Texture Validation
-[MTLDebugRenderCommandEncoder setTileTextures:withRange:]
Set Tile Textures Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:atIndex:]
Set Tile Sampler State Validation
-[MTLDebugRenderCommandEncoder setTileSamplerStates:withRange:]
Set Tile Sampler States Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder _dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:]
Dispatch Threads Per Tile Validation
the renderPipelineState was not created with a tileDescriptor
threadsPerTile (%lu, %lu) must equal tile size (%lu, %lu) when threadgroupSizeMatchesTileSize is true
threadsPerTile.width(%lu) and threadsPerTile.height(%lu) must match the tile size or threadsPerTile.width(%lu) must be equal to threadsPerTile.height(%lu)
roundup2(threadsPerTile.width(%lu)) * roundup2(threadsPerTile.height(%lu)) * threadsPerTile.depth(%lu) must be <= %lu, both width and height are rounded up to nearest even number 
tile shader input image-block layout must match the previous state's image-block layout
threadsPerTile.width(%lu) * threadsPerTile.height(%lu) * threadsPerTile.depth(%lu) must not be 0
threadsPerTile.width(%lu) must be <= %lu
threadsPerTile.depth(%lu) must be 1
-[MTLDebugRenderCommandEncoder setThreadgroupMemoryLength:offset:atIndex:]
Set Threadgroup Memory Length Validation
A dispatch is required to reinterpret threadgroup memory.
offset + length(%lu) must be <= threadgroupMemoryLength(%lu).
offset(%lu) must be a multiple of %lu bytes.
-[MTLDebugRenderCommandEncoder useResource:usage:]
Use Resource Validation
-[MTLDebugRenderCommandEncoder useResource:usage:stages:]
stages (0x%lx) has an invalid stage
'stages' does not specify any render stages. Specify at least one stage.
useResource:usage:stages:
-[MTLDebugRenderCommandEncoder useResources:count:usage:]
Use Resources Validation
-[MTLDebugRenderCommandEncoder useResources:count:usage:stages:]
useResources:count:usage:stages: (index = %lu)
-[MTLDebugRenderCommandEncoder useHeap:]
-[MTLDebugRenderCommandEncoder useHeap:stages:]
Use Heap Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:]
Use Heaps Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:stages:]
-[MTLDebugRenderCommandEncoder setViewport:]
Viewport Validation
redundant setViewport.
previous setViewport was unused.
-[MTLDebugRenderCommandEncoder setViewports:count:]
viewports parameter cannot be nullptr
viewport count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setFrontFacingWinding:]
Set Front Facing Winding Validation
redundant setFrontFacingWinding.
previous setFrontFacingWinding was unused.
-[MTLDebugRenderCommandEncoder setCullMode:]
Set Cull Mode Validation
redundant setCullMode.
previous setCullMode was unused.
-[MTLDebugRenderCommandEncoder setDepthClipMode:]
Set Depth Clip Mode Validation
redundant setDepthClipMode.
previous setDepthClipMode was unused.
-[MTLDebugRenderCommandEncoder setLineWidth:]
Set Line Width Validation
lineWidth(%g) must be between 1.0f and %.1ff
redundant setLineWidth.
previous setLineWidth was unused.
-[MTLDebugRenderCommandEncoder setDepthBias:slopeScale:clamp:]
Set Depth Bias Validation
redundant setDepthBias.
previous setDepthBias was unused.
-[MTLDebugRenderCommandEncoder setScissorRect:]
Set Scissor Rect Validation
redundant setScissorRect.
previous setScissorRect was unused.
-[MTLDebugRenderCommandEncoder setScissorRects:count:]
Set Scissor Rects Validation
scissorRects parameter cannot be nullptr
scissor rect count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setTransformFeedbackState:]
Set Transform Feedback State Validation
-[MTLDebugRenderCommandEncoder setVertexAmplificationMode:value:]
Set Vertex Amplification Mode Validation
vertexAmplificationMode is not a valid MTLVertexAmplificationMode.
the number of bits set to 1 in value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
redundant setVertexAmplificationMode.
previous setVertexAmplificationMode was unused.
-[MTLDebugRenderCommandEncoder setVertexAmplificationCount:viewMappings:]
invalid usage because device does not support vertex amplification.
count(%u) is not supported on this device. See supportsVertexAmplificationCount:(NSUInteger).
redundant setVertexAmplificationCount.
previous setVertexAmplificationCount was unused.
-[MTLDebugRenderCommandEncoder setTriangleFrontFillMode:backFillMode:]
Set Triangle Front Fill Mode Validation
-[MTLDebugRenderCommandEncoder setTriangleFillMode:]
Set Triangle Fill Mode Validation
redundant setTriangleFillMode.
previous setTriangleFillMode was unused.
-[MTLDebugRenderCommandEncoder setDepthStencilState:]
Set Depth Stencil State Validation
depthStencilState must not be nil.
depthStencilState is not a MTLDepthStencilState.
depthStencilState is associated with a different device
redundant setDepthStencilState.
previous setDepthStencilState was unused.
-[MTLDebugRenderCommandEncoder setStencilReferenceValue:]
Set Stencil Reference Value Validation
redundant setStencilReferenceValue.
previous setStencilReferenceValue was unused.
-[MTLDebugRenderCommandEncoder setStencilFrontReferenceValue:backReferenceValue:]
Set Stencil Front Reference Value Validation
_MTLDebugValidateDeferredStoreActionOnDevice
Deferred Store Action Validation
storeAction must not be MTLStoreActionUnknown
store actions known at render command encoder init time may not be mutated
storeAction unsupported for Memoryless attachment.
MTLRenderPassDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassDescriptor %s store action requires resolve texture
Store action for color attachment index %u must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for depth attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for stencil attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
-[MTLDebugRenderCommandEncoder setColorStoreAction:atIndex:]
Set Color Store Action Validation
deferred color store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreAction:]
deferred depth store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreAction:]
deferred stencil store actions cannot be set on sub render command encoders
_MTLDebugValidateDeferredStoreActionOptionsOnDevice
Deferred Store Action Options on Device Validation
-[MTLDebugRenderCommandEncoder setColorStoreActionOptions:atIndex:]
Set Color Store Action Options Validation
deferred color store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreActionOptions:]
deferred depth store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreActionOptions:]
deferred stencil store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setVisibilityResultMode:offset:]
Set Visibility Result Mode Validation
offset(%lu) must be a multiple of result-size(%u) bytes.
offset(%lu) must be <= %lu.
using the same offset (%lu) in the visibility buffer twice in the same command encoder is not allowed.
framebuffer visibilityResultBuffer must not be nil.
offset(%lu) + result-size(%u) must be <= [visibilityResultBuffer length](%lu).
redundant setVisibilityResultMode.
previous setVisibilityResultMode was unused.
-[MTLDebugRenderCommandEncoder setBlendColorRed:green:blue:alpha:]
Set Blend Color Validation
redundant setBlendColorRed.
previous setBlendColorRed was unused.
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:atIndex:]
Set Color Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:]
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:]
Set Depth Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:yInvert:]
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:]
Set Stencil Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:yInvert:]
primitiveType is not a valid MTLPrimitiveType.
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:]
Draw Errors Validation
only triangles may be drawn when using a rasterization rate map.
renderPipelineState must be set.
renderPipelineState must be created using a MTLRenderPipelineDescriptor.
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassPoint but primitiveType is not MTLPrimitiveTypePoint
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassLine but primitiveType is neither MTLPrimitiveTypeLine nor MTLPrimitiveTypeLineStrip
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassTriangle but primitiveType is neither MTLPrimitiveTypeTriangle nor MTLPrimitiveTypeTriangleStrip
renderPipelineState is a mesh shader pipeline, which cannot be used for this draw command
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:]
The scissor rectangle count (%lu) should be equal to the viewport count (%lu) or should be 1.
input image-block layout must match the previous state image-block layout
the renderPipelineState has a vertex shader that writes to render_target_array_index but renderTargetArrayLength is set to zero
renderPipelineState is not a mesh shader pipeline
Vertex Amplification Count (%u) must be between (inclusive) 1 and the maximum vertex amplification count specified in the pipeline state (%u)
-[MTLDebugRenderCommandEncoder validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:]
Draw Primitives Validation
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:]
-[MTLDebugRenderCommandEncoder validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:]
Draw Indexed Primitives Validation
indexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
-[MTLDebugRenderCommandEncoder drawPrimitives:indirectBuffer:indirectBufferOffset:]
indirectBuffer
sizeof(MTLDrawPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawIndexedPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder setObjectBytes:length:atIndex:]
Set Object Bytes Validation
-[MTLDebugRenderCommandEncoder setObjectBuffer:offset:atIndex:]
Set Object Buffer Validation
-[MTLDebugRenderCommandEncoder setObjectBufferOffset:atIndex:]
Set Object Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setObjectBuffers:offsets:withRange:]
Set Object Buffers Validation
-[MTLDebugRenderCommandEncoder setObjectTexture:atIndex:]
Set Object Texture Validation
-[MTLDebugRenderCommandEncoder setObjectTextures:withRange:]
Set Object Textures Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:atIndex:]
Set Object Sampler State Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:withRange:]
Set Object Sampler States Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
Set Object Threadgroup Memory Length Validation
-[MTLDebugRenderCommandEncoder setObjectThreadgroupMemoryLength:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshBytes:length:atIndex:]
Set Mesh Bytes Validation
-[MTLDebugRenderCommandEncoder setMeshBuffer:offset:atIndex:]
Set Mesh Buffer Validation
-[MTLDebugRenderCommandEncoder setMeshBufferOffset:atIndex:]
Set Mesh Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setMeshBuffers:offsets:withRange:]
Set Mesh Buffers Validation
-[MTLDebugRenderCommandEncoder setMeshTexture:atIndex:]
Set Mesh Texture Validation
-[MTLDebugRenderCommandEncoder setMeshTextures:withRange:]
Set Mesh Textures Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:atIndex:]
Set Mesh Sampler State Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:withRange:]
Set Mesh Sampler States Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
Draw Mesh Threadgroups With Indirect Buffer Validation
sizeof(MTLDispatchThreadgroupsIndirectArguments)
-[MTLDebugRenderCommandEncoder updateFence:afterStages:]
Cannot set the (MTLRenderStages)afterStages to 0. The parameter should be set to a valid MTLRenderStages value.
-[MTLDebugRenderCommandEncoder waitForFence:beforeStages:]
Cannot set the (MTLRenderStages)beforeStages to 0. The parameter should be set to a valid MTLRenderStages value.
Wait for Fence Validation
-[MTLDebugRenderCommandEncoder endEncoding_private]
End Encoding Validation
endEncoding without draw.
-[MTLDebugRenderCommandEncoder setTessellationFactorBuffer:offset:instanceStride:]
Set Tessellation Factor Buffer Validation
offset(%lu) must be a multiple of 4 bytes.
instanceStride(%lu) must be a multiple of 4 bytes.
-[MTLDebugRenderCommandEncoder setTessellationFactorScale:]
scale(%g) must be a normal floating point value (not denormal, infinite, nor NaN) and must be > 0.0f.
-[MTLDebugRenderCommandEncoder drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:]
patchIndexBuffer
-[MTLDebugRenderCommandEncoder drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
Draw Patches Validation
sizeof(MTLDrawPatchIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:]
Draw Indexed Patches Validation
controlPointIndexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugRenderCommandEncoder textureBarrier]
-textureBarrier is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithScope:afterStages:beforeStages:]
Memory Barrier With Scope Validation
render memoryBarrierWithScope is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithResources:count:afterStages:beforeStages:]
Memory Barrier With Resources Validation
render memoryBarrierWithResources is not supported on this device
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:withRange:]
Execute Commands In Buffer Validation
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the render pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDrawBoundary is not supported.
-[MTLDebugRenderCommandEncoder setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Table Validation
-[MTLDebugRenderCommandEncoder setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Tables Validation
intersectionFunctionTable is associated with a different stage (%@, expected %@)
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Table Validation
intersectionFunctionTable is not a MTLIntersectionFunctionTable.
intersectionFunctionTable is associated with a different device
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Tables Validation
-[MTLDebugRenderCommandEncoder setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Acceleration Structure Validation
indexType not valid MTLIndexType
%g %g %g %g %g %g
MTLWindingClockwise
MTLWindingCounterClockwise
MTLCullModeNone
MTLCullModeFront
MTLCullModeBack
MTLDepthClipModeClip
MTLDepthClipModeClamp
%lu %lu %lu %lu
MTLTriangleFillModeFill
MTLTriangleFillModeLines
MTLTriangleFillModePoint
MTLVisibilityResultModeDisabled
MTLVisibilityResultModeBoolean
MTLVisibilityResultModeCounting
local memory
%s must not be infinite or NaN.
viewport.originX
viewport.originY
viewport.width
viewport.height
viewport.znear
viewport.zfar
frontFacingWinding is not a valid MTLWinding.
cullMode is not a valid MTLCullMode.
depthClipMode is not a valid MTLDepthClipMode.
(rect.x(%lu) + rect.width(%lu))(%lu) must be <= render pass width(%lu)
(rect.y(%lu) + rect.height(%lu))(%lu) must be <= render pass height(%lu)
state(%u) is not a valid MTLTransformFeedbackState.
fillMode is not a valid MTLTriangleFillMode.
mode is not a valid MTLVisibilityResultMode.
%@ Function(%@): binding at index %lu is not a MTLDebugTexture.
%@ Function(%@): Shader reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): Shader writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
q24@?0@8@16
%@ Function(%@): there is an overlap with the threadgroupMemoryArgument at offset (%lu) and at offset(%lu).
validateDisjointRenderTargetsAndTexture
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also a %s attachment at index %lu. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and writeMask != MTLColorWriteMaskNone.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and depth writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and stencil writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is currently being written to in this render pass. This may be a conflict.
resolve
color
depth
stencil
vertex_id type is not big enough to draw this many vertices (%lu)
instance_id type is not big enough to draw this many instances (%lu)
missing vertexDescriptor %s binding at index %lu.
incorrect vertexDescriptor %s binding at index %lu.
MTLDepthStencilDescriptor sets depth test but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor has depthWriteEnabled but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor uses frontFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
MTLDepthStencilDescriptor uses backFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
%s requires a postTessellationVertexFunction but the vertexFunction of the renderPipelineState is not a postTessellationVertexFunction.
%s requires a normal vertexFunction but the vertexFunction of the renderPipelineState is a postTessellationVertexFunction.
(%sOffset + %s)(%lu) must be <= [%s length](%lu).
%sOffset(%lu) must be a multiple of 4 bytes.
validateCommonTessellationErrors
Common Tessellation Errors Validation
missing tessellationFactorBuffer binding.
numberOfPatchControlPoints(%lu) must match the number of control points(%ld) set in the vertexFunction of the renderPipelineState.
numberOfPatchControlPoints(%lu) must be <= 32.
for drawIndexedPatches numberOfPatchControlPoints(%lu) must not be 0.
for MTLTessellationFactorStepFunctionConstant and MTLTessellationFactorStepFunctionPerPatch tessellationFactorBufferInstanceStride(%lu) must be zero.
for MTLTessellationFactorStepFunctionPerInstance and MTLTessellationFactorStepFunctionPerPatchAndPerInstance tessellationFactorBufferInstanceStride(%lu) must be non-zero.
tessellationFactorBufferInstanceStride(%lu) must be a multiple of %lu bytes.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeNone not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt16 not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt32 not valid for %s.
tessellationFactorBuffer
%sOffset(%lu) + tessellationFactorBytesUsed(%lu) must be <= [%s length](%lu).
(patchStart + patchCount)(%lu) * %lu must be <= tessellationFactorBufferInstanceStride(%lu).
%@ called with stages (0x%lx), but %s resource was created for stage %@
MTL_XML_DUMP_EVENTS
MTLCommandBufferKernelStartTime
MTLCommandBufferKernelEndTime
MTLCommandBufferGPUStartTime
MTLCommandBufferGPUEndTime
-[MTLDebugResource doesAliasResource:]
Resource Validation
Input resource was not allocated on a heap.
-[MTLDebugResource doesAliasAllResources:count:]
Resources count cannot be zero.
resources must not be nil
Input resource %0lx was not allocated on a heap.
-[MTLDebugResource doesAliasAnyResources:count:]
v24@?0@"MTLStructType"8Q16
-[MTLDebugIndirectRenderCommand setVertexBuffer:offset:atIndex:]
Vertex Buffer Validation
-[MTLDebugIndirectRenderCommand setFragmentBuffer:offset:atIndex:]
Fragment Buffer Validation
-[MTLDebugIndirectRenderCommand drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
drawPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
drawIndexedPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setRenderPipelineState:]
Render Pipeline State Validation
-[MTLDebugIndirectRenderCommand drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawIndexedPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setObjectBuffer:offset:atIndex:]
Object Buffer Validation
index(%lu) must be < maxObjectBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setMeshBuffer:offset:atIndex:]
Mesh Buffer Validation
index(%lu) must be < maxMeshBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setBarrier]
setBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand clearBarrier]
clearBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreadgroups is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreads is not enabled on this indirect command buffer
-[MTLDebugRenderPipelineState validateHandleForSetFunction:]
-[MTLDebugRenderPipelineState validateBinaryFunctions:stage:]
Pipeline state is adding %@ functions which is not supported by the device
Function '%s' was found in %@ functions array but is not precompiled.
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:]
Pipeline state is adding vertex functions but it was created with supportAddingVertexBinaryFunctions=NO
Pipeline state is adding fragment functions but it was created with supportAddingFragmentBinaryFunctions=NO
Unable to create new render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:]
Unable to create new tile render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:error:]
cannot specify both tile and render pipeline additional functions simultaneously.
Pipeline state is adding tile functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding object functions but it was created with supportAddingObjectBinaryFunctions=NO
Pipeline state is adding mesh functions but it was created with supportAddingMeshBinaryFunctions=NO
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:selector:]
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:]
stage invalid.
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:selector:]
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:withStage:selector:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:stage:]
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) cannot exceed maxTotalThreadsPer%sThreadgroup (%lu)
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) must be multiple of %sThreadExecutionWidth (%lu)
validateMTLSamplerDescriptor
Sampler Descriptor Validation
MTLSamplerDescriptor:non-normalized coords require MTLSamplerMipFilterNotMipmapped.
MTLSamplerDescriptor:non-normalized coords require MTLSamplerAddressModeClampToEdge, MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor.
MTLSamplerDescriptor:non-normalized coords require maxAnisotropy == 1.
MTLSamplerDescriptor:non-normalized coords require minFilter==magFilter of MTLSamplerMinMagFilterNearest or MTLSamplerMinMagFilterLinear, to be portable to all Metal devices.
MTLSamplerDescriptor's min filter value (%lu) is invalid.
MTLSamplerDescriptor's mag filter value (%lu) is invalid.
MTLSamplerDescriptor's mip filter value (%lu) is invalid.
MTLSamplerDescriptor's max anisotropy value (%lu) is invalid. Clamping to [%i, %i] range.
MTLSamplerDescriptor's S texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's T texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's R texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's texture coordinate address modes must either contain MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor modes but not both.
MTLSamplerDescriptor: pixelFormat(%s) must be MTLPixelFormatInvalid when supportsArgumentBuffers == YES
MTLSamplerAddressModeMirrorClampToEdge is not supported on this device
MTLSamplerAddressModeClampToHalfBorderColor is not supported on this device
Custom border colors are not supported on this device
%@ is not supported on this device
Exceeded the limit on number of unique samplers usable in argument buffers (which is %u)
Sparse textures cannot be created with dual-plane texture formats
The requested hazard tracking mode does not match the heap's mode
The requested CPU cache mode does not match the heap's mode
The requested storage mode is not compatible with the heap's mode
Shared textures created via heaps are not supported on this device
MTLResourceOptions options have unknown bits 0x%lx.
MTLTextureUsageShaderWrite is not supported for MTLHeapTypeSparse on this platform
-[MTLDebugHeap maxAvailableSizeWithAlignment:]
aligment needs to be power of two, or zero.
-[MTLDebugHeap newBufferWithLength:options:]
Requested length %lu must not exceed heap size %lu.
Cannot create buffer from sparse heap.
newBufferWithLength:options: cannot be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options:offset: instead.
-[MTLDebugHeap newTextureWithDescriptor:]
newTextureWithDescriptor: cannot be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor:offset: instead.
Sparse textures are not supported on this device
MTLHeapTypeSparse does not support MTLTextureType1D and MTLTextureType1DArray
MTLHeapTypeSparse does not support MTLTextureTypeTextureBuffer
MTLUnmappedDepthValueOne is only supported for MTLPixelFormatDepth32Float
-[MTLDebugHeap setPurgeableState:]
-[MTLDebugHeap validateOffset:withRequirements:]
Offset Validation
Cannot place resource at offset %lu extending beyond the heap size %lu (resource size %lu)
Cannot place resource at offset %lu which is not aligned to %lu bytes
-[MTLDebugHeap newBufferWithLength:options:offset:]
newBufferWithLength:options:offset: can only be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options: instead.
-[MTLDebugHeap newTextureWithDescriptor:offset:]
newTextureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor: instead.
-[MTLDebugHeap validateRaytracingHeap]
Heap must be MTLStorageModePrivate to allocate acceleration structures
-[MTLDebugHeap newAccelerationStructureWithSize:]
Cannot create acceleration structure of zero size.
Requested size %lu must not exceed heap size %lu.
-[MTLDebugHeap newAccelerationStructureWithSize:offset:]
newAccelerationStructureWithSize:offset can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize: instead.
-[MTLDebugHeap newAccelerationStructureWithDescriptor:offset:]
newAccelerationStructureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithDescriptor: instead.
-[MTLDebugHeap newAccelerationStructureWithSize:resourceIndex:]
-[MTLDebugHeap newAccelerationStructureWithSize:offset:resourceIndex:]
newAccelerationStructureWithSize:offset:resourceIndex can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize:resourceIndex: instead.
-[MTLDebugTexture dealloc]
usageRequested 0x%lx != usageRequired 0x%lx
-[MTLDebugTexture makeAliasable]
Sparse textures cannot be made aliasable.
Memoryless textures cannot be made aliasable.
Texture Views created from Textures, that are backed by the Heap, cannot be made aliasable.
-[MTLDebugTexture setPurgeableState:]
Set Purgeable Stage Validation
_validateReplaceRegion
Replace Region Validation
(size.width(%lu) * size.height(%lu) * size.depth(%lu))(%lu) must not be 0.
CPU access for textures with MTLResourceStorageModePrivate storage mode is disallowed.
CPU access for textures with MTLStorageModeMemoryless is disallowed.
texture must not be a framebufferOnly texture.
mipmapLevel(%lu) must be < [texture mipmapLevelCount](%lu).
(origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(origin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(origin.x + size.width)(%lu) must be <= width(%lu).
(origin.y + size.height)(%lu) must be <= height(%lu).
(origin.z + size.depth)(%lu) must be <= depth(%lu).
origin.x(%lu) must be a multiple of %s blockWidth(%lu).
origin.y(%lu) must be a multiple of %s blockHeight(%lu).
origin.z(%lu) must be a multiple of %s blockDepth(%lu).
origin.x must be 0 (full image) for %s.
origin.y must be 0 (full image) for %s.
origin.z must be 0 (full image) for %s.
size.width(%lu) must equal width(%lu) (full image) for %s.
size.height(%lu) must equal height(%lu) (full image) for %s.
size.depth(%lu) must equal depth(%lu) (full image) for %s.
rowBytes must be 0 for %s.
imageBytes must be 0 for %s.
rowBytes(%lu) must be >= (%lu).
imageBytes(%lu) must be >= (%lu).
rowBytes(%lu) must be a multiple of %s %s bytes(%lu).
block
pixel
imageBytes(%lu) must be a multiple of %s %s bytes(%lu).
CPU access for this texture with pixel format %s is disallowed.
Replacing region on slice(%u) on mipmapLevel(%u) that is currently attached as a writeable render target.
_validateGetBytes
Get Bytes Validation
GetBytes Validation
_validateTextureView
Texture View Validation
cannot create View from Memoryless texture.
texture usage (0x%02lx) doesn't specify MTLTextureUsagePixelFormatView (0x%02lx)
invalid pixelFormat.
texture view creation not allowed from frameBufferOnly textures.
textureType %@ cannot be used for buffer-backed textures.
-[MTLDebugAccelerationStructure setPurgeableState:]
Intel
-[MTLDebugIOCommandBuffer internalValidateEvent:]
IO Command Buffer Event Validation
event must not be nil.
event is not a MTLSharedEvent.
event is associated with a different device.
-[MTLDebugIOCommandBuffer internalValidateLoadBuffer:offset:size:sourceHandle:sourceHandleOffset:]
Load Buffer From IO Handle Validation
buffer is associated with a different device.
sourceHandle must not be nil.
sourceHandle is not a MTLIOFileHandle.
sourceHandle is associated with a different device.
(offset + size)(%lu) must be <= [buffer length](%lu).
sourceHandleOffset(%lu) must be <= [sourceHandle length](%lu)
sourceHandleOffset(%lu) + size(%lu) must be <= [sourceHandle length](%lu)
-[MTLDebugIOCommandBuffer internalValidateLoadBytes:size:sourceHandle:sourceHandleOffset:]
Load Bytes From IO Handle Validation
-[MTLDebugIOCommandBuffer internalValidateLoadTexture:slice:level:size:sourceBytesPerRow:sourceBytesPerImage:destinationOrigin:sourceHandle:sourceHandleOffset:]
Load Texture From IO Handle Validation
texture is associated with a different device.
texture is Memoryless and cannot be used for load operations.
(destinationOrigin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + adjustedSize.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + size.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + size.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= depth(%lu).
3D compressed texture loading is not supported.
texture buffer loading is not supported.
-[MTLDebugIOCommandBuffer commit]
IO Command Buffer Commit Validation
committing an already committed io command buffer.
-[MTLDebugIOCommandBuffer tryCancel]
IO Command Buffer tryCancel Validation
trying to cancel an uncommitted io command buffer.
12StringBuffer
12AppendBuffer
12BinaryBuffer
BufferHeap::MemoryAllocated (MB) - %.2f
BufferHeap::MemoryUsed (MB) - %.2f/%.2f
DescriptorHeapSize (MB) - %.2f
DescriptorHeapNewHandle - %llu
ConstantBufferCache::TotalMemory - %llu
Device Alloc - %s, %p
Device Dealloc - %s, %p
Fatal failure when instrumenting %s "%s":
Function is not instrumented and faults will not be detected.
Partial failure when instrumenting %s "%s":%s%s
MTLDebugIndirectComputeCommand
MTLGPUDebugRenderCommandEncoder
MTLGPUDebugCommandEncoder
NSObject
MTLToolsIndirectCommandBuffer
MTLIndirectCommandBufferSPI
MTLIndirectCommandBuffer
MTLResource
MTLGPUDebugGPULog
MTLFunctionLog
MTLGPUDebugBufferErrorLog
MTLGPUDebugTextureErrorLog
MTLGPUDebugStackOverflowErrorLog
MTLGPUDebugTrapErrorLog
MTLToolsBlitCommandEncoder
MTLBlitCommandEncoderSPI
MTLCommandEncoderSPI
MTLCommandEncoder
MTLBlitCommandEncoder
MTLToolsFence
MTLFenceSPI
MTLFence
MTLCountersRenderCommandEncoder
MTLToolsCounterSampleBuffer
MTLCounterSampleBuffer
MTLGPUDebugLibrary
MTLToolsBuffer
MTLBufferSPI
MTLResourceSPI
MTLBuffer
MTLToolsCommandBuffer
MTLCommandBufferSPI
MTLCommandBuffer
MTLToolsRetainingContainer
MTLToolsCommandEncoder
MTLToolsPerfCounterMailbox
MTLToolsCommandQueue
MTLCommandQueueSPI
MTLCommandQueue
MTLDebugVisibleFunctionTable
MTLDebugResourcePurgeable
MTLToolsDynamicLibrary
MTLDynamicLibrarySPI
MTLDynamicLibrary
MTLToolsBinaryArchive
MTLBinaryArchiveSPI
MTLBinaryArchive
MTLToolsHeap
MTLHeapSPI
MTLHeap
MTLToolsComputeCommandEncoder
MTLComputeCommandEncoderSPI
MTLComputeCommandEncoder
MTLGPUDebugImageData
MTLToolsAccelerationStructureCommandEncoder
MTLAccelerationStructureCommandEncoderSPI
MTLAccelerationStructureCommandEncoder
MTLToolsComputePipelineState
MTLComputePipelineStateSPI
MTLComputePipelineState
MTLPipelineStateWithProgramAddressTable
MTLGPUDebugAccelerationStructure
MTLGPUDebugResource
MTLGPUDebugBuffer
MTLToolsDepthStencilState
MTLDepthStencilStateSPI
MTLDepthStencilState
MTLToolsIndirectComputeCommand
MTLIndirectComputeCommandSPI
MTLIndirectComputeCommand
MTLGPUDebugDevice
MTLToolsDevice
MTLDeviceSPI
MTLDevice
MTLToolsEvent
MTLEventSPI
MTLEvent
MTLToolsSharedEvent
MTLSharedEventSPI
MTLSharedEvent
MTLToolsLateEvalEvent
MTLLateEvalEvent
MTLToolsFunction
MTLFunctionSPI
MTLFunction
MTLToolsLibrary
MTLLibrarySPI
MTLLibrary
MTLToolsVisibleFunctionTable
MTLVisibleFunctionTableSPI
MTLVisibleFunctionTable
MTLDebugPipelineLibrary
MTLCountersComputeCommandEncoder
MTLGPUDebugRenderPipelineState
MTLGPUDebugAccelerationStructureCommandEncoder
MTLToolsObject
MTLToolsParallelRenderCommandEncoder
MTLParallelRenderCommandEncoderSPI
MTLParallelRenderCommandEncoder
MTLToolsIntersectionFunctionTable
MTLIntersectionFunctionTableSPI
MTLIntersectionFunctionTable
MTLToolsRenderCommandEncoder
MTLRenderCommandEncoderSPI
MTLRenderCommandEncoder
MTLGPUDebugIntersectionFunctionTable
MTLGPUDebugIndirectComputeCommand
MTLToolsRasterizationRateMap
MTLRasterizationRateMapSPI
MTLRasterizationRateMap
MTLDebugIntersectionFunctionTable
MTLCountersTraceCommandEncoder
MTLCountersTraceBlitCommandEncoder
MTLCountersTraceComputeCommandEncoder
MTLCountersTraceRenderCommandEncoder
MTLCountersTraceResourceStateCommandEncoder
MTLCountersTraceCommandBuffer
MTLToolsRenderPipelineState
MTLRenderPipelineStateSPI
MTLRenderPipelineState
MTLToolsResource
MTLToolsResourceGroupSPI
MTLResourceGroupSPI
MTLGPUDebugIndirectRenderCommand
MTLToolsSamplerState
MTLSamplerState
MTLSamplerStateSPI
MTLToolsTexture
MTLTextureImplementation
MTLTextureSPI
MTLTexture
MTLToolsTextureLayout
MTLTextureLayout
MTLCountersParallelRenderCommandEncoder
MTLGPUDebugCommandBuffer
MTLGPUDebugBufferEncoder
MTLToolsResourceStateCommandEncoder
MTLResourceStateCommandEncoderSPI
MTLResourceStateCommandEncoder
MTLDebugBlitCommandEncoder
MTLDebugResourceStateCommandEncoder
MTLDebugBufferMarker
MTLDebugBuffer
MTLDebugDeadlineProfile
MTLGPUDebugCommandQueue
MTLDebugCommandBuffer
MTLGPUDebugBinaryArchive
MTLGPUDebugPipelineStateInfoEncoder
MTLDebugDynamicLibrary
MTLToolsIndirectRenderCommand
MTLIndirectRenderCommandSPI
MTLIndirectRenderCommand
MTLDebugCounterSampleBuffer
MTLDebugBinaryArchive
MTLCountersDevice
MTLGPUDebugArgumentEncoder
MTLGPUDebugComputePipelineState
MTLDebugCommandQueue
MTLDebugComputeCommandEncoder
MTLAccelerationStructure
MTLDebugAccelerationStructureCommandEncoder
MTLDebugFunctionHandle
MTLFunctionHandle
MTLDebugComputePipelineState
MTLDebugIndirectCommandBuffer
MTLCountersCommandQueue
MTLToolsPipelineLibrary
MTLPipelineLibrarySPI
MTLPipelineLibrary
MTLToolsArgumentEncoder
MTLArgumentEncoderSPI
MTLArgumentEncoder
MTLGPUDebugHeap
MTLDebugArgumentEncoder
MTLIOScratchBufferAllocator
MTLDebugDevice
MTLDebugDepthStencilState
MTLGPUDebugIndirectCommandBuffer
MTLDebugEvent
MTLDebugSharedEvent
MTLDebugLateEvalEvent
MTLGPUDebugFunctionHandle
MTLGPUDebugParallelRenderCommandEncoder
MTLCountersResourceStateCommandEncoder
MTLToolsAccelerationStructure
MTLAccelerationStructureSPI
MTLToolsObjectCache
MTLDebugFunction
MTLDebugLibrary
MTLDebugParallelRenderCommandEncoder
MTLDebugRenderTargetAttachmentInfo
MTLDebugRenderCommandEncoder
MTLToolsDeadlineProfile
MTLDeadlineProfile
MTLCountersCommandBuffer
MTLGPUDebugBlitCommandEncoder
MTLGPUDebugVisibleFunctionTable
MTLDebugResource
MTLGPUDebugComputeCommandEncoder
MTLToolsFunctionHandle
MTLGPUDebugFunction
MTLDebugIndirectRenderCommand
MTLDebugRenderPipelineState
MTLDebugSamplerState
MTLDebugHeap
MTLDebugTexture
MTLDebugTextureLayout
MTLGPUDebugDynamicLibrary
MTLDebugAccelerationStructure
MTLGPUDebugTexture
MTLToolsIOCommandBuffer
MTLIOCommandBufferSPI
MTLIOCommandBuffer
MTLToolsIOHandle
MTLIOHandleSPI
MTLIOFileHandle
MTLToolsIOScratchBufferAllocator
MTLToolsIOScratchBuffer
MTLIOScratchBuffer
MTLToolsIOCommandQueue
MTLIOCommandQueueSPI
MTLIOCommandQueue
MTLDebugIOCommandBuffer
MTLDebugIOHandle
MTLDebugIOScratchBufferAllocator
MTLDebugIOScratchBuffer
MTLDebugIOCommandQueue
MTLCountersBlitCommandEncoder
initWithBaseObject:parent:
dealloc
inheritPipelineState
baseObject
supportIndirectCommandBuffers
setComputePipelineState:
maxKernelBufferBindCount
inheritBuffers
setKernelBuffer:offset:atIndex:
commandTypes
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
initWithBaseObject:descriptor:indexCount:indirectCommandBuffer:
index
indirectCommandBuffer
_desc
_index
_iCB
TQ,R
T@"<MTLIndirectCommandBuffer>",R
initWithRenderCommandEncoder:parent:descriptor:
_initBufferArgumentData:
initWithRenderCommandEncoder:parent:
commandBuffer
temporaryBufferWithBytes:length:
temporaryBufferWithLength:
vertexFunctionData
setVertexBytes:length:atIndex:
fragmentFunctionData
setFragmentBytes:length:atIndex:
fragmentMaxCallStackDepth
tileFunctionData
setTileBytes:length:atIndex:
tileMaxCallStackDepth
tileDebugInstrumentationData
activeThreadgroupMask
fragmentDebugInstrumentationData
setThreadgroupMemoryLength:offset:atIndex:
objectFunctionData
setObjectBytes:length:atIndex:
objectMaxCallStackDepth
meshFunctionData
setMeshBytes:length:atIndex:
meshMaxCallStackDepth
useResource:usage:
markBuffer:usage:stages:
handleForOffset:
setVertexBuffer:offset:atIndex:
useResource:usage:stages:
addRetainedObject:
supportsMeshShaders
setMeshBuffer:offset:atIndex:
setObjectBuffer:offset:atIndex:
setFragmentBuffer:offset:atIndex:
supportsTileShaders
setTileBuffer:offset:atIndex:
vertexConstantsBuffer
fragmentConstantsBuffer
tileConstantsBuffer
meshConstantsBuffer
objectConstantsBuffer
binaryFunctionData
countByEnumeratingWithState:objects:count:
flushBindings
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
setTessellationControlPointIndexBuffer:offset:
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
dispatchThreadsPerTile:
dispatchThreadsPerTile:inRegion:
dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
setVertexAmplificationCount:viewMappings:
useResourceInternal:usage:stages:
markTexture:usage:stages:
useWithRenderEncoder:usage:stages:
_useResourceCommon:usage:stages:
markHeap:stages:
useHeap:
useHeap:stages:
setDepthStencilState:
beginUseOfMeshShadersInEncoder:
setRenderPipelineStateBuffers:
setRenderPipelineState:
setVertexVisibleFunctionTable:atBufferIndex:
setFragmentVisibleFunctionTable:atBufferIndex:
setTileVisibleFunctionTable:atBufferIndex:
setObjectVisibleFunctionTable:atBufferIndex:
setMeshVisibleFunctionTable:atBufferIndex:
setVertexIntersectionFunctionTable:atBufferIndex:
setFragmentIntersectionFunctionTable:atBufferIndex:
setTileIntersectionFunctionTable:atBufferIndex:
setVertexAccelerationStructure:atBufferIndex:
setFragmentAccelerationStructure:atBufferIndex:
setTileAccelerationStructure:atBufferIndex:
setObjectIntersectionFunctionTable:atBufferIndex:
setMeshIntersectionFunctionTable:atBufferIndex:
setObjectAccelerationStructure:atBufferIndex:
setMeshAccelerationStructure:atBufferIndex:
endingEncoder:type:
endEncoding
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
T#,R
T@"NSString",R,C
encoderID
TI,R
initWithRenderCommandEncoder:commandBuffer:descriptor:encoderID:
initWithRenderCommandEncoder:parallelEncoder:encoderID:
setBufferUsageTable:textureUsageTable:forStage:
setVertexReportBuffer:offset:
setFragmentReportBuffer:offset:
setTileReportBuffer:offset:
setObjectReportBuffer:offset:
setMeshReportBuffer:offset:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
setObjectBufferOffset:atIndex:
setObjectBuffers:offsets:withRange:
setMeshBufferOffset:atIndex:
setMeshBuffers:offsets:withRange:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setTileTexture:atIndex:
setTileTextures:withRange:
setMeshTexture:atIndex:
setMeshTextures:withRange:
setObjectTexture:atIndex:
setObjectTextures:withRange:
executeCommandsInBuffer:withRange:
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
useResources:count:usage:
useResources:count:usage:stages:
useHeaps:count:
useHeaps:count:stages:
setVertexVisibleFunctionTables:withBufferRange:
setFragmentVisibleFunctionTables:withBufferRange:
setTileVisibleFunctionTables:withBufferRange:
setObjectVisibleFunctionTables:withBufferRange:
setMeshVisibleFunctionTables:withBufferRange:
setVertexIntersectionFunctionTables:withBufferRange:
setFragmentIntersectionFunctionTables:withBufferRange:
setTileIntersectionFunctionTables:withBufferRange:
setVertexAccelerationStructures:withBufferRange:
setFragmentAccelerationStructures:withBufferRange:
setTileAccelerationStructures:withBufferRange:
setObjectIntersectionFunctionTables:withBufferRange:
setMeshIntersectionFunctionTables:withBufferRange:
setObjectAccelerationStructures:withBufferRange:
setMeshAccelerationStructures:withBufferRange:
.cxx_construct
useResourceIteration
_tileStageActive
_tileStageUsed
_fragmentStageActive
_vertexStageActive
_objectStageActive
_meshStageActive
_enableUseResourceValidation
_commandBuffer
_vertexHandles
_fragmentHandles
_tileHandles
_threadgroup
_objectHandles
_meshHandles
_options
_drawID
_encoderType
_currentPipeline
_currentDepthStencil
_vertexReportBuffer
_fragmentReportBuffer
_tileReportBuffer
_objectReportBuffer
_meshReportBuffer
_vertexAmpState
_vertexBufferUsageTable
_vertexTextureUsageTable
_fragmentBufferUsageTable
_fragmentTextureUsageTable
T@"MTLGPUDebugCommandBuffer",R,D
vertexDebugInstrumentationData
bufferAccessMask
objectDebugInstrumentationData
meshDebugInstrumentationData
device
encodeBuffers:offsets:withRange:resultOffset:
offset
indirectComputeCommandAtIndex:
indirectRenderCommandAtIndex:
size
storageMode
getHeader:headerSize:
resetWithRange:
uniqueIdentifier
gpuAddress
resourceIndex
gpuHandle
gpuResourceID
setPurgeableState:
makeAliasable
isAliasable
label
setLabel:
cpuCacheMode
hazardTrackingMode
resourceOptions
heap
heapOffset
allocatedSize
T@"NSString",C
T@"<MTLDevice>",R
T@"<MTLHeap>",R
T{MTLResourceID=Q},R
TQ,R,N
TQ,R,D,N
initWithDebugLocation:
addObject:
inlinedAt
logs
arrayWithArray:
setOperation:
setAddressSpace:
setBuffer:
setOffset:
buffer
resourceUsageForBuffer:stage:
setSpecifiedUsage:
type
setArgument:
setErrorReason:
stringForID:
setFunctionName:
setLogs:
encoderLabel
function
debugLocation
T@"NSString",R,N
T@"<MTLFunction>",R,N
T@"<MTLFunctionLogDebugLocation>",R,N
image
setImage:
errorStackTrace
setErrorStackTrace:
callIndex
setCallIndex:
setType:
setEncoderLabel:
setFunction:
setDebugLocation:
_image
_errorStackTrace
_callIndex
_type
_encoderLabel
_function
_debugLocation
T@"MTLGPUDebugImageData",&,N,V_image
T@"NSArray",&,N,V_errorStackTrace
TQ,N,V_callIndex
TQ,N,V_type
T@"NSString",&,N,V_encoderLabel
T@"<MTLFunction>",&,N,V_function
T@"<MTLFunctionLogDebugLocation>",&,N,V_debugLocation
init
length
stringWithFormat:
formattedDescription:
addressSpace
operation
argument
specifiedUsage
_addressSpace
_operation
_specifiedUsage
_buffer
_offset
_argument
Ti,N,V_addressSpace
T@"<MTLBuffer>",&,N,V_buffer
TQ,N,V_offset
Ti,N,V_operation
T@"MTLArgument",&,N,V_argument
Ti,N,V_specifiedUsage
errorReason
_errorReason
Ti,N,V_errorReason
functionName
_functionName
T@"NSString",&,N,V_functionName
name
functionType
debugInstrumentationData
userReflection
vertexArguments
arguments
kernelFunctionData
tileArguments
fragmentArguments
objectArguments
meshArguments
initWithFormat:
debugLocationForID:
encoderIdentifierForEncoderIndex:
standardizedURL
path
containsString:
objectAtIndexedSubscript:
initWithBlitCommandEncoder:parent:descriptor:
sampleBufferAttachments
sampleBuffer
updateFence:
waitForFence:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
generateMipmapsForTexture:
fillBuffer:range:value:
fillBuffer:range:pattern4:
fillTexture:level:slice:region:bytes:length:
fillTexture:level:slice:region:color:
fillTexture:level:slice:region:color:pixelFormat:
invalidateCompressedTexture:
invalidateCompressedTexture:slice:level:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
resetTextureAccessCounters:region:mipLevel:slice:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
resetCommandsInBuffer:withRange:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
optimizeIndirectCommandBuffer:withRange:
resolveCounters:inRange:destinationBuffer:destinationOffset:
sampleCountersInBuffer:atSampleIndex:withBarrier:
endEncodingAndRetrieveProgramAddressTable
insertDebugSignpost:
pushDebugGroup:
popDebugGroup
synchronizeResource:
synchronizeTexture:slice:level:
T@"MTLToolsCommandBuffer",R,D,N
APITimingEnabled
traceBuffer
renderCommandEncoder
_initWithCommandBuffer:
setVertexSamplerState:atIndex:
setVertexSamplerStates:withRange:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentSamplerState:atIndex:
setFragmentSamplerStates:withRange:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:
setTileSamplerState:atIndex:
setTileSamplerStates:withRange:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setViewport:
setViewports:count:
setFrontFacingWinding:
setCullMode:
setDepthClipMode:
setLineWidth:
setDepthBias:slopeScale:clamp:
setScissorRect:
setScissorRects:count:
setVertexAmplificationMode:value:
setTriangleFillMode:
setStencilReferenceValue:
setStencilFrontReferenceValue:backReferenceValue:
setColorStoreAction:atIndex:
setDepthStoreAction:
setStencilStoreAction:
setVisibilityResultMode:offset:
setBlendColorRed:green:blue:alpha:
setColorResolveTexture:slice:depthPlane:level:atIndex:
setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:
setDepthResolveTexture:slice:depthPlane:level:
setDepthResolveTexture:slice:depthPlane:level:yInvert:
setStencilResolveTexture:slice:depthPlane:level:
setStencilResolveTexture:slice:depthPlane:level:yInvert:
updateFence:afterStages:
waitForFence:beforeStages:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorScale:
memoryBarrierWithScope:afterStages:beforeStages:
memoryBarrierWithResources:count:afterStages:beforeStages:
_APITimingEnabled
_traceEncoder
sampleCount
resolveCounterRange:
T@"NSString",R
options
copy
modifyFunctionDescriptor:
newFunctionWithDescriptor:error:
getFunctionForBaseObject:library:
prepareForBinaryFunctionUsage
newFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:error:
setName:
setApplyFunctionConstants:
setConstantValues:
initWithLibrary:device:
newFunctionWithName:
newFunctionWithName:constantValues:error:
newFunctionWithName:constantValues:completionHandler:
newFunctionWithName:constantValues:functionCache:error:
newFunctionWithName:constantValues:pipelineLibrary:error:
newFunctionWithName:constantValues:pipelineLibrary:completionHandler:
underlyingGPUAddress
stringByPaddingToLength:withString:startingAtIndex:
arrayWithObjects:count:
componentsJoinedByString:
parentGPUAddress
setParentGPUAddress:
parentGPUSize
setParentGPUSize:
contents
didModifyRange:
newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:
_aneIOSurface
addDebugMarker:range:
removeAllDebugMarkers
newTextureWithDescriptor:offset:bytesPerRow:
initWithBaseObject:parent:buffer:
iosurface
isPurgeable
isComplete
waitUntilComplete
doesAliasResource:
doesAliasAllResources:count:
doesAliasAnyResources:count:
responsibleProcess
setResponsibleProcess:
allocationID
protectionOptions
unfilteredResourceOptions
setOwnerWithIdentity:
T^{__IOSurface=},R
TQ,N
initWithCommandBuffer:parent:descriptor:
retainedReferences
originalObject
snapshotPerfSampleHandlerAndStatEnabled:forCommandBuffer:
deadlineProfile
invokeScheduledHandlers
invokeCompletedHandlers
preScheduledHandlers
postScheduledHandlers
preCompletionHandlers
postCompletionHandlers
removeAllObjects
clearRetainedObjects
status
extractDataAndNumSamples:forRequester:isLast:
addScheduledHandler:
addCompletedHandler:
preCommit
commit
commitAndHold
commitAndWaitUntilSubmitted
debugCommandEncoder
GPUStartTime
GPUEndTime
globalTraceObjectID
enqueue
presentDrawable:
presentDrawable:atTime:
presentDrawable:options:
waitUntilScheduled
waitUntilCompleted
error
blitCommandEncoder
computeCommandEncoder
accelerationStructureCommandEncoder
resourceStateCommandEncoder
kernelStartTime
kernelEndTime
debugBufferContentsWithLength:
encodeDashboardTagForResourceGroup:
encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:
encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:
visibilityResultBuffer
setVisibilityResultBuffer:
_descriptorPrivate
_descriptorAtIndex:
texture
colorAttachments
setTexture:
resolveTexture
setResolveTexture:
depthAttachment
stencilAttachment
setSampleBuffer:
setRasterizationRateMap:
unwrapMTLComputePassDescriptorInternal:
unwrapMTLRenderPassDescriptor:
renderCommandEncoderWithDescriptor:
parallelRenderCommandEncoderWithDescriptor:
initWithParallelRenderCommandEncoder:parent:descriptor:
sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:
initWithComputeCommandEncoder:parent:descriptor:
computeCommandEncoderWithDispatchType:
unwrapMTLComputePassDescriptor:
computeCommandEncoderWithDescriptor:
sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:
unwrapMTLBlitPassDescriptor:
blitCommandEncoderWithDescriptor:
unwrapMTLResourceStatePassDescriptor:
resourceStateCommandEncoderWithDescriptor:
initWithResourceStateCommandEncoder:parent:descriptor:
encodeSignalEvent:value:
encodeWaitForEvent:value:
encodeWaitForEvent:value:timeout:
addPurgedResource:
addPurgedHeap:
sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:
isProfilingEnabled
setProfilingEnabled:
profilingResults
userDictionary
getListIndex
addSynchronizationNotification:
executeSynchronizationNotifications:
executeSynchronizationNotifications:scope:resources:count:
setResourceGroups:count:
dropResourceGroups:count:
encodeCacheHintTag:resourceGroups:count:
encodeCacheHintFinalize:resourceGroups:count:
setProtectionOptions:
errorOptions
rasterizationRateMap
commitWithDeadline:
commitAndWaitUntilSubmittedWithDeadline:
unwrapMTLAccelerationStructurePassDescriptor:
accelerationStructureCommandEncoderWithDescriptor:
initWithAccelerationStructureCommandEncoder:parent:descriptor:
commandQueue
T@"<MTLCommandQueue>",R
TB,R
Td,R
T@"<MTLLogContainer>",R
T@"NSError",R
listIndex
TQ,R,N,GgetListIndex
profilingEnabled
TB,GisProfilingEnabled
T@"NSDictionary",R
T@"NSMutableDictionary",R,N
T@"<MTLDeadlineProfile>",R,&
retainedObjects
T@"NSMutableSet",R,N
willEncodeSignalEvent:value:writeableResources:
retainObjectsFromRenderPassDescriptor:
useRetainedObjectsLock
setUseRetainedObjectsLock:
.cxx_destruct
_flags
_retainedObjectsLock
_useRetainedObjectsLock
_handlerLock
_scheduledHandlers
_completedHandlers
_didInvokeHandlers
_perfSampleHandlerBlock
_StatEnabled
_deadlineProfile
_retainedObjects
TB,V_useRetainedObjectsLock
T@"NSMutableSet",R,N,V_retainedObjects
filterCounterRangeWithFirstBatch:lastBatch:filterIndex:
initWithBaseObject:parallelRenderCommandEncoder:
T@"<MTLToolsRetainingContainer>",R,N,V_commandBuffer
insertData:andNumSamples:forRequester:
_requester
_data
_iterator
commandBufferWithUnretainedReferences
unwrapMTLCommandBufferDescriptor:alwaysCopy:
commandBufferWithDescriptor:
insertDebugCaptureBoundary
dispatchAvailableCompletionNotifications
getGPUPriority
setGPUPriority:
setGPUPriority:offset:
getBackgroundGPUPriority
setBackgroundGPUPriority:
setBackgroundGPUPriority:offset:
maxCommandBufferCount
backgroundTrackingPID
setBackgroundTrackingPID:
finish
skipRender
setSkipRender:
executionEnabled
setExecutionEnabled:
setCompletionQueue:
setSubmissionQueue:
isOpenGLQueue
getSPIStats
requestCounters:
addPerfSampleHandler:
isStatEnabled
requestCounters:withIndex:
subdivideCounterList:
qosLevel
commitQueue
commitSynchronously
completionQueue
disableCrossQueueHazardTracking
availableCounters
getRequestedCounters
setStatEnabled:
getStatOptions
setStatOptions:
getStatLocations
setStatLocations:
counterInfo
availableCountersAndDict
T@"NSObject<OS_dispatch_queue>",R
StatEnabled
TB,N,GisStatEnabled
StatOptions
TQ,N,GgetStatOptions
StatLocations
TQ,N,GgetStatLocations
_perfSampleMailbox
_perfHandlerLock
functionCount
supportsFunctionPointers
stage
validateHandleForSetFunction:
setFunction:atIndex:
numberWithUnsignedInteger:
lockPurgeableState
unlockPurgeableState
purgeableStateValidForRendering
initWithVisibleFunctionTable:parent:descriptor:stage:
initWithVisibleFunctionTable:parent:descriptor:pipelineState:stage:
setFunctions:withRange:
_purgeableStateToken
_purgeableStateHasBeenSet
_functionCount
_pipelineState
_stage
TQ,R,V_functionCount
TQ,R,V_stage
binaryData
exportedFunctions
exportedVariables
importedSymbols
importedLibraries
installName
libraryPath
libraryUUID
serializeToURL:error:
serializeToURL:options:error:
unwrapMTLRelocations:
setRelocations:
shaderValidationEnabled
setDebugInstrumentationData:
removeKey:
relocations
T@"NSObject<OS_dispatch_data>",R
T@"NSArray",R
Tr^{?=[32C]},R
T@"NSArray",C,N
T@"MTLDebugInstrumentationData",&,N
TB,R,N
_relocations
unwrapMTLComputePipelineDescriptor:
addComputePipelineFunctionsWithDescriptor:error:
addComputePipelineFunctionsWithDescriptor:options:error:
unwrapMTLRenderPipelineDescriptor:
addRenderPipelineFunctionsWithDescriptor:error:
addRenderPipelineFunctionsWithDescriptor:options:error:
unwrapMTLTileRenderPipelineDescriptor:
addTileRenderPipelineFunctionsWithDescriptor:error:
addTileRenderPipelineFunctionsWithDescriptor:options:error:
unwrapMTLMeshRenderPipelineDescriptor:
addMeshRenderPipelineFunctionsWithDescriptor:error:
addMeshRenderPipelineFunctionsWithDescriptor:options:error:
unwrapMTLStitchedLibraryDescriptor:
addLibraryWithDescriptor:error:
keys
addArchiveEntry:forKey:
getArchiveDataForKey:
addBinaryEntry:forKey:
getBinaryDataForKey:
pipelineCollection
enumerateArchivesFromBackingFile:
enumerateArchivesFromPipelineCollection:
storeComputePipelineDescriptor:
storeRenderPipelineDescriptor:
storeTileRenderPipelineDescriptor:
storeMeshRenderPipelineDescriptor:
getArchiveIDWithError:
recompilablePipelineCount
newPipelineDescriptorAtIndex:pipelineType:error:
archiveFunctionIds
unwrapMTLFunctionDescriptor:
addFunctionWithDescriptor:library:error:
usedSize
maxAvailableSizeWithAlignment:
currentAllocatedSize
initWithBaseObject:parent:heap:
newBufferWithLength:options:
_newToolsBuffer:
newBufferWithLength:options:offset:
newTextureWithDescriptor:
_newToolsTexture:
newTextureWithDescriptor:offset:
newAccelerationStructureWithSize:
_newToolsAccelerationStructure:
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithSize:offset:
newAccelerationStructureWithDescriptor:offset:
newAccelerationStructureWithSize:resourceIndex:
newAccelerationStructureWithSize:offset:resourceIndex:
Tq,R
notifyResourceReleasing:
setBytes:length:atIndex:
setBufferOffset:atIndex:
setBuffer:offset:atIndex:
setBuffers:offsets:withRange:
setTexture:atIndex:
setTextures:withRange:
setSamplerState:atIndex:
setSamplerStates:withRange:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setThreadgroupMemoryLength:atIndex:
dispatchThreadgroups:threadsPerThreadgroup:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
setImageblockWidth:height:
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
newKernelDebugInfo
dispatchType
memoryBarrierWithScope:
memoryBarrierWithResources:count:
enableNullBufferBinds:
setVisibleFunctionTable:atBufferIndex:
setVisibleFunctionTables:withBufferRange:
setIntersectionFunctionTable:atBufferIndex:
setIntersectionFunctionTables:withBufferRange:
setAccelerationStructure:atBufferIndex:
useResourceGroup:usage:
encodeStartDoWhile
encodeEndDoWhile:offset:comparison:referenceValue:
encodeStartWhile:offset:comparison:referenceValue:
encodeEndWhile
encodeStartIf:offset:comparison:referenceValue:
encodeStartElse
encodeEndIf
setThreadgroupPackingDisabled:
setImageBlockWidth:height:
_applyImageIDRelocation:
initWithFunction:debugInstrumentationData:
_applyConstantRelocation:
supportsGlobalVariableRelocationCompute
initWithSymbolName:bytes:length:
count
initWithCapacity:
addObjectsFromArray:
_applyConstantRelocation
setBufferIndex:
bufferIndex
initWithDynamicLibrary:
initWithFunction:
setConstantData:
loadedImageName
dynamicLibrary
imageType
constantDataBuffer
_device
_constantDataMutex
_constantDataBufferIndex
_constantDataKeyPair
_loadedImageName
_debugInstrumentationData
_imageType
_imageID
_functionType
_dynamicLibrary
Ti,R,N
T@"MTLDebugInstrumentationData",R,N
T@"MTLGPUDebugFunction",R,W,N
T@"MTLGPUDebugDynamicLibrary",R,W,N
isSubclassOfClass:
geometryDescriptors
primitiveDataBuffer
setPrimitiveDataBuffer:
vertexBuffer
setVertexBuffer:
indexBuffer
setIndexBuffer:
transformationMatrixBuffer
setTransformationMatrixBuffer:
vertexBuffers
boundingBoxBuffers
boundingBoxBuffer
setBoundingBoxBuffer:
instanceDescriptorBuffer
setInstanceDescriptorBuffer:
instancedAccelerationStructures
setObject:atIndexedSubscript:
motionTransformBuffer
setMotionTransformBuffer:
buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
copyAccelerationStructure:toAccelerationStructure:
writeCompactedAccelerationStructureSize:toBuffer:offset:
writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:
copyAndCompactAccelerationStructure:toAccelerationStructure:
writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:
writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:
writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:
serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:
arrayWithCapacity:
serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:
serializeAccelerationStructure:toBuffer:serializedBufferOffset:
deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:
writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:
writeGenericBVHStructureSizesOfAccelerationStructure:into:
version
initWithVersion:
headerBuffer
setHeaderBuffer:
headerBufferOffset
setHeaderBufferOffset:
innerNodeBuffer
setInnerNodeBuffer:
innerNodeBufferOffset
setInnerNodeBufferOffset:
leafNodeBuffer
setLeafNodeBuffer:
leafNodeBufferOffset
setLeafNodeBufferOffset:
primitiveBuffer
setPrimitiveBuffer:
primitiveBufferOffset
setPrimitiveBufferOffset:
geometryBuffer
setGeometryBuffer:
geometryBufferOffset
setGeometryBufferOffset:
instanceTransformBuffer
setInstanceTransformBuffer:
instanceTransformBufferOffset
setInstanceTransformBufferOffset:
perPrimitiveDataBuffer
setPerPrimitiveDataBuffer:
perPrimitiveDataBufferOffset
setPerPrimitiveDataBufferOffset:
writeGenericBVHStructureOfAccelerationStructure:into:
writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:
writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:
writeAccelerationStructureSerializationData:toBuffer:offset:
functionHandleWithFunction:
newComputePipelineStateWithAdditionalBinaryFunctions:error:
newVisibleFunctionTableWithDescriptor:
newIntersectionFunctionTableWithDescriptor:
textureWriteRoundingMode
maxTotalThreadsPerThreadgroup
threadExecutionWidth
staticThreadgroupMemoryLength
imageblockMemoryLengthForDimensions:
pipelineBinaries
T@"MTLDebugInstrumentationData",R,&,N
newComputePipelineStateWithAdditionalBinaryFunctions:
_setupIdentifier
setDataType:
setIndex:
newArgumentEncoderWithArguments:
setArgumentBuffer:offset:
setAccelerationStructure:atIndex:
useResourceInternal:usage:
useWithComputeEncoder:usage:
T@"<MTLResource>",R,N
initWithAccelerationStructure:device:
initWithAccelerationStructure:heap:
_gpuIdentifier
T@"<MTLAccelerationStructure>",&,D,N
initWithBuffer:device:offset:length:track:
initWithBuffer:heap:device:offset:length:track:
initWithBuffer:device:
initWithBuffer:device:offset:length:
initWithBuffer:heap:device:
isTracked
_bufferIndex
_length
_descriptorHeap
T@"<MTLBuffer>",&,D,N
initWithTextureView:parentBuffer:heap:device:
encodedLength
constantDataAtIndex:
readsDepth
writesDepth
readsStencil
writesStencil
initWithDepthStencilState:descriptor:device:
getThreadgroupMemoryLengthAtIndex:
getStageInRegion
hasBarrier
getImageBlockSize
setBarrier
clearBarrier
dispatchThreadgroupsArguments
dispatchThreadsArguments
reset
getPipelineStateUniqueIdentifier
getKernelBufferAtIndex:
getCommandType
getOptimizedStatus
newInternalBufferWithLength:options:
setAccess:
setArrayLength:
enumerateByteRangesUsingBlock:
UTF8String
supportsFamily:
supportsArgumentBuffersTier2
supportsRaytracing
initWithBytesNoCopy:length:freeWhenDone:
pluginData
_modifyPluginData:
setPluginData:
pipelineOptions
_modifyCompileOptions:
setPipelineOptions:
initWithDictionary:
setObject:forKeyedSubscript:
binaryFunctions
prepareForUsage
setForceSoftwareVertexFetch:
vertexFunction
prepareForRenderPipelineUsage
fragmentFunction
vertexLinkedFunctions
_prepareBinaryLinkedFunctions:
fragmentLinkedFunctions
meshFunction
objectFunction
meshLinkedFunctions
objectLinkedFunctions
vertexPreloadedLibraries
loadDynamicLibrariesForFunction:insertLibraries:error:
setVertexPreloadedLibraries:
_prepareInsertLibraries:
fragmentPreloadedLibraries
setFragmentPreloadedLibraries:
meshPreloadedLibraries
setMeshPreloadedLibraries:
objectPreloadedLibraries
setObjectPreloadedLibraries:
initWithLength:
bytes
isAlphaToCoverageEnabled
maxVertexCallStackDepth
maxFragmentCallStackDepth
maxMeshCallStackDepth
maxObjectCallStackDepth
dictionaryWithObjects:forKeys:count:
_modifyRenderPipelineDescriptor:
computeFunction
prepareForComputePipelineUsage
loadDynamicLibrariesForComputeDescriptor:error:
setPreloadedLibraries:
maxCallStackDepth
preloadedLibraries
linkedFunctions
_modifyComputePipelineDescriptor:
tileFunction
_modifyTilePipelineDescriptor:
_modifyMeshRenderPipelineDescriptor:
newCommandQueueWithDescriptor:
initWithCommandQueue:device:
commandQueueDescriptor
setMaxCommandBufferCount:
newRenderPipelineStateWithDescriptor:options:reflection:error:
unwrapAndModifyRenderPipelineDescriptor:options:
initWithRenderPipelineState:descriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
releaseReflection
onRenderPipelineCreated:
newRenderPipelineStateWithDescriptor:options:completionHandler:
unwrapAndModifyTileRenderPipelineDescriptor:options:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
initWithRenderPipelineState:tileDescriptor:reflection:device:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
errorWithDomain:code:userInfo:
newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
newComputePipelineStateWithDescriptor:options:reflection:error:
unwrapAndModifyComputePipelineDescriptor:options:
initWithComputePipelineState:descriptor:unwrappedDescriptor:reflection:device:
onComputePipelineCreated:
newComputePipelineStateWithDescriptor:options:completionHandler:
setComputeFunction:
newComputePipelineStateWithDescriptor:error:
newComputePipelineStateWithDescriptor:completionHandler:
setMaxVertexBufferBindCount:
setMaxFragmentBufferBindCount:
setMaxKernelBufferBindCount:
setInheritBuffers:
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
initWithIndirectCommandBuffer:descriptor:maxCommandCount:resourceOptions:device:
initWithArray:
functions
setFunctions:
unwrapStitchedLibraryDescriptor:
setShaderValidationEnabled:
newLibraryWithStitchedDescriptor:completionHandler:
newLibraryWithStitchedDescriptor:error:
newLibraryWithStitchedDescriptorSPI:error:
newDagStringWithGraphs:
newLibraryWithSource:options:completionHandler:
newDynamicLibraryWithURL:options:error:
loadDynamicLibrariesForFunction:insertLibraries:options:error:
newBinaryArchiveWithDescriptor:error:
initWithBinaryArchive:device:
newBinaryLibraryWithOptions:url:error:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithIOSurface:
newBufferWithDescriptor:
newHeapWithDescriptor:
initWithHeap:descriptor:device:
newTextureWithDescriptor:iosurface:plane:
newTextureWithBytesNoCopy:length:descriptor:deallocator:
newArgumentEncoderWithArguments:structType:
mutableCopy
constantBlockAlignment
dataType
setConstantBlockAlignment:
insertObject:atIndex:
initWithArgumentEncoder:layout:device:
validateRaytracing
accelerationStructureSizesWithDescriptor:
newAccelerationStructureWithBuffer:offset:
newAccelerationStructureWithBuffer:offset:resourceIndex:
deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:
deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:
newAccelerationStructureWithSize:withDescriptor:
initWithVisibleFunctionTable:descriptor:device:
initWithIntersectionFunctionTable:device:descriptor:
supportsCMPIndirectCommandBuffers
supportsRenderDynamicLibraries
supportsGlobalVariableRelocationRender
supportsFunctionPointersFromRender
supportsRaytracingFromRender
initWithDynamicLibrary:device:
getCachedObjectForKey:onMiss:
initWithFunction:library:
newStageBufferArgumentEncoder
newStageArgumentBuffer
unwrapAndModifyMeshRenderPipelineDescriptor:options:
newCommandQueue
newCommandQueueWithMaxCommandBufferCount:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:error:
newRenderPipelineStateWithMeshDescriptor:completionHandler:
newRenderPipelineStateWithMeshDescriptor:error:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
ICB_Inherit_PSO_VertexPipelineState
ICB_Inherit_None_VertexPipelineState
ICB_Inherit_Buffers_VertexPipelineState
ICB_DepthStencilState
ICB_Inherit_PSO_ComputePipelineState
ICB_Inherit_None_ComputePipelineState
ICB_Inherit_Buffers_ComputePipelineState
ICB_Inherit_Both_ComputePipelineState
newLibraryWithCIFiltersForComputePipeline:imageFilterFunctionInfo:error:
newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithCIFilters:imageFilterFunctionInfo:error:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newLibraryWithDAG:functions:error:
newLibraryWithDescriptor:error:
newLibraryWithDescriptor:completionHandler:
newLibraryWithDescriptorSPI:error:
newLibraryWithFile:error:
newLibraryWithData:error:
newLibraryWithURL:error:
newLibraryWithSource:options:error:
newDynamicLibraryWithURL:error:
newDynamicLibraryFromURL:error:
newDynamicLibrary:error:
newDynamicLibrary:computeDescriptor:error:
loadDynamicLibrariesForComputeDescriptor:options:error:
newBufferWithLength:options:gpuAddress:
newBufferWithBytes:length:options:gpuAddress:
newBufferWithBytesNoCopy:length:options:gpuAddress:deallocator:
newArgumentEncoderWithLayout:
supportsGFXIndirectCommandBuffers
supportsSharedFunctionTables
supportsStackOverflowErrorCode
supportsForkJoin
getDynamicLibraryForBaseObject:
supportsResourceUsageValidation
newArgumentEncoderWithBufferBinding:
supportsRayTracingPerPrimitiveData
accelerationStructureComputePipelineState
bufferHeap
boundsCheckOptions
deviceOptions
globalBufferHeap
constantBufferCache
globalICBBufferResidentList
_boundsCheckOptionsData
_argumentDescriptors
_deviceInitFlag
_icbPipelineInit
_icbInheritVertexPipelineState
_icbInheritNoneVertexPipelineState
_icbInheritBuffersVertexPipelineState
_icbDepthStencilState
_icbInheritComputePipelineState
_icbInheritNoneComputePipelineState
_icbInheritBuffersComputePipelineState
_icbInheritBothComputePipelineState
_accelerationStructureComputePipelineState
T@"<MTLRenderPipelineState>",R,N
T@"<MTLDepthStencilState>",R,N
T@"<MTLComputePipelineState>",R,N
T@"<MTLComputePipelineState>",R,N,V_accelerationStructureComputePipelineState
bundleWithIdentifier:
URLForResource:withExtension:
setRasterizationEnabled:
setSupportIndirectCommandBuffers:
setVertexFunction:
setDepthWriteEnabled:
setDepthCompareFunction:
frontFaceStencil
setReadMask:
setWriteMask:
backFaceStencil
newDepthStencilStateWithDescriptor:
hasArgumentLimitsInstrumentationFailures
hasArgumentBufferInstrumentationFailures
hasGlobalConstantsInstrumentationFailures
unwrapMTLCompileOptions:
additionalCompilerArguments
setAdditionalCompilerArguments:
initWithTexture:heap:device:
_setDeviceWrapper:
newFunctionWithGLCoreIR:functionType:
newFunctionWithGLCoreIR:inputsDescription:functionType:
newFunctionWithGLESIR:functionType:
newFunctionWithGLESIR:inputsDescription:functionType:
newFunctionWithGLIR:functionType:
newFunctionWithGLIR:inputsDescription:functionType:
shaderDebugInfoCaching
setShaderDebugInfoCaching:
mapShaderSampleBufferWithBuffer:capacity:size:
unmapShaderSampleBuffer
reportLeaks
requiresRaytracingEmulation
GPUBVHBuilder
registryID
architecture
getMostCompatibleArchitecture:
vendorName
familyName
productName
targetDeviceInfo
targetDeviceArchitecture
library
setLibrary:
validateDynamicLibrary:state:error:
validateDynamicLibraryURL:error:
areGPUAssertionsEnabled
setGPUAssertionsEnabled:
reserveGPUAddressRange:
maxThreadsPerThreadgroup
isLowPower
isHeadless
isRemovable
hasUnifiedMemory
recommendedMaxWorkingSetSize
sharedMemorySize
dedicatedMemorySize
bufferRobustnessSupport
isDepth24Stencil8PixelFormatSupported
unloadShaderCaches
libraryCacheStats
pipelineCacheStats
copyShaderCacheToPath:
getShaderCacheKeys
compilerPropagatesThreadPriority:
newIndirectCommandBufferWithDescriptor:maxCount:options:
newIndirectRenderCommandEncoderWithBuffer:
newIndirectComputeCommandEncoderWithBuffer:
getDepthStencilStateForBaseObject:descriptor:
newSamplerStateWithDescriptor:
getSamplerStateForBaseObject:descriptor:
startCollectingPipelineDescriptors
endCollectingPipelineDescriptors
newPipelineLibraryWithFilePath:error:
serializeRenderPipelineDescriptor:
newRenderPipelineDescriptorWithSerializedData:deserializationContext:
newComputePipelineDescriptorWithSerializedData:deserializationContext:
serializeStructType:
newStructTypeWithSerializedData:
heapTextureSizeAndAlignWithDescriptor:
heapBufferSizeAndAlignWithLength:options:
newFence
indirectArgumentBufferCapabilities
newIndirectArgumentBufferLayoutWithStructType:
newIndirectArgumentEncoderWithLayout:
maxThreadgroupMemoryLength
maxArgumentBufferSamplerCount
setFragmentFunction:
pipelineLibrary
setPipelineLibrary:
setVertexLinkedFunctions:
setFragmentLinkedFunctions:
setMeshLinkedFunctions:
setObjectLinkedFunctions:
binaryArchives
setBinaryArchives:
setObjectFunction:
setMeshFunction:
setLinkedFunctions:
functionPointers
setFunctionPointers:
setTileFunction:
libraries
setLibraries:
symbolName
initWithSymbolName:buffer:offset:
privateFunctions
setPrivateFunctions:
deviceSupportsFeatureSet:
deviceOrFeatureProfileSupportsFeatureSet:
supportsFeatureSet:
supportsTextureSampleCount:
supportsSampleCount:
minLinearTextureAlignmentForPixelFormat:
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
areProgrammableSamplePositionsSupported
getDefaultSamplePositions:count:
supportsRasterizationRateMapWithLayerCount:
newRasterizationRateMapWithDescriptor:
maxRasterizationRateLayerCount
_deviceWrapper
resourcePatchingTypeForResourceType:
reserveResourceIndicesForResourceType:indices:indexCount:
halfFPConfig
singleFPConfig
doubleFPConfig
featureProfile
limits
supportPriorityBand
maxFramebufferStorageBits
linearTextureArrayAlignmentBytes
linearTextureArrayAlignmentSlice
maxTileBuffers
maxTileTextures
maxTileSamplers
maxTileInlineDataSize
minTilePixels
maxColorAttachments
maxVertexAttributes
maxVertexBuffers
maxVertexTextures
maxVertexSamplers
maxVertexInlineDataSize
maxInterpolants
maxFragmentBuffers
maxFragmentTextures
maxFragmentSamplers
maxFragmentInlineDataSize
maxComputeBuffers
maxComputeTextures
maxComputeSamplers
maxComputeInlineDataSize
maxComputeLocalMemorySizes
maxTotalComputeThreadsPerThreadgroup
maxComputeThreadgroupMemory
maxLineWidth
maxPointSize
maxVisibilityQueryOffset
minConstantBufferAlignmentBytes
minBufferNoCopyAlignmentBytes
maxTextureWidth1D
maxTextureWidth2D
maxTextureHeight2D
maxTextureWidth3D
maxTextureHeight3D
maxTextureDepth3D
maxTextureDimensionCube
maxTextureLayers
linearTextureAlignmentBytes
iosurfaceTextureAlignmentBytes
iosurfaceReadOnlyTextureAlignmentBytes
deviceLinearTextureAlignmentBytes
deviceLinearReadOnlyTextureAlignmentBytes
maxFunctionConstantIndices
maxComputeThreadgroupMemoryAlignmentBytes
maxInterpolatedComponents
maxTessellationFactor
maxIndirectBuffers
maxIndirectTextures
maxIndirectSamplers
maxIndirectSamplersPerDevice
maxFenceInstances
maxViewportCount
maxCustomSamplePositions
maxVertexAmplificationFactor
maxVertexAmplificationCount
maxTextureBufferWidth
maxComputeAttributes
maxIOCommandsInFlight
maxPredicatedNestingDepth
maxConstantBufferArguments
maxBufferLength
readWriteTextureSupport
argumentBuffersSupport
areRasterOrderGroupsSupported
isFloat32FilteringSupported
isBCTextureCompressionSupported
isMsaa32bSupported
isRGB10A2GammaSupported
isCustomBorderColorSupported
isClampToHalfBorderSupported
supportsShaderBarycentricCoordinates
isLargeMRTSupported
isQuadDataSharingSupported
isFixedLinePointFillDepthGradientSupported
sparseTexturesSupport
simulatorHostFeatureProfile
tileSizeWithSparsePageSize:textureType:pixelFormat:sampleCount:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:
newResourceGroupFromResources:count:
metalAssertionsEnabled
setMetalAssertionsEnabled:
newEvent
newSharedEvent
newSharedEventWithMachPort:
newSharedEventWithHandle:
newLateEvalEvent
newTextureLayoutWithDescriptor:isHeapOrBufferBacked:
setupMPSFunctionTable:
allowLibrariesFromOtherPlatforms
setResourcesPurgeableState:newState:oldState:count:
sparseTileSizeInBytes
sparseTileSizeInBytesForSparsePageSize:
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
counterSets
sampleTimestamps:gpuTimestamp:
supportsCounterSampling:
newCounterSampleBufferWithDescriptor:error:
isPlacementHeapSupported
commandBufferErrorOptions
setCommandBufferErrorOptions:
getSupportedCommandBufferErrorOptions
supportsPrimitiveType:
deviceCreationFlags
unwrapMTLDynamicLibraryDescriptorSPI:
validateDynamicLibraryDescriptor:error:
newDynamicLibraryWithDescriptor:error:
supportsVertexAmplificationCount:
isCompatibleWithAccelerationStructure:
deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:
deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:
isRTZRoundingSupported
supportsTextureWriteRoundingMode:
defaultTextureWriteRoundingMode
isAnisoSampleFixSupported
newProfileWithExecutionSize:
setDeadlineProfile:
supportsBufferlessClientStorageTexture
supportsComputeMemoryBarrier
supportsRenderMemoryBarrier
supportsReadWriteTextureArgumentsTier2
supportsStreamingCodecSignaling
supportsProgrammableSamplePositions
supportsLargeFramebufferConfigs
supportsCustomBorderColor
supportsSamplerAddressModeClampToHalfBorder
supportsBCTextureCompression
supports3DBCTextures
supportsRGBA10A2Gamma
supportsBGR10A2
supportsPrimitiveRestartOverride
supportsGlobalVariableRelocation
supportsTLS
supports32bpcMSAATextures
supports32BitMSAA
supports32BitFloatFiltering
supportsQueryTextureLOD
supportsVertexAmplification
supportsPlacementHeaps
supportsOpenCLTextureWriteSwizzles
supportsPullModelInterpolation
supportsInt64
supportsFixedLinePointFillDepthGradient
supportsLateEvalEvent
supportsNonZeroTextureWriteLOD
supportsSharedTextureHandles
supportsBufferPrefetchStatistics
supportsLimitedYUVFormats
supportsNonPrivateDepthStencilTextures
supportsNonPrivateMSAATextures
supportsSharedStorageHeapResources
supportsSharedStorageTextures
supportsLinearTextureFromSharedBuffer
supportsPipelineLibraries
supportsFragmentOnlyEncoders
supportsBufferWithIOSurface
supportsProgrammableBlending
supportsRenderToLinearTextures
supportsMemorylessRenderTargets
supportsFastMathInfNaNPropagation
supportsInvariantVertexPosition
supportsShaderLODAverage
supportsRelaxedTextureViewRequirements
supportsSeparateDepthStencil
supportsGPUStatistics
supportsCompressedTextureViewSPI
supportsRenderTargetTextureRotation
supportsDynamicControlPointCount
supportsIABHashForTools
supportsBinaryArchives
supportsBinaryLibraries
supportsDeadlineProfile
supportsFillTexture
supportsSetThreadgroupPackingDisabled
supportsASTCTextureCompression
supportsExtendedYUVFormats
supportsPublicXR10Formats
supportsSRGBwrites
supportsDepthClipMode
supportsPacked32TextureBufferWrites
supports3DASTCTextures
supportsExtendedXR10Formats
supportsFragmentBufferWrites
supportsCountingOcclusionQuery
supportsBaseVertexInstanceDrawing
supportsIndirectDrawAndDispatch
supportsTessellation
supportsReadWriteBufferArguments
supportsArrayOfTextures
supportsArrayOfSamplers
supportsCombinedMSAAStoreAndResolveAction
supportsMutableTier1ArgumentBuffers
supportsSamplerCompareFunction
supportsMSAADepthResolve
supportsMSAAStencilResolve
supportsMSAADepthResolveFilter
supportsIndirectStageInRegion
supportsIndirectTextures
supportsNorm16BCubicFiltering
supportsTextureOutOfBoundsReads
supportsTextureSwizzle
supportsAlphaYUVFormats
supportsMemoryOrderAtomics
supportsQuadGroup
supportsRenderTextureWrites
supportsImageBlocks
supportsImageBlockSampleCoverageControl
supportsNativeHardwareFP16
supportsPostDepthCoverage
supportsMipLevelsSmallerThanBlockSize
supportsNonUniformThreadgroupSize
supportsReadWriteTextureArguments
supportsReadWriteTextureCubeArguments
supportsTextureCubeArray
supportsQuadShufflesAndBroadcast
supportsConcurrentComputeDispatch
supportsRenderPassWithoutRenderTarget
supportsRasterOrderGroups
supportsRasterOrderGroupsColorAttachment
supportsLinearTexture2DArray
supportsNonSquareTileShaders
supportsSeparateVisibilityAndShadingRate
supports2DLinearTexArraySPI
supportsLayeredRendering
supportsViewportAndScissorArray
supportsIndirectTessellation
supportsMSAAStencilResolveFilter
supportsStencilFeedback
supportsFP32TessFactors
supportsUnalignedVertexFetch
supportsSIMDGroup
supportsShaderMinLODClamp
supportsSIMDShufflesAndBroadcast
supportsWritableArrayOfTextures
supportsVariableRateRasterization
supportsYCBCRFormats
supportsYCBCRFormatsPQ
supportsYCBCRFormats12
supportsYCBCRFormatsXR
supportsASTCHDRTextureCompression
supportsSparseTextures
supportsSparseHeaps
supportsIndirectWritableTextures
supportsDynamicLibraries
supportsStatefulDynamicLibraries
supportsPrimitiveMotionBlur
supportsRayTracingExtendedVertexFormats
supportsHeapAccelerationStructureAllocation
supportsRayTracingBuffersFromTables
supportsRayTracingAccelerationStructureCPUDeserialization
supportsBlackOrWhiteSamplerBorderColors
supportsMirrorClampToEdgeSamplerMode
supportsSIMDReduction
supportsDepthClipModeClampExtended
supportsTexture2DMultisampleArray
supportsForceSeamsOnCubemaps
supportsFloat16BCubicFiltering
supportsFloat16InfNanFiltering
supportsRTZRounding
supportsAnisoSampleFix
supportsYCBCRPackedFormatsPQ
supportsYCBCRPackedFormats12
supportsYCBCRPackedFormatsXR
supportsBufferBoundsChecking
supportsDevicePartitioning
supportsComputeCompressedTextureWrite
supportsSIMDGroupMatrix
supportsInterchangeTiled
supportsQuadReduction
supportsSIMDShuffleAndFill
supportsBfloat16Format
supportsSparseDepthAttachments
supportsAtomicUlongVoidMinMax
supportsLossyCompression
supportsFunctionPointersFromMesh
supportsMeshShadersInICB
supportsCommandBufferJump
supportsRayTracingICBs
supportsExplicitVisibilityGroups
initWithSamplerState:descriptor:device:
heapAccelerationStructureSizeAndAlignWithSize:
heapAccelerationStructureSizeAndAlignWithDescriptor:
newIOHandleWithURL:error:
newIOHandleWithURL:compressionType:error:
newUncachedIOHandleWithURL:error:
newUncachedIOHandleWithURL:compressionType:error:
scratchBufferAllocator
setScratchBufferAllocator:
newIOCommandQueueWithDescriptor:error:
lookupRecompiledBinaryArchive:
registerDevices
newIOHandleWithURL:compressionMethod:error:
areBarycentricCoordsSupported
T{?=QQQ},R
lowPower
TB,R,GisLowPower
headless
TB,R,GisHeadless
removable
TB,R,GisRemovable
depth24Stencil8PixelFormatSupported
TB,R,GisDepth24Stencil8PixelFormatSupported
rasterOrderGroupsSupported
TB,R,GareRasterOrderGroupsSupported
barycentricCoordsSupported
TB,R,GareBarycentricCoordsSupported
programmableSamplePositionsSupported
TB,R,GareProgrammableSamplePositionsSupported
indirectArgumentBufferDecodingData
setIndirectArgumentBufferDecodingData:
getBVHBuilderLock
getRawBVHBuilderPtr
setRawBVHBuilderPtr:
newIndirectArgumentEncoderWithArguments:
newComputePipelineStateWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithGraphs:functions:error:
newLibraryWithGraphsSPI:functions:error:
startCollectingPipelineDescriptorsUsingPrefixForNames:
serializeComputePipelineDescriptor:
serializeStructType:version:
compileVisibleFunction:withDescriptor:destinationBinaryArchive:error:
compileVisibleFunction:withDescriptor:error:
compileVisibleFunction:withDescriptor:completionHandler:
deserializeCompileTimeStats:addToDictionary:
gpuAssertionsEnabled
TB,GareGPUAssertionsEnabled,SsetGPUAssertionsEnabled:
BCTextureCompressionSupported
TB,R,GisBCTextureCompressionSupported
Tr^{MTLTargetDeviceArch=QI*},R
T@"MTLTargetDeviceArchitecture",R
T@"MTLArchitecture",R
TB,N
Tr^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ},R
Tf,R
T{IndirectArgumentBufferCapabilities=b1b1b1b29},R
quadDataSharingSupported
TB,R,GisQuadDataSharingSupported
float32FilteringSupported
TB,R,GisFloat32FilteringSupported
msaa32bSupported
TB,R,GisMsaa32bSupported
RTZRoundingSupported
TB,R,GisRTZRoundingSupported
AnisoSampleFixSupported
TB,R,GisAnisoSampleFixSupported
FixedLinePointFillDepthGradientSupported
TB,R,GisFixedLinePointFillDepthGradientSupported
largeMRTSupported
TB,R,GisLargeMRTSupported
RGB10A2GammaSupported
TB,R,GisRGB10A2GammaSupported
CustomBorderColorSupported
TB,R,GisCustomBorderColorSupported
ClampToHalfBorderSupported
TB,R,GisClampToHalfBorderSupported
placementHeapSupported
TB,R,GisPlacementHeapSupported
T@"MTLGPUBVHBuilder",R
T@"NSDictionary",C,N
notifyExternalReferencesNonZeroOnDealloc:
debugPipelineOptions:includePipelinePerfStats:
supportsTextureWriteFPRoundingMode:
isIntegrated
memorySize
functionHandleObjectCache
dynamicLibraryObjectCache
sourceLibraryObjectCache
functionObjectCache
depthStencilObjectCache
samplerObjectCache
_integrated
_memorySize
integrated
TB,R,GisIntegrated,V_integrated
TQ,R,V_memorySize
setBinaryFunctions:
groups
dictionary
objectForKeyedSubscript:
setValue:forKey:
setGroups:
enableBarrier
setEnableBarrier:
notifyListener:atValue:block:
newSharedEventHandle
signaledValue
setSignaledValue:
waitUntilSignaledValue:timeoutMS:
vertexAttributes
returnType
stageInputAttributes
filePath
lineNumber
unpackedFilePath
functionInputs
renderTargetArrayIndexType
functionConstantsDictionary
patchType
patchControlPointCount
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:reflection:
newArgumentEncoderWithBufferIndex:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:binaryArchives:
bitcodeData
reflectionWithOptions:
reflectionWithOptions:pipelineLibrary:
reflectionWithOptions:binaryArchives:
reflectionWithOptions:completionHandler:
bitCodeHash
newFunctionWithPluginData:bitcodeType:
functionHandle
precompiledOutput
T@"MTLType",R
T@"<MTLFunctionHandle>",R,N
overrideTriple
setOverrideTriple:
libraryIdentifier
newExternFunctionWithName:
newFunctionWithDescriptor:destinationArchive:error:
functionNames
externFunctionNames
T@"NSData",R
T@"NSUUID",R,C
setValue:atIndex:
setValue:withRange:
globalBuffer
setGlobalBuffer:
globalBufferOffset
setGlobalBufferOffset:
T@"<MTLBuffer>",&,N
newComputePipelineStateWithName:options:reflection:error:
newComputePipelineDescriptorWithName:error:
initWithComputePipelineState:reflection:parent:descriptor:
newRenderPipelineStateWithName:options:reflection:error:
newRenderPipelineDescriptorWithName:error:
initWithPipelineState:reflection:parent:descriptor:
initWithLibrary:parent:filePath:
setFilePath:
_filePath
T@"NSString",C,N,V_filePath
initWithComputeCommandEncoder:commandBuffer:descriptor:
globalConstantsData
initWithDevice:
imageData
userReflectionData
newSerializedVertexDataWithFlags:options:error:
initWithVertexData:fragmentData:serializedVertexDescriptor:device:options:flags:
performanceStatistics
setPerformanceStatistics:
_initConstantsBuffer:device:
initWithTileData:functionType:device:options:flags:
initWithObjectData:meshData:fragmentData:device:options:flags:
functionHandleWithFunction:stage:
initWithFunctionHandle:renderPipelineState:stage:function:
unwrapBinaryFunctions:
setVertexAdditionalBinaryFunctions:
setFragmentAdditionalBinaryFunctions:
newRenderPipelineStateWithAdditionalBinaryFunctions:error:
setVertexDebugInstrumentationData:
setFragmentDebugInstrumentationData:
initWithRenderPipelineState:vertexBinaryFunctions:fragmentBinaryFunctions:tileBinaryFunctions:objectBinaryFunctions:meshBinaryFunctions:withState:device:
newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:
setTileDebugInstrumentationData:
vertexAdditionalBinaryFunctions
fragmentAdditionalBinaryFunctions
tileAdditionalBinaryFunctions
setTileAdditionalBinaryFunctions:
objectAdditionalBinaryFunctions
setObjectAdditionalBinaryFunctions:
meshAdditionalBinaryFunctions
setMeshAdditionalBinaryFunctions:
setObjectDebugInstrumentationData:
setMeshDebugInstrumentationData:
initWithVisibleFunctionTable:descriptor:renderPipeline:
newVisibleFunctionTableWithDescriptor:stage:
initWithIntersectionFunctionTable:device:descriptor:renderPipelineState:
newIntersectionFunctionTableWithDescriptor:stage:
initWithRenderPipelineState:meshDescriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:
newVisibleFunctionTableFromVertexStageWithDescriptor:
newVisibleFunctionTableFromFragmentStageWithDescriptor:
newVisibleFunctionTableFromTileStageWithDescriptor:
newVisibleFunctionTableFromObjectStageWithDescriptor:
newVisibleFunctionTableFromMeshStageWithDescriptor:
newVertexIntersectionFunctionTableWithDescriptor:
newFragmentIntersectionFunctionTableWithDescriptor:
newTileIntersectionFunctionTableWithDescriptor:
newObjectIntersectionFunctionTableWithDescriptor:
newMeshIntersectionFunctionTableWithDescriptor:
internalReflection
indirectStateBuffer
vertexMaxCallStackDepth
_internalReflection
_userReflection
_binaryFunctionData
_vertexFunctionData
_fragmentFunctionData
_tileFunctionData
_objectFunctionData
_meshFunctionData
_retainedFunctions
_indirectStateBuffer
_supportsIndirectCommandBuffers
_vertexMaxCallStackDepth
_fragmentMaxCallStackDepth
_meshMaxCallStackDepth
_objectMaxCallStackDepth
_tileMaxCallStackDepth
T@"NSArray",R,N,V_binaryFunctionData
T@"MTLGPUDebugImageData",R,N
T@"MTLRenderPipelineReflection",R,N
T@"MTLGPUDebugBuffer",R,N
Ti,R,N,V_vertexMaxCallStackDepth
Ti,R,N,V_fragmentMaxCallStackDepth
Ti,R,N,V_meshMaxCallStackDepth
Ti,R,N,V_objectMaxCallStackDepth
Ti,R,N,V_tileMaxCallStackDepth
primitiveDataElementSize
setOriginalObject:
parent
strongParent
setBaseObject:
_parent
_baseObject
_externalReferences
T@,&,N,V_baseObject
isMemorylessRender
sampledRenderCommandEncoderWithProgramInfoBuffer:capacity:
setColorStoreActionOptions:atIndex:
setDepthStoreActionOptions:
setStencilStoreActionOptions:
separateCommits
setSeparateCommits:
setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:
setOpaqueTriangleIntersectionFunctionWithSignature:withRange:
_globalBuffer
setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setDepthClipModeSPI:
setCommandDataCorruptModeSPI:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setDepthCleared
setStencilCleared
setAlphaTestReferenceValue:
setPointSize:
setClipPlane:p2:p3:p4:atIndex:
setViewportTransformEnabled:
setProvokingVertexMode:
setPrimitiveRestartEnabled:
setPrimitiveRestartEnabled:index:
setTriangleFrontFillMode:backFillMode:
setTransformFeedbackState:
addSplitHandler:
useRenderPipelineState:
useRenderPipelineStates:count:
tileWidth
tileHeight
setObjectSamplerState:atIndex:
setObjectSamplerStates:withRange:
setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setObjectThreadgroupMemoryLength:atIndex:
useResourceGroup:usage:stages:
setVisibleFunctionTable:atBufferIndex:stage:
setVisibleFunctionTables:withBufferRange:stage:
setIntersectionFunctionTable:atBufferIndex:stage:
setIntersectionFunctionTables:withBufferRange:stage:
setAccelerationStructure:atBufferIndex:stage:
setMeshSamplerState:atIndex:
setMeshSamplerStates:withRange:
setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:
textureBarrier
setColorResolveTexture:slice:depthPlane:level:atIndex:yInvert:
setIntersectionFunctionTable:atIndex:
initWithIntersectionFunctionTable:device:descriptor:computePipelineState:
_computePipelineState
_renderPipelineState
_handleBuffer
T@"<MTLIntersectionFunctionTable>",&,D,N
resetAtIndex:
setBuffer:offset:atIndex:forStage:commandIndex:
setThreadgroupMemoryLength:atIndex:commandIndex:
setComputePipelineStateBuffers:commandIndex:
initWithIndirectComputeCommand:commandIndex:indirectCommandBuffer:
_commandIndex
screenSize
physicalGranularity
layerCount
parameterBufferSizeAndAlign
physicalSizeForLayer:
mapScreenToPhysicalCoordinates:forLayer:
mapPhysicalToScreenCoordinates:forLayer:
minFactor
mutability
copyParameterDataToBuffer:offset:
resetUsingDescriptor:
T{?=QQ},R
Tf,R,N
initWithIntersectionFunctionTable:parent:descriptor:stage:
initWithIntersectionFunctionTable:parent:descriptor:pipelineState:stage:
init:flags:
flags
segment
_timer
_stream
_segment
TQ,R,N,V_flags
T{_NSRange=QQ},R,N,V_segment
init:
updateTextureMappings:mode:regions:mipLevels:slices:numRegions:
updateTextureMapping:mode:region:mipLevel:slice:
updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles:
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
objectForKey:
unsignedIntegerValue
tracePath
stringByAppendingPathComponent:
writeToFile:options:error:
localizedDescription
appendSamples:length:
saveCommandBuffer:queue:profilingResults:
_commands
_encoders
_samples
_timestamp
dataWithLength:
setLength:
base64EncodedDataWithOptions:
dataWithBytesNoCopy:length:freeWhenDone:
lengthOfBytesUsingEncoding:
threadgroupSizeMatchesTileSize
newVertexShaderDebugInfo
newFragmentShaderDebugInfo
imageblockSampleLength
explicitVisibilityGroupID
maxTotalThreadsPerObjectThreadgroup
maxTotalThreadsPerMeshThreadgroup
objectThreadExecutionWidth
meshThreadExecutionWidth
maxTotalThreadgroupsPerMeshGrid
vertexFunctionHandleWithFunction:
fragmentFunctionHandleWithFunction:
tileFunctionHandleWithFunction:
objectFunctionHandleWithFunction:
meshFunctionHandleWithFunction:
newVisibleFunctionTableWithDescriptor:selector:
newIntersectionFunctionTableWithDescriptor:selector:
TI,R,N
validateCPUReadable
validateCPUWriteable
_heap
TQ,R,N,V_options
containsResource:
setRenderPipelineStateBuffers:commandIndex:
setTessellationControlPointIndexBuffer:offset:commandIndex:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
initWithIndirectRenderCommand:commandIndex:indirectCommandBuffer:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
pixelFormat
parentTexture
realRootResource
parentRelativeLevel
parentRelativeSlice
bufferOffset
bufferBytesPerRow
swizzle
swizzleKey
isCompressed
compressionFeedback
compressionType
compressionFootprint
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
textureType
usage
width
height
depth
mipmapLevelCount
arrayLength
isSparse
isFramebufferOnly
sparseSurfaceDefaultValue
firstMipmapInTail
tailSizeInBytes
allowGPUOptimizedContents
newTextureViewWithPixelFormat:resourceIndex:
newTextureViewWithPixelFormat:
initWithBaseObject:parent:parentTexture:
newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newCompressedTextureViewWithPixelFormat:textureType:level:slice:
canGenerateMipmapLevels
generateMipmapLevel:slice:
rotation
iosurfacePlane
numFaces
isDrawable
getBytes:bytesPerRow:fromRegion:mipmapLevel:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
rootResource
T@"<MTLResource>",R
T@"<MTLTexture>",R
T@"<MTLBuffer>",R
framebufferOnly
TB,R,GisFramebufferOnly
T{?=CCCC},R,N
copyFromSlice:mipmapLevel:origin:size:toPixels:rowBytes:imageBytes:
copyFromPixels:rowBytes:imageBytes:toSlice:mipmapLevel:origin:size:
tailSize
_parentTexture
T@"<MTLTexture>",R,V_parentTexture
T@"<MTLBuffer>",R,V_buffer
alignment
copyGranularity
watermark
initializeTextureMemory:
copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:
copyFromTextureMemory:textureSlice:textureLevel:textureRegion:toLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:
finalizeTextureMemory:
T{?=[2Q]},R
initWithBaseRenderPass:commandBuffer:descriptor:
_newReportBuffer
_temporaryBufferWithLength:
_encodeReportBuffer:type:
_encodeResourceTableBuffers:type:
_allocReportEntryStorageForType:
setVisibleFunctionTable:atIndex:
setBufferUsageTable:textureUsageTable:
setKernelReportBuffer:offset:
_lateInit
beginingEncoder:type:
initWithParallelRenderCommandEncoder:parent:descriptor:encoderID:
initWithComputeCommandEncoder:commandBuffer:descriptor:encoderID:
initWithBlitCommandEncoder:parent:descriptor:encoderID:
_checkReportBuffers
initWithCommandBuffer:commandQueue:descriptor:
resourceUsageForTexture:stage:
_initialized
_stageArgumentEncoder
_vertexComputeReportBuffer
_vertexComputeReportOffset
_fragmentReportOffset
_usedBuffers
_currentPooledBuffer
_currentPooledBufferOffset
_currentEncoderID
_currentReportID
_reportBufferList
_reportEntryList
_encoderLabels
_allocationLock
_tempBufLock
_supportsTileStage
_supportsMeshStage
_hasDeferredBindingObjectAndMeshReportBuffers
_bufferUsageTables
_textureUsageTables
_heapUsageTable
T@"MTLGPUDebugDevice",R,D
gpuIdentifier
enumerateBufferIndices:
enumerateTextureIndices:
_setDefaults
addObject:retained:purgeable:
internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:move:
cStringUsingEncoding:
validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
validateTextureAccess:region:mipLevel:slice:
optimizedRangeList
rangeValue
removeObjectAtIndex:
valueWithRange:
maxVertexBufferBindCount
maxFragmentBufferBindCount
maxObjectBufferBindCount
maxMeshBufferBindCount
validateCopyFromTexture:sourceSlice:sourceLevel:sourceSize:toTexture:destinationSlice:destinationLevel:options:sliceCount:levelCount:
initWithBlitCommandEncoder:commandBuffer:descriptor:
canDealloc
canEndEncoding
hasEndEncoding
updatedFences
string
appendString:
checkEncoderState
validateSparseTextureMappingMode:
initWithResourceStateCommandEncoder:commandBuffer:descriptor:
hasEndedEncoding
range
setRange:
_label
_range
T@"NSString",C,N,V_label
T{_NSRange=QQ},N,V_range
initWithBaseObject:
initWithBaseTexture:device:buffer:offset:bytesPerRow:
initWithBaseTexture:device:buffer:offset:bytesPerRow:bytesPerImage:
initWithBuffer:device:options:
initWithBuffer:heap:device:options:
initWithBuffer:device:bytes:options:
copyDebugMarkers
common
pointer
isContentExposedToCPU
setIsContentExposedToCPU:
_common
_debugDevice
_debugMarkers
_isContentExposedToCPU
_pointer
T@"MTLDebugResource",R,N,V_common
Tr^v,R,N,V_pointer
TB,N,V_isContentExposedToCPU
complainAboutSloppyTextureUsage
validateCommandQueue:
_commandQueue
setRetainedReferences:
_tracePath
T@"NSString",R,N,V_tracePath
addReferenceTrackingCommandBuffer:
isCommitted
loadAction
loadValidationEnabled
setLoadAction:
setClearColor:
setClearDepth:
setClearStencil:
addReferencedObject:internallyRetained:
addPurgeableObject:
_removeUsedRenderTargetsExcept:
baseTexture
baseLevelOffset
baseSliceRangeOffset
addUsedRenderTarget:slices:
baseResolveTexture
resolveLevelOffset
resolveSliceRangeOffset
validateDeadlineAwareness:
lockPurgeableObjects
unlockPurgeableObjects
removeAllReferencedObjects:
removeReferenceTrackingCommandBuffer:
removeUsedRenderTarget:slices:
unionSet:
validateStoreLoadTransition:atIndex:renderTargetArrayLength:
testObjectReferenced:wasInternallyRetained:
addActiveRenderTargets:
_currentEncoder
_attachmentSet
_prevAttachments
_currAttachments
_purgeableObjectsLock
_referencedPurgeableObjects
_externallyRetainedObjects
_internallyRetainedObjects
_referencedDeadObject
_renderTargetAttachmentLock
_didAddRenderTargetAttachments
_renderTargetAttachments
renderTargetArrayLength
requireUsage:
clearDepth
threadgroupMemoryLength
startOfVertexSampleIndex
endOfVertexSampleIndex
startOfFragmentSampleIndex
endOfFragmentSampleIndex
startOfEncoderSampleIndex
endOfEncoderSampleIndex
null
setRenderPipelineState:atIndex:
setComputePipelineState:atIndex:
globalConstantsBuffer
threadgroupArgumentOffset
_argumentEncoder
isFileURL
drawArguments
drawIndexedArguments
drawIndexedPatchesArguments
drawPatchesArguments
getTessellationFactorArguments
getFragmentBufferAtIndex:
getVertexBufferAtIndex:
drawMeshArguments
getObjectBufferAtIndex:
getMeshBufferAtIndex:
initWithCounterSampleBuffer:device:descriptor:
descriptor
_descriptor
_storageMode
T@"MTLCounterSampleBufferDescriptor",R,N,V_descriptor
TQ,R,N,V_storageMode
_newRenderPipelineStateWithTileDescriptor:options:reflection:error:
_newRenderPipelineStateWithTileDescriptor:options:completionHandler:
TB,R,N,V_APITimingEnabled
setArgumentBuffer:startOffset:arrayElement:
internalICBBuffer
setIndirectCommandBuffer:atIndex:
setRenderPipelineStates:withRange:
setComputePipelineStates:withRange:
setIndirectCommandBuffers:withRange:
newArgumentEncoderForBufferAtIndex:
_layout
appendData:
newSerializedComputeDataWithFlags:options:
initWithSerializedData:serializedStageInputDescriptor:device:options:flags:
initWithVisibleFunctionTable:descriptor:computePipeline:
initWithFunctionHandle:computePiplineState:function:
initWithComputePipelineState:binaryFunctions:withState:device:
constantOffset
_kernelFunctionData
_constantOffset
_threadgroupArgumentOffset
_activeThreadgroupMask
_maxCallStackDepth
T@"MTLComputePipelineReflection",R,N
Ti,R,N,V_maxCallStackDepth
_deadlineAwareState
threadGroupSizeIsMultipleOfThreadExecutionWidth
_validateThreadsPerThreadgroup:
reflection
validateStageInRegion:
_validateAllFunctionArguments
endEncoding_private
validateFunctionTableUseResource:selectorName:
computePipelineState
enumerateBuffersUsingBlock:
enumerateTexturesUsingBlock:
enumerateSamplersUsingBlock:
enumerateThreadgroupMemoryLengthsUsingBlock:
_buffers
_textures
_samplers
_threadgroupMemoryLengths
_imageBlockSize
canSetComputePipelineState
hasSetComputePipelineState
hasSetStageInRegion
stageInRegion
hasIndirectSetStageInRegion
allowsNullBufferBinds
T@"<MTLComputePipelineState>",R,N,V_computePipelineState
builtInArguments
builtInType
isActive
bufferAlignment
bufferDataSize
access
threadgroupMemoryDataSize
textureDataType
motionEndTime
motionStartTime
primitiveDataBufferOffset
primitiveDataStride
intersectionFunctionTableOffset
vertexFormat
vertexStride
transformationMatrixBufferOffset
vertexBufferOffset
indexBufferOffset
indexType
triangleCount
motionKeyframeCount
boundingBoxStride
boundingBoxBufferOffset
boundingBoxCount
instanceCount
instanceDescriptorType
instanceDescriptorStride
instanceDescriptorBufferOffset
validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
initWithAccelerationStructureCommandEncoder:parent:
initWithBaseObject:parent:function:
initWithBaseObject:parent:function:stage:
builtInDataType
getParameter:
functionHandleToDebugFunctionHandle:parentFunction:
supportAddingBinaryFunctions
isAncestorOf:
_maxThreadPositionInGrid
_maxThreadsPerGrid
_maxThreadPositionInThreadgroup
_maxThreadIndexInThreadgroup
_maxThreadsPerThreadgroup
_maxThreadgroupPositionInGrid
_maxThreadgroupsPerGrid
_maxStageInGridSize
_maxStageInGridOrigin
_reflection
T@"<MTLFunction>",R,N,V_function
T@"MTLComputePipelineDescriptor",R,N,V_descriptor
T@"MTLComputePipelineReflection",R,N,V_reflection
array
initWithIndirectCommandBuffer:device:descriptor:maxCommandCount:options:
_optimizedRangeList
_maxCommandCount
_isRender
T@"NSMutableArray",R
T@"MTLIndirectCommandBufferDescriptor",R
stringWithUTF8String:
stringByStandardizingPath
defaultManager
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
componentsSeparatedByString:
containsObject:
pipelineNames
disableRunTimeCompilation
setDisableRunTimeCompilation:
pipelineCache
functionCache
T@"<MTLPipelineCache>",R,N
layout
setVisibleFunctionTables:withRange:
setIntersectionFunctionTables:withRange:
T@"_MTLIndirectArgumentBufferLayout",R,N
_newGPUDebugAccelerationStructure:
_enableResourceUsageValidation
_bufferLock
_bufferIndices
_textureLock
_textureIndices
_accelerationStructureLock
_accelerationStructureIndices
elementType
elementStructType
elementArrayType
members
indirectArgumentIndex
structType
arrayType
pointerType
elementIsArgumentBuffer
setArgumentBuffer:startOffset:elementIndex:
supportArgumentBuffers
initWithBaseObject:structType:parent:
_currentBuffer
_currentOffset
_reflectionParser
initWithHeap:device:
validateResourceOptions:isTexture:isIOSurface:context:
validateNewBufferArgs:options:context:
noCopy
initWithBaseTexture:device:
validateMemorylessResource:context:
pathForResource:ofType:
initWithLibrary:parent:type:code:options:
validateLinkedFunctions:context:
_newRenderPipelineStateWithDescriptor:options:reflection:error:
_newRenderPipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithDescriptor:options:reflection:error:
_newComputePipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithFunction:options:reflection:error:
_newComputePipelineStateWithFunction:options:completionHandler:
initWithPipelineState:reflection:parent:tileDescriptor:
initWithPipelineState:reflection:parent:meshDescriptor:
_newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
_newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
setImageFilterFunctions:imageFilterFunctionInfo:
fileSystemRepresentation
initWithUTF8String:
initWithBaseTexture:device:plane:
initWithBaseTextureLayout:device:descriptor:
layerPointer:
bufferStructType
priority
newScratchBufferWithMinimumSize:
notifySamplerStateDeallocated:
clearRenderEncoder:writeMask:withCheckerboard:
storeValidationEnabled
_argumentBufferSamplers
_referenceTrackingCommandBufferLock
_referenceTrackingCommandBuffers
_checkerboardRTPipelineCache
_storeValidationEnabled
_loadValidationEnabled
TB,R,V_loadValidationEnabled
TB,R,V_storeValidationEnabled
storeAction
setConstantValue:type:atIndex:
setPixelFormat:
setDepthAttachmentPixelFormat:
depthCompareFunction
isDepthWriteEnabled
attachmentWriteMask
_attachmentWriteMask
T@"MTLDepthStencilDescriptor",R,N,V_descriptor
TC,R,N,V_attachmentWriteMask
stencilCompareFunction
writeMask
stencilFailureOperation
depthStencilPassOperation
depthFailureOperation
maxCommands
maxVertexBindings
maxFragmentBindings
maxKernelBindings
maxObjectBindings
maxMeshBindings
mayContainDrawMeshes
commandByteStride
inheritsBuffers
inheritsPipelineState
internalDrawOrDispatchIDBuffer
onExecuteWithRenderEncoder:
onExecuteWithComputeEncoder:
_hasRender
_hasCompute
_inheritsBuffers
_inheritsPipelineState
_argumentStorage
_drawOrDispatchIDBuffer
_maxCommands
_maxVertexBindings
_maxFragmentBindings
_maxKernelBindings
_maxThreadgroupBindings
_maxObjectBindings
_maxMeshBindings
_mayContainDrawMeshes
_commandByteStride
_originalResourceOptions
T@"<MTLBuffer>",R,N
T@"<MTLIndirectCommandBufferSPI>",&,D,N
_encoderID
numberWithFloat:
setDescriptor:
T@"MTLAccelerationStructureDescriptor",&,N
_toolsBuffer
initWithKeyOptions:valueOptions:capacity:
removeObjectForKey:
setObject:forKey:
getCachedObjectForKey:
_map
_lock
_keyRemoveList
_listLock
dataTypeDescription
elementIsIndirectArgumentBuffer
constantValues
_constantValues
T@"MTLFunctionConstantValues",&,V_constantValues
validateDescriptor:expectedClass:
copyConstantValues:
debugType
setDebugType:
code
setCode:
compileOptions
setCompileOptions:
imageFilterFunctions
imageFilterFunctionInfo
_debugType
_code
_compileOptions
_imageFilterFunctions
_imageFilterFunctionInfo
TQ,N,V_debugType
T@,C,N,V_code
T@"MTLCompileOptions",C,N,V_compileOptions
T@"NSArray",R,N,V_imageFilterFunctions
T^{?=BQ^{?}},R,N,V_imageFilterFunctionInfo
initWithRenderCommandEncoder:parallelRenderCommandEncoder:descriptor:
setStoreAction:
setStoreActionOptions:
mergeAttachmentWriteMask:
_unknownStoreActions
T@"MTLRenderPassDescriptor",R,C,N,V_descriptor
initWithDesc:renderTargetArrayLength:
intersectsTexture:
attachmentTexture
_attachmentTexture
_baseResolveTexture
_baseTexture
_renderTargetArrayLength
_baseLevelOffset
_resolveLevelOffset
_baseSliceRangeOffset
_resolveSliceRangeOffset
T@"<MTLTexture>",R,N,V_attachmentTexture
T@"<MTLTexture>",R,N,V_baseResolveTexture
T@"<MTLTexture>",R,N,V_baseTexture
TQ,R,N,V_renderTargetArrayLength
TQ,R,N,V_baseLevelOffset
TQ,R,N,V_resolveLevelOffset
T{_NSRange=QQ},R,N,V_baseSliceRangeOffset
T{_NSRange=QQ},R,N,V_resolveSliceRangeOffset
validate:width:height:
renderTargetWidth
renderTargetHeight
_init
defaultColorSampleCount
defaultRasterSampleCount
openGLModeEnabled
numberWithUnsignedLong:
rasterSampleCount
colorSampleCount
meshDescriptor
rasterizationEnabled
tileDescriptor
validateFramebufferWithRenderPipelineState:context:
outputImageBlockData
isMeshShaderPipeline
objectThreadsPerThreadgroup
meshThreadsPerThreadgroup
_dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
renderPipelineState
isImageBlockLayoutInputCompatibleWithOutputOf:
validateFunctionTableUseResource:stages:context:selectorName:
inputPrimitiveTopology
validateCommonDrawErrors:
updatePipelineData
_validateThreadgroupSize:stage:context:
validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:
validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:
validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:
_validateAllFunctionArguments:
tessellationControlPointIndexType
allObjects
removeObject:
setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
viewports
scissorRects
viewport
scissorRect
enumerateVertexBuffersUsingBlock:
enumerateVertexTexturesUsingBlock:
enumerateVertexSamplersUsingBlock:
enumerateFragmentBuffersUsingBlock:
enumerateFragmentTexturesUsingBlock:
enumerateFragmentSamplersUsingBlock:
enumerateTileBuffersUsingBlock:
enumerateTileTexturesUsingBlock:
enumerateTileSamplersUsingBlock:
enumerateThreadgroupMemoryUsingBlock:
frontFacingWinding
cullMode
depthClipMode
lineWidth
depthBias
depthBiasSlopeScale
depthBiasClamp
triangleFillMode
peakPerSampleStorage
resolvedSampleCount
depthStencilState
defaultDepthStencilDescriptor
frontStencilRef
backStencilRef
visibilityResultMode
visibilityResultOffset
blendColorRed
blendColorGreen
blendColorBlue
blendColorAlpha
tessellationFactorBufferArgument
tessellationFactorBufferInstanceStride
tessellationFactorScale
_dirtyBits
_openGLModeEnabled
_vertexBuiltinArguments
_attachmentInfo
_previousRenderPipelineStateWithWritesToImageBlock
_resolvedRasterSampleCount
_vertexBuffers
_vertexTextures
_vertexSamplers
_fragmentBuffers
_fragmentTextures
_fragmentSamplers
_tileBuffers
_tileTextures
_tileSamplers
_threadgroupMemoryArguments
_objectBuffers
_objectTextures
_objectSamplers
_objectThreadgroupMemoryLengths
_meshBuffers
_meshTextures
_meshSamplers
_encoderState
_visibilityOffsets
_viewports
_scissorRects
_amplificationMode
_amplificationValue
_vertexAmplificationCount
_updatedFences
_storingRenderTargets
_maxVertexBuffers
_objectThreadsPerTG
_meshThreadsPerTG
_lineWidth
_depthBias
_depthBiasSlopeScale
_depthBiasClamp
_frontStencilRef
_backStencilRef
_blendColorRed
_blendColorGreen
_blendColorBlue
_blendColorAlpha
_tessellationFactorScale
_frontFacingWinding
_cullMode
_depthClipMode
_triangleFillMode
_peakPerSampleStorage
_resolvedSampleCount
_depthStencilState
_defaultDepthStencilDescriptor
_visibilityResultMode
_visibilityResultOffset
_width
_height
_tessellationFactorBufferInstanceStride
_tessellationFactorBufferArgument
TQ,R,N,V_attachmentWriteMask
T^v,R,N
T{?=dddddd},R,N
T{?=QQQQ},R,N
TQ,R,N,V_frontFacingWinding
TQ,R,N,V_cullMode
TQ,R,N,V_depthClipMode
Tf,R,N,V_lineWidth
Tf,R,N,V_depthBias
Tf,R,N,V_depthBiasSlopeScale
Tf,R,N,V_depthBiasClamp
TQ,R,N,V_triangleFillMode
T@"<MTLRenderPipelineState>",R,N,V_renderPipelineState
TQ,R,N,V_peakPerSampleStorage
TQ,R,N,V_resolvedSampleCount
T@"<MTLDepthStencilState>",R,N,V_depthStencilState
T@"MTLDepthStencilDescriptor",R,N,V_defaultDepthStencilDescriptor
TI,R,N,V_frontStencilRef
TI,R,N,V_backStencilRef
TQ,R,N,V_visibilityResultMode
TQ,R,N,V_visibilityResultOffset
Tf,R,N,V_blendColorRed
Tf,R,N,V_blendColorGreen
Tf,R,N,V_blendColorBlue
Tf,R,N,V_blendColorAlpha
TQ,R,V_width
TQ,R,V_height
T{?=BBQ@QQQQQBff},R,N,V_tessellationFactorBufferArgument
TQ,R,N,V_tessellationFactorBufferInstanceStride
Tf,R,N,V_tessellationFactorScale
sortedArrayUsingComparator:
readMask
tessellationFactorFormat
tessellationFactorStepFunction
numberWithUnsignedLongLong:
_traceBuffer
T@"MTLCountersTraceCommandBuffer",R,N,V_traceBuffer
TI,R,V_encoderID
_setupCommon
T@"<MTLVisibleFunctionTable>",&,D,N
T@,R,V_baseObject
setComputePipelineStateBuffers:
initWithComputeCommandEncoder:parent:encoderID:
setAccelerationStructures:withBufferRange:
_commandBufferJumpNestingLevel
_handles
_dispatchID
_reportBuffer
_bufferUsageTable
_textureUsageTable
T@"MTLToolsFunction",R,V_function
_initImageData
internalStructTypeFromUserStructType:
internalArrayTypeFromUserArrayType:
stride
convertUserType:
indirectArgumentIndexStride
setIndirectArgumentIndexStride:
argumentIndex
setMembers:count:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:binaryArchives:
data
_argumentLayoutsMutex
_argumentLayouts
setStructType:withDevice:
initWithArrayLength:elementType:stride:pixelFormat:aluType:details:
initWithName:type:access:isActive:locationIndex:dataType:pixelFormat:aluType:dataSize:alignment:
initWithName:offset:dataType:pixelFormat:aluType:indirectArgumentIndex:render_target:raster_order_group:details:
_updateCachedPipelineState
_updateCachedTilePipelineState
imageBlockMasterStructMembers
imageBlockDataReturn
initWithObjects:
_findMasterStruct:includeImageBlockData:
isStructLayoutThreadSafeWith:
isRasterizationEnabled
layouts
vertexBuiltInArguments
supportAddingVertexBinaryFunctions
supportAddingFragmentBinaryFunctions
validateBinaryFunctions:stage:
supportAddingObjectBinaryFunctions
supportAddingMeshBinaryFunctions
newVisibleFunctionTableWithDescriptor:stage:selector:
functionHandleToDebugFunctionHandle:parentFunction:stage:
functionHandleWithFunction:stage:selector:
newIntersectionFunctionTableWithDescriptor:withStage:selector:
_updateCachedMeshPipelineState
objectThreadgroupSizeIsMultipleOfThreadExecutionWidth
meshThreadgroupSizeIsMultipleOfThreadExecutionWidth
_maxVertexCount
_maxInstanceCount
_maxPatchCount
_rasterSampleCount
_colorPixelFormat
_depthPixelFormat
_stencilPixelFormat
_vertexDescriptorLayoutCount
_vertexDescriptorLayouts
_threadgroupSizeMatchesTileSize
_tileDescriptor
_meshDescriptor
T@"MTLRenderPipelineDescriptor",R,N,V_descriptor
T@"MTLRenderPipelineReflection",R,N,V_reflection
T@"MTLTileRenderPipelineDescriptor",R,N,V_tileDescriptor
meshShaderPipeline
TB,R,GisMeshShaderPipeline
T@"MTLMeshRenderPipelineDescriptor",R,N,V_meshDescriptor
T@"MTLSamplerDescriptor",R,C,N,V_descriptor
compareFunction
normalizedCoordinates
mipFilter
sAddressMode
tAddressMode
rAddressMode
maxAnisotropy
minFilter
magFilter
setMaxAnisotropy:
borderColor
borderColorSPI
descriptorPrivate
validateHeapResourceOptions:isTexture:isIOSurface:context:
validateHeapTextureUsage:options:context:
validatePixelFormatWithHeap:context:
initWithBaseTexture:heap:device:
validateOffset:withRequirements:
validateRaytracingHeap
_newDebugAccelerationStructure:
debugDevice
T@"MTLDebugDevice",R,N,V_debugDevice
initWithBaseTexture:device:texture:
initWithBaseTexture:device:texture:pixelFormat:
initWithBaseTexture:device:texture:pixelFormat:textureType:levels:slices:
bytesPerRow
bytesPerImage
plane
isLinearTexture
_pixelFormatInfo
_usageRequired
_subViewUseLock
_activeSubViews
_isLinearTexture
_bytesPerRow
_bytesPerImage
_plane
TQ,R,N,V_offset
TQ,R,N,V_bytesPerRow
TQ,R,N,V_bytesPerImage
TQ,R,N,V_plane
TB,R,N,V_isLinearTexture
T@"MTLTextureDescriptor",R,C,N,V_descriptor
_imageData
T@"MTLGPUDebugImageData",R,N,V_imageData
_debugBuffer
initWithTextureView:parentTexture:heap:device:
_identifier
T@"<MTLTextureSPI>",&,D,N
loadBuffer:offset:size:sourceHandle:sourceHandleOffset:
loadBytes:size:sourceHandle:sourceHandleOffset:
loadTexture:slice:level:size:sourceBytesPerRow:sourceBytesPerImage:destinationOrigin:sourceHandle:sourceHandleOffset:
copyStatusToBuffer:offset:
tryCancel
addBarrier
waitForEvent:value:
signalEvent:value:
barrier
loadBuffer:offset:size:handle:handleOffset:
loadTexture:slice:level:size:bytesPerRow:bytesPerImage:dstOrigin:handle:handleOffset:
vnioID
read:size:offset:stagingBuffer:stagingBufferSize:needsDecompress:
readIntoStagingBuffer:offset:stagingBuffer:stagingBufferSize:needsDecompress:
read:size:offset:stagingBuffer:stagingBufferSize:
readIntoStagingBuffer:offset:stagingBuffer:stagingBufferSize:
stagingBufferSize:offset:
getHandleOffset:offset:
decompress:size:offset:stagingBuffer:stagingBufferSize:
enqueueBarrier
internalValidateEvent:
internalValidateLoadBytes:size:sourceHandle:sourceHandleOffset:
internalValidateLoadBuffer:offset:size:sourceHandle:sourceHandleOffset:
internalValidateLoadTexture:slice:level:size:sourceBytesPerRow:sourceBytesPerImage:destinationOrigin:sourceHandle:sourceHandleOffset:
allocateScratchBufferWithMinimumSize:
@48@0:8@16@24Q32@40
Q16@0:8
@16@0:8
v16@0:8
v24@0:8@16
v40@0:8@16Q24Q32
v64@0:8{?=QQQ}16{?=QQQ}40
@"MTLIndirectCommandBufferDescriptor"
@"<MTLIndirectCommandBufferSPI>"
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@32@0:8r^v16Q24
@24@0:8Q16
I16@0:8
@"MTLGPUDebugBuffer"32@0:8r^v16Q24
@"MTLGPUDebugBuffer"24@0:8Q16
@44@0:8@16@24@32I40
@36@0:8@16@24I32
v32@0:8@16Q24
v40@0:8@16@24Q32
v32@0:8Q16Q24
v48@0:8r^@16r^Q24{_NSRange=QQ}32
v40@0:8r^v16Q24Q32
v40@0:8Q16Q24Q32
v40@0:8r^@16{_NSRange=QQ}24
v40@0:8Q16@24Q32
v48@0:8Q16Q24Q32Q40
v56@0:8Q16Q24Q32Q40Q48
v56@0:8Q16Q24Q32@40Q48
v64@0:8Q16Q24Q32@40Q48Q56
v64@0:8Q16Q24@32Q40@48Q56
v80@0:8Q16Q24Q32@40Q48Q56q64Q72
v56@0:8Q16@24Q32@40Q48
v72@0:8Q16Q24Q32@40Q48Q56Q64
v72@0:8Q16@24Q32@40Q48@56Q64
v88@0:8Q16Q24Q32@40Q48@56Q64Q72Q80
v40@0:8{?=QQQ}16
v88@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40
v92@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40I88
v88@0:8{?=QQQ}16{?=QQQ}40{?=QQQ}64
v80@0:8@16Q24{?=QQQ}32{?=QQQ}56
v40@0:8@16{_NSRange=QQ}24
v32@0:8Q16r^{?=II}24
v48@0:8@16Q24{optional<unsigned long>=(?=cQ)B}32
v40@0:8r^@16Q24Q32
v48@0:8r^@16Q24Q32Q40
v32@0:8r^@16Q24
@"MTLGPUDebugCommandBuffer"
{MTLGPUDebugStageBufferHandles="handles"[31Q]"resources"[31@"<MTLGPUDebugResource>"]"offsets"[31Q]"lengths"[31I]"gpu_address"[31[2Q]]"needsFlush"B}
{MTLGPUDebugTileThreadgroup="entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
^{Options=Iiiii{?=b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1}}
{GPUDebugEventUUIDPacket="pipelineStateID"Q"entryPointImageID"Q"encoderID"I"eventID"I}
@"MTLGPUDebugRenderPipelineState"
@"MTLToolsDepthStencilState"
{MTLGPUDebugBufferSubAlloc="buffer"@"<MTLBuffer>""offset"Q}
{?="count"C"mappingsValid"B"mappings"[2{?="viewportArrayIndexOffset"I"renderTargetArrayIndexOffset"I}]}
@"<MTLBuffer>"
Q24@0:8Q16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v32@0:8{_NSRange=QQ}16
{MTLResourceID=Q}16@0:8
@"<MTLIndirectRenderCommand>"24@0:8Q16
@"<MTLIndirectComputeCommand>"24@0:8Q16
v32@0:8^^v16^Q24
@"<MTLFunction>"16@0:8
@"<MTLFunctionLogDebugLocation>"16@0:8
v24@0:8Q16
@"MTLGPUDebugImageData"
@"NSArray"
@"NSString"
@"<MTLFunction>"
@"<MTLFunctionLogDebugLocation>"
i16@0:8
v20@0:8i16
@"MTLArgument"
@"<MTLProgramAddressTable>"16@0:8
v136@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112
v120@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96
v128@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96Q120
v120@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112
v128@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112Q120
v44@0:8@16{_NSRange=QQ}24C40
v80@0:8@16Q24Q32@40Q48Q56Q64Q72
v32@0:8@16@24
v56@0:8@16Q24@32Q40Q48
v108@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@92Q100
v88@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80
v56@0:8@16{_NSRange=QQ}24@40Q48
v36@0:8@16Q24B32
v24@0:8@"<MTLResource>"16
v40@0:8@"<MTLTexture>"16Q24Q32
v136@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112
v120@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96
v128@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96Q120
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112
v128@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112Q120
v24@0:8@"<MTLTexture>"16
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24C40
v80@0:8@"<MTLTexture>"16Q24Q32@"<MTLTexture>"40Q48Q56Q64Q72
v32@0:8@"<MTLTexture>"16@"<MTLTexture>"24
v56@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40Q48
v24@0:8@"<MTLFence>"16
v108@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@"<MTLBuffer>"92Q100
v88@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80
v40@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24
v56@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24@"<MTLIndirectCommandBuffer>"40Q48
v36@0:8@"<MTLCounterSampleBuffer>"16Q24B32
v56@0:8@"<MTLCounterSampleBuffer>"16{_NSRange=QQ}24@"<MTLBuffer>"40Q48
v144@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136
v44@0:8@16{_NSRange=QQ}24I40
v104@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
v144@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112Q136
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24I40
v104@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
@32@0:8@16@24
@40@0:8@16@24@32
v40@0:8@16f24f28Q32
v56@0:8r^@16r^f24r^f32{_NSRange=QQ}40
v48@0:8@16Q24@32Q40
v64@0:8{?=dddddd}16
v32@0:8r^{?=dddddd}16Q24
v20@0:8f16
v28@0:8f16f20f24
v48@0:8{?=QQQQ}16
v32@0:8r^{?=QQQQ}16Q24
v20@0:8I16
v24@0:8I16I20
v32@0:8f16f20f24f28
v56@0:8@16Q24Q32Q40Q48
v60@0:8@16Q24Q32Q40B48Q52
v48@0:8@16Q24Q32Q40
v52@0:8@16Q24Q32Q40B48
@"MTLCountersTraceRenderCommandEncoder"
@32@0:8{_NSRange=QQ}16
@"NSData"32@0:8{_NSRange=QQ}16
@32@0:8@16^@24
v32@0:8@16@?24
@24@0:8@16
@40@0:8@16@24^@32
v40@0:8@16@24@?32
@48@0:8@16@24@32^@40
v48@0:8@16@24@32@?40
B32@0:8r^@16Q24
i20@0:8I16
B24@0:8@"<MTLResource>"16
^v16@0:8
@40@0:8@16Q24Q32
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@48@0:8@16Q24Q32Q40
^{__IOSurface=}16@0:8
@"<MTLTexture>"48@0:8@"MTLTextureDescriptor"16Q24Q32Q40
v24@0:8@?16
v32@0:8@16d24
d16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
v24@0:8@"<MTLDrawable>"16
v32@0:8@"<MTLDrawable>"16d24
@"<MTLBlitCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLComputeCommandEncoder>"24@0:8@"MTLComputePassDescriptor"16
@"<MTLBlitCommandEncoder>"24@0:8@"MTLBlitPassDescriptor"16
@"<MTLComputeCommandEncoder>"16@0:8
@"<MTLComputeCommandEncoder>"24@0:8Q16
v32@0:8@"<MTLEvent>"16Q24
@"<MTLParallelRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLResourceStateCommandEncoder>"16@0:8
@"<MTLResourceStateCommandEncoder>"24@0:8@"MTLResourceStatePassDescriptor"16
@"<MTLAccelerationStructureCommandEncoder>"16@0:8
@"<MTLAccelerationStructureCommandEncoder>"24@0:8@"MTLAccelerationStructurePassDescriptor"16
@"<MTLCommandQueue>"16@0:8
@"<MTLLogContainer>"16@0:8
@"NSError"16@0:8
v56@0:8@16Q24r^Q32r^Q40Q48
B24@0:8Q16
v20@0:8B16
^v24@0:8^Q16
@40@0:8@16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
v36@0:8@16Q24I32
v40@0:8Q16r^@24Q32
v24@0:8@"<MTLResourceGroupSPI>"16
v48@0:8@"<MTLResourceGroupSPI>"16Q24Q32Q40
v56@0:8@"<MTLResourceGroupSPI>"16Q24r^Q32r^Q40Q48
v24@0:8@"<MTLHeap>"16
v24@0:8@"NSArray"16
v32@0:8@"<MTLDrawable>"16@"NSDictionary"24
@"NSDictionary"16@0:8
@"NSMutableDictionary"16@0:8
@"<MTLDeadlineProfile>"16@0:8
@"<MTLRenderCommandEncoder>"40@0:8@"MTLRenderPassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@"<MTLComputeCommandEncoder>"40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"40@0:8@"MTLComputePassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLDebugCommandEncoder>"16@0:8
v36@0:8@"<MTLEvent>"16Q24I32
B24@0:8@"MTLToolsObject"16
@"NSMutableSet"16@0:8
v40@0:8@16Q24@32
v44@0:8i16Q20r^@28Q36
{?="hasCommit"b1"addedCompletedHandler"b1"addedScheduledHandler"b1"padding"b29}
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
{vector<void (^)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__begin_"^@?"__end_"^@?"__end_cap_"{__compressed_pair<void (^*)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__value_"^@?}}
@"MTLToolsDeadlineProfile"
@"NSMutableSet"
v28@0:8I16I20I24
@"<MTLToolsRetainingContainer>"
v40@0:8@16Q24^v32
@40@0:8^Q16^v24^B32
{vector<std::pair<NSData *, unsigned long>, std::allocator<std::pair<NSData *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<NSData *, unsigned long> *, std::allocator<std::pair<NSData *, unsigned long>>>="__value_"^v}}
{__wrap_iter<std::pair<NSData *, unsigned long> *>="__i"^v}
@"<MTLCommandBuffer>"16@0:8
@"<MTLCommandBuffer>"24@0:8@"MTLCommandBufferDescriptor"16
B28@0:8Q16S24
i24@0:8@16
i32@0:8@16Q24
v24@0:8@"NSObject<OS_dispatch_queue>"16
@"NSObject<OS_dispatch_queue>"16@0:8
@"MTLCommandQueueSPIStats"16@0:8
@"NSArray"16@0:8
i24@0:8@"NSArray"16
i32@0:8@"NSArray"16Q24
@"NSArray"24@0:8@"NSArray"16
v24@0:8@?<v@?@"<MTLCommandBuffer>"@"NSData"Q>16
@?32@0:8^B16@24
@"MTLToolsPerfCounterMailbox"
@48@0:8@16@24@32Q40
@56@0:8@16@24@32@40Q48
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__cxx_atomic_base_impl<int>>="__a_value"Ai}}
@"MTLToolsObject"
B32@0:8@16^@24
B32@0:8@"NSURL"16^@24
B40@0:8@16Q24^@32
r^{?=[32C]}16@0:8
B40@0:8@"NSURL"16Q24^@32
@"NSString"24@0:8Q16
@"NSObject<OS_dispatch_data>"16@0:8
@"MTLDebugInstrumentationData"16@0:8
v24@0:8@"MTLDebugInstrumentationData"16
B40@0:8@16@24^@32
B32@0:8@"MTLComputePipelineDescriptor"16^@24
B32@0:8@"MTLRenderPipelineDescriptor"16^@24
B32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
B40@0:8@"MTLFunctionDescriptor"16@"<MTLLibrary>"24^@32
@24@0:8^@16
@40@0:8Q16^I24^@32
v32@0:8@16r^{?=[32C]}24
@24@0:8r^{?=[32C]}16
^{MTLPipelineCollection=}16@0:8
B24@0:8@?16
v32@0:8@"MTLBinaryEntry"16@"MTLBinaryKey"24
@"MTLBinaryEntry"24@0:8@"MTLBinaryKey"16
@"NSString"24@0:8^@16
@"<NSObject>"40@0:8Q16^I24^@32
@"NSMutableArray"16@0:8
B40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
B40@0:8@"MTLRenderPipelineDescriptor"16Q24^@32
B40@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32
B32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
B40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32
v32@0:8@"NSObject<OS_dispatch_data>"16r^{?=[32C]}24
@"NSObject<OS_dispatch_data>"24@0:8r^{?=[32C]}16
B32@0:8@"MTLStitchedLibraryDescriptor"16^@24
B24@0:8@"MTLComputePipelineDescriptor"16
B24@0:8@"MTLRenderPipelineDescriptor"16
B24@0:8@"MTLTileRenderPipelineDescriptor"16
B24@0:8@"MTLMeshRenderPipelineDescriptor"16
B24@0:8@?<B@?^{?=[32C]}@"NSObject<OS_dispatch_data>">16
@32@0:8Q16Q24
@40@0:8Q16Q24Q32
@32@0:8@16Q24
q16@0:8
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLBuffer>"40@0:8Q16Q24Q32
@"<MTLTexture>"32@0:8@"MTLTextureDescriptor"16Q24
@"<MTLAccelerationStructure>"24@0:8Q16
@"<MTLAccelerationStructure>"24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLAccelerationStructure>"32@0:8Q16Q24
@"<MTLAccelerationStructure>"32@0:8@"MTLAccelerationStructureDescriptor"16Q24
@"<MTLAccelerationStructure>"40@0:8Q16Q24Q32
v64@0:8{?={?=QQQ}{?=QQQ}}16
v56@0:8@16Q24{?=QQQ}32
v24@0:8@"<MTLComputePipelineState>"16
v40@0:8@"<MTLBuffer>"16Q24Q32
v32@0:8@"<MTLVisibleFunctionTable>"16Q24
v32@0:8@"<MTLIntersectionFunctionTable>"16Q24
v32@0:8@"<MTLAccelerationStructure>"16Q24
v32@0:8@"<MTLTexture>"16Q24
v32@0:8@"<MTLSamplerState>"16Q24
v40@0:8@"<MTLSamplerState>"16f24f28Q32
v32@0:8@"<MTLBuffer>"16Q24
v56@0:8@"<MTLBuffer>"16Q24{?=QQQ}32
v32@0:8@"<MTLResource>"16Q24
v40@0:8@"<MTLIndirectCommandBuffer>"16@"<MTLBuffer>"24Q32
B44@0:8@16Q24Q32I40
v44@0:8@16Q24Q32I40
@"NSData"16@0:8
v32@0:8@"<MTLResourceGroupSPI>"16Q24
B44@0:8@"<MTLBuffer>"16Q24Q32I40
v44@0:8@"<MTLBuffer>"16Q24Q32I40
@"MTLGPUDebugBuffer"
@"MTLGPUDebugDevice"
{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{KeyBufferPair="key"{Key="hash"{?="key"[32C]}"data"@"NSData"}"buffer"@"<MTLBuffer>"}
@"MTLDebugInstrumentationData"
@"MTLGPUDebugFunction"
@"MTLGPUDebugDynamicLibrary"
v48@0:8@16@24@32Q40
v56@0:8@16@24@32@40Q48
v64@0:8@16@24@32@40Q48Q56
v48@0:8@16@24Q32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLBuffer>"32Q40
v56@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48
v64@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48Q56
v32@0:8@"<MTLAccelerationStructure>"16@"<MTLAccelerationStructure>"24
v40@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32Q40
v48@0:8@16@24Q32@40
v56@0:8@16@24@32Q40@48
B32@0:8@16@24
v120@0:8@16@24Q32@40Q48@56Q64@72Q80@88Q96@104Q112
v48@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"MTLAccelerationStructureDescriptor"40
v56@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40@"MTLAccelerationStructureDescriptor"48
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBufferSizesSPI"24
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBuffersSPI"24
v120@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64@"<MTLBuffer>"72Q80@"<MTLBuffer>"88Q96@"<MTLBuffer>"104Q112
Q40@0:8{?=QQQ}16
@"<MTLFunctionHandle>"24@0:8@"<MTLFunction>"16
@"<MTLComputePipelineState>"32@0:8@"NSArray"16^@24
@"<MTLVisibleFunctionTable>"24@0:8@"MTLVisibleFunctionTableDescriptor"16
@"<MTLIntersectionFunctionTable>"24@0:8@"MTLIntersectionFunctionTableDescriptor"16
v32@0:8@"MTLGPUDebugComputeCommandEncoder"16Q24
v48@0:8@"MTLGPUDebugRenderCommandEncoder"16Q24{optional<unsigned long>=(?=cQ)B}32
@"<MTLResource>"16@0:8
@48@0:8@16@24Q32Q40
@52@0:8@16@24Q32Q40B48
@60@0:8@16@24@32Q40Q48B56
^v24@0:8Q16
{?={?=QQQ}{?=QQQ}}16@0:8
@"_MTLIndirectDispatchThreadgroupsArguments"16@0:8
@"_MTLIndirectDispatchThreadsArguments"16@0:8
@"_MTLImageBlockArguments"16@0:8
v24@0:8^Q16
@32@0:8^@16^Q24
@32@0:8@16^Q24
@48@0:8@16Q24^@32^@40
v40@0:8@16Q24@?32
@40@0:8@16r^{?=BQ^{?}}24^@32
@40@0:8@16Q24^@32
@48@0:8@16@24Q32^@40
@40@0:8Q16@24^@32
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@24@0:8^{__IOSurface=}16
@48@0:8r^v16Q24Q32Q40
@56@0:8^v16Q24Q32Q40@?48
@40@0:8@16^{__IOSurface=}24Q32
@48@0:8^v16Q24@32@?40
{?=QQQ}24@0:8@16
@32@0:8^v16@24
@40@0:8^v16@24@32
@32@0:8Q16@24
{MetalBufferHeap="_mutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_buffers"{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}"_freeList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_currentFreeIndex"i"_totalMemoryAllocated"Q"_totalMemoryInUse"Q"_bufferLength"Q"_device"@"MTLGPUDebugDevice"}
{Options="version"I"mode"i"programTypes"i"accessTypes"i"failMode"i""{?="enableReporting"b1"packPointerAddresses"b1"unpackPointerAddress"b1"forceInline"b1"enableBacktracking"b1"optimizeConstantDeref"b1"skipVertexFetchLoads"b1"enableGEPOptimization"b1"emitBoundsChecking"b1"runStandardOptimizations"b1"backtrackFailuresAssumeSafe"b1"pageDataIs32bitLength"b1"forceUnrollLoops"b1"mergeAccessChecks"b1"convertToAB"b1"arraysOfBuffersAB"b1"noInlineTrivialFunctions"b1"unrollMemCpyWA"b1"checkGlobalConstants"b1"enableTextureChecks"b1"demoteGlobalConstantsToArg"b1"argumentPointerIndirection"b1"enableThreadgroupMemoryChecks"b1"mergeThreadgroupGlobals"b1"mergeThreadgroupArguments"b1"tagThreadgroupPointers"b1"noInlineCheckFunctions"b1"enableJumpThreading"b1"enableICBSupport"b1"enableGlobalRelocations"b1"enableTrapReporting"b1"enableRaytracing"b1"enableResourceUsageValidation"b1"enableStackOverflow"b1}}
{GPUDebugDeviceOptions="retainReflection"b1"retainPSOFunctions"b1"abortOnFault"b1}
{GPUDebugBufferDescriptorHeap="s"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_freeIndexList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_bufferList"{vector<MTLGPUDebugBuffer *, std::allocator<MTLGPUDebugBuffer *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<MTLGPUDebugBuffer **, std::allocator<MTLGPUDebugBuffer *>>="__value_"^@}}"_freeIndex"Q"_argumentEncoder"@"<MTLArgumentEncoder>""_descriptorHeap"@"<MTLBuffer>"}
{GPUDebugConstantBufferCache="_totalUsedMemory"Q"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_cache"{unordered_map<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, std::allocator<std::pair<const GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__table_"{__hash_table<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>, std::allocator<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>>="__value_"f}}}"_device"@"MTLGPUDebugDevice"}
{GlobalResidentBufferList="_iteration"I"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_bufferList"{list<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__end_"{__list_node_base<id<MTLBuffer>, void *>="__prev_"^v"__next_"^v}"__size_alloc_"{__compressed_pair<unsigned long, std::allocator<std::__list_node<id<MTLBuffer>, void *>>>="__value_"Q}}}
@"NSData"
@"NSMutableArray"
{once_flag="__state_"Q}
@"<MTLRenderPipelineState>"
@"<MTLDepthStencilState>"
@"<MTLComputePipelineState>"
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
B24@0:8q16
v32@0:8^{?=ff}16Q24
@40@0:8@16q24^@32
{?=QQQ}40@0:8Q16Q24Q32
Q24@0:8q16
{?=QQQ}48@0:8Q16Q24Q32q40
v32@0:8^Q16^Q24
{?=QQ}24@0:8Q16
{?=QQQ}16@0:8
v72@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56Q64
v64@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56
@"<MTLCommandQueue>"24@0:8Q16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptor"16^@24
v32@0:8@"MTLStitchedLibraryDescriptor"16@?<v@?@"<MTLLibrary>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLRenderPipelineState>"48@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLRasterizationRateMap>"24@0:8@"MTLRasterizationRateMapDescriptor"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@"<MTLIOFileHandle>"32@0:8@"NSURL"16^@24
@"<MTLIOCommandQueue>"32@0:8@"MTLIOCommandQueueDescriptor"16^@24
@"<MTLIOFileHandle>"40@0:8@"NSURL"16q24^@32
@"<MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
@"<MTLArgumentEncoder>"24@0:8@"<MTLBufferBinding>"16
@"<MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
@"<MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
@"<MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
{?=QQQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=QQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=II}16@0:8
@20@0:8I16
B44@0:8^@16Q24^Q32i40
B24@0:8{?=II}16
v40@0:8@16r^v24@32
v48@0:8@16r^v24@32@40
B36@0:8@16B24^@28
r^{MTLTargetDeviceArch=QI*}16@0:8
r^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ}16@0:8
f16@0:8
{IndirectArgumentBufferCapabilities=b1b1b1b29}16@0:8
v24@0:8^{MPSFunctionTable=}16
v40@0:8Q16^Q24Q32
B32@0:8{_NSRange=QQ}16
B40@0:8^{?=III}16Q24Q32
@32@0:8^v16Q24
@40@0:8^v16@24Q32
^{os_unfair_lock_s=I}16@0:8
@28@0:8@16I24
@28@0:8@16B24
{?=QQQ}48@0:8q16Q24Q32Q40
v48@0:8@16@24@32^@40
v40@0:8@16@24^@32
@32@0:8r^@16Q24
@"MTLArchitecture"24@0:8@"NSArray"16
v24@0:8@"<MTLDeviceSPI>"16
@"<MTLBuffer>"24@0:8^{__IOSurface=}16
B24@0:8@"NSString"16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
@"_MTLIndirectArgumentBufferLayout"24@0:8@"MTLStructType"16
@"<MTLArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLIndirectRenderCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLIndirectComputeCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLSharedEvent>"20@0:8I16
@"<MTLAccelerationStructure>"32@0:8@"<MTLBuffer>"16Q24
@"<MTLAccelerationStructure>"40@0:8@"<MTLBuffer>"16Q24Q32
@"<MTLAccelerationStructure>"32@0:8^v16@"MTLAccelerationStructureDescriptor"24
@"<MTLAccelerationStructure>"40@0:8^v16@"NSArray"24@"MTLAccelerationStructureDescriptor"32
@"<MTLAccelerationStructure>"32@0:8Q16@"MTLAccelerationStructureAllocationDescriptor"24
v40@0:8@"<MTLAccelerationStructure>"16r^v24@"MTLAccelerationStructureDescriptor"32
v48@0:8@"<MTLAccelerationStructure>"16r^v24@"NSArray"32@"MTLAccelerationStructureDescriptor"40
@"<MTLDynamicLibrary>"40@0:8@"<MTLLibrary>"16@"MTLComputePipelineDescriptor"24^@32
B32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"40@0:8@"NSURL"16Q24^@32
@"NSArray"32@0:8@"MTLComputePipelineDescriptor"16^@24
@"NSArray"40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
@"NSArray"40@0:8@"MTLFunction"16@"NSArray"24^@32
@"NSArray"48@0:8@"MTLFunction"16@"NSArray"24Q32^@40
B36@0:8@"<MTLLibrary>"16B24^@28
@"<MTLBinaryArchive>"40@0:8Q16@"NSURL"24^@32
@"<MTLRenderPipelineState>"32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
v32@0:8@"MTLMeshRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLDeadlineProfile>"24@0:8Q16
@"MTLTargetDeviceArchitecture"16@0:8
@"MTLArchitecture"16@0:8
@"MTLGPUBVHBuilder"16@0:8
v24@0:8@"NSDictionary"16
v24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLBuffer>"48@0:8r^v16Q24Q32Q40
@"<MTLBuffer>"56@0:8^v16Q24Q32Q40@?<v@?^vQ>48
@"<MTLBuffer>"24@0:8@"MTLBufferDescriptor"16
@"<MTLLateEvalEvent>"16@0:8
@"<MTLComputePipelineState>"32@0:8@"MTLComputePipelineDescriptor"16^@24
v32@0:8@"MTLComputePipelineDescriptor"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
v32@0:8@"MTLTileRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLFunction>"32@0:8^v16Q24
@"<MTLFunction>"40@0:8^v16@"NSObject<OS_dispatch_data>"24Q32
v24@0:8@"MTLGPUBVHBuilder"16
@"<MTLIndirectArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLComputePipelineState>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLLibrary>"40@0:8@"NSString"16@"NSArray"24^@32
@"<MTLLibrary>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptorSPI"16^@24
@"NSString"24@0:8@"NSArray"16
@"<MTLLibrary>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLPipelineLibrarySPI>"32@0:8@"NSString"16^@24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLRenderPipelineDescriptor"16
@"NSObject<OS_dispatch_data>"24@0:8@"MTLComputePipelineDescriptor"16
@"MTLRenderPipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"MTLComputePipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLStructType"16
@"NSObject<OS_dispatch_data>"28@0:8@"MTLStructType"16I24
@"MTLStructType"24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLTexture>"48@0:8^v16Q24@"MTLTextureDescriptor"32@?<v@?^vQ>40
@"<MTLTextureLayout>"28@0:8@"MTLTextureDescriptor"16B24
@"<MTLIndirectArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
v48@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@"<MTLBinaryArchive>"32^@40
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24^@32
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@?<v@?@"NSError">32
@"<MTLResourceGroupSPI>"32@0:8r^@16Q24
v32@0:8@"NSObject<OS_dispatch_data>"16@"NSMutableDictionary"24
Q28@0:8Q16B24
@"<MTLDeviceSPI>"
@"MTLToolsObjectCache"
v40@0:8@"MTLSharedEventListener"16Q24@?<v@?@"<MTLSharedEvent>"Q>32
@"MTLSharedEventHandle"16@0:8
B32@0:8Q16Q24
@32@0:8Q16^@24
@"<MTLArgumentEncoder>"24@0:8Q16
@"<MTLArgumentEncoder>"32@0:8Q16^@24
v32@0:8Q16@?24
@40@0:8Q16^@24@32
@28@0:8@16C24
@"MTLFunctionReflection"24@0:8Q16
@"MTLFunctionReflection"32@0:8Q16@"<MTLPipelineLibrary>"24
@"MTLFunctionReflection"32@0:8Q16@"NSArray"24
v32@0:8Q16@?<v@?@"MTLFunctionReflection">24
@"<MTLArgumentEncoder>"32@0:8Q16@"<MTLPipelineLibrary>"24
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"<MTLPipelineLibrary>"32
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"NSArray"32
@"<MTLFunction>"28@0:8@"NSData"16C24
@"MTLType"16@0:8
@"<MTLFunctionHandle>"16@0:8
@"<MTLFunction>"24@0:8@"NSString"16
@"<MTLFunction>"40@0:8@"NSString"16@"MTLFunctionConstantValues"24^@32
v40@0:8@"NSString"16@"MTLFunctionConstantValues"24@?<v@?@"<MTLFunction>"@"NSError">32
v32@0:8@"MTLFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLFunctionDescriptor"16^@24
v32@0:8@"MTLIntersectionFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLIntersectionFunctionDescriptor"16^@24
@"<MTLFunction>"48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32^@40
v48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32@?<v@?@"<MTLFunction>"@"NSError">40
@"<MTLFunction>"40@0:8@"MTLFunctionDescriptor"16@"<MTLBinaryArchive>"24^@32
@"NSUUID"16@0:8
v32@0:8@"<MTLFunctionHandle>"16Q24
v40@0:8Q16{_NSRange=QQ}24
@"<MTLBuffer>"16@0:8
v24@0:8@"<MTLBuffer>"16
@"MTLCountersTraceComputeCommandEncoder"
@64@0:8@16@24@32@40@48Q56
@80@0:8@16@24@32@40@48@56@64@72
@48@0:8@16@24@32@40
@"MTLRenderPipelineReflection"
@"MTLToolsDevice"
@"<MTLRenderCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
v24@0:8@"<MTLRenderPipelineState>"16
v24@0:8@"<MTLDepthStencilState>"16
v80@0:8@"<MTLBuffer>"16Q24{?=QQQ}32{?=QQQ}56
v64@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56
v56@0:8Q16Q24Q32@"<MTLBuffer>"40Q48
v80@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56q64Q72
v40@0:8Q16@"<MTLBuffer>"24Q32
v64@0:8Q16Q24@"<MTLBuffer>"32Q40@"<MTLBuffer>"48Q56
v32@0:8@"<MTLFence>"16Q24
v72@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64
v56@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48
v88@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80
v72@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64
v40@0:8@"<MTLResource>"16Q24Q32
v32@0:8@"<MTLHeap>"16Q24
v40@0:8f16f20f24f28Q32
v44@0:8@16f24f28f32Q36
v28@0:8B16Q20
v24@0:8@?<v@?@"<MTLRenderCommandEncoderSPI>"Q>16
v48@0:8@"<MTLTexture>"16Q24@"<MTLSamplerState>"32Q40
v44@0:8@"<MTLSamplerState>"16f24f28f32Q36
v56@0:8@"<MTLTexture>"16Q24Q32Q40Q48
v60@0:8@"<MTLTexture>"16Q24Q32Q40B48Q52
v48@0:8@"<MTLTexture>"16Q24Q32Q40
v52@0:8@"<MTLTexture>"16Q24Q32Q40B48
v40@0:8@"<MTLResourceGroupSPI>"16Q24Q32
v60@0:8@16Q24Q32Q40Q48B56
v48@0:8r^@16{_NSRange=QQ}24Q40
@"MTLGPUDebugComputePipelineState"
@40@0:8@16Q24@32
{?=QQQ}24@0:8Q16
{?=ff}32@0:8{?=ff}16Q24
{?=QQ}16@0:8
v24@0:8@"MTLRasterizationRateMapDescriptor"16
@32@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16Q24
{_NSRange=QQ}16@0:8
^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}
{_NSRange="location"Q"length"Q}
@24@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16
v80@0:8Q16Q24Q32@40Q48Q56Q64Q72
v64@0:8@16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v64@0:8@16Q24Q32@40Q48Q56
@20@0:8B16
v32@0:8r^v16Q24
v40@0:8r^v16@24@32
{BinaryBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}"_timebase"{mach_timebase_info="numer"I"denom"I}}
{AppendBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}}
@"<MTLFunctionHandle>"32@0:8@"<MTLFunction>"16Q24
@"<MTLVisibleFunctionTable>"32@0:8@"MTLVisibleFunctionTableDescriptor"16Q24
@"<MTLIntersectionFunctionTable>"32@0:8@"MTLIntersectionFunctionTableDescriptor"16Q24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineFunctionsDescriptor"16^@24
@"<MTLRenderPipelineState>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLRenderPipelineState>"32@0:8@"NSArray"16^@24
@32@0:8@16:24
@"MTLToolsHeap"
v112@0:8Q16Q24Q32@40Q48@56Q64Q72Q80@88Q96Q104
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLTexture>"16@0:8
@48@0:8Q16Q24Q32Q40
@72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
@"<MTLTexture>"48@0:8Q16Q24Q32Q40
@"<MTLTexture>"32@0:8Q16Q24
@"<MTLTexture>"72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@"<MTLTexture>"76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
v104@0:8Q16Q24{?=QQQ}32{?=QQQ}56^v80Q88Q96
v104@0:8r^v16Q24Q32Q40Q48{?=QQQ}56{?=QQQ}80
@"<MTLTexture>"
v120@0:8r^v16Q24Q32Q40^v48Q56Q64{?={?=QQQ}{?=QQQ}}72
v120@0:8r^v16Q24Q32{?={?=QQQ}{?=QQQ}}40^v88Q96Q104Q112
v24@0:8^v16
{?=[2Q]}16@0:8
@56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
@"<MTLBuffer>"56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
{pair<id<MTLBuffer>, unsigned long>=@Q}24@0:8Q16
{ReportBufferEntry=Q@Q}24@0:8Q16
@"<MTLArgumentEncoder>"
{vector<MetalBuffer, std::allocator<MetalBuffer>>="__begin_"^{MetalBuffer}"__end_"^{MetalBuffer}"__end_cap_"{__compressed_pair<MetalBuffer *, std::allocator<MetalBuffer>>="__value_"^{MetalBuffer}}}
{MetalBuffer="heap"^{MetalBufferHeap}"index"I}
{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}
{vector<ReportBufferEntry, std::allocator<ReportBufferEntry>>="__begin_"^{ReportBufferEntry}"__end_"^{ReportBufferEntry}"__end_cap_"{__compressed_pair<ReportBufferEntry *, std::allocator<ReportBufferEntry>>="__value_"^{ReportBufferEntry}}}
{vector<NSString *, std::allocator<NSString *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<NSString **, std::allocator<NSString *>>="__value_"^@}}
[2{BufferUsageTable="_backingMemory"@"<MTLBuffer>"}]
[2{TextureUsageTable="_backingMemory"@"<MTLBuffer>"}]
{HeapUsageTable="_heapStages"{vector<std::pair<MTLGPUDebugHeap *, unsigned long>, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<MTLGPUDebugHeap *, unsigned long> *, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__value_"^v}}}
v64@0:8@"<MTLTexture>"16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@"<MTLTexture>"16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v48@0:8@"<MTLTexture>"16Q24@"<MTLBuffer>"32Q40
v64@0:8@"<MTLTexture>"16Q24Q32@"<MTLBuffer>"40Q48Q56
v148@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136B144
v112@0:8@16Q24Q32{?=QQQ}40@64Q72Q80Q88Q96Q104
{deque<id, std::allocator<id>>="__map_"{__split_buffer<id *, std::allocator<id *>>="__first_"^^@"__begin_"^^@"__end_"^^@"__end_cap_"{__compressed_pair<id **, std::allocator<id *>>="__value_"^^@}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<id>>="__value_"Q}}
@"MTLDebugCommandBuffer"
@40@0:8@16@24Q32
@48@0:8@16@24r^v32Q40
r^v16@0:8
@"MTLDebugResource"
@"MTLDebugDevice"
@"MTLDebugCommandQueue"
v32@0:8@16B24B28
v28@0:8@16B24
B32@0:8@16^B24
@"_MTLCommandEncoder"
{unordered_multiset<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__table_"{__hash_table<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>, std::allocator<std::__hash_node<AttachmentDescriptorSimple, void *>>>="__value_"{__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, AttachmentDescriptorSimple::hash_t>="__value_"Q}"__p3_"{__compressed_pair<float, AttachmentDescriptorSimple::equal_t>="__value_"f}}}
{array<AttachmentDescriptorSimple, 8UL>="__elems_"[8{AttachmentDescriptorSimple="texture"^v"level"Q"sliceRange"{_NSRange="location"Q"length"Q}"depthPlaneRange"{_NSRange="location"Q"length"Q}"storeAction"Q}]}
{unordered_set<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__table_"{__hash_table<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>, std::allocator<std::__hash_node<id<MTLDebugResourcePurgeable>, void *>>>="__value_"{__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<id<MTLDebugResourcePurgeable>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<id<MTLDebugResourcePurgeable>>>="__value_"f}}}
{unordered_set<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__table_"{__hash_table<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>, std::allocator<std::__hash_node<MTLToolsObject *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLToolsObject *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLToolsObject *>>="__value_"f}}}
v96@0:8Q16Q24Q32@40Q48Q56Q64@72Q80Q88
v96@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64@"<MTLBuffer>"72Q80Q88
v112@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80@"<MTLBuffer>"88Q96Q104
^{?=[3I]}16@0:8
@"_MTLIndirectDrawArguments"16@0:8
@"_MTLIndirectDrawIndexedArguments"16@0:8
@"_MTLIndirectDrawPatchesArguments"16@0:8
@"_MTLIndirectDrawIndexedPatchesArguments"16@0:8
@"_MTLIndirectTessellationFactorArguments"16@0:8
@"MTLCounterSampleBufferDescriptor"
@40@0:8@16r^v24@32
@56@0:8@16@24@32@40@48
@"MTLComputePipelineReflection"
[31{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[128{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[16{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{?="width"Q"height"Q"depth"Q}
{?="origin"{?="x"Q"y"Q"z"Q}"size"{?="width"Q"height"Q"depth"Q}}
[3Q]
@"MTLComputePipelineDescriptor"
@56@0:8@16@24@32Q40Q48
@"<MTLIndirectCommandBuffer>"
@"<MTLComputePipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"<MTLRenderPipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"MTLComputePipelineDescriptor"32@0:8@"NSString"16^@24
@"MTLRenderPipelineDescriptor"32@0:8@"NSString"16^@24
@"<MTLPipelineCache>"16@0:8
v32@0:8@"<MTLRenderPipelineState>"16Q24
v32@0:8@"<MTLComputePipelineState>"16Q24
v32@0:8@"<MTLIndirectCommandBuffer>"16Q24
@"_MTLIndirectArgumentBufferLayout"16@0:8
{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}
@"<MTLIOScratchBuffer>"24@0:8Q16
v32@0:8@16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16B24B28^{_MTLMessageContext=q*I@q@*}32
v40@0:8Q16Q24^{_MTLMessageContext=q*I@q@*}32
v40@0:8@16Q24^f32
{MTLSamplerDescriptorHashMap="_map"{unordered_map<std::array<unsigned long long, 3>, unsigned int, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, std::allocator<std::pair<const std::array<unsigned long long, 3>, unsigned int>>>="__table_"{__hash_table<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>, std::allocator<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>>="__value_"f}}}"_limit"I}
{unordered_set<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__table_"{__hash_table<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>, std::allocator<std::__hash_node<MTLDebugCommandBuffer *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLDebugCommandBuffer *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLDebugCommandBuffer *>>="__value_"f}}}
{CheckerboardRenderTargetPipelineCache="_cacheLock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"_library"@"<MTLLibrary>""_vertexFunction"@"<MTLFunction>""_depthStencilState"[2@"<MTLDepthStencilState>"]"_fConstants"@"MTLFunctionConstantValues""_cache"{unordered_map<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, std::allocator<std::pair<const MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__table_"{__hash_table<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>, std::allocator<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>>="__value_"f}}}}
C16@0:8
@"MTLDepthStencilDescriptor"
@56@0:8@16@24Q32Q40@48
@"MTLCountersTraceResourceStateCommandEncoder"
@"MTLAccelerationStructureDescriptor"16@0:8
v24@0:8@"MTLAccelerationStructureDescriptor"16
@"MTLToolsBuffer"
@32@0:8@16@?24
@"NSMapTable"
{recursive_mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{vector<id, std::allocator<id>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id *, std::allocator<id>>="__value_"^@}}
@"MTLFunctionConstantValues"
@56@0:8@16@24Q32@40@48
v32@0:8@16#24
v32@0:8@16r^{?=BQ^{?}}24
^{?=BQ^{?}}16@0:8
@"MTLCompileOptions"
^{?=BQ^{?}}
{atomic<unsigned long long>="__a_"{__cxx_atomic_impl<unsigned long long, std::__cxx_atomic_base_impl<unsigned long long>>="__a_value"AQ}}
@"MTLRenderPassDescriptor"
@32@0:8r^{MTLRenderPassAttachmentDescriptorPrivate=@QQQQQQ{?=dddd}dIQ@QQQQQQB}16Q24
Q24@0:8@16
{?=dddddd}16@0:8
{?=QQQQ}16@0:8
v56@0:8{?=QQQ}16^{?={?=QQQ}{?=QQQ}}40^I48
v48@0:8@16Q24^{_MTLMessageContext=q*I@q@*}32@40
v24@0:8^{_MTLMessageContext=q*I@q@*}16
v56@0:8Q16Q24Q32Q40r*48
v72@0:8Q16Q24Q32@40Q48Q56r*64
v64@0:8@16Q24Q32^{?=BBQ@QQQQQBff}40Q48Q56
v72@0:8r^@16{_NSRange=QQ}24Q40^{?=BBQ@QQQQQBff}48Q56Q64
{?=BBQ@QQQQQBff}16@0:8
^{?=QQ}
[10{?="pixelFormat"Q"sampleCount"Q}]
[36{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{vector<MTLViewport, std::allocator<MTLViewport>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLViewport *, std::allocator<MTLViewport>>="__value_"^{?}}}
{vector<MTLScissorRect, std::allocator<MTLScissorRect>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLScissorRect *, std::allocator<MTLScissorRect>>="__value_"^{?}}}
{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}
@"MTLCountersTraceCommandBuffer"
{MTLGPUDebugThreadgroupLengths="threadgroupSizes"[31I]"entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
@"MTLToolsFunction"
@48@0:8Q16^@24@32@40
{unordered_map<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__table_"{__hash_table<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>, std::allocator<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>>="__value_"f}}}
@40@0:8@16Q24:32
v40@0:8r^{?=QQQ}16Q24^{_MTLMessageContext=q*I@q@*}32
[8Q]
[31{?="bufferIndex"Q"bufferStride"Q}]
@"MTLRenderPipelineDescriptor"
@"MTLTileRenderPipelineDescriptor"
@"MTLMeshRenderPipelineDescriptor"
@"MTLSamplerDescriptor"
v32@0:8Q16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16{?=QQ}24
@64@0:8@16@24@32Q40Q48Q56
@88@0:8@16@24@32Q40Q48{_NSRange=QQ}56{_NSRange=QQ}72
{MTLPixelFormatInfo="name"*"flags"I"castClass"Q"type"(?="normal"{MTLNormalPixelFormatInfo="pixelBytes"Q"componentCount"C"alignment"C"pixelBytesRender"Q"pixelBytesRenderMSAA"Q}"compressed"{MTLCompressedPixelFormatInfo="blockBytes"Q"blockWidth"Q"blockHeight"Q"blockDepth"Q})}
{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::allocator<std::pair<const SubView, unsigned long>>>="__table_"{__hash_table<std::__hash_value_type<SubView, unsigned long>, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>, std::allocator<std::__hash_value_type<SubView, unsigned long>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>>="__value_"f}}}
@"MTLTextureDescriptor"
@"MTLDebugBuffer"
v48@0:8^v16Q24@32Q40
v56@0:8@16Q24Q32@40Q48
v120@0:8@16Q24Q32{?=QQQ}40Q64Q72{?=QQQ}80@104Q112
v24@0:8@?<v@?@"<MTLIOCommandBuffer>">16
v48@0:8^v16Q24@"<MTLIOFileHandle>"32Q40
v56@0:8@"<MTLBuffer>"16Q24Q32@"<MTLIOFileHandle>"40Q48
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40Q64Q72{?=QQQ}80@"<MTLIOFileHandle>"104Q112
v32@0:8@"<MTLSharedEvent>"16Q24
q56@0:8^v16Q24Q32^v40Q48
^v48@0:8Q16Q24^v32Q40
q64@0:8^v16Q24Q32^v40Q48^B56
^v56@0:8Q16Q24^v32Q40^B48
Q32@0:8Q16Q24
@"<MTLIOCommandBuffer>"16@0:8
@"MTLCountersTraceBlitCommandEncoder"
-[MTLDebugIndirectComputeCommand setComputePipelineState:]
Setting the pipeline state of indirect command buffers created with inheritPipelineState = YES is invalid
Setting a pipeline that does not have supportIndirectCommandBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand setKernelBuffer:offset:atIndex:]
index(%lu) must be < %lu.
Setting buffers on a indirect command buffer created with inheritBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand concurrentDispatchThreadgroups:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatch is not enabled on this indirect command buffer
-[MTLDebugIndirectComputeCommand concurrentDispatchThreads:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatchThreads is not enabled on this indirect command buffer
<unknown>
<unnamed>
<nil>
Unknown
Read Only
Write Only
Read Write
%@, length:%llu, resident:%@
%@, length:%llu
Invalid %@ %@ executing %@ function "%@" encoder: "%@", %@: %lu, at offset %llu
device
threadgroup
buffer: %@
Null texture access
Texture usage flags mismatch
%@ executing %@ function "%@" encoder: "%@", %@: %lu
Stack Overflow executing function "%@", %@ function "%@" encoder: "%@", %@: %u
Trap hit in function "%@", %@ function "%@", encoder: "%@", %@: %u
kernel
dispatch
vertex
draw
fragment
visible
intersection
object
mesh
%@(%@)
%llX
.xctoolchain/
v24@?0@"<MTLFunction>"8@"NSError"16
%@%@
label =
<none>
v16@?0@"<MTLCommandBuffer>"8
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
v32@?0@"<MTLCommandBuffer>"8@"NSData"16Q24
-[MTLDebugVisibleFunctionTable setPurgeableState:]
Setting purgeability state directly on heap sub-allocated resources is not allowed.
Cannot set purgeability state to volatile while resource is in use by a command buffer.
-[MTLDebugVisibleFunctionTable setFunction:atIndex:]
Visible Function Tables are not supported by the device.
function stage %@ does not match intersection table stage %@
pipelineState must be MTLComputePipelineState or MTLRenderPipelineState
-[MTLDebugVisibleFunctionTable setFunctions:withRange:]
NSMaxRange(range)(%lu) must be <= %lu.
functionCount =
mtl.global_constants_handle
mtl.current_image_id
v8@?0
com.apple.Metal
GPUDebug
v40@?0r^v8{_NSRange=QQ}16^B32
MTL_BOUNDS_ACCURATE_MODE
MTL_SHADER_VALIDATION_CPUOPT_FORCE_INIT
MTLBoundsCheck::Options
MTLBoundsCheck::RenderPipelineData
MTLBoundsCheck::ComputePipelineData
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
MetalShaderValidation
Metal Shader Validation does not support mesh shaders in this release. To use mesh shaders in this release, disable Metal Shader Validation in the Xcode scheme settings.
v32@?0@"<MTLComputePipelineState>"8@"MTLComputePipelineReflection"16@"NSError"24
-[MTLGPUDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
Indirect Command Buffers are not currently supported with Shader Validation
v24@?0@"<MTLLibrary>"8@"NSError"16
-[MTLGPUDebugDevice validateRaytracing]
ray tracing is not currently supported with Shader Validation
@"MTLToolsDynamicLibrary"8@?0
@"MTLToolsFunction"8@?0
MTL_SHADER_VALIDATION_MODE
Tier1
Tier2
MTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING
MTL_SHADER_VALIDATION_GLOBAL_MEMORY
MTL_SHADER_VALIDATION_THREADGROUP_MEMORY
MTL_SHADER_VALIDATION_TEXTURE_USAGE
MTL_SHADER_VALIDATION_RESOURCE_USAGE
MTL_SHADER_VALIDATION_STACK_OVERFLOW
MTL_SHADER_VALIDATION_COMPILER_INLINING
none
full
partial
default
MTL_SHADER_VALIDATION_FAIL_MODE
zerofill
allow
MTL_SHADER_VALIDATION_GPUOPT_FORCE_INLINE
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_PACK_POINTER_ADDRESSES
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_BACKTRACK
MTL_SHADER_VALIDATION_GPUOPT_CONST_DEREF
MTL_SHADER_VALIDATION_GPUOPT_GEP
MTL_SHADER_VALIDATION_GPUOPT_GENERIC
MTL_SHADER_VALIDATION_GPUOPT_SKIP_VFETCH
MTL_SHADER_VALIDATION_GPUOPT_BACKTRACK_FAIL_ASSUME_SAFE
MTL_SHADER_VALIDATION_GPUOPT_MERGE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_USE_LENGTH_ONLY
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_TRIVIAL
MTL_SHADER_VALIDATION_GPUOPT_DEMOTE_GLOBALS_CONSTANTS_TO_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_POINTER_INDIRECTION
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_GLOBALS
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_JUMP_THREADING
MTL_SHADER_VALIDATION_GPUOPT_USE_RELOCATIONS
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_REFELECTION
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_TRAP
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_FUNCTIONS
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_RAY_TRACING
MTL_SHADER_VALIDATION_ABORT_ON_FAULT
Invalid option for %s, valid options are:
com.apple.gpusw.MetalTools
MTLGPUDebugICBSupport
metallib
ICB_Inherit_PSO_Vertex
ICB_Inherit_None_Vertex
ICB_Inherit_Buffers_Vertex
ICB_Inherit_PSO_Kernel
ICB_Inherit_None_Kernel
ICB_Inherit_Buffers_Kernel
ICB_Inherit_Both_Kernel
Faults from argument buffers will not be detected.
Faults from reading global constant variables will not be detected.
%@ -debug-info-kind=line-tables-only
-debug-info-kind=line-tables-only
@"MTLToolsLibrary"8@?0
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v24@?0@"<MTLComputePipelineState>"8@"NSError"16
ciKernelMain
-[MTLToolsDevice unwrapMTLCommandBufferDescriptor:alwaysCopy:]
Incorrect object type in %s: expected %s, found %s
@"MTLToolsDepthStencilState"8@?0
@"MTLToolsSamplerState"8@?0
v24@?0@"<MTLSharedEvent>"8Q16
-[MTLDebugPipelineLibrary newComputePipelineStateWithName:options:reflection:error:]
name must not be nil.
descriptor is not a NSString.
-[MTLDebugPipelineLibrary newRenderPipelineStateWithName:options:reflection:error:]
@"MTLToolsFunctionHandle"8@?0
-[MTLGPUDebugAccelerationStructureCommandEncoder buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:]
Per Primitive Data is not supported with shader validation!
%@ -> %@
-[MTLDebugIntersectionFunctionTable setPurgeableState:]
-[MTLDebugIntersectionFunctionTable setFunction:atIndex:]
-[MTLDebugIntersectionFunctionTable setFunctions:withRange:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:]
-[MTLDebugIntersectionFunctionTable setOpaqueTriangleIntersectionFunctionWithSignature:withRange:]
"version":"
0.908
,"handle":"
,"device":{
"handle":"
,"name":"
,"queue":{
,"events":{
,"methods":[
{"selector":"
,"flags":
,"commands":"
,"commandBufferLength":
,"encoders":[
{"flags":
,"segment":{"location":
,"length":
,"statistics":{"flags":
,"counters":[
{"name":"
],"samples":"
,"sampleBufferLength":
cb_%llu.json
Error saving file '%@' (%@)
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
fillBuffer:range:value
fillBuffer:range:pattern4
fillTexture:level:slice:region:data:size
fillTexture:level:slice:region:color
fillTexture:level:slice:region:color:pixelFormat
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount
copyFromTexture:toTexture
generateMipmapsForTexture
synchronizeResource
synchronizeTexture
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset
resetTextureAccessCounters:region:mipLevel:slice
dispatchThreadgroups:threadsPerThreadgroup
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
setBuffer:offset:atIndex
setBufferOffset:atIndex
setBuffers:offsets:withRange
setBytes:length:atIndex
setComputePipelineState
setSamplerState:atIndex
setSamplerState:lodMinClamps:lodMaxClamps:atIndex
setSamplerStates:withRange
setSamplerStates:lodMinClamps:lodMaxClamps:withRange
setStageInRegion
setTexture:atIndex
setTextures:withRange
setThreadgroupMemoryLength:atIndex
memoryBarrierWithScope
memoryBarrierWithResources:count
drawPrimitives:vertexStart:vertexCount
drawPrimitives:vertexStart:vertexCount:instanceCount
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance
drawPrimitives:indirectBuffer:indirectBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset
drawIndexedPatches:patchStart:patchCount:controlPointIndexBuffer:controlPointIndexBufferOffset:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset
dispatchThreadsPerTile
setBlendColorRed:green:blue:alpha
setColorStoreAction:atIndex
setCullMode
setDepthBias:slopeScale:clamp
setDepthClipMode
setDepthStencilState
setDepthStoreAction
setFragmentBuffer:offset:atIndex
setFragmentBufferOffset:atIndex
setFragmentBuffers:offsets:withRange
setFragmentBytes:length:atIndex
setFragmentSamplerState:atIndex
setFragmentSamplerState:lodMinClamps:lodMaxClamps:atIndex
setFragmentSamplerStates:withRange
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange
setFragmentTexture:atIndex
setFragmentTextures:withRange
setFrontFaceWinding
setRenderPipelineState
setScissorRect
setScissorRects:count
setStencilFrontReferenceValue:backReferenceValue
setStencilReferenceValue
setStencilStoreAction
setTessellationFactorBuffer:offset:instanceStride
setTessellationFactorScale
setTriangleFillMode
setVertexBuffer:offset:atIndex
setVertexBufferOffset:atIndex
setVertexBuffers:offsets:withRange
setVertexBytes:length:atIndex
setVertexSamplerState:atIndex
setVertexSamplerState:lodMinClamps:lodMaxClamps:atIndex
setVertexSamplerStates:withRange
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange
setVertexTexture:atIndex
setVertexTextures:withRange
setTileBuffer:offset:atIndex
setTileBufferOffset:atIndex
setTileBuffers:offsets:withRange
setTileBytes:length:atIndex
setTileSamplerState:atIndex
setTileSamplerState:lodMinClamps:lodMaxClamps:atIndex
setTileSamplerStates:withRange
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange
setTileTexture:atIndex
setTileTextures:withRange
setViewport
setViewports:count
setVisibilityResultMode:offset
textureBarrier
memoryBarrierWithScope:afterStages:beforeStages
memoryBarrierWithResources:count:afterStages:beforeStages
setVisibleFunctionTable:atBufferIndex
setVisibleFunctionTables:withBufferRange
setIntersectionFunctionTable:atBufferIndex
setIntersectionFunctionTables:withBufferRange
insertDebugSignpost
pushDebugGroup
popDebugGroup
setLabel
updateFence
updateFence:afterStages
useHeap
useHeap:stages
useHeaps:count
useHeaps:count:stages
useResource:usage
useResource:usage:stages
useResources:count:usage
useResources:count:usage:stages
waitForFence
waitForFence:beforeStages
updateTextureMapping:mode:regions:mipLevel:slice
updateTextureMappings:mode:regions:mipLevels:numRegions:slices
updateTextureMappings:mode:indirectBuffer:indirectBufferOffset
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
%llu
-[MTLToolsResource validateCPUReadable]
resourceOptions (0x%lx) specify MTLResourceStorageModePrivate, which is not CPU accessible.
resourceOptions (0x%lx) specify MTLStorageModeMemoryless, which is not CPU accessible.
-[MTLToolsResource validateCPUWriteable]
%@:%@
v20@?0^I8I16
-[MTLDebugBlitCommandEncoder dealloc]
Command encoder released without endEncoding.
-[MTLDebugBlitCommandEncoder internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Encoder Copy From Texture Validation
the combination of MTLBlitOptionDepthFromDepthStencil and MTLBlitOptionStencilFromDepthStencil is invalid.
invalid usage because encoding has ended.
sourceTexture must not be nil.
sourceTexture is not a MTLTexture.
sourceTexture is associated with a different device
sourceTexture is Memoryless and cannot be used for copy operations!
destinationTexture must not be nil.
destinationTexture is not a MTLTexture.
destinationTexture is associated with a different device
destinationTexture is Memoryless and cannot be used for copy operations!
(sourceSize.width(%lu) * sourceSize.height(%lu) * sourceSize.depth(%lu))(%lu) must not be 0.
sourceTexture != nil
destinationTexture != nil
Copy From Texture Validation
[sourceTexture pixelFormat](%s) and [destinationTexture pixelFormat](%s) are not compatible for depth/stencil blits.
[sourceTexture pixelFormat](%s) must be compatible with [destinationTexture pixelFormat](%s).
[sourceTexture sampleCount](%lu) must equal [destinationTexture sampleCount](%lu).
sourceTexture must not be a framebufferOnly texture.
destinationTexture must not be a framebufferOnly texture.
sourceLevel(%lu) must be < [sourceTexture mipmapLevelCount](%lu).
sourceSlice(%lu) must be < (%lu).
destinationLevel(%lu) must be < [destinationTexture mipmapLevelCount](%lu).
destinationSlice(%lu) must be < (%lu).
(sourceOrigin.x + adjustedSourceSize.width)(%lu) must be <= paddedWidth(%lu).
(sourceOrigin.y + adjustedSourceSize.height)(%lu) must be <= paddedHeight(%lu).
(sourceOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(sourceOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(sourceOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(sourceOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
(destinationOrigin.x + adjustedDestinationSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedDestinationSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + destinationSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + destinationSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + destinationSize.depth)(%lu) must be <= depth(%lu).
sourceOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
sourceOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
sourceOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
size.width(%lu) must be a multiple of %s blockWidth(%lu).
size.height(%lu) must be a multiple of %s blockHeight(%lu).
size.depth(%lu) must be a multiple of %s blockDepth(%lu).
destinationOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
destinationOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
destinationOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
sourceOrigin.x must be 0 (full image) for %s.
sourceOrigin.y must be 0 (full image) for %s.
sourceOrigin.z must be 0 (full image) for %s.
sourceSize.width(%lu) must equal width(%lu) (full image) for %s.
sourceSize.height(%lu) must equal height(%lu) (full image) for %s.
sourceSize.depth(%lu) must equal depth(%lu) (full image) for %s.
destinationOrigin.x must be 0 (full image) for %s.
destinationOrigin.y must be 0 (full image) for %s.
destinationOrigin.z must be 0 (full image) for %s.
destinationSize.width(%lu) must equal width(%lu) (full image) for %s.
destinationSize.height(%lu) must equal height(%lu) (full image) for %s.
destinationSize.depth(%lu) must equal depth(%lu) (full image) for %s.
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s and destinationTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for destinationTexture with pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
Copy From Buffer Validation
sourceBuffer must not be nil.
sourceBuffer is not a MTLBuffer.
sourceBuffer is associated with a different device
destinationTexture cannot be Memoryless.
(destinationOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
sourceOffset (%lu) must be a multiple of %lu bytes.
%s disallowed unless MTLBlitOptionRowLinearPVRTC option is used.
%s is not allowed to use the MTLBlitOptionRowLinearPVRTC option.
sourceBytesPerRow(%lu) must be >= (%lu).
sourceBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [sourceBuffer length](%lu).
sourceBytesPerRow (%lu) must be a multiple of %lu bytes.
sourceBytesPerImage (%lu) must be a multiple of %lu bytes.
sourceBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
blits between texture with pixel format %s and buffer are not allowed.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
destinationBuffer must not be nil.
destinationBuffer is not a MTLBuffer.
destinationBuffer is associated with a different device
destinationOffset (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be >= (%lu).
destinationBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [destinationBuffer length](%lu).
destinationBytesPerRow (%lu) must be a multiple of %lu bytes.
destinationBytesPerImage (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:]
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
-[MTLDebugBlitCommandEncoder generateMipmapsForTexture:]
Generate Mipmaps For Texture Validation
tex must not be nil.
tex is not a MTLTexture.
tex is associated with a different device
cannot generate mipmaps of Memoryless texture.
[tex mipmapLevelCount](%lu) must be > 1.
tex(%s) is not colorRenderable.
tex(%s) is not filterable.
tex != nil
-[MTLDebugBlitCommandEncoder fillBuffer:range:value:]
Fill Buffer Validation
buffer must not be nil.
buffer is not a MTLBuffer.
buffer is associated with a different device
(range.location + range.length)(%lu) must be <= [buffer length](%lu).
range.length(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder fillBuffer:range:pattern4:]
range.location(%lu) must be a multiple of 4 bytes.
range.length(%lu) must be a multiple of 4 bytes.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:]
(sourceOffset + size)(%lu) must be <= [sourceBuffer length](%lu).
(destinationOffset + size)(%lu) must be <= [destinationBuffer length](%lu).
size(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder waitForFence:]
MTLFence cannot be waited on after it has been updated within the same encoder.
-[MTLDebugBlitCommandEncoder endEncoding]
endEncoding without use.
-[MTLDebugBlitCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
firstBatch (%d) must be less than or equal to lastBatch(%d)
-[MTLDebugBlitCommandEncoder getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:]
Get Texture Access Counters Validation
countersBuffer must not be nil.
countersBuffer is not a MTLBuffer.
countersBuffer is associated with a different device
(countersBufferOffset)(%lu) must be < [countersBuffer length](%lu).
Only sparse textures support access counters.
-[MTLDebugBlitCommandEncoder resetTextureAccessCounters:region:mipLevel:slice:]
-[MTLDebugBlitCommandEncoder validateTextureAccess:region:mipLevel:slice:]
Validate Texture Access Validation
slice(%lu) must be lower than arrayLength(%lu)
mipLevel(%lu) must be lower or equal to min(mipmapLevelCount-1,firstMipmapInTail)(%lu)
texture != nil
(region.origin.x + region.width)(%lu) must be <= widthInTiles(%lu).
(region.origin.y + region.height)(%lu) must be <= heightInTiles(%lu).
(region.origin.z + size.depth)(%lu) must be <= depthInTiles(%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:]
Optimize Contents For GPU Access Validation
texture must not be nil.
texture is not a MTLTexture.
texture is associated with a different device
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:slice:level:]
level(%lu) must be < [texture mipmapLevelCount](%lu).
slice(%lu) must be < (%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:]
Optimize Contents For CPU Access Validation
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:slice:level:]
-[MTLDebugBlitCommandEncoder resetCommandsInBuffer:withRange:]
Specified range (loc=%lu, len=%lu) is not inside the command buffer with size %lu.
-[MTLDebugBlitCommandEncoder copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:]
Copy Indirect Command Buffer Validation
source is not a MTLIndirectCommandBuffer.
destination is not a MTLIndirectCommandBuffer.
Specified source range (loc=%lu, len=%lu) is not inside the source command buffer with size %lu.
Specified destination range (loc=%lu, len=%lu) is not inside the destination command buffer with size %lu.
source commandTypes (%lu) are not equal to destination commandTypes (%lu).
source inheritPipelineState (%s) is not equal to destination inheritPipelineState (%s).
source inheritBuffers (%s) is not equal to destination inheritBuffers (%s).
source maxVertexBufferBindCount (%lu) is not equal to destination maxVertexBufferBindCount (%lu).
source maxFragmentBufferBindCount (%lu) is not equal to destination maxFragmentBufferBindCount (%lu).
source maxKernelBufferBindCount (%lu) is not equal to destination maxKernelBufferBindCount (%lu).
source maxObjectBufferBindCount (%lu) is not equal to destination maxObjectBufferBindCount (%lu).
source maxMeshBufferBindCount (%lu) is not equal to destination maxMeshBufferBindCount (%lu).
-[MTLDebugBlitCommandEncoder optimizeIndirectCommandBuffer:withRange:]
Optimize Indirect Command Buffer Validation
Overlapping ranges are not allowed
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:bytes:length:]
Fill Texture Validation
bytes must not be nil.
texture must have a color format, but is %s.
region.origin.x must be 0 (full image) for %s.
region.origin.y must be 0 (full image) for %s.
region.origin.z must be 0 (full image) for %s.
region.size.width(%lu) must equal width(%lu) (full image) for %s.
region.size.height(%lu) must equal height(%lu) (full image) for %s.
region.size.depth(%lu) must equal depth(%lu) (full image) for %s.
buffer length for format %s must be at least %lu, but %lu was specified.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:]
format(%s) must be a color format.
-[MTLDebugBlitCommandEncoder fillTexture:level:slice:region:color:pixelFormat:]
format(%s) is not compatible with the texture format (%s).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:]
sliceCount must not be 0.
levelCount must not be 0.
sourceTexture.width(%lu) at mip %lu must match destinationTexture.width(%lu) at mip level %lu.
sourceTexture.height(%lu) at mip %lu must match destinationTexture.height(%lu) at mip level %lu.
sourceTexture.depth(%lu) at mip %lu must match destinationTexture.depth(%lu) at mip level %lu.
sourceLevel(%lu) + levelCount(%lu) must not exceed sourceTexture.mipmapLevelCount(%lu).
destinationLevel(%lu) + levelCount(%lu) must not exceed destinationTexture.mipmapLevelCount(%lu).
sourceSlice(%lu) + sliceCount(%lu) must not exceed sourceTexture.arrayLength(%lu) x sourceTexture.numFaces(%lu).
destinationSlice(%lu) + sliceCount(%lu) must not exceed destinationTexture.arrayLength(%lu) x destinationTexture.numFaces(%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:toTexture:]
-[MTLDebugBlitCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
Sample Counters In Buffer Validation
buffer must no be nil
Sample buffer is not a MTLCounterSampleBuffer.
Sample buffer is associated with a different device.
sampleIndex(%lu) must be < sampleCount(%lu).
MTLCounterSamplingPointAtBlitBoundary is not supported.
-[MTLDebugBlitCommandEncoder resolveCounters:inRange:destinationBuffer:destinationOffset:]
Resolve Counters Validation
MTLCounterSampleBuffer must be provided
Destination buffer is not a MTLBuffer.
Destination buffer is associated with a different device.
Destination offset (%llu) must be multiple of minimum constant buffer alignment (%llu).
NSMaxRange(range)(%lu) must be <= sampleCount(%lu).
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:]
Invalidate Compressed Texture Validation
-[MTLDebugBlitCommandEncoder invalidateCompressedTexture:slice:level:]
option is not a valid MTLBlitOption.
texture
Blit from %@ has protection options %016llx not set in command buffer protection options %016llx
Blit to %@ with protection options %016llx missing bits set in command buffer protection options %016llx
is illegal on a non-placement heap
is defined on a placement heap only when using a blit method copying entire texture surfaces, or when copying between buffers
is defined on a placement heap only when both textures have the same MTLTextureUsage flags
is defined on a placement heap only when both textures are linear and have the same bufferBytesPerRow value
is defined on a placement heap only when both top-level resources have the same layout
is defined on a placement heap when the texture views refer to the same sub-resources with the same texture type
top-level source and top-level destination resource dimensions must be identical when moving resources inside a placement heap
validateResourceAliasing
blitting between aliasing resources %s.
MTLBlitOptionNone
MTLBlitOptionDepthFromDepthStencil
MTLBlitOptionStencilFromDepthStencil
MTLBlitOptionRowLinearPVRTC
buffer
validateTextureRegion
region.size(%lu, %lu, %lu) must not be empty.
(region.origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(region.origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(region.origin.z + adjustedSize.depth)(%lu) must be <= paddedDepth(%lu).
region.origin.x(%lu) must be a multiple of %s blockWidth(%lu).
region.origin.y(%lu) must be a multiple of %s blockHeight(%lu).
region.origin.z(%lu) must be a multiple of %s blockDepth(%lu).
-[MTLDebugResourceStateCommandEncoder dealloc]
Command encoder released without endEncoding
-[MTLDebugResourceStateCommandEncoder validateSparseTextureMappingMode:]
Invalid mapping mode (%lu)
-[MTLDebugResourceStateCommandEncoder validateTextureAccess:region:mipLevel:slice:]
-[MTLDebugResourceStateCommandEncoder updateTextureMappings:mode:regions:mipLevels:slices:numRegions:]
Cannot update texture mapping: Encoder has ended encoding
Only sparse textures support mapping modifications.
mipLevels[%i](%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:region:mipLevel:slice:]
mipLevel(%lu) must be <= [texture firstMipmapInTail](%lu)
-[MTLDebugResourceStateCommandEncoder updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:]
-[MTLDebugResourceStateCommandEncoder moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
Resource State Encoder Validation
Only sparse textures (source) support mapping modifications.
Only sparse textures (destination) support mapping modifications.
The textures must have the same pixel format.
The source and destination texture must be created from the same heap.
destinationLevel(%lu) must be <= [destinationTexture firstMipmapInTail](%lu).
sourceLevel(%lu) must be <= [sourceTexture firstMipmapInTail](%lu).
-[MTLDebugResourceStateCommandEncoder waitForFence:]
-[MTLDebugResourceStateCommandEncoder endEncoding]
Can't end encoding for this encoder, already ended encoding
Ending encoding with no commands encoded.
-[MTLDebugBuffer makeAliasable]
This resource was not allocated on a heap.
-[MTLDebugBuffer newTextureWithDescriptor:offset:bytesPerRow:]
New Texture With Descriptor Validation
descriptor must not be nil.
descriptor is not a MTLTextureDescriptor.
resourceOptions (0x%lx) must match backing buffer resource options (0x%lx).
linear texture depth(%ld) must be 1
linear texture mipmapLevelCount(%ld) must be 1
linear texture sampleCount(%ld) must be 1
linear texture arrayLength(%ld) must be 1
compressionType must be set to lossless for linear textures
compressionFootprint must be set to lossless for linear textures
linear textures cannot be created with usage MTLTextureUsageRenderTarget
-[MTLDebugBuffer newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:]
Texture Descriptor Validation
2D linear texture array is not supported.
bytesPerImage must be aligned to %u bytes.
-[MTLDebugBuffer setPurgeableState:]
validateNewTexture
MTLTextureDescriptor.usage == MTLTextureUsageUnknown.
cannot create Memoryless texture from Buffer.
Textures with compressed pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with depth pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with stencil pixel formats cannot be created from a buffer and must be created as a standalone texture.
bytesPerRow(%lu) must be greater than (width * pixel_bytes)(%lu).
bytesPerRow must be non-zero.
Buffer-backed textures must have a texture type of MTLTextureType2D, MTLTextureTypeTextureBuffer or MTLTextureType2DArray, found %@.
Length required by texture offset, bytes per row, height and array length(%lu) exceed buffer capacity(%lu).
Offset of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found offset(%lu)
BytesPerRow of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found bytesPerRow(%lu)
-[MTLDebugDeadlineProfile validateCommandQueue:]
Deadline Profiles cannot be reused across command queues
-[MTLDebugCommandBuffer dealloc]
MTLCommandBuffer is in an invalid status when being destroyed; is it being over-released?
-[MTLDebugCommandBuffer encodeWaitForEvent:value:]
Standard MTLEvents must signal events on the same device. Use MTLSharedEvent for cross-device events.
-[MTLDebugCommandBuffer encodeWaitForEvent:value:timeout:]
-[MTLDebugCommandBuffer encodeSignalEvent:value:]
-[MTLDebugCommandBuffer waitUntilScheduled]
waitUntilScheduled on uncommitted command buffer
-[MTLDebugCommandBuffer waitUntilCompleted]
waitUntilCompleted on uncommitted command buffer
-[MTLDebugCommandBuffer blitCommandEncoder]
encoding in progress
-[MTLDebugCommandBuffer resourceStateCommandEncoder]
MSAA Resolve is only supported for color, depth, and stencil textures
MTLRenderPassDescriptor resolveTexture is associated with a different device
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1D.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType2DMultisample.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureTypeTextureBuffer.
MTLRenderPassDescriptor resolveTexture must not be Memoryless.
MTLRenderPassDescriptor texture and resolveTexture size mismatch.
PixelFormat %s cannot be a MSAA resolve target
Texture PixelFormat %s does not match Resolve PixelFormat %s
Slice is %lu, but the texture has only %lu slices
mipmap level is %lu, but the texture has only %lu levels
depth plane is %lu, but the texture has a depth of %lu at mip level %lu
resolveTexture sampleCount is %lu, but must be 1
resolveTexture must not be buffer-backed.
_MTLValidateDepthStencilStoreState
%@: mixing %@ and %@ store actions for the depth and stencil render pass attachments is not allowed.
MTLDebugRenderPipeline
MTLDebugRenderCommandEncoder
%@: the stencil attachment resolve filter mode (MTLMultisampleStencilResolveFilterDepthResolvedSample) is not valid because the depth attachment store action (%@) does not contain a resolve.
-[MTLDebugCommandBuffer addCompletedHandler:]
block cannot be nil
-[MTLDebugCommandBuffer addScheduledHandler:]
-[MTLDebugCommandBuffer unwrapMTLRenderPassDescriptor:]
colorAttachment[%lu].loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
depthAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
stencilAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
-[MTLDebugCommandBuffer renderCommandEncoderWithDescriptor:]
RenderCommandEncoder Validation
renderPassDescriptor must not be nil.
renderPassDescriptor is not a MTLRenderPassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoder]
-[MTLDebugCommandBuffer computeCommandEncoderWithDescriptor:]
ComputeCommandEncoder Validation
computePassDescriptor must not be nil.
computePassDescriptor is not a MTLComputePassDescriptor.
-[MTLDebugCommandBuffer blitCommandEncoderWithDescriptor:]
blitPassDescriptor must not be nil.
blitPassDescriptor is not a MTLBlitPassDescriptor.
-[MTLDebugCommandBuffer resourceStateCommandEncoderWithDescriptor:]
resourceStatePassDescriptor must not be nil.
resourceStatePassDescriptor is not a MTLResourceStatePassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoderWithDispatchType:]
-[MTLDebugCommandBuffer parallelRenderCommandEncoderWithDescriptor:]
ParallelRenderCommandEncoder Validation
-[MTLDebugCommandBuffer preCommit]
command buffer references deallocated object which previously existed at address %p.
-[MTLDebugCommandBuffer sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledRenderCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
SampledComputeCommandEncoder Validation
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer lockPurgeableObjects]
MTLResource %p (label: %@), referenced in cmd buffer %p (label: %@) is in volatile or empty purgeable state at commit
-[MTLDebugCommandBuffer accelerationStructureCommandEncoder]
-[MTLDebugCommandBuffer accelerationStructureCommandEncoderWithDescriptor:]
Acceleration Structure Command Encoder Validation
accelerationStructurePassDescriptor must not be nil.
accelerationStructurePassDescriptor is not a MTLAccelerationStructurePassDescriptor.
-[MTLDebugCommandBuffer encodeDashboardTagForResourceGroup:]
Streaming Codec SPI
resourceGroup must be non-nil
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:]
dashboard(%llu) is not a valid MTLDashboard value
-[MTLDebugCommandBuffer encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:]
-[MTLDebugCommandBuffer commitWithDeadline:]
%s SPI should only be used with Deadline Aware Command Buffers
MTLStoreActionDontCare
MTLStoreActionStore
MTLStoreActionMultisampleResolve
MTLStoreActionStoreAndMultisampleResolve
MTLStoreActionUnknown
validateRenderPassDescriptor
RenderPass Descriptor Validation
not a MTLDebugTexture.
Texture at colorAttachment[%lu] has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions at color attachment %i includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
Attachment %u overlaps with attachment %u
MTLRenderPassDescriptor render targets have inconsistent sample counts.
Mixing MTLTextureType3D with other attachment types is not allowed when renderTargetArrayLength is not zero
This set of render targets requires %lu bytes of pixel storage. This device supports %lu bytes.
Texture at depthAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on the depth attachment includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
This render pass descriptor's clear depth (%f) is outside of the range [0..1]
Texture at stencilAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
rasterizationRateMap must be an MTLRasterizationRateMap instance.
rasterizationRateMap.device must match the current device.
renderTargetWidth (%lu) must be <= rasterizationRateMap.screenSize.width (%lu).
renderTargetHeight (%lu) must be <= rasterizationRateMap.screenSize.height (%lu).
renderTargetArrayLength (%lu) must be <= rasterizationRateMap.layerCount (%lu).
maximum physical rendering width (%lu) must be <= minimum attachment width (%lu).
maximum physical rendering height (%lu) must be <= minimum attachment height (%lu).
renderTargetWidth (%lu) must be <= minimum attachment width (%lu).
renderTargetHeight (%lu) must be <= minimum attachment height (%lu).
No rendertargets set in RenderPassDescriptor.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's renderTarget{Width|Height} properties to nonzero values.
Sparse textures are not supported as depth attachments on this device
Sparse textures are not supported as stencil attachments on this device
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must have a combined depth+stencil pixel format.
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must be the same depth and stencil texture.
When depth and stencil are used together, the render pass has to write to the same level and slice for both.
When depth and stencil are used together, the resolve texture for the depth and stencil render pass attachments must be the same depth and stencil texture.
When both depth (%lu x %lu) and stencil (%lu x %lu) are used from separate textures, they must have identical dimensions.
defaultColorSampleCount (%lu) is not supported by device.
defaultRasterSampleCount (%lu) is not supported by device.
no sampleCount for color and raster available, either set defaultColorSampleCount or set defaultRasterSampleCount or set appropriate attachments
unexpected color and depth/stencil sample counts
defaultColorSampleCount should be zero.
No output textures defined for the render pass. Either set a texture to at least one render pass attachment, or use targetless rasterization by setting the render pass descriptor's defaultRasterSampleCount property to a nonzero value.
defaultRasterSampleCount should be zero.
Per sample storage cannot be greater than 64B
Per pixel storage cannot be greater than 256B
Total allocated thread group memory (%lu) cannot be greater than (%lu)
4X MSAA does not support 32 x 32 tiles
MTLRenderPassDescriptor visibilityResultBuffer is associated with a different device
%lu custom sample positions were programmed, but this render pass uses %lu rasterizer sample(s). These counts must match.
startOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfVertexSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
startOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfFragmentSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfFragmentSampleIndex must be MTLCounterDontSample
MTLRenderPassAttachmentDescriptor texture is associated with a different device
Memoryless attachment need to be Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
Memoryless attachment cannot be loaded as it have no memory to load from.
Memoryless attachment content cannot be stored in memory.
PixelFormat %s at color attachment %lu is not color renderable
PixelFormat %s is not depth renderable
PixelFormat %s is not stencil renderable
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1D.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureType1DArray.
MTLRenderPassAttachmentDescriptor texture must not be MTLTextureTypeTextureBuffer.
Slice is %lu, but the texture at attachment %lu has only %lu slices
mipmap level is %lu, but the texture at attachment %lu has only %lu levels
depth plane index is %lu, but the texture has a depth of %lu at mip level %lu
depth plane + renderTargetArrayLength is %lu, but the texture has a depth of %lu at mip level %lu.
slice + renderTargetArrayLength is %lu, but the texture only has %lu slices.
MTLRenderPassAttachmentDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassAttachmentDescriptor %s store action at attachment %lu requires resolve texture
MTLRenderPassAttachmentDescriptor %s depth resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor MTLMultisampleStencilResolveFilterDepthResolvedSample stencil resolve filter mode is not supported by device
MTLRenderPassAttachmentDescriptor texture at attachment %lu must not be buffer-backed.
MTLRenderPassAttachmentDescriptor resolveTexture must have storeAction of MTLStoreActionMultisampleResolve, MTLStoreActionStoreAndMultisampleResolve or MTLStoreActionUnknown
MTLRenderPassAttachmentDescriptor texture must be MTLTextureType2DMultisample or MTLTextureType2DMultisampleArray when using a resolveTexture.
texture sampleCount is %lu, but must be > 1 when using a resolveTexture
the depth attachment
the stencil attachment
color attachment %lu
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, but Programmable Sample Positions is not supported on this device.
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, which does not apply to the store action (%@).
MTLMultisampleDepthResolveFilterSample0
MTLMultisampleDepthResolveFilterMin
MTLMultisampleDepthResolveFilterMax
validateTileDimensions
Invalid tile dimensions (%lu, %lu)
startOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
endOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u) or MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfEncoderSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfEncoderSampleIndex must be MTLCounterDontSample
validateStoreLoadTransition
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. The results are undefined.
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. This is perfectly valid transition but it will result in reduced performance.
MTLLoadActionDontCare
MTLLoadActionLoad
MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES
-[MTLDebugDynamicLibrary serializeToURL:error:]
url must not be nil.
url must be a file URL.
-[MTLDebugDynamicLibrary serializeToURL:options:error:]
-[MTLDebugCounterSampleBuffer resolveCounterRange:]
NSMaxRange(indexRange)(%lu) must be <= sampleCount(%lu).
CPU access not allowed for sample buffers with MTLResourceStorageModePrivate.
-[MTLDebugBinaryArchive addComputePipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLComputePipelineDescriptor object.
descriptor.computeFunction must not be nil.
Linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLRenderPipelineDescriptor object.
Vertex linked functions cannot be added to this archive.
Fragment linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addMeshRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLMeshRenderPipelineDescriptor object.
Object linked functions cannot be added to this archive.
Mesh linked functions cannot be added to this archive.
-[MTLDebugBinaryArchive addTileRenderPipelineFunctionsWithDescriptor:options:error:]
device does not support tile shaders
descriptor is not a MTLTileRenderPipelineDescriptor object.
-[MTLDebugBinaryArchive serializeToURL:error:]
-[MTLDebugBinaryArchive serializeToURL:options:error:]
MTL_COUNTERS_LAYER_API_TIMING
-[MTLDebugCommandQueue insertDebugCaptureBoundary]
InsertDebugCaptureBoundary should not be called inside the completion handler
-[MTLDebugCommandQueue validateDeadlineAwareness:]
All commandBuffers from this commandQueue must have a deadlineProfile associated with it
Only MTLCommandQueues with MTLGPUPriorityRealTime can contain a deadline profile
-[MTLDebugComputeCommandEncoder dealloc]
computePipelineState =
<null>
Set Buffers:
Buffer %lu:
Set Textures:
Texture %lu:
Set Samplers:
Sampler %lu:
Set ThreadgroupMemoryLengths:
Threadgroup %lu:
Image Block Size: %lu x %lu
-[MTLDebugComputeCommandEncoder setComputePipelineState:]
computePipelineState must not be nil.
computePipelineState is not a MTLComputePipelineState.
computePipelineState is associated with a different device
redundant setComputePipelineState.
previous setComputePipelineState was unused.
-[MTLDebugComputeCommandEncoder setBytes:length:atIndex:]
length(%lu) must be <= %lu.
-[MTLDebugComputeCommandEncoder setBuffer:offset:atIndex:]
offset(%lu) must be < [buffer length](%lu).
offset(%lu) must be 0.
-[MTLDebugComputeCommandEncoder setBufferOffset:atIndex:]
index(%lu) must have an existing buffer.
-[MTLDebugComputeCommandEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an MTLBuffer.
buffers[%lu] is associated with a different device
offset[%lu](%lu) must be < [buffers[%lu] length](%lu).
offsets[%lu](%lu) must be 0.
-[MTLDebugComputeCommandEncoder setTexture:atIndex:]
frameBufferOnly texture not supported for compute.
Memoryless texture not supported for compute.
-[MTLDebugComputeCommandEncoder setTextures:withRange:]
textures[%lu] is not an MTLTexture.
textures[%lu] is associated with a different device
frameBufferOnly textures[%lu] not supported for compute.
textures[%lu] is Memoryless and cannot be assigned.
-[MTLDebugComputeCommandEncoder setSamplerState:atIndex:]
sampler is not a MTLSamplerState.
sampler is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerStates:withRange:]
samplers[%lu] is not an MTLSamplerState.
samplers[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugComputeCommandEncoder setSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugComputeCommandEncoder setThreadgroupMemoryLength:atIndex:]
length(%lu) must be a multiple of %lu bytes.
-[MTLDebugComputeCommandEncoder setImageblockWidth:height:]
width(%lu) must be a power of 2.
height(%lu) must be a power of 2.
width(%lu)*height(%lu) must be less than or equal to 1024
-[MTLDebugComputeCommandEncoder validateStageInRegion:]
stage_in region (width(%lu) * height(%lu) * depth(%lu))(%lu) must not be 0.
stage_in region (width)(%lu) must be <= width(%lu).
stage_in region (height)(%lu) must be <= height(%lu).
stage_in region (depth)(%lu) must be <= depth(%lu).
-[MTLDebugComputeCommandEncoder setStageInRegionWithIndirectBuffer:indirectBufferOffset:]
indirectBufferOffset (%lu) must be a multiple of 4
-[MTLDebugComputeCommandEncoder _validateThreadsPerThreadgroup:]
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must not be 0.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (device threadgroup size limit)
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (kernel threadgroup size limit)
threadsPerThreadgroup.width(%lu) must be <= %lu.
threadsPerThreadgroup.height(%lu) must be <= %lu.
threadsPerThreadgroup.depth(%lu) must be <= %lu.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be multiples of %lu.
-[MTLDebugComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:]
threadgroupsPerGrid.width(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.height(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadgroupsPerGrid.width(%lu) * threadgroupsPerGrid.y(%lu) * threadgroupsPerGrid.depth(%lu))(%lu) must not be 0.
Compute
stage_in region was not set for compute pipeline
-[MTLDebugComputeCommandEncoder dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:]
indirectBuffer must not be nil.
indirectBuffer is not a MTLBuffer.
indirectBuffer is associated with a different device
(indirectBufferOffset + sizeof(MTLDispatchThreadgroupsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
indirectBufferOffset(%lu) must be a multiple of 4 bytes.
-[MTLDebugComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:]
threadsPerGrid.width(%lu) must be <= UINT32_MAX.
threadsPerGrid.height(%lu) must be <= UINT32_MAX.
threadsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadsPerGrid.width(%lu) * threadsPerGrid.y(%lu) * threadsPerGrid.depth(%lu))(%lu) must not be 0.
-[MTLDebugComputeCommandEncoder dispatchThreadsWithIndirectBuffer:indirectBufferOffset:]
(indirectBufferOffset + sizeof(MTLDispatchThreadsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
-[MTLDebugComputeCommandEncoder waitForFence:]
-[MTLDebugComputeCommandEncoder endEncoding_private]
endEncoding without dispatchThreadgroups.
-[MTLDebugComputeCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
MTLVisibleFunctionTable
MTLIntersectionFunctionTable
-[MTLDebugComputeCommandEncoder useResource:usage:]
resource should not be nil
usage (0x%lx) has an invalid value
useResource:usage:
-[MTLDebugComputeCommandEncoder useResources:count:usage:]
resource (at index: %lu) should not be nil
useResources:count:usage: (index = %lu)
-[MTLDebugComputeCommandEncoder useHeap:]
heap should not be nil
-[MTLDebugComputeCommandEncoder useHeaps:count:]
heap (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder memoryBarrierWithScope:]
scope (0x%lx) has an invalid value for compute
compute memoryBarrierWithScope is not supported on this device
-[MTLDebugComputeCommandEncoder memoryBarrierWithResources:count:]
resources should not be nil or empty array
compute memoryBarrierWithResources is not supported on this device
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:withRange:]
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the compute pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugComputeCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDispatchBoundary is not supported.
-[MTLDebugComputeCommandEncoder setAccelerationStructure:atBufferIndex:]
Acceleration structure
-[MTLDebugComputeCommandEncoder setVisibleFunctionTable:atBufferIndex:]
functionTable is not a MTLVisibleFunctionTable.
functionTable is associated with a different device
-[MTLDebugComputeCommandEncoder setVisibleFunctionTables:withBufferRange:]
visibleFunctionTables[%lu] is not a MTLVisibleFunctionTable.
visibleFunctionTables[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTable:atBufferIndex:]
functionTable is not a MTLIntersectionFunctionTable.
-[MTLDebugComputeCommandEncoder setIntersectionFunctionTables:withBufferRange:]
intersectionFunctionTables[%lu] is not a MTLIntersectionFunctionTable.
intersectionFunctionTables[%lu] is associated with a different device
validateArg
unused binding in encoder at %s index %lu.
sampler
threadgroupMemory
visibleFunctionTable
primitiveAccelerationStructure
instanceAccelerationStructure
intersectionFunctionTable
MTLDebugFunctionArgumentInit
redundant setting of %@.
thread_position_in_grid
threads_per_grid
thread_position_in_threadgroup
thread_index_in_threadgroup
threads_per_threadgroup
threadgroup_position_in_grid
threadgroups_per_grid
validateBuiltinArguments
Invalid built-in argument %@
component %lu: %llu must be <= %llu for %@ [[ %@ ]]
validateComputeFunctionArguments
%@ Function(%@): missing %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu].
%@ Function(%@): the offset into the buffer %@ that is bound at %s index %lu must be a multiple of %lu but was set to %lu.
%@ Function(%@): argument %@[%lu] from %s(%lu) with offset(%lu) and length(%lu) has space for %lu bytes, but argument has a length(%lu).
%@ Function(%@): Read-only bytes are being bound at index %lu to a shader argument with write access enabled (did you mean to use const or constant in the shader?).
%@ Function(%@): Reading from buffer bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to buffer bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): threadgroupMemoryLength(%lu) must be >= %lu at %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect type of texture (%@) bound at %s binding at index %lu (expect %@) for %@[%lu].
%@ Function(%@): Non-writeable texture format %s is being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): A sparse texture is being bound at index %lu to a shader argument with write access enabled. Sparse textures do not support writes from shaders.
%@ Function(%@): The pixel format (%s) of the %s (name:%@) bound at index %lu is incompatible with the data type (%@) of the %s parameter (%@ [[%s(%lu)]]). %s is compatible with the data type(s) %@.
%@ Function(%@): reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
%@ Function(%@): Shader uses texture(%@[%lu]) as read-write, but hardware does not support read-write texture of this pixel format.
%@ Function(%@): Reading from texture bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to texture bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu] - found %@.
Functon(%@): total used threadgroupMemoryLength(%lu) must be <= %lu.
validateTableStage
%@ called with a %s resource created for stage %@ rather than Compute
checkBuffer
%@ is not an MTLBuffer.
%@ is associated with a different device
%@ offset (%lu) must be < %@ length (%lu).
%@ must not be nil
%@ offset (%lu) must be 0.
checkAccelerationStructure
%@ is not an MTLAccelerationStructure.
checkMotionParameter
Acceleration descriptor is using primitive motion blur which is not supported by the device.
Primitive motion start time (%f) must be before or at the same time with motion end time (%f)
primitiveDataBuffer
checkPrimitiveData
primitiveDataElementSize must be non-zero
primitiveDataElementSize (%lu) cannot be larger than primitiveDataStride (%lu)
primitiveDataBufferOffset (%lu) exceeds primitiveDataBuffer.length (%lu)
primitiveDataBuffer.length (%lu) is not large enough to contain %lu primitives with primitiveDataBufferOffset (%lu), primitiveDataStride (%lu), and primitiveDataElementSize (%lu).
primitiveDataBufferOffset requires 4 byte alignment, found offset %lu.
primitiveDataStride requires 4 byte alignment, found offset %lu.
checkAccelerationStructureDescriptorWithRefitOptions
Number of geometry descriptors (%lu) must be less than 2^30
Number of geometry descriptors (%lu) must be less than 2^24
All geometry descriptors in a primitive acceleration structure descriptor must be the same type
Geometry descriptor intersection function table offset (%lu) must be less than 2^24
vertex buffer
Vertex buffer offset (%lu) must be a multiple of %lu bytes
index buffer
Index buffer offset (%lu) must be a multiple of the index data type stride (%lu)
Number of indices to read (triangle count multiplied by 3) (%lu) times index stride (%lu) plus index buffer offset (%lu) must be less than or equal to index buffer length (%lu)
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) must be less than or equal to vertex buffer length (%lu)
Motion keyframe count (%lu) must match vertexBuffers count (%lu)
Vertex buffer offset (%lu) in keyframe data must be a multiple of %lu bytes
Number of vertices to read (triangle count multiplied by 3) (%lu) times vertex stride (%lu) plus vertex buffer offset (%lu) in keyframe data must be less than or equal to vertex buffer length (%lu)
Bounding box stride (%lu) must be at least %lu bytes
Bounding box stride (%lu) must be a multiple of %lu bytes
bounding box buffer
Bounding box buffer offset (%lu) must be a multiple of %lu bytes
Bounding box buffer size (%lu) must be at least the bounding box buffer offset (%lu) plus the bounding box stride (%lu) times the number of bounding boxes (%lu)
Motion keyframe count (%lu) must match boundingBoxBuffers count (%lu)
Geometry descriptor must be a MTLAccelerationStructureTriangleGeometryDescriptor, a MTLAccelerationStructureMotionTriangleGeometryDescriptor, a MTLAccelerationStructureBoundingBoxGeometryDescriptor or a MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor
Number of primitives (%lu) must be less than 2^30
Number of primitives (%lu) must be less than 2^28
Number of instances (%lu) must be less than 2^30
Number of instances (%lu) must be less than 2^24
Instance descriptor type (%lu) is not a valid MTLAccelerationStructureInstanceDescriptorType
Instance descriptor stride (%lu) must be at least %lu bytes
Instance descriptor stride (%lu) must be a multiple of %lu bytes
instance descriptor buffer
Instance descriptor buffer offset (%lu) must be a multiple of %lu bytes
Instance descriptor buffer size (%lu) must be at least the instance descriptor buffer offset (%lu) plus the instance descriptor stride (%lu) times the number of instances (%lu)
Instanced acceleration structure
Must have at least 1 instanced acceleration structure if instance count > 0
Acceleration structure descriptor must be a MTLPrimitiveAccelerationStructureDescriptor or a MTLInstanceAccelerationStructureDescriptor
Acceleration structure descriptor must not be nil
-[MTLDebugAccelerationStructureCommandEncoder buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:]
Cannot build acceleration structure because encoder has ended encoding
Scratch buffer
Acceleration structure size (%lu) must be at least %lu bytes
Scratch buffer size (%lu) must be at least scratch buffer offset (%lu) plus required scratch buffer size (%lu)
-[MTLDebugAccelerationStructureCommandEncoder validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:]
Cannot refit acceleration structure because encoder has ended encoding
No options specified on refit
Source acceleration structure
Destination acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder copyAccelerationStructure:toAccelerationStructure:]
Cannot copy acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:]
Cannot write compacted acceleration structure because encoder has ended encoding
Size buffer
-[MTLDebugAccelerationStructureCommandEncoder writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:]
sizeDataType must be MTLDataTypeUInt or MTLDataTypeULong
-[MTLDebugAccelerationStructureCommandEncoder copyAndCompactAccelerationStructure:toAccelerationStructure:]
Cannot copy and compact acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:]
Cannot write serialized acceleration structure size because encoder has ended encoding
The size buffer is not big enough to hold the size (64 bits required)
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:]
Cannot write deserialized acceleration structure size because encoder has ended encoding
Serialized acceleration structure buffer
-[MTLDebugAccelerationStructureCommandEncoder writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:]
Cannot write deserialized primitive acceleration structure sizes because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:]
serializePrimitiveAccelerationStructure validation
Cannot serialize acceleration structure because encoder has ended encoding
Buffer
-[MTLDebugAccelerationStructureCommandEncoder serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:]
serializeInstanceAccelerationStructure validation
Primitive acceleration structure
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:]
deserializePrimitiveAccelerationStructure validation
Cannot deserialize acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
deserializeInstanceAccelerationStructure validation
-[MTLDebugAccelerationStructureCommandEncoder deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:]
-[MTLDebugAccelerationStructureCommandEncoder serializeAccelerationStructure:toBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:]
Cannot write geometry size of acceleration structure because encoder has ended encoding
-[MTLDebugAccelerationStructureCommandEncoder writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:]
Cannot write geometry of acceleration structure because encoder has ended encoding
Geometry buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:into:]
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:into:]
Header buffer
Inner node buffer
Leaf node buffer
Primitive buffer
Instance transform buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:]
Sizes buffer
-[MTLDebugAccelerationStructureCommandEncoder writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:]
-[MTLDebugAccelerationStructureCommandEncoder writeAccelerationStructureSerializationData:toBuffer:offset:]
Output buffer
MTLAccelerationStructureSerializationData exceeds end of buffer from offset (%lu) with length (%lu).
Buffer requires 4 byte alignment, found offset %lu.
validateVertexFormatAndStride
Single component vertex formats are not supported
Vertex stride (%lu) must be at least %lu bytes
Vertex stride (%lu) must be a multiple of %lu bytes
Transformation buffer
validateTransformationBuffer
MTLPackedFloat4x3 exceeds end of transformation buffer from offset (%lu) with length (%lu).
Transformation buffer requires 4 byte alignment, found offset %lu.
None
Vertex
Fragment
Tile
Object
Mesh
-[MTLDebugComputePipelineState functionHandleWithFunction:]
function must not be nil.
function is not a MTLFunction.
-[MTLDebugComputePipelineState newComputePipelineStateWithAdditionalBinaryFunctions:error:]
Pipeline state is adding functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding functions which is not supported by the device
Function '%s' was found in functions array but is not precompiled.
Unable to create new compute pipeline state with additional binary functions: %@
-[MTLDebugComputePipelineState newVisibleFunctionTableWithDescriptor:]
descriptor is not a MTLVisibleFunctionTableDescriptor.
-[MTLDebugComputePipelineState newIntersectionFunctionTableWithDescriptor:]
descriptor is not a MTLIntersectionFunctionTableDescriptor.
-[MTLDebugComputePipelineState validateHandleForSetFunction:]
The function handle for function '%s' was not created from the pipeline state that created this MTLVisibleFunctionTable.
-[MTLDebugIndirectCommandBuffer indirectRenderCommandAtIndex:]
Indirect Command Buffer Validation
CPU access for MTLIndirectCommandBuffer with MTLResourceStorageModePrivate storage mode is disallowed.
MTLIndirectCommandBuffer created without any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectRenderCommands 
The requested command (%lu) is greater than the indirect command buffer size (%lu)
-[MTLDebugIndirectCommandBuffer indirectComputeCommandAtIndex:]
MTLIndirectCommandBuffer created with any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectComputeCommands 
-[MTLDebugIndirectCommandBuffer setPurgeableState:]
-[MTLDebugIndirectCommandBuffer resetWithRange:]
MTL_XML_DUMP_COUNTERS
MTL_XML_SYNC_BEFORE_SAMPLE
MTL_XML_TRACE_PATH
xml_trace_%p
Error creating directory '%@' (%@)
MTL_XML_COUNTER_NAMES
MTLStat_nSec
Unsupported counter: %@
Failed to request counters
Index %u does not match any member of the argument buffer
Index %u does not correspond to any valid member of the argument buffer
Trying to set a %@ at index %u but the argument buffer has a %@ at this index
index range (%lu, %lu) has indices that are outside of the valid index range [%u, %u]
index (%lu) is outside of the valid index range [%u, %u]
-[MTLDebugArgumentEncoder setArgumentBuffer:startOffset:elementIndex:]
Argument Buffer Validation
buffer is not a MTLBuffer
buffer storage mode (%@) should be MTLStorageModeShared
offset (%lu) + encodedLength (%lu) should be smaller or equal to the buffer length (%lu)
-[MTLDebugArgumentEncoder setBuffer:offset:atIndex:]
No argument buffer is set
buffer is not a valid MTLBuffer
offset (%lu) should be smaller than the buffer length (%lu)
offset(%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setBuffers:offsets:withRange:]
buffers[%lu] is not an valid MTLBuffer.
offsets[%lu](%lu) must be 0 when buffer is nil.
-[MTLDebugArgumentEncoder setTexture:atIndex:]
-[MTLDebugArgumentEncoder setTextures:withRange:]
-[MTLDebugArgumentEncoder setSamplerState:atIndex:]
Sampler state did not have supportArgumentBuffers flag set on creation, but is used with argument buffers
-[MTLDebugArgumentEncoder setSamplerStates:withRange:]
-[MTLDebugArgumentEncoder constantDataAtIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineState:atIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineStates:withRange:]
-[MTLDebugArgumentEncoder setComputePipelineState:atIndex:]
-[MTLDebugArgumentEncoder setComputePipelineStates:withRange:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffer:atIndex:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffers:withRange:]
-[MTLDebugArgumentEncoder newArgumentEncoderForBufferAtIndex:]
No argument buffer at that index
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atBufferIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withBufferRange:]
-[MTLDebugArgumentEncoder setVisibleFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setVisibleFunctionTables:withRange:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTable:atIndex:]
-[MTLDebugArgumentEncoder setIntersectionFunctionTables:withRange:]
Constant
Texture
Sampler
Struct
RenderPipelineState
ComputePipelineState
IndirectCommandBuffer
VisibleFunctionTable
IntersectionFunctionTable
PrimitiveAccelerationStructure
InstanceAccelerationStructure
METAL_COMPLAIN_ABOUT_SLOPPY_TEXTURE_USAGE
MTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS
MTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS
-[MTLDebugDevice heapTextureSizeAndAlignWithDescriptor:]
-[MTLDebugDevice newHeapWithDescriptor:]
New Heap With Descriptor Validation
Sparse heaps are not supported on this device
Heap needs to have a size.
Requested storage mode is not allowed for Heaps.
Requested CPU cache mode is not allowed for Heaps.
Requested hazard tracking mode is not allowed for Heaps.
Storage mode must be MTLStorageModePrivate for heap type MTLHeapTypeSparse
Memoryless texture need to have renderable PixelFormat.
Memoryless texture need to be of type Texture2D, Texture2DMultisample, Texture2DArray or Texture2DMultisampleArray.
options 0x%lx conveys invalid cpuCacheMode of 0x%lx
IOSurface textures must use MTLStorageModeShared
MTLStorageModeShared not allowed for textures
MTLStorageModeMemoryless can only be used with textures
MTLStorageModeMemoryless is not supported on this device
Illegal MTLStorageMode 0x%lx
options 0x%lx conveys invalid hazardTrackingMode of 0x%lx
MTLResourceOptions options has unknown bits 0x%lx.
Cannot create buffer of zero length.
newBufferWith*:length 0x%lx must not exceed %llu MB.
-[MTLDebugDevice newBufferWithLength:options:]
Buffer Validation
-[MTLDebugDevice newBufferWithBytes:length:options:]
storageModePrivate incompatible with ...WithBytes variant of newBuffer
newBufferWithBytes:pointer must not be nil.
-[MTLDebugDevice newBufferWithBytesNoCopy:length:options:deallocator:]
storageModePrivate incompatible with ...WithBytesNoCopy variant of newBuffer
newBufferWithBytesNoCopy:pointer must not be nil.
newBufferWithBytesNoCopy:pointer %p is not %d byte aligned.
newBufferWithBytesNoCopy:length 0x%lx is not %d byte aligned.
-[MTLDebugDevice newBufferWithDescriptor:]
MTLResourceStorageModeShared should be used with noCopy=YES or contents being set
contents must not be nil when noCopy is set to YES
MTLBufferDescriptor.contents %p is not %d byte aligned.
MTLBufferDescriptor.length 0x%lx is not multiple of %d.
-[MTLDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
maximum vertex buffer bind count (%lu) must be <= %lu.
maximum fragment buffer bind count (%lu) must be <= %lu.
maximum kernel buffer bind count (%lu) must be <= %lu.
-[MTLDebugDevice newArgumentEncoderWithArguments:]
arguments cannot be nil
arguments must have at least one element
-[MTLDebugDevice newTextureWithBytesNoCopy:length:descriptor:deallocator:]
MTLResourceStorageModeShared must be used.
newTextureWithBytesNoCopy:pointer must not be nil.
newTextureWithBytesNoCopy:pointer %p is not %d byte aligned.
-[MTLDebugDevice newDepthStencilStateWithDescriptor:]
descriptor is not a MTLDepthStencilDescriptor.
texture buffer width (%llu) must be less than %llu
texture buffer height (%llu) must be 1
texture buffer depth (%llu) must be 1
texture buffer mipmapLevelCount (%llu) must be 1
texture buffer sampleCount (%llu) must be 1
texture buffer arrayLength (%llu) must be 1
usage must be set
MTLTextureUsageRenderTarget is not valid for a texture buffer
Texture buffer usage must contain read or write
texture buffer with pixel format (%s) cannot be written to from a shader
pixel format (%s) cannot be written to from a shader on this device
pixel format (%s) cannot be used for a texture buffer
-[MTLDebugDevice newTextureWithDescriptor:]
Cannot use an Xn format when creating a new texture
-[MTLDebugDevice newSamplerStateWithDescriptor:]
descriptor is not a MTLSamplerDescriptor.
-[MTLDebugDevice newBinaryArchiveWithDescriptor:error:]
Binary Archive with Descriptor Validation
descriptor is not a MTLBinaryArchiveDescriptor object.
url, if not nil, must be a file URL.
-[MTLDebugDevice newBinaryLibraryWithOptions:url:error:]
-[MTLDebugDevice newDynamicLibraryWithURL:options:error:]
Dynamic Library with URL Validation
device does not support dynamic libraries
-[MTLDebugDevice newDynamicLibrary:computeDescriptor:error:]
Dynamic Library Validation
library must not be nil.
library is not a MTLLibrary object.
-[MTLDebugDevice newDynamicLibrary:error:]
-[MTLDebugDevice loadDynamicLibrariesForComputeDescriptor:options:error:]
-[MTLDebugDevice loadDynamicLibrariesForFunction:insertLibraries:options:error:]
insertLibaries must not be nil.
-[MTLDebugDevice validateDynamicLibrary:state:error:]
-[MTLDebugDevice validateDynamicLibraryURL:error:]
Pipeline descriptor is using MTLLinkedFunctions functions which is not supported by the device.
Function '%s' in group '%s' was not found in functions array.
Pipeline descriptor is using MTLLinkedFunctions groups which is not supported by the device.
Pipeline descriptor is using MTLLinkedFunctions %@ which is not supported by the device.
Function '%s' was found in %@ array but is not precompiled.
functions
privateFunctions
binaryFunctions
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:reflection:error:]
Render Pipeline State Descriptor Validation
descriptor is not a MTLRenderPipelineDescriptor.
vertexPreloadedLibraries is not empty but device does not support render dynamic libraries
fragmentPreloadedLibraries is not empty but device does not support render dynamic libraries
objectPreloadedLibraries is not empty but device does not support render dynamic libraries
meshPreloadedLibraries is not empty but device does not support render dynamic libraries
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:reflection:error:]
Compute Pipeline State Descriptor Validation
descriptor is not a MTLComputePipelineDescriptor.
preloadedLibraries is not empty but device does not support dynamic libraries
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:reflection:error:]
Tile Render Pipeline State Descriptor Validation
descriptor is not a MTLTileRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:reflection:error:]
Mesh Pipeline State Descriptor Validation
descriptor is not a MTLMeshRenderPipelineDescriptor.
device does not support mesh shaders.
-[MTLDebugDevice _newRenderPipelineStateWithMeshDescriptor:options:completionHandler:]
-[MTLDebugDevice newLibraryWithFile:error:]
filepath must not be nil.
filepath is not a NSString.
-[MTLDebugDevice newLibraryWithURL:error:]
url is not a NSURL.
Invalid file url
-[MTLDebugDevice newLibraryWithSource:options:error:]
Library with Source Validation
options is not a MTLCompileOptions.
options.libraries contains an object that is not a MTLDynamicLibrary at index %lu.
source must not be nil.
source is not a NSString.
-[MTLDebugDevice newLibraryWithSource:options:completionHandler:]
-[MTLDebugDevice newLibraryWithData:error:]
data must not be nil.
-[MTLDebugDevice newPipelineLibraryWithFilePath:error:]
-[MTLDebugDevice newTextureWithDescriptor:iosurface:plane:]
iosurface must not be nil.
-[MTLDebugDevice newBufferWithIOSurface:]
-[MTLDebugDevice minLinearTextureAlignmentForPixelFormat:]
minLinearTextureAlignment Validation
%s is not supported on this device.
Linear textures do not support compressed pixel formats
Linear textures do not support depth/stencil pixel formats
-[MTLDebugDevice minimumLinearTextureAlignmentForPixelFormat:]
-[MTLDebugDevice newCounterSampleBufferWithDescriptor:error:]
MTLCounterSampleBufferDescriptor must be provided
descriptor is not a MTLCounterSampleBufferDescriptor.
-[MTLDebugDevice newLateEvalEvent]
Event Creation Validation
Late Eval Events not supported on this device
-[MTLDebugDevice newFence]
Attempt to create new fence over the fence instance limit (%lu).
The following Metal object is being destroyed while still required to be alive by the command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
The following Metal object has been over-released by the application and is being destroyed while still retained by command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
-[MTLDebugDevice notifyExternalReferencesNonZeroOnDealloc:]
<no label set>
-[MTLDebugDevice validateRaytracing]
device does not support ray tracing
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:]
buffer offset (%lu) must be < buffer length (%lu).
-[MTLDebugDevice newAccelerationStructureWithBuffer:offset:resourceIndex:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:]
-[MTLDebugDevice deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:]
accelerationStructure must not be nil.
-[MTLDebugDevice deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:]
-[MTLDebugDevice newVisibleFunctionTableWithDescriptor:]
-[MTLDebugDevice newIntersectionFunctionTableWithDescriptor:]
-[MTLDebugDevice newIOHandleWithURL:error:]
New IO Handle Validation
Invalid file url.
-[MTLDebugDevice newIOHandleWithURL:compressionType:error:]
compressionType must be one of MTLIOCompressionTypeZlib, MTLIOCompressionTypeLZFSE, MTLIOCompressionTypeLZ4, MTLIOCompressionTypeLZMA, or MTLIOCompressionTypeLZBitmap.
-[MTLDebugDevice newUncachedIOHandleWithURL:error:]
-[MTLDebugDevice newUncachedIOHandleWithURL:compressionType:error:]
-[MTLDebugDevice newIOCommandQueueWithDescriptor:error:]
New IO Command Queue Validation
descriptor is not a MTLIOCommandQueueDescriptor
descriptor.priority must be one of MTLIOPriorityHigh, MTLIOPriorityNormal, or MTLIOPriorityLow.
descriptor.type must be one of MTLIOCommandQueueTypeConcurrent, or MTLIOCommandQueueTypeSerial.
descriptor.scratchBufferAllocator is not a MTLIOScratchBufferAllocator.
MTLDebugShaders
simple_vertex
_validateRasterizationRateMapLayers
RasterizationRateMap Layers Validation
device must support variable rasterization rate feature.
screenSize.width (%lu) must be >0 and <=%lu.
screenSize.height (%lu) must be >0 and <=%lu.
layerCount (%lu) must be >0 and <=%lu.
layers must not be nil.
layers[%lu] must not be nil.
layers[%lu] must be a MTLRasterizationRateLayerDescriptor instance.
fill_checkboard_fragment
threadgroupMemoryLength
functionTable
accelerationStructure
buffer =
bufferOffset =
texture =
baseLevel =
sampler =
lodMinClamp =
lodMaxClamp =
threadgroupMemoryLength =
newArgumentEncoder
Function %@ does not have a buffer argument with buffer index %lu
Buffer argument %@ (buffer index: %lu) of function %@ is not an indirect argument buffer. If %@ is expected to be an argument buffer, this could be a shader bug. Argument buffers can be distinguished from regular buffers if they contain buffers, textures, samplers, or any element with the [[id]] attribute
-[MTLDebugLibrary newFunctionWithName:]
name is not a NSString.
validateNewFunctionWithConstantArguments
functionName is not a NSString.
constantValues must not be nil.
-[MTLDebugLibrary validateDescriptor:expectedClass:]
descriptor is not a %@.
Requesting binary compilation which is not supported by the device - supportsFunctionPointers = NO.
All linked functions must have unique names. Function '%s' is a duplicate symbol in %s, symbol first found in %s.
_validateUniqueNames
-[MTLDebugParallelRenderCommandEncoder setColorStoreAction:atIndex:]
attachmentIndex(%lu) must be < %lu
-[MTLDebugParallelRenderCommandEncoder setColorStoreActionOptions:atIndex:]
-[MTLDebugParallelRenderCommandEncoder endEncoding_private]
endEncoding called with store action for color attachment index %u still set to MTLStoreActionUnknown
endEncoding called with store action for depth attachment still set to MTLStoreActionUnknown
endEncoding called with store action for stencil attachment still set to MTLStoreActionUnknown
endEncoding called with store action unsupported for Memoryless attachment.
-[MTLDebugParallelRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
filterCounterRangeWithFirstBatch should not be called on ParallelRenderCommandEncoders
%s must not be nil.
%s is not a MTLBuffer.
%s is associated with a different device
%sOffset(%lu) + (indexCount(%lu) * %lu) must be <= [%s length](%lu).
indexCount(%lu) must be non-zero.
%sOffset(%lu) must be a multiple of %lu bytes.
_MTLDebugValidatePatchIndexBuffer
Patch Index Buffer Validation
%sOffset(%lu) + (patchIndicesUsed(%lu) * %lu) must be <= [%s length](%lu).
patchCount(%lu) must be non-zero.
instanceCount(%lu) must be non-zero.
%sOffset(%lu) must be 0.
v24@?0@"<MTLRenderCommandEncoderSPI>"8Q16
-[MTLDebugRenderCommandEncoder _init]_block_invoke
Exceeded HW limit of resources used by render encoder working in Memoryless mode.
Exceeded HW limit of scissor rectangles for render encoder working in Memoryless mode.
Exceeded HW limit of depth biases for render encoder working in Memoryless mode.
Internal error preventing the usage of memoryless for this render encoder.
-[MTLDebugRenderCommandEncoder dealloc]
descriptor =
viewportCount =
viewports:
Viewport %lu:
frontFacingWinding =
cullMode =
depthClipMode =
lineWidth =
depthBias =
depthBiasSlopeScale =
depthBiasClamp =
scissorRectCount =
scissorRects:
Scissor %lu:
amplificationMode =
amplificationValue =
vertexAmplificationCount =
triangleFillMode =
renderPipelineState =
depthStencilState =
frontStencilRef =
0x%x
backStencilRef =
visibilityResultMode =
visibilityResultOffset =
Blend Color =
%g %g %g %g
Set Vertex Buffers:
Set Vertex Textures:
Set Vertex Samplers:
Set Fragment Buffers:
Set Fragment Textures:
Set Fragment Samplers:
Set Tile Buffers:
Set Tile Textures:
Set Tile Samplers:
Set Tessellation Factor Buffer =
tessellationFactorBufferInstanceStride =
tessellationFactorScale =
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState colorSampleCount (%lu).
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For color attachment %d, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For color attachment %d, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For depth attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For depth attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For stencil attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For stencil attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
The color sample count (%lu) does not match the renderPipelineState's color sample count (%lu)
The raster sample count (%lu) does not match the renderPipelineState's raster sample count (%lu)
Device does not support separable raster/color shading rates
The sample count (%lu) does not match the renderPipelineState's sample count (%lu)
-[MTLDebugRenderCommandEncoder setRenderPipelineState:]
Set Render Pipeline State Validation
renderPipelineState must not be nil.
redundant setRenderPipelineState.
previous setRenderPipelineState was unused.
renderPipelineState is not a MTLRenderPipelineState.
renderPipelineState is associated with a different device
the pipelineState's per sample imageBlock usage(%lu) is greater than the encoder's perSample imageBlock usage(%lu)
The threadgroup memory consumed must be <= (%lu)
-[MTLDebugRenderCommandEncoder setVertexBytes:length:atIndex:]
Set Vertex Bytes Validation
-[MTLDebugRenderCommandEncoder setVertexBuffer:offset:atIndex:]
Set Vertex Buffer Validation
-[MTLDebugRenderCommandEncoder setVertexBufferOffset:atIndex:]
Set Vertex Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setVertexBuffers:offsets:withRange:]
Set Vertex Buffers Offset Validation
-[MTLDebugRenderCommandEncoder setVertexTexture:atIndex:]
Set Vertex Texture Validation
texture is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexTextures:withRange:]
Set Vertex Textures Validation
textures[%lu] is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexSamplerState:atIndex:]
Set Vertex Sampler State Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:withRange:]
Set Vertex Sampler States Validation
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentBytes:length:atIndex:]
Set Fragment Bytes Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBufferOffset:atIndex:]
Set Fragment Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setFragmentBuffers:offsets:withRange:]
Set Fragment Buffers Validation
-[MTLDebugRenderCommandEncoder setFragmentTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentTextures:withRange:]
Set Fragment Textures Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:atIndex:]
Set Fragment Sampler State Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:withRange:]
Set Fragment Sampler States Validation
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:]
textureIndex(%lu) must be < %lu.
samplerIndex(%lu) must be < %lu.
-[MTLDebugRenderCommandEncoder setTileBytes:length:atIndex:]
Set Tile Bytes Validation
-[MTLDebugRenderCommandEncoder setTileBuffer:offset:atIndex:]
Set Tile Buffer Validation
-[MTLDebugRenderCommandEncoder setTileBufferOffset:atIndex:]
Set Tile Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setTileBuffers:offsets:withRange:]
Set Tile Buffers Validation
-[MTLDebugRenderCommandEncoder setTileTexture:atIndex:]
Set Tile Texture Validation
-[MTLDebugRenderCommandEncoder setTileTextures:withRange:]
Set Tile Textures Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:atIndex:]
Set Tile Sampler State Validation
-[MTLDebugRenderCommandEncoder setTileSamplerStates:withRange:]
Set Tile Sampler States Validation
-[MTLDebugRenderCommandEncoder setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder _dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:]
Dispatch Threads Per Tile Validation
the renderPipelineState was not created with a tileDescriptor
threadsPerTile (%lu, %lu) must equal tile size (%lu, %lu) when threadgroupSizeMatchesTileSize is true
threadsPerTile.width(%lu) and threadsPerTile.height(%lu) must match the tile size or threadsPerTile.width(%lu) must be equal to threadsPerTile.height(%lu)
roundup2(threadsPerTile.width(%lu)) * roundup2(threadsPerTile.height(%lu)) * threadsPerTile.depth(%lu) must be <= %lu, both width and height are rounded up to nearest even number 
tile shader input image-block layout must match the previous state's image-block layout
threadsPerTile.width(%lu) * threadsPerTile.height(%lu) * threadsPerTile.depth(%lu) must not be 0
threadsPerTile.width(%lu) must be <= %lu
threadsPerTile.depth(%lu) must be 1
-[MTLDebugRenderCommandEncoder setThreadgroupMemoryLength:offset:atIndex:]
Set Threadgroup Memory Length Validation
A dispatch is required to reinterpret threadgroup memory.
offset + length(%lu) must be <= threadgroupMemoryLength(%lu).
offset(%lu) must be a multiple of %lu bytes.
-[MTLDebugRenderCommandEncoder useResource:usage:]
Use Resource Validation
-[MTLDebugRenderCommandEncoder useResource:usage:stages:]
stages (0x%lx) has an invalid stage
'stages' does not specify any render stages. Specify at least one stage.
useResource:usage:stages:
-[MTLDebugRenderCommandEncoder useResources:count:usage:]
Use Resources Validation
-[MTLDebugRenderCommandEncoder useResources:count:usage:stages:]
useResources:count:usage:stages: (index = %lu)
-[MTLDebugRenderCommandEncoder useHeap:]
-[MTLDebugRenderCommandEncoder useHeap:stages:]
Use Heap Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:]
Use Heaps Validation
-[MTLDebugRenderCommandEncoder useHeaps:count:stages:]
-[MTLDebugRenderCommandEncoder setViewport:]
Viewport Validation
redundant setViewport.
previous setViewport was unused.
-[MTLDebugRenderCommandEncoder setViewports:count:]
viewports parameter cannot be nullptr
viewport count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setFrontFacingWinding:]
Set Front Facing Winding Validation
redundant setFrontFacingWinding.
previous setFrontFacingWinding was unused.
-[MTLDebugRenderCommandEncoder setCullMode:]
Set Cull Mode Validation
redundant setCullMode.
previous setCullMode was unused.
-[MTLDebugRenderCommandEncoder setDepthClipMode:]
Set Depth Clip Mode Validation
redundant setDepthClipMode.
previous setDepthClipMode was unused.
-[MTLDebugRenderCommandEncoder setLineWidth:]
Set Line Width Validation
lineWidth(%g) must be between 1.0f and %.1ff
redundant setLineWidth.
previous setLineWidth was unused.
-[MTLDebugRenderCommandEncoder setDepthBias:slopeScale:clamp:]
Set Depth Bias Validation
redundant setDepthBias.
previous setDepthBias was unused.
-[MTLDebugRenderCommandEncoder setScissorRect:]
Set Scissor Rect Validation
redundant setScissorRect.
previous setScissorRect was unused.
-[MTLDebugRenderCommandEncoder setScissorRects:count:]
Set Scissor Rects Validation
scissorRects parameter cannot be nullptr
scissor rect count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setTransformFeedbackState:]
Set Transform Feedback State Validation
-[MTLDebugRenderCommandEncoder setVertexAmplificationMode:value:]
Set Vertex Amplification Mode Validation
vertexAmplificationMode is not a valid MTLVertexAmplificationMode.
the number of bits set to 1 in value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
value(%u) must be between (inclusive) 1 and the maximum amplification factor for the current device (%u)
redundant setVertexAmplificationMode.
previous setVertexAmplificationMode was unused.
-[MTLDebugRenderCommandEncoder setVertexAmplificationCount:viewMappings:]
invalid usage because device does not support vertex amplification.
count(%u) is not supported on this device. See supportsVertexAmplificationCount:(NSUInteger).
redundant setVertexAmplificationCount.
previous setVertexAmplificationCount was unused.
-[MTLDebugRenderCommandEncoder setTriangleFrontFillMode:backFillMode:]
Set Triangle Front Fill Mode Validation
-[MTLDebugRenderCommandEncoder setTriangleFillMode:]
Set Triangle Fill Mode Validation
redundant setTriangleFillMode.
previous setTriangleFillMode was unused.
-[MTLDebugRenderCommandEncoder setDepthStencilState:]
Set Depth Stencil State Validation
depthStencilState must not be nil.
depthStencilState is not a MTLDepthStencilState.
depthStencilState is associated with a different device
redundant setDepthStencilState.
previous setDepthStencilState was unused.
-[MTLDebugRenderCommandEncoder setStencilReferenceValue:]
Set Stencil Reference Value Validation
redundant setStencilReferenceValue.
previous setStencilReferenceValue was unused.
-[MTLDebugRenderCommandEncoder setStencilFrontReferenceValue:backReferenceValue:]
Set Stencil Front Reference Value Validation
_MTLDebugValidateDeferredStoreActionOnDevice
Deferred Store Action Validation
storeAction must not be MTLStoreActionUnknown
store actions known at render command encoder init time may not be mutated
storeAction unsupported for Memoryless attachment.
MTLRenderPassDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassDescriptor %s store action requires resolve texture
Store action for color attachment index %u must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for depth attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for stencil attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
-[MTLDebugRenderCommandEncoder setColorStoreAction:atIndex:]
Set Color Store Action Validation
deferred color store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreAction:]
deferred depth store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreAction:]
deferred stencil store actions cannot be set on sub render command encoders
_MTLDebugValidateDeferredStoreActionOptionsOnDevice
Deferred Store Action Options on Device Validation
-[MTLDebugRenderCommandEncoder setColorStoreActionOptions:atIndex:]
Set Color Store Action Options Validation
deferred color store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreActionOptions:]
deferred depth store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreActionOptions:]
deferred stencil store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setVisibilityResultMode:offset:]
Set Visibility Result Mode Validation
offset(%lu) must be a multiple of result-size(%u) bytes.
offset(%lu) must be <= %lu.
using the same offset (%lu) in the visibility buffer twice in the same command encoder is not allowed.
framebuffer visibilityResultBuffer must not be nil.
offset(%lu) + result-size(%u) must be <= [visibilityResultBuffer length](%lu).
redundant setVisibilityResultMode.
previous setVisibilityResultMode was unused.
-[MTLDebugRenderCommandEncoder setBlendColorRed:green:blue:alpha:]
Set Blend Color Validation
redundant setBlendColorRed.
previous setBlendColorRed was unused.
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:atIndex:]
Set Color Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:]
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:]
Set Depth Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setDepthResolveTexture:slice:depthPlane:level:yInvert:]
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:]
Set Stencil Resolve Texture Validation
-[MTLDebugRenderCommandEncoder setStencilResolveTexture:slice:depthPlane:level:yInvert:]
primitiveType is not a valid MTLPrimitiveType.
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:]
Draw Errors Validation
only triangles may be drawn when using a rasterization rate map.
renderPipelineState must be set.
renderPipelineState must be created using a MTLRenderPipelineDescriptor.
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassPoint but primitiveType is not MTLPrimitiveTypePoint
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassLine but primitiveType is neither MTLPrimitiveTypeLine nor MTLPrimitiveTypeLineStrip
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassTriangle but primitiveType is neither MTLPrimitiveTypeTriangle nor MTLPrimitiveTypeTriangleStrip
renderPipelineState is a mesh shader pipeline, which cannot be used for this draw command
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:]
The scissor rectangle count (%lu) should be equal to the viewport count (%lu) or should be 1.
input image-block layout must match the previous state image-block layout
the renderPipelineState has a vertex shader that writes to render_target_array_index but renderTargetArrayLength is set to zero
renderPipelineState is not a mesh shader pipeline
Vertex Amplification Count (%u) must be between (inclusive) 1 and the maximum vertex amplification count specified in the pipeline state (%u)
-[MTLDebugRenderCommandEncoder validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:]
Draw Primitives Validation
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:]
-[MTLDebugRenderCommandEncoder validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:]
Draw Indexed Primitives Validation
indexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
-[MTLDebugRenderCommandEncoder drawPrimitives:indirectBuffer:indirectBufferOffset:]
indirectBuffer
sizeof(MTLDrawPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawIndexedPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder setObjectBytes:length:atIndex:]
Set Object Bytes Validation
-[MTLDebugRenderCommandEncoder setObjectBuffer:offset:atIndex:]
Set Object Buffer Validation
-[MTLDebugRenderCommandEncoder setObjectBufferOffset:atIndex:]
Set Object Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setObjectBuffers:offsets:withRange:]
Set Object Buffers Validation
-[MTLDebugRenderCommandEncoder setObjectTexture:atIndex:]
Set Object Texture Validation
-[MTLDebugRenderCommandEncoder setObjectTextures:withRange:]
Set Object Textures Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:atIndex:]
Set Object Sampler State Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:withRange:]
Set Object Sampler States Validation
-[MTLDebugRenderCommandEncoder setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
Set Object Threadgroup Memory Length Validation
-[MTLDebugRenderCommandEncoder setObjectThreadgroupMemoryLength:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshBytes:length:atIndex:]
Set Mesh Bytes Validation
-[MTLDebugRenderCommandEncoder setMeshBuffer:offset:atIndex:]
Set Mesh Buffer Validation
-[MTLDebugRenderCommandEncoder setMeshBufferOffset:atIndex:]
Set Mesh Buffer Offset Validation
-[MTLDebugRenderCommandEncoder setMeshBuffers:offsets:withRange:]
Set Mesh Buffers Validation
-[MTLDebugRenderCommandEncoder setMeshTexture:atIndex:]
Set Mesh Texture Validation
-[MTLDebugRenderCommandEncoder setMeshTextures:withRange:]
Set Mesh Textures Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:atIndex:]
Set Mesh Sampler State Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:withRange:]
Set Mesh Sampler States Validation
-[MTLDebugRenderCommandEncoder setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
Draw Mesh Threadgroups With Indirect Buffer Validation
sizeof(MTLDispatchThreadgroupsIndirectArguments)
-[MTLDebugRenderCommandEncoder updateFence:afterStages:]
Cannot set the (MTLRenderStages)afterStages to 0. The parameter should be set to a valid MTLRenderStages value.
-[MTLDebugRenderCommandEncoder waitForFence:beforeStages:]
Cannot set the (MTLRenderStages)beforeStages to 0. The parameter should be set to a valid MTLRenderStages value.
Wait for Fence Validation
-[MTLDebugRenderCommandEncoder endEncoding_private]
End Encoding Validation
endEncoding without draw.
-[MTLDebugRenderCommandEncoder setTessellationFactorBuffer:offset:instanceStride:]
Set Tessellation Factor Buffer Validation
offset(%lu) must be a multiple of 4 bytes.
instanceStride(%lu) must be a multiple of 4 bytes.
-[MTLDebugRenderCommandEncoder setTessellationFactorScale:]
scale(%g) must be a normal floating point value (not denormal, infinite, nor NaN) and must be > 0.0f.
-[MTLDebugRenderCommandEncoder drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:]
patchIndexBuffer
-[MTLDebugRenderCommandEncoder drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
Draw Patches Validation
sizeof(MTLDrawPatchIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:]
Draw Indexed Patches Validation
controlPointIndexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugRenderCommandEncoder textureBarrier]
-textureBarrier is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithScope:afterStages:beforeStages:]
Memory Barrier With Scope Validation
render memoryBarrierWithScope is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithResources:count:afterStages:beforeStages:]
Memory Barrier With Resources Validation
render memoryBarrierWithResources is not supported on this device
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:withRange:]
Execute Commands In Buffer Validation
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the render pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDrawBoundary is not supported.
-[MTLDebugRenderCommandEncoder setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Table Validation
-[MTLDebugRenderCommandEncoder setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Visible Function Tables Validation
intersectionFunctionTable is associated with a different stage (%@, expected %@)
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Table Validation
intersectionFunctionTable is not a MTLIntersectionFunctionTable.
intersectionFunctionTable is associated with a different device
-[MTLDebugRenderCommandEncoder setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:]
Set Intersection Function Tables Validation
-[MTLDebugRenderCommandEncoder setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:]
Set Acceleration Structure Validation
indexType not valid MTLIndexType
%g %g %g %g %g %g
MTLWindingClockwise
MTLWindingCounterClockwise
MTLCullModeNone
MTLCullModeFront
MTLCullModeBack
MTLDepthClipModeClip
MTLDepthClipModeClamp
%lu %lu %lu %lu
MTLTriangleFillModeFill
MTLTriangleFillModeLines
MTLTriangleFillModePoint
MTLVisibilityResultModeDisabled
MTLVisibilityResultModeBoolean
MTLVisibilityResultModeCounting
local memory
%s must not be infinite or NaN.
viewport.originX
viewport.originY
viewport.width
viewport.height
viewport.znear
viewport.zfar
frontFacingWinding is not a valid MTLWinding.
cullMode is not a valid MTLCullMode.
depthClipMode is not a valid MTLDepthClipMode.
(rect.x(%lu) + rect.width(%lu))(%lu) must be <= render pass width(%lu)
(rect.y(%lu) + rect.height(%lu))(%lu) must be <= render pass height(%lu)
state(%u) is not a valid MTLTransformFeedbackState.
fillMode is not a valid MTLTriangleFillMode.
mode is not a valid MTLVisibilityResultMode.
%@ Function(%@): binding at index %lu is not a MTLDebugTexture.
%@ Function(%@): Shader reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): Shader writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
q24@?0@8@16
%@ Function(%@): there is an overlap with the threadgroupMemoryArgument at offset (%lu) and at offset(%lu).
validateDisjointRenderTargetsAndTexture
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also a %s attachment at index %lu. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and writeMask != MTLColorWriteMaskNone.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and depth writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and stencil writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is currently being written to in this render pass. This may be a conflict.
resolve
color
depth
stencil
vertex_id type is not big enough to draw this many vertices (%lu)
instance_id type is not big enough to draw this many instances (%lu)
missing vertexDescriptor %s binding at index %lu.
incorrect vertexDescriptor %s binding at index %lu.
MTLDepthStencilDescriptor sets depth test but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor has depthWriteEnabled but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor uses frontFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
MTLDepthStencilDescriptor uses backFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
%s requires a postTessellationVertexFunction but the vertexFunction of the renderPipelineState is not a postTessellationVertexFunction.
%s requires a normal vertexFunction but the vertexFunction of the renderPipelineState is a postTessellationVertexFunction.
(%sOffset + %s)(%lu) must be <= [%s length](%lu).
%sOffset(%lu) must be a multiple of 4 bytes.
validateCommonTessellationErrors
Common Tessellation Errors Validation
missing tessellationFactorBuffer binding.
numberOfPatchControlPoints(%lu) must match the number of control points(%ld) set in the vertexFunction of the renderPipelineState.
numberOfPatchControlPoints(%lu) must be <= 32.
for drawIndexedPatches numberOfPatchControlPoints(%lu) must not be 0.
for MTLTessellationFactorStepFunctionConstant and MTLTessellationFactorStepFunctionPerPatch tessellationFactorBufferInstanceStride(%lu) must be zero.
for MTLTessellationFactorStepFunctionPerInstance and MTLTessellationFactorStepFunctionPerPatchAndPerInstance tessellationFactorBufferInstanceStride(%lu) must be non-zero.
tessellationFactorBufferInstanceStride(%lu) must be a multiple of %lu bytes.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeNone not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt16 not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt32 not valid for %s.
tessellationFactorBuffer
%sOffset(%lu) + tessellationFactorBytesUsed(%lu) must be <= [%s length](%lu).
(patchStart + patchCount)(%lu) * %lu must be <= tessellationFactorBufferInstanceStride(%lu).
%@ called with stages (0x%lx), but %s resource was created for stage %@
MTL_XML_DUMP_EVENTS
MTLCommandBufferKernelStartTime
MTLCommandBufferKernelEndTime
MTLCommandBufferGPUStartTime
MTLCommandBufferGPUEndTime
-[MTLDebugResource doesAliasResource:]
Resource Validation
Input resource was not allocated on a heap.
-[MTLDebugResource doesAliasAllResources:count:]
Resources count cannot be zero.
resources must not be nil
Input resource %0lx was not allocated on a heap.
-[MTLDebugResource doesAliasAnyResources:count:]
v24@?0@"MTLStructType"8Q16
-[MTLDebugIndirectRenderCommand setVertexBuffer:offset:atIndex:]
Vertex Buffer Validation
-[MTLDebugIndirectRenderCommand setFragmentBuffer:offset:atIndex:]
Fragment Buffer Validation
-[MTLDebugIndirectRenderCommand drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
drawPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
drawIndexedPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setRenderPipelineState:]
Render Pipeline State Validation
-[MTLDebugIndirectRenderCommand drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawIndexedPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setObjectBuffer:offset:atIndex:]
Object Buffer Validation
index(%lu) must be < maxObjectBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setMeshBuffer:offset:atIndex:]
Mesh Buffer Validation
index(%lu) must be < maxMeshBufferBindCount(%lu).
-[MTLDebugIndirectRenderCommand setBarrier]
setBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand clearBarrier]
clearBarrier is not enabled on this indirect command buffer (requires DrawMeshThreadgroups or DrawMeshThreads)
-[MTLDebugIndirectRenderCommand drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreadgroups is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:]
drawMeshThreads is not enabled on this indirect command buffer
-[MTLDebugRenderPipelineState validateHandleForSetFunction:]
-[MTLDebugRenderPipelineState validateBinaryFunctions:stage:]
Pipeline state is adding %@ functions which is not supported by the device
Function '%s' was found in %@ functions array but is not precompiled.
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:]
Pipeline state is adding vertex functions but it was created with supportAddingVertexBinaryFunctions=NO
Pipeline state is adding fragment functions but it was created with supportAddingFragmentBinaryFunctions=NO
Unable to create new render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:]
Unable to create new tile render pipeline state with additional binary functions: %@
-[MTLDebugRenderPipelineState newRenderPipelineStateWithAdditionalBinaryFunctions:error:]
cannot specify both tile and render pipeline additional functions simultaneously.
Pipeline state is adding tile functions but it was created with supportAddingBinaryFunctions=NO
Pipeline state is adding object functions but it was created with supportAddingObjectBinaryFunctions=NO
Pipeline state is adding mesh functions but it was created with supportAddingMeshBinaryFunctions=NO
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:selector:]
-[MTLDebugRenderPipelineState newVisibleFunctionTableWithDescriptor:stage:]
stage invalid.
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:selector:]
-[MTLDebugRenderPipelineState functionHandleWithFunction:stage:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:withStage:selector:]
-[MTLDebugRenderPipelineState newIntersectionFunctionTableWithDescriptor:stage:]
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) cannot exceed maxTotalThreadsPer%sThreadgroup (%lu)
threadsPer%sThreadgroup (%lu x %lu x %lu = %lu) must be multiple of %sThreadExecutionWidth (%lu)
validateMTLSamplerDescriptor
Sampler Descriptor Validation
MTLSamplerDescriptor:non-normalized coords require MTLSamplerMipFilterNotMipmapped.
MTLSamplerDescriptor:non-normalized coords require MTLSamplerAddressModeClampToEdge, MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor.
MTLSamplerDescriptor:non-normalized coords require maxAnisotropy == 1.
MTLSamplerDescriptor:non-normalized coords require minFilter==magFilter of MTLSamplerMinMagFilterNearest or MTLSamplerMinMagFilterLinear, to be portable to all Metal devices.
MTLSamplerDescriptor's min filter value (%lu) is invalid.
MTLSamplerDescriptor's mag filter value (%lu) is invalid.
MTLSamplerDescriptor's mip filter value (%lu) is invalid.
MTLSamplerDescriptor's max anisotropy value (%lu) is invalid. Clamping to [%i, %i] range.
MTLSamplerDescriptor's S texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's T texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's R texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's texture coordinate address modes must either contain MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor modes but not both.
MTLSamplerDescriptor: pixelFormat(%s) must be MTLPixelFormatInvalid when supportsArgumentBuffers == YES
MTLSamplerAddressModeMirrorClampToEdge is not supported on this device
MTLSamplerAddressModeClampToHalfBorderColor is not supported on this device
Custom border colors are not supported on this device
%@ is not supported on this device
Exceeded the limit on number of unique samplers usable in argument buffers (which is %u)
Sparse textures cannot be created with dual-plane texture formats
The requested hazard tracking mode does not match the heap's mode
The requested CPU cache mode does not match the heap's mode
The requested storage mode is not compatible with the heap's mode
Shared textures created via heaps are not supported on this device
MTLResourceOptions options have unknown bits 0x%lx.
MTLTextureUsageShaderWrite is not supported for MTLHeapTypeSparse on this platform
-[MTLDebugHeap maxAvailableSizeWithAlignment:]
aligment needs to be power of two, or zero.
-[MTLDebugHeap newBufferWithLength:options:]
Requested length %lu must not exceed heap size %lu.
Cannot create buffer from sparse heap.
newBufferWithLength:options: cannot be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options:offset: instead.
-[MTLDebugHeap newTextureWithDescriptor:]
newTextureWithDescriptor: cannot be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor:offset: instead.
Sparse textures are not supported on this device
MTLHeapTypeSparse does not support MTLTextureType1D and MTLTextureType1DArray
MTLHeapTypeSparse does not support MTLTextureTypeTextureBuffer
MTLUnmappedDepthValueOne is only supported for MTLPixelFormatDepth32Float
-[MTLDebugHeap setPurgeableState:]
-[MTLDebugHeap validateOffset:withRequirements:]
Offset Validation
Cannot place resource at offset %lu extending beyond the heap size %lu (resource size %lu)
Cannot place resource at offset %lu which is not aligned to %lu bytes
-[MTLDebugHeap newBufferWithLength:options:offset:]
newBufferWithLength:options:offset: can only be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options: instead.
-[MTLDebugHeap newTextureWithDescriptor:offset:]
newTextureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor: instead.
-[MTLDebugHeap validateRaytracingHeap]
Heap must be MTLStorageModePrivate to allocate acceleration structures
-[MTLDebugHeap newAccelerationStructureWithSize:]
Cannot create acceleration structure of zero size.
Requested size %lu must not exceed heap size %lu.
-[MTLDebugHeap newAccelerationStructureWithSize:offset:]
newAccelerationStructureWithSize:offset can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize: instead.
-[MTLDebugHeap newAccelerationStructureWithDescriptor:offset:]
newAccelerationStructureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithDescriptor: instead.
-[MTLDebugHeap newAccelerationStructureWithSize:resourceIndex:]
-[MTLDebugHeap newAccelerationStructureWithSize:offset:resourceIndex:]
newAccelerationStructureWithSize:offset:resourceIndex can only be used when heap type is MTLHeapTypePlacement, use newAccelerationStructureWithSize:resourceIndex: instead.
-[MTLDebugTexture dealloc]
usageRequested 0x%lx != usageRequired 0x%lx
-[MTLDebugTexture makeAliasable]
Sparse textures cannot be made aliasable.
Memoryless textures cannot be made aliasable.
Texture Views created from Textures, that are backed by the Heap, cannot be made aliasable.
-[MTLDebugTexture setPurgeableState:]
Set Purgeable Stage Validation
_validateReplaceRegion
Replace Region Validation
(size.width(%lu) * size.height(%lu) * size.depth(%lu))(%lu) must not be 0.
CPU access for textures with MTLResourceStorageModePrivate storage mode is disallowed.
CPU access for textures with MTLStorageModeMemoryless is disallowed.
texture must not be a framebufferOnly texture.
mipmapLevel(%lu) must be < [texture mipmapLevelCount](%lu).
(origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(origin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(origin.x + size.width)(%lu) must be <= width(%lu).
(origin.y + size.height)(%lu) must be <= height(%lu).
(origin.z + size.depth)(%lu) must be <= depth(%lu).
origin.x(%lu) must be a multiple of %s blockWidth(%lu).
origin.y(%lu) must be a multiple of %s blockHeight(%lu).
origin.z(%lu) must be a multiple of %s blockDepth(%lu).
origin.x must be 0 (full image) for %s.
origin.y must be 0 (full image) for %s.
origin.z must be 0 (full image) for %s.
size.width(%lu) must equal width(%lu) (full image) for %s.
size.height(%lu) must equal height(%lu) (full image) for %s.
size.depth(%lu) must equal depth(%lu) (full image) for %s.
rowBytes must be 0 for %s.
imageBytes must be 0 for %s.
rowBytes(%lu) must be >= (%lu).
imageBytes(%lu) must be >= (%lu).
rowBytes(%lu) must be a multiple of %s %s bytes(%lu).
block
pixel
imageBytes(%lu) must be a multiple of %s %s bytes(%lu).
CPU access for this texture with pixel format %s is disallowed.
Replacing region on slice(%u) on mipmapLevel(%u) that is currently attached as a writeable render target.
_validateGetBytes
Get Bytes Validation
GetBytes Validation
_validateTextureView
Texture View Validation
cannot create View from Memoryless texture.
texture usage (0x%02lx) doesn't specify MTLTextureUsagePixelFormatView (0x%02lx)
invalid pixelFormat.
texture view creation not allowed from frameBufferOnly textures.
textureType %@ cannot be used for buffer-backed textures.
-[MTLDebugAccelerationStructure setPurgeableState:]
Intel
-[MTLDebugIOCommandBuffer internalValidateEvent:]
IO Command Buffer Event Validation
event must not be nil.
event is not a MTLSharedEvent.
event is associated with a different device.
-[MTLDebugIOCommandBuffer internalValidateLoadBuffer:offset:size:sourceHandle:sourceHandleOffset:]
Load Buffer From IO Handle Validation
buffer is associated with a different device.
sourceHandle must not be nil.
sourceHandle is not a MTLIOFileHandle.
sourceHandle is associated with a different device.
(offset + size)(%lu) must be <= [buffer length](%lu).
sourceHandleOffset(%lu) must be <= [sourceHandle length](%lu)
sourceHandleOffset(%lu) + size(%lu) must be <= [sourceHandle length](%lu)
-[MTLDebugIOCommandBuffer internalValidateLoadBytes:size:sourceHandle:sourceHandleOffset:]
Load Bytes From IO Handle Validation
-[MTLDebugIOCommandBuffer internalValidateLoadTexture:slice:level:size:sourceBytesPerRow:sourceBytesPerImage:destinationOrigin:sourceHandle:sourceHandleOffset:]
Load Texture From IO Handle Validation
texture is associated with a different device.
texture is Memoryless and cannot be used for load operations.
(destinationOrigin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + adjustedSize.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + size.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + size.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= depth(%lu).
3D compressed texture loading is not supported.
texture buffer loading is not supported.
-[MTLDebugIOCommandBuffer commit]
IO Command Buffer Commit Validation
committing an already committed io command buffer.
-[MTLDebugIOCommandBuffer tryCancel]
IO Command Buffer tryCancel Validation
trying to cancel an uncommitted io command buffer.
12StringBuffer
12AppendBuffer
12BinaryBuffer
(6TbF
 .8"B
a aaaaaaaaaaa#a&aaa),/258;>ADGJMPSV
BufferHeap::MemoryAllocated (MB) - %.2f
BufferHeap::MemoryUsed (MB) - %.2f/%.2f
DescriptorHeapSize (MB) - %.2f
DescriptorHeapNewHandle - %llu
ConstantBufferCache::TotalMemory - %llu
Device Alloc - %s, %p
Device Dealloc - %s, %p
Fatal failure when instrumenting %s "%s":
Function is not instrumented and faults will not be detected.
Partial failure when instrumenting %s "%s":%s%s
MTLDebugIndirectComputeCommand
MTLGPUDebugRenderCommandEncoder
MTLGPUDebugCommandEncoder
NSObject
MTLToolsIndirectCommandBuffer
MTLIndirectCommandBufferSPI
MTLIndirectCommandBuffer
MTLResource
MTLGPUDebugGPULog
MTLFunctionLog
MTLGPUDebugBufferErrorLog
MTLGPUDebugTextureErrorLog
MTLGPUDebugStackOverflowErrorLog
MTLGPUDebugTrapErrorLog
MTLToolsBlitCommandEncoder
MTLBlitCommandEncoderSPI
MTLCommandEncoderSPI
MTLCommandEncoder
MTLBlitCommandEncoder
MTLToolsFence
MTLFenceSPI
MTLFence
MTLCountersRenderCommandEncoder
MTLToolsCounterSampleBuffer
MTLCounterSampleBuffer
MTLGPUDebugLibrary
MTLToolsBuffer
MTLBufferSPI
MTLResourceSPI
MTLBuffer
MTLToolsCommandBuffer
MTLCommandBufferSPI
MTLCommandBuffer
MTLToolsRetainingContainer
MTLToolsCommandEncoder
MTLToolsPerfCounterMailbox
MTLToolsCommandQueue
MTLCommandQueueSPI
MTLCommandQueue
MTLDebugVisibleFunctionTable
MTLDebugResourcePurgeable
MTLToolsDynamicLibrary
MTLDynamicLibrarySPI
MTLDynamicLibrary
MTLToolsBinaryArchive
MTLBinaryArchiveSPI
MTLBinaryArchive
MTLToolsHeap
MTLHeapSPI
MTLHeap
MTLToolsComputeCommandEncoder
MTLComputeCommandEncoderSPI
MTLComputeCommandEncoder
MTLGPUDebugImageData
MTLToolsAccelerationStructureCommandEncoder
MTLAccelerationStructureCommandEncoderSPI
MTLAccelerationStructureCommandEncoder
MTLToolsComputePipelineState
MTLComputePipelineStateSPI
MTLComputePipelineState
MTLPipelineStateWithProgramAddressTable
MTLGPUDebugAccelerationStructure
MTLGPUDebugResource
MTLGPUDebugBuffer
MTLToolsDepthStencilState
MTLDepthStencilStateSPI
MTLDepthStencilState
MTLToolsIndirectComputeCommand
MTLIndirectComputeCommandSPI
MTLIndirectComputeCommand
MTLGPUDebugDevice
MTLToolsDevice
MTLDeviceSPI
MTLDevice
MTLToolsEvent
MTLEventSPI
MTLEvent
MTLToolsSharedEvent
MTLSharedEventSPI
MTLSharedEvent
MTLToolsLateEvalEvent
MTLLateEvalEvent
MTLToolsFunction
MTLFunctionSPI
MTLFunction
MTLToolsLibrary
MTLLibrarySPI
MTLLibrary
MTLToolsVisibleFunctionTable
MTLVisibleFunctionTableSPI
MTLVisibleFunctionTable
MTLDebugPipelineLibrary
MTLCountersComputeCommandEncoder
MTLGPUDebugRenderPipelineState
MTLGPUDebugAccelerationStructureCommandEncoder
MTLToolsObject
MTLToolsParallelRenderCommandEncoder
MTLParallelRenderCommandEncoderSPI
MTLParallelRenderCommandEncoder
MTLToolsIntersectionFunctionTable
MTLIntersectionFunctionTableSPI
MTLIntersectionFunctionTable
MTLToolsRenderCommandEncoder
MTLRenderCommandEncoderSPI
MTLRenderCommandEncoder
MTLGPUDebugIntersectionFunctionTable
MTLGPUDebugIndirectComputeCommand
MTLToolsRasterizationRateMap
MTLRasterizationRateMapSPI
MTLRasterizationRateMap
MTLDebugIntersectionFunctionTable
MTLCountersTraceCommandEncoder
MTLCountersTraceBlitCommandEncoder
MTLCountersTraceComputeCommandEncoder
MTLCountersTraceRenderCommandEncoder
MTLCountersTraceResourceStateCommandEncoder
MTLCountersTraceCommandBuffer
MTLToolsRenderPipelineState
MTLRenderPipelineStateSPI
MTLRenderPipelineState
MTLToolsResource
MTLToolsResourceGroupSPI
MTLResourceGroupSPI
MTLGPUDebugIndirectRenderCommand
MTLToolsSamplerState
MTLSamplerState
MTLSamplerStateSPI
MTLToolsTexture
MTLTextureImplementation
MTLTextureSPI
MTLTexture
MTLToolsTextureLayout
MTLTextureLayout
MTLCountersParallelRenderCommandEncoder
MTLGPUDebugCommandBuffer
MTLGPUDebugBufferEncoder
MTLToolsResourceStateCommandEncoder
MTLResourceStateCommandEncoderSPI
MTLResourceStateCommandEncoder
MTLDebugBlitCommandEncoder
MTLDebugResourceStateCommandEncoder
MTLDebugBufferMarker
MTLDebugBuffer
MTLDebugDeadlineProfile
MTLGPUDebugCommandQueue
MTLDebugCommandBuffer
MTLGPUDebugBinaryArchive
MTLGPUDebugPipelineStateInfoEncoder
MTLDebugDynamicLibrary
MTLToolsIndirectRenderCommand
MTLIndirectRenderCommandSPI
MTLIndirectRenderCommand
MTLDebugCounterSampleBuffer
MTLDebugBinaryArchive
MTLCountersDevice
MTLGPUDebugArgumentEncoder
MTLGPUDebugComputePipelineState
MTLDebugCommandQueue
MTLDebugComputeCommandEncoder
MTLAccelerationStructure
MTLDebugAccelerationStructureCommandEncoder
MTLDebugFunctionHandle
MTLFunctionHandle
MTLDebugComputePipelineState
MTLDebugIndirectCommandBuffer
MTLCountersCommandQueue
MTLToolsPipelineLibrary
MTLPipelineLibrarySPI
MTLPipelineLibrary
MTLToolsArgumentEncoder
MTLArgumentEncoderSPI
MTLArgumentEncoder
MTLGPUDebugHeap
MTLDebugArgumentEncoder
MTLIOScratchBufferAllocator
MTLDebugDevice
MTLDebugDepthStencilState
MTLGPUDebugIndirectCommandBuffer
MTLDebugEvent
MTLDebugSharedEvent
MTLDebugLateEvalEvent
MTLGPUDebugFunctionHandle
MTLGPUDebugParallelRenderCommandEncoder
MTLCountersResourceStateCommandEncoder
MTLToolsAccelerationStructure
MTLAccelerationStructureSPI
MTLToolsObjectCache
MTLDebugFunction
MTLDebugLibrary
MTLDebugParallelRenderCommandEncoder
MTLDebugRenderTargetAttachmentInfo
MTLDebugRenderCommandEncoder
MTLToolsDeadlineProfile
MTLDeadlineProfile
MTLCountersCommandBuffer
MTLGPUDebugBlitCommandEncoder
MTLGPUDebugVisibleFunctionTable
MTLDebugResource
MTLGPUDebugComputeCommandEncoder
MTLToolsFunctionHandle
MTLGPUDebugFunction
MTLDebugIndirectRenderCommand
MTLDebugRenderPipelineState
MTLDebugSamplerState
MTLDebugHeap
MTLDebugTexture
MTLDebugTextureLayout
MTLGPUDebugDynamicLibrary
MTLDebugAccelerationStructure
MTLGPUDebugTexture
MTLToolsIOCommandBuffer
MTLIOCommandBufferSPI
MTLIOCommandBuffer
MTLToolsIOHandle
MTLIOHandleSPI
MTLIOFileHandle
MTLToolsIOScratchBufferAllocator
MTLToolsIOScratchBuffer
MTLIOScratchBuffer
MTLToolsIOCommandQueue
MTLIOCommandQueueSPI
MTLIOCommandQueue
MTLDebugIOCommandBuffer
MTLDebugIOHandle
MTLDebugIOScratchBufferAllocator
MTLDebugIOScratchBuffer
MTLDebugIOCommandQueue
MTLCountersBlitCommandEncoder
newSerializedComputeDataWithFlags:options:
meshAdditionalBinaryFunctions
bufferAlignment
count
newSerializedVertexDataWithFlags:options:error:
setClearStencil:
meshArguments
countByEnumeratingWithState:objects:count:
imageBlockDataReturn
fragmentPreloadedLibraries
bufferDataSize
imageBlockMasterStructMembers
frontFaceStencil
setIndex:
tileFunction
isActive
setIndexBuffer:
meshFunction
setIndirectArgumentIndexStride:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
isAlphaToCoverageEnabled
maxAnisotropy
pipelineLibrary
bufferStructType
elementArrayType
elementIsArgumentBuffer
dataType
setTileAdditionalBinaryFunctions:
standardizedURL
pipelineOptions
meshLinkedFunctions
setInheritBuffers:
builtInArguments
elementIsIndirectArgumentBuffer
dataTypeDescription
setInnerNodeBuffer:
builtInDataType
indexBuffer
setComputeFunction:
elementStructType
dataWithBytesNoCopy:length:freeWhenDone:
builtInType
setInnerNodeBufferOffset:
meshPreloadedLibraries
startOfEncoderSampleIndex
dataWithLength:
elementType
bundleWithIdentifier:
indexBufferOffset
setInstanceDescriptorBuffer:
startOfFragmentSampleIndex
pointerType
indexType
bytes
addObject:
transformationMatrixBuffer
setInstanceTransformBuffer:
startOfVertexSampleIndex
initWithKeyOptions:valueOptions:capacity:
setTileDebugInstrumentationData:
meshThreadgroupSizeIsMultipleOfThreadExecutionWidth
setPerPrimitiveDataBuffer:
setInstanceTransformBufferOffset:
cStringUsingEncoding:
initWithLength:
setTileFunction:
transformationMatrixBufferOffset
meshThreadsPerThreadgroup
indirectArgumentIndex
setPerPrimitiveDataBufferOffset:
addObjectsFromArray:
triangleCount
indirectArgumentIndexStride
setPerformanceStatistics:
stencilAttachment
setConstantBlockAlignment:
setPipelineLibrary:
functionPointers
debugLocationForID:
stencilCompareFunction
resolveTexture
setPipelineOptions:
isDepthWriteEnabled
stencilFailureOperation
initWithName:offset:dataType:pixelFormat:aluType:indirectArgumentIndex:render_target:raster_order_group:details:
functions
setConstantValue:type:atIndex:
clearDepth
setPixelFormat:
inheritBuffers
initWithName:type:access:isActive:locationIndex:dataType:pixelFormat:aluType:dataSize:alignment:
minFilter
isFileURL
preloadedLibraries
initWithObjectData:meshData:fragmentData:device:options:flags:
unionSet:
inheritPipelineState
storeAction
setDataType:
initWithObjects:
geometryBuffer
setPreloadedLibraries:
defaultColorSampleCount
colorAttachments
URLForResource:withExtension:
setDeadlineProfile:
geometryBufferOffset
setPrimitiveBuffer:
defaultManager
colorSampleCount
UTF8String
geometryDescriptors
setPrimitiveBufferOffset:
defaultRasterSampleCount
mipFilter
setPrimitiveDataBuffer:
maxFragmentBufferBindCount
setDepthAttachmentPixelFormat:
depthAttachment
maxFragmentCallStackDepth
stride
setLeafNodeBuffer:
unsignedIntegerValue
setTransformationMatrixBuffer:
string
motionEndTime
setPrivateFunctions:
depthCompareFunction
primitiveBuffer
setLeafNodeBufferOffset:
stringByAppendingPathComponent:
motionKeyframeCount
initWithArray:
commandQueueDescriptor
noCopy
depthFailureOperation
stringByPaddingToLength:withString:startingAtIndex:
primitiveBufferOffset
setLength:
motionStartTime
depthStencilPassOperation
commandTypes
initWithArrayLength:elementType:stride:pixelFormat:aluType:details:
normalizedCoordinates
valueWithRange:
motionTransformBuffer
primitiveDataBuffer
sAddressMode
setLibraries:
_descriptorAtIndex:
setDepthCompareFunction:
stringByStandardizingPath
sampleBuffer
stringForID:
additionalCompilerArguments
setLibrary:
_descriptorPrivate
primitiveDataBufferOffset
sampleBufferAttachments
version
stringWithFormat:
primitiveDataElementSize
descriptorPrivate
vertexAdditionalBinaryFunctions
mutableCopy
setLinkedFunctions:
primitiveDataStride
stringWithUTF8String:
setValue:forKey:
allObjects
vertexArguments
setRasterizationEnabled:
setLoadAction:
structType
priority
setRasterizationRateMap:
null
privateFunctions
vertexBuffer
setReadMask:
setDepthWriteEnabled:
supportAddingBinaryFunctions
setVertexAdditionalBinaryFunctions:
setMaxAnisotropy:
numberWithFloat:
setMaxCommandBufferCount:
vertexBufferOffset
numberWithUnsignedInteger:
supportAddingFragmentBinaryFunctions
vertexBuffers
isRasterizationEnabled
setMaxFragmentBufferBindCount:
endOfEncoderSampleIndex
compareFunction
appendData:
initWithSerializedData:serializedStageInputDescriptor:device:options:flags:
supportAddingMeshBinaryFunctions
setMaxKernelBufferBindCount:
initWithSymbolName:buffer:offset:
numberWithUnsignedLong:
vertexBuiltInArguments
endOfFragmentSampleIndex
maxKernelBufferBindCount
setVertexBuffer:
supportAddingObjectBinaryFunctions
numberWithUnsignedLongLong:
initWithSymbolName:bytes:length:
setMaxVertexBufferBindCount:
appendString:
endOfVertexSampleIndex
supportAddingVertexBinaryFunctions
objectAdditionalBinaryFunctions
objectArguments
supportArgumentBuffers
setMembers:count:
componentsJoinedByString:
maxMeshBufferBindCount
scratchBufferAllocator
vertexFormat
isStructLayoutThreadSafeWith:
maxMeshCallStackDepth
objectAtIndexedSubscript:
rAddressMode
isSubclassOfClass:
vertexFunction
setMeshAdditionalBinaryFunctions:
setResolveTexture:
componentsSeparatedByString:
rangeValue
maxObjectBufferBindCount
initWithTileData:functionType:device:options:flags:
maxObjectCallStackDepth
setForceSoftwareVertexFetch:
rasterSampleCount
setVertexDebugInstrumentationData:
initWithUTF8String:
setVertexFunction:
vertexLinkedFunctions
objectForKey:
rasterizationRateMap
initWithVersion:
objectForKeyedSubscript:
setFragmentAdditionalBinaryFunctions:
vertexPreloadedLibraries
enumerateByteRangesUsingBlock:
setRetainedReferences:
initWithVertexData:fragmentData:serializedVertexDescriptor:device:options:flags:
objectFunction
argumentIndex
setSampleBuffer:
vertexStride
setMeshDebugInstrumentationData:
setVertexLinkedFunctions:
visibilityResultBuffer
setMeshFunction:
setVertexPreloadedLibraries:
dictionary
array
computeFunction
layerPointer:
dictionaryWithObjects:forKeys:count:
objectLinkedFunctions
arrayType
readMask
setFragmentDebugInstrumentationData:
arrayWithArray:
errorWithDomain:code:userInfo:
setMeshLinkedFunctions:
layouts
objectPreloadedLibraries
setFragmentFunction:
leafNodeBuffer
arrayWithCapacity:
setMeshPreloadedLibraries:
leafNodeBufferOffset
inlinedAt
arrayWithObjects:count:
constantBlockAlignment
objectThreadgroupSizeIsMultipleOfThreadExecutionWidth
innerNodeBuffer
setScratchBufferAllocator:
setFragmentLinkedFunctions:
objectThreadsPerThreadgroup
innerNodeBufferOffset
lengthOfBytesUsingEncoding:
setFragmentPreloadedLibraries:
setAccess:
libraries
inputPrimitiveTopology
setAdditionalCompilerArguments:
library
backFaceStencil
containsObject:
openGLModeEnabled
containsString:
setApplyFunctionConstants:
insertObject:atIndex:
base64EncodedDataWithOptions:
initWithBytesNoCopy:length:freeWhenDone:
initWithCapacity:
setVisibilityResultBuffer:
instanceCount
symbolName
setMotionTransformBuffer:
instanceDescriptorBuffer
globalConstantsData
tAddressMode
setName:
instanceDescriptorBufferOffset
copy
setArrayLength:
setObject:atIndexedSubscript:
instanceDescriptorStride
fileSystemRepresentation
instanceDescriptorType
setObject:forKey:
linkedFunctions
instanceTransformBuffer
setObject:forKeyedSubscript:
loadAction
removeAllObjects
instanceTransformBufferOffset
binaryArchives
groups
writeMask
instancedAccelerationStructures
setObjectAdditionalBinaryFunctions:
tessellationControlPointIndexType
setBinaryArchives:
tessellationFactorFormat
setBinaryFunctions:
binaryFunctions
writeToFile:options:error:
removeObject:
setFunctionPointers:
maxVertexBufferBindCount
hasArgumentBufferInstrumentationFailures
tessellationFactorStepFunction
setFunctions:
setWriteMask:
removeObjectAtIndex:
setBoundingBoxBuffer:
hasArgumentLimitsInstrumentationFailures
setStoreAction:
texture
initWithDebugLocation:
removeObjectForKey:
maxVertexCallStackDepth
setStoreActionOptions:
setObjectDebugInstrumentationData:
hasGlobalConstantsInstrumentationFailures
textureDataType
setStructType:withDevice:
setObjectFunction:
userReflectionData
borderColor
setSupportIndirectCommandBuffers:
validate:width:height:
setGeometryBuffer:
borderColorSPI
initWithDictionary:
headerBuffer
boundingBoxBuffer
setObjectLinkedFunctions:
localizedDescription
fragmentAdditionalBinaryFunctions
setGeometryBufferOffset:
threadGroupSizeIsMultipleOfThreadExecutionWidth
headerBufferOffset
fragmentArguments
setObjectPreloadedLibraries:
boundingBoxBufferOffset
path
intersectionFunctionTableOffset
threadgroupArgumentOffset
boundingBoxBuffers
members
initWithFormat:
threadgroupMemoryDataSize
pathForResource:ofType:
boundingBoxCount
perPrimitiveDataBuffer
setGroups:
renderTargetHeight
setTexture:
threadgroupMemoryLength
fragmentFunction
boundingBoxStride
renderTargetWidth
perPrimitiveDataBufferOffset
setHeaderBuffer:
magFilter
setHeaderBufferOffset:
tileAdditionalBinaryFunctions
access
sortedArrayUsingComparator:
setClearColor:
bufferAccessMask
performanceStatistics
activeThreadgroupMask
tileArguments
setClearDepth:
fragmentLinkedFunctions
initWithBaseObject:parent:
dealloc
initWithBaseObject:descriptor:indexCount:indirectCommandBuffer:
index
indirectCommandBuffer
setComputePipelineState:
setKernelBuffer:offset:atIndex:
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
_desc
_index
_iCB
TQ,R
T@"<MTLIndirectCommandBuffer>",R
initWithRenderCommandEncoder:parent:descriptor:
initWithRenderCommandEncoder:parent:
setThreadgroupMemoryLength:offset:atIndex:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
dispatchThreadsPerTile:
dispatchThreadsPerTile:inRegion:
dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:
setVertexAmplificationCount:viewMappings:
setDepthStencilState:
setRenderPipelineState:
endEncoding
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
T#,R
T@"NSString",R,C
temporaryBufferWithBytes:length:
temporaryBufferWithLength:
encoderID
TI,R
_initBufferArgumentData:
initWithRenderCommandEncoder:commandBuffer:descriptor:encoderID:
initWithRenderCommandEncoder:parallelEncoder:encoderID:
flushBindings
setTessellationControlPointIndexBuffer:offset:
setBufferUsageTable:textureUsageTable:forStage:
setVertexReportBuffer:offset:
setFragmentReportBuffer:offset:
setTileReportBuffer:offset:
setObjectReportBuffer:offset:
setMeshReportBuffer:offset:
setRenderPipelineStateBuffers:
setVertexBuffer:offset:atIndex:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setVertexBytes:length:atIndex:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setFragmentBytes:length:atIndex:
setTileBuffer:offset:atIndex:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
setTileBytes:length:atIndex:
setObjectBuffer:offset:atIndex:
setObjectBufferOffset:atIndex:
setObjectBuffers:offsets:withRange:
setObjectBytes:length:atIndex:
setMeshBuffer:offset:atIndex:
setMeshBufferOffset:atIndex:
setMeshBuffers:offsets:withRange:
setMeshBytes:length:atIndex:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setTileTexture:atIndex:
setTileTextures:withRange:
setMeshTexture:atIndex:
setMeshTextures:withRange:
setObjectTexture:atIndex:
setObjectTextures:withRange:
executeCommandsInBuffer:withRange:
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
useResourceInternal:usage:stages:
_useResourceCommon:usage:stages:
useResource:usage:
useResource:usage:stages:
useResources:count:usage:
useResources:count:usage:stages:
useHeap:
useHeap:stages:
useHeaps:count:
useHeaps:count:stages:
setVertexVisibleFunctionTable:atBufferIndex:
setVertexVisibleFunctionTables:withBufferRange:
setFragmentVisibleFunctionTable:atBufferIndex:
setFragmentVisibleFunctionTables:withBufferRange:
setTileVisibleFunctionTable:atBufferIndex:
setTileVisibleFunctionTables:withBufferRange:
setObjectVisibleFunctionTable:atBufferIndex:
setObjectVisibleFunctionTables:withBufferRange:
setMeshVisibleFunctionTable:atBufferIndex:
setMeshVisibleFunctionTables:withBufferRange:
setVertexIntersectionFunctionTable:atBufferIndex:
setVertexIntersectionFunctionTables:withBufferRange:
setFragmentIntersectionFunctionTable:atBufferIndex:
setFragmentIntersectionFunctionTables:withBufferRange:
setTileIntersectionFunctionTable:atBufferIndex:
setTileIntersectionFunctionTables:withBufferRange:
setVertexAccelerationStructure:atBufferIndex:
setVertexAccelerationStructures:withBufferRange:
setFragmentAccelerationStructure:atBufferIndex:
setFragmentAccelerationStructures:withBufferRange:
setTileAccelerationStructure:atBufferIndex:
setTileAccelerationStructures:withBufferRange:
setObjectIntersectionFunctionTable:atBufferIndex:
setObjectIntersectionFunctionTables:withBufferRange:
setMeshIntersectionFunctionTable:atBufferIndex:
setMeshIntersectionFunctionTables:withBufferRange:
setObjectAccelerationStructure:atBufferIndex:
setObjectAccelerationStructures:withBufferRange:
setMeshAccelerationStructure:atBufferIndex:
setMeshAccelerationStructures:withBufferRange:
.cxx_construct
useResourceIteration
_tileStageActive
_tileStageUsed
_fragmentStageActive
_vertexStageActive
_objectStageActive
_meshStageActive
_enableUseResourceValidation
_commandBuffer
_vertexHandles
_fragmentHandles
_tileHandles
_threadgroup
_objectHandles
_meshHandles
_options
_drawID
_encoderType
_currentPipeline
_currentDepthStencil
_vertexReportBuffer
_fragmentReportBuffer
_tileReportBuffer
_objectReportBuffer
_meshReportBuffer
_vertexAmpState
_vertexBufferUsageTable
_vertexTextureUsageTable
_fragmentBufferUsageTable
_fragmentTextureUsageTable
commandBuffer
T@"MTLGPUDebugCommandBuffer",R,D
setPurgeableState:
makeAliasable
isAliasable
label
setLabel:
device
cpuCacheMode
storageMode
hazardTrackingMode
resourceOptions
heap
heapOffset
allocatedSize
T@"NSString",C
T@"<MTLDevice>",R
T@"<MTLHeap>",R
resetWithRange:
indirectRenderCommandAtIndex:
indirectComputeCommandAtIndex:
size
gpuResourceID
T{MTLResourceID=Q},R
getHeader:headerSize:
uniqueIdentifier
gpuHandle
gpuAddress
resourceIndex
TQ,R,N
TQ,R,D,N
type
encoderLabel
function
debugLocation
T@"NSString",R,N
T@"<MTLFunction>",R,N
T@"<MTLFunctionLogDebugLocation>",R,N
image
setImage:
errorStackTrace
setErrorStackTrace:
callIndex
setCallIndex:
setType:
setEncoderLabel:
setFunction:
setDebugLocation:
_image
_errorStackTrace
_callIndex
_type
_encoderLabel
_function
_debugLocation
T@"MTLGPUDebugImageData",&,N,V_image
T@"NSArray",&,N,V_errorStackTrace
TQ,N,V_callIndex
TQ,N,V_type
T@"NSString",&,N,V_encoderLabel
T@"<MTLFunction>",&,N,V_function
T@"<MTLFunctionLogDebugLocation>",&,N,V_debugLocation
init
addressSpace
setAddressSpace:
buffer
setBuffer:
offset
setOffset:
operation
setOperation:
argument
setArgument:
specifiedUsage
setSpecifiedUsage:
_addressSpace
_operation
_specifiedUsage
_buffer
_offset
_argument
Ti,N,V_addressSpace
T@"<MTLBuffer>",&,N,V_buffer
TQ,N,V_offset
Ti,N,V_operation
T@"MTLArgument",&,N,V_argument
Ti,N,V_specifiedUsage
errorReason
setErrorReason:
_errorReason
Ti,N,V_errorReason
functionName
setFunctionName:
_functionName
T@"NSString",&,N,V_functionName
insertDebugSignpost:
pushDebugGroup:
popDebugGroup
endEncodingAndRetrieveProgramAddressTable
synchronizeResource:
synchronizeTexture:slice:level:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
generateMipmapsForTexture:
fillBuffer:range:value:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
updateFence:
waitForFence:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
resetTextureAccessCounters:region:mipLevel:slice:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
resetCommandsInBuffer:withRange:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
optimizeIndirectCommandBuffer:withRange:
sampleCountersInBuffer:atSampleIndex:withBarrier:
resolveCounters:inRange:destinationBuffer:destinationOffset:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
invalidateCompressedTexture:
invalidateCompressedTexture:slice:level:
fillBuffer:range:pattern4:
fillTexture:level:slice:region:bytes:length:
fillTexture:level:slice:region:color:
fillTexture:level:slice:region:color:pixelFormat:
initWithBlitCommandEncoder:parent:descriptor:
T@"MTLToolsCommandBuffer",R,D,N
_initWithCommandBuffer:
setVertexSamplerState:atIndex:
setVertexSamplerStates:withRange:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentSamplerState:atIndex:
setFragmentSamplerStates:withRange:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:
setTileSamplerState:atIndex:
setTileSamplerStates:withRange:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setViewport:
setViewports:count:
setFrontFacingWinding:
setCullMode:
setDepthClipMode:
setLineWidth:
setDepthBias:slopeScale:clamp:
setScissorRect:
setScissorRects:count:
setVertexAmplificationMode:value:
setTriangleFillMode:
setStencilReferenceValue:
setStencilFrontReferenceValue:backReferenceValue:
setColorStoreAction:atIndex:
setDepthStoreAction:
setStencilStoreAction:
setVisibilityResultMode:offset:
setBlendColorRed:green:blue:alpha:
setColorResolveTexture:slice:depthPlane:level:atIndex:
setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:
setDepthResolveTexture:slice:depthPlane:level:
setDepthResolveTexture:slice:depthPlane:level:yInvert:
setStencilResolveTexture:slice:depthPlane:level:
setStencilResolveTexture:slice:depthPlane:level:yInvert:
updateFence:afterStages:
waitForFence:beforeStages:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorScale:
memoryBarrierWithScope:afterStages:beforeStages:
memoryBarrierWithResources:count:afterStages:beforeStages:
_APITimingEnabled
_traceEncoder
resolveCounterRange:
sampleCount
T@"NSString",R
initWithLibrary:device:
newFunctionWithDescriptor:error:
newFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:error:
newFunctionWithName:
newFunctionWithName:constantValues:error:
newFunctionWithName:constantValues:completionHandler:
newFunctionWithName:constantValues:functionCache:error:
newFunctionWithName:constantValues:pipelineLibrary:error:
newFunctionWithName:constantValues:pipelineLibrary:completionHandler:
isPurgeable
isComplete
waitUntilComplete
doesAliasResource:
doesAliasAllResources:count:
doesAliasAnyResources:count:
responsibleProcess
setResponsibleProcess:
allocationID
protectionOptions
unfilteredResourceOptions
setOwnerWithIdentity:
contents
didModifyRange:
newTextureWithDescriptor:offset:bytesPerRow:
addDebugMarker:range:
removeAllDebugMarkers
length
newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:
_aneIOSurface
iosurface
parentGPUAddress
setParentGPUAddress:
parentGPUSize
setParentGPUSize:
T^{__IOSurface=},R
TQ,N
formattedDescription:
unwrapMTLComputePassDescriptorInternal:
enqueue
commit
addScheduledHandler:
presentDrawable:
presentDrawable:atTime:
waitUntilScheduled
addCompletedHandler:
waitUntilCompleted
blitCommandEncoder
renderCommandEncoderWithDescriptor:
computeCommandEncoderWithDescriptor:
blitCommandEncoderWithDescriptor:
computeCommandEncoder
computeCommandEncoderWithDispatchType:
encodeWaitForEvent:value:
encodeSignalEvent:value:
parallelRenderCommandEncoderWithDescriptor:
resourceStateCommandEncoder
resourceStateCommandEncoderWithDescriptor:
accelerationStructureCommandEncoder
accelerationStructureCommandEncoderWithDescriptor:
commandQueue
retainedReferences
errorOptions
kernelStartTime
kernelEndTime
logs
GPUStartTime
GPUEndTime
status
error
T@"<MTLCommandQueue>",R
TB,R
Td,R
T@"<MTLLogContainer>",R
T@"NSError",R
encodeDashboardTagForResourceGroup:
encodeDashboardFinalizeForResourceGroup:dashboard:value:forIndex:
encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:
addPurgedResource:
addPurgedHeap:
commitWithDeadline:
commitAndWaitUntilSubmittedWithDeadline:
setLogs:
presentDrawable:options:
isProfilingEnabled
setProfilingEnabled:
profilingResults
userDictionary
deadlineProfile
debugBufferContentsWithLength:
sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:
sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:
debugCommandEncoder
commitAndHold
commitAndWaitUntilSubmitted
setProtectionOptions:
encodeWaitForEvent:value:timeout:
setResourceGroups:count:
dropResourceGroups:count:
encodeCacheHintTag:resourceGroups:count:
encodeCacheHintFinalize:resourceGroups:count:
getListIndex
globalTraceObjectID
listIndex
TQ,R,N,GgetListIndex
profilingEnabled
TB,GisProfilingEnabled
T@"NSDictionary",R
T@"NSMutableDictionary",R,N
T@"<MTLDeadlineProfile>",R,&
addRetainedObject:
clearRetainedObjects
retainedObjects
T@"NSMutableSet",R,N
initWithCommandBuffer:parent:descriptor:
invokeScheduledHandlers
invokeCompletedHandlers
postCompletionHandlers
preCompletionHandlers
postScheduledHandlers
preScheduledHandlers
preCommit
unwrapMTLRenderPassDescriptor:
unwrapMTLComputePassDescriptor:
unwrapMTLBlitPassDescriptor:
unwrapMTLResourceStatePassDescriptor:
willEncodeSignalEvent:value:writeableResources:
addSynchronizationNotification:
executeSynchronizationNotifications:
executeSynchronizationNotifications:scope:resources:count:
retainObjectsFromRenderPassDescriptor:
unwrapMTLAccelerationStructurePassDescriptor:
useRetainedObjectsLock
setUseRetainedObjectsLock:
.cxx_destruct
_flags
_retainedObjectsLock
_useRetainedObjectsLock
_handlerLock
_scheduledHandlers
_completedHandlers
_didInvokeHandlers
_perfSampleHandlerBlock
_StatEnabled
_deadlineProfile
_retainedObjects
TB,V_useRetainedObjectsLock
T@"NSMutableSet",R,N,V_retainedObjects
initWithBaseObject:parallelRenderCommandEncoder:
filterCounterRangeWithFirstBatch:lastBatch:filterIndex:
T@"<MTLToolsRetainingContainer>",R,N,V_commandBuffer
insertData:andNumSamples:forRequester:
extractDataAndNumSamples:forRequester:isLast:
_requester
_data
_iterator
commandBufferWithDescriptor:
commandBufferWithUnretainedReferences
insertDebugCaptureBoundary
getGPUPriority
setGPUPriority:
setGPUPriority:offset:
getBackgroundGPUPriority
setBackgroundGPUPriority:
setBackgroundGPUPriority:offset:
setSubmissionQueue:
setCompletionQueue:
finish
backgroundTrackingPID
setBackgroundTrackingPID:
maxCommandBufferCount
qosLevel
commitQueue
commitSynchronously
completionQueue
disableCrossQueueHazardTracking
skipRender
setSkipRender:
executionEnabled
setExecutionEnabled:
isOpenGLQueue
getSPIStats
availableCounters
availableCountersAndDict
requestCounters:
requestCounters:withIndex:
getRequestedCounters
subdivideCounterList:
addPerfSampleHandler:
counterInfo
dispatchAvailableCompletionNotifications
isStatEnabled
setStatEnabled:
getStatOptions
setStatOptions:
getStatLocations
setStatLocations:
T@"NSObject<OS_dispatch_queue>",R
StatEnabled
TB,N,GisStatEnabled
StatOptions
TQ,N,GgetStatOptions
StatLocations
TQ,N,GgetStatLocations
snapshotPerfSampleHandlerAndStatEnabled:forCommandBuffer:
_perfSampleMailbox
_perfHandlerLock
lockPurgeableState
unlockPurgeableState
purgeableStateValidForRendering
initWithVisibleFunctionTable:parent:descriptor:stage:
initWithVisibleFunctionTable:parent:descriptor:pipelineState:stage:
setFunction:atIndex:
setFunctions:withRange:
functionCount
stage
_purgeableStateToken
_purgeableStateHasBeenSet
_functionCount
_pipelineState
_stage
TQ,R,V_functionCount
TQ,R,V_stage
serializeToURL:error:
installName
serializeToURL:options:error:
binaryData
exportedFunctions
exportedVariables
importedSymbols
importedLibraries
libraryPath
libraryUUID
relocations
setRelocations:
debugInstrumentationData
setDebugInstrumentationData:
shaderValidationEnabled
T@"NSObject<OS_dispatch_data>",R
T@"NSArray",R
Tr^{?=[32C]},R
T@"NSArray",C,N
T@"MTLDebugInstrumentationData",&,N
TB,R,N
_relocations
addComputePipelineFunctionsWithDescriptor:error:
addRenderPipelineFunctionsWithDescriptor:error:
addTileRenderPipelineFunctionsWithDescriptor:error:
addFunctionWithDescriptor:library:error:
addBinaryEntry:forKey:
getBinaryDataForKey:
getArchiveIDWithError:
recompilablePipelineCount
newPipelineDescriptorAtIndex:pipelineType:error:
archiveFunctionIds
addComputePipelineFunctionsWithDescriptor:options:error:
addRenderPipelineFunctionsWithDescriptor:options:error:
addTileRenderPipelineFunctionsWithDescriptor:options:error:
addMeshRenderPipelineFunctionsWithDescriptor:error:
addMeshRenderPipelineFunctionsWithDescriptor:options:error:
addArchiveEntry:forKey:
getArchiveDataForKey:
addLibraryWithDescriptor:error:
storeComputePipelineDescriptor:
storeRenderPipelineDescriptor:
storeTileRenderPipelineDescriptor:
storeMeshRenderPipelineDescriptor:
pipelineCollection
enumerateArchivesFromBackingFile:
enumerateArchivesFromPipelineCollection:
options
keys
maxAvailableSizeWithAlignment:
newBufferWithLength:options:
newTextureWithDescriptor:
newBufferWithLength:options:offset:
newTextureWithDescriptor:offset:
newAccelerationStructureWithSize:
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithSize:offset:
newAccelerationStructureWithDescriptor:offset:
usedSize
currentAllocatedSize
Tq,R
newAccelerationStructureWithSize:resourceIndex:
newAccelerationStructureWithSize:offset:resourceIndex:
_newToolsBuffer:
_newToolsTexture:
notifyResourceReleasing:
_newToolsAccelerationStructure:
enableNullBufferBinds:
setBytes:length:atIndex:
setBuffer:offset:atIndex:
setBufferOffset:atIndex:
setBuffers:offsets:withRange:
setVisibleFunctionTable:atBufferIndex:
setVisibleFunctionTables:withBufferRange:
setIntersectionFunctionTable:atBufferIndex:
setIntersectionFunctionTables:withBufferRange:
setAccelerationStructure:atBufferIndex:
setTexture:atIndex:
setTextures:withRange:
setSamplerState:atIndex:
setSamplerStates:withRange:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setThreadgroupMemoryLength:atIndex:
setImageblockWidth:height:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
memoryBarrierWithScope:
memoryBarrierWithResources:count:
dispatchType
newKernelDebugInfo
setThreadgroupPackingDisabled:
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
useResourceGroup:usage:
encodeStartDoWhile
encodeEndDoWhile:offset:comparison:referenceValue:
encodeStartWhile:offset:comparison:referenceValue:
encodeEndWhile
encodeStartIf:offset:comparison:referenceValue:
encodeStartElse
encodeEndIf
initWithComputeCommandEncoder:parent:descriptor:
setImageBlockWidth:height:
initWithDynamicLibrary:
initWithFunction:
initWithFunction:debugInstrumentationData:
_applyConstantRelocation
_applyConstantRelocation:
_applyImageIDRelocation:
setConstantData:
loadedImageName
dynamicLibrary
functionType
imageType
constantDataBuffer
_device
_constantDataMutex
_constantDataBufferIndex
_constantDataKeyPair
_loadedImageName
_debugInstrumentationData
_imageType
_imageID
_functionType
_dynamicLibrary
Ti,R,N
T@"MTLDebugInstrumentationData",R,N
T@"MTLGPUDebugFunction",R,W,N
T@"MTLGPUDebugDynamicLibrary",R,W,N
buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
copyAccelerationStructure:toAccelerationStructure:
writeCompactedAccelerationStructureSize:toBuffer:offset:
writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:
copyAndCompactAccelerationStructure:toAccelerationStructure:
writeSerializedAccelerationStructureSize:toBuffer:sizeBufferOffset:
writeDeserializedAccelerationStructureSize:serializedOffset:toBuffer:sizeBufferOffset:
writeDeserializedPrimitiveAccelerationStructureSizes:serializedOffset:toBuffer:sizesBufferOffset:
serializePrimitiveAccelerationStructure:toBuffer:serializedBufferOffset:
serializeInstanceAccelerationStructure:primitiveAccelerationStructures:toBuffer:serializedBufferOffset:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
serializeAccelerationStructure:toBuffer:serializedBufferOffset:
deserializeAccelerationStructure:fromBuffer:serializedBufferOffset:
deserializeAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:
writeGeometrySizeOfAccelerationStructure:toBuffer:sizeBufferOffset:
writeGeometryOfAccelerationStructure:toBuffer:geometryBufferOffset:
deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:withDescriptor:
deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:withDescriptor:
writeGenericBVHStructureSizesOfAccelerationStructure:into:
writeGenericBVHStructureOfAccelerationStructure:into:
writeGenericBVHStructureSizesOfAccelerationStructure:toBuffer:sizesBufferOffset:
writeGenericBVHStructureOfAccelerationStructure:headerBuffer:headerBufferOffset:innerNodeBuffer:innerNodeBufferOffset:leafNodeBuffer:leafNodeBufferOffset:primitiveBuffer:primitiveBufferOffset:geometryBuffer:geometryOffset:instanceTransformBuffer:instanceTransformOffset:
writeAccelerationStructureSerializationData:toBuffer:offset:
initWithAccelerationStructureCommandEncoder:parent:descriptor:
imageblockMemoryLengthForDimensions:
functionHandleWithFunction:
newComputePipelineStateWithAdditionalBinaryFunctions:error:
newVisibleFunctionTableWithDescriptor:
newIntersectionFunctionTableWithDescriptor:
maxTotalThreadsPerThreadgroup
threadExecutionWidth
staticThreadgroupMemoryLength
supportIndirectCommandBuffers
pipelineBinaries
textureWriteRoundingMode
T@"MTLDebugInstrumentationData",R,&,N
newComputePipelineStateWithAdditionalBinaryFunctions:
initWithBaseObject:parent:heap:
useWithComputeEncoder:usage:
useWithRenderEncoder:usage:stages:
handleForOffset:
baseObject
underlyingGPUAddress
T@"<MTLResource>",R,N
initWithAccelerationStructure:device:
initWithAccelerationStructure:heap:
_setupIdentifier
_gpuIdentifier
T@"<MTLAccelerationStructure>",&,D,N
initWithBuffer:device:
initWithBuffer:device:offset:length:
initWithBuffer:device:offset:length:track:
initWithBuffer:heap:device:
initWithBuffer:heap:device:offset:length:track:
setBufferIndex:
bufferIndex
isTracked
_bufferIndex
_length
_descriptorHeap
T@"<MTLBuffer>",&,D,N
readsDepth
writesDepth
readsStencil
writesStencil
initWithDepthStencilState:descriptor:device:
setBarrier
clearBarrier
reset
getKernelBufferAtIndex:
getCommandType
dispatchThreadgroupsArguments
dispatchThreadsArguments
getThreadgroupMemoryLengthAtIndex:
getStageInRegion
hasBarrier
getImageBlockSize
getOptimizedStatus
getPipelineStateUniqueIdentifier
newArgumentEncoderWithArguments:structType:
newArgumentEncoderWithArguments:
supportsRenderDynamicLibraries
supportsGlobalVariableRelocationRender
newStageBufferArgumentEncoder
newStageArgumentBuffer
newInternalBufferWithLength:options:
modifyFunctionDescriptor:
_modifyCompileOptions:
_modifyPluginData:
_prepareBinaryLinkedFunctions:
_prepareInsertLibraries:
_modifyRenderPipelineDescriptor:
unwrapAndModifyRenderPipelineDescriptor:options:
_modifyComputePipelineDescriptor:
unwrapAndModifyComputePipelineDescriptor:options:
_modifyTilePipelineDescriptor:
unwrapAndModifyTileRenderPipelineDescriptor:options:
_modifyMeshRenderPipelineDescriptor:
unwrapAndModifyMeshRenderPipelineDescriptor:options:
onRenderPipelineCreated:
onComputePipelineCreated:
newCommandQueueWithDescriptor:
newCommandQueue
newCommandQueueWithMaxCommandBufferCount:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:options:completionHandler:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
newRenderPipelineStateWithTileDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:error:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
newRenderPipelineStateWithMeshDescriptor:completionHandler:
newRenderPipelineStateWithMeshDescriptor:error:
newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
newComputePipelineStateWithDescriptor:error:
newComputePipelineStateWithDescriptor:options:reflection:error:
newComputePipelineStateWithDescriptor:completionHandler:
newComputePipelineStateWithDescriptor:options:completionHandler:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
ICB_Inherit_PSO_VertexPipelineState
ICB_Inherit_None_VertexPipelineState
ICB_Inherit_Buffers_VertexPipelineState
ICB_DepthStencilState
ICB_Inherit_PSO_ComputePipelineState
ICB_Inherit_None_ComputePipelineState
ICB_Inherit_Buffers_ComputePipelineState
ICB_Inherit_Both_ComputePipelineState
newLibraryWithCIFiltersForComputePipeline:imageFilterFunctionInfo:error:
newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithCIFilters:imageFilterFunctionInfo:error:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newLibraryWithDAG:functions:error:
unwrapStitchedLibraryDescriptor:
newLibraryWithStitchedDescriptor:error:
newLibraryWithStitchedDescriptor:completionHandler:
newLibraryWithStitchedDescriptorSPI:error:
newLibraryWithDescriptor:error:
newLibraryWithDescriptor:completionHandler:
newLibraryWithDescriptorSPI:error:
newDagStringWithGraphs:
newLibraryWithFile:error:
newLibraryWithData:error:
newLibraryWithURL:error:
newLibraryWithSource:options:error:
newLibraryWithSource:options:completionHandler:
newDynamicLibraryWithURL:error:
newDynamicLibraryFromURL:error:
newDynamicLibraryWithURL:options:error:
newDynamicLibrary:error:
newDynamicLibrary:computeDescriptor:error:
loadDynamicLibrariesForComputeDescriptor:error:
loadDynamicLibrariesForComputeDescriptor:options:error:
loadDynamicLibrariesForFunction:insertLibraries:error:
loadDynamicLibrariesForFunction:insertLibraries:options:error:
newBinaryArchiveWithDescriptor:error:
newBinaryLibraryWithOptions:url:error:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithIOSurface:
newBufferWithLength:options:gpuAddress:
newBufferWithBytes:length:options:gpuAddress:
newBufferWithBytesNoCopy:length:options:gpuAddress:deallocator:
newBufferWithDescriptor:
newHeapWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
newTextureWithBytesNoCopy:length:descriptor:deallocator:
newArgumentEncoderWithLayout:
validateRaytracing
accelerationStructureSizesWithDescriptor:
newAccelerationStructureWithBuffer:offset:
newAccelerationStructureWithBuffer:offset:resourceIndex:
deserializePrimitiveAccelerationStructureFromBytes:withDescriptor:
deserializeInstanceAccelerationStructureFromBytes:primitiveAccelerationStructures:withDescriptor:
newAccelerationStructureWithSize:withDescriptor:
supportsArgumentBuffersTier2
supportsCMPIndirectCommandBuffers
supportsGFXIndirectCommandBuffers
supportsFunctionPointersFromRender
supportsSharedFunctionTables
supportsRaytracing
supportsRaytracingFromRender
supportsStackOverflowErrorCode
supportsForkJoin
supportsMeshShaders
getDynamicLibraryForBaseObject:
getFunctionForBaseObject:library:
supportsResourceUsageValidation
newArgumentEncoderWithBufferBinding:
supportsRayTracingPerPrimitiveData
accelerationStructureComputePipelineState
bufferHeap
boundsCheckOptions
deviceOptions
globalBufferHeap
constantBufferCache
globalICBBufferResidentList
_boundsCheckOptionsData
_argumentDescriptors
_deviceInitFlag
_icbPipelineInit
_icbInheritVertexPipelineState
_icbInheritNoneVertexPipelineState
_icbInheritBuffersVertexPipelineState
_icbDepthStencilState
_icbInheritComputePipelineState
_icbInheritNoneComputePipelineState
_icbInheritBuffersComputePipelineState
_icbInheritBothComputePipelineState
_accelerationStructureComputePipelineState
T@"<MTLRenderPipelineState>",R,N
T@"<MTLDepthStencilState>",R,N
T@"<MTLComputePipelineState>",R,N
T@"<MTLComputePipelineState>",R,N,V_accelerationStructureComputePipelineState
setupMPSFunctionTable:
registerDevices
heapTextureSizeAndAlignWithDescriptor:
heapBufferSizeAndAlignWithLength:options:
newDepthStencilStateWithDescriptor:
newSamplerStateWithDescriptor:
newFence
supportsFeatureSet:
supportsFamily:
supportsTextureSampleCount:
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
getDefaultSamplePositions:count:
supportsRasterizationRateMapWithLayerCount:
newRasterizationRateMapWithDescriptor:
newEvent
newSharedEvent
newSharedEventWithHandle:
newIOHandleWithURL:error:
newIOCommandQueueWithDescriptor:error:
newIOHandleWithURL:compressionMethod:error:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
sparseTileSizeInBytesForSparsePageSize:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:
newCounterSampleBufferWithDescriptor:error:
sampleTimestamps:gpuTimestamp:
supportsCounterSampling:
supportsVertexAmplificationCount:
heapAccelerationStructureSizeAndAlignWithSize:
heapAccelerationStructureSizeAndAlignWithDescriptor:
name
registryID
maxThreadsPerThreadgroup
isLowPower
isHeadless
isRemovable
hasUnifiedMemory
recommendedMaxWorkingSetSize
isDepth24Stencil8PixelFormatSupported
readWriteTextureSupport
argumentBuffersSupport
areRasterOrderGroupsSupported
supports32BitFloatFiltering
supports32BitMSAA
supportsQueryTextureLOD
supportsBCTextureCompression
supportsPullModelInterpolation
areBarycentricCoordsSupported
supportsShaderBarycentricCoordinates
maxThreadgroupMemoryLength
maxArgumentBufferSamplerCount
areProgrammableSamplePositionsSupported
sparseTileSizeInBytes
maxBufferLength
counterSets
supportsDynamicLibraries
supportsFunctionPointers
supportsPrimitiveMotionBlur
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
T{?=QQQ},R
lowPower
TB,R,GisLowPower
headless
TB,R,GisHeadless
removable
TB,R,GisRemovable
depth24Stencil8PixelFormatSupported
TB,R,GisDepth24Stencil8PixelFormatSupported
rasterOrderGroupsSupported
TB,R,GareRasterOrderGroupsSupported
barycentricCoordsSupported
TB,R,GareBarycentricCoordsSupported
programmableSamplePositionsSupported
TB,R,GareProgrammableSamplePositionsSupported
reportLeaks
allowLibrariesFromOtherPlatforms
vendorName
familyName
productName
getMostCompatibleArchitecture:
compilerPropagatesThreadPriority:
_setDeviceWrapper:
_deviceWrapper
deviceSupportsFeatureSet:
deviceOrFeatureProfileSupportsFeatureSet:
minLinearTextureAlignmentForPixelFormat:
unloadShaderCaches
libraryCacheStats
pipelineCacheStats
copyShaderCacheToPath:
supportsSampleCount:
newIndirectArgumentBufferLayoutWithStructType:
supportsTextureWriteRoundingMode:
newIndirectCommandBufferWithDescriptor:maxCount:options:
newIndirectRenderCommandEncoderWithBuffer:
newIndirectComputeCommandEncoderWithBuffer:
newSharedEventWithMachPort:
setResourcesPurgeableState:newState:oldState:count:
isCompatibleWithAccelerationStructure:
deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:
deserializeInstanceAccelerationStructure:fromBytes:primitiveAccelerationStructures:withDescriptor:
validateDynamicLibraryDescriptor:error:
newDynamicLibraryWithDescriptor:error:
validateDynamicLibrary:state:error:
validateDynamicLibraryURL:error:
newProfileWithExecutionSize:
supportsBufferlessClientStorageTexture
supportsComputeMemoryBarrier
supportsRenderMemoryBarrier
supportsReadWriteTextureArgumentsTier2
supportsStreamingCodecSignaling
supportsProgrammableSamplePositions
supportsLargeFramebufferConfigs
supportsCustomBorderColor
supportsSamplerAddressModeClampToHalfBorder
supports3DBCTextures
supportsRGBA10A2Gamma
supportsBGR10A2
supportsPrimitiveRestartOverride
supportsGlobalVariableRelocation
supportsGlobalVariableRelocationCompute
supportsTLS
supports32bpcMSAATextures
supportsVertexAmplification
supportsPlacementHeaps
supportsOpenCLTextureWriteSwizzles
supportsInt64
supportsFixedLinePointFillDepthGradient
supportsLateEvalEvent
supportsNonZeroTextureWriteLOD
supportsSharedTextureHandles
supportsBufferPrefetchStatistics
supportsLimitedYUVFormats
supportsNonPrivateDepthStencilTextures
supportsNonPrivateMSAATextures
supportsSharedStorageHeapResources
supportsSharedStorageTextures
supportsLinearTextureFromSharedBuffer
supportsPipelineLibraries
supportsFragmentOnlyEncoders
supportsBufferWithIOSurface
supportsProgrammableBlending
supportsRenderToLinearTextures
supportsMemorylessRenderTargets
supportsFastMathInfNaNPropagation
supportsInvariantVertexPosition
supportsShaderLODAverage
supportsRelaxedTextureViewRequirements
supportsSeparateDepthStencil
supportsGPUStatistics
supportsCompressedTextureViewSPI
supportsRenderTargetTextureRotation
supportsDynamicControlPointCount
supportsIABHashForTools
supportsBinaryArchives
supportsBinaryLibraries
supportsDeadlineProfile
supportsFillTexture
supportsSetThreadgroupPackingDisabled
supportsASTCTextureCompression
supportsExtendedYUVFormats
supportsPublicXR10Formats
supportsSRGBwrites
supportsDepthClipMode
supportsPacked32TextureBufferWrites
supports3DASTCTextures
supportsExtendedXR10Formats
supportsFragmentBufferWrites
supportsCountingOcclusionQuery
supportsBaseVertexInstanceDrawing
supportsIndirectDrawAndDispatch
supportsTessellation
supportsReadWriteBufferArguments
supportsArrayOfTextures
supportsArrayOfSamplers
supportsCombinedMSAAStoreAndResolveAction
supportsMutableTier1ArgumentBuffers
supportsSamplerCompareFunction
supportsMSAADepthResolve
supportsMSAAStencilResolve
supportsMSAADepthResolveFilter
supportsIndirectStageInRegion
supportsIndirectTextures
supportsNorm16BCubicFiltering
supportsTextureOutOfBoundsReads
supportsTextureSwizzle
supportsAlphaYUVFormats
supportsMemoryOrderAtomics
supportsQuadGroup
supportsRenderTextureWrites
supportsImageBlocks
supportsTileShaders
supportsImageBlockSampleCoverageControl
supportsNativeHardwareFP16
supportsPostDepthCoverage
supportsMipLevelsSmallerThanBlockSize
supportsNonUniformThreadgroupSize
supportsReadWriteTextureArguments
supportsReadWriteTextureCubeArguments
supportsTextureCubeArray
supportsQuadShufflesAndBroadcast
supportsConcurrentComputeDispatch
supportsRenderPassWithoutRenderTarget
supportsRasterOrderGroups
supportsRasterOrderGroupsColorAttachment
supportsLinearTexture2DArray
supportsNonSquareTileShaders
supportsSeparateVisibilityAndShadingRate
supports2DLinearTexArraySPI
supportsLayeredRendering
supportsViewportAndScissorArray
supportsIndirectTessellation
supportsMSAAStencilResolveFilter
supportsStencilFeedback
supportsFP32TessFactors
supportsUnalignedVertexFetch
supportsSIMDGroup
supportsShaderMinLODClamp
supportsSIMDShufflesAndBroadcast
supportsWritableArrayOfTextures
supportsVariableRateRasterization
supportsYCBCRFormats
supportsYCBCRFormatsPQ
supportsYCBCRFormats12
supportsYCBCRFormatsXR
supportsASTCHDRTextureCompression
supportsSparseTextures
supportsSparseHeaps
supportsIndirectWritableTextures
supportsStatefulDynamicLibraries
supportsRayTracingExtendedVertexFormats
supportsHeapAccelerationStructureAllocation
supportsRayTracingBuffersFromTables
supportsRayTracingAccelerationStructureCPUDeserialization
supportsBlackOrWhiteSamplerBorderColors
supportsMirrorClampToEdgeSamplerMode
supportsSIMDReduction
supportsDepthClipModeClampExtended
supportsTexture2DMultisampleArray
supportsForceSeamsOnCubemaps
supportsFloat16BCubicFiltering
supportsFloat16InfNanFiltering
supportsRTZRounding
supportsAnisoSampleFix
supportsYCBCRPackedFormatsPQ
supportsYCBCRPackedFormats12
supportsYCBCRPackedFormatsXR
supportsBufferBoundsChecking
supportsDevicePartitioning
supportsComputeCompressedTextureWrite
supportsSIMDGroupMatrix
supportsInterchangeTiled
supportsQuadReduction
supportsSIMDShuffleAndFill
supportsBfloat16Format
supportsSparseDepthAttachments
supportsAtomicUlongVoidMinMax
supportsLossyCompression
supportsFunctionPointersFromMesh
supportsMeshShadersInICB
supportsCommandBufferJump
supportsRayTracingICBs
supportsExplicitVisibilityGroups
bufferRobustnessSupport
deviceCreationFlags
areGPUAssertionsEnabled
setGPUAssertionsEnabled:
commandBufferErrorOptions
setCommandBufferErrorOptions:
isBCTextureCompressionSupported
targetDeviceInfo
targetDeviceArchitecture
architecture
halfFPConfig
singleFPConfig
doubleFPConfig
metalAssertionsEnabled
setMetalAssertionsEnabled:
featureProfile
simulatorHostFeatureProfile
limits
maxFramebufferStorageBits
linearTextureArrayAlignmentBytes
linearTextureArrayAlignmentSlice
maxTileBuffers
maxTileTextures
maxTileSamplers
maxTileInlineDataSize
minTilePixels
maxColorAttachments
maxVertexAttributes
maxVertexBuffers
maxVertexTextures
maxVertexSamplers
maxVertexInlineDataSize
maxInterpolants
maxFragmentBuffers
maxFragmentTextures
maxFragmentSamplers
maxFragmentInlineDataSize
maxComputeBuffers
maxComputeTextures
maxComputeSamplers
maxComputeInlineDataSize
maxComputeLocalMemorySizes
maxTotalComputeThreadsPerThreadgroup
maxComputeThreadgroupMemory
maxLineWidth
maxPointSize
maxVisibilityQueryOffset
minConstantBufferAlignmentBytes
minBufferNoCopyAlignmentBytes
maxTextureWidth1D
maxTextureWidth2D
maxTextureHeight2D
maxTextureWidth3D
maxTextureHeight3D
maxTextureDepth3D
maxTextureDimensionCube
maxTextureLayers
linearTextureAlignmentBytes
iosurfaceTextureAlignmentBytes
iosurfaceReadOnlyTextureAlignmentBytes
deviceLinearTextureAlignmentBytes
deviceLinearReadOnlyTextureAlignmentBytes
maxFunctionConstantIndices
maxComputeThreadgroupMemoryAlignmentBytes
maxInterpolatedComponents
maxTessellationFactor
maxIndirectBuffers
maxIndirectTextures
maxIndirectSamplers
maxIndirectSamplersPerDevice
maxFenceInstances
maxViewportCount
maxCustomSamplePositions
maxVertexAmplificationFactor
maxVertexAmplificationCount
maxTextureBufferWidth
maxComputeAttributes
maxIOCommandsInFlight
maxPredicatedNestingDepth
maxConstantBufferArguments
supportPriorityBand
sharedMemorySize
dedicatedMemorySize
indirectArgumentBufferCapabilities
isFloat32FilteringSupported
isMsaa32bSupported
isRTZRoundingSupported
defaultTextureWriteRoundingMode
isAnisoSampleFixSupported
isFixedLinePointFillDepthGradientSupported
isLargeMRTSupported
maxRasterizationRateLayerCount
isPlacementHeapSupported
GPUBVHBuilder
requiresRaytracingEmulation
pluginData
setPluginData:
supportsPrimitiveType:
indirectArgumentBufferDecodingData
setIndirectArgumentBufferDecodingData:
resourcePatchingTypeForResourceType:
reserveResourceIndicesForResourceType:indices:indexCount:
reserveGPUAddressRange:
newLateEvalEvent
mapShaderSampleBufferWithBuffer:capacity:size:
unmapShaderSampleBuffer
newFunctionWithGLCoreIR:functionType:
newFunctionWithGLCoreIR:inputsDescription:functionType:
newFunctionWithGLESIR:functionType:
newFunctionWithGLESIR:inputsDescription:functionType:
newFunctionWithGLIR:functionType:
newFunctionWithGLIR:inputsDescription:functionType:
getShaderCacheKeys
getBVHBuilderLock
getRawBVHBuilderPtr
setRawBVHBuilderPtr:
newIndirectArgumentEncoderWithArguments:
newComputePipelineStateWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithGraphs:functions:error:
newLibraryWithGraphsSPI:functions:error:
newPipelineLibraryWithFilePath:error:
startCollectingPipelineDescriptors
startCollectingPipelineDescriptorsUsingPrefixForNames:
endCollectingPipelineDescriptors
serializeRenderPipelineDescriptor:
serializeComputePipelineDescriptor:
newRenderPipelineDescriptorWithSerializedData:deserializationContext:
newComputePipelineDescriptorWithSerializedData:deserializationContext:
serializeStructType:
serializeStructType:version:
newStructTypeWithSerializedData:
newTextureLayoutWithDescriptor:isHeapOrBufferBacked:
newIndirectArgumentEncoderWithLayout:
tileSizeWithSparsePageSize:textureType:pixelFormat:sampleCount:
compileVisibleFunction:withDescriptor:destinationBinaryArchive:error:
compileVisibleFunction:withDescriptor:error:
compileVisibleFunction:withDescriptor:completionHandler:
newResourceGroupFromResources:count:
deserializeCompileTimeStats:addToDictionary:
shaderDebugInfoCaching
setShaderDebugInfoCaching:
isQuadDataSharingSupported
sparseTexturesSupport
isRGB10A2GammaSupported
isCustomBorderColorSupported
isClampToHalfBorderSupported
gpuAssertionsEnabled
TB,GareGPUAssertionsEnabled,SsetGPUAssertionsEnabled:
BCTextureCompressionSupported
TB,R,GisBCTextureCompressionSupported
Tr^{MTLTargetDeviceArch=QI*},R
T@"MTLTargetDeviceArchitecture",R
T@"MTLArchitecture",R
TB,N
Tr^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ},R
Tf,R
T{IndirectArgumentBufferCapabilities=b1b1b1b29},R
quadDataSharingSupported
TB,R,GisQuadDataSharingSupported
float32FilteringSupported
TB,R,GisFloat32FilteringSupported
msaa32bSupported
TB,R,GisMsaa32bSupported
RTZRoundingSupported
TB,R,GisRTZRoundingSupported
AnisoSampleFixSupported
TB,R,GisAnisoSampleFixSupported
FixedLinePointFillDepthGradientSupported
TB,R,GisFixedLinePointFillDepthGradientSupported
largeMRTSupported
TB,R,GisLargeMRTSupported
RGB10A2GammaSupported
TB,R,GisRGB10A2GammaSupported
CustomBorderColorSupported
TB,R,GisCustomBorderColorSupported
ClampToHalfBorderSupported
TB,R,GisClampToHalfBorderSupported
placementHeapSupported
TB,R,GisPlacementHeapSupported
T@"MTLGPUBVHBuilder",R
T@"NSDictionary",C,N
notifyExternalReferencesNonZeroOnDealloc:
unwrapMTLDynamicLibraryDescriptorSPI:
unwrapMTLRenderPipelineDescriptor:
debugPipelineOptions:includePipelinePerfStats:
unwrapMTLComputePipelineDescriptor:
unwrapMTLTileRenderPipelineDescriptor:
unwrapMTLMeshRenderPipelineDescriptor:
unwrapMTLCompileOptions:
unwrapMTLStitchedLibraryDescriptor:
unwrapMTLRelocations:
unwrapMTLFunctionDescriptor:
getSupportedCommandBufferErrorOptions
supportsTextureWriteFPRoundingMode:
unwrapMTLCommandBufferDescriptor:alwaysCopy:
getDepthStencilStateForBaseObject:descriptor:
getSamplerStateForBaseObject:descriptor:
newIOHandleWithURL:compressionType:error:
newUncachedIOHandleWithURL:error:
newUncachedIOHandleWithURL:compressionType:error:
lookupRecompiledBinaryArchive:
isIntegrated
memorySize
functionHandleObjectCache
dynamicLibraryObjectCache
sourceLibraryObjectCache
functionObjectCache
depthStencilObjectCache
samplerObjectCache
_integrated
_memorySize
integrated
TB,R,GisIntegrated,V_integrated
TQ,R,V_memorySize
enableBarrier
setEnableBarrier:
notifyListener:atValue:block:
newSharedEventHandle
signaledValue
setSignaledValue:
waitUntilSignaledValue:timeoutMS:
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:reflection:
patchType
patchControlPointCount
vertexAttributes
stageInputAttributes
functionConstantsDictionary
reflectionWithOptions:
reflectionWithOptions:pipelineLibrary:
reflectionWithOptions:binaryArchives:
reflectionWithOptions:completionHandler:
newArgumentEncoderWithBufferIndex:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:binaryArchives:
bitCodeHash
bitcodeData
newFunctionWithPluginData:bitcodeType:
filePath
lineNumber
unpackedFilePath
renderTargetArrayIndexType
returnType
arguments
functionHandle
T@"MTLType",R
T@"<MTLFunctionHandle>",R,N
initWithFunction:library:
functionInputs
precompiledOutput
functionNames
newExternFunctionWithName:
newFunctionWithDescriptor:destinationArchive:error:
overrideTriple
setOverrideTriple:
setShaderValidationEnabled:
externFunctionNames
libraryIdentifier
T@"NSData",R
T@"NSUUID",R,C
setValue:atIndex:
setValue:withRange:
globalBuffer
setGlobalBuffer:
globalBufferOffset
setGlobalBufferOffset:
T@"<MTLBuffer>",&,N
initWithLibrary:parent:filePath:
newComputePipelineStateWithName:options:reflection:error:
newRenderPipelineStateWithName:options:reflection:error:
setFilePath:
_filePath
T@"NSString",C,N,V_filePath
initWithComputeCommandEncoder:commandBuffer:descriptor:
_initConstantsBuffer:device:
initWithRenderPipelineState:descriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
initWithRenderPipelineState:vertexBinaryFunctions:fragmentBinaryFunctions:tileBinaryFunctions:objectBinaryFunctions:meshBinaryFunctions:withState:device:
initWithRenderPipelineState:tileDescriptor:reflection:device:
initWithRenderPipelineState:meshDescriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
unwrapBinaryFunctions:
functionHandleWithFunction:stage:
newRenderPipelineStateWithAdditionalBinaryFunctions:fragmentAdditionalBinaryFunctions:error:
newTileRenderPipelineStateWithAdditionalBinaryFunctions:error:
newRenderPipelineStateWithAdditionalBinaryFunctions:error:
newVisibleFunctionTableFromVertexStageWithDescriptor:
newVisibleFunctionTableFromFragmentStageWithDescriptor:
newVisibleFunctionTableFromTileStageWithDescriptor:
newVisibleFunctionTableFromObjectStageWithDescriptor:
newVisibleFunctionTableFromMeshStageWithDescriptor:
newVisibleFunctionTableWithDescriptor:stage:
newVertexIntersectionFunctionTableWithDescriptor:
newFragmentIntersectionFunctionTableWithDescriptor:
newTileIntersectionFunctionTableWithDescriptor:
newObjectIntersectionFunctionTableWithDescriptor:
newMeshIntersectionFunctionTableWithDescriptor:
newIntersectionFunctionTableWithDescriptor:stage:
releaseReflection
vertexFunctionData
fragmentFunctionData
tileFunctionData
objectFunctionData
meshFunctionData
internalReflection
userReflection
vertexConstantsBuffer
fragmentConstantsBuffer
tileConstantsBuffer
objectConstantsBuffer
meshConstantsBuffer
indirectStateBuffer
binaryFunctionData
vertexMaxCallStackDepth
fragmentMaxCallStackDepth
meshMaxCallStackDepth
objectMaxCallStackDepth
tileMaxCallStackDepth
_internalReflection
_userReflection
_binaryFunctionData
_vertexFunctionData
_fragmentFunctionData
_tileFunctionData
_objectFunctionData
_meshFunctionData
_retainedFunctions
_indirectStateBuffer
_supportsIndirectCommandBuffers
_vertexMaxCallStackDepth
_fragmentMaxCallStackDepth
_meshMaxCallStackDepth
_objectMaxCallStackDepth
_tileMaxCallStackDepth
T@"NSArray",R,N,V_binaryFunctionData
T@"MTLGPUDebugImageData",R,N
T@"MTLRenderPipelineReflection",R,N
T@"MTLGPUDebugBuffer",R,N
Ti,R,N,V_vertexMaxCallStackDepth
Ti,R,N,V_fragmentMaxCallStackDepth
Ti,R,N,V_meshMaxCallStackDepth
Ti,R,N,V_objectMaxCallStackDepth
Ti,R,N,V_tileMaxCallStackDepth
originalObject
setOriginalObject:
parent
strongParent
setBaseObject:
_parent
_baseObject
_externalReferences
T@,&,N,V_baseObject
renderCommandEncoder
setColorStoreActionOptions:atIndex:
setDepthStoreActionOptions:
setStencilStoreActionOptions:
separateCommits
setSeparateCommits:
sampledRenderCommandEncoderWithProgramInfoBuffer:capacity:
initWithParallelRenderCommandEncoder:parent:descriptor:
isMemorylessRender
setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:
setOpaqueTriangleIntersectionFunctionWithSignature:withRange:
_globalBuffer
setObjectSamplerState:atIndex:
setObjectSamplerStates:withRange:
setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setObjectThreadgroupMemoryLength:atIndex:
setMeshSamplerState:atIndex:
setMeshSamplerStates:withRange:
setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:
textureBarrier
tileWidth
tileHeight
setDepthClipModeSPI:
addSplitHandler:
setCommandDataCorruptModeSPI:
setAlphaTestReferenceValue:
setPointSize:
setClipPlane:p2:p3:p4:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setViewportTransformEnabled:
setProvokingVertexMode:
setPrimitiveRestartEnabled:
setPrimitiveRestartEnabled:index:
setTriangleFrontFillMode:backFillMode:
setTransformFeedbackState:
setDepthCleared
setStencilCleared
useResourceGroup:usage:stages:
setColorResolveTexture:slice:depthPlane:level:atIndex:yInvert:
useRenderPipelineState:
useRenderPipelineStates:count:
setVisibleFunctionTable:atBufferIndex:stage:
setVisibleFunctionTables:withBufferRange:stage:
setIntersectionFunctionTable:atBufferIndex:stage:
setIntersectionFunctionTables:withBufferRange:stage:
setAccelerationStructure:atBufferIndex:stage:
initWithIntersectionFunctionTable:device:descriptor:
initWithIntersectionFunctionTable:device:descriptor:computePipelineState:
initWithIntersectionFunctionTable:device:descriptor:renderPipelineState:
_computePipelineState
_renderPipelineState
_handleBuffer
T@"<MTLIntersectionFunctionTable>",&,D,N
initWithIndirectComputeCommand:commandIndex:indirectCommandBuffer:
_commandIndex
copyParameterDataToBuffer:offset:
physicalSizeForLayer:
mapScreenToPhysicalCoordinates:forLayer:
mapPhysicalToScreenCoordinates:forLayer:
screenSize
physicalGranularity
layerCount
parameterBufferSizeAndAlign
T{?=QQ},R
resetUsingDescriptor:
mutability
minFactor
Tf,R,N
initWithIntersectionFunctionTable:parent:descriptor:stage:
initWithIntersectionFunctionTable:parent:descriptor:pipelineState:stage:
init:flags:
flags
segment
_timer
_stream
_segment
TQ,R,N,V_flags
T{_NSRange=QQ},R,N,V_segment
init:
updateTextureMappings:mode:regions:mipLevels:slices:numRegions:
updateTextureMapping:mode:region:mipLevel:slice:
updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles:
moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
appendSamples:length:
saveCommandBuffer:queue:profilingResults:
_commands
_encoders
_samples
_timestamp
threadgroupSizeMatchesTileSize
imageblockSampleLength
maxTotalThreadsPerObjectThreadgroup
maxTotalThreadsPerMeshThreadgroup
objectThreadExecutionWidth
meshThreadExecutionWidth
maxTotalThreadgroupsPerMeshGrid
newVertexShaderDebugInfo
newFragmentShaderDebugInfo
vertexFunctionHandleWithFunction:
fragmentFunctionHandleWithFunction:
tileFunctionHandleWithFunction:
objectFunctionHandleWithFunction:
meshFunctionHandleWithFunction:
vertexDebugInstrumentationData
fragmentDebugInstrumentationData
tileDebugInstrumentationData
objectDebugInstrumentationData
meshDebugInstrumentationData
explicitVisibilityGroupID
TI,R,N
newVisibleFunctionTableWithDescriptor:selector:
newIntersectionFunctionTableWithDescriptor:selector:
validateCPUReadable
validateCPUWriteable
_heap
TQ,R,N,V_options
containsResource:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
initWithIndirectRenderCommand:commandIndex:indirectCommandBuffer:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
pixelFormat
initWithSamplerState:descriptor:device:
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
rootResource
parentTexture
parentRelativeLevel
parentRelativeSlice
bufferOffset
bufferBytesPerRow
iosurfacePlane
textureType
width
height
depth
mipmapLevelCount
arrayLength
usage
isFramebufferOnly
firstMipmapInTail
tailSizeInBytes
isSparse
allowGPUOptimizedContents
compressionType
swizzle
T@"<MTLResource>",R
T@"<MTLTexture>",R
T@"<MTLBuffer>",R
framebufferOnly
TB,R,GisFramebufferOnly
T{?=CCCC},R,N
rotation
isCompressed
compressionFeedback
swizzleKey
numFaces
isDrawable
compressionFootprint
newCompressedTextureViewWithPixelFormat:textureType:level:slice:
canGenerateMipmapLevels
generateMipmapLevel:slice:
newTextureViewWithPixelFormat:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:
sparseSurfaceDefaultValue
initWithBaseObject:parent:parentTexture:
initWithBaseObject:parent:buffer:
realRootResource
copyFromSlice:mipmapLevel:origin:size:toPixels:rowBytes:imageBytes:
copyFromPixels:rowBytes:imageBytes:toSlice:mipmapLevel:origin:size:
tailSize
_parentTexture
T@"<MTLTexture>",R,V_parentTexture
T@"<MTLBuffer>",R,V_buffer
copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:
copyFromTextureMemory:textureSlice:textureLevel:textureRegion:toLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:
finalizeTextureMemory:
alignment
copyGranularity
watermark
initializeTextureMemory:
T{?=[2Q]},R
initWithBaseRenderPass:commandBuffer:descriptor:
encodeBuffers:offsets:withRange:resultOffset:
initWithCommandBuffer:commandQueue:descriptor:
_lateInit
resourceUsageForBuffer:stage:
resourceUsageForTexture:stage:
_temporaryBufferWithLength:
markBuffer:usage:stages:
markTexture:usage:stages:
markHeap:stages:
encoderIdentifierForEncoderIndex:
_checkReportBuffers
beginingEncoder:type:
endingEncoder:type:
beginUseOfMeshShadersInEncoder:
_newReportBuffer
_allocReportEntryStorageForType:
_encodeResourceTableBuffers:type:
_encodeReportBuffer:type:
_initialized
_stageArgumentEncoder
_vertexComputeReportBuffer
_vertexComputeReportOffset
_fragmentReportOffset
_usedBuffers
_currentPooledBuffer
_currentPooledBufferOffset
_currentEncoderID
_currentReportID
_reportBufferList
_reportEntryList
_encoderLabels
_allocationLock
_tempBufLock
_supportsTileStage
_supportsMeshStage
_hasDeferredBindingObjectAndMeshReportBuffers
_bufferUsageTables
_textureUsageTables
_heapUsageTable
T@"MTLGPUDebugDevice",R,D
initWithResourceStateCommandEncoder:parent:descriptor:
_setDefaults
initWithBlitCommandEncoder:commandBuffer:descriptor:
internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:move:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceSize:toTexture:destinationSlice:destinationLevel:options:sliceCount:levelCount:
validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
validateTextureAccess:region:mipLevel:slice:
canDealloc
canEndEncoding
hasEndEncoding
updatedFences
initWithResourceStateCommandEncoder:commandBuffer:descriptor:
checkEncoderState
validateSparseTextureMappingMode:
hasEndedEncoding
range
setRange:
_label
_range
T@"NSString",C,N,V_label
T{_NSRange=QQ},N,V_range
initWithBuffer:device:options:
initWithBuffer:heap:device:options:
initWithBuffer:device:bytes:options:
copyDebugMarkers
common
pointer
isContentExposedToCPU
setIsContentExposedToCPU:
_common
_debugDevice
_debugMarkers
_isContentExposedToCPU
_pointer
T@"MTLDebugResource",R,N,V_common
Tr^v,R,N,V_pointer
TB,N,V_isContentExposedToCPU
validateCommandQueue:
_commandQueue
initWithCommandQueue:device:
tracePath
_tracePath
T@"NSString",R,N,V_tracePath
validateStoreLoadTransition:atIndex:renderTargetArrayLength:
addPurgeableObject:
addObject:retained:purgeable:
addReferencedObject:internallyRetained:
removeAllReferencedObjects:
testObjectReferenced:wasInternallyRetained:
_removeUsedRenderTargetsExcept:
lockPurgeableObjects
unlockPurgeableObjects
addActiveRenderTargets:
_currentEncoder
_attachmentSet
_prevAttachments
_currAttachments
_purgeableObjectsLock
_referencedPurgeableObjects
_externallyRetainedObjects
_internallyRetainedObjects
_referencedDeadObject
_renderTargetAttachmentLock
_didAddRenderTargetAttachments
_renderTargetAttachments
initWithBinaryArchive:device:
initWithDevice:
setArgumentBuffer:offset:
encodedLength
_argumentEncoder
getVertexBufferAtIndex:
getFragmentBufferAtIndex:
drawArguments
drawIndexedArguments
drawPatchesArguments
drawIndexedPatchesArguments
getTessellationFactorArguments
getObjectBufferAtIndex:
getMeshBufferAtIndex:
drawMeshArguments
initWithCounterSampleBuffer:device:descriptor:
descriptor
_descriptor
_storageMode
T@"MTLCounterSampleBufferDescriptor",R,N,V_descriptor
TQ,R,N,V_storageMode
_newRenderPipelineStateWithTileDescriptor:options:reflection:error:
_newRenderPipelineStateWithTileDescriptor:options:completionHandler:
APITimingEnabled
TB,R,N,V_APITimingEnabled
initWithArgumentEncoder:layout:device:
setArgumentBuffer:startOffset:arrayElement:
setRenderPipelineState:atIndex:
setRenderPipelineStates:withRange:
setComputePipelineState:atIndex:
setComputePipelineStates:withRange:
setIndirectCommandBuffer:atIndex:
setIndirectCommandBuffers:withRange:
newArgumentEncoderForBufferAtIndex:
_layout
initWithComputePipelineState:descriptor:unwrappedDescriptor:reflection:device:
initWithComputePipelineState:binaryFunctions:withState:device:
kernelFunctionData
globalConstantsBuffer
constantOffset
maxCallStackDepth
_kernelFunctionData
_constantOffset
_threadgroupArgumentOffset
_activeThreadgroupMask
_maxCallStackDepth
T@"MTLComputePipelineReflection",R,N
Ti,R,N,V_maxCallStackDepth
validateDeadlineAwareness:
_deadlineAwareState
validateStageInRegion:
_validateAllFunctionArguments
_validateThreadsPerThreadgroup:
endEncoding_private
enumerateBuffersUsingBlock:
enumerateTexturesUsingBlock:
enumerateSamplersUsingBlock:
enumerateThreadgroupMemoryLengthsUsingBlock:
validateFunctionTableUseResource:selectorName:
computePipelineState
_buffers
_textures
_samplers
_threadgroupMemoryLengths
_imageBlockSize
canSetComputePipelineState
hasSetComputePipelineState
hasSetStageInRegion
stageInRegion
hasIndirectSetStageInRegion
allowsNullBufferBinds
T@"<MTLComputePipelineState>",R,N,V_computePipelineState
initWithAccelerationStructureCommandEncoder:parent:
validateRefit:descriptor:destination:scratchBuffer:scratchBufferOffset:options:
initWithBaseObject:parent:function:
initWithBaseObject:parent:function:stage:
initWithComputePipelineState:reflection:parent:descriptor:
getParameter:
functionHandleToDebugFunctionHandle:parentFunction:
isAncestorOf:
validateHandleForSetFunction:
reflection
_maxThreadPositionInGrid
_maxThreadsPerGrid
_maxThreadPositionInThreadgroup
_maxThreadIndexInThreadgroup
_maxThreadsPerThreadgroup
_maxThreadgroupPositionInGrid
_maxThreadgroupsPerGrid
_maxStageInGridSize
_maxStageInGridOrigin
_reflection
T@"<MTLFunction>",R,N,V_function
T@"MTLComputePipelineDescriptor",R,N,V_descriptor
T@"MTLComputePipelineReflection",R,N,V_reflection
optimizedRangeList
initWithIndirectCommandBuffer:device:descriptor:maxCommandCount:options:
_optimizedRangeList
_maxCommandCount
_isRender
T@"NSMutableArray",R
T@"MTLIndirectCommandBufferDescriptor",R
newComputePipelineDescriptorWithName:error:
newRenderPipelineDescriptorWithName:error:
pipelineNames
disableRunTimeCompilation
setDisableRunTimeCompilation:
pipelineCache
functionCache
T@"<MTLPipelineCache>",R,N
constantDataAtIndex:
setAccelerationStructure:atIndex:
setVisibleFunctionTable:atIndex:
setVisibleFunctionTables:withRange:
setIntersectionFunctionTable:atIndex:
setIntersectionFunctionTables:withRange:
layout
T@"_MTLIndirectArgumentBufferLayout",R,N
initWithHeap:descriptor:device:
enumerateBufferIndices:
enumerateTextureIndices:
_newGPUDebugAccelerationStructure:
_enableResourceUsageValidation
_bufferLock
_bufferIndices
_textureLock
_textureIndices
_accelerationStructureLock
_accelerationStructureIndices
initWithBaseObject:structType:parent:
setArgumentBuffer:startOffset:elementIndex:
_currentBuffer
_currentOffset
_reflectionParser
newScratchBufferWithMinimumSize:
complainAboutSloppyTextureUsage
validateMemorylessResource:context:
validateResourceOptions:isTexture:isIOSurface:context:
validateNewBufferArgs:options:context:
notifySamplerStateDeallocated:
validateLinkedFunctions:context:
_newRenderPipelineStateWithDescriptor:options:reflection:error:
_newRenderPipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithDescriptor:options:reflection:error:
_newComputePipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithFunction:options:reflection:error:
_newComputePipelineStateWithFunction:options:completionHandler:
_newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
_newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
addReferenceTrackingCommandBuffer:
removeReferenceTrackingCommandBuffer:
clearRenderEncoder:writeMask:withCheckerboard:
storeValidationEnabled
loadValidationEnabled
_argumentBufferSamplers
_referenceTrackingCommandBufferLock
_referenceTrackingCommandBuffers
_checkerboardRTPipelineCache
_storeValidationEnabled
_loadValidationEnabled
TB,R,V_loadValidationEnabled
TB,R,V_storeValidationEnabled
attachmentWriteMask
_attachmentWriteMask
T@"MTLDepthStencilDescriptor",R,N,V_descriptor
TC,R,N,V_attachmentWriteMask
initWithIndirectCommandBuffer:descriptor:maxCommandCount:resourceOptions:device:
maxCommands
maxVertexBindings
maxFragmentBindings
maxKernelBindings
maxObjectBindings
maxMeshBindings
mayContainDrawMeshes
commandByteStride
inheritsBuffers
inheritsPipelineState
internalICBBuffer
internalDrawOrDispatchIDBuffer
resetAtIndex:
setBuffer:offset:atIndex:forStage:commandIndex:
setTessellationControlPointIndexBuffer:offset:commandIndex:
setRenderPipelineStateBuffers:commandIndex:
setComputePipelineStateBuffers:commandIndex:
setThreadgroupMemoryLength:atIndex:commandIndex:
onExecuteWithRenderEncoder:
onExecuteWithComputeEncoder:
_hasRender
_hasCompute
_inheritsBuffers
_inheritsPipelineState
_argumentStorage
_drawOrDispatchIDBuffer
_maxCommands
_maxVertexBindings
_maxFragmentBindings
_maxKernelBindings
_maxThreadgroupBindings
_maxObjectBindings
_maxMeshBindings
_mayContainDrawMeshes
_commandByteStride
_originalResourceOptions
T@"<MTLBuffer>",R,N
T@"<MTLIndirectCommandBufferSPI>",&,D,N
initWithFunctionHandle:computePiplineState:function:
initWithFunctionHandle:renderPipelineState:stage:function:
initWithParallelRenderCommandEncoder:parent:descriptor:encoderID:
_encoderID
setDescriptor:
T@"MTLAccelerationStructureDescriptor",&,N
_toolsBuffer
removeKey:
getCachedObjectForKey:
getCachedObjectForKey:onMiss:
_map
_lock
_keyRemoveList
_listLock
constantValues
setConstantValues:
_constantValues
T@"MTLFunctionConstantValues",&,V_constantValues
initWithLibrary:parent:type:code:options:
validateDescriptor:expectedClass:
copyConstantValues:
setImageFilterFunctions:imageFilterFunctionInfo:
debugType
setDebugType:
code
setCode:
compileOptions
setCompileOptions:
imageFilterFunctions
imageFilterFunctionInfo
_debugType
_code
_compileOptions
_imageFilterFunctions
_imageFilterFunctionInfo
TQ,N,V_debugType
T@,C,N,V_code
T@"MTLCompileOptions",C,N,V_compileOptions
T@"NSArray",R,N,V_imageFilterFunctions
T^{?=BQ^{?}},R,N,V_imageFilterFunctionInfo
mergeAttachmentWriteMask:
_unknownStoreActions
T@"MTLRenderPassDescriptor",R,C,N,V_descriptor
initWithDesc:renderTargetArrayLength:
intersectsTexture:
attachmentTexture
baseResolveTexture
baseTexture
renderTargetArrayLength
baseLevelOffset
resolveLevelOffset
baseSliceRangeOffset
resolveSliceRangeOffset
_attachmentTexture
_baseResolveTexture
_baseTexture
_renderTargetArrayLength
_baseLevelOffset
_resolveLevelOffset
_baseSliceRangeOffset
_resolveSliceRangeOffset
T@"<MTLTexture>",R,N,V_attachmentTexture
T@"<MTLTexture>",R,N,V_baseResolveTexture
T@"<MTLTexture>",R,N,V_baseTexture
TQ,R,N,V_renderTargetArrayLength
TQ,R,N,V_baseLevelOffset
TQ,R,N,V_resolveLevelOffset
T{_NSRange=QQ},R,N,V_baseSliceRangeOffset
T{_NSRange=QQ},R,N,V_resolveSliceRangeOffset
viewports
scissorRects
viewport
scissorRect
enumerateVertexBuffersUsingBlock:
enumerateVertexTexturesUsingBlock:
enumerateVertexSamplersUsingBlock:
enumerateFragmentBuffersUsingBlock:
enumerateFragmentTexturesUsingBlock:
enumerateFragmentSamplersUsingBlock:
enumerateTileBuffersUsingBlock:
enumerateTileTexturesUsingBlock:
enumerateTileSamplersUsingBlock:
enumerateThreadgroupMemoryUsingBlock:
initWithRenderCommandEncoder:parallelRenderCommandEncoder:descriptor:
_init
validateFramebufferWithRenderPipelineState:context:
_dispatchThreadsPerTile:inRegion:withRenderTargetArrayIndex:
validateFunctionTableUseResource:stages:context:selectorName:
updatePipelineData
validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:
validateCommonDrawErrors:
_validateAllFunctionArguments:
validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:
validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:
setVisibleFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setVisibleFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTable:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
setIntersectionFunctionTables:withBufferRange:maxBuffers:buffers:buffersLength:stage:
setAccelerationStructure:atBufferIndex:maxBuffers:buffers:buffersLength:stage:
frontFacingWinding
cullMode
depthClipMode
lineWidth
depthBias
depthBiasSlopeScale
depthBiasClamp
triangleFillMode
renderPipelineState
peakPerSampleStorage
resolvedSampleCount
depthStencilState
defaultDepthStencilDescriptor
frontStencilRef
backStencilRef
visibilityResultMode
visibilityResultOffset
blendColorRed
blendColorGreen
blendColorBlue
blendColorAlpha
tessellationFactorBufferArgument
tessellationFactorBufferInstanceStride
tessellationFactorScale
_dirtyBits
_openGLModeEnabled
_vertexBuiltinArguments
_attachmentInfo
_previousRenderPipelineStateWithWritesToImageBlock
_resolvedRasterSampleCount
_vertexBuffers
_vertexTextures
_vertexSamplers
_fragmentBuffers
_fragmentTextures
_fragmentSamplers
_tileBuffers
_tileTextures
_tileSamplers
_threadgroupMemoryArguments
_objectBuffers
_objectTextures
_objectSamplers
_objectThreadgroupMemoryLengths
_meshBuffers
_meshTextures
_meshSamplers
_encoderState
_visibilityOffsets
_viewports
_scissorRects
_amplificationMode
_amplificationValue
_vertexAmplificationCount
_updatedFences
_storingRenderTargets
_maxVertexBuffers
_objectThreadsPerTG
_meshThreadsPerTG
_lineWidth
_depthBias
_depthBiasSlopeScale
_depthBiasClamp
_frontStencilRef
_backStencilRef
_blendColorRed
_blendColorGreen
_blendColorBlue
_blendColorAlpha
_tessellationFactorScale
_frontFacingWinding
_cullMode
_depthClipMode
_triangleFillMode
_peakPerSampleStorage
_resolvedSampleCount
_depthStencilState
_defaultDepthStencilDescriptor
_visibilityResultMode
_visibilityResultOffset
_width
_height
_tessellationFactorBufferInstanceStride
_tessellationFactorBufferArgument
TQ,R,N,V_attachmentWriteMask
T^v,R,N
T{?=dddddd},R,N
T{?=QQQQ},R,N
TQ,R,N,V_frontFacingWinding
TQ,R,N,V_cullMode
TQ,R,N,V_depthClipMode
Tf,R,N,V_lineWidth
Tf,R,N,V_depthBias
Tf,R,N,V_depthBiasSlopeScale
Tf,R,N,V_depthBiasClamp
TQ,R,N,V_triangleFillMode
T@"<MTLRenderPipelineState>",R,N,V_renderPipelineState
TQ,R,N,V_peakPerSampleStorage
TQ,R,N,V_resolvedSampleCount
T@"<MTLDepthStencilState>",R,N,V_depthStencilState
T@"MTLDepthStencilDescriptor",R,N,V_defaultDepthStencilDescriptor
TI,R,N,V_frontStencilRef
TI,R,N,V_backStencilRef
TQ,R,N,V_visibilityResultMode
TQ,R,N,V_visibilityResultOffset
Tf,R,N,V_blendColorRed
Tf,R,N,V_blendColorGreen
Tf,R,N,V_blendColorBlue
Tf,R,N,V_blendColorAlpha
TQ,R,V_width
TQ,R,V_height
T{?=BBQ@QQQQQBff},R,N,V_tessellationFactorBufferArgument
TQ,R,N,V_tessellationFactorBufferInstanceStride
Tf,R,N,V_tessellationFactorScale
traceBuffer
_traceBuffer
T@"MTLCountersTraceCommandBuffer",R,N,V_traceBuffer
initWithBlitCommandEncoder:parent:descriptor:encoderID:
TI,R,V_encoderID
initWithVisibleFunctionTable:descriptor:computePipeline:
initWithVisibleFunctionTable:descriptor:renderPipeline:
initWithVisibleFunctionTable:descriptor:device:
_setupCommon
T@"<MTLVisibleFunctionTable>",&,D,N
initWithBaseObject:
T@,R,V_baseObject
initWithComputeCommandEncoder:parent:encoderID:
initWithComputeCommandEncoder:commandBuffer:descriptor:encoderID:
setBufferUsageTable:textureUsageTable:
setKernelReportBuffer:offset:
setComputePipelineStateBuffers:
setAccelerationStructures:withBufferRange:
useResourceInternal:usage:
_commandBufferJumpNestingLevel
_handles
_dispatchID
_reportBuffer
_bufferUsageTable
_textureUsageTable
T@"MTLToolsFunction",R,V_function
convertUserType:
internalArrayTypeFromUserArrayType:
internalStructTypeFromUserStructType:
_initImageData
prepareForRenderPipelineUsage
prepareForComputePipelineUsage
prepareForBinaryFunctionUsage
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:binaryArchives:
data
_argumentLayoutsMutex
_argumentLayouts
initWithPipelineState:reflection:parent:descriptor:
initWithPipelineState:reflection:parent:tileDescriptor:
_updateCachedTilePipelineState
_findMasterStruct:includeImageBlockData:
outputImageBlockData
isImageBlockLayoutInputCompatibleWithOutputOf:
rasterizationEnabled
_updateCachedPipelineState
validateBinaryFunctions:stage:
newVisibleFunctionTableWithDescriptor:stage:selector:
functionHandleToDebugFunctionHandle:parentFunction:stage:
functionHandleWithFunction:stage:selector:
newIntersectionFunctionTableWithDescriptor:withStage:selector:
isMeshShaderPipeline
initWithPipelineState:reflection:parent:meshDescriptor:
_updateCachedMeshPipelineState
_validateThreadgroupSize:stage:context:
tileDescriptor
meshDescriptor
_maxVertexCount
_maxInstanceCount
_maxPatchCount
_rasterSampleCount
_colorPixelFormat
_depthPixelFormat
_stencilPixelFormat
_vertexDescriptorLayoutCount
_vertexDescriptorLayouts
_threadgroupSizeMatchesTileSize
_tileDescriptor
_meshDescriptor
T@"MTLRenderPipelineDescriptor",R,N,V_descriptor
T@"MTLRenderPipelineReflection",R,N,V_reflection
T@"MTLTileRenderPipelineDescriptor",R,N,V_tileDescriptor
meshShaderPipeline
TB,R,GisMeshShaderPipeline
T@"MTLMeshRenderPipelineDescriptor",R,N,V_meshDescriptor
T@"MTLSamplerDescriptor",R,C,N,V_descriptor
validatePixelFormatWithHeap:context:
validateHeapResourceOptions:isTexture:isIOSurface:context:
validateHeapTextureUsage:options:context:
initWithHeap:device:
validateOffset:withRequirements:
_newDebugAccelerationStructure:
validateRaytracingHeap
debugDevice
T@"MTLDebugDevice",R,N,V_debugDevice
initWithBaseTexture:device:buffer:offset:bytesPerRow:
initWithBaseTexture:device:buffer:offset:bytesPerRow:bytesPerImage:
initWithBaseTexture:device:
initWithBaseTexture:device:plane:
initWithBaseTexture:heap:device:
initWithBaseTexture:device:texture:
initWithBaseTexture:device:texture:pixelFormat:
initWithBaseTexture:device:texture:pixelFormat:textureType:levels:slices:
requireUsage:
addUsedRenderTarget:slices:
removeUsedRenderTarget:slices:
bytesPerRow
bytesPerImage
plane
isLinearTexture
_pixelFormatInfo
_usageRequired
_subViewUseLock
_activeSubViews
_isLinearTexture
_bytesPerRow
_bytesPerImage
_plane
TQ,R,N,V_offset
TQ,R,N,V_bytesPerRow
TQ,R,N,V_bytesPerImage
TQ,R,N,V_plane
TB,R,N,V_isLinearTexture
initWithBaseTextureLayout:device:descriptor:
T@"MTLTextureDescriptor",R,C,N,V_descriptor
initWithDynamicLibrary:device:
prepareForUsage
imageData
_imageData
T@"MTLGPUDebugImageData",R,N,V_imageData
_debugBuffer
initWithTexture:heap:device:
initWithTextureView:parentBuffer:heap:device:
initWithTextureView:parentTexture:heap:device:
gpuIdentifier
_identifier
T@"<MTLTextureSPI>",&,D,N
loadBytes:size:sourceHandle:sourceHandleOffset:
loadBuffer:offset:size:sourceHandle:sourceHandleOffset:
loadTexture:slice:level:size:sourceBytesPerRow:sourceBytesPerImage:destinationOrigin:sourceHandle:sourceHandleOffset:
copyStatusToBuffer:offset:
tryCancel
addBarrier
waitForEvent:value:
signalEvent:value:
barrier
isCommitted
loadBuffer:offset:size:handle:handleOffset:
loadTexture:slice:level:size:bytesPerRow:bytesPerImage:dstOrigin:handle:handleOffset:
read:size:offset:stagingBuffer:stagingBufferSize:
readIntoStagingBuffer:offset:stagingBuffer:stagingBufferSize:
read:size:offset:stagingBuffer:stagingBufferSize:needsDecompress:
readIntoStagingBuffer:offset:stagingBuffer:stagingBufferSize:needsDecompress:
stagingBufferSize:offset:
getHandleOffset:offset:
decompress:size:offset:stagingBuffer:stagingBufferSize:
vnioID
enqueueBarrier
internalValidateEvent:
internalValidateLoadBuffer:offset:size:sourceHandle:sourceHandleOffset:
internalValidateLoadBytes:size:sourceHandle:sourceHandleOffset:
internalValidateLoadTexture:slice:level:size:sourceBytesPerRow:sourceBytesPerImage:destinationOrigin:sourceHandle:sourceHandleOffset:
allocateScratchBufferWithMinimumSize:
@48@0:8@16@24Q32@40
Q16@0:8
@16@0:8
v16@0:8
v24@0:8@16
v40@0:8@16Q24Q32
v64@0:8{?=QQQ}16{?=QQQ}40
@"MTLIndirectCommandBufferDescriptor"
@"<MTLIndirectCommandBufferSPI>"
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@32@0:8r^v16Q24
@24@0:8Q16
I16@0:8
@"MTLGPUDebugBuffer"32@0:8r^v16Q24
@"MTLGPUDebugBuffer"24@0:8Q16
@44@0:8@16@24@32I40
@36@0:8@16@24I32
v32@0:8@16Q24
v40@0:8@16@24Q32
v32@0:8Q16Q24
v48@0:8r^@16r^Q24{_NSRange=QQ}32
v40@0:8r^v16Q24Q32
v40@0:8Q16Q24Q32
v40@0:8r^@16{_NSRange=QQ}24
v40@0:8Q16@24Q32
v48@0:8Q16Q24Q32Q40
v56@0:8Q16Q24Q32Q40Q48
v56@0:8Q16Q24Q32@40Q48
v64@0:8Q16Q24Q32@40Q48Q56
v64@0:8Q16Q24@32Q40@48Q56
v80@0:8Q16Q24Q32@40Q48Q56q64Q72
v56@0:8Q16@24Q32@40Q48
v72@0:8Q16Q24Q32@40Q48Q56Q64
v72@0:8Q16@24Q32@40Q48@56Q64
v88@0:8Q16Q24Q32@40Q48@56Q64Q72Q80
v40@0:8{?=QQQ}16
v88@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40
v92@0:8{?=QQQ}16{?={?=QQQ}{?=QQQ}}40I88
v88@0:8{?=QQQ}16{?=QQQ}40{?=QQQ}64
v80@0:8@16Q24{?=QQQ}32{?=QQQ}56
v40@0:8@16{_NSRange=QQ}24
v32@0:8Q16r^{?=II}24
v48@0:8@16Q24{optional<unsigned long>=(?=cQ)B}32
v40@0:8r^@16Q24Q32
v48@0:8r^@16Q24Q32Q40
v32@0:8r^@16Q24
@"MTLGPUDebugCommandBuffer"
{MTLGPUDebugStageBufferHandles="handles"[31Q]"resources"[31@"<MTLGPUDebugResource>"]"offsets"[31Q]"lengths"[31I]"gpu_address"[31[2Q]]"needsFlush"B}
{MTLGPUDebugTileThreadgroup="entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
^{Options=Iiiii{?=b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1}}
{GPUDebugEventUUIDPacket="pipelineStateID"Q"entryPointImageID"Q"encoderID"I"eventID"I}
@"MTLGPUDebugRenderPipelineState"
@"MTLToolsDepthStencilState"
{MTLGPUDebugBufferSubAlloc="buffer"@"<MTLBuffer>""offset"Q}
{?="count"C"mappingsValid"B"mappings"[2{?="viewportArrayIndexOffset"I"renderTargetArrayIndexOffset"I}]}
@"<MTLBuffer>"
Q24@0:8Q16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v32@0:8{_NSRange=QQ}16
{MTLResourceID=Q}16@0:8
@"<MTLIndirectRenderCommand>"24@0:8Q16
@"<MTLIndirectComputeCommand>"24@0:8Q16
v32@0:8^^v16^Q24
@"<MTLFunction>"16@0:8
@"<MTLFunctionLogDebugLocation>"16@0:8
v24@0:8Q16
@"MTLGPUDebugImageData"
@"NSArray"
@"NSString"
@"<MTLFunction>"
@"<MTLFunctionLogDebugLocation>"
i16@0:8
v20@0:8i16
@"MTLArgument"
@"<MTLProgramAddressTable>"16@0:8
v136@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112
v120@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96
v128@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96Q120
v120@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112
v128@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112Q120
v44@0:8@16{_NSRange=QQ}24C40
v80@0:8@16Q24Q32@40Q48Q56Q64Q72
v32@0:8@16@24
v56@0:8@16Q24@32Q40Q48
v108@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@92Q100
v88@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80
v56@0:8@16{_NSRange=QQ}24@40Q48
v36@0:8@16Q24B32
v24@0:8@"<MTLResource>"16
v40@0:8@"<MTLTexture>"16Q24Q32
v136@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112
v120@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96
v128@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96Q120
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112
v128@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112Q120
v24@0:8@"<MTLTexture>"16
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24C40
v80@0:8@"<MTLTexture>"16Q24Q32@"<MTLTexture>"40Q48Q56Q64Q72
v32@0:8@"<MTLTexture>"16@"<MTLTexture>"24
v56@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40Q48
v24@0:8@"<MTLFence>"16
v108@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@"<MTLBuffer>"92Q100
v88@0:8@"<MTLTexture>"16{?={?=QQQ}{?=QQQ}}24Q72Q80
v40@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24
v56@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24@"<MTLIndirectCommandBuffer>"40Q48
v36@0:8@"<MTLCounterSampleBuffer>"16Q24B32
v56@0:8@"<MTLCounterSampleBuffer>"16{_NSRange=QQ}24@"<MTLBuffer>"40Q48
v144@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136
v44@0:8@16{_NSRange=QQ}24I40
v104@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
v144@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112Q136
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24I40
v104@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40r^v88Q96
v120@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88
v128@0:8@"<MTLTexture>"16Q24Q32{?={?=QQQ}{?=QQQ}}40{?=dddd}88Q120
@32@0:8@16@24
@40@0:8@16@24@32
v40@0:8@16f24f28Q32
v56@0:8r^@16r^f24r^f32{_NSRange=QQ}40
v48@0:8@16Q24@32Q40
v64@0:8{?=dddddd}16
v32@0:8r^{?=dddddd}16Q24
v20@0:8f16
v28@0:8f16f20f24
v48@0:8{?=QQQQ}16
v32@0:8r^{?=QQQQ}16Q24
v20@0:8I16
v24@0:8I16I20
v32@0:8f16f20f24f28
v56@0:8@16Q24Q32Q40Q48
v60@0:8@16Q24Q32Q40B48Q52
v48@0:8@16Q24Q32Q40
v52@0:8@16Q24Q32Q40B48
@"MTLCountersTraceRenderCommandEncoder"
@32@0:8{_NSRange=QQ}16
@"NSData"32@0:8{_NSRange=QQ}16
@32@0:8@16^@24
v32@0:8@16@?24
@24@0:8@16
@40@0:8@16@24^@32
v40@0:8@16@24@?32
@48@0:8@16@24@32^@40
v48@0:8@16@24@32@?40
B32@0:8r^@16Q24
i20@0:8I16
B24@0:8@"<MTLResource>"16
^v16@0:8
@40@0:8@16Q24Q32
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@48@0:8@16Q24Q32Q40
^{__IOSurface=}16@0:8
@"<MTLTexture>"48@0:8@"MTLTextureDescriptor"16Q24Q32Q40
v24@0:8@?16
v32@0:8@16d24
d16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
v24@0:8@"<MTLDrawable>"16
v32@0:8@"<MTLDrawable>"16d24
@"<MTLBlitCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLComputeCommandEncoder>"24@0:8@"MTLComputePassDescriptor"16
@"<MTLBlitCommandEncoder>"24@0:8@"MTLBlitPassDescriptor"16
@"<MTLComputeCommandEncoder>"16@0:8
@"<MTLComputeCommandEncoder>"24@0:8Q16
v32@0:8@"<MTLEvent>"16Q24
@"<MTLParallelRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLResourceStateCommandEncoder>"16@0:8
@"<MTLResourceStateCommandEncoder>"24@0:8@"MTLResourceStatePassDescriptor"16
@"<MTLAccelerationStructureCommandEncoder>"16@0:8
@"<MTLAccelerationStructureCommandEncoder>"24@0:8@"MTLAccelerationStructurePassDescriptor"16
@"<MTLCommandQueue>"16@0:8
@"<MTLLogContainer>"16@0:8
@"NSError"16@0:8
v56@0:8@16Q24r^Q32r^Q40Q48
B24@0:8Q16
v20@0:8B16
^v24@0:8^Q16
@40@0:8@16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
v36@0:8@16Q24I32
v40@0:8Q16r^@24Q32
v24@0:8@"<MTLResourceGroupSPI>"16
v48@0:8@"<MTLResourceGroupSPI>"16Q24Q32Q40
v56@0:8@"<MTLResourceGroupSPI>"16Q24r^Q32r^Q40Q48
v24@0:8@"<MTLHeap>"16
v24@0:8@"NSArray"16
v32@0:8@"<MTLDrawable>"16@"NSDictionary"24
@"NSDictionary"16@0:8
@"NSMutableDictionary"16@0:8
@"<MTLDeadlineProfile>"16@0:8
@"<MTLRenderCommandEncoder>"40@0:8@"MTLRenderPassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@"<MTLComputeCommandEncoder>"40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"40@0:8@"MTLComputePassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLDebugCommandEncoder>"16@0:8
v36@0:8@"<MTLEvent>"16Q24I32
B24@0:8@"MTLToolsObject"16
@"NSMutableSet"16@0:8
v40@0:8@16Q24@32
v44@0:8i16Q20r^@28Q36
{?="hasCommit"b1"addedCompletedHandler"b1"addedScheduledHandler"b1"padding"b29}
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
{vector<void (^)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__begin_"^@?"__end_"^@?"__end_cap_"{__compressed_pair<void (^*)(id<MTLCommandBuffer>), std::allocator<void (^)(id<MTLCommandBuffer>)>>="__value_"^@?}}
@"MTLToolsDeadlineProfile"
@"NSMutableSet"
v28@0:8I16I20I24
@"<MTLToolsRetainingContainer>"
v40@0:8@16Q24^v32
@40@0:8^Q16^v24^B32
{vector<std::pair<NSData *, unsigned long>, std::allocator<std::pair<NSData *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<NSData *, unsigned long> *, std::allocator<std::pair<NSData *, unsigned long>>>="__value_"^v}}
{__wrap_iter<std::pair<NSData *, unsigned long> *>="__i"^v}
@"<MTLCommandBuffer>"16@0:8
@"<MTLCommandBuffer>"24@0:8@"MTLCommandBufferDescriptor"16
B28@0:8Q16S24
i24@0:8@16
i32@0:8@16Q24
v24@0:8@"NSObject<OS_dispatch_queue>"16
@"NSObject<OS_dispatch_queue>"16@0:8
@"MTLCommandQueueSPIStats"16@0:8
@"NSArray"16@0:8
i24@0:8@"NSArray"16
i32@0:8@"NSArray"16Q24
@"NSArray"24@0:8@"NSArray"16
v24@0:8@?<v@?@"<MTLCommandBuffer>"@"NSData"Q>16
@?32@0:8^B16@24
@"MTLToolsPerfCounterMailbox"
@48@0:8@16@24@32Q40
@56@0:8@16@24@32@40Q48
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__cxx_atomic_base_impl<int>>="__a_value"Ai}}
@"MTLToolsObject"
B32@0:8@16^@24
B32@0:8@"NSURL"16^@24
B40@0:8@16Q24^@32
r^{?=[32C]}16@0:8
B40@0:8@"NSURL"16Q24^@32
@"NSString"24@0:8Q16
@"NSObject<OS_dispatch_data>"16@0:8
@"MTLDebugInstrumentationData"16@0:8
v24@0:8@"MTLDebugInstrumentationData"16
B40@0:8@16@24^@32
B32@0:8@"MTLComputePipelineDescriptor"16^@24
B32@0:8@"MTLRenderPipelineDescriptor"16^@24
B32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
B40@0:8@"MTLFunctionDescriptor"16@"<MTLLibrary>"24^@32
@24@0:8^@16
@40@0:8Q16^I24^@32
v32@0:8@16r^{?=[32C]}24
@24@0:8r^{?=[32C]}16
^{MTLPipelineCollection=}16@0:8
B24@0:8@?16
v32@0:8@"MTLBinaryEntry"16@"MTLBinaryKey"24
@"MTLBinaryEntry"24@0:8@"MTLBinaryKey"16
@"NSString"24@0:8^@16
@"<NSObject>"40@0:8Q16^I24^@32
@"NSMutableArray"16@0:8
B40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
B40@0:8@"MTLRenderPipelineDescriptor"16Q24^@32
B40@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32
B32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
B40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32
v32@0:8@"NSObject<OS_dispatch_data>"16r^{?=[32C]}24
@"NSObject<OS_dispatch_data>"24@0:8r^{?=[32C]}16
B32@0:8@"MTLStitchedLibraryDescriptor"16^@24
B24@0:8@"MTLComputePipelineDescriptor"16
B24@0:8@"MTLRenderPipelineDescriptor"16
B24@0:8@"MTLTileRenderPipelineDescriptor"16
B24@0:8@"MTLMeshRenderPipelineDescriptor"16
B24@0:8@?<B@?^{?=[32C]}@"NSObject<OS_dispatch_data>">16
@32@0:8Q16Q24
@40@0:8Q16Q24Q32
@32@0:8@16Q24
q16@0:8
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLBuffer>"40@0:8Q16Q24Q32
@"<MTLTexture>"32@0:8@"MTLTextureDescriptor"16Q24
@"<MTLAccelerationStructure>"24@0:8Q16
@"<MTLAccelerationStructure>"24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLAccelerationStructure>"32@0:8Q16Q24
@"<MTLAccelerationStructure>"32@0:8@"MTLAccelerationStructureDescriptor"16Q24
@"<MTLAccelerationStructure>"40@0:8Q16Q24Q32
v64@0:8{?={?=QQQ}{?=QQQ}}16
v56@0:8@16Q24{?=QQQ}32
v24@0:8@"<MTLComputePipelineState>"16
v40@0:8@"<MTLBuffer>"16Q24Q32
v32@0:8@"<MTLVisibleFunctionTable>"16Q24
v32@0:8@"<MTLIntersectionFunctionTable>"16Q24
v32@0:8@"<MTLAccelerationStructure>"16Q24
v32@0:8@"<MTLTexture>"16Q24
v32@0:8@"<MTLSamplerState>"16Q24
v40@0:8@"<MTLSamplerState>"16f24f28Q32
v32@0:8@"<MTLBuffer>"16Q24
v56@0:8@"<MTLBuffer>"16Q24{?=QQQ}32
v32@0:8@"<MTLResource>"16Q24
v40@0:8@"<MTLIndirectCommandBuffer>"16@"<MTLBuffer>"24Q32
B44@0:8@16Q24Q32I40
v44@0:8@16Q24Q32I40
@"NSData"16@0:8
v32@0:8@"<MTLResourceGroupSPI>"16Q24
B44@0:8@"<MTLBuffer>"16Q24Q32I40
v44@0:8@"<MTLBuffer>"16Q24Q32I40
@"MTLGPUDebugBuffer"
@"MTLGPUDebugDevice"
{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{KeyBufferPair="key"{Key="hash"{?="key"[32C]}"data"@"NSData"}"buffer"@"<MTLBuffer>"}
@"MTLDebugInstrumentationData"
@"MTLGPUDebugFunction"
@"MTLGPUDebugDynamicLibrary"
v48@0:8@16@24@32Q40
v56@0:8@16@24@32@40Q48
v64@0:8@16@24@32@40Q48Q56
v48@0:8@16@24Q32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLBuffer>"32Q40
v56@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48
v64@0:8@"<MTLAccelerationStructure>"16@"MTLAccelerationStructureDescriptor"24@"<MTLAccelerationStructure>"32@"<MTLBuffer>"40Q48Q56
v32@0:8@"<MTLAccelerationStructure>"16@"<MTLAccelerationStructure>"24
v40@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32Q40
v48@0:8@16@24Q32@40
v56@0:8@16@24@32Q40@48
B32@0:8@16@24
v120@0:8@16@24Q32@40Q48@56Q64@72Q80@88Q96@104Q112
v48@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40
v48@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"MTLAccelerationStructureDescriptor"40
v56@0:8@"<MTLAccelerationStructure>"16@"NSArray"24@"<MTLBuffer>"32Q40@"MTLAccelerationStructureDescriptor"48
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBufferSizesSPI"24
B32@0:8@"<MTLAccelerationStructure>"16@"MTLGenericBVHBuffersSPI"24
v120@0:8@"<MTLAccelerationStructure>"16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64@"<MTLBuffer>"72Q80@"<MTLBuffer>"88Q96@"<MTLBuffer>"104Q112
Q40@0:8{?=QQQ}16
@"<MTLFunctionHandle>"24@0:8@"<MTLFunction>"16
@"<MTLComputePipelineState>"32@0:8@"NSArray"16^@24
@"<MTLVisibleFunctionTable>"24@0:8@"MTLVisibleFunctionTableDescriptor"16
@"<MTLIntersectionFunctionTable>"24@0:8@"MTLIntersectionFunctionTableDescriptor"16
v32@0:8@"MTLGPUDebugComputeCommandEncoder"16Q24
v48@0:8@"MTLGPUDebugRenderCommandEncoder"16Q24{optional<unsigned long>=(?=cQ)B}32
@"<MTLResource>"16@0:8
@48@0:8@16@24Q32Q40
@52@0:8@16@24Q32Q40B48
@60@0:8@16@24@32Q40Q48B56
^v24@0:8Q16
{?={?=QQQ}{?=QQQ}}16@0:8
@"_MTLIndirectDispatchThreadgroupsArguments"16@0:8
@"_MTLIndirectDispatchThreadsArguments"16@0:8
@"_MTLImageBlockArguments"16@0:8
v24@0:8^Q16
@32@0:8^@16^Q24
@32@0:8@16^Q24
@48@0:8@16Q24^@32^@40
v40@0:8@16Q24@?32
@40@0:8@16r^{?=BQ^{?}}24^@32
@40@0:8@16Q24^@32
@48@0:8@16@24Q32^@40
@40@0:8Q16@24^@32
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@24@0:8^{__IOSurface=}16
@48@0:8r^v16Q24Q32Q40
@56@0:8^v16Q24Q32Q40@?48
@40@0:8@16^{__IOSurface=}24Q32
@48@0:8^v16Q24@32@?40
{?=QQQ}24@0:8@16
@32@0:8^v16@24
@40@0:8^v16@24@32
@32@0:8Q16@24
{MetalBufferHeap="_mutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_buffers"{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}"_freeList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_currentFreeIndex"i"_totalMemoryAllocated"Q"_totalMemoryInUse"Q"_bufferLength"Q"_device"@"MTLGPUDebugDevice"}
{Options="version"I"mode"i"programTypes"i"accessTypes"i"failMode"i""{?="enableReporting"b1"packPointerAddresses"b1"unpackPointerAddress"b1"forceInline"b1"enableBacktracking"b1"optimizeConstantDeref"b1"skipVertexFetchLoads"b1"enableGEPOptimization"b1"emitBoundsChecking"b1"runStandardOptimizations"b1"backtrackFailuresAssumeSafe"b1"pageDataIs32bitLength"b1"forceUnrollLoops"b1"mergeAccessChecks"b1"convertToAB"b1"arraysOfBuffersAB"b1"noInlineTrivialFunctions"b1"unrollMemCpyWA"b1"checkGlobalConstants"b1"enableTextureChecks"b1"demoteGlobalConstantsToArg"b1"argumentPointerIndirection"b1"enableThreadgroupMemoryChecks"b1"mergeThreadgroupGlobals"b1"mergeThreadgroupArguments"b1"tagThreadgroupPointers"b1"noInlineCheckFunctions"b1"enableJumpThreading"b1"enableICBSupport"b1"enableGlobalRelocations"b1"enableTrapReporting"b1"enableRaytracing"b1"enableResourceUsageValidation"b1"enableStackOverflow"b1}}
{GPUDebugDeviceOptions="retainReflection"b1"retainPSOFunctions"b1"abortOnFault"b1}
{GPUDebugBufferDescriptorHeap="s"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_freeIndexList"{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}"_bufferList"{vector<MTLGPUDebugBuffer *, std::allocator<MTLGPUDebugBuffer *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<MTLGPUDebugBuffer **, std::allocator<MTLGPUDebugBuffer *>>="__value_"^@}}"_freeIndex"Q"_argumentEncoder"@"<MTLArgumentEncoder>""_descriptorHeap"@"<MTLBuffer>"}
{GPUDebugConstantBufferCache="_totalUsedMemory"Q"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_cache"{unordered_map<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, std::allocator<std::pair<const GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__table_"{__hash_table<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>, std::allocator<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, std::equal_to<GPUDebugConstantBufferCache::Key>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::equal_to<GPUDebugConstantBufferCache::Key>, GPUDebugConstantBufferCache::Key::Hash, true>>="__value_"f}}}"_device"@"MTLGPUDebugDevice"}
{GlobalResidentBufferList="_iteration"I"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_bufferList"{list<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__end_"{__list_node_base<id<MTLBuffer>, void *>="__prev_"^v"__next_"^v}"__size_alloc_"{__compressed_pair<unsigned long, std::allocator<std::__list_node<id<MTLBuffer>, void *>>>="__value_"Q}}}
@"NSData"
@"NSMutableArray"
{once_flag="__state_"Q}
@"<MTLRenderPipelineState>"
@"<MTLDepthStencilState>"
@"<MTLComputePipelineState>"
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
B24@0:8q16
v32@0:8^{?=ff}16Q24
@40@0:8@16q24^@32
{?=QQQ}40@0:8Q16Q24Q32
Q24@0:8q16
{?=QQQ}48@0:8Q16Q24Q32q40
v32@0:8^Q16^Q24
{?=QQ}24@0:8Q16
{?=QQQ}16@0:8
v72@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56Q64
v64@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56
@"<MTLCommandQueue>"24@0:8Q16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptor"16^@24
v32@0:8@"MTLStitchedLibraryDescriptor"16@?<v@?@"<MTLLibrary>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLRenderPipelineState>"48@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLRasterizationRateMap>"24@0:8@"MTLRasterizationRateMapDescriptor"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@"<MTLIOFileHandle>"32@0:8@"NSURL"16^@24
@"<MTLIOCommandQueue>"32@0:8@"MTLIOCommandQueueDescriptor"16^@24
@"<MTLIOFileHandle>"40@0:8@"NSURL"16q24^@32
@"<MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
@"<MTLArgumentEncoder>"24@0:8@"<MTLBufferBinding>"16
@"<MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
@"<MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
@"<MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
{?=QQQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=QQ}24@0:8@"MTLAccelerationStructureDescriptor"16
{?=II}16@0:8
@20@0:8I16
B44@0:8^@16Q24^Q32i40
B24@0:8{?=II}16
v40@0:8@16r^v24@32
v48@0:8@16r^v24@32@40
B36@0:8@16B24^@28
r^{MTLTargetDeviceArch=QI*}16@0:8
r^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ}16@0:8
f16@0:8
{IndirectArgumentBufferCapabilities=b1b1b1b29}16@0:8
v24@0:8^{MPSFunctionTable=}16
v40@0:8Q16^Q24Q32
B32@0:8{_NSRange=QQ}16
B40@0:8^{?=III}16Q24Q32
@32@0:8^v16Q24
@40@0:8^v16@24Q32
^{os_unfair_lock_s=I}16@0:8
@28@0:8@16I24
@28@0:8@16B24
{?=QQQ}48@0:8q16Q24Q32Q40
v48@0:8@16@24@32^@40
v40@0:8@16@24^@32
@32@0:8r^@16Q24
@"MTLArchitecture"24@0:8@"NSArray"16
v24@0:8@"<MTLDeviceSPI>"16
@"<MTLBuffer>"24@0:8^{__IOSurface=}16
B24@0:8@"NSString"16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
@"_MTLIndirectArgumentBufferLayout"24@0:8@"MTLStructType"16
@"<MTLArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLIndirectRenderCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLIndirectComputeCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLSharedEvent>"20@0:8I16
@"<MTLAccelerationStructure>"32@0:8@"<MTLBuffer>"16Q24
@"<MTLAccelerationStructure>"40@0:8@"<MTLBuffer>"16Q24Q32
@"<MTLAccelerationStructure>"32@0:8^v16@"MTLAccelerationStructureDescriptor"24
@"<MTLAccelerationStructure>"40@0:8^v16@"NSArray"24@"MTLAccelerationStructureDescriptor"32
@"<MTLAccelerationStructure>"32@0:8Q16@"MTLAccelerationStructureAllocationDescriptor"24
v40@0:8@"<MTLAccelerationStructure>"16r^v24@"MTLAccelerationStructureDescriptor"32
v48@0:8@"<MTLAccelerationStructure>"16r^v24@"NSArray"32@"MTLAccelerationStructureDescriptor"40
@"<MTLDynamicLibrary>"40@0:8@"<MTLLibrary>"16@"MTLComputePipelineDescriptor"24^@32
B32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"32@0:8@"MTLDynamicLibraryDescriptorSPI"16^@24
@"<MTLDynamicLibrary>"40@0:8@"NSURL"16Q24^@32
@"NSArray"32@0:8@"MTLComputePipelineDescriptor"16^@24
@"NSArray"40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
@"NSArray"40@0:8@"MTLFunction"16@"NSArray"24^@32
@"NSArray"48@0:8@"MTLFunction"16@"NSArray"24Q32^@40
B36@0:8@"<MTLLibrary>"16B24^@28
@"<MTLBinaryArchive>"40@0:8Q16@"NSURL"24^@32
@"<MTLRenderPipelineState>"32@0:8@"MTLMeshRenderPipelineDescriptor"16^@24
v32@0:8@"MTLMeshRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLDeadlineProfile>"24@0:8Q16
@"MTLTargetDeviceArchitecture"16@0:8
@"MTLArchitecture"16@0:8
@"MTLGPUBVHBuilder"16@0:8
v24@0:8@"NSDictionary"16
v24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLBuffer>"48@0:8r^v16Q24Q32Q40
@"<MTLBuffer>"56@0:8^v16Q24Q32Q40@?<v@?^vQ>48
@"<MTLBuffer>"24@0:8@"MTLBufferDescriptor"16
@"<MTLLateEvalEvent>"16@0:8
@"<MTLComputePipelineState>"32@0:8@"MTLComputePipelineDescriptor"16^@24
v32@0:8@"MTLComputePipelineDescriptor"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
v32@0:8@"MTLTileRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLFunction>"32@0:8^v16Q24
@"<MTLFunction>"40@0:8^v16@"NSObject<OS_dispatch_data>"24Q32
v24@0:8@"MTLGPUBVHBuilder"16
@"<MTLIndirectArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLComputePipelineState>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLLibrary>"40@0:8@"NSString"16@"NSArray"24^@32
@"<MTLLibrary>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptorSPI"16^@24
@"NSString"24@0:8@"NSArray"16
@"<MTLLibrary>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLPipelineLibrarySPI>"32@0:8@"NSString"16^@24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLRenderPipelineDescriptor"16
@"NSObject<OS_dispatch_data>"24@0:8@"MTLComputePipelineDescriptor"16
@"MTLRenderPipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"MTLComputePipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLStructType"16
@"NSObject<OS_dispatch_data>"28@0:8@"MTLStructType"16I24
@"MTLStructType"24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLTexture>"48@0:8^v16Q24@"MTLTextureDescriptor"32@?<v@?^vQ>40
@"<MTLTextureLayout>"28@0:8@"MTLTextureDescriptor"16B24
@"<MTLIndirectArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
v48@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@"<MTLBinaryArchive>"32^@40
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24^@32
v40@0:8@"<MTLFunction>"16@"MTLFunctionDescriptor"24@?<v@?@"NSError">32
@"<MTLResourceGroupSPI>"32@0:8r^@16Q24
v32@0:8@"NSObject<OS_dispatch_data>"16@"NSMutableDictionary"24
Q28@0:8Q16B24
@"<MTLDeviceSPI>"
@"MTLToolsObjectCache"
v40@0:8@"MTLSharedEventListener"16Q24@?<v@?@"<MTLSharedEvent>"Q>32
@"MTLSharedEventHandle"16@0:8
B32@0:8Q16Q24
@32@0:8Q16^@24
@"<MTLArgumentEncoder>"24@0:8Q16
@"<MTLArgumentEncoder>"32@0:8Q16^@24
v32@0:8Q16@?24
@40@0:8Q16^@24@32
@28@0:8@16C24
@"MTLFunctionReflection"24@0:8Q16
@"MTLFunctionReflection"32@0:8Q16@"<MTLPipelineLibrary>"24
@"MTLFunctionReflection"32@0:8Q16@"NSArray"24
v32@0:8Q16@?<v@?@"MTLFunctionReflection">24
@"<MTLArgumentEncoder>"32@0:8Q16@"<MTLPipelineLibrary>"24
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"<MTLPipelineLibrary>"32
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"NSArray"32
@"<MTLFunction>"28@0:8@"NSData"16C24
@"MTLType"16@0:8
@"<MTLFunctionHandle>"16@0:8
@"<MTLFunction>"24@0:8@"NSString"16
@"<MTLFunction>"40@0:8@"NSString"16@"MTLFunctionConstantValues"24^@32
v40@0:8@"NSString"16@"MTLFunctionConstantValues"24@?<v@?@"<MTLFunction>"@"NSError">32
v32@0:8@"MTLFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLFunctionDescriptor"16^@24
v32@0:8@"MTLIntersectionFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLIntersectionFunctionDescriptor"16^@24
@"<MTLFunction>"48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32^@40
v48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32@?<v@?@"<MTLFunction>"@"NSError">40
@"<MTLFunction>"40@0:8@"MTLFunctionDescriptor"16@"<MTLBinaryArchive>"24^@32
@"NSUUID"16@0:8
v32@0:8@"<MTLFunctionHandle>"16Q24
v40@0:8Q16{_NSRange=QQ}24
@"<MTLBuffer>"16@0:8
v24@0:8@"<MTLBuffer>"16
@"MTLCountersTraceComputeCommandEncoder"
@64@0:8@16@24@32@40@48Q56
@80@0:8@16@24@32@40@48@56@64@72
@48@0:8@16@24@32@40
@"MTLRenderPipelineReflection"
@"MTLToolsDevice"
@"<MTLRenderCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
v24@0:8@"<MTLRenderPipelineState>"16
v24@0:8@"<MTLDepthStencilState>"16
v80@0:8@"<MTLBuffer>"16Q24{?=QQQ}32{?=QQQ}56
v64@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56
v56@0:8Q16Q24Q32@"<MTLBuffer>"40Q48
v80@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56q64Q72
v40@0:8Q16@"<MTLBuffer>"24Q32
v64@0:8Q16Q24@"<MTLBuffer>"32Q40@"<MTLBuffer>"48Q56
v32@0:8@"<MTLFence>"16Q24
v72@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64
v56@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48
v88@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80
v72@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64
v40@0:8@"<MTLResource>"16Q24Q32
v32@0:8@"<MTLHeap>"16Q24
v40@0:8f16f20f24f28Q32
v44@0:8@16f24f28f32Q36
v28@0:8B16Q20
v24@0:8@?<v@?@"<MTLRenderCommandEncoderSPI>"Q>16
v48@0:8@"<MTLTexture>"16Q24@"<MTLSamplerState>"32Q40
v44@0:8@"<MTLSamplerState>"16f24f28f32Q36
v56@0:8@"<MTLTexture>"16Q24Q32Q40Q48
v60@0:8@"<MTLTexture>"16Q24Q32Q40B48Q52
v48@0:8@"<MTLTexture>"16Q24Q32Q40
v52@0:8@"<MTLTexture>"16Q24Q32Q40B48
v40@0:8@"<MTLResourceGroupSPI>"16Q24Q32
v60@0:8@16Q24Q32Q40Q48B56
v48@0:8r^@16{_NSRange=QQ}24Q40
@"MTLGPUDebugComputePipelineState"
@40@0:8@16Q24@32
{?=QQQ}24@0:8Q16
{?=ff}32@0:8{?=ff}16Q24
{?=QQ}16@0:8
v24@0:8@"MTLRasterizationRateMapDescriptor"16
@32@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16Q24
{_NSRange=QQ}16@0:8
^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}
{_NSRange="location"Q"length"Q}
@24@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16
v80@0:8Q16Q24Q32@40Q48Q56Q64Q72
v64@0:8@16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v64@0:8@16Q24Q32@40Q48Q56
@20@0:8B16
v32@0:8r^v16Q24
v40@0:8r^v16@24@32
{BinaryBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}"_timebase"{mach_timebase_info="numer"I"denom"I}}
{AppendBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}}
@"<MTLFunctionHandle>"32@0:8@"<MTLFunction>"16Q24
@"<MTLVisibleFunctionTable>"32@0:8@"MTLVisibleFunctionTableDescriptor"16Q24
@"<MTLIntersectionFunctionTable>"32@0:8@"MTLIntersectionFunctionTableDescriptor"16Q24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineFunctionsDescriptor"16^@24
@"<MTLRenderPipelineState>"40@0:8@"NSArray"16@"NSArray"24^@32
@"<MTLRenderPipelineState>"32@0:8@"NSArray"16^@24
@32@0:8@16:24
@"MTLToolsHeap"
v112@0:8Q16Q24Q32@40Q48@56Q64Q72Q80@88Q96Q104
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLTexture>"16@0:8
@48@0:8Q16Q24Q32Q40
@72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
@"<MTLTexture>"48@0:8Q16Q24Q32Q40
@"<MTLTexture>"32@0:8Q16Q24
@"<MTLTexture>"72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@"<MTLTexture>"76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
v104@0:8Q16Q24{?=QQQ}32{?=QQQ}56^v80Q88Q96
v104@0:8r^v16Q24Q32Q40Q48{?=QQQ}56{?=QQQ}80
@"<MTLTexture>"
v120@0:8r^v16Q24Q32Q40^v48Q56Q64{?={?=QQQ}{?=QQQ}}72
v120@0:8r^v16Q24Q32{?={?=QQQ}{?=QQQ}}40^v88Q96Q104Q112
v24@0:8^v16
{?=[2Q]}16@0:8
@56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
@"<MTLBuffer>"56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
{pair<id<MTLBuffer>, unsigned long>=@Q}24@0:8Q16
{ReportBufferEntry=Q@Q}24@0:8Q16
@"<MTLArgumentEncoder>"
{vector<MetalBuffer, std::allocator<MetalBuffer>>="__begin_"^{MetalBuffer}"__end_"^{MetalBuffer}"__end_cap_"{__compressed_pair<MetalBuffer *, std::allocator<MetalBuffer>>="__value_"^{MetalBuffer}}}
{MetalBuffer="heap"^{MetalBufferHeap}"index"I}
{vector<id<MTLBuffer>, std::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::allocator<id<MTLBuffer>>>="__value_"^@}}
{vector<ReportBufferEntry, std::allocator<ReportBufferEntry>>="__begin_"^{ReportBufferEntry}"__end_"^{ReportBufferEntry}"__end_cap_"{__compressed_pair<ReportBufferEntry *, std::allocator<ReportBufferEntry>>="__value_"^{ReportBufferEntry}}}
{vector<NSString *, std::allocator<NSString *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<NSString **, std::allocator<NSString *>>="__value_"^@}}
[2{BufferUsageTable="_backingMemory"@"<MTLBuffer>"}]
[2{TextureUsageTable="_backingMemory"@"<MTLBuffer>"}]
{HeapUsageTable="_heapStages"{vector<std::pair<MTLGPUDebugHeap *, unsigned long>, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<MTLGPUDebugHeap *, unsigned long> *, std::allocator<std::pair<MTLGPUDebugHeap *, unsigned long>>>="__value_"^v}}}
v64@0:8@"<MTLTexture>"16Q24r^{?={?=QQQ}{?=QQQ}}32r^Q40r^Q48Q56
v96@0:8@"<MTLTexture>"16Q24{?={?=QQQ}{?=QQQ}}32Q80Q88
v48@0:8@"<MTLTexture>"16Q24@"<MTLBuffer>"32Q40
v64@0:8@"<MTLTexture>"16Q24Q32@"<MTLBuffer>"40Q48Q56
v148@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136B144
v112@0:8@16Q24Q32{?=QQQ}40@64Q72Q80Q88Q96Q104
{deque<id, std::allocator<id>>="__map_"{__split_buffer<id *, std::allocator<id *>>="__first_"^^@"__begin_"^^@"__end_"^^@"__end_cap_"{__compressed_pair<id **, std::allocator<id *>>="__value_"^^@}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<id>>="__value_"Q}}
@"MTLDebugCommandBuffer"
@40@0:8@16@24Q32
@48@0:8@16@24r^v32Q40
r^v16@0:8
@"MTLDebugResource"
@"MTLDebugDevice"
@"MTLDebugCommandQueue"
v32@0:8@16B24B28
v28@0:8@16B24
B32@0:8@16^B24
@"_MTLCommandEncoder"
{unordered_multiset<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__table_"{__hash_table<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::allocator<AttachmentDescriptorSimple>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>, std::allocator<std::__hash_node<AttachmentDescriptorSimple, void *>>>="__value_"{__hash_node_base<std::__hash_node<AttachmentDescriptorSimple, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, AttachmentDescriptorSimple::hash_t>="__value_"Q}"__p3_"{__compressed_pair<float, AttachmentDescriptorSimple::equal_t>="__value_"f}}}
{array<AttachmentDescriptorSimple, 8UL>="__elems_"[8{AttachmentDescriptorSimple="texture"^v"level"Q"sliceRange"{_NSRange="location"Q"length"Q}"depthPlaneRange"{_NSRange="location"Q"length"Q}"storeAction"Q}]}
{unordered_set<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__table_"{__hash_table<id<MTLDebugResourcePurgeable>, std::hash<id<MTLDebugResourcePurgeable>>, std::equal_to<id<MTLDebugResourcePurgeable>>, std::allocator<id<MTLDebugResourcePurgeable>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>, std::allocator<std::__hash_node<id<MTLDebugResourcePurgeable>, void *>>>="__value_"{__hash_node_base<std::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<id<MTLDebugResourcePurgeable>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<id<MTLDebugResourcePurgeable>>>="__value_"f}}}
{unordered_set<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__table_"{__hash_table<MTLToolsObject *, std::hash<MTLToolsObject *>, std::equal_to<MTLToolsObject *>, std::allocator<MTLToolsObject *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>, std::allocator<std::__hash_node<MTLToolsObject *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLToolsObject *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLToolsObject *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLToolsObject *>>="__value_"f}}}
v96@0:8Q16Q24Q32@40Q48Q56Q64@72Q80Q88
v96@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64@"<MTLBuffer>"72Q80Q88
v112@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80@"<MTLBuffer>"88Q96Q104
^{?=[3I]}16@0:8
@"_MTLIndirectDrawArguments"16@0:8
@"_MTLIndirectDrawIndexedArguments"16@0:8
@"_MTLIndirectDrawPatchesArguments"16@0:8
@"_MTLIndirectDrawIndexedPatchesArguments"16@0:8
@"_MTLIndirectTessellationFactorArguments"16@0:8
@"MTLCounterSampleBufferDescriptor"
@40@0:8@16r^v24@32
@56@0:8@16@24@32@40@48
@"MTLComputePipelineReflection"
[31{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[128{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[16{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{?="width"Q"height"Q"depth"Q}
{?="origin"{?="x"Q"y"Q"z"Q}"size"{?="width"Q"height"Q"depth"Q}}
[3Q]
@"MTLComputePipelineDescriptor"
@56@0:8@16@24@32Q40Q48
@"<MTLIndirectCommandBuffer>"
@"<MTLComputePipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"<MTLRenderPipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"MTLComputePipelineDescriptor"32@0:8@"NSString"16^@24
@"MTLRenderPipelineDescriptor"32@0:8@"NSString"16^@24
@"<MTLPipelineCache>"16@0:8
v32@0:8@"<MTLRenderPipelineState>"16Q24
v32@0:8@"<MTLComputePipelineState>"16Q24
v32@0:8@"<MTLIndirectCommandBuffer>"16Q24
@"_MTLIndirectArgumentBufferLayout"16@0:8
{vector<unsigned int, std::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::allocator<unsigned int>>="__value_"^I}}
@"<MTLIOScratchBuffer>"24@0:8Q16
v32@0:8@16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16B24B28^{_MTLMessageContext=q*I@q@*}32
v40@0:8Q16Q24^{_MTLMessageContext=q*I@q@*}32
v40@0:8@16Q24^f32
{MTLSamplerDescriptorHashMap="_map"{unordered_map<std::array<unsigned long long, 3>, unsigned int, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, std::allocator<std::pair<const std::array<unsigned long long, 3>, unsigned int>>>="__table_"{__hash_table<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>, std::allocator<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<std::array<unsigned long long, 3>, std::__hash_value_type<std::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, MTLSamplerDescriptorHashMap::hash_t, true>>="__value_"f}}}"_limit"I}
{unordered_set<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__table_"{__hash_table<MTLDebugCommandBuffer *, std::hash<MTLDebugCommandBuffer *>, std::equal_to<MTLDebugCommandBuffer *>, std::allocator<MTLDebugCommandBuffer *>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>, std::allocator<std::__hash_node<MTLDebugCommandBuffer *, void *>>>="__value_"{__hash_node_base<std::__hash_node<MTLDebugCommandBuffer *, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::hash<MTLDebugCommandBuffer *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<MTLDebugCommandBuffer *>>="__value_"f}}}
{CheckerboardRenderTargetPipelineCache="_cacheLock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"_library"@"<MTLLibrary>""_vertexFunction"@"<MTLFunction>""_depthStencilState"[2@"<MTLDepthStencilState>"]"_fConstants"@"MTLFunctionConstantValues""_cache"{unordered_map<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, std::allocator<std::pair<const MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__table_"{__hash_table<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>, std::allocator<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, std::equal_to<MTLDebugCheckerboardFillHashKey>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::equal_to<MTLDebugCheckerboardFillHashKey>, MTLDebugCheckerboardFillHashKey::Hash, true>>="__value_"f}}}}
C16@0:8
@"MTLDepthStencilDescriptor"
@56@0:8@16@24Q32Q40@48
@"MTLCountersTraceResourceStateCommandEncoder"
@"MTLAccelerationStructureDescriptor"16@0:8
v24@0:8@"MTLAccelerationStructureDescriptor"16
@"MTLToolsBuffer"
@32@0:8@16@?24
@"NSMapTable"
{recursive_mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
{vector<id, std::allocator<id>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id *, std::allocator<id>>="__value_"^@}}
@"MTLFunctionConstantValues"
@56@0:8@16@24Q32@40@48
v32@0:8@16#24
v32@0:8@16r^{?=BQ^{?}}24
^{?=BQ^{?}}16@0:8
@"MTLCompileOptions"
^{?=BQ^{?}}
{atomic<unsigned long long>="__a_"{__cxx_atomic_impl<unsigned long long, std::__cxx_atomic_base_impl<unsigned long long>>="__a_value"AQ}}
@"MTLRenderPassDescriptor"
@32@0:8r^{MTLRenderPassAttachmentDescriptorPrivate=@QQQQQQ{?=dddd}dIQ@QQQQQQB}16Q24
Q24@0:8@16
{?=dddddd}16@0:8
{?=QQQQ}16@0:8
v56@0:8{?=QQQ}16^{?={?=QQQ}{?=QQQ}}40^I48
v48@0:8@16Q24^{_MTLMessageContext=q*I@q@*}32@40
v24@0:8^{_MTLMessageContext=q*I@q@*}16
v56@0:8Q16Q24Q32Q40r*48
v72@0:8Q16Q24Q32@40Q48Q56r*64
v64@0:8@16Q24Q32^{?=BBQ@QQQQQBff}40Q48Q56
v72@0:8r^@16{_NSRange=QQ}24Q40^{?=BBQ@QQQQQBff}48Q56Q64
{?=BBQ@QQQQQBff}16@0:8
^{?=QQ}
[10{?="pixelFormat"Q"sampleCount"Q}]
[36{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{vector<MTLViewport, std::allocator<MTLViewport>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLViewport *, std::allocator<MTLViewport>>="__value_"^{?}}}
{vector<MTLScissorRect, std::allocator<MTLScissorRect>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLScissorRect *, std::allocator<MTLScissorRect>>="__value_"^{?}}}
{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}
@"MTLCountersTraceCommandBuffer"
{MTLGPUDebugThreadgroupLengths="threadgroupSizes"[31I]"entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
@"MTLToolsFunction"
@48@0:8Q16^@24@32@40
{unordered_map<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__table_"{__hash_table<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>, std::allocator<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::hash<unsigned int>, std::equal_to<unsigned int>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<unsigned int, std::__hash_value_type<unsigned int, std::unique_ptr<GPUDebugArgumentEncoderLayout>>, std::equal_to<unsigned int>, std::hash<unsigned int>, true>>="__value_"f}}}
@40@0:8@16Q24:32
v40@0:8r^{?=QQQ}16Q24^{_MTLMessageContext=q*I@q@*}32
[8Q]
[31{?="bufferIndex"Q"bufferStride"Q}]
@"MTLRenderPipelineDescriptor"
@"MTLTileRenderPipelineDescriptor"
@"MTLMeshRenderPipelineDescriptor"
@"MTLSamplerDescriptor"
v32@0:8Q16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16{?=QQ}24
@64@0:8@16@24@32Q40Q48Q56
@88@0:8@16@24@32Q40Q48{_NSRange=QQ}56{_NSRange=QQ}72
{MTLPixelFormatInfo="name"*"flags"I"castClass"Q"type"(?="normal"{MTLNormalPixelFormatInfo="pixelBytes"Q"componentCount"C"alignment"C"pixelBytesRender"Q"pixelBytesRenderMSAA"Q}"compressed"{MTLCompressedPixelFormatInfo="blockBytes"Q"blockWidth"Q"blockHeight"Q"blockDepth"Q})}
{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::allocator<std::pair<const SubView, unsigned long>>>="__table_"{__hash_table<std::__hash_value_type<SubView, unsigned long>, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>, std::allocator<std::__hash_value_type<SubView, unsigned long>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<SubView, unsigned long>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::hash_t, SubView::equal_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<SubView, std::__hash_value_type<SubView, unsigned long>, SubView::equal_t, SubView::hash_t, true>>="__value_"f}}}
@"MTLTextureDescriptor"
@"MTLDebugBuffer"
v48@0:8^v16Q24@32Q40
v56@0:8@16Q24Q32@40Q48
v120@0:8@16Q24Q32{?=QQQ}40Q64Q72{?=QQQ}80@104Q112
v24@0:8@?<v@?@"<MTLIOCommandBuffer>">16
v48@0:8^v16Q24@"<MTLIOFileHandle>"32Q40
v56@0:8@"<MTLBuffer>"16Q24Q32@"<MTLIOFileHandle>"40Q48
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40Q64Q72{?=QQQ}80@"<MTLIOFileHandle>"104Q112
v32@0:8@"<MTLSharedEvent>"16Q24
q56@0:8^v16Q24Q32^v40Q48
^v48@0:8Q16Q24^v32Q40
q64@0:8^v16Q24Q32^v40Q48^B56
^v56@0:8Q16Q24^v32Q40^B48
Q32@0:8Q16Q24
@"<MTLIOCommandBuffer>"16@0:8
@"MTLCountersTraceBlitCommandEncoder"
