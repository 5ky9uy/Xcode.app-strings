allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
la_object_t  _Nonnull la_splat_from_float(float, la_attribute_t)
la_object_t  _Nonnull la_splat_from_double(double, la_attribute_t)
la_object_t  _Nonnull la_splat_from_vector_element(la_object_t _Nonnull, la_index_t)
operator %s does not support splat
splat from vector element
requires object to be 1xn or nx1.  actual dimensions were %ld x %ld
%s must be less than %s; failed comparison: %ld < %ld
vector_index
the number of elements in the object (zero indexed)
la_object_t  _Nonnull la_splat_from_matrix_element(la_object_t _Nonnull, la_index_t, la_index_t)
splat from matrix element
matrix_row
the number of rows in the object (zero indexed)
matrix_col
the number of columns in the object (zero indexed)
la_object_t  _Nonnull la_vector_from_splat(la_object_t _Nonnull, la_count_t)
operator %s requires splat
vector from splat
la_object_t  _Nonnull la_matrix_from_splat(la_object_t _Nonnull, la_count_t, la_count_t)
matrix from splat
NSString
%ld %ld
LA_SUCCESS: Completed successfully
LA_WARNING_POORLY_CONDITIONED: *Warning* matrix was poorly conditioned
LA_DIMENSION_MISMATCH_ERROR: Encountered a dimension mismatch
LA_INTERNAL_ERROR
LA_INVALID_PARAMETER_ERROR: One or more parameter has an illegal value
LA_PRECISION_MISMATCH_ERROR: Precision of underlying scalar values must match
LA_SINGULAR_ERROR: Matrix is singular
LA_SLICE_OUT_OF_BOUNDS_ERROR: Requested slice not within bounds
Unhandled error code
la_object_t  _Nonnull la_matrix_from_float_buffer_nocopy(float * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_deallocator_t _Nullable, la_attribute_t)
%s must be a non-null pointer
buffer
la_object_t  _Nonnull la_matrix_from_float_buffer(const float * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_attribute_t)
la_object_t  _Nonnull la_matrix_from_double_buffer_nocopy(double * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_deallocator_t _Nullable, la_attribute_t)
la_object_t  _Nonnull la_matrix_from_double_buffer(const double * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_attribute_t)
la_status_t la_matrix_to_float_buffer(float * _Nonnull, la_count_t, la_object_t _Nonnull)
%s must be float type
matrix
matrix to float buffer
la_status_t la_matrix_to_double_buffer(double * _Nonnull, la_count_t, la_object_t _Nonnull)
%s must be double type
matrix to double buffer
la_object_t  _Nonnull la_matrix_slice(la_object_t _Nonnull, la_index_t, la_index_t, la_index_t, la_index_t, la_count_t, la_count_t)
inherited state from object operand
matrix slice
requested slice [%ld .. %ld] x [%ld .. %ld]. must be within [0 .. %ld] x [0 .. %ld]
la_object_t  _Nonnull la_diagonal_matrix_from_vector(la_object_t _Nonnull, la_index_t)
diagonal matrix from vector
la_object_t  _Nonnull la_identity_matrix(la_count_t, la_scalar_type_t, la_attribute_t)
%s must be %s or %s
scalar_type
LA_SCALAR_TYPE_DOUBLE
la_object_t  _Nonnull la_vector_from_matrix_row(la_object_t _Nonnull, la_count_t)
vector from matrix row
number of matrix rows
la_object_t  _Nonnull la_vector_from_matrix_col(la_object_t _Nonnull, la_count_t)
vector from matrix col
number of matrix columns
la_object_t  _Nonnull la_vector_from_matrix_diagonal(la_object_t _Nonnull, la_index_t)
vector from matrix diagonal
matrix_diagonal
%s must be greater than %s; failed comparison: %ld > %ld
number of rows
zero
number of columns
row stride
%s must be greater than or equal to %s; failed comparison: %ld >= %ld
float la_norm_as_float(la_object_t _Nonnull, la_norm_t)
vector
norm type must be %s, %s, or %s
LA_L1_NORM
LA_L2_NORM
LA_LINF_NORM
norm
double la_norm_as_double(la_object_t _Nonnull, la_norm_t)
la_object_t  _Nonnull la_normalized_vector(la_object_t _Nonnull, la_norm_t)
normalized vector
la_object_t la_norm_as_object(la_object_t, la_norm_t)
la_status_t la_vector_to_float_buffer(float * _Nonnull, la_index_t, la_object_t _Nonnull)
vector to float buffer
la_status_t la_vector_to_double_buffer(double * _Nonnull, la_index_t, la_object_t _Nonnull)
la_object_t  _Nonnull la_vector_slice(la_object_t _Nonnull, la_index_t, la_index_t, la_count_t)
vector slice
requested slice [%ld .. %ld]. must be within [0 .. %ld]
la_object_t  _Nonnull la_matrix_product(la_object_t _Nonnull, la_object_t _Nonnull)
matrix_left
matrix_right
inherited state from %s operand
left
right
%s and %s must both have the same scalar type (float / double)
operator %s does not support op(splat,splat)
product
One of the following must be true: 1) left.cols == right.cols; 2) Kx1 * KxN, left is transposed giving 1xK * KxN; 3) MxK * 1xK, right is transposed giving MxK * Kx1. Provided operands look like (%ld x %ld) * (%ld x %ld). Failed comparison %ld == %ld
matrix_left columns
matrix_right rows
%s must be equal to %s; failed comparison: %ld == %ld
la_object_t  _Nonnull la_inner_product(la_object_t _Nonnull, la_object_t _Nonnull)
vector_left
vector_right
inner product
requires each object to be 1xn or nx1.  actual dimensions were %ld x %ld and %ld x %ld
la_object_t  _Nonnull la_outer_product(la_object_t _Nonnull, la_object_t _Nonnull)
outer product
la_object_t  _Nonnull la_sum(la_object_t _Nonnull, la_object_t _Nonnull)
obj_left
obj_right
element wise sum
obj_left rows
obj_right rows
obj_left columns
obj_right columns
la_object_t  _Nonnull la_difference(la_object_t _Nonnull, la_object_t _Nonnull)
element wise difference
la_object_t  _Nonnull la_elementwise_product(la_object_t _Nonnull, la_object_t _Nonnull)
element wise product
la_object_t  _Nonnull la_transpose(la_object_t _Nonnull)
transpose
la_object_t  _Nonnull la_scale_with_float(la_object_t _Nonnull, float)
scalar product with float
la_object_t  _Nonnull la_scale_with_double(la_object_t _Nonnull, double)
scalar product with double
la_object_t  _Nonnull la_solve(la_object_t _Nonnull, la_object_t _Nonnull)
system
linear system
system rows
rhs rows
OS_la_object
NSObject
init
dealloc
stringWithUTF8String:
stringWithFormat:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
v16@0:8
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
la_object_t  _Nonnull la_splat_from_float(float, la_attribute_t)
la_object_t  _Nonnull la_splat_from_double(double, la_attribute_t)
la_object_t  _Nonnull la_splat_from_vector_element(la_object_t _Nonnull, la_index_t)
operator %s does not support splat
splat from vector element
requires object to be 1xn or nx1.  actual dimensions were %ld x %ld
%s must be less than %s; failed comparison: %ld < %ld
vector_index
the number of elements in the object (zero indexed)
la_object_t  _Nonnull la_splat_from_matrix_element(la_object_t _Nonnull, la_index_t, la_index_t)
splat from matrix element
matrix_row
the number of rows in the object (zero indexed)
matrix_col
the number of columns in the object (zero indexed)
la_object_t  _Nonnull la_vector_from_splat(la_object_t _Nonnull, la_count_t)
operator %s requires splat
vector from splat
la_object_t  _Nonnull la_matrix_from_splat(la_object_t _Nonnull, la_count_t, la_count_t)
matrix from splat
NSString
%ld %ld
LA_SUCCESS: Completed successfully
LA_WARNING_POORLY_CONDITIONED: *Warning* matrix was poorly conditioned
LA_DIMENSION_MISMATCH_ERROR: Encountered a dimension mismatch
LA_INTERNAL_ERROR
LA_INVALID_PARAMETER_ERROR: One or more parameter has an illegal value
LA_PRECISION_MISMATCH_ERROR: Precision of underlying scalar values must match
LA_SINGULAR_ERROR: Matrix is singular
LA_SLICE_OUT_OF_BOUNDS_ERROR: Requested slice not within bounds
Unhandled error code
la_object_t  _Nonnull la_matrix_from_float_buffer_nocopy(float * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_deallocator_t _Nullable, la_attribute_t)
%s must be a non-null pointer
buffer
la_object_t  _Nonnull la_matrix_from_float_buffer(const float * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_attribute_t)
la_object_t  _Nonnull la_matrix_from_double_buffer_nocopy(double * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_deallocator_t _Nullable, la_attribute_t)
la_object_t  _Nonnull la_matrix_from_double_buffer(const double * _Nonnull, la_count_t, la_count_t, la_count_t, la_hint_t, la_attribute_t)
la_status_t la_matrix_to_float_buffer(float * _Nonnull, la_count_t, la_object_t _Nonnull)
%s must be float type
matrix
matrix to float buffer
la_status_t la_matrix_to_double_buffer(double * _Nonnull, la_count_t, la_object_t _Nonnull)
%s must be double type
matrix to double buffer
la_object_t  _Nonnull la_matrix_slice(la_object_t _Nonnull, la_index_t, la_index_t, la_index_t, la_index_t, la_count_t, la_count_t)
inherited state from object operand
matrix slice
requested slice [%ld .. %ld] x [%ld .. %ld]. must be within [0 .. %ld] x [0 .. %ld]
la_object_t  _Nonnull la_diagonal_matrix_from_vector(la_object_t _Nonnull, la_index_t)
diagonal matrix from vector
la_object_t  _Nonnull la_identity_matrix(la_count_t, la_scalar_type_t, la_attribute_t)
%s must be %s or %s
scalar_type
LA_SCALAR_TYPE_DOUBLE
la_object_t  _Nonnull la_vector_from_matrix_row(la_object_t _Nonnull, la_count_t)
vector from matrix row
number of matrix rows
la_object_t  _Nonnull la_vector_from_matrix_col(la_object_t _Nonnull, la_count_t)
vector from matrix col
number of matrix columns
la_object_t  _Nonnull la_vector_from_matrix_diagonal(la_object_t _Nonnull, la_index_t)
vector from matrix diagonal
matrix_diagonal
%s must be greater than %s; failed comparison: %ld > %ld
number of rows
zero
number of columns
row stride
%s must be greater than or equal to %s; failed comparison: %ld >= %ld
float la_norm_as_float(la_object_t _Nonnull, la_norm_t)
vector
norm type must be %s, %s, or %s
LA_L1_NORM
LA_L2_NORM
LA_LINF_NORM
norm
double la_norm_as_double(la_object_t _Nonnull, la_norm_t)
la_object_t  _Nonnull la_normalized_vector(la_object_t _Nonnull, la_norm_t)
normalized vector
la_object_t la_norm_as_object(la_object_t, la_norm_t)
la_status_t la_vector_to_float_buffer(float * _Nonnull, la_index_t, la_object_t _Nonnull)
vector to float buffer
la_status_t la_vector_to_double_buffer(double * _Nonnull, la_index_t, la_object_t _Nonnull)
la_object_t  _Nonnull la_vector_slice(la_object_t _Nonnull, la_index_t, la_index_t, la_count_t)
vector slice
requested slice [%ld .. %ld]. must be within [0 .. %ld]
la_object_t  _Nonnull la_matrix_product(la_object_t _Nonnull, la_object_t _Nonnull)
matrix_left
matrix_right
inherited state from %s operand
left
right
%s and %s must both have the same scalar type (float / double)
operator %s does not support op(splat,splat)
product
One of the following must be true: 1) left.cols == right.cols; 2) Kx1 * KxN, left is transposed giving 1xK * KxN; 3) MxK * 1xK, right is transposed giving MxK * Kx1. Provided operands look like (%ld x %ld) * (%ld x %ld). Failed comparison %ld == %ld
matrix_left columns
matrix_right rows
%s must be equal to %s; failed comparison: %ld == %ld
la_object_t  _Nonnull la_inner_product(la_object_t _Nonnull, la_object_t _Nonnull)
vector_left
vector_right
inner product
requires each object to be 1xn or nx1.  actual dimensions were %ld x %ld and %ld x %ld
la_object_t  _Nonnull la_outer_product(la_object_t _Nonnull, la_object_t _Nonnull)
outer product
la_object_t  _Nonnull la_sum(la_object_t _Nonnull, la_object_t _Nonnull)
obj_left
obj_right
element wise sum
obj_left rows
obj_right rows
obj_left columns
obj_right columns
la_object_t  _Nonnull la_difference(la_object_t _Nonnull, la_object_t _Nonnull)
element wise difference
la_object_t  _Nonnull la_elementwise_product(la_object_t _Nonnull, la_object_t _Nonnull)
element wise product
la_object_t  _Nonnull la_transpose(la_object_t _Nonnull)
transpose
la_object_t  _Nonnull la_scale_with_float(la_object_t _Nonnull, float)
scalar product with float
la_object_t  _Nonnull la_scale_with_double(la_object_t _Nonnull, double)
scalar product with double
la_object_t  _Nonnull la_solve(la_object_t _Nonnull, la_object_t _Nonnull)
system
linear system
system rows
rhs rows
OS_la_object
NSObject
init
dealloc
stringWithUTF8String:
stringWithFormat:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
v16@0:8
