drawing
T@"CHDrawing",R,&,N,V_drawing
characterSet
T@"NSCharacterSet",R,&,N,V_characterSet
expandCodePoints
TB,R,N,V_expandCodePoints
normalizationContext
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_normalizationContext
firstPointIsSubstrokeCut
TB,R,N,V_firstPointIsSubstrokeCut
lastPointIsSubstrokeCut
TB,R,N,V_lastPointIsSubstrokeCut
maxCandidateCount
TQ,R,N,V_maxCandidateCount
CHLanguageUtilities.mm
minLength has to be > 0
v8@?0
.@#:/-_
%@%@
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
v16@?0@"CHTokenizedStrokeResult"8
Stroke Group Query %p
strokeGroupItems
T@"NSArray",C,N,S_setStrokeGroupItems:,V_strokeGroupItems
strokeGroupItemsByID
T@"NSDictionary",C,N,S_setStrokeGroupItemsByID:,V_strokeGroupItemsByID
Unknown
Handwriting
CHStrokeGroupQuery.m
Invalid parameter not satisfying: %@
identifier
stableIdentifier
strokeIdentifiers
locale
tokenizedTextResultsByLocale
 ID: %@, StableID: %@, Stroke count: %ld, type: %@
_tokenizedTextResultsByLocale
T@"NSDictionary",R,C,N,V__tokenizedTextResultsByLocale
_errorsByLocale
T@"NSDictionary",R,C,N,V__errorsByLocale
strokeGroupIdentifier
T@"NSNumber",R,N,V_strokeGroupIdentifier
strokeGroupStableIdentifier
T@"NSNumber",R,N,V_strokeGroupStableIdentifier
T@"NSArray",R,C,N,V_strokeIdentifiers
strokeGroupType
Tq,R,N,V_strokeGroupType
preferredLocale
T@"NSLocale",R,C,N,V_preferredLocale
CHStrokeGroupingStrategy.m
strokeProvider
T@"<CHStrokeProvider>",R,&,N,V_strokeProvider
strategyIdentifier
T@"NSString",R,&,N
encodedStrokeIdentifier
supportsSecureCoding
TB,R
T@"NSData",R,&,N,V_encodedStrokeIdentifier
CHTokenizedTextResultToken.m
string
strokeIndexes
The input string (%@) contains one or more ligature private code points
wordID
recognitionScore
combinedScore
alignmentScore
properties
substrokeCount
 '%@', strokes: %@, substrokeCount: %ld, wordID: %d, recognitionScore: %0.4f, combinedScore: %0.4f, alignmentScore: %0.4f, rare: %@, lexicon: %@, pattern: %@, inappropriate: %@, precedingSpace: %@
TI,R,N,V_wordID
T@"NSString",R,C,N,V_string
T@"NSIndexSet",R,C,N,V_strokeIndexes
Td,R,N
TQ,R,N
Tq,R,N
T@"NSString",C,D,N
T@"NSIndexSet",C,D,N
TI,D,N
Td,D,N
TQ,D,N
Tq,D,N
resultLevel
Tq,R,N,V_resultLevel
T@"NSSet",R,C,N,V_strokeIdentifiers
+N9mZUAHooNvMiQnjeTJ8g
.codemap
vo_en
imgData
featureData
softmax_output
std::vector<std::vector<CHCandidateResult> > CHNeuralNetwork::ClassifyCHDrawingFromBatches(NSArray<CHClassifiableDrawing *> * _Nonnull)
CHNeuralNetwork.mm
Error, the number of results doesn't match the model batch size (usesCPUOnly == %u)
Error, the number of results doesn't match the data batch size (usesCPUOnly == %u)
std::vector<CHCandidateResult> CHNeuralNetwork::filterCandidateResults(std::vector<CHCandidateResult> &, NSUInteger, NSCharacterSet * _Nullable, BOOL)
Not-a-char codepoint (U+%04x) is being added to the filtered candidate results (activeCharacterSet is nil: %d)
std::vector<CHCandidateResult> CHNeuralNetwork::feedforward(MLDictionaryFeatureProvider * _Nullable)
Error for model prediction in CHNeuralNetwork::feedforward: %@
std::vector<std::vector<CHCandidateResult> > CHNeuralNetwork::feedforwardFromBatches(MLDictionaryFeatureProvider * _Nullable)
Error for model prediction in CHNeuralNetwork::feedforwardFromBatches: %@
Unexpected prediction tensor dimension: %lu
Prediction tensor must be of dimension %ld instead of %lu for batch size different from 1
CHRecognitionOptionTextBefore
CHRecognitionOptionTextAfter
CHRecognitionOptionPrecedingSpaceBehavior
CHRecognitionOptionFrameContext
CHRecognitionOptionDrawingAnchorPoint
CHRecognitionOptionShouldRefineCandidates
CHRecognitionOptionShouldPreserveCaseVariantCandidates
v56@?0@"NSString"8{_NSRange=QQ}16{_NSRange=QQ}32^B48
enableCachingIfAvailable
TB,N,V_enableCachingIfAvailable
enableGen2ModelIfAvailable
TB,N,V_enableGen2ModelIfAvailable
enableGen2CharacterLMIfAvailable
TB,N,V_enableGen2CharacterLMIfAvailable
v24@?0^{_LXEntry=}8*16
012olzOLZ
Oval
Line
Outline Arrow
Triangle
Rectangle
Pentagon
Manhattan Line
Chat Bubble
Star
Heart
Cloud
Scribble
com.apple.CoreHandwriting
HWRTriangleAlignToAxisThreshold
HWRTriangleIsoscelesLengthRatioThreshold
HWRTriangleEquilateralLengthRatioThreshold
HWROvalFitToCircleRadiiRatioThreshold
HWROvalAlignToIncrementsOf
HWRRectangleFitToSquareLengthRatioThreshold
HWRRectangleAlignToIncrementsOf
HWROutlinedArrowAlignToIncrementsOf
HWRLineAlignToAxisThreshold
HWRLineLengthRatioThreshold
B24@?0@"CHTextRecognitionResult"8@"NSDictionary"16
v64@?0@"CHTokenizedTextResultToken"8q16{?=qqq}24{_NSRange=QQ}48
'.-/
-/._@
v28@?0r*8q16I24
d16@?0r^{NetworkEdge=QQQQddQQQ{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}}8
d16@?0^{LatticePath=^IQQQQBB^{Network}{vector<unsigned long, std::__1::allocator<unsigned long> >=^Q^Q{__compressed_pair<unsigned long *, std::__1::allocator<unsigned long> >=^Q}}{vector<unsigned long, std::__1::allocator<unsigned long> >=^Q^Q{__compressed_pair<unsigned long *, std::__1::allocator<unsigned long> >=^Q}}ddddddddddddQ^{_LXCursor}^{_LXCursor}@i{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}{_NSRange=QQ}{vector<_NSRange, std::__1::allocator<_NSRange> >=^{_NSRange}^{_NSRange}{__compressed_pair<_NSRange *, std::__1::allocator<_NSRange> >=^{_NSRange}}}{vector<_NSRange, std::__1::allocator<_NSRange> >=^{_NSRange}^{_NSRange}{__compressed_pair<_NSRange *, std::__1::allocator<_NSRange> >=^{_NSRange}}}{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}QQ}8
B32@?0@"CHTextRecognitionResult"8Q16^B24
CHRecognizer.mm
Lattice path from the no-space expansion path is expected to contain a single word
'".-
The candidate string length must be greater than the length of the active prefix
There should be at least one final token for each word in the sublattice.
!?();:
Lexicon correction requires non-empty token string.
The prefix length should be smaller than the candidate string length
The corrected entry string length must be greater than the length of the active prefix
The token prefix should be case-sensitive equal after lexicon correction
The token prefix should be case-insensitive equal after lexicon correction
Guess
d24@?0r^{LatticePath=^IQQQQBB^{Network}{vector<unsigned long, std::__1::allocator<unsigned long> >=^Q^Q{__compressed_pair<unsigned long *, std::__1::allocator<unsigned long> >=^Q}}{vector<unsigned long, std::__1::allocator<unsigned long> >=^Q^Q{__compressed_pair<unsigned long *, std::__1::allocator<unsigned long> >=^Q}}ddddddddddddQ^{_LXCursor}^{_LXCursor}@i{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}{_NSRange=QQ}{vector<_NSRange, std::__1::allocator<_NSRange> >=^{_NSRange}^{_NSRange}{__compressed_pair<_NSRange *, std::__1::allocator<_NSRange> >=^{_NSRange}}}{vector<_NSRange, std::__1::allocator<_NSRange> >=^{_NSRange}^{_NSRange}{__compressed_pair<_NSRange *, std::__1::allocator<_NSRange> >=^{_NSRange}}}{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}QQ}8d16
%@%@%@
q24@?0@8@16
A single segment group is expected in spatially-segmented configurations (found %lu segment groups)
The number of segments (%lu) must be the same as the number of sorted segment indexes (%lu)
The number of nodes in the candidate network (%lu) should match the number of generated segments (%lu)
Unexpected number of token columns in result from no-space path expansion: expected 1, got %ld
Unexpected number of token rows in result from no-space path expansion: expected 1, got %ld
v48@?0@"CHTokenizedTextResultToken"8q16{?=qqq}24
Lattice path search can not be initialized with partial paths if there is a prefix.
We must add at least one candidate for each edge
Batch contains %lu non classified drawings
There must be at least one valid path
Incorrect index in segment decoding: index %ld (idx %ld + offset %ld) should be smaller than %ld, the number of segments on the group.
v24@?0Q8^B16
The recognition model must be loaded before inference can be called on it
The text decoder must be loaded before decoding can be executed
ctc_zh
CoreHandwriting
automatic_prespaces
The token activation range is longer than the sequence in the activation matrix.
The first stroke index must be non-negative
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
recognitionMode
Ti,R,N
contentType
Ti,N
autoCapitalizationMode
T@"NSLocale",R,C,N
maxRecognitionResultCount
TQ,N
activeCharacterSet
T@"NSCharacterSet",&,N
minimumDrawingSize
T{CGSize=dd},N
TB,R,N
engine
T^{CHNeuralNetwork=^?B^{CHCodeMap}IIII@@{CGRect={CGPoint=dd}{CGSize=dd}}},N,V_engine
freeformEngine
T^{CHNeuralNetwork=^?B^{CHCodeMap}IIII@@{CGRect={CGPoint=dd}{CGSize=dd}}},N,V_freeformEngine
strokeTransitionModel
T@"CHStrokeTransitionModel",&,N,V_strokeTransitionModel
cutpointModel
T@"CHCutpointModel",&,N,V_cutpointModel
recognitionModel
T@"CHCTCRecognitionModel",&,N,V_recognitionModel
textDecoder
T@"CVNLPCTCTextDecoder",&,N,V_textDecoder
recognitionQueue
T@"NSObject<OS_dispatch_queue>",&,N,V_recognitionQueue
radicalClusterFST
T^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ},N,V_radicalClusterFST
formatGrammarFST
T^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ},N,V_formatGrammarFST
patternFST
T@"CHPatternNetwork",&,N,V_patternFST
postProcessingFST
T@"CHPatternNetwork",&,N,V_postProcessingFST
configuration
T@"CHRecognizerConfiguration",&,N,S_setConfiguration:,V_configuration
languageModel
T^v,N,V_languageModel
lmVocabulary
T^v,N,V_lmVocabulary
characterLanguageModel
T^v,N,V_characterLanguageModel
mecabra
T^{__Mecabra=},N,V_mecabra
cjkStaticLexicon
T^v,N,V_cjkStaticLexicon
cjkDynamicLexicon
T^v,N,V_cjkDynamicLexicon
staticLexicon
T^{_LXLexicon=},N,V_staticLexicon
phraseLexicon
T^{_LXLexicon=},N,V_phraseLexicon
customLexicon
T^{_LXLexicon=},N,V_customLexicon
customPhraseLexicon
T^{_LXLexicon=},N,V_customPhraseLexicon
textReplacements
T@"NSDictionary",&,N,V_textReplacements
textReplacementLowercasedKeyMapping
T@"NSMutableDictionary",&,N,V_textReplacementLowercasedKeyMapping
spellChecker
T@"CHSpellChecker",&,N,V_spellChecker
ovsTrie
T^{_CFBurstTrie=},N,V_ovsTrie
learningDictionaryURL
T@"NSURL",&,N,V_learningDictionaryURL
savedDrawing
T@"CHDrawing",C,N,V_savedDrawing
savedTop1CandidateString
T@"NSString",C,N,V_savedTop1CandidateString
saveDrawingUntilNextCandidateAccepted
TB,N,V_saveDrawingUntilNextCandidateAccepted
cachedDrawing
T@"CHDrawing",C,N,V_cachedDrawing
cachedResults
T{map<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::allocator<std::__1::pair<const std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >={__tree<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true>, std::__1::allocator<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true> >=Q}}},N,V_cachedResults
characterIDMap
T{map<unsigned int, unsigned int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned int> > >={__tree<std::__1::__value_type<unsigned int, unsigned int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true> >=Q}}},N,V_characterIDMap
transliterationVariantMap
T^{VariantMap=^i^i^ii^iQ},N,V_transliterationVariantMap
icuTransliterator
T^^v,N,V_icuTransliterator
lastCharacterSegmentCount
TQ,N,V_lastCharacterSegmentCount
lastCharacterSegmentIndexes
T@"NSMutableIndexSet",&,N,V_lastCharacterSegmentIndexes
postProcessor
T@"CHPostProcessingManager",&,N,V_postProcessor
T@"NSLocale",C,N
recognitionType
Ti,N,V_recognitionType
TB,N
TQ,N,V_maxRecognitionResultCount
T@"NSCharacterSet",&,N,V_activeCharacterSet
T{CGSize=dd},N,V_minimumDrawingSize
recordedInsightFromLastRequest
T@"CHRecognitionInsight",R,N
edgeIndex
TQ,R,N,V_edgeIndex
numberOfSubstrokes
Tq,R,N,V_numberOfSubstrokes
numberOfSegments
Tq,R,N,V_numberOfSegments
classifiableDrawing
T@"CHClassifiableDrawing",R,&,N,V_classifiableDrawing
strokeGroup
T{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}},R,N,V_strokeGroup
delayedSegmentIDs
T{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}},R,N,V_delayedSegmentIDs
CHStrokeUtilities.mm
strokeProvider cannot be nil.
B32@?0@"<CHStroke>"8Q16^B24
StrokeProviderError: Inconsistency in stroke provider. Stroke with id %@ is exposed but this id can not be resolved by stroke provider version %@.
Stroke Grouping Logic Error: Failed to get stroke with id %@. The stroke is not exposed by stroke provider version %@.
stroke
block
timestep must be > 0
v40@?0{CGPoint=dd}8d24^B32
q16@?0q8
=== Insight Request ===
  request: %@
=== Recognizer Configuration ===
  recognizerLocale: %@
  recognizerRecognitionMode: %@
  recognizerContentType: %@
  autoCapitalizationMode: %@
  recognizerActiveCharacterSet: %@
  recognizerMaxRecognitionResultCount: %ld
  recognizerMinimumDrawingSize: {width: %0.2f, height: %0.2f}
    %@: %@,
v32@?0@"NSString"8@"NSObject"16^B24
  recognizerOptions: %@
=== Input Drawing ===
None captured
  inputDrawing: %@
@"NSString"24@?0@"NSIndexPath"8q16
{%ld, %ld}
  cutPoints: %@
@"NSString"24@?0@"NSNumber"8q16
%.3f
  spaceProbabilities: %@
  charBoundaryProbabilities: %@
  delayedStrokeProbabilities: %@
=== Text Result ===
insightRequest
T@"CHRecognitionInsightRequest",&,N,V_insightRequest
recognizerLocale
T@"NSLocale",C,N,V_recognizerLocale
recognizerRecognitionMode
Ti,N,V_recognizerRecognitionMode
recognizerContentType
Ti,N,V_recognizerContentType
Ti,N,V_autoCapitalizationMode
recognizerActiveCharacterSet
T@"NSCharacterSet",C,N,V_recognizerActiveCharacterSet
recognizerOptions
T@"NSDictionary",C,N,V_recognizerOptions
recognizerMaxRecognitionResultCount
TQ,N,V_recognizerMaxRecognitionResultCount
recognizerMinimumDrawingSize
T{CGSize=dd},N,V_recognizerMinimumDrawingSize
inputDrawing
T@"CHDrawing",C,N,V_inputDrawing
inputDrawingCutPoints
T@"NSArray",C,N,V_inputDrawingCutPoints
spaceProbabilities
T@"NSArray",C,N,V_spaceProbabilities
charBoundaryProbabilities
T@"NSArray",C,N,V_charBoundaryProbabilities
delayedStrokeProbabilities
T@"NSArray",C,N,V_delayedStrokeProbabilities
textResult
T@"CHTokenizedTextResult",C,N,V_textResult
recognitionError
T@"NSError",C,N,V_recognitionError
recognizerRecognitionModeDescription
T@"NSString",R,N
recognizerContentTypeDescription
autoCapitalizationModeDescription
void CHDrawingStrokes::resampleStrokesEqualInSpace(CHDrawingStrokes &, const float, std::vector<std::map<NSInteger, NSInteger> > &)
CHDrawing.mm
Empty stroke detected during spatial resampling.
void CHDrawingStrokes::readCharacter(const char *)
Error: readCharacter: filename ptr = 0
Error: readCharacter: Empty filename
Error: readCharacter: Wrong filename :%s:
%d %d %d
drawingStrokes
origin: (%0.2f, %0.2f), size: (%0.2f, %0.2f)
 strokes: %lu, points: %lu, %@
At least one stroke index must be passed
%d %d
Error: Degenerated drawing (empty stroke present)
T{CHDrawingStrokes={vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}qI{Matrix<double>=^^?^dII}d{vector<int, std::__1::allocator<int> >=^i^i{__compressed_pair<int *, std::__1::allocator<int> >=^i}}},N,V_drawing
q24@?0@"CHCutPoint"8@"CHCutPoint"16
strokeIndex
Tq,R,N,V_strokeIndex
pointIndex
Tq,R,N,V_pointIndex
isEndOfStroke
TB,R,N,V_isEndOfStroke
Space probability was not predicted for every stroke.
Character boundary probability was not predicted for every stroke.
B32@?0@"CHSegmentDescriptor"8Q16^B24
Delayed segments must have an associated main segment
B32@?0@8Q16^B24
segmentID
T@"NSNumber",R,N,V_segmentID
startCutPoint
T@"CHCutPoint",R,N,V_startCutPoint
endCutPoint
T@"CHCutPoint",R,N,V_endCutPoint
segmentBounds
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_segmentBounds
relatedSegmentIDs
T@"NSArray",R,N
contextBounds
T{CGRect={CGPoint=dd}{CGSize=dd}},N,V_contextBounds
trailingSpaceRatio
Td,N,V_trailingSpaceRatio
trailingSpaceProbability
Td,N,V_trailingSpaceProbability
trailingCharBoundaryProbability
Td,N,V_trailingCharBoundaryProbability
Segment range %@ exceeds the segment count %lu
All segments must be accounted for in the segment groups
segmentGroupIndex
Tq,R,N,V_segmentGroupIndex
segments
T@"NSArray",R,N,V_segments
delayedSegments
T@"NSArray",R,N,V_delayedSegments
bounds
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N
totalSegmentCount
UIImage
/System/Library/Frameworks/UIKit.framework/UIKit
CHTextInputScriptSpec.m
Method can only be called on a single character string
CHTextInputTargetContentInfo.m
textInputTarget
referenceSubstring
selectedTextRange %@ beyond text length %ld
activePreviewRange %@ beyond text length %ld
Invalid referenceSubstringRange %@
referenceSubstringRange %@ beyond text length %ld
Invalid referenceSubstringRange %@, length doesn't match string length %ld
charRectsInReferenceSubstring cannot be NULL for referenceSubstringRange: %@
  %ld: origin: (%0.2f, %0.2f), size: (%0.2f, %0.2f)
@"NSString"24@?0@8q16
(none)
 textInputTarget: (%@), contentType: %@, textContentLength: %ld, referenceSubstring: "%@", referenceSubstringRange: %@, selectedRange: %@, isCursorStrong: %@, containsCommittedStrokes: %@, activePreviewRange: %@, strokeCoveredTextRange: %@, lastCharacterLevelPosition: %@, isSingleLine: %@, supportsAutoLineBreaks: %@, characterRectsInReferenceSubstring: {%@}, protectedCharacterIndexes: {%@}
aceimnorsuvwxz,.-_*+~<>
gjpqy
v24@?0q8^B16
v56@?0q8{CGRect={CGPoint=dd}{CGSize=dd}}16^B48
T@"CHTextInputTarget",R,&,N,V_textInputTarget
textContentLength
Tq,R,N,V_textContentLength
T@"NSString",R,C,N,V_referenceSubstring
referenceSubstringRange
T{_NSRange=QQ},R,N,V_referenceSubstringRange
strokeCoveredTextRange
T{_NSRange=QQ},R,N,V_strokeCoveredTextRange
selectedTextRange
T{_NSRange=QQ},R,N,V_selectedTextRange
isCursorStrong
TB,R,N,V_isCursorStrong
containsCommittedStrokes
TB,R,N,V_containsCommittedStrokes
activePreviewRange
T{_NSRange=QQ},R,N,V_activePreviewRange
Ti,R,N,V_contentType
Ti,R,N,V_autoCapitalizationMode
isSingleLine
TB,R,N,V_isSingleLine
supportsAutoLineBreaks
TB,R,N,V_supportsAutoLineBreaks
lastCharacterLevelPosition
Tq,R,N,V_lastCharacterLevelPosition
characterRectsInReferenceSubstring
T^{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_characterRectsInReferenceSubstring
protectedCharacterIndexes
T@"NSIndexSet",R,C,N,V_protectedCharacterIndexes
The referenceSubstring length must be equal to the range that it covers
T@"CHTextInputTarget",&,D,N
T{_NSRange=QQ},D,N
TB,D,N
Ti,D,N
strokeIdentifier
substrokesCount
classificationAsNonText
lineOrientation
lineError
containerScore
{CGRect={CGPoint=dd}{CGSize=dd}}
boundsDiagonal
enlargedBounds
rotatedBounds
supportByStrokeIdentifier
support
Tq,R,N,V_classificationAsNonText
Tq,R,N,V_substrokesCount
T@"NSDictionary",R,&,N,V_supportByStrokeIdentifier
Td,R,N,V_lineError
Td,R,N,V_containerScore
lineOrientationAngle
Td,R,N,V_lineOrientationAngle
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_bounds
Td,R,N,V_boundsDiagonal
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_enlargedBounds
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_rotatedBounds
T@"CHEncodedStrokeIdentifier",R,&,N,V_strokeIdentifier
effectiveClassification
Td,R,N,V_support
<%@: %p strokeIdentifier=(%@) support=%.3f class=%ld>
T@"NSDictionary",&,D,N
CHCornerDetector.mm
Could not find a point in the drawing to match that in the resampled drawing
_strawSize
TQ,R,N,V__strawSize
_cornerIndexSet
T@"NSMutableIndexSet",R,C,N,V__cornerIndexSet
_directionChangeCornerIndexes
T@"NSMutableIndexSet",R,C,N,V__directionChangeCornerIndexes
_resampledDrawingPointMap
T{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}{__compressed_pair<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > *, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}}},R,N,V__resampledDrawingPointMap
shouldUseDynamicSampling
TB,N,V_shouldUseDynamicSampling
minimumSignificantSegmentLength
Td,N,V_minimumSignificantSegmentLength
T@"CHDrawing",C,N,V_drawing
resampledDrawing
T@"CHDrawing",R,C,N,V_resampledDrawing
directionChangeCount
TQ,R,N,V_directionChangeCount
highestDirectionChangeCount
TQ,R,N,V_highestDirectionChangeCount
strokeGroups
groupingResultsByStrategyIdentifier
T@"NSDictionary",R,&,N,V_groupingResultsByStrategyIdentifier
CHStrokeGroupingManager.mm
At least one stroke grouping strategy must be set.
%@, 
v32@?0@"CHEncodedStrokeIdentifier"8@"NSNumber"16^B24
v24@?0@"CHEncodedStrokeIdentifier"8^B16
B24@?0@"CHStrokeGroup"8^B16
groupingManagerNonText
q24@?0@"CHEncodedStrokeIdentifier"8@"CHEncodedStrokeIdentifier"16
q24@?0@"CHStrokeGroup"8@"CHStrokeGroup"16
q24@?0@"<CHStroke>"8@"<CHStroke>"16
groupingStrategiesByIdentifier
T@"NSDictionary",R,&,N,V_groupingStrategiesByIdentifier
sessionLastResult
T@"CHRecognitionSessionResult",R,&,N,V_sessionLastResult
locales
T@"NSArray",R,&,N,V_locales
isInlineContinuousMode
TB,R,N,V_isInlineContinuousMode
textInputTargets
T@"NSArray",R,&,N,V_textInputTargets
recognitionLocaleIdentifier
T@"NSString",R,C,N
autoLineBreakEnabled
TB,R,N,V_autoLineBreakEnabled
autoLineBreakRequireWeakCursor
TB,R,N,V_autoLineBreakRequireWeakCursor
autoLineBreakMinVerticalDistance
Td,R,N,V_autoLineBreakMinVerticalDistance
autoLineBreakDualBreakVerticalDistance
Td,R,N,V_autoLineBreakDualBreakVerticalDistance
autoLineBreakAreaWidthFactor
Td,R,N,V_autoLineBreakAreaWidthFactor
lineBreakVerticalBarGestureEnabled
TB,R,N,V_lineBreakVerticalBarGestureEnabled
lineBreakVerticalBarUpToDelete
TB,R,N,V_lineBreakVerticalBarUpToDelete
subwordGestureEndingSpeedRange
Td,R,N,V_subwordGestureEndingSpeedRange
subwordGestureSpeedThreshold
Td,R,N,V_subwordGestureSpeedThreshold
preventLeftoverCharsInSubwordGestures
TB,R,N,V_preventLeftoverCharsInSubwordGestures
CHRecognitionSessionResult.m
Use the designated initializer instead
encodedStrokeProviderVersion
orderedStrokeIdentifiers
", "
"%@"
 strokeProviderVersion: %@, locales: %@, strokeClassificationResult: %@, strokeGroupingResult: %@
  Group %ld: 
recognition: %@
textCorrection: %@
Group Results: 
@"NSString"24@?0@"CHStrokeGroup"8@"NSLocale"16
GroupID %ld, %@
== %@ ==
GroupID %ld
%@: {
<NO RESULT>
"%@"%@
<ERROR: %@>
Gen 1
Gen 2
Recognizer Generation: %@
None
Language Fitness: %@
B32@?0@"CHStrokeGroup"8Q16^B24
strokeProviderVersion
sessionMode
preferredLocales
strokeClassificationResult
strokeGroupingResult
recognitionResults
inlineContinuousModeResults
generationDuration
recognitionEnvironment
_recognitionResultsByGroupID
T@"NSDictionary",R,C,N,V__recognitionResultsByGroupID
_textCorrectionResultsByGroupID
T@"NSDictionary",R,C,N,V__textCorrectionResultsByGroupID
_transcriptionCapability
T@"<CHStrokeProviderVersion>",R,&,N,V_strokeProviderVersion
T@"NSArray",R,&,N,V_orderedStrokeIdentifiers
Tq,R,N,V_sessionMode
T@"NSArray",R,C,N,V_locales
T@"NSArray",R,C,N,V_preferredLocales
clutterFilter
T@"CHStrokeClutterFilter",R,&,N,V_clutterFilter
Tq,R,N,V_recognitionEnvironment
T@"CHStrokeClassificationResult",R,&,N,V_strokeClassificationResult
T@"CHStrokeGroupingResult",R,&,N,V_strokeGroupingResult
T{?=ddddd},R,N,V_generationDuration
highConfidenceDebugDescription
allResultsDebugDescription
allResultsDebugDescriptionByGroup
strokeClassificationsByStrokeIdentifier
 Strokes: %ld, text strokes: %ld
B32@?0@"CHEncodedStrokeIdentifier"8@"NSNumber"16^B24
substrokesByStrokeIdentifier
nontextCandidates
T@"NSDictionary",R,C,N,V_strokeClassificationsByStrokeIdentifier
T@"NSDictionary",R,C,N,V_substrokesByStrokeIdentifier
textStrokeIdentifiers
T@"NSSet",R,C,N
T@"NSSet",R,C,N,V_nontextCandidates
 Groups: %ld, created: %ld, deleted: %ld
T@"NSSet",R,C,N,V_strokeGroups
createdStrokeGroups
T@"NSSet",R,C,N,V_createdStrokeGroups
deletedStrokeGroups
T@"NSSet",R,C,N,V_deletedStrokeGroups
textStrokeGroupsSortedTopBottomLeftRight
T@"NSArray",R,C,N
textStrokeGroupsSortedByWritingOrientation
strokeGroupsSortedByWritingOrientation
strokeGroupClusters
textStrokeGroupClusters
textStrokeGroups
CHSkipConfidenceFiltering
recognitionResultsByLocale
errorsByLocale
languageFitnessByLocale
inputStrokeIdentifiers
T@"NSArray",R,C,N,V_inputStrokeIdentifiers
T@"NSDictionary",R,C,N,V_recognitionResultsByLocale
T@"NSDictionary",R,C,N,V_errorsByLocale
resultsByLocale
langFitnessByLocale
q24@?0@"NSLocale"8@"NSLocale"16
T@"CHDrawing",R,&,N
T@"NSDictionary",R,C,N
textCorrectionResult
T@"CHTextCorrectionResult",R,C,N,V_textCorrectionResult
CHRemoteRecognitionRequest.mm
options
priority
minimumDrawingWidth
minimumDrawingHeight
shouldUseTextReplacements
hasBeenSubmitted
The CHRemoteRecognitionRequest cannot be mutated after being submitted
hasBeenSubmitted state cannot be reverted after being set to YES
Remote Recognition Request %p (locale=%@, mode=%@, content type=%@, autocapitalization mode=%@, option keys=%@, active character set=%p, drawing=%p, shouldUseTextReplacements=%@, enableCachingIfAvailable=%@, enableGen2ModelIfAvailable=%@, enableGen2CharacterLMIfAvailable=%@, hasBeenSubmitted=%@, priority=%ld)
T@"NSLocale",C,N,V_locale
Ti,N,V_recognitionMode
Ti,N,V_contentType
T@"NSCharacterSet",C,N,V_activeCharacterSet
T@"NSDictionary",C,N,V_options
TB,N,V_shouldUseTextReplacements
TB,N,V_hasBeenSubmitted
Tq,N,V_priority
General
Recognizer
RecognitionSession
StrokeGrouping
ClutterFiltering
RemoteRecognizer
TextCorrectionRecognizer
CoreHandwritingSignPosts
com.apple.corehandwriting
CHTokenizedTextResultColumn.m
tokenRows
@"NSString"24@?0@"NSArray"8q16
@"NSString"24@?0@"CHTokenizedTextResultToken"8q16
[%p "%@" %.2f, %.2f]
  %@
 rows: %ld {
v32@?0@"NSArray"8Q16^B24
token
T@"NSArray",R,C,N,V_tokenRows
T@"NSIndexSet",R,N
Invalid index %ld when trying to replace a row from column with %lu rows.
Invalid index %ld when trying to remvove a row from column with %lu rows.
q24@?0@"NSArray"8@"NSArray"16
T@"NSArray",C,D,N
com.apple.CoreHandwriting.StrokeGroupID
CHStrokeGroup.mm
 uniqueID: %ld, ancestorID: %ld, bounds: {x: %0.1f, y: %0.1f, width: %0.1f, height: %0.1f}, strokes: %ld, strategy: %@
Cannot have nil strokeIdentifiers
ancestorIdentifier
uniqueIdentifier
firstStrokeIdentifier
lastStrokeIdentifier
classification
groupingConfidence
{CGPoint=dd}
firstStrokeOrigin
No group found for stroke identifier %@, All strokes should belong to a group.
Tq,R,N,V_uniqueIdentifier
Tq,R,N,V_ancestorIdentifier
T{CGPoint=dd},R,N,V_firstStrokeOrigin
averageWritingOrientation
T{CGVector=dd},R,N
T@"NSSet",R,N,V_strokeIdentifiers
T@"CHEncodedStrokeIdentifier",R,N,V_firstStrokeIdentifier
T@"CHEncodedStrokeIdentifier",R,N,V_lastStrokeIdentifier
Tq,R,N,V_classification
Td,R,N,V_groupingConfidence
T@"NSString",R,N,V_strategyIdentifier
CHRecognitionSessionTextInputTask.mm
initialTextInputTargets
targetContentInfo
The strokes count in the drawing (%ld) must match the ones in the result (%ld).
The strokes count in the original drawing (%ld) must match the ones in the result (%ld).
inputTargetDataSource
v16@?0@"CHTextInputTargetContentInfo"8
dataSource
v32@?0@8Q16^B24
delegate
T@"<CHRecognitionSessionTextInputTaskDelegate>",D,N
T@"NSLocale",R,N
T@"NSArray",R,&,N,V_initialTextInputTargets
activeTextInputQuery
T@"CHTextInputQuery",&,N,V_activeTextInputQuery
 ID: %@, frame: {x: %0.1f, y: %0.1f, width: %0.1f, height: %0.1f}
inputTargetIdentifier
frameXOrigin
frameYOrigin
frameWidth
frameHeight
T@"NSNumber",R,C,N,V_inputTargetIdentifier
frame
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_frame
B24@?0@"CHSubstrokePlacement"8@"NSDictionary"16
CHTextLineStrokeGroup.mm
There should be at least one substroke covering one of the %lu strokeIdentifiers.
The number of points in the raw baseline estimate must be > 0 at this point.
writingDirectionSortedStrokeIdentifiers
writingDirectionSortedSubstrokes
averageStrokeDeviation
localStrokeWritingOrientations
lastSubstrokeIndexBeforeMerge
coalescedLastSubstrokes
T@"NSArray",R,&,N,V_writingDirectionSortedStrokeIdentifiers
NSIndexPath *modifyIndexPath(NSIndexPath *, NSUInteger, NSUInteger)
CHUtilities.mm
The length of the computed path must be the same as the input
%@-%@_%@
%@_%@
%@-%@
 Low confidence, reporting nil.
Title Query %p
transcribedTitle
T@"NSString",R,C,N,V_transcribedTitle
titleStrokeIdentifiers
T@"NSSet",R,C,N,V_titleStrokeIdentifiers
class: %@ score: %3.5f string: %@
score
Td,V_score
T@"NSString",R,V_string
wordRanges
T@"NSArray",R,V_wordRanges
wordIDs
T@"NSArray",R,V_wordIDs
wordRecognitionScores
T@"NSArray",R,V_wordRecognitionScores
wordCombinedScores
T@"NSArray",R,V_wordCombinedScores
wordStrokeSets
T@"NSArray",R,V_wordStrokeSets
wordLexicalEntries
T@"NSArray",R,V_wordLexicalEntries
wordPatternEntries
T@"NSArray",R,V_wordPatternEntries
rareWordIndexes
T@"NSIndexSet",R,V_rareWordIndexes
inappropriateWordIndexes
T@"NSIndexSet",R,V_inappropriateWordIndexes
isTextReplacement
TB,R,V_isTextReplacement
rotation
Td,R,V_rotation
startEndpointType
Ti,R,V_startEndpointType
endEndpointType
Ti,R,V_endEndpointType
startLocation
T{CGPoint=dd},R,V_startLocation
endLocation
T{CGPoint=dd},R,V_endLocation
midpointLocation
T{CGPoint=dd},R,V_midpointLocation
controlPoint
T{CGPoint=dd},R,V_controlPoint
pathPoints
T@"NSArray",R,V_pathPoints
cornerLine
TB,R,V_cornerLine
center
T{CGPoint=dd},R,V_center
size
T{CGSize=dd},R,V_size
upperLeftPoint
T{CGPoint=dd},R,V_upperLeftPoint
upperRightPoint
T{CGPoint=dd},R,V_upperRightPoint
lowerLeftPoint
T{CGPoint=dd},R,V_lowerLeftPoint
lowerRightPoint
T{CGPoint=dd},R,V_lowerRightPoint
vertex1
T{CGPoint=dd},R,V_vertex1
vertex2
T{CGPoint=dd},R,V_vertex2
vertex3
T{CGPoint=dd},R,V_vertex3
stemLocation
T{CGPoint=dd},R,V_stemLocation
stemWidth
Td,R,V_stemWidth
Freeform
CHSearchQuery.m
session
v16@?0@"NSIndexSet"8
Stroke index %ld in search result out of group stroke count %ld.
v32@?0{_NSRange=QQ}8^B24
queryString
Search Query %p
foundItems
T@"NSArray",C,N,S_setFoundItems:,V_foundItems
T@"NSString",C,N,V_queryString
 strokeIdentifiers: %@
item should be of class CHSearchQueryItem: %@
CHVisualization.m
recognitionSession
T@"CHRecognitionSession",R,&,N,V_recognitionSession
T@"<CHVisualizationDelegate>",N,V_delegate
layeringPriority
wantsInputDrawings
nextFIFO
T@"CHPointFIFO",&,N,V_nextFIFO
strokes
T@"CHDrawing",&,N,V_strokes
T@"CHDrawing",&,N,V_drawing
prevPoints
T{vector<float __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^^{__compressed_pair<float * __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^}},N,V_prevPoints
width
TQ,N,V_width
spacing
Tf,N,V_spacing
points
T{vector<float __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^^{__compressed_pair<float * __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^}},N,V_points
controlPoints
T{vector<float __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^^{__compressed_pair<float * __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^}},N,V_controlPoints
lastPoint
T,N,V_lastPoint
drawingTarget
T@"<CHPointFIFODrawingTarget>",&,N,V_drawingTarget
unitScale
Tf,N,V_unitScale
emitInterpolatedPoints
TB,N,V_emitInterpolatedPoints
emissionHandler
T@?,C,V_emissionHandler
path
T^{CGPath=},N,V_path
lineWidth
Td,N,V_lineWidth
CHTextInputGesture.mm
CHTextInputGesture does not support the text correction type.
The affected range to be trimmed must be valid
Refined stroke ranges can only be computed for scribble, circle or polygon result types
The initial affected text range must be valid
Character range cannot be undefined.
The input string and range must be compatible with each other
Range %@ out of string length %ld
leadingExpansion cannot be negative: %ld
trailingExpansion cannot be negative: %ld
inputString
Character index %lu beyond bounds for string length: %lu
The searching range must be valid
There must be a valid character closest to the point
The drawing cannot be empty
_textResult
T@"CHTokenizedTextResult",&,N,V__textResult
_storedAffectedRange
T{_NSRange=QQ},N,V__storedAffectedRange
gestureType
Tq,N,V_gestureType
T@"CHTextInputTargetContentInfo",R,N,V_targetContentInfo
T@"NSLocale",R,N,V_locale
normalizedDrawing
T@"CHDrawing",R,N,V_normalizedDrawing
originalDrawing
T@"CHDrawing",R,N,V_originalDrawing
preferCharacterLevel
TB,R,N,V_preferCharacterLevel
lastStroke
T@"<CHStroke>",R,N,V_lastStroke
The stroke covered range must be within the reference substring range
The computed character index (%li) must be valid in the string (length=%li)
caretTipPoint
T{CGPoint=dd},R,N,V_caretTipPoint
0x%x
ctc_en
CHCTCRecognitionModel.mm
An error occurred in the %@ model when extracting features: %@
output_topk_indices
decodingPruningPolicy
T{CVNLPTextDecodingPruningPolicy=qBfI},R,N,V_decodingPruningPolicy
_activationsDomain
Tq,R,V__activationsDomain
_distMean
Td,R,V__distMean
_distStd
Td,R,V__distStd
_stringCodeMap
T@"NSOrderedSet",R,&,V__stringCodeMap
_interpointDistance
Td,R,V__interpointDistance
_hasBatchFirstFeatureArrayShape
TB,R,V__hasBatchFirstFeatureArrayShape
sequenceCompression
Tq,R,N,V_sequenceCompression
distanceFeatureIndex
Tq,R,N,V_distanceFeatureIndex
sinAlphaFeatureIndex
Tq,R,N,V_sinAlphaFeatureIndex
cosAlphaFeatureIndex
Tq,R,N,V_cosAlphaFeatureIndex
gapFeatureIndex
Tq,R,N,V_gapFeatureIndex
directionalFeaturesInputName
T@"NSString",R,&,N,V_directionalFeaturesInputName
characterProbabilityOutputName
T@"NSString",R,&,N,V_characterProbabilityOutputName
codeMap
T^{CHCodeMap=*Q^II},R,N,V_codeMap
blankIndex
Tq,R,N,V_blankIndex
spaceIndex
Tq,R,N,V_spaceIndex
CHTokenizedTextResult.mm
columns
paths
transcriptionPaths count (%ld) != scores count (%ld)
kBestPathsTokens
kBestPathsProb
transcriptionPaths count (%ld) != probabilities count (%ld)
B24@?0Q8^B16
transcriptionPaths count (%ld) != probabilities count (%ld) after tokenized result is built
tokenColumns
transcriptionPaths
transcriptionPathScores
trailingSeparator
recognizerGenerationIdentifier
precedingLineBreaks
changeableTokenColumns
column
@"NSString"24@?0@"CHTokenizedTextResultColumn"8q16
rows
%ld %@
transcriptionPath
Column %ld %@
 %ld (%ld changeable) %@ [%@], %ld %@ 
Gen1
Gen2
The character range must be compatible with the top transcription
Error: Tokenized text result without any transcription path encountered when computing language fitness.
en_US
tokenColumnCount
changeableTokenColumnCount
T@"NSString",R,C,N,V_trailingSeparator
T@"NSArray",R,C,N,V_transcriptionPaths
T@"NSArray",R,C,N,V_transcriptionPathScores
topTranscription
recognizerDebugDescription
B32@?0@"NSIndexPath"8Q16^B24
v48@?0r^I8q16d24q32^B40
abcxyz
ErrorModel
errorModel
T@"CHSpellCheckerErrorModel",&,N,V_errorModel
CHStrokeClutterFilter.mm
found an unknown stroke ID %@ to be removed in clutter filtering
clutter filter inconsistent status: %lu <==> %lu
Cannot find corresponding stroke ID given the item ID: %@
calling strokeIDsWithinRegionOfInterest() while clutter filter being in inconsistent status: %lu <==> %lu
highDensityStrokeCount
modelName
T@"NSString",R,&,N,V_modelName
masking_1/mul:0
time_distributed_1/Reshape_1:0
time_distributed_2/Reshape_1:0
time_distributed_3/Reshape_1:0
stroke_classification
_model
T^{MontrealNeuralNetwork=},R,N,V__model
inputNames
T@"NSArray",R,&,N,V_inputNames
featureCounts
T@"NSDictionary",R,&,N,V_featureCounts
outputNames
T@"NSArray",R,&,N,V_outputNames
classCounts
T@"NSDictionary",R,&,N,V_classCounts
model
T@"MLModel",R,&,N,V_model
resourcePath
T@"NSString",R,&,N,V_resourcePath
CHRecurrentNeuralNetwork.mm
An error occurred in the %@ model when extracting features
v56@?0@"CHDrawing"8@"NSString"16^f24{_NSRange=QQ}32^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}48
An error occurred in the %@ model during prediction: %@
spaceProbabilityOutputName
T@"NSString",R,&,N,V_spaceProbabilityOutputName
charBoundaryProbabilityOutputName
T@"NSString",R,&,N,V_charBoundaryProbabilityOutputName
delayedStrokeProbabilityOutputName
T@"NSString",R,&,N,V_delayedStrokeProbabilityOutputName
distanceLeftFeatureIndex
Tq,R,N,V_distanceLeftFeatureIndex
distanceRightFeatureIndex
Tq,R,N,V_distanceRightFeatureIndex
sinAngleLeftFeatureIndex
Tq,R,N,V_sinAngleLeftFeatureIndex
cosAngleLeftFeatureIndex
Tq,R,N,V_cosAngleLeftFeatureIndex
sinAngleRightFeatureIndex
Tq,R,N,V_sinAngleRightFeatureIndex
cosAngleRightFeatureIndex
Tq,R,N,V_cosAngleRightFeatureIndex
endpointFeatureIndex
Tq,R,N,V_endpointFeatureIndex
cutpointProbabilityOutputName
T@"NSString",R,&,N,V_cutpointProbabilityOutputName
sinAngleFeatureIndex
Tq,R,N,V_sinAngleFeatureIndex
cosAngleFeatureIndex
Tq,R,N,V_cosAngleFeatureIndex
textStrokeProbabilityOutputName
T@"NSString",R,&,N,V_textStrokeProbabilityOutputName
input
output
strokeGroup1
T@"NSArray",R,&,N,V_strokeGroup1
strokeGroup2
T@"NSArray",R,&,N,V_strokeGroup2
groupBounds1
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_groupBounds1
groupBounds2
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N,V_groupBounds2
transitionTime
Td,R,N,V_transitionTime
orderedStrokes
T@"NSArray",R,&,N,V_orderedStrokes
orderedStrokesGroup1
T@"NSArray",R,&,N,V_orderedStrokesGroup1
orderedStrokesGroup2
T@"NSArray",R,&,N,V_orderedStrokesGroup2
substrokeCount1
Tq,R,N,V_substrokeCount1
substrokeCount2
Tq,R,N,V_substrokeCount2
CHTopDownStrokeGroupingStrategy.mm
At least one stroke is needed to calculate accumulated time differences
timeWindowStrategy
startTimestamp
Td,R,N,V_startTimestamp
endTimestamp
Td,R,N,V_endTimestamp
CHTimeWindowStrokeGroupingStrategy.m
CHRecognitionSessionTask.mm
Use designated initializer instead
The preferred locales list cannot be empty.
com.apple.CoreHandwriting.RecognitionSessionRecognizers
Recognition tasks can only be executed once: %@
delegate cannot be nil when the task starts
B8@?0
CHRecognitionTaskOverhead
strokeGroupingResult cannot be nil for a non-cancelled task.
Invalid status transition from %ld to %ld.
CHRecognitionSessionLogging
InternalBuild
Oji6HRoPi7rH7HPdWVakuw
outputResult
T@"CHRecognitionSessionResult",&,N,S_setOutputResult:,V_outputResult
status
Tq,N,S_setStatus:,V_status
_recognizersQueue
T@"NSObject<OS_dispatch_queue>",R,&,N,V__recognizersQueue
strokeClassificationModel
T@"CHStrokeClassificationModel",R,&,N,V_strokeClassificationModel
subjectStrokeIdentifiers
T@"NSArray",R,&,N,V_subjectStrokeIdentifiers
cancelled
TB,V_cancelled
partialResultBlock
T@?,C,N,V_partialResultBlock
inputResult
T@"CHRecognitionSessionResult",R,&,N,V_inputResult
T@"<CHRecognitionSessionTaskDelegate>",N,V_delegate
recognitionLocales
T@"NSArray",R,C,N,V_recognitionLocales
strokeGroupingRequirement
Tq,R,N,V_strokeGroupingRequirement
isHighResponsivenessTask
TB,R,N,V_isHighResponsivenessTask
saveInputDrawings
TB,N,V_saveInputDrawings
forceRecognitionStrokeGroupIdentifiers
T@"NSSet",C,N,V_forceRecognitionStrokeGroupIdentifiers
strokeGroupingOnly
TB,N,V_strokeGroupingOnly
Text Input Query %p
availableItems
T@"NSArray",C,N,S_setAvailableItems:,V_availableItems
totalDuration
Td,N,V_totalDuration
textInputTargetsDataSource
T@"<CHTextInputQueryTargetDataSource>",V_textInputTargetsDataSource
, error: %@
 text: '%@', itemID: %@, stableItemID: %@, type: %ld, strokes: %ld%@
CHTextInputQuery.m
item should be of class CHTextInputQueryItem: %@
itemIdentifier
T@"NSNumber",R,N,V_itemIdentifier
itemStableIdentifier
T@"NSNumber",R,N,V_itemStableIdentifier
correctionResult
T@"CHTextCorrectionResult",R,N,V_correctionResult
CHDataDetectorQuery.mm
There must be a preferred locale for the filtered results.
gjpqyz
v32@?0@"NSDictionary"8@"NSDictionary"16@"DDScannerResult"24
The stroke indexes matching data detected content should be non-empty [%@]
Data Detector Query %p
 strokeIdentifiers: %@, result type: %@
item should be of class CHDataDetectorQueryItem: %@
dataDetectorResult
T@"DDScannerResult",R,&,N,V_dataDetectorResult
estimatedBaseline
Tr^{CGPath=},R,N,V_estimatedBaseline
convexHull
curvature
Td,R,N,V_curvature
substroke
writingOrientation
strokeDeviation
originalWritingDirectionIndex
coalescedCenter
T@"CHSubstroke",R,&,N,V_substroke
T{CGVector=dd},N,V_writingOrientation
T{CGVector=dd},N,V_strokeDeviation
Tq,N,V_originalWritingDirectionIndex
T{CGPoint=dd},N,V_coalescedCenter
%.10g
Helvetica-Bold
Stroke group classification: 
text
clutter
doodle
line
container
unknown
CTFontCreateWithName
/System/Library/Frameworks/CoreText.framework/CoreText
CTParagraphStyleCreate
CTFramesetterCreateWithAttributedString
CTFramesetterCreateFrame
CTFrameDraw
kCTFontAttributeName
kCTForegroundColorAttributeName
kCTParagraphStyleAttributeName
{%f, %f}
v56@?0q8{CHLineSegment={CGPoint=dd}{CGPoint=dd}}16^B48
CHPolygon.mm
area
Td,N,V_area
vertexCount
Tq,R,N,V_vertexCount
vertices
T^{CGPoint=dd},R,N,V_vertices
resultDrawn
T@"CHRecognitionSessionResult",&,N,V_resultDrawn
activeStrokeGroupAncestorIdentifiers
T@"NSSet",C,N,V_activeStrokeGroupAncestorIdentifiers
T@"<CHStrokeGroupBasedVisualizationDelegate>",D,N
newGroupsDefaultToActive
TB,R,N,V_newGroupsDefaultToActive
com.apple.handwritingd.remoterecognition
CHRemoteRecognizer.mm
A locale is required to build the remote recognition request
v16@?0@"NSError"8
v32@?0@"NSArray"8@"NSArray"16@"NSError"24
XPC connection must be non-nil
v24@?0@"CHTokenizedTextResult"8@"NSError"16
_connection
T@"NSXPCConnection",R,N,V__connection
Ti,R,N,V_recognitionMode
T@"NSLocale",R,C,N,V_locale
TB,R,N,V_enableCachingIfAvailable
TB,R,N,V_enableGen2ModelIfAvailable
TB,R,N,V_enableGen2CharacterLMIfAvailable
StrokeBounds
SubstrokeBounds
StrokePoints
GroupBounds
Grouping
GroupClassification
GroupBaselineLegacy
GroupBaseline
NormalizedDrawing
NormalizedDrawingAll
Stroke Bounds
Substroke Bounds
Stroke Points
Stroke Group Bounds
Stroke Groups by Color
Stroke Groups Classification
Stroke Groups Baseline (Legacy)
Stroke Groups Baseline
Normalized Drawing (Selective)
Normalized Drawing (All)
CHStatusKeyStatus
CHStatusKeyEnvironment
CHStatusKeyLocales
CHStatusKeyLastDurationTotal
CHStatusKeyLastDurationDetailed
CHStatusStrokeCount
CHStatusKeyGroupCount
CHStatusKeyTranscript
CHStatusKeyAllResults
Status
Environment
Locales
Total Duration
Detailed
Stroke Count
Group Count
Transcript
Text Results
CHVisualizationManager.mm
Use initWithRecognitionSession: instead.
visualizationID
In process
Out of process
Automatic
%@ (%@)
@"NSString"24@?0@"NSLocale"8q16
%0.2fs
%0.2fs clutter filtering, %0.2fs Stroke class., %0.2fs Grouping, %0.2fs Recog.
%ld text, %ld non-text
Group %ld (ID: %ld)
<Status Reporting Disabled>
visualizationIdentifier
Cannot activate an already active visualization
q24@?0@"NSString"8@"NSString"16
v32@?0@"NSNumber"8@"NSNumber"16^B24
_enabledVisualizationIDs
T@"NSMutableSet",R,&,N,V__enabledVisualizationIDs
_activeVisualizationIDs
T@"NSMutableArray",R,&,N,V__activeVisualizationIDs
_activeVisualizationsByID
T@"NSMutableDictionary",R,&,N,V__activeVisualizationsByID
_strokeGroupIndexByAncestorID
T@"NSMutableDictionary",R,&,N,V__strokeGroupIndexByAncestorID
_registeredAsChangeObserver
TB,N,V__registeredAsChangeObserver
_registeredAsInputDrawingsClient
TB,N,V__registeredAsInputDrawingsClient
T@"<CHVisualizationManagerDelegate>",N,V_delegate
statusReportingEnabled
TB,N,V_statusReportingEnabled
Transcription Query %p
CHQuery.m
com.apple.CoreHandwriting.QueryProcessing
_queryActive
TB,N,V__queryActive
lastProcessedStrokeProviderVersion
T@"<CHStrokeProviderVersion>",C,V_lastProcessedStrokeProviderVersion
T@"<CHQueryDelegate>",N,V_delegate
preferredUpdatesInterval
Td,N,V_preferredUpdatesInterval
Query %p
processingQueue
T@"NSObject<OS_dispatch_queue>",R,&,N
debugName
T@"CHTokenizedTextResult",&,N,V_textResult
terminatingSpecialCharacter
T@"NSString",&,N,V_terminatingSpecialCharacter
textResults
T@"NSArray",&,N,V_textResults
<div style="clear:both;margin:auto;font-size:250%%;" >
<p>WARNING : NOTHING WAS SAVED : YOU MUST CLICK ON THE FOLLOWING LINK !</p>
<p><a href="#" onclick="SendMail(%d);">Send via email to Antoine !</a></p>
</div>
<p>For information, here are the files you flagged:</p>
<p id="po-term%d" style="margin:0;" \>
</body>
</html>
Text
Encircle
Polygon
SplitJoin
Insertion Caret
CHTextCorrectionResult.m
inputTarget
<%@: %p> "%@"
 inputTargetID: %@, affectedRange: %@, resultType: %@, textResult: %@, isCharacterLevel: %@, error: %@
affectedRange
resultType
isCharacterLevel
error
T@"CHTextInputTarget",R,N,V_inputTarget
T{_NSRange=QQ},R,N,V_affectedRange
T@"CHTokenizedTextResult",R,N,V_textResult
Tq,R,N,V_resultType
characterLevel
TB,R,N,GisCharacterLevel,V_characterLevel
T@"NSError",R,N,V_error
MultiCharacter
MultiCharacterOverlapped
SingleCharacter
Sketch
MultiCharacterInline
Default
Digits
PhoneNumber
Username
EmailAddress
ASCII
Equation
Words
Sentences
AllUppercase
AllLowercase
English
French
Spanish
Italian
German
Chinese
Cantonese
SimplifiedChinese
TraditionalChinese
Roman
 Recognizer configuration with mode: %@, locale: %@, contentType: %@, autoCapitalizationMode: %@, language: %@, script: %@
zh_Hans
zh_Hant
Latn
Hans
Hant
none
%@-%ld-%@-%@
CHRecognizerConfiguration.mm
Recognizer configuration needs to be defined
zh_hant
v44@?0^{__CFURL=}8i16^{__CFLocale=}20^{__CFString=}28^B36
corpus.wid
odat
P.bin
PP.bin
G.bin
R.bin
synthetics_
zh-Hans
zh-Hant
bundle
zh_compact
vo_en_compact
vo_de
vo_other
An error occurred when loading the English CTC model
An error occurred when loading the Chinese CTC model
mode
Ti,R,N,V_mode
contentTypeForNoSpaceRecognition
Invalid empty FST line entry
File not found: (
Node[
has out degree zero but is not marked as a final node
has in degree zero but is not marked as an initial node
void Network::mergeEquivalentEdges(vector<NetworkEdge> &)
Network.mm
Error when merging equivalent edges: index out of bounds
LatticePaths Network::kBestPaths(const NodeIndex, const NodeIndex, const NSUInteger, const LXLexiconRef, LXCursorRef, const LXMutableLexiconRef, LXCursorRef, CHPatternNetwork *, NetworkCursor *, CHRecognitionContentType, const LMLanguageModelRef, BOOL, double (^)(const NetworkEdge &), double (^)(LatticePath *), BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, const std::map<CHStrokeIndex, double> &, LatticePaths *)
Inconsistent network structure: edge with start node %zu belong in output edges of node %zu 
0x%zx
_strokeProviderDrawn
T@"<CHStrokeProvider>",&,N,V__strokeProviderDrawn
sessionVersion
sessionResultVersion
Tq,R,N,V_sessionVersion
Tq,R,N,V_sessionResultVersion
Initial
Accumulating
Processing
Finished
stroke_classification.dat
CHRecognitionSession.mm
Queue setup can only be performed once.
com.apple.CoreHandwriting.RecognitionSessionCanvasTaskSharedTarget
com.apple.CoreHandwriting.RecognitionSessionCanvasHighResponsivenessTask
com.apple.CoreHandwriting.RecognitionSessionTextInputTaskSharedTarget
com.apple.CoreHandwriting.RecognitionSessionTask
com.apple.CoreHandwriting.RecognitionSession
v16@?0@"<CHRecognitionSessionObserver>"8
notificationBlock
dataSource %@ returned a nil strokeProviderSnapshot.
latestStrokeProvider cannot be nil when scheduling change processing.
v16@?0@"CHRecognitionSessionResult"8
Unimplemented
version
lastRecognitionResult
_textRecognitionLocales
T@"NSArray",C,N,S_setTextRecognitionLocales:,V__textRecognitionLocales
T@"CHRecognitionSessionResult",&,S_setLastRecognitionResult:
Tq,N,S_setStatus:
latestStrokeProvider
T@"<CHStrokeProvider>",&,S_setLatestStrokeProvider:
_hasUnprocessedChanges
TB,N,S_setHasUnprocessedChanges:,V__hasUnprocessedChanges
_recognizersByLocaleID
T@"NSMutableDictionary",R,&,N,V__recognizersByLocaleID
_latestTextInputTargets
T@"NSArray",&,S_setLatestTextInputTargets:,V__latestTextInputTargets
_correctionRecognizersByLocaleID
T@"NSMutableDictionary",R,&,N,V__correctionRecognizersByLocaleID
_changeCoalescingIndex
TQ,N,V__changeCoalescingIndex
_changeObservers
T@"NSMutableArray",R,&,N,V__changeObservers
_inputDrawingClients
T@"NSMutableArray",R,&,N,V__inputDrawingClients
_tasksWorkQueue
T@"NSObject<OS_dispatch_queue>",R,&,N,V__tasksWorkQueue
_sessionQueue
T@"NSObject<OS_dispatch_queue>",R,&,N,V__sessionQueue
_highResponsivenessQueue
T@"NSObject<OS_dispatch_queue>",R,&,N,V__highResponsivenessQueue
_taskQueueQoSClass
TI,R,N,V__taskQueueQoSClass
_activeTasks
T@"NSMutableArray",R,&,N,V__activeTasks
_shouldForceFastGrouping
TB,S_setShouldForceFastGrouping:,V__shouldForceFastGrouping
Tq,R,N,V_mode
T@"NSArray",C,N,V_preferredLocales
T@"NSArray",C,N
T@"<CHRecognitionSessionDataSource>",N,V_dataSource
Tq,N,V_recognitionEnvironment
sessionData
T@"NSData",R,N
allow_next_gen_char_lm_for_graphite
apply_autocapitalization
B32@?0@"NSValue"8Q16^B24
B32@?0@"NSLocale"8Q16^B24
The tokenization level must be CHStrokeTokenizationLevelStroke to be compatible with fastGroupingResult=nil
foundStrokeIdentifiers is nil
A cached result must exist when calling _strokeIdentifiersFromCachedResultUsingContextStrokes:tokenizationLevel:
A cached result must exist when calling _contextualTextResultsFromCachedResultUsingContextStrokes:shouldCancel:
Context results must be non-nil
T@"CHRecognitionSessionVersion",R,&
T@"CHRecognitionSessionResult",R,&
T@"<CHStrokeProvider>",R,&
T@"CHTextInputQuery",N
shouldForceFastGrouping
CHTextCorrectionRecognizer.mm
The original and rescaled drawings should have equal stroke counts
The original and rescaled drawings should have equal total point counts
Expected nil or valid tokenized result as output of CHTextCorrectionRecognizer.
Invalid stroke covered range when recognizing editing gesture. %@
Cannot recognize editing gesture for drawing with %ld strokes.
Unexpected number of token columns in text result refinement for single character mode. Expected 1 token column, got %lu
_textRecognizer
T@"<CHRecognizing>",R,N,V__textRecognizer
_shapeRecognizer
T@"CHRecognizer",R,N,V__shapeRecognizer
_cornerDetector
T@"CHCornerDetector",R,N,V__cornerDetector
T@"NSLocale",R,&,N,V_locale
isRemoteRecognition
TB,R,N,V_isRemoteRecognition
CHCharacterSetsRules.mm
com.apple.CoreHandwriting.CHCharacterSetsRules
^*+=<>.,
:'"-/
apmAPM.
strdndth.
:;B=
)(pPDoOxX*
_-.+
_-.:/+&?%()$=
-/.@_
lowercaseCharSet
T@"NSCharacterSet",&,N,V_lowercaseCharSet
uppercaseCharSet
T@"NSCharacterSet",&,N,V_uppercaseCharSet
digitCharSet
T@"NSCharacterSet",&,N,V_digitCharSet
startPunctuationCharSet
T@"NSCharacterSet",&,N,V_startPunctuationCharSet
middlePunctuationCharSet
T@"NSCharacterSet",&,N,V_middlePunctuationCharSet
endOfWordPunctuationCharSet
T@"NSCharacterSet",&,N,V_endOfWordPunctuationCharSet
endOfSentencePunctuationCharSet
T@"NSCharacterSet",&,N,V_endOfSentencePunctuationCharSet
digitStartPunctuationCharSet
T@"NSCharacterSet",&,N,V_digitStartPunctuationCharSet
digitEndPunctuationCharSet
T@"NSCharacterSet",&,N,V_digitEndPunctuationCharSet
arithmeticOperatorCharSet
T@"NSCharacterSet",&,N,V_arithmeticOperatorCharSet
dateTimeSeparatorCharSet
T@"NSCharacterSet",&,N,V_dateTimeSeparatorCharSet
dateTimeEndLetterCharSet
T@"NSCharacterSet",&,N,V_dateTimeEndLetterCharSet
numeralEndLetterCharSet
T@"NSCharacterSet",&,N,V_numeralEndLetterCharSet
lexiconSkipCharSet
T@"NSCharacterSet",&,N,V_lexiconSkipCharSet
containsDotCharSet
T@"NSCharacterSet",&,N,V_containsDotCharSet
containsTwoDotsCharSet
T@"NSCharacterSet",&,N,V_containsTwoDotsCharSet
prefixCapitalizationExceptionCharSet
T@"NSCharacterSet",&,N,V_prefixCapitalizationExceptionCharSet
selfLoopPunctuationCharSet
T@"NSCharacterSet",&,N,V_selfLoopPunctuationCharSet
emoticonTopCharSet
T@"NSCharacterSet",&,N,V_emoticonTopCharSet
emoticonMiddleCharSet
T@"NSCharacterSet",&,N,V_emoticonMiddleCharSet
emoticonBottomCharSet
T@"NSCharacterSet",&,N,V_emoticonBottomCharSet
emailAtCharSet
T@"NSCharacterSet",&,N,V_emailAtCharSet
emailPunctuationCharSet
T@"NSCharacterSet",&,N,V_emailPunctuationCharSet
urlPunctuationCharSet
T@"NSCharacterSet",&,N,V_urlPunctuationCharSet
nonSpaceSeparatorCharSet
T@"NSCharacterSet",&,N,V_nonSpaceSeparatorCharSet
strokeMaxPenalties
T{map<unsigned int, unsigned long, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned long> > >={__tree<std::__1::__value_type<unsigned int, unsigned long>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true> >=Q}}},N,V_strokeMaxPenalties
signatureUniChar
T{map<unsigned int, int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, int> > >={__tree<std::__1::__value_type<unsigned int, int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true> >=Q}}},N,V_signatureUniChar
_charSetRulesQueue
T@"NSObject<OS_dispatch_queue>",R,&,N,V__charSetRulesQueue
substrokePlacementsByStrokeIdentifier
T@"NSDictionary",R,&,N,V_substrokePlacementsByStrokeIdentifier
vertical
horizontal
CHBottomUpStrokeGroupingStrategy.mm
Stroke group can't be nil and must be of CHTextLineStrokeGroup class.
There must be at least one substroke in the input for the coalescing algorithm.
q24@?0@"CHSubstrokePlacement"8@"CHSubstrokePlacement"16
q24@?0@"CHTextLineStrokeGroup"8@"CHTextLineStrokeGroup"16
strokeClassificationLastResult
T@"CHStrokeClassificationResult",R,&,N,V_strokeClassificationLastResult
textOnly
TB,R,N,V_textOnly
PKStrokesDrawn
PKSmartSelection
PKCopyAsText
PKSmartShapes
PKInsertSpace
PKDataDetector
com.apple.corehandwriting.fast_stroke_grouping
CHFastStrokeGroupingStrategy.mm
Fast grouping result must exist for the requested tokenization type
CHStrokeGroupBaselineLegacyVisualization.m
Invalid stroke index %ld
IndexableContent Query %p
indexableContent
T@"CHRecognitionSessionIndexableContent",&,S_setIndexableContent:,V_indexableContent
indexableTextRepresentation
T@"NSString",R,C,N,V_indexableTextRepresentation
presentableTextRepresentation
T@"NSString",R,C,N,V_presentableTextRepresentation
fastGroupingClusters
T{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}},R,N,V_fastGroupingClusters
stateType
TQ,N,V_stateType
0x61a649a
0x34f55ec
0x7f7446f
0xe6b391a
0x08d4b39
0xbdde29e
0x633a6c7
0x346ff32
0xf9be5b7
0xf9dd946
0x27087b3
0x5fb9dc5
0xcf06682
0xcff9621
leftContext
T@"NSString",&,N,V_leftContext
Ti,V_contentType
result
T@"CHMutableTokenizedTextResult",&,N,V_result
sequence
T@"NSArray",&,N,V_sequence
defaultProcessor
T@"CHPostProcessingManager",&,N,V_defaultProcessor
digitProcessor
T@"CHPostProcessingManager",&,N,V_digitProcessor
phoneProcessor
T@"CHPostProcessingManager",&,N,V_phoneProcessor
usernameProcessor
T@"CHPostProcessingManager",&,N,V_usernameProcessor
emailProcessor
T@"CHPostProcessingManager",&,N,V_emailProcessor
urlProcessor
T@"CHPostProcessingManager",&,N,V_urlProcessor
asciiProcessor
T@"CHPostProcessingManager",&,N,V_asciiProcessor
equationProcessor
T@"CHPostProcessingManager",&,N,V_equationProcessor
CHPostProcessingManager.mm
The best token index %ld is not contained in the returned tokens range %d, %ld
shouldAutocapitalize
TB,N,V_shouldAutocapitalize
recognizer
T@"CHRecognizer",N,V_recognizer
T@"NSLocale",N,V_locale
Tr^{_LXLexicon=},N,V_staticLexicon
Tr^{_LXLexicon=},N,V_customLexicon
Tr^{_LXLexicon=},N,V_phraseLexicon
Tr^{_LXLexicon=},N,V_customPhraseLexicon
consumableStrokesCharSet
T@"NSCharacterSet",&,N,V_consumableStrokesCharSet
fullWidthPunctuationThatExpectsUppercaseAfter
T@"NSCharacterSet",&,N,V_fullWidthPunctuationThatExpectsUppercaseAfter
wordID count %ld should match wordRangesInString count %ld
growingToken should not be nil
growingStrokesSet should not be nil
CHIdentifyLowAlignmentConfidenceColumnsStep unexpectedly decreased the changeable token column count.
@"CHTokenizedTextResultToken"40@?0@"CHTokenizedTextResultToken"8{?=qqq}16
shouldKeepOutOfPatternCandidates
TB,N,V_shouldKeepOutOfPatternCandidates
shouldKeepDuplicateTokenIDs
TB,N,V_shouldKeepDuplicateTokenIDs
shouldKeepOriginalSpelling
TB,N,V_shouldKeepOriginalSpelling
patternType
Tq,N,V_patternType
capitalizationToSplit
TB,N,V_capitalizationToSplit
convertToLowercase
TB,N,V_convertToLowercase
+#*'",. 
allowedCharacters
T@"NSCharacterSet",&,N,V_allowedCharacters
characterReplacements
T@"NSDictionary",&,N,V_characterReplacements
CHMergeColumnsNoWhiteSpaceStep removed all columns.
CHMergeColumnsNoWhiteSpaceStep set unexpected changeable token column count.
@24@?0@8q16
.,!?;:
?17TriangleRegressor
9Regressor
10CHTriangle
R@333333
?fffff
?333333
N/@333333
333333
Mb`?-C
6:?b2U0*
3?-C
MbP?
A@ffffff
 Bff
0E__
333333
15CHManhattanLine
6CHLine
12CHChatBubble
19ChatBubbleRegressor
6MatrixIfE
6CHStar
?UUUUUU
6MatrixIdE
@RRRRRR
?ffffff
?ffffff
______
?______
?______
VVVVVV
?______
9CHEllipse
?333333
______
?______
?______
VVVVVV
?333333
@333333
@333333
@333333
333333
333333
@333333
333333
@ffffff
333333
333333
333333
?333333
333333
?ffffff
15CHOutlinedArrow
11CHRectangle
12CHBasicShape
%@pz
18RectangleRegressor
2@NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
?^^^^^^
MbP?
@7CHCloud
UUUUUU
?UUUUUU
?14CHStraightLine
12CHBezierLine
?VVVVVV
?^^^^^^
?}}}}}}
9SymbolMap
333333
?333333
?333333
?333333
?333333
?333333
333333
ffffff
NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
VVVVVV
?7CHHeart
ffffff
es-8R
?ffffff
0Ees-8R
?es-8R
RRRRRR
C10CHPentagon
26CHRSketchRecognitionResult
%@: beginning update for result version %@.
%@: finished update for session %p. %ld item(s) available.
Failed to get stroke with id: %@ from stroke provider version %@
%@ decoding failed. Token string and stroke indexes are required to be nonnull when constructing a result token
Model execution on CPU only: %d
Model batch size: %d
Falling back to a batch size of %u for usesCPUOnly == %d
Error loading recognition model: %@
Error model output data format not supported: %ld
Error creating MLFeatures: %@
Configuration for recognizer with mode=%@ and locale=%@ is not supported.
Error loading the static lexicon: %@
Error loading the phrase lexicon: %@
Transliteration map is unexpectedly not defined for locale "%@".
Processing input as single character drawing with %lu segments and %lu delayed segments
Favoring alternative no-space-expansion path with transcription = %s 
shouldHavePrecedingSpace: No, or empty history
shouldHavePrecedingSpace: No, history ends in newline
shouldHavePrecedingSpace: no charLM
shouldHavePrecedingSpace: w/o:%f w/:%f space:%i w/o:'%@' w/:'%@'
BEGIN "CHActivationMatrix"
CHActivationMatrix
END "CHActivationMatrix"
BEGIN "CHDecoding"
Using the CVNLP Text Decoder
CHDecoding
END "CHDecoding"
Previous token stroke index set is empty, and current token %@ stroke index set is also empty
CHRecognizer is running RNN recognition pipeline: %d
BEGIN "CHNextGenRecognition"
CHNextGenRecognition
END "CHNextGenRecognition"
BEGIN "CHPostProcessing"
CHPostProcessing
END "CHPostProcessing"
BEGIN "CHSegmentAndDecode"
CHSegmentAndDecode
END "CHSegmentAndDecode"
  Stroke provider change added %ld strokes, removed %ld strokes.
  Ignoring %ld added strokes that cannot enumerate their points.
Stroke with no enumerable points found, recognition results may be affected. Stroke: %@
Drawing with no enumerable points found, recognition results may be affected. Drawing: %@
Warning: Less than %2.1f%% of the original points remain in the drawing after cleanup (before: %d, after: %d)
Error: computeSpatialFeaturesWithNoOverlapFromSparseBitmap: new bitmap size (%u) is larger than the original size (%u)
Error: computeSpatialFeaturesWithNoOverlapFromSparseBitmap: new bitmap size (%u) is equal to 0
%@ decoding failed. There was a problem decoding the stroke data.
The strokeCoveredTextRange %@ must be within the referenceSubstringRange %@
Trying to get support for unsupported non-text candidate class.
Stroke Grouping with strategies [%@]. Added strokes: %ld, removed strokes: %ld
Filtering results for locale %s, fitness %.2f < %.2f 
Successfully decoded and constructed a CHRemoteRecognitionRequest object: %@
%@ decoding failed. Locale and drawing are required to be non-null and priority has to be valid.
%@ decoding failed. Result token rows are required to be nonnull when constructing a request
Received nil target content info for target %@
Target content info is invalid, ignoring. referenceSubstring.length %ld != referenceSubstringRange.length %ld
Target content info is invalid, ignoring. selectedTextRange %@ invalid for length %ld
Target content info is invalid, ignoring. strokeCoveredTextRange %@ is not in range of referenceSubstringRange %@
Request for target content info timed out for target %@
Data detectors baseline approximation with %lu points, correction error = %.2f, number of substrokes %lu
%@: finished update for session %p. Length: %ld.%s
%@: finished update for session %p. Found %ld item(s).
Gesture recognized with type %ld, range  = %ld,%ld
No characters found on either side of the vertical bar stroke
An error occurred when trying to create feature provider for the %@ model: %@
An error occurred in the %@ model: %@
Unexpect rank of the CoreML output array: %lu
An error occurred in defining a new shape for the output: %@
Error in model %@. Expected output length: %lu, actual output length: %lu
An error occurred when trying to allocate feature array for the %@ model: %@
%@ decoding failed. Token columns, transcription paths, and scores are required to be nonnull and equal in size when constructing a text result
Incompatible index sets have no partition of common index sets.
Error: LMLanguageModelConditionalProbabilityVector returns false
clutter strokes: %lu, affected strokes: %lu, added strokes: %lu, removed strokes: %lu
debug quicklook window MaxCell=%lu
debug quicklook window size=[%lu, %lu]
debug quicklook: grid range X=[%ld, %ld], Y=[%ld, %ld]
An error occurred when loading model ("%@")
Model not found ("%@")
Canceling RNN recursive probability prediction
An error occurred running prediction with model: %@
An error occurred when loading a model: %@
Stroke Grouping with strategy %@. Added strokes: %ld, removed strokes: %ld
Stroke Grouping with strategy %@ triggered with 0 strokes in the stroke provider.
Best split (%lu/%lu) has score %.3f, splitting threshold is %.3f
SPLIT %lu/%lu: TS=%.3f, TT=%.3f, VD=%.3f, HD=%.3f, LT=%.3f, AR=%.3f, WD=%.3f, TF=%.3f, HS=%.3f, MH=%.3f, SC=%.3f, AL=%.3f
Could not find stroke for id: %@
Ran stroke classification in duration = %3.6f seconds
BEGIN "CHSessionTaskAccurateGrouping"
CHSessionTaskAccurateGrouping
END "CHSessionTaskAccurateGrouping"
Grouping algorithm not implemented: %ld
Recognition task almost finished, waiting for explicit overhead of %0.1fs.
Recognition results for version %@:
GroupingOnly option selected. Skipping the recognition and performing grouping only.
Beginning recognizer request for stroke group %ld, locale %@
Finished recognizer request for stroke group %ld, locale %@. Duration: %0.3f
CHTokenizedTextResult is nil
Recognizer finished for stroke group %ld, duration: %0.3fs
Running remote recognition
Remote Recognition error: %@
Running local recognition
Failed to run recognition on sub-drawing after %li attempts
Remote call to compute transcription paths error: %@
Recognition successful using %li sub-drawings
%@: finished update for session %p, version %@. %ld item(s) available.
Found %lu strokes in the data detected content but only %lu strokes in the entire stroke group: %@. Found stroke indexes: %@
The last stroke index found in the data detected content (#strokes=%lu) should be within the scope of the strokeIDs array (#strokes=%lu)
Remote connection to handwritingd was interrupted
Remote connection to handwritingd was invalidated
An XPC proxy service error occurred: %@
Error during recognition: %@
Result retrieved for %@
Error: unable to mmap resource %s
Error: Index %lu out of bounds of the code map %lu symbols
%@: start for session %p
%@: pause
%@: result changed, will dispatch to main queue to notify the delegate.
%@: result changed, but cannot notify delegate. queryActive: %@, delegate %p.
Resource for transliteration map not found for locale "%@" (script=%lu, language=%lu) with resource path "%s"
An error occurred when loading the stroke transition model
An error occurred when loading the cut point model
CHRecognizer is running rnn character language model: %d
found paths with incompatible number of segments covered from %zu to %zu: previous value %lu, value for new path %zu 
Unsupported Network Version %s
Error: LMLanguageModelConditionalProbabilityVector returns false in LMScoreVector 3Gram!
Error: LMLanguageModelConditionalProbabilityVector returns false in LMScoreVector 2Gram!
Error: unable to reallocate memory for path expansion.
Configuring RecognitionSession %p with preferred locales: %@. Effective locales: %@.
stroke provider visible strokes %lu
RecognitionSession %p received needsRecognitionUpdate request. Will trigger processing soon.
RecognitionSession %p cannot process needsRecognitionUpdate request. dataSource: %@, text recognition locales: %@.,  preferred locales: %@.
RecognitionSession %p cancelOngoingRequests. Cancelling %ld pending tasks. hasUnprocessedChanges %@->N. Last saved result for version: %@
RecognitionSession %p received request to rebuild recognition results. Stroke provider version: %@
RecognitionSession %p rebuilding recognition results. Cleared previous results. Will trigger processing soon.
RecognitionSession %p cannot process rebuildRecognitionResults request. dataSource: %@, text recognition locales: %@, preferred locales: %@.
RecognitionSession %p enqueueing recognition task for version %@.
RecognitionSession %p canceling pending task for version %@, superseded by request for version %@.
RecognitionSession %p trying to process changes, but there are no text recognition locales. Only grouping will be performed
RecognitionSession %p starting task for version: %@.
RecognitionSession %p finished task for version: %@. Duration: %0.3fs (%0.3fs G, %0.3fs R). Groups: %ld, created: %ld, deleted: %ld.
RecognitionSession %p finished task for version: %@. Cancelled: %s. Produced result: %s.
RecognitionSession %p has been serialized with preferredLocales: %@, recognitionEnvironment: %ld, priority: %ld, and lastRecognitionResult.
Last recognition result not loaded because session result version %ld does not match the current result version %ld.
RecognitionSession %p has been deserialized with preferredLocales: %@, recognitionEnvironment: %ld, priority: %ld, and lastRecognitionResult.
Nil RecognitionSession has been returned because session version %ld does not match the current session version %ld.
Visible stroke count: %lu, Ordered stroke count: %lu lastRecognitionResultIsValid: %d, _lastRecognitionResult: %p
Using last accurate results for tokenStrokeIdentifiersForContextStrokes results
Last accurate results for tokenStrokeIdentifiersForContextStrokes don't match visible strokes
Visible strokes not available in the stroke provider for fast grouping. Falling back on the ordered strokes.
Cached fast grouping line clusters not available. Computing line clusters on %lu strokes
Cached clutter filter not available. Creating new clutter filter
Using cached clutter filter for grouping query
Fast grouping duration: %2.2f seconds
Using cached fast grouping line clusters for grouping query
CHStrokeTokenizationLevelStroke requested, so avoiding any clustering or grouping
Canceling tokenStrokeIdentifiersForContextStrokes request
RecognitionSession %p starting high responsiveness task for version: %@.
CHTextCorrectRecognizer is running with automatic_prespaces feature: %d
doesIntersectNoSpaceRegion: %i isContainedInPaddedNoSpaceRegion: %i
doesIntersectSpaceRegion: %i isContainedInPaddedSpaceRegion: %i
SpaceBehavior: %li
Running stroke classification over %ld strokes
Index %ld out of bounds in normalized image for container support calculation.
Canceling agglomerative clustering results computation
%lu clusters found by the fast grouping algorithm
Canceling line cluster results computation
groupingResultForContextStrokes: %lu words found
%@: finished update for session %p. indexableContent length: %ld
CHLexiconCorrectionStep is running with autoCapitalizationMode: %@
CHTransliterateHalfWidthPunctuationStep is running
CHSemanticTokenizerStep is running
CHIdentifyLowAlignmentConfidenceColumnsStep is running
CHDropSpaceBeforePunctuationMarksStep is running
CHCandidateRefinementStep is running
CHRemoveSpacesFromStrongURLsAndEmailsStep is running
CHRemoveSpacesFromStrongURLsStep range: %@ stringLength: %li isEmail: %i isUrl: %i
CHRemoveSpacesFromSpecialFieldsStep is running
CHMergeColumnsNoWhiteSpaceStep is running
`"e"d"
"& 5"
N5l\SL
NZN+N@
N*N@
!`$a$b$c$d$e$f$g$h$
`"e"d"
CHClassifiableDrawing
CHLanguageUtilities
CHStrokeGroupQuery
CHStrokeGroupQueryItem
CHStrokeGroupingStrategy
SubclassesToOverride
CHEncodedStrokeIdentifier
NSCopying
NSSecureCoding
NSCoding
CHTokenizedTextResultToken
NSMutableCopying
Private
CHMutableTokenizedTextResultToken
CHTokenizedStrokeResult
CHRecognizerOptions
CHRecognizer
CHRecognizing
NSObject
Insight
CHDrawingContext
CHStrokeUtilities
CHRecognitionInsightRequest
CHRecognitionInsight
Internal
CHDrawing
CHCutPoint
CHSegmentDescriptor
CHDrawingSegmentGroup
CHStrokeGroupBaselineVisualization
CHTextInputScriptSpec
CHTextInputTargetContentInfo
CHMutableTextInputTargetContentInfo
CHNonTextCandidateStroke
CHMutableNonTextCandidateStroke
CHCornerDetector
CHMergedStrokeGroupingResults
CHStrokeGroupingManager
CHTextInputProtoSettings
CHNormalizedDrawingVisualization
CHNormalizedDrawingAllVisualization
CHRecognitionSessionResult
CHStrokeClassificationResult
CHStrokeGroupingResult
CHStrokeGroupRecognitionResult
CHStrokeGroupTextCorrectionResult
CHRemoteRecognitionRequest
CHTokenizedTextResultColumn
CHMutableTokenizedTextResultColumn
CHStrokeGroup
CHRecognitionSessionTextInputTask
CHTextInputTarget
CHTextLineStrokeGroup
CHTitleQuery
CHRecognitionResult
CHTextRecognitionResult
CHSketchRecognitionResult
CHLineSketchRecognitionResult
CHManhattanLineSketchRecognitionResult
CHOutlinedArrowSketchRecognitionResult
CHRectangleSketchRecognitionResult
CHTriangleRecognitionResult
CHEllipseRecognitionResult
CHChatBubbleRecognitionResult
CHStarRecognitionResult
CHPentagonRecognitionResult
CHScribbleRecognitionResult
CHHeartRecognitionResult
CHCloudRecognitionResult
CHFreeformRecognitionResult
CHSubstrokeBoundsVisualization
CHStrokeGroupingVisualization
CHSearchQuery
CHSearchQueryItem
CHVisualization
CHPointFIFO
CHPointStrokeFIFO
CHBoxcarFilterPointFIFO
CHQuadCurvePointFIFO
CHStrokePointsVisualization
CHTextInputGesture
CHTextInputInsertionCaretGesture
CHCTCRecognitionModel
CHTokenizedTextResult
CHMutableTokenizedTextResult
CHSpellCheckerErrorModel
CHSpellChecker
CHStrokeClutterFilter
CHRecurrentNeuralNetwork
CHRecurrentNeuralNetworkMontreal
CHRecurrentNeuralNetworkCoreML
CHStrokeTransitionModel
CHCutpointModel
CHStrokeClassificationModel
CHTopDownStrokeSplit
CHOrderedStrokeGroup
CHTopDownStrokeGroupingStrategy
CHTimeWindowStrokeGroup
CHTimeWindowStrokeGroupingStrategy
CHRecognitionSessionTask
CHTextInputQuery
CHTextInputQueryItem
CHDataDetectorQuery
CHDataDetectorQueryItem
CHSubstroke
CHSubstrokePlacement
CHStrokeGroupClassificationVisualization
CHPolygon
CHStrokeGroupBasedVisualization
CHRemoteRequestProtocol
CHRemoteRecognizer
CHVisualizationManager
CHStrokeGroupBasedVisualizationDelegate
CHVisualizationDelegate
CHRecognitionSessionObserver
CHTranscriptionQuery
CHQuery
RecognitionSessionObserver
ForSubclasses
CHContextualTextResult
CHContextualTextResults
CHTextCorrectionResult
CHRecognizerConfiguration
CHStrokeVisualization
CHGroupBoundsVisualization
CHRecognitionSessionVersion
CHRecognitionSession
CHRecognitionSessionTextInputTaskDelegate
CHRecognitionSessionTaskDelegate
CHTextCorrectionRecognizer
CHCharacterSetRules
CHBottomUpStrokeGroupingResult
CHBottomUpStrokeGroupingStrategy
MutableCopying
CHMutableStrokeClassificationResult
CHStrokeClassifier
CHFastStrokeGroupingStrategy
CHStrokeGroupBaselineLegacyVisualization
CHIndexableContentQuery
CHRecognitionSessionIndexableContent
CHStrokeFastGroupingResult
NetworkCursor
CHPatternNetwork
CHResultWithContext
CHPostProcessingManager
CHPostprocessingStep
CHTextFieldTypeSwitchStep
CHLexiconCorrectionStep
CHTransliterateHalfWidthPunctuationStep
CHSemanticTokenizerStep
CHIdentifyLowAlignmentConfidenceColumnsStep
CHDropSpaceBeforePunctuationMarksStep
CHCandidateRefinementStep
CHRemoveSpacesFromStrongURLsAndEmailsStep
CHRemoveSpacesFromSpecialFieldsStep
CHTransliterateChineseStep
CHReorderSCTCConfusionStep
CHMultiWordOVSFilteringStep
CHNumberFieldResultReorderingStep
CHMergeColumnsNoWhiteSpaceStep
CoreHandwriting
CHExtensions
init
dealloc
initWithDrawing:characterSet:expandCodePoints:normalizationContext:firstPointIsSubstrokeCut:lastPointIsSubstrokeCut:maxCandidateCount:
drawing
characterSet
expandCodePoints
normalizationContext
firstPointIsSubstrokeCut
lastPointIsSubstrokeCut
maxCandidateCount
_expandCodePoints
_firstPointIsSubstrokeCut
_lastPointIsSubstrokeCut
_drawing
_characterSet
_maxCandidateCount
_normalizationContext
lowercaseString
array
length
substringWithRange:
whitespaceCharacterSet
stringByTrimmingCharactersInSet:
rangeOfString:
numberWithUnsignedInteger:
addObject:
valueWithRange:
normalizeLMTokenIDForWord:tokenID:isFromPattern:score:languageModel:
arrayWithArray:
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
characterSetWithCharactersInString:
componentsSeparatedByCharactersInSet:
countByEnumeratingWithState:objects:count:
properties
string
stringByAppendingFormat:
integerValue
objectForKeyedSubscript:
getCharacters:
stringWithCharacters:length:
tokensRangesForString:outTokenIDs:languageModel:
splitStringIntoSubtokensForLexicon:minLength:
findPartialMatchInPhraseLexicon:token:contextBeforeToken:
transliterateStringUsingICUTransliterator:_icuTransliterator:
dictionaryWithObjectsAndKeys:
bounds
pointCountForStrokeIndex:
pointForStrokeIndex:pointIndex:
q_updateQueryResult
q_sessionResult
debugName
strokeProviderVersion
q_strokeGroupItemsFromSessionResult:
recognitionSession
count
_setStrokeGroupItems:
strokeGroupingResult
locales
strokeGroups
arrayWithCapacity:
strokeGroupsSortedByWritingOrientation
uniqueIdentifier
numberWithInteger:
recognitionResultForStrokeGroupIdentifier:
inputStrokeIdentifiers
recognitionResultsByLocale
errorsByLocale
ancestorIdentifier
localesSortedByLanguageFitness:
firstObject
q_itemTypeForStrokeGroup:recognitionResult:
latestStrokeProvider
strokeIdentifiersForData:withStrokeProvider:
initWithStrokeGroupIdentifier:stableIdentifier:strokeIdentifiers:type:preferredLocale:tokenizedTextResultsByLocale:errorsByLocale:
classification
transcriptionPaths
transcriptionWithPath:columnRange:filterLowConfidence:excludeGibberish:rejectionRate:tokenProcessingBlock:
tokenizedStrokeResultForInitialStrokes:point:tokenizationLevel:completion:shouldCancel:
encodedStrokeIdentifiers:withStrokeProvider:
tokenStrokeIdentifiersForContextStrokes:point:tokenizationLevel:completion:shouldCancel:
processingQueue
copy
dictionaryWithCapacity:
strokeGroupIdentifier
setObject:forKeyedSubscript:
q_queryResultDidChange
stringWithFormat:
tokenizedStrokeResultForInitialStrokes:point:tokenizationLevel:
strokeGroupItems
strokeGroupItemsByID
_setStrokeGroupItemsByID:
_strokeGroupItems
_strokeGroupItemsByID
_tokenizedTextResultsByLocale
_errorsByLocale
descriptionForStrokeGroupQueryItemType:
description
textRecognitionResultForLocale:error:
strokeGroupStableIdentifier
strokeIdentifiers
strokeGroupType
preferredLocale
_strokeGroupIdentifier
_strokeGroupStableIdentifier
_strokeIdentifiers
_strokeGroupType
_preferredLocale
__tokenizedTextResultsByLocale
__errorsByLocale
strokeProvider
strokeIdentifierFromData:
strokeForIdentifier:
firstStrokeIdentifier
lastStrokeIdentifier
mutableCopy
minusSet:
containsObject:
compareOrderOfStrokeWithIdentifier:toStrokeWithIdentifier:
setWithCapacity:
firstStrokeOrigin
encodedStrokeIdentifier
getFirstStrokeIdentifier:lastStrokeIdentifier:inGroup:addingStrokeIdentifiers:removingStrokeIdentifiers:
groupingConfidence
groupByAddingStrokeIdentifiers:removingStrokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:classification:groupingConfidence:firstStrokeOrigin:
initWithStrokeProvider:
strategyIdentifier
strokesForIdentifiers:
strokeGroupFromGroup:addingStrokes:
_strokeProvider
initWithStrokeGroups:createdStrokeGroups:deletedStrokeGroups:
updatedGroupingResult:byAddingStrokes:removingStrokeIdentifiers:stableStrokeIdentifiers:allSubstrokesByStrokeIdentifier:withCancellationBlock:
recognizableDrawingForStrokeGroup:translationVector:originalDrawing:orderedStrokesIDs:rescalingFactor:
addPoint:
subdataWithRange:
hash
isEqualToCHEncodedStrokeIdentifier:
isEqual:
encodeObject:forKey:
decodeObjectOfClass:forKey:
initWithData:
supportsSecureCoding
copyWithZone:
encodeWithCoder:
initWithCoder:
_savedHash
_encodedStrokeIdentifier
indexSet
initWithString:strokeIndexes:wordID:recognitionScore:combinedScore:alignmentScore:properties:substrokeCount:
characterSetWithRange:
rangeOfCharacterFromSet:
decodeInt32ForKey:
decodeDoubleForKey:
decodeIntegerForKey:
encodeInt32:forKey:
encodeDouble:forKey:
encodeInteger:forKey:
wordID
isEqualToString:
strokeIndexes
isEqualToIndexSet:
substrokeCount
recognitionScore
combinedScore
alignmentScore
isEqualToTokenizedTextResultToken:
tokenWithString:strokeIndexes:wordID:recognitionScore:combinedScore:alignmentScore:properties:substrokeCount:
mutableCopyWithZone:
isEquivalentToToken:
_string
_strokeIndexes
_wordID
_recognitionScore
_combinedScore
_alignmentScore
_properties
_substrokeCount
setString:
setStrokeIndexes:
setWordID:
setRecognitionScore:
setCombinedScore:
setAlignmentScore:
setProperties:
setSubstrokeCount:
initWithStrokeIdentifiers:resultLevel:
resultLevel
_resultLevel
stringWithCString:encoding:
initWithComputeUnits:
fileURLWithPath:
modelWithContentsOfURL:configuration:error:
lastPathComponent
stringByDeletingPathExtension
stringByDeletingLastPathComponent
stringByAppendingString:
stringByAppendingPathComponent:
cStringUsingEncoding:
modelDescription
inputDescriptionsByName
multiArrayConstraint
shape
objectAtIndex:
unsignedIntValue
outputDescriptionsByName
dataType
numberWithUnsignedInt:
arrayWithObjects:count:
initWithShape:dataType:error:
dataPointer
objectAtIndexedSubscript:
bitmapRepresentationForSize:
initWithDictionary:error:
stringWithUTF8String:
handleFailureInFunction:file:lineNumber:description:
characterIsMember:
initWithUsesCPUOnly:
predictionFromFeatures:options:error:
localizedDescription
featureValueForName:
multiArrayValue
setMaxComputationBatchSize:
strides
enumerateSubstringsInRange:options:usingBlock:
enableCachingIfAvailable
setEnableCachingIfAvailable:
enableGen2ModelIfAvailable
setEnableGen2ModelIfAvailable:
enableGen2CharacterLMIfAvailable
setEnableGen2CharacterLMIfAvailable:
_enableCachingIfAvailable
_enableGen2ModelIfAvailable
_enableGen2CharacterLMIfAvailable
defaultLocaleForRecognitionType:withMode:
initWithMode:locale:learningDictionaryURL:recognizerOptions:
validateRecognitionMode:
isLocaleSupported:withMode:
stringForRecognitionMode:
localeIdentifier
initWithMode:locale:contentType:autoCapitalizationMode:enableCachingIfAvailable:enableGen2ModelIfAvailable:enableGen2CharacterLMIfAvailable:
defaultMinimumDrawingSize
_reloadEngineAndResources
initWithType:mode:locale:learningDictionaryURL:
numberWithDouble:
_defaultPunctuationStringsOutputScores:maxCandidateCount:
numberWithInt:
indexSetWithIndexesInRange:
doubleValue
numberWithBool:
initWithString:score:wordRanges:wordIDs:wordRecognitionScores:wordCombinedScores:wordStrokeSets:wordLexicalEntries:wordPatternEntries:rareWordIndexes:inappropriateWordIndexes:isTextReplacement:
indexPathWithIndex:
initWithTokenRows:
initWithTokenColumns:transcriptionPaths:scores:recognizerGenerationIdentifier:
characterAtIndex:
appendString:
_isInappropriateString:
requiredInappropriateFilteringFlags
caseInsensitiveCompare:
_isInappropriateLexiconEntry:
obfuscateString:
_isInappropriateString:withLexicon:
_isInappropriateString:withTrie:
_transliterationVariantsForString:
rangeOfComposedCharacterSequenceAtIndex:
shouldGenerateDigitLetterAlternatives
_alternativeInterpretationsForString:
substringToIndex:
shouldEnforceGrammarOnTransliterations
contentType
rootCursorForContentType:inNetwork:forFirstSegmentGroup:
newCursorByAdvancingWithString:fromCursor:inNetwork:
newCursorByAdvancingWithSymbol:fromCursor:inNetwork:
stringWithString:
replaceOccurrencesOfString:withString:options:range:
mecabraInputMethodType
_unloadEngineAndResources
newRecognitionEngine
newFreeFormEngine
newLanguageModel
newSpellChecker
newStaticLexicon:
newPhraseLexicon:
newCJKStaticLexicon
newOVSTrie
newPatternFST
newPostProcessingFST
newGrammarFST
newRadicalClusterFST
newTransliterationVariantMap
whitelistMecabraRareCharacters
newCharacterLanguageModelAndMap:
newStrokeTransitionModel
newCutpointModel
newCTCRecognitionModel
_initializeTextDecoder
_initializePostProcessor
newPostProcessorWithStaticLexicon:customLexicon:phraseLexicon:customPhraseLexicon:recognizer:textReplacements:postProcessingFST:languageModel:
newCTCTextDecoderWithStaticLexicon:customLexicon:wordLanguageModel:
mode
_loadMecabraIfNeeded
dictionaryWithObjects:forKeys:count:
shouldForwardMecabraOTAAssetsUpdate
removeAllObjects
setObject:forKey:
logCandidateIfAppropriate:
locale
debugDescription
rangeValue
addIndex:
initWithType:mode:locale:
objectForKey:
addCharactersInRange:
sketchDescriptionForCode:
sketchCodeForDescription:
orientationRepresentationForSampling:convolutionWidth:
strokeCount
initWithString:score:rotation:center:size:
initWithString:score:rotation:vertex1:vertex2:vertex3:
initWithString:score:rotation:center:size:stemLocation:stemWidth:
cumulativePointToPointDistance
distanceBetweenFirstAndLastPoint
initWithScore:
initWithString:score:rotation:upperLeftPoint:upperRightPoint:lowerLeftPoint:lowerRightPoint:
initWithString:score:rotation:center:size:controlPointLocation:
initWithString:score:rotation:startLocation:startEndpointType:endLocation:endEndpointType:midPointLocation:controlPointLocation:
pointCount
valueWithPoint:
initWithString:score:rotation:startLocation:startEndpointType:endLocation:endEndpointType:midPointLocation:controlPointLocation:pathPoints:
_effectiveMaxRecognitionResultCount
insertObject:atIndex:
chatBubbleCandidateResultForDrawing:candidate:rejectionResult:
ellipseCandidateResultForDrawing:candidate:
rectangleCandidateResultForDrawing:candidate:
triangleCandidateResultForDrawing:candidate:
starCandidateResultForDrawing:candidate:
lineCandidateResultForDrawing:candidate:rejectionResult:
heartCandidateResultForDrawing:candidate:
pentagonCandidateResultForDrawing:candidate:
outlineArrowCandidateResultForDrawing:candidate:
manhattanLineCandidateResultForDrawing:candidate:rejectionResult:
cloudCandidateResultForDrawing:candidate:rejectionResult:
score
setScore:
exchangeObjectAtIndex:withObjectAtIndex:
inappropriateWordIndexes
predicateWithBlock:
filterUsingPredicate:
substringFromIndex:
_initialContextRectFromRecognizerOptions:
shouldRefineChineseCharacterCandidates
_refineChineseCharacterCandidates:drawing:
shouldApplyLMRescoring
_rescoreCandidatesWithLanguageModel:history:
shouldTransliterateAndSynthetizeCandidates
_applyTransliterationAndSyntheticCandidates:
shouldPromoteChineseCommonCharacters
isRareChineseEntry:
segments
_resolvedStrokeIndexes:segmentGroup:segmentOffset:substrokeCount:
shouldTransformCharacterProbabilitiesIntoLogScores
mecabraRareWordIndexes:wordRanges:
indexSetWithIndex:
_textReplacementResultForLegacyRecognitionResult:
_removeOVSResults:withHistory:
wordStrokeSets
addIndexes:
tokenColumnCount
_calculateJointWordLMScoreForString:wordRanges:wordIDs:patternEntries:history:historyLength:
punctuationCharacterSet
decimalDigitCharacterSet
formUnionWithCharacterSet:
symbolCharacterSet
letterCharacterSet
invertedSet
boolValue
rangeOfCharacterFromSet:options:range:
setObject:atIndexedSubscript:
indexOfObject:
_tokensUsingLMTokenizerForString:wordRanges:nonWordPatterns:outTokenIDs:
unsignedIntegerValue
maximumLengthOfBytesUsingEncoding:
getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
initWithBytes:length:encoding:
whitespaceAndNewlineCharacterSet
rangeOfString:options:range:
shouldPerformGlobalBestSearch
shouldPerformGlobalBestSearchWithSmallLattice
shouldPerformIntegratedLexiconExpansion
shouldPenalizeLetterInsertion
shouldPerformMultiWordsExpansion
shouldApplyLexicalPenalty
shouldExpandNonSpaceSeparators
delayedSegments
segmentBounds
segmentID
shouldComputeStrokePenalties
shouldExpandCodePoints
shouldPenalizePrefixes
shouldApplyRomanPostProcessing
tokenizedTextResultForRomanLatticePaths:history:activeHistoryRange:isMultiWordsPath:isNoSpacePath:maximumPathCount:startNode:segmentGroup:precedingSpaceBehavior:totalStrokeCount:totalSubstrokeCount:
shouldApplyChinesePostProcessing
tokenizedTextResultForChineseLatticePaths:maximumPathCount:network:mecabraIDs:startNode:endNode:segmentGroup:
indexOfObjectPassingTest:
shouldAutoCapitalize
arrayWithObjects:
orthographyWithDominantScript:languageMap:
enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:
componentsJoinedByString:
expectedMinStrokeCount:
compare:options:
tokenizedTextResultForRomanNoSpaceLatticePaths:maximumResultCount:activeHistoryRange:precedingSpaceBehavior:totalStrokeCount:totalSubstrokeCount:
tokenizedTextResultForRomanMultiWordsLatticePaths:maximumResultCount:history:activeHistoryRange:startNode:segmentGroup:precedingSpaceBehavior:
tokenizedTextResultForRomanSingleWordLatticePaths:history:activeHistoryRange:startNode:segmentGroup:
tokenRows
shouldUseTokenPrecedingSpaces
addTokenRowWithTokens:
adjustColumns
arrayWithObject:
segmentGroupIndex
_encodeTempDelayedSegmentID:
_lexiconCorrectionsForToken:withLexicon:textReplacements:consumableStrokesSet:minimumTokenScore:activeHistoryRange:outBestTokenScore:shouldCapitalizeWord:shouldSkipEntryCorrection:allowFullCapsCorrections:minimalLengthForLowConfidenceCorrections:lowConfidenceThreshold:minimalLengthForCustomCapitalizationCorrections:outBestTokenIndex:outFoundTokenInLexicon:outFoundCaseMatchingTokenInLexicon:outCorrectionFromOutOfContextEntry:
arrayByAddingObjectsFromArray:
arrayByAddingObject:
sortTokenRows
shouldTransliterateSentences
_applySentenceTransliterationCandidates:codesLen:codesMax:
stringByReplacingOccurrencesOfString:withString:
rareWordIndexes
removeObjectAtIndex:
wordCombinedScores
floatValue
_tokenizedTextResultFromResults:segmentGroup:offsetSegment:decodedStrokeSets:spaceBehavior:
uppercaseStringWithLocale:
_computeEditPenalizationFromString:toReferenceString:withSuffix:withCaseSensitivity:withFirstLetterCaseSensitivity:withDiacriticSensitivity:withDiacriticsCharSet:withConsumableStrokesCharSet:outputSuffix:lexiconExtraCharacters:firstLetterCaseFlipped:
hasPrefix:
compare:
rangeOfString:options:
stringByReplacingCharactersInRange:withString:
alphanumericCharacterSet
correctionsForString:shouldUseErrorModel:forLocale:
transcriptionPathScores
tokenColumns
indexAtPosition:
tokensInTranscriptionPath:atColumnIndex:
_spellCheckerCorrectionsForToken:
replaceObjectAtIndex:withObject:
recognizerGenerationIdentifier
_shouldCapitalizeGivenHistory:
characterType:
_updateResults:string:score:recognitionScore:lexicalEntry:patternEntry:isInappropriateWord:wordID:wordStrokeSet:
shouldApplyDiacriticSensitivity
sortUsingComparator:
_filterNonHumanFriendlyCandidates:
_adjustResultsForConfusableCharacters:
wordLexicalEntries
lastObject
wordPatternEntries
shouldUseCaching
setCachedDrawing:
supportedSegmentationStrategy
strokeIndicesSortedByMinXCoordinate
shouldPerformRegularSpaceRecognition
shouldPerformNoSpaceRecognition
_historyStringFromRecognizerOptions:
precomposedStringWithCanonicalMapping
_precedingSpaceBehaviorFromRecognizerOptions:
sortedDrawingUsingMinXCoordinate
shouldFallbackOnSingleCharacterExpansion
recognitionResultsForSingleCharacterDrawing:segmentGroup:options:history:
appendTokenColumns:
matchingStrokePrefixRangeForDrawing:
_cachingWithMatchingStrokeRange:drawing:
_sortedIndexesForSegmentGroup:drawing:
_candidateNetworkFromSegmentationNetwork:segmentGroup:drawing:boundsAtNode:matchingStrokeRange:sortedSegmentIndexes:shouldCancel:
shouldComposeLexiconWithNetwork
_textResultWithNetworkComposeFromCandidateNetwork:segmentGroup:drawing:maxRecognitionResultCount:history:totalStrokeCount:totalSubstrokeCount:
setTranscriptionPaths:scores:
shouldExpandLexiconInNetwork
_textResultWithLexiconExpansionFromCandidateNetwork:history:prefix:activeHistoryRange:rootStaticCursor:rootCustomCursor:rootPatternCursor:segmentGroup:maxRecognitionResultCount:precedingSpaceBehavior:shouldPerformNoSpaceRecognition:inLatticePaths:outLatticePaths:totalStrokeCount:totalSubstrokeCount:shouldCancel:
contentTypeForNoSpaceRecognition
_calculateBestTranscriptionPaths:scores:fromTokenizedResult:pathCount:history:skipLMRescoring:
shouldKeepDuplicateTokenIDs
trimTokensToTranscriptionPathCount:
shouldKeepOutOfPatternCandidates
filterCandidatesWithOutOfPattern:duplicateTokenIDs:shouldKeepOriginalSpelling:
_addAlternativeCandidatesForTokenizedResult:
enumerateTokensInTranscriptionPath:columnRange:tokenProcessingBlock:
topTranscription
UTF8String
_contextTokenIDsFromHistory:maxCharacterLength:maxTokenCount:
refineAlternativeTokens:historyTokenIDs:languageModel:
_createNetworkTruncatedPrefixStringUsingPrefix:fullHistoryStringLength:hasLexiconCursor:prefixStringLength:hasComplexChars:activeHistoryRange:
_mininmumPathCount
bestPathsFromNetwork:pathCount:staticLexiconCursor:customLexiconCursor:patternCursor:history:activeHistoryRange:mecabraIDs:segmentGroup:precedingSpaceBehavior:effectiveContentType:shouldAllowSpaceInsertion:inLatticePaths:outLatticePaths:totalStrokeCount:totalSubstrokeCount:
classifiableDrawing
edgeIndex
strokeGroup
_adjustCandidatesForConfusableCharacters:
shouldDetectChinesePunctuation
_adjustCandidatesForChinesePunctuation:segmentDrawing:completeDrawing:
shouldDetectRomanPunctuation
_adjustCandidatesForRomanPunctuation:segmentDrawing:
numberOfSegments
delayedSegmentIDs
numberOfSubstrokes
_addEdgesFromCandidates:toEdges:referenceEdge:network:consumedSegmentCount:delayedSegmentIDs:numSubstrokes:
engineCandidateCount
shouldApplyCandidatesThresholding
_candidateLatticePruningThresholdForEdgeType:
appendSegment:fromDrawing:
relatedSegmentIDs
intValue
_computeLocalFrameWithLeftBounds:rightBounds:delayedStrokeDrawingsLocalBounds:delayedStrokeDrawings:
reverseObjectEnumerator
initWithEdgeIndex:numberOfSubstrokes:numberOfSegments:classifiableDrawing:strokeGroup:delayedSegmentIDs:
_classifyEdgeDrawingsFromContexts:allEdges:segmentationNetwork:candidateNetwork:cachedEdgeSet:completeDrawing:allowSmallerFinalBatch:shouldCancel:
removeObjectsInRange:
shouldRelaxFinalCandidatesThresholding
_stringForCode:
engine
shouldApplyLMSorting
wordRanges
wordIDs
wordRecognitionScores
containsIndex:
isTextReplacement
indexPathByAddingIndex:
_calculateJointWordLMScoreForTokenPath:tokenizedResult:history:historyLength:pathTranscription:
_lmRescoringWeightForPath:
subarrayWithRange:
_decodeTempDelayedSegmentID:
indexForSegmentID:fromSegments:
strokeIndexSet
enumerateIndexesUsingBlock:
totalSegmentCount
_tokenFromLegacyResult:wordIndex:strokeSet:substrokeCount:
setTokenColumns:
newlineCharacterSet
languageResourceBundle
characterLanguageModel
languageModel
_drawingAnchorPointFromRecognizerOptions:
recognitionModel
recognizeDrawing:minimumDrawingSize:initialVectorAnchorPoint:activeCharacterSet:outStrokeEndings:
setActivationMatrix:
initWithHistory:activeRange:
decodingCommitActionBlock
defaultPathScoringFunctionForLanguageResourceBundle:
initWithCommitActionBehavior:scoringFunction:beamWidth:pathCount:shouldOptimizeAlignment:
decodingResultWithConfiguration:withContext:
_tokenizedTextResultFromTextDecodingResult:options:strokeEndings:drawing:
ch_sentenceEndPunctuationCharacterSet
shouldApplyLatinSpacingForLocale:
modelName
_textAfterFromRecognizerOptions:
candidates
fullString
setSavedTop1CandidateString:
tokens
shouldHavePrecedingSpace:history:
savedTop1CandidateString
_updatePrecedingAndTrailingSeparatorsForTopCandidate:history:textAfter:locale:outTrailingSeparator:inFirstTokenHasPrecedingSpace:outFirstTokenHasPrecedingSpace:
rootCursorForPatternType:inNetwork:forFirstSegmentGroup:
activationRange
lastIndex
terminatingCharacter
extendedToken:withStrokeIndexSet:alignmentScore:
longCharacterIsMember:
removeAllIndexes
_tokenIDForString:withLexicon:outIsInappropriate:
isCompletePattern
initWithBestPathTokens:pathProbabilities:trailingSeparator:recognizerGenerationIdentifier:
initWithTokenColumns:transcriptionPaths:scores:trailingSeparator:recognizerGenerationIdentifier:
strokeTransitionModel
classifyStrokesInDrawing:minimumDrawingSize:outDelayedStrokeProbabilities:outSpaceProbabilities:outCharBoundaryProbabilities:
detectedDelayedStrokes:
recordSpaceProbabilities:
recordCharBoundaryProbabilities:
recordDelayedStrokeProbabilities:
cutpointModel
detectCutpointsInDrawing:minimumDrawingSize:excludingStrokeIDs:
_correctedDelayedStrokeIDs:inDrawing:segmentationPoints:correctedSegmentationPoints:
generateSegmentsFromDrawing:withSegmentationPoints:buildingContextBoundsWithRadius:spaceProbabilities:charBoundaryProbabilities:extractDelayedStrokeIDs:extractedDelayedSegments:
_segmentWordRangesForSegments:
generateSegmentsFromDrawing:
segmentGroupsFromSegments:delayedSegments:segmentGroupRanges:
_recognitionResultsForMultipleCharacterDrawing:segmentGroups:options:shouldCancel:
addIndexesInRange:
shouldRunNextGenRecognizer
_resultUsingNextGenerationPipelineWithDrawing:options:
initWithResult:leftContext:contentType:
process:
result
_resultUsingSegmentAndDecodePipelineWithDrawing:insight:options:shouldCancel:
setSavedDrawing:
strokeIndex
pointIndex
isEndOfStroke
strokeBoundsAtIndex:
trailingSpaceProbability
indexPathWithIndexes:length:
_setupRecognitionInsightRecording
setSaveDrawingUntilNextCandidateAccepted:
_shouldReturnDefaultResultsForDrawing:
_defaultPunctuationResultWithStrokeCount:
_tokenizedTextRecognitionResultForDrawing:options:shouldCancel:
recordConfigurationForRecognizer:options:
recordTextResult:recognitionError:
_defaultLegacyPunctuationResultsWithStrokeCount:
recognitionResultsForSketchDrawing:options:
_legacyTextRecognitionResultsForDrawing:options:shouldCancel:
legacyTextRecognitionResults
recognitionResultsForDrawing:options:shouldCancel:
indexesOfStrokesSmallerThanSize:
_refineCandidates:withAllowedCandidateCodes:
expectedMaxDotCount:
shouldTreatAllSmallStrokesAsPunctuation
_penalizeCandidatesForRomanPunctuation:punctuationStrokeCount:
removeIndexes:
convexHullForStrokes:inDrawing:
enlargedConvexHull:withMargin:
threePointsOrientationWithOrigin:pointA:pointB:
distanceFromPoint:toRectangle:
distanceFromPoint:toSegmentFromPoint:toPoint:
lowercaseLetterCharacterSet
uppercaseLetterCharacterSet
shouldApplyCharacterLMRescoring
shouldReplaceInvalidTokenIDs
_tokenIDForUNKCharacterString:
precedingSpaceDefaultBehavior
getValue:
maxRecognitionResultDefaultCount
autoCapitalizationMode
_setConfiguration:
isEqualToRecognizerConfiguration:
hasSameResourcesAsConfiguration:
hasSamePostProcessingAsConfiguration:
recordInsightRequest:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
superclass
initWithMode:locale:
recognitionMode
setContentType:
setAutoCapitalizationMode:
maxRecognitionResultCount
setMaxRecognitionResultCount:
activeCharacterSet
setActiveCharacterSet:
minimumDrawingSize
setMinimumDrawingSize:
initWithMode:locale:recognizerOptions:
initWithMode:locale:learningDictionaryURL:
initWithType:mode:learningDictionaryURL:
isOVSString:
transliterationVariantsForString:
_isLocaleSupported:
updateAddressBookLexicon:
updateUserDictionaryLexicon:
updateMecabraWithRegionalOTAAssets:nonRegionalOTAAssets:
setCustomLexicon:customVocabulary:
setCustomPhraseLexicon:
setTextReplacements:
candidatesCleared
candidateAccepted:
completionsForCandidate:prefix:option:
completionsForCandidate:candidateContext:prefix:option:
strokeIndexesForLastCharacter
initWithType:mode:
supportedCharacterSet
supportedStrings
characterSetForStrings:
endpointsForDrawing:startLocation:endLocation:
bestTranscriptionPathsForTokenizedResult:scores:history:
inGraphite
segmentationPointsForDrawing:
textRecognitionResultForDrawing:options:shouldCancel:
recognitionResultsForDrawing:options:
setRecognitionType:
setRecognitionMode:
setLocale:
recognitionType
setEngine:
freeformEngine
setFreeformEngine:
setStrokeTransitionModel:
setCutpointModel:
setRecognitionModel:
textDecoder
setTextDecoder:
recognitionQueue
setRecognitionQueue:
radicalClusterFST
setRadicalClusterFST:
formatGrammarFST
setFormatGrammarFST:
patternFST
setPatternFST:
postProcessingFST
setPostProcessingFST:
configuration
setLanguageModel:
lmVocabulary
setLmVocabulary:
setCharacterLanguageModel:
mecabra
setMecabra:
cjkStaticLexicon
setCjkStaticLexicon:
cjkDynamicLexicon
setCjkDynamicLexicon:
staticLexicon
setStaticLexicon:
phraseLexicon
setPhraseLexicon:
customLexicon
setCustomLexicon:
customPhraseLexicon
textReplacements
textReplacementLowercasedKeyMapping
setTextReplacementLowercasedKeyMapping:
spellChecker
setSpellChecker:
ovsTrie
setOvsTrie:
learningDictionaryURL
setLearningDictionaryURL:
savedDrawing
saveDrawingUntilNextCandidateAccepted
cachedDrawing
cachedResults
setCachedResults:
characterIDMap
setCharacterIDMap:
transliterationVariantMap
setTransliterationVariantMap:
icuTransliterator
setIcuTransliterator:
lastCharacterSegmentCount
setLastCharacterSegmentCount:
lastCharacterSegmentIndexes
setLastCharacterSegmentIndexes:
postProcessor
setPostProcessor:
.cxx_destruct
.cxx_construct
_nextRecognitionInsightRequest
_activeRecognitionInsight
_whitelistMecabraRareCharacters
_saveDrawingUntilNextCandidateAccepted
_recognitionType
_maxRecognitionResultCount
_activeCharacterSet
_engine
_freeformEngine
_strokeTransitionModel
_cutpointModel
_recognitionModel
_textDecoder
_recognitionQueue
_radicalClusterFST
_formatGrammarFST
_patternFST
_postProcessingFST
_configuration
_languageModel
_lmVocabulary
_characterLanguageModel
_mecabra
_cjkStaticLexicon
_cjkDynamicLexicon
_staticLexicon
_phraseLexicon
_customLexicon
_customPhraseLexicon
_textReplacements
_textReplacementLowercasedKeyMapping
_spellChecker
_ovsTrie
_learningDictionaryURL
_savedDrawing
_savedTop1CandidateString
_cachedDrawing
_transliterationVariantMap
_icuTransliterator
_lastCharacterSegmentCount
_lastCharacterSegmentIndexes
_postProcessor
_minimumDrawingSize
_cachedResults
_characterIDMap
recordInsightWithRequest:
recordedInsightFromLastRequest
trailingCharBoundaryProbability
startCutPoint
isStartOfStroke
endCutPoint
contextBounds
trailingSpaceRatio
_edgeIndex
_numberOfSubstrokes
_numberOfSegments
_classifiableDrawing
_strokeGroup
_delayedSegmentIDs
orderedStrokes
unionSet:
removeObject:
isPointEnumerationSupportedForStroke:
indexesOfObjectsPassingTest:
removeObjectsAtIndexes:
strokeIdentifier
enumeratePointsWithDistanceStep:usingBlock:
enumeratePointsWithTimestep:usingBlock:
enumeratePointsForStroke:interpolationType:resolution:usingBlock:
endTimestamp
startTimestamp
convexHullForPoints:
getAddedStrokes:removedStrokeIdentifiers:inStrokeProvider:lastGroupingResult:
strokeForIdentifier:inStrokeProvider:
durationOfStrokesInStrokeGroup:strokeProvider:
speedForFinalTimeRange:stroke:
arcLengthForStroke:
boundingBoxOfPoints:rotatedAroundPoint:byAngle:
unionStrokeBounds:usingStrokeCountLimit:reverseOrder:
unionStrokeBounds:aroundXPosition:usingOneSideStrokeCountLimit:
convexHullForStroke:
circumferenceRatioOfCircleFittedToPoints:circleCenter:circleRadius:
vectorMeanWithoutOutliers:
lineOrientationForStrokePoints:error:
regularizedPathFromPoints:delta:gamma:outError:
appendFormat:
insightRequest
recognizerActiveCharacterSet
recognizerLocale
recognizerRecognitionModeDescription
recognizerContentTypeDescription
autoCapitalizationModeDescription
recognizerMaxRecognitionResultCount
recognizerMinimumDrawingSize
recognizerOptions
enumerateKeysAndObjectsUsingBlock:
inputDrawing
inputDrawingCutPoints
ch_descriptionWithSeparator:filterBlock:
spaceProbabilities
delayedStrokeProbabilities
charBoundaryProbabilities
textResult
recognizerRecognitionMode
recognizerContentType
stringForRecognitionContentType:
stringForAutoCapitalizationMode:
setInsightRequest:
setRecognizerLocale:
setRecognizerRecognitionMode:
setRecognizerContentType:
setRecognizerActiveCharacterSet:
setRecognizerOptions:
setRecognizerMaxRecognitionResultCount:
setRecognizerMinimumDrawingSize:
setInputDrawing:
setInputDrawingCutPoints:
setSpaceProbabilities:
setCharBoundaryProbabilities:
setDelayedStrokeProbabilities:
setTextResult:
recognitionError
setRecognitionError:
_recognizerRecognitionMode
_recognizerContentType
_autoCapitalizationMode
_insightRequest
_recognizerLocale
_recognizerActiveCharacterSet
_recognizerOptions
_recognizerMaxRecognitionResultCount
_inputDrawing
_inputDrawingCutPoints
_spaceProbabilities
_charBoundaryProbabilities
_delayedStrokeProbabilities
_textResult
_recognitionError
_recognizerMinimumDrawingSize
recordInputDrawing:
recordInputDrawingCutPoints:
componentsSeparatedByString:
endStroke
setWithObjects:
decodeObjectOfClasses:forKey:
bytes
setDrawing:
dataWithBytes:length:
isEqualToDrawing:
drawingTransformedWithTranslation:scaleFactor:
initWithStrokeIndex:pointIndex:isEndOfStroke:
findLocalYMaximaWithWindowSize:excludingStrokes:
initialSegmentationPointIndicesForDrawing
filterPointsWithProximity:fixedPoints:points:
sortedCHCutPointArray:
allocWithZone:
initWithCGImage:
initWithContentsOfFile:
initWithContentsOfXYString:
drawingWithStrokesFromIndexSet:
centroidForStrokeIndexes:
clear
isPrefixForDrawing:
xyRepresentation
drawingScaledByFactor:
drawingSpatiallyResampled:outputPointMap:
setLineHeight:
findSignalCutPointsExcludingStrokes:
boundingBoxForDrawingSegmentFromCutPoint:toCutPoint:
averageCharacterHeightEstimation:minChunkHeight:
debugQuickLookObject
sortedArrayUsingComparator:
_isEndOfStroke
_strokeIndex
_pointIndex
isSinglePointSegment
initWithSegmentID:startCutPoint:endCutPoint:trailingSpaceProbability:trailingCharBoundaryProbability:referenceDrawing:
addObjectsFromArray:
resolvedCutPoint:withReferenceDrawing:
computeRelatedSegments:withDelayedSegments:
_computeLocalContextForSegments:withContextSizeRadius:
_resassignSpaceProbabilitiesFromDelayedSegments:toSegments:
_addRelatedSegmentID:
setContextBounds:
setTrailingSpaceRatio:
setTrailingSpaceProbability:
boundingBoxFromSegmentID:toSegmentID:withSegments:withSourceDrawing:
setTrailingCharBoundaryProbability:
_relatedSegmentIDs
_segmentID
_startCutPoint
_endCutPoint
_trailingSpaceRatio
_trailingSpaceProbability
_trailingCharBoundaryProbability
_segmentBounds
_contextBounds
orderedSet
initWithSegmentGroupIndex:segments:delayedSegments:
_segmentGroupIndex
_segments
_delayedSegments
drawVisualizationInRect:context:viewBounds:
resultDrawn
textStrokeGroupsSortedTopBottomLeftRight
dirtyRectForStrokeGroup:
newEstimatedBaselineForStrokesWithIdentifiers:estimatedDescenderLocations:
layeringPriority
isSkippableScriptCode:
singleScriptCodeForString:
shouldCorrectionGesturesSnapToTokensForScriptCode:
isCharacterFullWidth:
isRightToLeftScriptForCharacter:
shouldRelaxCharacterBoundsPercentageOverlapForScript:
_initWithTextInputTarget:contentLength:referenceSubstring:referenceSubstringRange:charRectsInReferenceSubstring:strokeCoveredTextRange:selectedTextRange:isCursorStrong:activePreviewRange:contentType:autoCapitalizationMode:isSingleLine:lastCharacterLevelPosition:protectedCharacterIndexes:
initWithTextInputTarget:contentLength:referenceSubstring:referenceSubstringRange:charRectsInReferenceSubstring:strokeCoveredTextRange:selectedTextRange:isCursorStrong:activePreviewRange:contentType:isSingleLine:lastCharacterLevelPosition:
referenceSubstringRange
characterRectsInReferenceSubstring
selectedTextRange
activePreviewRange
strokeCoveredTextRange
lastCharacterLevelPosition
textInputTarget
textContentLength
referenceSubstring
isCursorStrong
containsCommittedStrokes
protectedCharacterIndexes
setReferenceSubstring:range:characterRects:
setTextInputTarget:
setTextContentLength:
setStrokeCoveredTextRange:
setSelectedTextRange:
setIsCursorStrong:
setContainsCommittedStrokes:
setActivePreviewRange:
isSingleLine
setIsSingleLine:
supportsAutoLineBreaks
setSupportsAutoLineBreaks:
setLastCharacterLevelPosition:
setProtectedCharacterIndexes:
characterRectForCharacterIndex:
enumerateCharacterRectsInRange:reverse:block:
enumerateCharacterRectsInRange:block:
initWithTextInputTarget:contentLength:referenceSubstring:referenceSubstringRange:charRectsInReferenceSubstring:strokeCoveredTextRange:selectedTextRange:isCursorStrong:activePreviewRange:contentType:autoCapitalizationMode:isSingleLine:lastCharacterLevelPosition:
initWithTextInputTarget:contentLength:referenceSubstring:referenceSubstringRange:charRectsInReferenceSubstring:strokeCoveredTextRange:selectedTextRange:activePreviewRange:contentType:lastCharacterLevelPosition:
absoluteLocationFromRelativeLocation:
relativeLocationFromAbsoluteLocation:
visualCharacterRectForCharacterIndex:
referenceSubstringInRange:
referenceSubstringRangeOfComposedCharacterAtIndex:
unionCharacterRects
_textInputTarget
_textContentLength
_referenceSubstring
_referenceSubstringRange
_characterRectsInReferenceSubstring
_strokeCoveredTextRange
_selectedTextRange
_isCursorStrong
_containsCommittedStrokes
_activePreviewRange
_contentType
_isSingleLine
_supportsAutoLineBreaks
_lastCharacterLevelPosition
_protectedCharacterIndexes
convexHull
initWithStrokeIdentifier:substrokesCount:classificationAsNonText:lineOrientation:lineError:containerScore:bounds:boundsDiagonal:enlargedBounds:rotatedBounds:supportByStrokeIdentifier:support:
substrokesCount
classificationAsNonText
lineOrientationAngle
lineError
containerScore
valueWithBytes:objCType:
boundsDiagonal
supportByStrokeIdentifier
support
getValue:size:
setWithArray:
enlargedBounds
rotatedBounds
isEqualToNonTextCandidateStroke:
initWithStroke:consistingOfSubstrokes:classificationAsNonText:lineOrientation:lineError:containerScore:
effectiveClassification
_supportByStrokeIdentifier
_support
_strokeIdentifier
_classificationAsNonText
_substrokesCount
_lineError
_containerScore
_lineOrientationAngle
_boundsDiagonal
_bounds
_enlargedBounds
_rotatedBounds
_removeSupportForStrokeIdentifier:
numberWithFloat:
removeObjectForKey:
_adjustSupportForLineClassificationByAddingStroke:consistingOfSubstrokes:
_adjustSupportForContainerClassificationByAddingStroke:consistingOfSubstrokes:
_setSupportForStrokeIdentifier:support:
setSupportByStrokeIdentifier:
adjustSupportByRemovingStrokeIdentifier:
adjustSupportByAddingStroke:consistingOfSubstrokes:
_detectCorners
initWithIndexSet:
cornerIndexes
firstIndex
resampledDrawing
_distance:p1:p2:
minimumSignificantSegmentLength
_resolveResampledDirectionChangePointIndexes:
_resampleDrawing:outputPointMap:
_cornerIndexSet
dictionary
_strawSize
allValues
sortedArrayUsingSelector:
numberWithUnsignedLong:
_postProcessCorners:corners:straws:
_detectDirectionalChanges
_resamplingDistance:
shouldUseDynamicSampling
_isLine:usingThreshold:p1:p2:
_strokeHalfwayCorner:p1:p2:
_removeColinearCorners:usingThreshold:corners:
_removeColinearCorners:usingDistanceThreshold:usingLowerThreshold:usingUpperThreshold:corners:
_removeAdjacentCorners:corners:straws:
_pathDistance:p1:p2:
directionChangeCornerIndexes
setMinimumSignificantSegmentLength:
setShouldUseDynamicSampling:
directionChangeCount
highestDirectionChangeCount
_directionChangeCornerIndexes
_resampledDrawingPointMap
_shouldUseDynamicSampling
_minimumSignificantSegmentLength
_resampledDrawing
_directionChangeCount
_highestDirectionChangeCount
__strawSize
__cornerIndexSet
__directionChangeCornerIndexes
__resampledDrawingPointMap
initWithStrokeGroups:createdStrokeGroups:deletedStrokeGroups:groupingResultsByStrategyIdentifier:
groupingResultsByStrategyIdentifier
_groupingResultsByStrategyIdentifier
initWithStrokeProvider:locale:textInputTargets:
initWithStrokeProvider:defaultWritingOrientation:locales:isInlineContinuousMode:inlineContinuousModeTargets:
sessionLastResult
strokeClassificationResult
groupingStrategiesByIdentifier
allKeys
orderedStrokeIdentifiers
strokeClassificationsByStrokeIdentifier
_isGroupableNonTextForStrokeClassification:
enumerateObjectsUsingBlock:
addEntriesFromDictionary:
intersectsSet:
objectsPassingTest:
setWithObject:
initWithStrokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:classification:groupingConfidence:strategyIdentifier:firstStrokeOrigin:
initWithStrokeProvider:locales:clutterFilter:
groupingResultUsingStrokes:distanceMetric:mergingDistanceThreshold:shouldCancel:
_groupsFromClusterResult:strokes:strokeClassificationsByStrokeIdentifier:
allObjects
substrokesByStrokeIdentifier
_greedyCombinationOfGroupingResults:stableStrokeIdentifiers:withCancellationBlock:
textStrokeGroups
isEqualToSet:
setByAddingObjectsFromSet:
fastGroupingClusters
_simpleDrawingForStrokeGroup:originalDrawing:orderedStrokeIDs:
initWithStrokeProvider:sessionLastResult:locales:isInlineContinuousMode:inlineContinuousModeTargets:
updatedGroupingResultByAddingStrokes:removingStrokeIdentifiers:orderedStrokeIdentifiers:strokeClassificationResult:cancellationBlock:
isInlineContinuousMode
textInputTargets
_isInlineContinuousMode
_sessionLastResult
_locales
_textInputTargets
_groupingStrategiesByIdentifier
sharedSettings
recognitionLocaleIdentifier
autoLineBreakEnabled
autoLineBreakRequireWeakCursor
autoLineBreakMinVerticalDistance
autoLineBreakDualBreakVerticalDistance
autoLineBreakAreaWidthFactor
lineBreakVerticalBarGestureEnabled
lineBreakVerticalBarUpToDelete
subwordGestureEndingSpeedRange
subwordGestureSpeedThreshold
preventLeftoverCharsInSubwordGestures
_autoLineBreakEnabled
_autoLineBreakRequireWeakCursor
_lineBreakVerticalBarGestureEnabled
_lineBreakVerticalBarUpToDelete
_preventLeftoverCharsInSubwordGestures
_autoLineBreakMinVerticalDistance
_autoLineBreakDualBreakVerticalDistance
_autoLineBreakAreaWidthFactor
_subwordGestureEndingSpeedRange
_subwordGestureSpeedThreshold
shouldDrawStrokeGroup:
_transformForInputDrawingBounds:referenceBounds:viewBounds:
_drawGroupBrackgroundInRect:context:
drawInputDrawing:inContext:transform:
_drawCutPoints:inputDrawing:inContext:transform:
activeStrokeGroupAncestorIdentifiers
wantsInputDrawings
_recognitionResultsByGroupID
_textCorrectionResultsByGroupID
preferredLocales
languageCode
textStrokeGroupsSortedByWritingOrientation
highConfidenceTextForSessionResult:rejectionRate:doesContainUnfilteredMultiLocaleResults:
_resultsDebugDescriptionIntoGroupsArray:groupHeaderBlock:
textCorrectionResultForStrokeGroupIdentifier:
textCorrectionResult
error
transcriptionWithPath:columnRange:filterLowConfidence:
languageFitnessForLocale:
strokeIdentifierToGroupIndexMappingForStrokeIdentifiers:orderedStrokeGroups:
textStrokeGroupClusters
isEquivalentToStrokeGroup:
defaultWordTerminationCharacterForLocale:
initWithTextResult:terminatingSpecialCharacter:
encodedStrokeProviderVersion
sessionMode
recognitionEnvironment
getBytes:length:
initWithStrokeProviderVersion:encodedStrokeProviderVersion:orderedStrokeIdentifiers:sessionMode:locales:preferredLocales:clutterFilter:strokeClassificationResult:strokeGroupingResult:recognitionResults:inlineContinuousModeResults:generationDuration:recognitionEnvironment:
generationDuration
isEqualToSerializableRecognitionSessionResult:
clutterFilter
isEqualToRecognitionSessionResult:
initWithResult:validStrokes:
_transcriptionCapability
highConfidenceDebugDescription
allResultsDebugDescription
allResultsDebugDescriptionByGroup
allResultsDebugDescriptionWithGroupHeaderBlock:
fullyCoveredStrokeGroupsForContextStrokes:partiallyCoveredStrokeGroups:
contextualResultsWithFullyCoveredStrokeGroups:partiallyCoveredStrokeGroups:drawingCanvasSize:
hasCompleteRecognitionResults
__transcriptionCapability
_encodedStrokeProviderVersion
__shouldUseCachedHasCompleteRecognitionResults
__hasCompleteRecognitionResults
_strokeProviderVersion
_orderedStrokeIdentifiers
_sessionMode
_preferredLocales
_clutterFilter
_recognitionEnvironment
_strokeClassificationResult
_strokeGroupingResult
__recognitionResultsByGroupID
__textCorrectionResultsByGroupID
_generationDuration
textStrokeIdentifiers
keysOfEntriesPassingTest:
nontextCandidates
initWithStrokeClassificationsByStrokeIdentifier:substrokesByStrokeIdentifier:nontextCandidates:
isEqualToStrokeClassificationResult:
isEquivalentToStrokeClassificationResult:
_textStrokeIdentifiers
_strokeClassificationsByStrokeIdentifier
_substrokesByStrokeIdentifier
_nontextCandidates
createdStrokeGroups
deletedStrokeGroups
_sortedStrokeGroupsByWritingOrientationTextOnly:
averageWritingOrientation
strokeGroupsClusteredByProximity:
isEqualToStrokeGroupingResult:
strokeGroupClusters
_strokeGroupsSortedTopBottomLeftRight
_textStrokeGroupsSortedByWritingOrientation
_strokeGroupsSortedByWritingOrientation
_textStrokeGroupClusters
_strokeGroupClusters
_textStrokeGroups
_strokeGroups
_createdStrokeGroups
_deletedStrokeGroups
initWithResultsByLocale:errorsByLocale:languageFitnessByLocale:inputStrokeIdentifiers:inputDrawing:inputDrawingCutPoints:
languageFitnessByLocale
sortedLocales:usingLanguageFitness:
filteredResultsByLocale:usingLanguageFitness:
standardUserDefaults
boolForKey:
initWithResultsByLocale:errorsByLocale:languageFitnessByLocale:inputStrokeIdentifiers:
isEqualToStrokeGroupRecognitionResult:
_languageFitnessByLocale
_inputStrokeIdentifiers
_recognitionResultsByLocale
sortedArrayWithOptions:usingComparator:
initWithTextCorrectionResult:inputStrokeIdentifiers:
isEqualToStrokeGroupTextCorrectionResult:
_textCorrectionResult
setOptions:
setHasBeenSubmitted:
setPriority:
initWithLocale:recognitionMode:drawing:options:priority:
decodeFloatForKey:
decodeBoolForKey:
setShouldUseTextReplacements:
encodeFloat:forKey:
encodeBool:forKey:
configurationKey
shouldUseTextReplacements
options
isEqualToDictionary:
priority
isEqualToRemoteRecognitionRequest:
recognizerConfigurationKey
hasBeenSubmitted
_shouldUseTextReplacements
_hasBeenSubmitted
_recognitionMode
_locale
_options
_priority
isEqualToArray:
isEqualToTokenizedTextResultColumn:
indexOfEquivalentTokenRow:tokenRange:
containsStartingTokenEquivalentToToken:
_tokenRows
_mutableTokenRows
setTokenRows:
setTokenRowWithTokens:atIndex:
removeTokenRowAtIndex:
initWithAncestorIdentifier:strokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:classification:groupingConfidence:strategyIdentifier:firstStrokeOrigin:
_newStrokeGroupUniqueIdentifier
initWithUniqueIdentifier:ancestorIdentifier:strokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:classification:groupingConfidence:strategyIdentifier:firstStrokeOrigin:
isEqualToStrokeGroup:
_averageInterStrokeGroupDistanceForSortedStrokeGroups:outStdDev:
strokeGroupContainingStrokeIdentifier:strokeGroups:foundStrokeGroupIndex:
isStrokeGroupSet:equivalentToStrokeGroupSet:
strokeGroupContainingStrokeIdentifier:strokeGroups:
_uniqueIdentifier
_ancestorIdentifier
_firstStrokeIdentifier
_lastStrokeIdentifier
_classification
_groupingConfidence
_strategyIdentifier
_firstStrokeOrigin
initWithLocales:preferredLocales:strokeProvider:inputResult:recognitionQOSClass:recognitionEnvironment:
recognitionLocales
inputResult
activeTextInputQuery
textInputTargetsDataSource
_dataSource:inputTargetContentInfoForStrokeGroups:locale:groupingManager:
cancelled
inputTarget
inputTargetIdentifier
isEqualToNumber:
_textCorrectionResultForStrokeGroup:groupingManager:targetContentInfo:locale:previousCorrectionResult:
initWithStrokeProvider:strokeClassificationLastResult:textOnly:
initialTextInputTargets
_contextBoundsForTargetContentInfo:
lastStrokeInGroup:strokeProvider:
delegate
textCorrectionRecognizerForLocale:
textCorrectionResultForDrawing:targetContentInfo:originalDrawing:lastStroke:localTypedContextBounds:normalizedDrawingScaleFactor:previousCorrectionResult:
_dataSource:textInputTargetForStrokeGroup:simultaneousGroups:
fetchContentInfoForTextInputTarget:strokeIdentifiers:completion:
queryItemStableIdentifierForStrokeGroup:
textInputTargetForItemStableIdentifier:strokeIdentifiers:simultaneousItemStableIdentifiers:
textInputTargetForItemStableIdentifier:strokeIdentifiers:
defaultTextAffectedRangeForTargetContentInfo:
frame
initWithLocale:strokeProvider:initialTextInputTargets:inputResult:recognitionEnvironment:
initWithLocales:preferredLocales:strokeProvider:inputResult:recognitionQOSClass:
recognitionResultsForGroupingResult:groupingManager:
textCorrectionResultsForGroupingResult:groupingManager:
newStrokeClassifier
newGroupingManager
setActiveTextInputQuery:
_initialTextInputTargets
_activeTextInputQuery
initWithIdentifier:frame:
isEqualToInputTarget:
_inputTargetIdentifier
_frame
initWithAncestorIdentifier:strokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:strategyIdentifier:writingDirectionSortedSubstrokes:averageWritingOrientation:averageStrokeDeviation:writingDirectionSortedStrokeIdentifiers:localStrokeWritingOrientations:coalescedLastSubstrokes:groupingConfidence:firstStrokeOrigin:
writingDirectionSortedSubstrokes
substroke
filteredArrayUsingPredicate:
newEstimatedBaselineForSubStrokes:estimatedDescenderLocations:
orientedBounds
writingOrientation
orientationTransform
initWithFIFO:
initWithFIFO:width:spacing:
flush
path
localStrokeWritingOrientations
initWithUniqueIdentifier:ancestorIdentifier:strokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:strategyIdentifier:writingDirectionSortedSubstrokes:averageWritingOrientation:averageStrokeDeviation:writingDirectionSortedStrokeIdentifiers:localStrokeWritingOrientations:coalescedLastSubstrokes:groupingConfidence:firstStrokeOrigin:
initWithStrokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:strategyIdentifier:writingDirectionSortedSubstrokes:averageWritingOrientation:averageStrokeDeviation:writingDirectionSortedStrokeIdentifiers:localStrokeWritingOrientations:coalescedLastSubstrokes:groupingConfidence:firstStrokeOrigin:
groupByAddingStrokeIdentifiers:removingStrokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:writingDirectionSortedSubstrokes:averageWritingOrientation:averageStrokeDeviation:writingDirectionSortedStrokeIdentifiers:localStrokeWritingOrientations:coalescedLastSubstrokes:groupingConfidence:lastSubstrokeIndexBeforeMerge:firstStrokeOrigin:
localWritingOrientationAtStrokeIndex:
averageStrokeDeviation
lastSubstrokeIndexBeforeMerge
coalescedLastSubstrokes
writingDirectionSortedStrokeIdentifiers
_writingDirectionSortedSubstrokes
_averageWritingOrientation
_averageStrokeDeviation
_localStrokeWritingOrientations
_lastSubstrokeIndexBeforeMerge
_coalescedLastSubstrokes
_writingDirectionSortedStrokeIdentifiers
getIndexes:range:
stringByAppendingPathExtension:
scriptCode
capitalizedString
countryCode
uppercaseString
lengthOfBytesUsingEncoding:
replaceCharactersInRange:withString:
characterTypeFromString:
stringByApplyingTransform:reverse:
initWithRecognitionSession:
setPreferredUpdatesInterval:
_setTranscribedTitle:strokeIdentifiers:
transcribedTitle
titleStrokeIdentifiers
_transcribedTitle
_titleStrokeIdentifiers
_score
mecabraCandidate
_isTextReplacement
_wordRanges
_wordIDs
_wordRecognitionScores
_wordCombinedScores
_wordStrokeSets
_wordLexicalEntries
_wordPatternEntries
_rareWordIndexes
_inappropriateWordIndexes
initWithString:score:rotation:
rotation
_rotation
startEndpointType
endEndpointType
startLocation
endLocation
midpointLocation
controlPoint
pathPoints
cornerLine
_cornerLine
_startEndpointType
_endEndpointType
_pathPoints
_startLocation
_endLocation
_midpointLocation
_controlPoint
center
size
_center
_size
upperLeftPoint
upperRightPoint
lowerLeftPoint
lowerRightPoint
_upperLeftPoint
_upperRightPoint
_lowerLeftPoint
_lowerRightPoint
vertex1
vertex2
vertex3
_vertex1
_vertex2
_vertex3
stemLocation
stemWidth
_stemWidth
_stemLocation
_newColorForStroke:inGroup:
visualizationIndexForStrokeGroup:
newColorForVisualizedItemAtIndex:
pause
q_foundItemsForSearchString:sessionResult:
_setFoundItems:
_enumerateMatchesForStrokeGroupResult:locales:queryString:usingBlock:
objectsAtIndexes:
initWithStrokeIdentifiers:
tokenRowsAtColumnIndex:
_findMatchingTokenPathInResult:initialTokenLocation:queryString:fromIndex:coveredStrokeIndexes:reverseMatchedTokens:
tokenAtLocation:
intersectsIndexesInRange:
enumerateRangesUsingBlock:
_isMatchSeparatorBeforeToken:atLocation:inResult:queryString:fromIndex:matchedLength:
_isMatchStringForToken:queryString:fromIndex:requirePrefixMatch:matchedLength:
precedingSeparatorForToken:
q_setNeedsQueryResultUpdating
stop
setQueryString:
queryString
foundItems
_foundItems
_queryString
isEqualToSearchQueryItem:
setDelegate:
_recognitionSession
_delegate
recognitionSessionDidUpdateRecognitionResult
toggleVisualizationRegionAtPoint:
nextFIFO
emitPoint:
setNextFIFO:
_nextFIFO
strokes
setStrokes:
_strokes
emitAveragedPoint
initWithFIFO:width:
width
setWidth:
spacing
setSpacing:
prevPoints
setPrevPoints:
_spacing
_width
_prevPoints
setUnitScale:
drawingTarget
lineWidth
setNeedsDisplayInRect:
interpolateFromPoint:toPoint:controlPoint:time:
initWithFIFO:drawingTarget:
setUnitScaleForViewSize:normalizedSize:contentScaleFactor:
unitScale
emitInterpolatedPoints
setEmitInterpolatedPoints:
emissionHandler
setEmissionHandler:
setPath:
setLineWidth:
points
setPoints:
controlPoints
setControlPoints:
lastPoint
setLastPoint:
setDrawingTarget:
_emitInterpolatedPoints
_unitScale
_emissionHandler
_path
_lineWidth
_drawingTarget
_lastPoint
_points
_controlPoints
drawStrokesFromStrokeProvider:inRect:context:
targetContentInfo
gestureType
_affectedRangeByAdjustingForProtectedCharacters:
_affectedRangeByRemovingTerminatingNewLines:
_affectedRangeByTrimmingSpaces:
_affectedRangeByAdjustingToTokensIfNeeded:allowSubtoken:didExpand:
originalDrawing
_affectedRangeByRefiningShapeBasedGesture:resultType:drawing:targetContentInfo:
_isShapeBasedRangeRefinementSupportedForResultType:
initWithVertices:vertexCount:
initWithRect:
polygonByIntersectingWithClipPolygon:
area
edgeCountIntersectingLineSegment:
_shouldExpandToFullTokensForScriptInString:withRange:shouldExpandStart:shouldExpandEnd:
rangeOfTokenAtCharacterIndex:inString:locale:
lastStroke
preferCharacterLevel
isVerticalBarShapeFromLineResult:originalDrawing:isDirectionDownward:
_cursorPositionForPoint:referenceString:referenceCharRects:searchingRange:
controlCharacterSet
tokenizedTextResultWithString:strokeIndexes:trailingSeparator:recognizerGenerationIdentifier:
normalizedDrawing
initWithGestureType:targetContentInfo:locale:normalizedDrawing:originalDrawing:lastStroke:preferCharacterLevel:
set_textResult:
set_storedAffectedRange:
verticalBarGestureFromLineResult:currentGesture:
isEditGestureForDrawing:targetContentInfo:tentativeResultType:
shouldReclassifyGestureType:
isDrawingCenterOnBlank:targetContentInfo:insertionLocation:
getAffectedRange:expandedToFullTokens:
setGestureType:
_storedAffectedRange
_preferCharacterLevel
_gestureType
_targetContentInfo
_normalizedDrawing
_originalDrawing
_lastStroke
__textResult
__storedAffectedRange
initWithCaretTipPoint:targetContentInfo:locale:normalizedDrawing:originalDrawing:
caretDirection
caretTipPoint
_caretTipPoint
initWithModelName:featureIndex:
inputNames
outputNames
resourcePath
codeMap
normalizedDrawing:targetHeight:minimumDrawingSize:interpolationDistance:outScaleFactor:outputPointMap:
directionalFeaturesInputName
_extractFeaturesFromDrawing:inputName:interpointDistance:initialVectorAnchorPoint:error:
featureCounts
sequenceCompression
gapFeatureIndex
model
initWithDataPointer:shape:dataType:strides:deallocator:error:
initWithMultiArray:domainType:characterObservations:blankIndex:pruningPolicy:
initWithMultiArray:indexArray:domainType:characterObservations:blankIndex:pruningPolicy:
distanceFeatureIndex
sinAlphaFeatureIndex
cosAlphaFeatureIndex
_distMean
_distStd
initWithModelName:decodingPruningPolicy:
_extractFeaturesFromDrawing:inputName:interpointDistance:error:
characterProbabilityOutputName
blankIndex
spaceIndex
decodingPruningPolicy
_activationsDomain
_stringCodeMap
_interpointDistance
_hasBatchFirstFeatureArrayShape
__hasBatchFirstFeatureArrayShape
_sequenceCompression
_distanceFeatureIndex
_sinAlphaFeatureIndex
_cosAlphaFeatureIndex
_gapFeatureIndex
_directionalFeaturesInputName
_characterProbabilityOutputName
_codeMap
_blankIndex
_spaceIndex
__activationsDomain
__distMean
__distStd
__stringCodeMap
__interpointDistance
_decodingPruningPolicy
initWithTokenColumns:transcriptionPaths:scores:trailingSeparator:recognizerGenerationIdentifier:changeableColumnCount:
initWithBestPathTokens:pathProbabilities:trailingSeparator:recognizerGenerationIdentifier:changeableColumnCount:
indexesPassingTest:
mergeTokenRow:intoUniqueRows:
setPrecedingLineBreaks:
changeableTokenColumnCount
shouldFilterOutStringForToken:isGibberish:
stringByPaddingToLength:withString:startingAtIndex:
_isGibberishToken:
precedingLineBreaks
languageFitnessForTranscriptionPath:locale:recognitionMode:
_tokenCountInTranscriptionPath:columnRange:
localeWithLocaleIdentifier:
exemplarCharacterSet
_scoreMeanAndStdForToken:forLocale:
_characterCountInToken:filteringCharacterSet:filteredCharacterCount:
_normalizedLanguageFitness:
ch_occurrencesOfCharactersInSet:maxCount:
_legacyTextRecognitionResultForTranscriptionIndex:
isEqualToTokenizedTextResult:
areTokenRowsEquivalent:otherRow:
precedingSeparatorForTopTranscriptionPath
trailingSeparator
recognizerDebugDescription
strokeIndexesForColumnsInRange:
isValid
tokensFromTopTranscriptionWithCharacterRange:
tokenizedResultWithFilteredPaths:
languageFitnessForLocale:recognitionMode:
phraseCaseCorrectedResultWithHistory:phraseLexicon:maxPhraseLength:
_tokenColumns
_transcriptionPaths
_transcriptionPathScores
_recognizerGenerationIdentifier
_precedingLineBreaks
_changeableCount
_trailingSeparator
containsIndexes:
commonStrokeSetsFromSets:tokenRow:
_columnStrokeSetsFromTokenRows:
initWithIndexes:length:
containsString:
setChangeableTokenColumnCount:
getCharIndex:
replacementErrorScoreForIntendedCharacter:actualCharacter:
transpositionErrorScoreForIntendedFirstCharacter:intendedSecondCharacter:
sharedSpellServer
newErrorModel
spellServer:findMisspelledWordInString:language:wordCount:countOnly:correction:
rangeOfCharacterFromSet:options:
spellServer:suggestGuessesForWordRange:inString:language:options:
spellServer:suggestGuessDictionariesForWordRange:inString:language:options:errorModel:
isWordInUserDictionaries:caseSensitive:
topCorrectionForString:contextBeforeToken:contextSeparator:shouldUseErrorModel:forLanguage:
errorModel
setErrorModel:
_spellServer
_errorModel
initWithCanvasHeatmap:stroke2ItemMapping:item2StrokeMapping:
unsignedLongValue
clutterFilterByAddingStrokes:removingStrokeIdentifiers:affectedStrokeIdentifiers:
isHighDensityStroke:
highDensityStrokeCount
isEmpty
strokeIDsWithinRectangleRegion:
_heatMap
_CHStrokeID2HeatmapItemID
_heatmapItemID2CHStrokeID
initWithModelName:
_modelName
initWithObjectsAndKeys:
maxSequenceLength
windowOverlap
_recursivelyPredictProbabilitiesForDrawing:features:pointRange:modelInputName:modelOutputNames:probabilities:probabilityPredictionBlock:error:cancellationBlock:
classCounts
_model
_inputNames
_featureCounts
_outputNames
_classCounts
__model
_resourcePath
spaceProbabilityOutputName
charBoundaryProbabilityOutputName
delayedStrokeProbabilityOutputName
_spaceProbabilityOutputName
_charBoundaryProbabilityOutputName
_delayedStrokeProbabilityOutputName
cutpointProbabilityOutputName
_detectedCutpoints:resampledDrawing:
_remappedCutpoints:pointMap:originalDrawing:excludingStrokeIDs:
distanceLeftFeatureIndex
distanceRightFeatureIndex
sinAngleLeftFeatureIndex
cosAngleLeftFeatureIndex
sinAngleRightFeatureIndex
cosAngleRightFeatureIndex
endpointFeatureIndex
_distanceLeftFeatureIndex
_distanceRightFeatureIndex
_sinAngleLeftFeatureIndex
_cosAngleLeftFeatureIndex
_sinAngleRightFeatureIndex
_cosAngleRightFeatureIndex
_endpointFeatureIndex
_cutpointProbabilityOutputName
normalizedDrawing:targetHeight:interpolationDistance:outputPointMap:
textStrokeProbabilityOutputName
classifyStrokesInDrawing:outTextStrokeProbabilities:cancellationBlock:
sinAngleFeatureIndex
cosAngleFeatureIndex
_sinAngleFeatureIndex
_cosAngleFeatureIndex
_textStrokeProbabilityOutputName
writingDirectionOrderedStrokes:substrokesByStrokeIdentifier:
_substrokeCountForStrokes:substrokesByStrokeIdentifier:
initWithStrokes:substrokesByStrokeIdentifier:splitIndex:
strokeGroup1
strokeGroup2
groupBounds1
groupBounds2
transitionTime
orderedStrokesGroup1
orderedStrokesGroup2
substrokeCount1
substrokeCount2
_strokeGroup1
_strokeGroup2
_transitionTime
_orderedStrokes
_orderedStrokesGroup1
_orderedStrokesGroup2
_substrokeCount1
_substrokeCount2
_groupBounds1
_groupBounds2
initWithAncestorIdentifier:strokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:classification:groupingConfidence:strategyIdentifier:firstStrokeOrigin:orderedStrokeIdentifiers:
initWithUniqueIdentifier:ancestorIdentifier:strokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:classification:groupingConfidence:strategyIdentifier:firstStrokeOrigin:orderedStrokeIdentifiers:
_estimateSplitScore:withTextInputTargets:arcLengthsByStrokeIdentifier:
_strokeIdentifersFromStrokes:
_strokeGroupWithStrokes:orderedStrokeIdentifiers:previousGroups:shouldSearchForStableIdentifier:
isStroke:versionOfStrokeWithIdentifier:
isSubsetOfSet:
_accumulatedTimeDifferences:
_findMostProbableTextInputTarget:forGroupBounds:outOverlap:outDistance:
_splitCostThreshold
_transitionTimeWeight
_transitionTimeUpperBound
_verticalDistanceWeight
_leftTransitionWeight
_leftTransitionUpperBound
_horizontalDistanceBarrier
_horizontalDistanceWeight
_aspectRatioWeight
_writingDirectionWeight
_writingDirectionUpperBound
_writingDirectionMinCoeff
_minLineHeightScore
_minArcLengthScore
_expectedSubstrokesPerLine
_minSubstrokesForSplit
_targetFitnessWeight
_reorderStrokes
initWithStrokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:startTimestamp:endTimestamp:
groupByAddingStrokeIdentifiers:removingStrokeIdentifiers:firstStrokeIdentifier:lastStrokeIdentifier:bounds:startTimestamp:endTimestamp:
_startTimestamp
_endTimestamp
_timeSortedStrokesForIdentifiers:
initWithLocales:preferredLocales:strokeProvider:inputResult:recognitionQOSClass:recognitionEnvironment:isHighResponsivenessTask:strokeClassificationModel:strokeGroupingRequirement:partialResultBlock:
outputResult
_setStatus:
timeIntervalSinceReferenceDate
encodedStrokeIdentifier:
archivedDataWithRootObject:requiringSecureCoding:error:
currentProgress
completedUnitCount
setCompletedUnitCount:
partialResultBlock
strokeGroupingRequirement
lineGroupingResultUsingStrokes:shouldCancel:
updatedStrokeClassificationResultByAddingStrokes:removingStrokeIdentifiers:clutterFilter:affectedClutterStrokeIDs:cancellationBlock:
strokeClassificationModel
refineStrokeClassificationResultUsingClassificationResult:strokeClassificationModel:sortedAddedStrokes:removedStrokeIdentifiers:cancellationBlock:
floatForKey:
sleepForTimeInterval:
_setOutputResult:
_logResultsIfAppropriateWithStrokeProvider:
setCancelled:
_isTransitionValidFromStatus:toStatus:
forceRecognitionStrokeGroupIdentifiers
progressWithTotalUnitCount:parent:pendingUnitCount:
totalUnitCount
_textRecognitionResultsForTextStrokeGroup:groupingManager:
_recognitionResultsForNonTextStrokeGroup:groupingManager:
strokeGroupingOnly
recognizerForLocale:
saveInputDrawings
_recognizersQueue
maxRequestStrokeCountForLocale:
_tokenizedTextResultForDrawing:usingRecognizer:isRemoteRecognizer:locale:strokeLimit:recognitionError:
textRecognitionResultForDrawing:options:error:
removeIndex:
transcriptionPathsForTokenizedTextResult:withHistory:scores:error:
sortDescriptorWithKey:ascending:comparator:
sortedArrayUsingDescriptors:
initWithLocales:preferredLocales:strokeProvider:inputResult:recognitionQOSClass:recognitionEnvironment:isHighResponsivenessTask:strokeClassificationModel:strokeGroupingRequirement:subjectStrokeIdentifiers:partialResultBlock:
main
cancel
status
isHighResponsivenessTask
setSaveInputDrawings:
setForceRecognitionStrokeGroupIdentifiers:
setStrokeGroupingOnly:
subjectStrokeIdentifiers
setPartialResultBlock:
_cancelled
_isHighResponsivenessTask
_saveInputDrawings
_strokeGroupingOnly
_inputResult
_status
_recognitionLocales
_outputResult
_strokeGroupingRequirement
_forceRecognitionStrokeGroupIdentifiers
__recognizersQueue
_strokeClassificationModel
_subjectStrokeIdentifiers
_partialResultBlock
q_textInputItemsFromSessionResult:
setTotalDuration:
_setAvailableItems:
sortDescriptorWithKey:ascending:
initWithIdentifier:stableIdentifier:strokeIdentifiers:correctionResult:
availableItems
setTextInputTargetsDataSource:
totalDuration
_availableItems
_textInputTargetsDataSource
_totalDuration
correctionResult
itemIdentifier
itemStableIdentifier
resultType
isEqualToTextInputQueryItem:
_itemIdentifier
_itemStableIdentifier
_correctionResult
initWithScannerType:passiveIntent:
setSpotlightSuggestionsEnabled:
_dataDetectorResultsForSessionResult:
initWithTextResults:
initWithStrokeIdentifiers:detectedResult:estimatedBaseline:
_enumerateDetectedRangesForContextualTextResults:usingBlock:
scanString:range:configuration:
urlificationRange
textResultToIndexMappingFromTopTranscriptionWithCharacterRange:intersectionRanges:
textResults
matchedString
_dataDetectorConfiguration
dataDetectorResult
type
category
isEqualToDataDetectorQueryItem:
estimatedBaseline
_estimatedBaseline
_dataDetectorResult
initWithStrokeIdentifier:bounds:startTimestamp:endTimestamp:convexHull:curvature:
curvature
isEqualToSubstroke:
substrokesForStroke:
_convexHull
_curvature
initWithSubstroke:
setWritingOrientation:
strokeDeviation
setStrokeDeviation:
originalWritingDirectionIndex
setOriginalWritingDirectionIndex:
coalescedCenter
setCoalescedCenter:
_substroke
_originalWritingDirectionIndex
_writingOrientation
_strokeDeviation
_coalescedCenter
initWithString:
mainBundle
localizedStringForKey:value:table:
_attributedStringFromString:withColor:font:paragraphStyle:
initWithAttributedString:
appendAttributedString:
initWithString:attributes:
_sutherlandHodgmanClipForSubjectPolygon:usingClipPolygon:
enumerateEdgesWithBlock:
vertexCount
vertices
_createClippedPolygonForPolygon:clippingLine:clippedPolygonVertexCount:
polygonDrawing
setArea:
_area
_vertexCount
_vertices
setResultDrawn:
lastRecognitionResult
newGroupsDefaultToActive
_markStrokeGroupsAsActive:
visualizationNeedsDisplay:
visualization:needsDisplayInRect:
setActiveStrokeGroupAncestorIdentifiers:
_newGroupsDefaultToActive
_resultDrawn
_activeStrokeGroupAncestorIdentifiers
initWithMachServiceName:options:
handleRecognitionRequest:withReply:
transcriptionPathsForTokenizedResult:recognitionRequest:withReply:
interfaceWithProtocol:
setClasses:forSelector:argumentIndex:ofReply:
setRemoteObjectInterface:
_teardownXPCConnection
setInterruptionHandler:
setInvalidationHandler:
resume
invalidate
_recognitionRequestWithDrawing:options:
_recognitionResultForRequest:error:
synchronousRemoteObjectProxyWithErrorHandler:
_setupXPCConnectionIfNeeded
isEqualToRemoteRecognizer:
absoluteMaxStrokeCountPerRequest
_connection
__connection
defaultManager
contentsAtPath:
JSONObjectWithData:options:error:
keysSortedByValueUsingComparator:
longLongValue
unregisterChangeObserver:
isEnabledVisualizationForIdentifier:
_enabledVisualizationIDs
_updateInstalledVisualizations
_activeVisualizationIDs
_updateSessionRegistration
statusReportingEnabled
_activeVisualizationsByID
availableVisualizationIdentifiers
_isActiveVisualizationForIdentifier:
_addVisualizationForIdentifier:
_removeVisualizationForIdentifier:
visualizationManagerNeedsDisplay:
_classForVisualizationIdentifier:
_registeredAsChangeObserver
registerChangeObserver:
set_registeredAsChangeObserver:
_registeredAsInputDrawingsClient
registerInputDrawingClient:
unregisterInputDrawingClient:
set_registeredAsInputDrawingsClient:
visualizationManager:needsDisplayInRect:
_strokeGroupIndexByAncestorID
_updateKnownStrokeGroupIndexes
visualizationManagerDidUpdateSessionStatus:
localizedNameForVisualizationIdentifier:
availableRecognitionSessionStatusKeys
localizedNameForRecognitionSessionStatusKey:
variableHeightForRecognitionSessionStatusKey:
recognitionSessionDidUpdateRecognitionResult:
preferredRecognitionResultUpdatesInterval
recognitionSessionDidChangeStatus:
setEnabled:forVisualizationIdentifier:
setStatusReportingEnabled:
valueForRecognitionStatusKey:
toggleSelectiveVisualizationsAtPoint:
_statusReportingEnabled
__registeredAsChangeObserver
__registeredAsInputDrawingsClient
__enabledVisualizationIDs
__activeVisualizationIDs
__activeVisualizationsByID
__strokeGroupIndexByAncestorID
contextualTextResultsForContextStrokes:completion:shouldCancel:
distantPast
_queryActive
set_queryActive:
_updateForRecognitionSessionResultChangeIfNeeded
waitForPendingRecognitionTasks
preferredUpdatesInterval
start
waitForPendingUpdates
lastProcessedStrokeProviderVersion
setLastProcessedStrokeProviderVersion:
_processingQueue
_currentProcessingSessionResult
_lastProcessedTime
__queryActive
_lastProcessedStrokeProviderVersion
_preferredUpdatesInterval
queryDidUpdateResult:
terminatingSpecialCharacter
setTerminatingSpecialCharacter:
_terminatingSpecialCharacter
setTextResults:
_textResults
affectedRange
isCharacterLevel
initWithInputTarget:affectedRange:textResult:resultType:isCharacterLevel:error:
isEqualToTextCorrectionResult:
_characterLevel
_inputTarget
_resultType
_error
_affectedRange
_decodeLocale:supportedLanguage:supportedScript:
_stringForRecognitionLanguage:
_stringForRecognitionScript:
supportedScriptForLocale:
supportedLanguageForLocale:
isLanguageSupported:withMode:
shouldRunNextGenCharacterLM
effectiveEngineLanguage
shouldTransliterateHalfWidthPunctuations
shouldApplySemanticTokenization
shouldIdentifyChangeableColumns
shouldMergeNoPrecedingWhiteSpaceColumns
linguisticResourcesFallbackLocale
URLWithString:
initWithFile:
initWithPatternFst:
shouldReorderSCTCConfusion
initWithRecognizer:
initWithRecognizer:languageModel:
initWithAutoCapitalizationMode:locale:staticLexicon:customLexicon:phraseLexicon:customPhraseLexicon:recognizer:textReplacements:
shouldRefineCandidates
initWithRecognizer:shouldKeepOutOfPatternCandidates:shouldKeepDuplicateTokenIDs:
shouldMarkMultiWordOVS
initWithSequence:
initWithPatternFst:patternType:capitalizationToSplit:convertToLowercase:
initForPhoneNumberFields
initForDigitFields
initProcessorDefault:processorDigits:processorPhone:processorUsername:processorEmail:processorURL:processorASCII:processorEquation:
initWithStep:
languageResourceBundleWithStaticLexicon:customLexicon:wordLanguageModel:
initWithLanguageResourceBundle:
defaultCommitActionBehaviorForLocale:
decodingLexiconWeight
initWithLexicon:priority:
initWithLexicons:decodingWeight:lowerBoundLogProbability:
decodingCharacterLMWeight
characterLMLowerBoundLogProbability
initWithCVNLPLanguageModel:locale:decodingWeight:lowerBoundLogProbability:
initWithLMLanguageModel:locale:decodingWeight:lowerBoundLogProbability:
decodingWordLMWeight
initWithLexicons:characterLanguageModel:wordLanguageModel:
forcedGen2ModelLocaleForLocale:
spellCheckingLocaleForRecognitionLocale:string:
shouldPreserveLegacyTranscriptionPaths
_language
_script
_mode
expectedMaxStrokeCount:
_strokeProviderDrawn
set_strokeProviderDrawn:
__strokeProviderDrawn
initWithSessionVersion:sessionResultVersion:
isValidSessionVersion
isValidSessionResultVersion
sessionVersion
sessionResultVersion
_sessionVersion
_sessionResultVersion
_setupExecutionQueuesForMode:
initWithMode:
setDataSource:
strokeProviderSnapshot
_setLatestStrokeProvider:
_updateLatestStrokeProviderVisibleStrokes
_invalidateCachedResults
_sessionQueue
effectiveLocalesFromLocales:
_setTextRecognitionLocales:
_cleanupCachedRecognizers
_isReadyToProcessChanges
rebuildRecognitionResults
setNeedsRecognitionUpdate
setPreferredLocales:
isEqualToData:
_notifyObserversWithBlock:
visibleStrokeEncodedIdentifiers
_setCachedFastGroupingRecognitionResult:
_setPartialRecognitionResult:
_hasPendingRecognitionTasks
_hasUnprocessedChanges
_changeObservers
nonretainedObjectValue
_activeTasks
indexableContent
dataSource
_setLatestTextInputTargets:
_setHasUnprocessedChanges:
_scheduleProcessStrokeProviderChangesImmediately:
_updateRecognitionSessionStatus
_cancelOngoingRequests
_changeCoalescingIndex
set_changeCoalescingIndex:
_setLastRecognitionResult:
_processPendingStrokeChangesIfAvailable
_preferredCoalescingInterval
_newRecognitionSessionTaskWithStrokeGroupingRequirement:isHighResponsivenessTask:strokeGroupingOnly:subjectStrokeIdentifiers:partialResultBlock:
_tasksWorkQueue
_inputDrawingClients
_recognizersByLocaleID
_shouldRunRecognitionLocally
createRecognizerForLocale:sessionMode:remote:priority:
_correctionRecognizersByLocaleID
isRemoteRecognition
initWithLocale:remoteRecognition:priority:
data
initWithMode:withVersion:
setRecognitionEnvironment:
initWithMode:recognitionSessionResult:dataSource:
setLocales:
_validateLastRecognitionResult:visibleStrokeIdentifiers:
_cachedFastGroupingResult
_cachedClutterFilter
cancelOngoingRequests
_cancelAllHighResponsivenessTasks
sessionData
loadSessionData:error:
_textRecognitionLocales
_latestTextInputTargets
_highResponsivenessQueue
_taskQueueQoSClass
_shouldForceFastGrouping
_setShouldForceFastGrouping:
_lastRecognitionResult
_latestStrokeProvider
_latestStrokeProviderVisibleStrokes
_cachedFastGroupingRecognitionResult
_partialRecognitionResult
_version
__hasUnprocessedChanges
__shouldForceFastGrouping
__taskQueueQoSClass
_dataSource
__textRecognitionLocales
__recognizersByLocaleID
__latestTextInputTargets
__correctionRecognizersByLocaleID
__changeCoalescingIndex
__changeObservers
__inputDrawingClients
__tasksWorkQueue
__sessionQueue
__highResponsivenessQueue
__activeTasks
valueWithNonretainedObject:
recognizableDrawingForStrokeGroupQueryItem:
progressWithTotalUnitCount:
_strokeIdentifiersFromCachedResultUsingContextStrokes:tokenizationLevel:
shouldForceFastGrouping
orderedSetWithArray:
groupingResultForContextStrokes:clusteredStrokes:fastGroupingResult:point:tokenizationLevel:
strokeIdentifiersInProximalGroupsForStrokeIdentifiers:sortedStrokeGroups:clusteredStrokeGroups:unusedStrokeIdentifiers:
setWithSet:
_strokeGroupsInProximityOfSubjectStrokeGroups:clusteredStrokeGroups:
_strokeGroupsContainingStrokeIdentifiers:
clustersForStrokes:shouldMakeSingleCluster:
fastGroupingResultWithFastGroupingClusters:clusteredStrokes:
_strokeIdentifiersInWordsContainingStrokeIdentifiers:
_strokeIdentifiersInGroupsContainingStrokeIdentifiers:
_strokeIdentifiersInProximalGroupsForStrokeIdentifiers:
_drawingCanvasSizeForLatestStrokeProviderSnapshot
_recognitionSessionResultOnDemandUsingContextStrokes:shouldCancel:
becomeCurrentWithPendingUnitCount:
_contextualTextResultsFromCachedResultUsingContextStrokes:shouldCancel:
resignCurrent
drawingCanvasSize
setShouldForceFastGrouping:
lastRecognitionResultWaitingForPendingTasks
_gestureOnBlankAreaResultForDrawing:originalDrawing:targetContentInfo:
_editingGestureResultForDrawing:originalDrawing:lastStroke:targetContentInfo:previousResult:
_refinedGestureResultForPreviousResult:originalDrawing:lastStroke:targetContentInfo:
_textInsertionResultForDrawing:targetContentInfo:originalDrawing:localTypedContextBounds:normalizedDrawingScaleFactor:insertionRange:
_cornerDetector
value:withObjCType:
_textBeforeStringForTargetContentInfo:insertionRange:
_precedingLineBreakCountForAutoLineBreak:targetContentInfo:
_precedingSpaceBehaviorFromTargetContentInfo:drawingBounds:localTypedContextBounds:insertionRange:lastCharacterBefore:
_textAfterStringForTargetContentInfo:insertionRange:
_textRecognizer
_modifiedTextResult:replacingString:
_improvedSingleCharacterOneColumnTextResult:targetContentInfo:insertionRange:locale:affectedRange:
_verticalBarGestureOnBlankAreaResultForDrawing:originalDrawing:targetContentInfo:
hasSuffix:
_relativeRangeOfPreviousCharacterFromTargetContentInfo:absoluteInsertionRange:
lowercaseStringWithLocale:
_shapeRecognizer
_isRemoteRecognition
__textRecognizer
__shapeRecognizer
__cornerDetector
sharedCharacterSetRules
_charSetRulesQueue
_expectedMaxStrokeCount:
_expectedMinStrokeCount:
_expectedMaxDotCount:
_characterType:
lowercaseCharSet
setLowercaseCharSet:
uppercaseCharSet
setUppercaseCharSet:
digitCharSet
setDigitCharSet:
startPunctuationCharSet
setStartPunctuationCharSet:
middlePunctuationCharSet
setMiddlePunctuationCharSet:
endOfWordPunctuationCharSet
setEndOfWordPunctuationCharSet:
endOfSentencePunctuationCharSet
setEndOfSentencePunctuationCharSet:
digitStartPunctuationCharSet
setDigitStartPunctuationCharSet:
digitEndPunctuationCharSet
setDigitEndPunctuationCharSet:
arithmeticOperatorCharSet
setArithmeticOperatorCharSet:
dateTimeSeparatorCharSet
setDateTimeSeparatorCharSet:
dateTimeEndLetterCharSet
setDateTimeEndLetterCharSet:
numeralEndLetterCharSet
setNumeralEndLetterCharSet:
lexiconSkipCharSet
setLexiconSkipCharSet:
containsDotCharSet
setContainsDotCharSet:
containsTwoDotsCharSet
setContainsTwoDotsCharSet:
prefixCapitalizationExceptionCharSet
setPrefixCapitalizationExceptionCharSet:
selfLoopPunctuationCharSet
setSelfLoopPunctuationCharSet:
emoticonTopCharSet
setEmoticonTopCharSet:
emoticonMiddleCharSet
setEmoticonMiddleCharSet:
emoticonBottomCharSet
setEmoticonBottomCharSet:
emailAtCharSet
setEmailAtCharSet:
emailPunctuationCharSet
setEmailPunctuationCharSet:
urlPunctuationCharSet
setUrlPunctuationCharSet:
nonSpaceSeparatorCharSet
setNonSpaceSeparatorCharSet:
strokeMaxPenalties
setStrokeMaxPenalties:
signatureUniChar
setSignatureUniChar:
_lowercaseCharSet
_uppercaseCharSet
_digitCharSet
_startPunctuationCharSet
_middlePunctuationCharSet
_endOfWordPunctuationCharSet
_endOfSentencePunctuationCharSet
_digitStartPunctuationCharSet
_digitEndPunctuationCharSet
_arithmeticOperatorCharSet
_dateTimeSeparatorCharSet
_dateTimeEndLetterCharSet
_numeralEndLetterCharSet
_lexiconSkipCharSet
_containsDotCharSet
_containsTwoDotsCharSet
_prefixCapitalizationExceptionCharSet
_selfLoopPunctuationCharSet
_emoticonTopCharSet
_emoticonMiddleCharSet
_emoticonBottomCharSet
_emailAtCharSet
_emailPunctuationCharSet
_urlPunctuationCharSet
_nonSpaceSeparatorCharSet
__charSetRulesQueue
_strokeMaxPenalties
_signatureUniChar
substrokePlacementsByStrokeIdentifier
initWithDictionary:copyItems:
initWithStrokeGroups:createdStrokeGroups:deletedStrokeGroups:substrokePlacementsByStrokeIdentifier:
_substrokePlacementsByStrokeIdentifier
_updateGroups:createdGroups:deletedGroups:forAddedStroke:substrokePlacementsByStrokeIdentifier:reusableIDRemovedGroups:trySplit:cancellationBlock:
mergeGroupsPostProcessing:createdGroups:deletedGroups:
_applyDefaultGroupingParameters
_applyStrictGroupingParameters
_getMergingLowerBoundCost:withStrokeBounds:toLineGroup:
getMergingEndOfLineCost:mergingEndOfLineStroke:forStroke:consistingOfSubstrokes:toLineGroup:
compareDistanceInWritingSequenceOfStroke:andStroke:toReferenceStroke:
getMergingMiddleOfLineCost:mergingMiddleOfLineStroke:forStroke:consistingOfSubstrokes:toLineGroup:
_textLineStrokeGroupByAddingStroke:withSubstrokePlacements:intoStrokeGroup:mergingEndSubgroup:bestStrokeMergeEnd:
tryRegroupingStrokesInGroup:substrokePlacementsByStrokeIdentifier:cancellationBlock:
_newTextLineStrokeGroupWithStroke:withSubstrokePlacements:reusableIDRemovedGroups:
estimateWritingDirectionAndSortSubstrokesAccordingly:averageWritingOrientation:averageStrokeDeviation:
_writingDirectionSortedStrokeIdentifiersFromSubstrokes:localWritingOrientations:
_lastSubstrokeCoalescedWithOverlappingSubstrokes:strokeDeviation:
_strokeGroupConfidenceForSortedSubstrokes:writingDirectionSortedStrokeIdentifiers:localStrokeWritingOrientations:averageWritingOrientation:averageStrokeDeviation:
_normalizedBoundsForWritingDirectionSortedStrokes:strokeWritingOrientations:firstStrokeDeviation:originalDrawing:rotatedSortedStrokes:
_scaleFactorForBoundsHeight:
_getMergingEndOfLineCost:mergingEndOfLineStroke:forStroke:consistingOfSubstrokes:toLineGroup:refSubstrokeIndex:
clippedWritingOrientation:
_averageVectorFromCoalescedSubstrokes:toSubstroke:withOrientation:strokeRef:strokeDest:
updateLocalWritingOrientationsForSubstrokes:useCoalescedCenter:
sortSubstrokesByWritingDirection:averageWritingOrientation:
refineLocalWritingOrientationsForSubstrokes:useCoalescedCenter:
initWithArray:copyItems:
refineWritingOrientationAndResortSubstrokes:averageWritingOrientation:
updateLocalStrokeDeviationsForSubstrokes:averageStrokeDeviation:
smoothLocalWritingOrientations:
flippedCenters:ofSubstrokes:maxStrokesGap:begnning:
_averageAngleAndReliabilityForStrokeGroup:
_boundingBoxesOfStrokesInGroup:rotatedAroundPoint:byAngle:
_verticalOffsetForBoundsHeight:andScaleFactor:
_defaultOrientationVector
_defaultDeviationVector
_strokeDeviationCapCoeff
_groupingMergingCostThresh
_groupingMergingEndCostLowThresh
_groupingSimilarCostThresh
_groupingContextSize
_mergeEndDxCostCoeff
_mergeEndDyCostCoeff
_mergeEndBelowModifier
_mergeEndLeftModifier
_mergeMiddleDxCostCoeff
_mergeMiddleDyCostCoeff
_mergeMiddleBelowModifier
_shouldLimitDefaultWritingOrientationDeviation
_shouldAdjustDeviationOfSmallGroups
_shouldCoalesceLastSubstrokes
initWithCapacity:
updateNonTextCandidatesByRemovingSupportFromStrokeIdentifier:skippingCandidatesWithStrokeIdentifier:
strokeAttributes
nonTextCandidateForStroke:withSubstrokes:
updateByRemovingStrokeIdentifier:withRemovedAndClutterStrokeIDs:
updateByTransitionedClutterStrokeIdentifier:withRemovedAndClutterStrokeIDs:
updateByAddingNonClutterStroke:withAllStrokes:forceText:
updateByAddingNonClutterStroke:withClassification:
updateByAddingClutterStroke:
strokeClassificationLastResult
textOnly
changeableClassificationByRefinement:stroke:
_tileIndexForYPosition:tileHeight:
containerSupportForPoints:withBounds:
_textOnly
_strokeClassificationLastResult
initWithFastGroupingClusters:clusteredStrokes:strokeProvider:strategyIdentifier:clutterFilter:
_agglomerativeClusteringUsingInitialClusters:distanceMetric:maxDistanceThreshold:shouldCancel:
_maxDistanceThresholdForTokenizationLevel:
_filterClusters:usingContextStrokes:clusteredStrokes:
_wordClustersForInitialClusters:
_strokeIdentifiersForContextStrokes:clusters:clusteredStrokes:tokenizationLevel:fastGroupingResult:
_labelBoundsForAnchorPoint:
_newBaselinePathForStrokeGroup:outFirstPoint:strokeProvider:
_getOrientedBounds:length:forStroke:atWritingDirectionIndex:inGroup:
_orientationTransformForStrokeBounds:atWritingDirectionIndex:inGroup:
initWithIndexableTextRepresentation:presentableTextRepresentation:
_setIndexableContent:
_indexableContent
indexableTextRepresentation
presentableTextRepresentation
_indexableTextRepresentation
_presentableTextRepresentation
_strokeGroupsFromFastGroupingClusters:clusteredStrokes:strokeProvider:strategyIdentifier:clutterFilter:
_strokeGroupFromSortedStrokeIdentifiers:strokeProvider:strategyIdentifier:
_strokeGroupFromFastGroupingCluster:strokeProvider:strategyIdentifier:
_fastGroupingClusters
nodeIndexCount
nodeIndexAtPosition:
stateType
addNodeIndex:withStateType:
cursorByAddingNodeIndex:toCursor:
setStateType:
_nodeIndexes
_stateType
newCursorByAdvancingCursor:withSymbol:
stateTypeForNodeIndex:
patternToSymbolMap
scannerWithString:
scanHexInt:
numberWithLong:
contentTypesToPatternsMapping
isString:fullPattern:inNetwork:
_network
_symbols
_startNodes
_startCursorForContentTypes
leftContext
setLeftContext:
setResult:
_leftContext
_result
initWithObjects:
sequence
setSequence:
_sequence
applyTransform:toAllTokens:
defaultProcessor
process:withProcessor:
digitProcessor
phoneProcessor
usernameProcessor
emailProcessor
urlProcessor
asciiProcessor
equationProcessor
setDefaultProcessor:
setDigitProcessor:
setPhoneProcessor:
setUsernameProcessor:
setEmailProcessor:
setUrlProcessor:
setAsciiProcessor:
setEquationProcessor:
_defaultProcessor
_digitProcessor
_phoneProcessor
_usernameProcessor
_emailProcessor
_urlProcessor
_asciiProcessor
_equationProcessor
getSpellCorrectedToken:contextBeforeToken:
capitalizeString:
applyLexiconCorrections:shouldCapitalizeWord:shouldSkipEntryCorrection:outBestTokenIndex:bestLexiconTokenScore:textReplacements:contextBeforeToken:
capitalizeToken:
tokenIsExemptFromCorrection:inPath:withTokensInRow:
applyLexiconCorrectionOnToken:hasEmptyContext:history:historyEndsAlphabetic:historyEndsWithLineBreak:prevToken:shouldCapitalizeGivenHistory:tokenIndex:textReplacements:shouldEntrySkipCorrection:contextBeforeToken:
shouldAutocapitalize
setShouldAutocapitalize:
recognizer
setRecognizer:
consumableStrokesCharSet
setConsumableStrokesCharSet:
fullWidthPunctuationThatExpectsUppercaseAfter
setFullWidthPunctuationThatExpectsUppercaseAfter:
_shouldAutocapitalize
_recognizer
_consumableStrokesCharSet
_fullWidthPunctuationThatExpectsUppercaseAfter
setValue:forKey:
_updateTokenInappropriateFlag:
initWithIndex:
setShouldKeepOutOfPatternCandidates:
setShouldKeepDuplicateTokenIDs:
shouldKeepOriginalSpelling
setShouldKeepOriginalSpelling:
_shouldKeepOutOfPatternCandidates
_shouldKeepDuplicateTokenIDs
_shouldKeepOriginalSpelling
patternType
setPatternType:
capitalizationToSplit
setCapitalizationToSplit:
convertToLowercase
setConvertToLowercase:
_capitalizationToSplit
_convertToLowercase
_patternType
countUnallowedCharactersInString:
tokenRowAsString:
compareStringForPhoneNumberCompatibility:with:
allowedCharacters
setAllowedCharacters:
characterReplacements
setCharacterReplacements:
_allowedCharacters
_characterReplacements
indexPathByRemovingLastIndex
ch_mappedArrayWithBlock:
@84@0:8@16@24B32{CGRect={CGPoint=dd}{CGSize=dd}}36B68B72Q76
v16@0:8
@16@0:8
B16@0:8
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
Q16@0:8
@"CHDrawing"
@"NSCharacterSet"
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
I48@0:8@16I24B28^d32^v40
@40@0:8@16^@24^v32
@32@0:8@16q24
B40@0:8^{_LXLexicon=}16@24@32
@32@0:8@16^^v24
@24@0:8@16
q32@0:8@16@24
@48@0:8@16{CGPoint=dd}24q40
@64@0:8@16{CGPoint=dd}24q40@?48@?56
v24@0:8@16
@"NSArray"
@"NSDictionary"
@24@0:8q16
@72@0:8@16@24@32q40@48@56@64
@32@0:8@16^@24
q16@0:8
@"NSNumber"
@"NSLocale"
v56@0:8^@16^@24@32@40@48
@32@0:8@16@24
@"<CHStrokeProvider>"
@64@0:8@16@24@32@40@48@?56
@64@0:8@16{CGVector=dd}24^@40^@48^d56
@24@0:8^{_NSZone=}16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
B24@0:8@16
@"NSData"
@76@0:8@16@24I32d36d44d52Q60q68
I16@0:8
@"NSString"
@"NSIndexSet"
d16@0:8
v20@0:8I16
v24@0:8d16
v24@0:8Q16
v24@0:8q16
@"NSSet"
v20@0:8B16
B28@0:8@16i24
d92@0:8@16@24@32B40B44B48@52@60^@68^@76^B84
Q24@0:8Q16
v68@0:8@16@24@32@40^@48B56^B60
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@28@0:8i16@20
i16@0:8
v20@0:8i16
{CGSize=dd}16@0:8
v32@0:8{CGSize=dd}16
@28@0:8i16@"NSLocale"20
@"NSLocale"16@0:8
@"NSCharacterSet"16@0:8
v24@0:8@"NSCharacterSet"16
@40@0:8i16i20^{__CFLocale=}24@32
@36@0:8i16@20@28
@44@0:8i16@20@28@36
@32@0:8i16i20@24
@32@0:8^@16q24
@24@0:8Q16
B24@0:8^{_LXEntry=}16
B32@0:8@16^{_LXLexicon=}24
B32@0:8@16^{_CFBurstTrie=}24
I40@0:8@16^{_LXLexicon=}24^B32
v24@0:8^v16
v32@0:8@16@24
v32@0:8^{_LXLexicon=}16^v24
v24@0:8^{_LXLexicon=}16
{vector<const void *, std::__1::allocator<const void *> >=^^v^^v{__compressed_pair<const void **, std::__1::allocator<const void *> >=^^v}}40@0:8@16@24Q32
{vector<const void *, std::__1::allocator<const void *> >=^^v^^v{__compressed_pair<const void **, std::__1::allocator<const void *> >=^^v}}48@0:8@16@24@32Q40
@24@0:8i16i20
@32@0:8i16i20^{__CFLocale=}24
@20@0:8i16
v40@0:8@16^{CGPoint=dd}24^{CGPoint=dd}32
@32@0:8@16^{CHCandidateResult=If}24
@40@0:8@16^{CHCandidateResult=If}24^@32
@48@0:8@16@24@32@40
d56@0:8@16@24^I32Q40^@48
d64@0:8@16@24@32@40^I48Q56
@48@0:8@16@24@32^@40
@144@0:8^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}16Q24^{_LXCursor=}32^{_LXCursor=}40@48@56{_NSRange=QQ}64^{vector<int, std::__1::allocator<int> >=^i^i{__compressed_pair<int *, std::__1::allocator<int> >=^i}}80@88q96i104B108^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}112^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}120q128q136
B72@0:8@16@24d32d40B48B52B56I60@64
@104@0:8r^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}16@24{_NSRange=QQ}32B48B52Q56q64@72q80q88q96
@72@0:8r^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}16Q24{_NSRange=QQ}32q48q56q64
@80@0:8r^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}16Q24@32{_NSRange=QQ}40q56@64q72
@72@0:8r^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}16Q24^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}32^{vector<int, std::__1::allocator<int> >=^i^i{__compressed_pair<int *, std::__1::allocator<int> >=^i}}40q48q56@64
@148@0:8@16^{_LXLexicon=}24@32@40d48{_NSRange=QQ}56^d72B80B84B88q92d100q108^q116^B124^B132^B140
@64@0:8r^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}16@24{_NSRange=QQ}32q48@56
^I60@0:8@16q24B32^Q36^B44^{_NSRange=QQ}52
v40@0:8{_NSRange=QQ}16@32
{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}32@0:8@16@24
@48@0:8@16@24@32@?40
@148@0:8^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}16@24@32{_NSRange=QQ}40^{_LXCursor=}56^{_LXCursor=}64@72@80Q88q96B104^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}108^{vector<LatticePath, std::__1::allocator<LatticePath> >=^{LatticePath}^{LatticePath}{__compressed_pair<LatticePath *, std::__1::allocator<LatticePath> >=^{LatticePath}}}116q124q132@?140
@72@0:8^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}16@24@32Q40@48q56q64
q76@0:8@16^{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}24^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}32^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}40^{set<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::allocator<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > > >={__tree<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::allocator<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > > >=Q}}}48@56B64@?68
{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}96@0:8^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}16@24@32^{vector<CGRect, std::__1::allocator<CGRect> >=^{CGRect}^{CGRect}{__compressed_pair<CGRect *, std::__1::allocator<CGRect> >=^{CGRect}}}40{_NSRange=QQ}48{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}64@?88
{CGRect={CGPoint=dd}{CGSize=dd}}96@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16{CGRect={CGPoint=dd}{CGSize=dd}}48^{vector<CGRect, std::__1::allocator<CGRect> >=^{CGRect}^{CGRect}{__compressed_pair<CGRect *, std::__1::allocator<CGRect> >=^{CGRect}}}80@88
d20@0:8B16
v104@0:8{vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}^{CHCandidateResult}{__compressed_pair<CHCandidateResult *, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}}}16^{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}40r^{NetworkEdge=QQQQddQQQ{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}}48^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}56q64{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}72q96
{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}20@0:8I16
@48@0:8@16Q24@32q40
d24@0:8@16
@40@0:8@16^@24@32
v60@0:8^@16^@24@32q40@48B56
@40@0:8@16Q24Q32
@48@0:8@16@24q32^q40
@52@0:8@16@24q32B40q44
B32@0:8@16@24
@64@0:8@16@24{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}32@56
@40@0:8@16@24@?32
{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}48@0:8r^{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}16@24@32^@40
v32@0:8^{vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}^{CHCandidateResult}{__compressed_pair<CHCandidateResult *, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}}}16r^{vector<unsigned int, std::__1::allocator<unsigned int> >=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int> >=^I}}24
v32@0:8^{vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}^{CHCandidateResult}{__compressed_pair<CHCandidateResult *, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}}}16@24
v40@0:8^{vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}^{CHCandidateResult}{__compressed_pair<CHCandidateResult *, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}}}16@24@32
v32@0:8^{vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}^{CHCandidateResult}{__compressed_pair<CHCandidateResult *, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}}}16q24
v24@0:8^{vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}^{CHCandidateResult}{__compressed_pair<CHCandidateResult *, std::__1::allocator<CHCandidateResult> >=^{CHCandidateResult}}}16
@32@0:8^S16i24i28
I24@0:8@16
q24@0:8@16
{CGRect={CGPoint=dd}{CGSize=dd}}24@0:8@16
{CGPoint=dd}24@0:8@16
^{CHNeuralNetwork=^?B^{CHCodeMap}IIII@@{CGRect={CGPoint=dd}{CGSize=dd}}}16@0:8
v24@0:8^{CHNeuralNetwork=^?B^{CHCodeMap}IIII@@{CGRect={CGPoint=dd}{CGSize=dd}}}16
^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}16@0:8
v24@0:8^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}16
^v16@0:8
^{__Mecabra=}16@0:8
v24@0:8^{__Mecabra=}16
^{_LXLexicon=}16@0:8
^{_CFBurstTrie=}16@0:8
v24@0:8^{_CFBurstTrie=}16
{map<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::allocator<std::__1::pair<const std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >={__tree<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true>, std::__1::allocator<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true> >=Q}}}16@0:8
v40@0:8{map<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::allocator<std::__1::pair<const std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >={__tree<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true>, std::__1::allocator<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true> >=Q}}}16
{map<unsigned int, unsigned int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned int> > >={__tree<std::__1::__value_type<unsigned int, unsigned int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true> >=Q}}}16@0:8
v40@0:8{map<unsigned int, unsigned int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned int> > >={__tree<std::__1::__value_type<unsigned int, unsigned int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true> >=Q}}}16
^{VariantMap=^i^i^ii^iQ}16@0:8
v24@0:8^{VariantMap=^i^i^ii^iQ}16
^^v16@0:8
v24@0:8^^v16
@"CHRecognitionInsightRequest"
@"CHRecognitionInsight"
^{CHNeuralNetwork=^?B^{CHCodeMap}IIII@@{CGRect={CGPoint=dd}{CGSize=dd}}}
@"CHStrokeTransitionModel"
@"CHCutpointModel"
@"CHCTCRecognitionModel"
@"CVNLPCTCTextDecoder"
@"NSObject<OS_dispatch_queue>"
^{Network={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}Q{vector<NetworkNode, std::__1::allocator<NetworkNode> >=^{NetworkNode}^{NetworkNode}{__compressed_pair<NetworkNode *, std::__1::allocator<NetworkNode> >=^{NetworkNode}}}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}{vector<NetworkEdge, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}^{NetworkEdge}{__compressed_pair<NetworkEdge *, std::__1::allocator<NetworkEdge> >=^{NetworkEdge}}}{vector<const NetworkEdge *, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}^^{NetworkEdge}{__compressed_pair<const NetworkEdge **, std::__1::allocator<const NetworkEdge *> >=^^{NetworkEdge}}}{SymbolMap=^^?{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}{map<std::__1::basic_string<char>, unsigned long, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, unsigned long> > >={__tree<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__value_type<std::__1::basic_string<char>, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::basic_string<char>, std::__1::__value_type<std::__1::basic_string<char>, unsigned long>, std::__1::less<std::__1::basic_string<char> >, true> >=Q}}}}B{map<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > >, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >={__tree<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > > > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, std::__1::map<unsigned long, unsigned long, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned long> > > >, std::__1::less<unsigned long>, true> >=Q}}}{set<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >={__tree<NetworkEdgeIdentifier, std::__1::less<NetworkEdgeIdentifier>, std::__1::allocator<NetworkEdgeIdentifier> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<NetworkEdgeIdentifier, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<NetworkEdgeIdentifier> >=Q}}}^IQ}
@"CHPatternNetwork"
@"CHRecognizerConfiguration"
^{__Mecabra=}
^{_LXLexicon=}
@"NSMutableDictionary"
@"CHSpellChecker"
^{_CFBurstTrie=}
@"NSURL"
^{VariantMap=^i^i^ii^iQ}
@"NSMutableIndexSet"
@"CHPostProcessingManager"
{CGSize="width"d"height"d}
{map<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::allocator<std::__1::pair<const std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >="__tree_"{__tree<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true>, std::__1::allocator<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > > > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::__value_type<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> >, std::__1::vector<CHCandidateResult, std::__1::allocator<CHCandidateResult> > >, std::__1::less<std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, true> >="__value_"Q}}}
{map<unsigned int, unsigned int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned int> > >="__tree_"{__tree<std::__1::__value_type<unsigned int, unsigned int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned int> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned int>, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true> >="__value_"Q}}}
@96@0:8Q16q24q32@40{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}48{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}72
{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}16@0:8
{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}16@0:8
@"CHClassifiableDrawing"
{set<long, std::__1::less<long>, std::__1::allocator<long> >="__tree_"{__tree<long, std::__1::less<long>, std::__1::allocator<long> >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::less<long> >="__value_"Q}}}
{vector<long, std::__1::allocator<long> >="__begin_"^q"__end_"^q"__end_cap_"{__compressed_pair<long *, std::__1::allocator<long> >="__value_"^q}}
v48@0:8^@16^@24@32@40
v48@0:8@16q24q32@?40
d32@0:8@16@24
d32@0:8d16@24
{CGRect={CGPoint=dd}{CGSize=dd}}48@0:8r^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16{CGPoint=dd}24d40
{CGRect={CGPoint=dd}{CGSize=dd}}36@0:8r^{vector<CGRect, std::__1::allocator<CGRect> >=^{CGRect}^{CGRect}{__compressed_pair<CGRect *, std::__1::allocator<CGRect> >=^{CGRect}}}16q24B32
{CGRect={CGPoint=dd}{CGSize=dd}}40@0:8r^{vector<CGRect, std::__1::allocator<CGRect> >=^{CGRect}^{CGRect}{__compressed_pair<CGRect *, std::__1::allocator<CGRect> >=^{CGRect}}}16d24q32
{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}24@0:8@16
{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}32@0:8@16@24
{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}24@0:8^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16
{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}32@0:8r^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16d24
d40@0:8r^{list<CGPoint, std::__1::allocator<CGPoint> >={__list_node_base<CGPoint, void *>=^{__list_node_base<CGPoint, void *>}^{__list_node_base<CGPoint, void *>}}{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__list_node<CGPoint, void *> > >=Q}}16^{CGPoint=dd}24^d32
d24@0:8^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}16
d32@0:8r^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16^d24
d64@0:8{CGPoint=dd}16{CGPoint=dd}32{CGPoint=dd}48
d64@0:8{CGPoint=dd}16{CGRect={CGPoint=dd}{CGSize=dd}}32
{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}48@0:8r^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16d24d32^d40
@"CHTokenizedTextResult"
@"NSError"
v24@0:8r^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}16
v528@0:8{CHDrawingStrokes={vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}qI{Matrix<double>=^^?^dII}d{vector<int, std::__1::allocator<int> >=^i^i{__compressed_pair<int *, std::__1::allocator<int> >=^i}}}16
{CGPoint=dd}32@0:8Q16Q24
@32@0:8{CGSize=dd}16
{CGRect={CGPoint=dd}{CGSize=dd}}24@0:8Q16
f16@0:8
v32@0:8{CGPoint=dd}16
{_NSRange=QQ}24@0:8@16
{Matrix<float>=^^?^fII}32@0:8{CGSize=dd}16
{Matrix<float>=^^?^fII}32@0:8Q16Q24
@24@0:8d16
@40@0:8{CGVector=dd}16d32
@32@0:8d16^{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}{__compressed_pair<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > *, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}}}24
@48@0:8Q16{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}24
@40@0:8d16@24@32
@40@0:8{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}16
{CGRect={CGPoint=dd}{CGSize=dd}}32@0:8@16@24
d32@0:8d16d24
{CHDrawingStrokes={vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}{vector<bool, std::__1::allocator<bool> >=^QQ{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >=Q}}{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}^{vector<double, std::__1::allocator<double> >}{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >=^{vector<double, std::__1::allocator<double> >}}}qI{Matrix<double>=^^?^dII}d{vector<int, std::__1::allocator<int> >=^i^i{__compressed_pair<int *, std::__1::allocator<int> >=^i}}}16@0:8
{CHDrawingStrokes="strokeBounds"{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >="__begin_"^{vector<double, std::__1::allocator<double> >}"__end_"^{vector<double, std::__1::allocator<double> >}"__end_cap_"{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >="__value_"^{vector<double, std::__1::allocator<double> >}}}"strokeBoundsValidity"{vector<bool, std::__1::allocator<bool> >="__begin_"^Q"__size_"Q"__cap_alloc_"{__compressed_pair<unsigned long, std::__1::allocator<unsigned long> >="__value_"Q}}"strokes"{vector<std::__1::vector<double, std::__1::allocator<double> >, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >="__begin_"^{vector<double, std::__1::allocator<double> >}"__end_"^{vector<double, std::__1::allocator<double> >}"__end_cap_"{__compressed_pair<std::__1::vector<double, std::__1::allocator<double> > *, std::__1::allocator<std::__1::vector<double, std::__1::allocator<double> > > >="__value_"^{vector<double, std::__1::allocator<double> >}}}"currentStrokeIndex"q"mSize"I"bitmap"{Matrix<double>="_vptr$Matrix"^^?"_data"^d"_w"I"_h"I}"lineHeight"d"sparseBitmap"{vector<int, std::__1::allocator<int> >="__begin_"^i"__end_"^i"__end_cap_"{__compressed_pair<int *, std::__1::allocator<int> >="__value_"^i}}}
@36@0:8q16q24B32
@72@0:8@16@24q32r^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}40r^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}48r^{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}56^@64
v32@0:8@16q24
{CGRect={CGPoint=dd}{CGSize=dd}}48@0:8q16q24@32@40
@64@0:8@16@24@32d40d48@56
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@"NSMutableArray"
@"CHCutPoint"
@40@0:8@16@24@32
@40@0:8q16@24@32
v88@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16^{CGContext=}48{CGRect={CGPoint=dd}{CGSize=dd}}56
B20@0:8i16
i24@0:8@16
@144@0:8@16q24@32{_NSRange=QQ}40^{CGRect={CGPoint=dd}{CGSize=dd}}56{_NSRange=QQ}64{_NSRange=QQ}80B96{_NSRange=QQ}100i116i120B124q128@136
@136@0:8@16q24@32{_NSRange=QQ}40^{CGRect={CGPoint=dd}{CGSize=dd}}56{_NSRange=QQ}64{_NSRange=QQ}80B96{_NSRange=QQ}100i116i120B124q128
@132@0:8@16q24@32{_NSRange=QQ}40^{CGRect={CGPoint=dd}{CGSize=dd}}56{_NSRange=QQ}64{_NSRange=QQ}80B96{_NSRange=QQ}100i116B120q124
@124@0:8@16q24@32{_NSRange=QQ}40^{CGRect={CGPoint=dd}{CGSize=dd}}56{_NSRange=QQ}64{_NSRange=QQ}80{_NSRange=QQ}96i112q116
q24@0:8q16
{CGRect={CGPoint=dd}{CGSize=dd}}24@0:8q16
v40@0:8{_NSRange=QQ}16@?32
v44@0:8{_NSRange=QQ}16B32@?36
@32@0:8{_NSRange=QQ}16
{_NSRange=QQ}24@0:8q16
{_NSRange=QQ}16@0:8
^{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
@"CHTextInputTarget"
{_NSRange="location"Q"length"Q}
^{CGRect={CGPoint=dd}{CGSize=dd}}
v32@0:8{_NSRange=QQ}16
v48@0:8@16{_NSRange=QQ}24^{CGRect={CGPoint=dd}{CGSize=dd}}40
@64@0:8@16@24q32d40d48d56
@184@0:8@16q24q32d40d48d56{CGRect={CGPoint=dd}{CGSize=dd}}64d96{CGRect={CGPoint=dd}{CGSize=dd}}104{CGRect={CGPoint=dd}{CGSize=dd}}136@168d176
@"CHEncodedStrokeIdentifier"
v32@0:8@16d24
@32@0:8@16^{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}{__compressed_pair<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > *, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}}}24
d40@0:8@16q24q32
v40@0:8@16d24@32
v56@0:8@16d24d32d40@48
v40@0:8@16@24@32
q40@0:8@16q24q32
B48@0:8@16d24q32q40
{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}{__compressed_pair<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > *, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}}}16@0:8
{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >="__begin_"^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}"__end_"^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}"__end_cap_"{__compressed_pair<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > *, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >="__value_"^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}}}
B24@0:8q16
@52@0:8@16@24@32B40@44
@56@0:8@16@24@32@40@?48
@40@0:8@16^@24^@32
@"CHRecognitionSessionResult"
{CGAffineTransform=dddddd}112@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16{CGRect={CGPoint=dd}{CGSize=dd}}48{CGRect={CGPoint=dd}{CGSize=dd}}80
v56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16^{CGContext=}48
v80@0:8@16^{CGContext=}24{CGAffineTransform=dddddd}32
v88@0:8@16@24^{CGContext=}32{CGAffineTransform=dddddd}40
@152@0:8@16@24@32q40@48@56@64@72@80@88@96{?=ddddd}104q144
@24@0:8@?16
@32@0:8@16@?24
@48@0:8@16@24{CGSize=dd}32
{?=ddddd}16@0:8
@"<CHStrokeProviderVersion>"
@"CHStrokeClutterFilter"
@"CHStrokeClassificationResult"
@"CHStrokeGroupingResult"
{?="strokeClutterFilteringDuration"d"strokeClassificationDuration"d"groupingDuration"d"recognitionDuration"d"totalDuration"d}
@20@0:8B16
@40@0:8@16^d24^B32
@64@0:8@16@24@32@40@48@56
@"CHTextCorrectionResult"
@52@0:8@16i24@28@36q44
q40@0:8@16{_NSRange=QQ}24
d32@0:8@16^d24
@40@0:8@16@24^q32
@112@0:8@16@24@32{CGRect={CGPoint=dd}{CGSize=dd}}40q72d80@88{CGPoint=dd}96
@120@0:8q16@24@32@40{CGRect={CGPoint=dd}{CGSize=dd}}48q80d88@96{CGPoint=dd}104
@128@0:8q16q24@32@40@48{CGRect={CGPoint=dd}{CGSize=dd}}56q88d96@104{CGPoint=dd}112
{CGVector=dd}16@0:8
@112@0:8@16@24@32@40{CGRect={CGPoint=dd}{CGSize=dd}}48q80d88{CGPoint=dd}96
r^{CGPath=}32@0:8@16@24
{CGPoint=dd}16@0:8
{CGPoint="x"d"y"d}
@56@0:8@16@24@32@40q48
@52@0:8@16@24@32@40I48
@56@0:8@16@24@32@40@48
@"CHTextInputQuery"
@56@0:8@16{CGRect={CGPoint=dd}{CGSize=dd}}24
@168@0:8@16@24@32{CGRect={CGPoint=dd}{CGSize=dd}}40@72@80{CGVector=dd}88{CGVector=dd}104@120r^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}128@136d144{CGPoint=dd}152
@176@0:8q16@24@32@40{CGRect={CGPoint=dd}{CGSize=dd}}48@80@88{CGVector=dd}96{CGVector=dd}112@128r^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}136@144d152{CGPoint=dd}160
@184@0:8q16q24@32@40@48{CGRect={CGPoint=dd}{CGSize=dd}}56@88@96{CGVector=dd}104{CGVector=dd}120@136r^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}144@152d160{CGPoint=dd}168
@176@0:8@16@24@32@40{CGRect={CGPoint=dd}{CGSize=dd}}48@80{CGVector=dd}88{CGVector=dd}104@120r^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}128@136d144q152{CGPoint=dd}160
^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}16@0:8
{CGVector=dd}24@0:8q16
^{CGPath=}32@0:8@16@24
{CGVector="dx"d"dy"d}
{vector<CGVector, std::__1::allocator<CGVector> >="__begin_"^{CGVector}"__end_"^{CGVector}"__end_cap_"{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >="__value_"^{CGVector}}}
@108@0:8@16d24@32@40@48@56@64@72@80@88@96B104
@40@0:8@16d24d32
@120@0:8@16d24d32{CGPoint=dd}40i56{CGPoint=dd}60i76{CGPoint=dd}80{CGPoint=dd}96@112
@112@0:8@16d24d32{CGPoint=dd}40i56{CGPoint=dd}60i76{CGPoint=dd}80{CGPoint=dd}96
@88@0:8@16d24d32{CGPoint=dd}40{CGSize=dd}56{CGPoint=dd}72
@104@0:8@16d24d32{CGPoint=dd}40{CGPoint=dd}56{CGPoint=dd}72{CGPoint=dd}88
@88@0:8@16d24d32{CGPoint=dd}40{CGPoint=dd}56{CGPoint=dd}72
@72@0:8@16d24d32{CGPoint=dd}40{CGSize=dd}56
@96@0:8@16d24d32{CGPoint=dd}40{CGSize=dd}56{CGPoint=dd}72d88
^{CGColor=}32@0:8@16@24
v48@0:8@16@24@32@?40
B80@0:8@16{?=qqq}24@48q56@64^@72
B80@0:8@16{?=qqq}24@48@56q64^q72
B52@0:8@16@24q32B40^q44
@"CHRecognitionSession"
@"<CHVisualizationDelegate>"
v32@0:816
@"CHPointFIFO"
@36@0:8@16Q24f32
@32@0:8@16Q24
v20@0:8f16
{vector<float __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^^{__compressed_pair<float * __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^}}16@0:8
v40@0:8{vector<float __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^^{__compressed_pair<float * __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >=^}}16
{vector<float __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >="__begin_"^"__end_"^"__end_cap_"{__compressed_pair<float * __attribute__((ext_vector_type(4))), std::__1::allocator<float __attribute__((ext_vector_type(4)))> >="__value_"^}}
68@0:8163248f64
v56@0:8{CGSize=dd}16{CGSize=dd}32d48
@?16@0:8
v24@0:8@?16
^{CGPath=}16@0:8
v24@0:8^{CGPath=}16
16@0:8
^{CGPath=}
@"<CHPointFIFODrawingTarget>"
v64@0:8@16{CGRect={CGPoint=dd}{CGSize=dd}}24^{CGContext=}56
{_NSRange=QQ}56@0:8{_NSRange=QQ}16q32@40@48
v56@0:8@16{_NSRange=QQ}24^B40^B48
{_NSRange=QQ}40@0:8q16@24@32
q64@0:8{CGPoint=dd}16@32^{CGRect={CGPoint=dd}{CGSize=dd}}40{_NSRange=QQ}48
B40@0:8@16@24q32
B40@0:8@16@24^B32
B40@0:8@16@24^q32
@68@0:8q16@24@32@40@48@56B64
v32@0:8^{_NSRange=QQ}16^B24
{_NSRange=QQ}32@0:8{_NSRange=QQ}16
{_NSRange=QQ}44@0:8{_NSRange=QQ}16B32^B36
@"CHTextInputTargetContentInfo"
@"<CHStroke>"
@64@0:8{CGPoint=dd}16@32@40@48@56
@48@0:8@16{CVNLPTextDecodingPruningPolicy=qBfI}24
@72@0:8@16{CGSize=dd}24{CGPoint=dd}40@56^{vector<long, std::__1::allocator<long> >=^q^q{__compressed_pair<long *, std::__1::allocator<long> >=^q}}64
@48@0:8@16@24d32^@40
@64@0:8@16@24d32{CGPoint=dd}40^@56
^{CHCodeMap=*Q^II}16@0:8
{CVNLPTextDecodingPruningPolicy=qBfI}16@0:8
^{CHCodeMap=*Q^II}
@"NSOrderedSet"
{CVNLPTextDecodingPruningPolicy="strategy"q"shouldSort"B"threshold"f"maxNumberOfCandidates"I}
{pair<double, double>=dd}32@0:8@16@24
q40@0:8@16@24^q32
@48@0:8@16@24@32q40
@40@0:8@16@24d32
@64@0:8@16@24@32@40q48q56
@56@0:8@16@24@32q40q48
@40@0:8{?=qqq}16
@44@0:8@16{_NSRange=QQ}24B40
@64@0:8@16{_NSRange=QQ}24B40B44^d48@?56
B32@0:8@16^B24
d28@0:8@16i24
d36@0:8@16@24i32
d24@0:8d16
v48@0:8@16{_NSRange=QQ}24@?40
@40@0:8@16^{_LXLexicon=}24q32
@40@0:8@16@24^v32
v28@0:8B16B20B24
Q20@0:8S16
d24@0:8S16S20
B28@0:8@16B24
@36@0:8@16B24@28
@"AppleSpell"
@"CHSpellCheckerErrorModel"
@40@0:8^{CHCanvasHeatmap=Q{unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > >={__hash_table<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordHash, true>, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordEqual, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordEqual, true> >=f}}}{unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> >={__hash_table<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long, void *> > >={__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long> >=f}}}{unordered_map<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> >, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > > > >={__hash_table<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordHash, true>, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordEqual, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > > > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordEqual, true> >=f}}}Q{unordered_map<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > >, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > > > >={__hash_table<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::__unordered_map_hasher<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::hash<unsigned long>, true>, std::__1::__unordered_map_equal<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::equal_to<unsigned long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > > > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::hash<unsigned long>, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::equal_to<unsigned long>, true> >=f}}}}16@24@32
@40@0:8@16@24^@32
@24@0:8^{CGRect={CGPoint=dd}{CGSize=dd}}16
^{CHCanvasHeatmap=Q{unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > >={__hash_table<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordHash, true>, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordEqual, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, unsigned long>, GridCoordEqual, true> >=f}}}{unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> >={__hash_table<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long, void *> > >={__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>=^{__hash_node_base<std::__1::__hash_node<unsigned long, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<unsigned long> >=Q}{__compressed_pair<float, std::__1::equal_to<unsigned long> >=f}}}{unordered_map<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> >, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > > > >={__hash_table<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordHash, true>, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordEqual, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > > > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordHash, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::pair<long, long>, std::__1::__hash_value_type<std::__1::pair<long, long>, std::__1::unordered_set<unsigned long, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<unsigned long> > >, GridCoordEqual, true> >=f}}}Q{unordered_map<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > >, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > > > >={__hash_table<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::__unordered_map_hasher<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::hash<unsigned long>, true>, std::__1::__unordered_map_equal<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::equal_to<unsigned long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > > > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::hash<unsigned long>, true> >=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned long, std::__1::__hash_value_type<unsigned long, std::__1::unordered_map<std::__1::pair<long, long>, unsigned long, GridCoordHash, GridCoordEqual, std::__1::allocator<std::__1::pair<const std::__1::pair<long, long>, unsigned long> > > >, std::__1::equal_to<unsigned long>, true> >=f}}}}
@72@0:8@16d24{CGSize=dd}32d48^d56^{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=}64
{vector<float, std::__1::allocator<float> >=^f^f{__compressed_pair<float *, std::__1::allocator<float> >=^f}}48@0:8@16@24d32^@40
B96@0:8@16^{vector<float, std::__1::allocator<float> >=^f^f{__compressed_pair<float *, std::__1::allocator<float> >=^f}}24{_NSRange=QQ}32@48@56^{vector<std::__1::reference_wrapper<std::__1::vector<double, std::__1::allocator<double> > >, std::__1::allocator<std::__1::reference_wrapper<std::__1::vector<double, std::__1::allocator<double> > > > >=^{reference_wrapper<std::__1::vector<double, std::__1::allocator<double> > >}^{reference_wrapper<std::__1::vector<double, std::__1::allocator<double> > >}{__compressed_pair<std::__1::reference_wrapper<std::__1::vector<double, std::__1::allocator<double> > > *, std::__1::allocator<std::__1::reference_wrapper<std::__1::vector<double, std::__1::allocator<double> > > > >=^{reference_wrapper<std::__1::vector<double, std::__1::allocator<double> > >}}}64@?72^@80@?88
^{MontrealNeuralNetwork=}16@0:8
^{MontrealNeuralNetwork=}
@"MLModel"
B64@0:8@16{CGSize=dd}24^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}40^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}48^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}56
{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}24@0:8r^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}16
@48@0:8@16{CGSize=dd}24r^{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}40
{vector<CHCutpointCandidate, std::__1::allocator<CHCutpointCandidate> >=^{CHCutpointCandidate}^{CHCutpointCandidate}{__compressed_pair<CHCutpointCandidate *, std::__1::allocator<CHCutpointCandidate> >=^{CHCutpointCandidate}}}32@0:8^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}16@24
@48@0:8^{vector<CHCutpointCandidate, std::__1::allocator<CHCutpointCandidate> >=^{CHCutpointCandidate}^{CHCutpointCandidate}{__compressed_pair<CHCutpointCandidate *, std::__1::allocator<CHCutpointCandidate> >=^{CHCutpointCandidate}}}16^{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}{__compressed_pair<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > *, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}}}24@32r^{set<long, std::__1::less<long>, std::__1::allocator<long> >={__tree<long, std::__1::less<long>, std::__1::allocator<long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<long> >=Q}}}40
@48@0:8@16d24d32^{vector<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}{__compressed_pair<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > *, std::__1::allocator<std::__1::map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > > > >=^{map<long, long, std::__1::less<long>, std::__1::allocator<std::__1::pair<const long, long> > >}}}40
B40@0:8@16^{vector<double, std::__1::allocator<double> >=^d^d{__compressed_pair<double *, std::__1::allocator<double> >=^d}}24@?32
@40@0:8@16@24q32
@128@0:8q16@24@32@40{CGRect={CGPoint=dd}{CGSize=dd}}48q80d88@96{CGPoint=dd}104@120
@136@0:8q16q24@32@40@48{CGRect={CGPoint=dd}{CGSize=dd}}56q88d96@104{CGPoint=dd}112@128
@44@0:8@16@24@32B40
d40@0:8@16@24@32
@72@0:8@16{CGRect={CGPoint=dd}{CGSize=dd}}24^d56^d64
@88@0:8@16@24@32{CGRect={CGPoint=dd}{CGSize=dd}}40d72d80
@96@0:8@16@24@32@40{CGRect={CGPoint=dd}{CGSize=dd}}48d80d88
@60@0:8@16@24@32@40I48q52
@88@0:8@16@24@32@40I48q52B60@64q72@?80
@96@0:8@16@24@32@40I48q52B60@64q72@80@?88
B32@0:8q16q24
@60@0:8@16@24B32@36q44^@52
@"<CHRecognitionSessionTaskDelegate>"
@"CHStrokeClassificationModel"
@"<CHTextInputQueryTargetDataSource>"
v32@0:8@16@?24
@"DDScannerServiceConfiguration"
@40@0:8@16@24^{CGPath=}32
r^{CGPath=}16@0:8
r^{CGPath=}
@"DDScannerResult"
@88@0:8@16{CGRect={CGPoint=dd}{CGSize=dd}}24d56d64r^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}72d80
^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16@0:8
{vector<CGPoint, std::__1::allocator<CGPoint> >="__begin_"^{CGPoint}"__end_"^{CGPoint}"__end_cap_"{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >="__value_"^{CGPoint}}}
{CGAffineTransform=dddddd}16@0:8
v32@0:8{CGVector=dd}16
@"CHSubstroke"
@48@0:8@16^{CGColor=}24^{__CTFont=}32^{__CTParagraphStyle=}40
^{CGPoint=dd}64@0:8@16{CHLineSegment={CGPoint=dd}{CGPoint=dd}}24^q56
@32@0:8^{CGPoint=dd}16q24
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
q48@0:8{CHLineSegment={CGPoint=dd}{CGPoint=dd}}16
^{CGPoint=dd}16@0:8
^{CGPoint=dd}
v40@0:8@16@24@?32
v32@0:8@"CHRemoteRecognitionRequest"16@?<v@?@"CHTokenizedTextResult"@"NSError">24
v40@0:8@"CHTokenizedTextResult"16@"CHRemoteRecognitionRequest"24@?<v@?@"NSArray"@"NSArray"@"NSError">32
@48@0:8@16@24^@32^@40
@"NSXPCConnection"
#24@0:8@16
^{CGColor=}24@0:8q16
v56@0:8@16{CGRect={CGPoint=dd}{CGSize=dd}}24
v56@0:8@"CHVisualization"16{CGRect={CGPoint=dd}{CGSize=dd}}24
v24@0:8@"CHVisualization"16
q24@0:8@"CHStrokeGroup"16
v24@0:8@"CHRecognitionSession"16
v28@0:8B16@20
@"<CHVisualizationManagerDelegate>"
@"NSMutableSet"
@40@0:8@16@?24@?32
@"<CHQueryDelegate>"
@40@0:8{_NSRange=QQ}16^@32
@68@0:8@16{_NSRange=QQ}24@40q48B56@60
i20@0:8i16
v40@0:8@16^Q24^Q32
Q24@0:8@16
B28@0:8Q16i24
@48@0:8i16@20i28i32B36B40B44
r^{_LXLexicon=}24@0:8^@16
^v24@0:8^{map<unsigned int, unsigned int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned int> > >={__tree<std::__1::__value_type<unsigned int, unsigned int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned int>, std::__1::less<unsigned int>, true> >=Q}}}16
@80@0:8^{_LXLexicon=}16^{_LXLexicon=}24^{_LXLexicon=}32^{_LXLexicon=}40@48@56@64^v72
@40@0:8^{_LXLexicon=}16^{_LXLexicon=}24^v32
@32@0:8q16q24
@"<CHRecognizing>"24@0:8@"NSLocale"16
@"CHTextCorrectionRecognizer"24@0:8@"NSLocale"16
@48@0:8q16B24B28@32@?40
B32@0:8@16^@24
@"CHRecognitionSessionVersion"
@"<CHRecognitionSessionDataSource>"
@44@0:8@16q24B32q36
@32@0:8q16@24
@64@0:8@16@24{_NSRange=QQ}32@48^{_NSRange=QQ}56
{_NSRange=QQ}40@0:8@16{_NSRange=QQ}24
@36@0:8@16B24q28
@96@0:8@16@24@32@40{CGRect={CGPoint=dd}{CGSize=dd}}48d80@88
@96@0:8@16@24@32{CGRect={CGPoint=dd}{CGSize=dd}}40d72{_NSRange=QQ}80
Q32@0:8@16@24
q112@0:8@16{CGRect={CGPoint=dd}{CGSize=dd}}24{CGRect={CGPoint=dd}{CGSize=dd}}56{_NSRange=QQ}88@104
@40@0:8@16{_NSRange=QQ}24
@"<CHRecognizing>"
@"CHRecognizer"
@"CHCornerDetector"
Q20@0:8I16
{map<unsigned int, unsigned long, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned long> > >={__tree<std::__1::__value_type<unsigned int, unsigned long>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true> >=Q}}}16@0:8
v40@0:8{map<unsigned int, unsigned long, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned long> > >={__tree<std::__1::__value_type<unsigned int, unsigned long>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned long> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned long>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true> >=Q}}}16
{map<unsigned int, int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, int> > >={__tree<std::__1::__value_type<unsigned int, int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true> >=Q}}}16@0:8
v40@0:8{map<unsigned int, int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, int> > >={__tree<std::__1::__value_type<unsigned int, int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, int> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, int>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true> >=Q}}}16
{map<unsigned int, unsigned long, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, unsigned long> > >="__tree_"{__tree<std::__1::__value_type<unsigned int, unsigned long>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, unsigned long> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, unsigned long>, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, unsigned long>, std::__1::less<unsigned int>, true> >="__value_"Q}}}
{map<unsigned int, int, std::__1::less<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, int> > >="__tree_"{__tree<std::__1::__value_type<unsigned int, int>, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true>, std::__1::allocator<std::__1::__value_type<unsigned int, int> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned int, int>, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned int, std::__1::__value_type<unsigned int, int>, std::__1::less<unsigned int>, true> >="__value_"Q}}}
{vector<CGRect, std::__1::allocator<CGRect> >=^{CGRect}^{CGRect}{__compressed_pair<CGRect *, std::__1::allocator<CGRect> >=^{CGRect}}}48@0:8@16{CGPoint=dd}24d40
@52@0:8@16q24@32B40@44
v76@0:8@16@24@32@40@48@56B64@?68
{CGRect={CGPoint=dd}{CGSize=dd}}64@0:8@16r^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}24{CGVector=dd}32^@48^{vector<std::__1::vector<CGPoint, std::__1::allocator<CGPoint> >, std::__1::allocator<std::__1::vector<CGPoint, std::__1::allocator<CGPoint> > > >=^{vector<CGPoint, std::__1::allocator<CGPoint> >}^{vector<CGPoint, std::__1::allocator<CGPoint> >}{__compressed_pair<std::__1::vector<CGPoint, std::__1::allocator<CGPoint> > *, std::__1::allocator<std::__1::vector<CGPoint, std::__1::allocator<CGPoint> > > >=^{vector<CGPoint, std::__1::allocator<CGPoint> >}}}56
@40@0:8@16{CGVector=dd}24
@32@0:8@16^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}24
v64@0:8^d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56
v56@0:8^d16^@24@32@40@48
v64@0:8^d16^@24@32@40@48q56
q40@0:8@16@24@32
{CGVector=dd}64@0:8@16@24{CGVector=dd}32@48@56
v40@0:8^@16^{CGVector=dd}24^{CGVector=dd}32
v32@0:8@16^{CGVector=dd}24
v28@0:8@16B24
v24@0:8^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}16
{CGVector=dd}32@0:8{CGVector=dd}16
{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}44@0:8r^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16@24q32B40
B32@0:8@16^{CGVector=dd}24
d72@0:8@16@24r^{vector<CGVector, std::__1::allocator<CGVector> >=^{CGVector}^{CGVector}{__compressed_pair<CGVector *, std::__1::allocator<CGVector> >=^{CGVector}}}32{CGVector=dd}40{CGVector=dd}56
v36@0:8@16@24B32
d56@0:8r^{vector<CGPoint, std::__1::allocator<CGPoint> >=^{CGPoint}^{CGPoint}{__compressed_pair<CGPoint *, std::__1::allocator<CGPoint> >=^{CGPoint}}}16{CGRect={CGPoint=dd}{CGSize=dd}}24
@36@0:8@16@24B32
B32@0:8q16@24
q32@0:8d16q24
f24@0:8q16
{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}40@0:8^{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}16i24f28@?32
@32@0:8^{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}16@24
@44@0:8@16i24d28@?36
{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}24@0:8^{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}16
{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}28@0:8@16B24
v40@0:8^{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}16@24@32
@64@0:8@16@24@32{CGPoint=dd}40q56
@56@0:8@16^{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}24@32q40@48
^{CGPath=}40@0:8@16^{CGPoint=dd}24@32
v56@0:8^{CGRect={CGPoint=dd}{CGSize=dd}}16^d24@32q40@48
{CGAffineTransform=dddddd}64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16q48@56
{CGRect={CGPoint=dd}{CGSize=dd}}32@0:8{CGPoint=dd}16
@"CHRecognitionSessionIndexableContent"
@40@0:8r^{CHFastGroupingCluster={map<unsigned long, CGPoint, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, CGPoint> > >={__tree<std::__1::__value_type<unsigned long, CGPoint>, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, CGPoint>, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, CGPoint> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, CGPoint>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, CGPoint>, std::__1::less<unsigned long>, true> >=Q}}}{CGPoint=dd}{set<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >={__tree<unsigned long, std::__1::less<unsigned long>, std::__1::allocator<unsigned long> >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned long, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned long> >=Q}}}}16@24@32
@56@0:8r^{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}16@24@32@40@48
{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}^{CHFastGroupingCluster}{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >=^{CHFastGroupingCluster}}}16@0:8
{vector<CHFastGroupingCluster, std::__1::allocator<CHFastGroupingCluster> >="__begin_"^{CHFastGroupingCluster}"__end_"^{CHFastGroupingCluster}"__end_cap_"{__compressed_pair<CHFastGroupingCluster *, std::__1::allocator<CHFastGroupingCluster> >="__value_"^{CHFastGroupingCluster}}}
@32@0:8Q16@24
v32@0:8Q16Q24
{vector<unsigned long, std::__1::allocator<unsigned long> >="__begin_"^Q"__end_"^Q"__end_cap_"{__compressed_pair<unsigned long *, std::__1::allocator<unsigned long> >="__value_"^Q}}
@32@0:8i16@20B28
@36@0:8q16@24B32
@40@0:8Q16@24@32
B40@0:8@16q24@32
@36@0:8@16@24i32
@"CHMutableTokenizedTextResult"
@32@0:8@?16@24
@80@0:8@16@24@32@40@48@56@64@72
@76@0:8i16@20^{_LXLexicon=}28^{_LXLexicon=}36^{_LXLexicon=}44^{_LXLexicon=}52@60@68
@64@0:8@16B24B28^q32^d40@48@56
B40@0:8@16@24@32
@84@0:8@16B24@28B36B40@44B52q56@64B72@76
r^{_LXLexicon=}16@0:8
v24@0:8r^{_LXLexicon=}16
r^{_LXLexicon=}
@32@0:8@16^v24
@32@0:8@16B24B28
@40@0:8@16q24B32B36
q32@0:8@16q24
