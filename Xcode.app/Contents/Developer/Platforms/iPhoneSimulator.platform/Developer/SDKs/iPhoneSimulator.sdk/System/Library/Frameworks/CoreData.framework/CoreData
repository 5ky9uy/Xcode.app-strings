init
retain
populateMappingsByEntityName
release
dealloc
alloc
entityMappings
countByEnumeratingWithState:objects:count:
sourceEntityName
mappingType
addObject:
name
null
numberWithUnsignedInteger:
dictionaryWithObjectsAndKeys:
exceptionWithName:reason:userInfo:
initWithObjects:forKeys:
initWithArray:
createPeerStoreLocationForPeerID:andStoreName:withUbiquityRootLocation:
createMapOfLocationsForOldManagedObjectModel:andNewManagedObjectModel:inUbiquityPeerStoreLocation:
canLogMessageAtLevel:
count
allKeys
objectForKey:
migrateTransactionLogFromLocation:toLocation:error:
createVersionHashStringForModel:
createBaselineLocation:forStoreName:andModelVersionHash:withUbiquityRootLocation:
migrateBaselineFromLocation:toLocation:error:
fileExistsAtLocation
createTemporaryTransactionLogLocationFromTransactionLogLocation:
initWithTransactionLogLocation:andLocalPeerID:
throttleLogs
moveFileToPermanentLocationWithError:
loadImportMetadataWithError:
loadInsertedObjectsDataWithError:
loadDeletedObjectsDataWithError:
loadUpdatedObjectsDataWithError:
saveSnapshot
storeName
storeSaveSnapshotForStoreName:
transactionDate
setTransactionDate:
transactionNumber
peerStates
peerIDs
setTransactionNumber:peerStates:andPeerIDs:
setTransactionLog:
setSourceStoreSaveSnapshot:
setDestinationStoreSaveSnapshot:
insertedObjects
createDestinationObjectsFromSourceObjects:migrationContext:
updatedObjects
deletedObjects
setInsertedObjects:
setUpdatedObjects:
setDeletedObjects:
setUseTemporaryLogLocation:
writeToDiskWithError:andUpdateFilenameInTransactionEntries:
entityName
destinationEntityName
primaryKey
owningPeerID
initWithStoreName:entityName:primaryKey:andPeerID:
attributeMappings
_propertyTransforms
prerequisiteTransform
replaceMissingValueOnly
valueExpression
expressionType
constantValue
isEqual:
setObject:forKey:
keyPath
destinationStoreSaveSnapshot
entitiesByName
relationshipMappings
objectAtIndex:
class
isKindOfClass:
initWithObjects:count:
initWithCapacity:
sourceGlobalObjectIDFromCompressedID:
createDestinationGlobalObjectIDFromSourceGlobalObjectID:
compressedGlobalObjectIDFromGlobalObjectID:
propertiesByName
isToMany
createDestinationObjectContentFromSourceObjectContent:withEntityMapping:migrationContext:
enumerateKeysAndObjectsUsingBlock:
initWithSourceModel:destinationModel:mappingModel:localPeerID:
migrateTransactionLogsForStoreName:andLocalPeerID:atUbiquityRootLocation:error:
_srcModel
_dstModel
_mappingModel
_localPeerID
_mappingsByEntityName
_removedEntities
_throttleLogs
globalObjectIDFromCompressedObjectID:
transactionLog
sourceStoreSaveSnapshot
_transactionLog
_sourceStoreSaveSnapshot
_destinationStoreSaveSnapshot
createModelFromBaselineModelWithModelVersionHash:peerID:storeName:andUbiquityRootLocation:
initWithDestinationModel:sourceModel:ubiquityRootLocation:localPeerID:
sourceModel
destinationModel
rootLocation
inferredMappingModelForSourceModel:destinationModel:error:
errorWithDomain:code:userInfo:
initWithLocalPeerID:ubiquityRootLocation:forStoreWithName:andManagedObjectModel:
existsInCloud
loadFile:
metadata
_migrateToModelVersionHash:
storeData
stringByAppendingPathComponent:
length
fileSystemRepresentation
numberWithInt:
stringWithCString:encoding:
fileURLWithPath:
URLByAppendingPathComponent:
writeToURL:atomically:
initWithSourceModel:destinationModel:
dictionaryWithObjects:forKeys:count:
migrateStoreFromURL:type:options:withMappingModel:toDestinationURL:destinationType:destinationOptions:error:
gatherContentsFromMigratedBaseline:withStoreFileURL:error:
safeSaveFile:moveToPermanentLocation:error:
makeCurrentBaselineWithError:
defaultManager
stringWithFormat:
removeItemAtPath:error:
initWithDestinationModel:storeName:previousModelVersionHash:ubiquityRootLocation:localPeerID:
migrateTransactionLogs:andBaselineIfNecessaryForStoreName:peerID:error:
_destinationModel
_sourceModel
_rootLocation
initWithRequest:context:sqlCore:
metadataToWrite
initForRequestContext:
faultHandler
hasChangesForWriting
sqlCore
model
persistentStoreRequest
rowCacheForContext:
prepareRows
setException:
rowCache
forgetRowForObjectID:
context
_addObjectIDsUpdatedByTriggers:
removeAllObjects
setConnection:
setResult:
connection
createSetOfObjectIDsUpdatedByTriggers
clearObjectIDsUpdatedByTriggers
rowForObjectID:
request
isWritingRequest
executePrologue
executeEpilogue
executeRequestUsingConnection:
originalRowForObjectID:
setOriginalRow:forObjectID:
savePlan
originalCachedRows
_metadataToWrite
_savePlan
_faultHandler
_objectIDsToPruneTrigger
_originalCachedRows
autorelease
initWithGenerationTokens:
requestType
generationTokens
setGenerationTokens:
description
_generationTokens
initWithName:code:reason:userInfo:
initWithName:reason:userInfo:
copy
userInfo
mutableCopy
addEntriesFromDictionary:
domain
code
exceptionWithName:code:reason:userInfo:
_setDomain:
errorObjectWithUserInfo:
_code
_domain
minimalFormInContext:
minimalFormInContext:ofPredicate:
rightExpression
operatorType
leftExpression
isNSString__
defaultInstance
isNSArray__
isNSSet__
isNSOrderedSet__
isNSDictionary__
valueForKey:
objectID
persistentStore
expressionForConstantValue:
comparisonPredicateModifier
options
predicateWithLeftExpression:rightExpression:modifier:type:options:
array
initWithType:subpredicates:
minimalFormInContext:ofPredicates:
isTemporaryID
predicateOperatorType
allowEvaluation
respondsToSelector:
evaluateWithObject:
dictionaryWithObject:forKey:
predicateOperator
_isForeignObjectExpression:givenContext:
initWithPredicateOperator:leftExpression:rightExpression:
subpredicates
selector
valueForKeyPath:
operand
arguments
_newKeyPathExpressionForString:
initWithOperand:andKeyPath:
arrayWithObject:
initWithExpressionType:operand:selector:argumentArray:
_mapKVCOperatorsToFunctionsInContext:
setValue:forKey:
substringWithRange:
expressionForKeyPath:
initWithObject:
componentsSeparatedByString:
removeLastObject
isEqualToString:
removeObjectAtIndex:
componentsJoinedByString:
expressionForFunction:selectorName:arguments:
expressionForFunction:arguments:
characterAtIndex:
appendString:
containsObject:
substringFromIndex:
initWithObjects:
collection
predicate
variableExpression
initWithExpression:usingIteratorExpression:predicate:
decodeIntegerForKey:
decodeObjectOfClass:forKey:
encodeInteger:forKey:
encodeObject:forKey:
supportsSecureCoding
encodeWithCoder:
initWithCoder:
messageCode
setMessageCode:
messageBody
setMessageBody:
token
setToken:
_messageCode
_messageBody
_token
managedObjectContext
_faultHandler__
retainedFulfillAggregateFaultForObject:andRelationship:withContext:
initWithSource:forRelationship:asFault:
setArray:
copyWithZone:
descriptionWithLocale:
descriptionWithLocale:indent:
willRead
enumerateObjectsWithOptions:usingBlock:
enumerateObjectsAtIndexes:options:usingBlock:
indexOfObjectWithOptions:passingTest:
indexOfObjectAtIndexes:options:passingTest:
indexesOfObjectsWithOptions:passingTest:
indexesOfObjectsAtIndexes:options:passingTest:
objectEnumerator
insertObject:atIndex:
replaceObjectAtIndex:withObject:
getObjects:
accessInstanceVariablesDirectly
allocWithZone:
retainCount
_tryRetain
_isDeallocating
isFault
turnIntoFault
source
relationship
mutableCopyWithZone:
_cd_rc
_realArray
_source
_relationship
_flags
initWithValue:
index
setIndex:
value
setValue:
tableName
setTableName:
_index
_value
_tableName
_isRelationship
deleteRule
_entitysReferenceID
willReadWithContents:
entity
_retainedObjectWithID:optionalHandler:withInlineStorage:
unionSet:
minusSet:
_commitPhotoshoperyForRelationshipAtIndex:newValue:
setSet:
member:
removeObject:
objectsWithOptions:passingTest:
allObjects
anyObject
intersectsSet:
isEqualToSet:
isSubsetOfSet:
makeObjectsPerformSelector:
makeObjectsPerformSelector:withObject:
addObjectsFromArray:
intersectSet:
initWithSource:destinations:forRelationship:inContext:
_shouldProcessKVOChange
_isIdenticalFault:
classForCoder
replacementObjectForCoder:
classForArchiver
_realSet
_createMutationMethodsForClass:forKey:
_addObjectMethod
_removeObjectMethod
_addMethod
_removeMethod
_intersectMethod
_setMethod
migrationDebugLevel
setMigrationDebugLevel:
_resetCaches
renamingIdentifier
initWithDomain:code:userInfo:
newEntityMappingWithSource:destination:
removeObjectForKey:
inferPropertyMappingsForEntityMapping:
setEntityMappings:
expressionForVariable:
arrayWithObjects:
expressionForFetch:context:countOnly:
setSourceExpression:
allValues
isTransient
_propertyType
drain
newInferredPropertyMappingWithSourceAttribute:destinationAttribute:
newInferredPropertyMappingWithSourceRelationship:destinationRelationship:
setAttributeMappings:
setRelationshipMappings:
setUserInfo:
setSourceEntityName:
versionHash
setSourceEntityVersionHash:
setName:
setDestinationEntityName:
setDestinationEntityVersionHash:
setMappingType:
isOptional
defaultValue
initWithPropertyName:valueExpression:
attributeType
_canTransformSourceAttributeType:toDestinationAttributeType:
storesBinaryDataExternally
expressionForEvaluatedObject
setPrerequisiteTransform:
setReplaceMissingValueOnly:
setValueExpression:
_setPropertyTransforms:
numberWithBool:
initWithObjectsAndKeys:
_setTransformValidations:
boolValue
minCount
newInferredMappingModel:
_currentEntityMapping
_error
initWithFormat:
initialize
createPredicateForFetchFromPredicate:withContext:
_hasIDMappings
acceptVisitor:flags:
initWithContext:
modifier
isNegation
initWithOperatorType:modifier:negate:options:
initWithOperatorType:modifier:options:
setContext:
setPredicateOperator:
createPredicateForFetchFromPredicate:
visitPredicate:
visitPredicateExpression:
_context
_mappedForParentStoreID:
replacementValueForValue:
initWithSet:copyItems:
willChangeValueForKey:withSetMutation:usingObjects:
didChangeValueForKey:withSetMutation:usingObjects:
initWithContainer:key:mutableSet:
_container
_key
_mutableSet
compare:options:range:
_caseInsensitiveNumericCompare:
_disableAutomaticTerminationWithoutSettingRelaunchable:
_enableAutomaticTerminationWithoutSettingRelaunchable:
self
setURL:forPersistentStore:
_setURL:forPersistentStore:withCoordinator:
attributeTypeForXMLInfo:
numberWithUnsignedInt:
decodeObjectForKey:
unsignedIntValue
clearSectionObjectsCache
_sections
indexOfObject:
_fetchedObjects
fetchedObjects
subarrayWithRange:
indexOfObject:inRange:
indexTitle
numberOfObjects
objects
initWithController:name:indexTitle:sectionOffset:
setNumberOfObjects:
setSectionOffset:
sectionNumber
setController:
sectionOffset
oldSectionNumber
setOldSectionNumber:
_controller
_name
_indexTitle
_sectionOffset
_numberOfObjects
_oldSectionNumber
_sectionObjects
initWithContainer:key:mutableSet:mutationMethods:
_mutationMethods
appendSQL:
sqlEntity
foreignKeyColumns
foreignEntityKeyColumns
foreignOrderKeyColumns
attributeColumns
subentityKey
optLockKey
_startSQL:
columnName
isConstrained
pk64
sqlType
initWithInt64:sqlType:
addBindVariable:
sqlEntityID
initWithUnsignedInt:sqlType:
optLock
slot
foreignKeyForSlot:
foreignEntityKeyForSlot:
foreignOrderKeyForSlot:
attributeValueForSlot:
attributeDescription
initWithValue:sqlType:attributeDescription:
isReflexive
correlationTableName
inverseColumnName
inverseOrderColumnName
orderColumnName
appendWhereClause:
newUpdateMaskForConstrainedValues
setOptLock:
buildWhereClauseForRow:optLock:
appendWhereClauseToSQL
initWithStatement:forAdapter:
sqlString
prepareInsertStatementWithRow:
prepareInsertStatementForRelationship:
prepareMasterReorderStatementForRelationship:
prepareMasterReorderStatementPart2ForRelationship:
prepareReorderStatementForRelationship:
prepareDeleteStatementForRelationship:
prepareConstrainedValuesUpdateStatementWithRow:
prepareUpdateStatementWithRow:originalRow:withMask:
prepareDeleteStatementWithRow:
_statement
_adapter
_sqlString
_whereClause
_selectList
clearCaches
retainedObject
clearCaches:
performAndWait:
initForConnection:
limitedStatement
setLimitedStatement:
unlimitedStatement
setUnlimitedStatement:
_limitedStatement
_unlimitedStatement
_connection
substitutionBindVariableOrder
setSubstitutionBindVariableOrder:
substitutionBindIntarrayOrder
setSubstitutionBindIntarrayOrder:
_substVarBindOrdering
_substIntarrayBindOrdering
initWithObjects:count:andFlags:
initWithObjects:count:andFlags:andContext:
concurrencyType
newArrayFromObjectIDs
indexOfObjectIdenticalTo:inRange:
methodForSelector:
_registerAsyncReferenceCallback
raise:format:
_objectsPointer
arrayFromObjectIDs
indexOfObjectIdenticalTo:
indexOfManagedObjectForObjectID:
managedObjectIDAtIndex:
getObjects:range:
_setShouldRelease:
_setShouldUseExtendedRelease:
_count
_array
_weakContext
setEntity:
setFetchBatchSize:
setIncludesPendingChanges:
setSortDescriptors:
setFetchOffset:
setHavingPredicate:
setPropertiesToGroupBy:
affectedStores
setAffectedStores:
resultType
setResultType:
includesSubentities
setIncludesSubentities:
includesPropertyValues
setIncludesPropertyValues:
returnsObjectsAsFaults
setReturnsObjectsAsFaults:
relationshipKeyPathsForPrefetching
setRelationshipKeyPathsForPrefetching:
returnsDistinctResults
setReturnsDistinctResults:
propertiesToFetch
setPropertiesToFetch:
shouldRefreshRefetchedObjects
setShouldRefreshRefetchedObjects:
_disablePersistentStoreResultCaching
_setDisablePersistentStoreResultCaching:
initWithLeftExpression:rightExpression:modifier:type:options:
setPredicate:
fetchBatchSize
setFetchLimit:
initWithPFArray:inRange:
_newSubArrayInRange:asMutable:
_internalDealloc
_processReferenceQueue:
rangeCount
rangeAtIndex:
retainedObjectAtIndex:
indexSet
addIndex:
initWithIndexesInRange:
_turnAllBatchesIntoObjects
sortedArrayUsingFunction:context:
sortedArrayUsingFunction:context:hint:
sortedArrayUsingSelector:
sortedArrayUsingComparator:
sortedArrayWithOptions:usingComparator:
filteredArrayUsingPredicate:
sortedArrayUsingDescriptors:
arrayWithObjects:count:
initWithPFArray:andRequest:andContext:
isEqualToArray:
_turnAllBatchesIntoFaults
objectsAtIndexes:
objectAtIndexedSubscript:
_pinnedObjectAtIndex:
_entryFlags
_moc
_request
_batchSize
_LRUBatches
finalize
_rehash
initWithPFArray:
_editCount
_offset
_limit
_originalArray
_updatedObjectsArray
_indicesVeneer
_replaceObject:atIndex:
_values
_sourceData
isEqualToOrderedSet:
initWithArray:andContext:
_underlyingArray
_weakmoc
setSubstitutionVariables:
executeFetchRequest:error:
objectWithID:
stringValue
valueWithBytes:objCType:
value:withObjCType:
initWithBytes:objCType:
getValue:
objCType
charValue
unsignedCharValue
shortValue
unsignedShortValue
intValue
longValue
unsignedLongValue
longLongValue
unsignedLongLongValue
floatValue
doubleValue
integerValue
unsignedIntegerValue
parseTriggerPredicateError:
validatePredicate:error:
isManyToMany
appendFormat:
inverseRelationship
isToOne
predicateWithFormat:
validateComparisonPredicate:error:
compoundPredicateType
initWithOperatorType:
symbol
isSupportedOperatorType:
relationshipNamed:
destinationEntity
attributeNamed:
inverseOperatorSymbolForOperator:
_setHasAttributesMonitoredByTriggers:
_setHasAttributesBackedByTriggers:
_setIsBackedByTrigger:
addKeyForTriggerOnRelationship:
initWithPredicateString:onAttribute:onEntity:
toManyDecrementWhenClause
toManyIncrementWhenClause
toManyInnerFetchWhereClause
ofClause
oldMatchingClause
newMatchingClause
columnChangedClause
bulkChangeStrings
sqlDropStrings
prepareForSQLGeneration:
createSQLStrings:
attribute
destinationAttributes
predicateString
_predicate
_predicateString
_entity
_attribute
_destinationEntity
_destinationAttributes
_mToManyInnerFetchWhereClause
_mToManyDecrementWhenClause
_mToManyIncrementWhenClause
_mOfClause
_mOldMatchingClause
_mNewMatchingClause
_mColumnChangedClause
_mSqlDropStrings
_mBulkChangeStrings
_dispose
initWithWeaksReferences:
setForUseWithModel:
getAllObjects:
setCapacityHint:forSlot:
clearTemporaryIDs
_slotLimit
_objectsByTemporaryID
_objectsByPermanentObjectID
_objectsBy64bitPKID
_capacitiesFor64bitPKMappings
initWithFormat:arguments:
UTF8String
getNumActiveProcessors
getProcessorSpeed
getPhysicalMemory
initWithFunction:withArgument:andPriority:
_task
lock
condition
isFinishedFlag
bundleForClass:
mainBundle
bundleWithPath:
hasPrefix:
hasSuffix:
rangeOfString:
rangeOfString:options:
localizedStringForKey:value:table:
_referenceData64
identifier
numberWithUnsignedLongLong:
persistentStoreForIdentifier:
managedObjectModel
objectIDFactoryForEntity:
initWithPK64:
initWithBytes:length:
data
initWithInteger:
_uniquenessConstraints
_rootEntity
_rootEntityGroupsForObjects:passingBlock:
dictionary
getCString:maxLength:encoding:
processInfo
hasExternalReferenceContent
_externalReferenceLocation
_originalData
stringWithUTF8String:
_safeguardLocation
preferredProtectionLevel
_bytesLengthForExternalReference
getBytes:range:
doCleanupOnDealloc
_safeguardLocationString
initWithContentsOfFile:options:error:
externalReferenceLocationString
fileExistsAtPath:
bytes
initWithBytesNoCopy:length:encoding:freeWhenDone:
valueTransformerName
valueTransformerForName:
transformedValue:
reverseTransformedValue:
firstObject
initWithOrderedSet:
newCollection:fromCollection:byAddingItems:
_newCollectionFromCollection:forParentContext:andClass:
newOrderedSetFromCollection:byRemovingItems:
newMutableOrderedSetFromCollection:
newOrderedSetFromCollection:byAddingItems:
indexSetWithIndexesInRange:
replaceObjectsAtIndexes:withObjects:
removeObjectsAtIndexes:
insertObjects:atIndexes:
createDictionaryPartitioningObjectsByRootEntity:
performBlockAndWait:
_createDictionaryPartitioningObjects:intoHierarchies:
superentity
isUbiquitousItemAtURL:
getResourceValue:forKey:error:
_generateObjectIDMaptableForArray:withMapping:andEntries:
_newObjectIDsArrayWithMapping:andEntries:andCoordinator:
_frameworkHash
_getPFBundleVersionNumber
_groupObjectsByRootEntity:
_coalescedPrefetchKeypaths:
_generateHashForString:
_getUUID
_doNameAndTypeCheck:
convertCString:toUnsignedInt64:withBase:
valueForProcessArgument:
writePFExternalReferenceDataToInterimFile:
moveInterimFileToPermanentLocation:
readExternalReferenceDataFromFile:
readBytesForExternalReferenceData:intoBuffer:range:
newMappedDataForExternalReference:
lengthOfFileAtExternalReferenceLocation:
deleteFileForPFExternalReferenceData:
createExternalReferenceLinkFromPath:toPath:protectionLevel:
cleanupExternalReferenceLink:
attemptToUpdatePermissionsForFileAtPath:toLevel:
setOrRemoveValue:forKey:inDictionary:
_createNicksBase64EncodedStringFromData:
decodeValue:forTransformableAttribute:
encodeObjectValue:forTransformableAttribute:
getIndexes:fromCollection:forObjectsInCollection:
newOrderedSetFromCollection:
anyObjectFromCollection:
newArrayOfObjectIDsFromCollection:
newSetOfObjectIDsFromCollection:
newOrderedSetOfObjectIDsFromCollection:
_objectsInOrderedCollection:formSubstringInOrderedCollection:
newOrderedSetFromCollection:byInsertingItems:atIndex:
newSetFromCollection:byAddingItems:
newMutableSetFromCollection:byRemovingItems:
newMutableSetFromCollection:byIntersectingWithCollection:
newMutableArrayFromCollection:byRemovingItems:
newMutableArrayFromCollection:forParentContext:
newMutableSetFromCollection:forParentContext:
newMutableOrderedSetFromCollection:forParentContext:
_replaceBaseline:inOrderedSet:withOrderedSet:
fetchHeterogeneousCollectionByObjectIDs:intoContext:
createDictionaryPartitioningObjectsByEntity:
createDictionaryPartitioningObjectsIntoHierarchies:
isUbiquitousURLUploaded:error:
isUbiquitousURLDownloaded:error:
_groupObjectsWithUniqueAttributesByRootEntity:
weakReferenceWithObject:
object
hash
address
_object
_objectAddress
unlock
tryLock
_lock
_owner
_init__
enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:
path
fileReferenceURL
_deleteIfNecessary:
stringByDeletingLastPathComponent
numberWithInteger:
_doCleanupForDir:exceptURLs:
externalDataReferencesDirectory
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
registerURLForCleanup:
lastPathComponent
contentsOfDirectoryAtPath:error:
temporaryLinksDirectoryForStore:
doCleanupForURL:
_storeLinksDirs
_filesToCleanUp
compare:
appendBytes:length:
getCharacters:
initWithCharactersNoCopy:length:freeWhenDone:
getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
appendData:
initWithBytesNoCopy:length:freeWhenDone:
indexForKey:
isNSNumber__
_underlyingProperty
keys
_setupForKeys:count:table:inData:
initWithUTF8String:
getCharacters:range:
cString
_fastCStringContents:
getCString:
cStringLength
_length
_retainedURIString
maximumLengthOfBytesUsingEncoding:
initWithPersistentStoreCoordinator:configurationName:URL:options:
persistentStoreCoordinator
configurationName
entitiesForConfiguration:
_registerCacheNode:
setWithArray:
_referenceData
setMetadata:
_updatedMetadataWithSeed:includeVersioning:
metadataForPersistentStoreWithURL:error:
save:
load:
addCacheNodes:
cacheNodes
willRemoveCacheNodes:
cacheNodeForObjectID:
newCacheNodeForManagedObject:
updateCacheNode:fromManagedObject:
newReferenceObjectForManagedObject:
objectIDForEntity:referenceObject:
referenceObjectForObjectID:
_rawMetadata__
_nodeCache
_entityCache
_storeMetadata
_nextReference
_reserved4
_reserved5
_insertNodeIntoMainCache:
_insertNodeIntoEntityCache:
executeFetchRequest:withContext:
executeSaveChangesRequest:withContext:
executeCountRequest:withContext:
executeRefreshRequest:withContext:
propertiesToGroupBy
_retrieveNodesSatisfyingRequest:
_retrieveNodeForObjectID:
_setHasRetainedStoreResources__:
values
expression
expressionValueWithObject:context:
isCountOnlyRequest
requestExpression
lastObject
initForKeys:count:
initWithSearchStrategy:
setValues:
fetchOffset
removeObjectsInRange:
fetchLimit
numberWithUnsignedLong:
hasChanges
_isMetadataDirty
_getNewIDForObject:
_changeIDsForManagedObjects:toIDs:
_addObject:
_retrieveNodeForObject:
_removeObject:
_updateObject:
_storeNextReferenceInMetadata
_setMetadataDirty:
arrayWithCapacity:
predicateWithValue:
sortDescriptors
_subentitiesIncludes:
sortUsingDescriptors:
_deleteNodeFromMainCache:
_deleteNodeFromEntityCache:
_versionNumber
_setVersionNumber:
executeRequest:withContext:error:
newValuesForObjectWithID:withContext:error:
newValueForRelationship:forObjectWithID:withContext:error:
_didLoadMetadata
_preflightCrossCheck
managedObjectContextDidRegisterObjectsWithIDs:
managedObjectContextDidUnregisterObjectsWithIDs:
obtainPermanentIDsForObjects:error:
_retainedObjectIDForEntity:referenceObject:
initWithURL:
setOption:forKey:
numberWithDouble:
sqlitePragmas
type
configuration
persistentStoreDescriptionWithURL:
isReadOnly
setReadOnly:
timeout
setTimeout:
setValue:forPragmaNamed:
shouldAddStoreAsynchronously
setShouldAddStoreAsynchronously:
shouldInvokeCompletionHandlerConcurrently
setShouldInvokeCompletionHandlerConcurrently:
shouldMigrateStoreAutomatically
setShouldMigrateStoreAutomatically:
shouldInferMappingModelAutomatically
setShouldInferMappingModelAutomatically:
setType:
setConfiguration:
setURL:
_options
_type
_configuration
_url
isFileURL
URLByDeletingLastPathComponent
_propertyNamed:
initWithObjectID:
knownKeyValuesPointer
_snapshot_
propertyCache
setPropertyCache:
_objectID
__versionNumber
_propertyCache
_reserved1
encodeInt:forKey:
attributeValueClassName
isIndexed
encodeBool:forKey:
_storeBinaryDataExternally
encodeInt32:forKey:
numberWithFloat:
decodeIntForKey:
_sortOutDefaultNumericValuesBecauseDoublesAndFloatsDontCompareEqualAndThatBreaksTests
decodeBoolForKey:
setIndexed:
initWithInt:
decodeInt32ForKey:
decodeInt64ForKey:
_extraIVars
decodeDoubleForKey:
_throwIfNotEditable
_classNameForType:
setAttributeValueClassName:
_hasMinValueInExtraIvars
_hasMaxValueInExtraIvars
validationPredicates
arrayWithArray:
numberWithLongLong:
validationWarnings
setAttributeType:
setDefaultValue:
setValueTransformerName:
allowsExternalBinaryDataStorage
setAllowsExternalBinaryDataStorage:
_attributeValueClass
_valueTransformerName
_attributeValueClassName
_defaultValue
_initWithName:
_initWithName:type:withClassName:
_isTriggerBacked
isNSDate__
timeIntervalSinceReferenceDate
_rawValidationPredicates
_rawValidationWarnings
_canConvertPredicate:andWarning:
_comparePredicatesAndWarnings:
_comparePredicatesAndWarningsWithUnoptimizedAttributeDescription:
_createCachesAndOptimizeState
_replaceValidationPredicates:andWarnings:
_nonPredicateValidateValue:forKey:inObject:error:
_generateErrorWithCode:andMessage:forKey:andValue:additionalDetail:
_versionHash:inStyle:
_initWithName:type:
initWithString:
initWithDouble:
initWithFloat:
initWithTimeIntervalSinceReferenceDate:
unarchiveObjectWithData:
_appendPropertyFieldsToData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:entitiesSlots:
replaceBytesInRange:withBytes:
_epsilonEquals:rhs:withFlags:
_initWithType:
setStoresBinaryDataExternally:
_writeIntoData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:entitiesSlots:fetchRequests:
initWithProperty:
setExternalType:
setExternalPrecision:
setExternalScale:
externalType
externalPrecision
externalScale
property
externalName
columnDefinition
_externalType
_externalPrecision
_externalScale
_modelsReferenceID
generatedNameSuffix
_retain_1
_release_1
isSubclassOfClass:
initWithUnsignedLongLong:
initWithBytes:length:encoding:
pathComponents
initWithEntity:andUUIDString:
_setPersistentStore:
setObjectStoreIdentifier:
_getURIBytes:length:
URLWithString:
automaticallyNotifiesObserversForKey:
classWithStore:andEntity:
allocateBatch:count:
version
managedObjectIDFromUTF8String:length:
managedObjectIDFromURIRepresentation:
_setStoreInfo1:
_storeInfo1
_storeDeallocated
_storeIdentifier
_isPersistentStoreAlive
URIRepresentation
entityForEntityDescription:
_fallbackFactory
_referenceData48_cd_rc16
_initCoreWithTaggedIndex:
_taggedPoolIndex
_fallbackFactories
_storeInfoForEntityDescription:
doURLStuff:createdStubFile:readOnly:error:options:
doFilesystemCleanupOnRemove:
initWithStore:fromPath:
initWithStore:
_setMap:
_theMap
saveToPath:
metadataForPersistentStoreWithURL:options:error:
setMetadata:forPersistentStoreWithURL:options:error:
readMetadataFromFile:error:
fullMetadata
setMetadata:forPersistentStoreWithURL:error:
setFullMetadata:
writeMetadataToFile:error:
saveDocumentToPath:
initWithSubresults:
subresults
_subresults
progress
cancel
initWithContext:andProgress:completetionBlock:
_cancelProgress
_isCancelled
setProgress:
operationError
setOperationError:
requestCompletionBlock
setRequestCompletionBlock:
_requestProgress
_requestError
_requestContext
_requestCompletionBlock
initForFetchRequest:withContext:andProgress:completetionBlock:
fetchRequest
finalResult
setFinalResult:
intermediateResultCallback
setIntermediateResultCallback:
_fetchRequest
_finalResult
_intermediateResultCallback
setDatabaseVersion:
setPrimaryKeyGeneration:
setMapData:
subdataWithRange:
initForReadingWithData:
finishDecoding
clearCurrentValues
readBinaryStoreFromData:originalPath:error:
fileHandleForUpdatingAtPath:
readDataOfLength:
seekToFileOffset:
initForWritingWithMutableData:
finishEncoding
_writeMetadataData:andMapDataData:toFile:error:
closeFile
fileHandleForReadingAtPath:
databaseVersion
primaryKeyGeneration
writeToFile:options:error:
mapData
readFromFile:error:
writeToFile:error:
_databaseVersion
_fullMetadata
_primaryKeyGeneration
_mapData
_storeOptions
_propertySearchMapping
fastIndexForKnownKey:
_doAttributeDecoding
dataForKey:
initWithValues:objectID:
attributeValues
_attributes
_attributesAsEncoded
_setMetadata:
fileExistsAtPath:isDirectory:
store
willAccessValueForKey:
_isValidRelationshipDestination__
setDestinations:forRelationship:
_nodeFromObject:objectIDMap:
removeObject:objectIDMap:
addObject:objectIDMap:
destinationsForRelationship:
dataWithCapacity:
initWithStore:fromArchivedData:
_theDictionary
updateObject:objectIDMap:
retainedObjectIDsForRelationship:forObjectID:
handleFetchRequest:
_archivedData
_entityForName:
entityForName:inManagedObjectContext:
_entityClass
allocWithEntity:
initWithEntity:insertIntoManagedObjectContext:
_entityDeallocated
isAbstract
encodeConditionalObject:forKey:
initWithDictionary:
versionHashModifier
setRenamingIdentifier:
setCompoundIndexes:
setUniquenessConstraints:
setSubentities:
setProperties:
_compoundIndexes
managedObjectClassName
subentitiesByName
attributesByName
_propertiesOfType:
_removeSubentity:
_addSubentity:
_relationshipNamesByType:
relationshipsByName
_valueCountByEnumeratingWithState:objects:count:
_removeProperty:
_addProperty:
_isFlattened
_setEntity:
_MOClassName
_subentityNamed:
_removeEntity:
_addEntity:
getBytes:length:
properties
sortDescriptorWithKey:ascending:
_versionHashInStyle:
lowercaseString
setExpression:
setExpressionResultType:
_checkForNonCascadeNoInverses
_attributeNamed:
insertNewObjectForEntityForName:inManagedObjectContext:
attributeKeys
isKindOfEntity:
subentities
toManyRelationshipKeys
toOneRelationshipKeys
relationshipsWithDestinationEntity:
inverseForRelationshipKey:
setManagedObjectClassName:
setAbstract:
_newVersionHashInStyle:
setVersionHashModifier:
compoundIndexes
uniquenessConstraints
_snapshotClass
_versionHashModifier
_versionHash
_model
_classNameForEntity
_instanceClass
_rootentity
_superentity
_subentities
_properties
_propertyMapping
_propertyRanges
_entityDescriptionFlags
_extraIvars
_userInfo
_flattenedSubentities
_kvcPropertyAccessors
_modelsReferenceIDForEntity
_setSuperentity:
isEditable
setElementID:
elementID
knownKeysMappingStrategy
_propertyWithRenamingIdentifier:
_keypathsToPrefetchForDeletePropagationPrefixedWith:toDepth:processedEntities:
_keypathsToPrefetchForDeletePropagation
initWithObjects:forKeys:count:
maxCount
instanceMethodForSelector:
_isGeneratedClass
classForEntity:
_setIsEditable:
_localRelationshipNamed:
_flattenProperties
_isEditable
_collectSubentities
sortUsingFunction:context:
isIndexedBySpotlight
isStoredInExternalRecord
isOrdered
mapping
_isInheritedPropertyNamed:
_setEntitysReferenceID:
_newMappingForPropertiesOfRange:
_hasUniquePropertiesUncached
_commonCachesAndOptimizedState
_removePropertyNamed:
_propertyRangesByType
caseInsensitiveCompare:
initWithKey:ascending:selector:
_isOptimizedForEncoding
initWithPropertyDescription:
_setIsFlattened:
_stripForMigration
_restoreValidation
_hasUniquePropertiesDownInheritanceHiearchy
_constraintIsExtension:
_setValues:retain:
_nukeMOClassName__
_keypathsForDeletions
_setManagedObjectModel:
_hasCustomPrimitiveProperties
_relationshipNamed:
_hasPotentialHashSkew
_offsetRelationshipIndex:fromSuperEntity:andIsToMany:
_allPropertyNames
_newSnowLeopardStyleDictionaryContainingPropertiesOfType:
_leopardStyleRelationshipsByName
_leopardStyleAttributesByName
_new_implicitlyObservedKeys
_setModelsReferenceID:
_sortedSubentities
_skipValidation
_hasAttributesWithExternalDataReferences
_hasPropertiesIndexedBySpotlight
_hasPropertiesStoredInTruthFile
_isPathologicalForConstraintMerging:
_hasUniqueProperties
_extensionsOfParentConstraint:
_hasUniquedAttributeWithName:
_writeIntoData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:uniquedMappings:entities:
_createValuePrimitiveSetterWithContainerClassID:key:
ivar
method
containerClassID
_createValuePrimitiveGetterWithContainerClassID:key:
_createValueSetterWithContainerClassID:key:
_createValueGetterWithContainerClassID:key:
_initWithSourceEntityDescription:destinationEntityDescription:
sourceEntityVersionHash
destinationEntityVersionHash
sourceExpression
entityMigrationPolicyClassName
initWithData:
setEntityMigrationPolicyClassName:
_reserved
_mappingsByName
_mappingType
_sourceEntityName
_sourceEntityVersionHash
_destinationEntityName
_destinationEntityVersionHash
_sourceExpression
_entityMigrationPolicyClassName
_attributeMappings
_relationshipMappings
_entityMappingFlags
_migrationPolicy
_addAttributeMapping:
_addRelationshipMapping:
_hasInferredMappingNeedingValidation
destinationContext
_migrationContext
setCurrentPropertyMapping:
associateSourceInstance:withDestinationInstance:forEntityMapping:
sourceInstancesForEntityMappingNamed:destinationInstances:
destinationEntityForEntityMapping:
orderedSetWithSet:
orderedSetWithArray:
orderedSetWithObject:
setWithObject:
mutableSetValueForKey:
beginEntityMapping:manager:error:
createDestinationInstancesForSourceInstance:entityMapping:manager:error:
endInstanceCreationForEntityMapping:manager:error:
createRelationshipsForDestinationInstance:entityMapping:manager:error:
endRelationshipCreationForEntityMapping:manager:error:
performCustomValidationForEntityMapping:manager:error:
endEntityMapping:manager:error:
_nonNilValueOrDefaultValueForAttribute:source:destination:
defaultMappingGenerator
externalNameForEntityName:
initWithExternalName:
setPropertyMappings:
setPrimaryKeys:
setSingleTableEntity:
setSubentityColumn:
setSubentityID:
propertyMappings
primaryKeys
isSingleTableEntity
subentityColumn
subentityID
initWithKey:ascending:
columnDefinitions
constraintDefinitions
primaryKeyColumnDefinitions
attributeColumnDefinitions
foreignKeyColumnDefinitions
foreignKeyConstraintDefinitions
initWithEntity:
createTableStatement
_propertyMappings
_primaryKeys
_isSingleTableEntity
_subentityColumn
_subentityID
expressionResultType
_reservedtype1_1
_reservedtype1_2
_reservedtype1_3
_reservedtype1_4
_reservedtype1_5
_reservedtype1_6
_reservedtype2_1
_reservedtype2_2
_reservedtype2_3
_expression
_expressionResultType
entities
createCachesForEntity:forValidator:
registerObject:
validateForSave:
validateCaches
reset
initWithManagedObjectModel:
_addConstraintRoot:forEntity:
registerObjects:
validateForSave
_cachesByEntity
entityID
entityDescription
initWithKeyPath:
foreignKey
foreignOrderKey
initWithModel:
inverseIsToOnePrefetchRequestForRelationshipNamed:onEntity:
manyToOnePrefetchRequestForRelationshipNamed:onEntity:
manyToManyPrefetchRequestsForRelationshipNamed:onEntity:
_prefetchRequestsByEntity
_initializeRelationshipCaches
toManyOffsetForProperty:
initWithOptions:andTimestamp:
timestamp
setTimestamp:
incrementRefCount
decrementRefCount
externalReferenceCount
incrementExternalReferenceCount:
copyRelationshipCachesFrom:
releaseRelationshipCaches
updateMissingRelationshipCachesFromOriginal:
relatedObjectIDsForProperty:
timestampForProperty:
setRelatedObjectIDs:forProperty:options:andTimestamp:
ancillaryOrderKeysForProperty:
setAncillaryOrderKeys:forProperty:options:andTimestamp:
_externalReferenceCount
_externalRefFlags
_toManyMap
_birth
initWithNode:
node
_node
initWithPersistenceStore:
willFireFault
_disableChangeNotifications
_willChangeValuesForKeys:
lockObjectStore
_parentStore
unlockObjectStore
_didChangeValuesForKeys:
_enableChangeNotifications
didFireFault
awakeFromFetch
_isToManyRelationship
fulfillFault:withContext:forIndex:
predicateWithSubstitutionVariables:
localizedDescription
isInserted
_newOrderedRelationshipInformationForRelationship:forObjectWithID:withContext:error:
willTurnIntoFault
_setSuppressingChangeNotifications__:
_clearRawPropertiesWithHint:
didTurnIntoFault
fulfillFault:withContext:error:
fulfillFault:withContext:
retainedOrderedFaultInformationForAggregateFaultForObject:andRelationship:withContext:error:
turnObject:intoFaultWithContext:
_fireFirstAndSecondLevelFaultsForObject:withContext:
_isUnprocessedDeletion__
_isPendingDeletion__
_delegate
context:shouldHandleInaccessibleFault:forObjectID:andTrigger:
shouldHandleInaccessibleFault:forObjectID:triggeredByProperty:
_hasRetainedStoreResources__
_queryGenerationToken__
managedObjectContextDidRegisterObjectsWithIDs:generation:
_setSuppressingKVO__:
_forceRegisterLostFault:
deleteObject:
_handleError:withError:
initWithName:
initWithName:managedObjectModel:
URLsForDirectory:inDomains:
URLForResource:withExtension:
initWithContentsOfURL:
_newModelForName:
initWithConcurrencyType:
setPersistentStoreCoordinator:
defaultDirectoryURL
persistentStoreDescriptions
addPersistentStoreWithDescription:completionHandler:
parentContext
setParentContext:
newBackgroundContext
performBlock:
persistentContainerWithName:
persistentContainerWithName:managedObjectModel:
loadPersistentStoresWithCompletionHandler:
performBackgroundTask:
viewContext
setPersistentStoreDescriptions:
_viewContext
_storeCoordinator
_storeDescriptions
persistentContainerWithPath:managedObjectModel:
persistentContainerWithPath:
persistentContainerWithPath:modelNamed:
setFetchRequest:
_reserved6
_lazyFetchRequestEntityName
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isMemberOfClass:
conformsToProtocol:
zone
superclass
debugDescription
initWithBool:
havingPredicate
includesPendingChanges
_newValidatedProperties:groupBy:error:
initWithEntityName:
fetchRequestWithEntityName:
execute:
groupByProperties
setGroupByProperties:
_groupByProperties
_havingPredicate
_additionalPrivateIvars
_valuesToFetch
_sortDescriptors
_fetchLimit
_relationshipKeyPathsForPrefetching
_isCachingFetchRequest__
_setAsyncResultHandle:
_asyncResultHandle
_copyForDirtyContext
_resolveEntityWithContext:
_incrementInUseCounter
stores
_XPCEncodedFlags
_setFlagsFromXPCEncoding:
initWithExpressionType:
initForFetch:context:countOnly:
countForFetchRequest:error:
predicateFormat
contextExpression
_expressionWithSubstitutionVariables:
_reserved2
_reserved3
_managedObjectContext
initWithSourceAttributeName:destinationAttributeName:
sourceAttributeName
destinationAttributeName
joinWithSourceAttributeName:destinationAttributeName:
_sourceAttributeName
_destinationAttributeName
numberWithShort:
_makeBranchTableForKeys:count:
_coreCreationForKeys:count:
_coreDealloc:
setWithObjects:
decodeObjectOfClasses:forKey:
encodeInt64:forKey:
initForKeys:
_reserved64
_table
_keys
allowedClasses
getObjects:andKeys:
initWithDictionary:copyItems:
_recount
initWithArray:forTarget:withReferenceValues:andRange:andCopyItems:
_countByEnumeratingWithState:objects:count:forKeys:
getKeys:
isEqualToDictionary:
setValue:atIndex:
valueAtIndex:
keyEnumerator
_keySearch
_invalidate
nextObject
_target
_list
_referenceItems
_range
newInstanceWithSearchStrategy:inData:
applyToSet:
_diffObject
initWithObject:index:
_setGenericValue:forKey:withIndex:flags:
_genericValueForKey:withIndex:flags:
dateWithTimeIntervalSinceReferenceDate:
_PFPlaceHolderSingleton
willChangeValueForKey:
didChangeValueForKey:
willChange:valuesAtIndexes:forKey:
didChange:valuesAtIndexes:forKey:
alloc_10_4
allocWithZone_10_4:
_queueForDealloc:
dictionaryWithCapacity:
substringToIndex:
_descriptionValues
insertObject:
_isPendingUpdate__
_isUnprocessedUpdate__
_transientPropertiesChangesMask__
didAccessValueForKey:
_validateValue:forProperty:andKey:withIndex:error:
isDeleted
_chainNewError:toOriginalErrorDoublePointer:
_validateForSave:
mutableArrayValueForKey:
_genericMutableSetValueForKey:withIndex:flags:
_genericMutableOrderedSetValueForKey:withIndex:flags:
mutableOrderedSetValueForKey:
setValuesForKeysWithDictionary:
_updateToManyRelationship:from:to:with:
dictionaryWithValuesForKeys:
_allProperties__
_originalSnapshot__
_newPersistentPropertiesWithRelationshipFaultsIntact__
_persistentProperties__
raise
_reservedCurrentEventSnapshot
_PFPlaceHolderSingleton_core
contextShouldIgnoreUnmodeledPropertyChanges
_batch_release__
isUpdated
hasFaultForRelationshipNamed:
setObservationInfo:
observationInfo
awakeFromInsert
awakeFromSnapshotEvents:
prepareForDeletion
willSave
didSave
validateValue:forKey:error:
validateForDelete:
validateForInsert:
validateForUpdate:
primitiveValueForKey:
setPrimitiveValue:forKey:
committedValuesForKeys:
changedValues
valueForUndefinedKey:
setValue:forUndefinedKey:
setNilValueForKey:
faultingState
changedValuesForCurrentEvent
hasPersistentChangedValues
objectIDsForRelationshipNamed:
_cd_lockingInfo
_cd_stateFlags
_cd_extraFlags
_cd_rawData
_cd_managedObjectContext
_cd_objectID
_cd_extras
_cd_queueReference
willRefresh:
didRefresh:
_lastSnapshot__
_calculateDiffsBetweenOrderedSet:andOrderedSet:
_newPropertiesForRetainedTypes:andCopiedTypes:preserveFaults:
_newPersistentPropertiesForConflictRecordFaultsIntact__
_transientProperties__
initWithIndex:
_implicitObservationInfoForEntity:forResultingClass:
isNSData__
decimalNumberWithString:
_isKindOfEntity:
addObjects:count:
initWithContainer:key:mutableOrderedSet:
initWithContainer:key:mutableOrderedSet:mutationMethods:
_excludeObject:fromPropertyWithKey:andIndex:
_includeObject:intoPropertyWithKey:andIndex:
_maintainInverseRelationship:forProperty:oldDestination:newDestination:
_maintainInverseRelationship:forProperty:forChange:onSet:
_propagateDelete:
_localizationPolicy
localizedEntityNameForEntity:
localizedPropertyNameForProperty:
replaceOccurrencesOfString:withString:options:range:
_generateErrorDetailForKey:withValue:
_substituteEntityAndProperty:inString:
_useFastValidationMethod
_validatePropertiesWithError:
localizedModelStringForKey:
dictionaryWithDictionary:
diffOrderedSets:::::::
removeObjectsInArray:
_genericUpdateFromSnapshot:
initWithSet:
_newSetFromSet:byApplyingDiffs:
_initWithEntity:withID:withHandler:withContext:
wasForgotten
_hasAnyObservers__
_hasPendingChanges
_clearPendingChanges__
_hasUnprocessedChanges__
_clearUnprocessedChanges__
_clearAllChanges__
_isSuppressingChangeNotifications__
_isSuppressingKVO__
_setPendingDeletion__:
_isPendingInsertion__
_setPendingInsertion__:
_setPendingUpdate__:
_setUnprocessedDeletion__:
_isUnprocessedInsertion__
_setUnprocessedInsertion__:
_setUnprocessedUpdate__:
_stateFlags
_setLastSnapshot__:
_nilOutReservedCurrentEventSnapshot__
_changedValuesForCurrentEvent
_versionReference__
_setVersionReference__:
_setObjectID__:
_setOriginalSnapshot__:
_referenceQueue__
_newChangedValuesForRefresh__
_newNestedSaveChangedValuesForParent:
_newSnapshotForUndo__
_newAllPropertiesWithRelationshipFaultsIntact__
_newCommittedSnapshotValues
_changedTransientProperties__
_implicitObservationInfo
_didChangeValue:forRelationship:named:withInverse:
_propagateDelete
_prepropagateDeleteForMerge
_updateFromSnapshot:
_updateFromRefreshSnapshot:includingTransients:
_updateFromUndoSnapshot:
_orderedObjectsAndKeys
_reorderObjectsToLocationsByOrderKey:error:
_orderKeysForRelationshipWithName__:
_updateLocationsOfObjectsToLocationByOrderKey:inRelationshipWithName:error:
defaultCenter
postNotificationName:object:
initForObservationWithName:store:
setStore:
.cxx_destruct
_queue
_store
signatureWithObjCTypes:
_isGeneratedClass_1
_PFMOClassFactoryData
isEqualToData:
allocBatch:withEntity:count:
allocateBatch:forEntity:count:
_initializeAccessorStubs
_initializePrimitiveAccessorStubs
_isOrdered
_defaultValidation:error:
methodSignatureForSelector:
implementsSelector:
batchAllocateWithEntity:insertIntoManagedObjectContext:count:
_hasOverriddenAwake
resolveClassMethod:
resolveInstanceMethod:
lastIndex
getIndexes:maxCount:inIndexRange:
replaceObjectsInRange:withObjects:count:
numberWithChar:
standardUserDefaults
integerForKey:
boolForKey:
stringForKey:
_registerForNotificationsWithCoordinator:
_setPersistentStoreCoordinator:
_setRetainsRegisteredObjects:
shouldDeleteInaccessibleFaults
discardEditing
_forgetObject:propagateToObjectStore:removeFromRegistry:
_resetAllChanges
managedObjectContextDidUnregisterObjectsWithIDs:generation:
_postObjectsDidChangeNotificationWithUserInfo:
unpinnedQueryGenerationToken
currentQueryGenerationToken
_setQueryGenerationFromToken:error:
assertOnImproperDealloc
_unregisterRunloopObservers
_unregisterForNotifications
_dispose:
callStackSymbols
_dealloc__
_stopObservingUndoManagerNotifications
_startObservingUndoManagerNotifications
_setUndoManager:
_processRecentChanges:
_retainedRegisteredObjects
_persistentStoreForIdentifier:
managedObjectIDForURIRepresentation:error:
_ignoringChangeNotifications
_insertObjectWithGlobalID:globalID:
_registerClearStateWithUndoManager
_establishEventSnapshotsForObject:
_enqueueEndOfEventNotification
_parentObtainPermanentIDsForObjects:context:error:
postNotificationName:object:userInfo:
_prepareForPushChanges:
_newSaveRequestForCurrentState
_hasEntityWithUniquenessConstraints
registeredObjects
_doPreSaveConstraintChecksForObjects:error:
_generateOptLockExceptionForConstraintFailure:
_informParentStore:ofInterestInObjects:
setDebugDefault:
mergePolicy
resolveConflicts:error:
_retainedCurrentQueryGeneration
_thereIsNoSadnessLikeTheDeathOfOptimism
_didSaveChanges
objectRegisteredForID:
_retainedObjectWithID:
_retainedObjectWithID:error:
stalenessInterval
_setStalenessInterval:
initWithFetchRequest:completionBlock:
_executeAsynchronousFetchRequest:
_attemptCoalesceChangesForFetch
_countWithNoChangesForRequest:error:
_countWithMergedChangesForRequest:possibleChanges:possibleDeletes:error:
_createStoreFetchRequestForFetchRequest:
currentProgress
initWithParent:userInfo:
estimatedResultCount
setTotalUnitCount:
setKind:
completionBlock
setCancellationHandler:
completedUnitCount
setCompletedUnitCount:
propagatesDeletesAtEndOfEvent
setPropagatesDeletesAtEndOfEvent:
processPendingChanges
_committedSnapshotForObject:
_refaultObject:globalID:boolean:
_prepareUnprocessedDeletionAfterRefresh:
undo
redo
_initWithParentObjectStore:
decodeFloatForKey:
setMergePolicy:
encodeFloat:forKey:
_forceRemoveFromDeletedObjects:
_mergeRefreshObject:mergeChanges:withPersistentSnapshot:
_mergeRefreshEpilogueForObject:mergeChanges:
_mergeChangesFromRemoteContextSave:intoContexts:
_mergeChangesFromDidSaveDictionary:usingObjectIDs:
refreshObject:mergeChanges:
performWithOptions:andBlock:
_setParentContext:
nostoresQueryGenerationToken
_validateQueryGeneration:error:
automaticallyMergesChangesFromParent
setAutomaticallyMergesChangesFromParent:
_setAutomaticallyMergesChangesFromParent:
removeObserver:name:object:
_automaticallyMergeChangesFromContextDidSaveNotification:
addObserver:selector:name:object:
mergeChangesFromContextDidSaveNotification:
__Multithreading_Violation_AllThatIsLeftToUsIsHonor__
mergeChangesFromRemoteContextSave:intoContexts:
setRetainsRegisteredObjects:
retainsRegisteredObjects
setShouldDeleteInaccessibleFaults:
setStalenessInterval:
setUndoManager:
undoManager
assignObject:toPersistentStore:
observeValueForKeyPath:ofObject:change:context:
_youcreatedanNSManagedObjectContextOnthemainthreadandillegallypassedittoabackgroundthread
existingObjectWithID:error:
_checkObjectForExistenceAndCacheRow:
executeRequest:error:
rollback
detectConflictsForObject:
refreshAllObjects
setQueryGenerationFromToken:error:
queryGenerationToken
_queueOwner
_dispatchQueue
_spinLock
_parentObjectStore
_unprocessedChanges
_unprocessedDeletes
_unprocessedInserts
_insertedObjects
_deletedObjects
_changedObjects
_lockedObjects
_refreshedObjects
_infoByGID
_cachedObsInfoByEntity
_undoTransactionID
_lockCount
_objectStoreLockCount
_fetchTimestamp
_referenceCallbackRegistration
_referenceQueue
_ignoreChangeNotification
_contextLabel
_newUnchangedLockedObjects
initWithInsertedObjects:updatedObjects:deletedObjects:lockedObjects:
substitutionVariables
_fetchLimitForRequest:
_unlimitRequest:
_registerObject:withID:
_informParentStore:noLongerInterestedInObjects:
_performCoordinatorActionAndWait:
_disposeObjects:count:notifyParent:
_contextDidDealloc
initForContext:
currentQueue
maxConcurrentOperationCount
_clearUnprocessedUpdates
_clearUpdates
_clearUnprocessedInsertions
_clearInsertions
_clearUnprocessedDeletions
_clearDeletions
_clearLockedObjects
_clearRefreshedObjects
isUndoRegistrationEnabled
removeAllActions
_incrementUndoTransactionID
_globalIDForObject:
_clearOriginalSnapshotForObject:
_validateObjects:forOperation:error:exhaustive:forSave:
mergeType
_clearOriginalSnapshotAndInitializeRec:
_postContextDidSaveNotificationWithUserInfo:
_forgetObject:propagateToObjectStore:
performFetch:error:
_globalIDsForObjects:
_batchRetainedObjects:forCount:withIDs:optionalHandler:withInlineStorage:
_validateDeletesUsingTable:withError:
_validateChangesForSave:
_informParentStoreOfInterestInObjectIDs:generation:
_informParentStoreNoLongerInterestedInObjectIDs:generation:
_retainedObjectsFromRemovedStore:
_stopsValidationAfterFirstError
_setStopsValidationAfterFirstError:
_debuggingOnly_localObjectForGlobalID:
_currentEventSnapshotForObject:
_growRegistrationCollectionForEntitySlot:toSize:
_setIsUbiquityImportContext:
_isImportContext
_isPreflightSaveInProgress
_setDisableDiscardEditing:
_disableDiscardEditing
_setPostSaveNotifications:
_postSaveNotifications
_persistentStoreDidUpdateAdditionalRowsWithNewVersions:
objectWillChange:
_undoInsertions:
_registerUndoForOperation:withObjects:withExtraArguments:
_undoDeletionsMovedToUpdates:
registerUndoWithTarget:selector:object:
_createAndPostChangeNotification:deletions:updates:refreshes:deferrals:wasMerge:
_undoDeletions:
_undoUpdates:
groupsByEvent
isUndoing
isRedoing
beginUndoGrouping
_clearChangedThisTransaction:
disableUndoRegistration
enableUndoRegistration
_postRefreshedObjectsNotificationAndClearList
_updateUnprocessedOwnDestinations:
_propagatePendingDeletesAtEndOfEvent:
_processPendingDeletions:withInsertions:withUpdates:withNewlyForgottenList:withRemovedChangedObjects:
_processPendingInsertions:withDeletions:withUpdates:
_processPendingUpdates:
_registerUndoForModifiedObjects:
_registerUndoForInsertedObjects:
_registerUndoForDeletedObjects:withDeletedChanges:
_updateUndoTransactionForThisEvent:withDeletions:withUpdates:
_processRecentlyForgottenObjects:
_postContextDidMergeChangesNotificationWithUserInfo:
_processDeletedObjects:
endUndoGrouping
_processEndOfEventNotification:
_prefetchObjectsForDeletePropagation:
_propagateDeletesUsingTable:
_forceInsertionForObject:
_undoManagerCheckpoint:
_noop:
_processObjectStoreChanges:
_processNotificationQueue
removeAllActionsWithTarget:
_storeConfigurationChanged:
_sendOrEnqueueNotification:selector:
_processChangedStoreConfigurationNotification:
defaultQueue
enqueueNotification:postingStyle:
_objectsChangedInStore:
isEditing
commitEditing
invocationWithMethodSignature:
setSelector:
setArgument:atIndex:
invokeWithTarget:
performSelector:withObject:afterDelay:inModes:
_managedObjectContextEditor:didCommit:contextInfo:
_sendCommitEditingSelectorToTarget:sender:selector:flag:contextInfo:delayed:
commitEditingWithDelegate:didCommitSelector:contextInfo:
objectDidBeginEditing:
objectDidEndEditing:
performBlockWithResult:
_setDelegate:
_orderedSetWithResultsFromFetchRequest:
_stopConflictDetectionForObject:
_mergeChangesFromRemoteContextSave:
_queueCount
_signal
_queueBatchForDealloc:
_signalRunloop
_rlObserver
_processing
_copyChildObject:toParentObject:fromChildContext:
_parentObjectsForFetchRequest:inContext:error:
_parentProcessSaveRequest:inContext:error:
initWithOwnedKKsD:andVersion:
_snapshot
_version
_allOrderKeysForDestination:inRelationship:error:
_orderKeysForRelationshipWithName__:onObjectWithID:
_updateLocationsOfObjectsToLocationByOrderKey:inRelationshipWithName:onObjectWithID:error:
persistentStores
_newArchiveForScalarObjectIDs:
unarchivedScalarObjectIDsFromData:withCoordinator:
_modelPathsFromBundles:
modelByMergingModels:
fetchRequestTemplatesByName
fetchRequestTemplateForName:
addPolicy:
_setLocalizationPolicy:
_deepCollectEntitiesInArray:entity:
_addEntities:toConfiguration:
setFetchRequestTemplate:forName:
versionIdentifiers
_addVersionIdentifiers:
initWithPath:
fileURLWithPath:isDirectory:
modelByMergingModels:forStoreMetadata:
_modelForVersionHashes:
removeObjectsForKeys:
_initWithEntities:
optimizedVersionURL
currentVersionURL
pathExtension
initWithContentsOfOptimizedURL:
unarchiveObjectWithFile:
setEntities:
setEntities:forConfiguration:
setVersionIdentifiers:
_ensureFullLocalizationDictionaryIsLoaded
localizationDictionary
setLocalizationDictionary:
_entityVersionHashesByNameInStyle:
_isConfiguration:inStyle:compatibleWithStoreMetadata:
mergedModelFromBundles:
mergedModelFromBundles:forStoreMetadata:
configurations
fetchRequestFromTemplateWithName:substitutionVariables:
entityVersionHashesByName
isConfiguration:compatibleWithStoreMetadata:
_dataForOptimization
_optimizationHints
_entities
_configurations
_fetchRequestTemplates
_versionIdentifiers
_managedObjectModelFlags
_newModelFromOptimizedEncoding:error:
_setIsEditable:optimizationStyle:
_optimizedEncoding:
initWithManagedObjectModel:configurationName:retainHashHack:
archivedDataWithRootObject:
entityNamed:
_odiousHashHack
_updateInverse:
dataWithBytes:length:
initWithContentsOfURL:forStoreMetadata:
allBundles
bundlePath
pathsForResourcesOfType:inDirectory:
_hasPrecomputedKeyOrder
_removeEntities:fromConfiguration:
_removeEntityNamed:
_precomputedKeysForEntity:
_configurationsByName
_sortedEntitiesForConfiguration:
_entitiesByVersionHash
_versionIdentifiersAsArray
coordinator
entitlements
auditToken
_entitlements
_cache
initForToken:entitlementNames:cache:
cache
initWithConnectionInfo:
setManagedObjectContext:
notificationManager
setNotificationManager:
_info
_manager
initWithCoordinator:
localGenerationForRemoteGeneration:
registerQueryGeneration:forRemoteGeneration:
releaseQueryGenerationForRemoteGeneration:
_coordinator
_prefetchRequestCache
_generationTokenMap
_transaction
pathForResource:ofType:
dictionaryWithContentsOfFile:
reason
versionInfoDictionary
versionHashInfo
bundle
currentVersion
urlForModelVersionWithName:
URLsForResourcesWithExtension:subdirectory:
modelVersions
_modelForVersionHashes:inStyle:
_bundle
_versionInfoDictionary
getNewIDForObject:
_addObject:objectIDMap:
_removeObject:objectIDMap:
_updateObject:objectIDMap:
save
nextPK64
databaseUUID
_pathFromURI:
_entitiesToFetch
_newMappingModelFromPaths:forSourceHashes:destinationHashes:
_initWithEntityMappings:
entityMappingsByName
_addEntityMapping:
mappingModelFromBundles:forSourceModel:destinationModel:
_entityMappings
_entityMappingsByName
_modelMappingFlags
allFrameworks
_isInferredMappingModel
_sourceEntityVersionHashesByName
_destinationEntityVersionHashesByName
initWithScope:
isDestination:compatibleDestinationFor:
initWithConstantValue:inScope:context:
generateSQLStringInContext:
propertyDescription
entityIDForName:
foreignEntityKey
isRelationship:compatibleWith:
initWithConstantValue:ofType:inScope:context:
generateVariableAlias
expressionForSubquery:usingIteratorVariable:predicate:
initWithExpression:trailingKeypath:inScope:
_subqueryIntermediateForToManyKeypathWithComponents:withFunction:inContext:
_generateSQLForKeypathWithComponents:onSQLEntity:inContext:
propertyType
propertyNamed:
_generateSQLForRelationshipUpdate:sourceRelationship:inContext:
_generateSQLForAttributeUpdate:sourceAttribute:inContext:
_generateSQLToUpdateProperty:fromMultiStepKeypathComponents:inContext:
_generateSQLToUpdateProperty:fromSingleStepKeypath:inContext:
_generateSQLForRelationshipUpdate:destination:inContext:
_generateSQLForAttributeUpdate:value:inContext:
_generateSQLForExpression:allowToMany:inContext:
_generateSQLToUpdateProperty:fromKeypath:inContext:
_generateSQLToUpdateProperty:fromSubquery:inContext:
initWithProperties:values:inScope:
isUpdateColumnsScoped
governingAliasForKeypathExpression:
_propertiesToUpdate
_valuesToUpdateTo
initWithServiceName:
initWithMachServiceName:options:
newEndpoint
initWithListenerEndpoint:
debugDefault
setInterruptionHandler:
logMessage:forComponent:
setInvalidationHandler:
handleRequest:reply:
interfaceWithProtocol:
setRemoteObjectInterface:
resume
createConnectionWithOptions:
invalidate
disconnect
remoteObjectProxy
classesForErrorArchive
decodeSecureArchivedData:usingDelegate:classes:
_isOnExtendedTimeout
initForStore:withOptions:
sendMessage:fromContext:store:error:
_semaphore
identifierForStore:
updateNotificationNameForStore:
handleNotification:
currentGenerationForStore:
initForStore:origin:generation:
origin
generation
storeIdentifier
initWithStoreIdentifier:origin:generation:
registerStore:
unregisterStore:
registerContext:
unregisterContext:
currentGenerationTokenForStore:
changesSinceGeneration:
_generations
_origin
performPrimitiveOperationUsingObject:andObject:
delegate
replacementObjectForXPCConnection:encoder:object:
requiresSecureCoding
initWithSource:newVersion:oldVersion:snapshot1:snapshot2:snapshot3:
_generationalComponentForStore:
_cachedRowForObjectWithID:generation:
initWithSource:newVersion:oldVersion:cachedSnapshot:persistedSnapshot:
_doCleanupForXPCStore:context:
ancestorSnapshot
sourceObject
objectSnapshot
cachedSnapshot
persistedSnapshot
newVersionNumber
oldVersionNumber
_snapshot1
_snapshot2
_snapshot3
_newVersion
_oldVersion
constraint
databaseObject
conflictingObjects
initWithConstraint:databaseObject:databaseSnapshot:conflictingObjects:conflictingSnapshots:
_isDBConflict
constraintValues
conflictingSnapshots
databaseSnapshot
_constraint
_databaseObject
_databaseSnapshot
_conflictedValues
_conflictingObjects
_conflictingSnapshots
initWithMergeType:
_valuesOnObject:matchAgainstValues:
_mergeToManyUnionRelationshipsForObject:andObject:
_mergeToManyUnionRelationshipsForConstraintConflict:
_mergeToManyRelationshipsForObject:ontoObject:
_mergeToManyRelationshipsForConstraintConflict:withDesignatedOriginal:
_byPropertyObjectTrumpMergeObject:ontoObject:writeAll:
_electPreexistingDesignatedOriginalFrom:
_electNewlyInsertedDesignatedOriginalFrom:
_mergeValuesForObject:ontoObject:
_electDesignatedOriginalForConflict:
_mergeContendersResolveConstraintConflict:withKeeper:
_eliminateContendersResolveConstraintConflict:withKeeper:
_didSomethingElseResolveDBConflict:
_unresolvedObjectsForContextConflict:
_unresolvedConflictFor:
_byPropertyStoreTrumpResolveConstraintConflict:
_byPropertyObjectTrumpResolveConstraintConflict:
_rollbackResolveConstraintConflict:
_overwriteResolveConstraintConflict:
_resolveContextConstraintConflict:
_mergeChangesStoreUpdatesTrumpForObject:withRecord:
_mergeChangesObjectUpdatesTrumpForObject:withRecord:
_clearCachedRowForObjectWithID:generation:
mergeToManyRelationshipForSourceObject:withOldSnapshot:newSnapshot:andAncestor:andLegacyPath:
valueForPropertyDescription:
_mergeDeletionWithStoreChangesForObject:withRecord:
predicateWithBlock:
resolveOptimisticLockingVersionConflicts:error:
resolveConstraintConflicts:error:
resolveConstraintConflict:error:
resolveConflict:
load
errorMergePolicy
mergeByPropertyStoreTrumpMergePolicy
mergeByPropertyObjectTrumpMergePolicy
overwriteMergePolicy
rollbackMergePolicy
initWithType:
setCurrentBaselineKV:
setCurrentKV:
initWithLocalPeerID:storeName:modelVersionHash:andUbiquityRootLocation:
setNumRequiredTransactions:
setStoreSize:
setLogSize:
setLogToStoreSizeRatio:
setMinLogBytes:
stringWithString:
sharedSwitchboard
retainedEntryForStoreName:andLocalPeerID:
privateStore
bytesForFileAtPath:
filePresenter
copyStatusDictionary
ubiquityLocationType
modelVersionHash
numBytes
createSetOfAllPeerIDsInKnowledgeVectors:
transactionNumberForPeerID:
createFullPath
dateWithTimeIntervalSinceNow:
haveEnoughTransactionsToRoll
logsConsumeEnoughDiskSpace
checkPeerReceiptsUnderRootLocation:forAgreementWithLocalPeerID:storeName:modelVersionHash:error:
updateHeuristics
canRollBaseline:
localPeerID
ubiquityRootLocation
numRequiredTransactions
storeSize
logSize
logToStoreSizeRatio
minLogBytes
currentBaselineKV
currentKV
_storeName
_ubiquityRootLocation
_modelVersionHash
_numRequiredTransactions
_storeSize
_logSize
_logToStoreSizeRatio
_minLogBytes
_currentBaselineKV
_currentKV
clearAssociationTables
setCurrentMigrationStep:
_createAssociationsBySource:withDestination:forEntityMapping:
_createAssociationsByDestination:fromSource:forEntityMapping:
initWithMigrationManager:
currentEntityMapping
setCurrentEntityMapping:
currentPropertyMapping
currentMigrationStep
destinationInstancesForEntityMapping:sourceInstance:
sourceInstancesForEntityMapping:destinationInstance:
_bySourceAssociationTable
_byDestinationAssociationTable
_byMappingBySourceAssociationTable
_byMappingByDestinationAssociationTable
_migrationManager
_currentMapping
_currentStep
_currentPropertyMapping
_doCleanupOnFailure:
_beginPowerAssertionWithAssert:
usesStoreSpecificMigrationManager
registeredStoreTypes
pointerValue
migrationManagerClass
_canMigrateWithMappingModel:
_migrateStoreFromURL:type:options:withMappingModel:toDestinationURL:destinationType:destinationOptions:error:
_endPowerAssertionWithAssert:andApp:
_mappingNamed:
sourceEntityForEntityMapping:
mappingModel
sourceContext
destinationInstancesForEntityMappingNamed:sourceInstances:
destinationInstancesForSourceRelationshipNamed:sourceInstances:
migrationProgress
cancelMigrationWithError:
setUsesStoreSpecificMigrationManager:
_sourceEntitiesByVersionHash
_destinationEntitiesByVersionHash
_sourceManagedObjectContext
_destinationManagedObjectContext
_migrationManagerFlags
_migrationCancellationError
fetchRequestForSourceEntityNamed:predicateString:includesSubentities:
_evaluateSourceExpressionForMapping:entityPolicy:
_performSanityCheckForMapping:fromSourceModel:toDestinationModel:
addPersistentStoreWithType:configuration:URL:options:error:
_copyMetadataFromStore:toStore:migrationManager:
_doFirstPassForMapping:error:
_doSecondPassForMapping:error:
_validateAllObjectsAfterMigration:
_doThirdPassForMapping:error:
removePersistentStore:error:
fetchRequestForSourceEntityNamed:predicateString:
isWritableFileAtPath:
classForStore:
setIdentifier:
_unload:
willRemoveFromPersistentStoreCoordinator:
didAddToPersistentStoreCoordinator:
loadMetadata:
_configurationName
_oidFactories
_defaultFaultHandler
_temporaryIDClass
_externalRecordsMonitor
_activeRequests
_reserved32
faultHandlerClass
_objectIDClass
cachedModelForPersistentStoreWithURL:options:error:
initForNonGenerationalStore:
objectIDClassForEntity:
_resetObjectIDFactoriesForStoreUUIDChange
_prepareForExecuteRequest:withContext:error:
_defaultMetadata
_updateMetadata
incrementInUseCounter
decrementInUseCounter
supportsConcurrentRequestHandling
supportsGenerationalQuerying
currentQueryGeneration
freeQueryGenerationWithIdentifier:
rowCacheClass
_replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:error:
_destroyPersistentStoreAtURL:options:error:
_figureOutWhereExternalReferencesEndedUpRelativeTo:
_createExternalDataDictWithValueCallbacks:
initWithValueCallbacks:preserveToManyRelationships:
_forgetRowForObjectID:
_registerRow:forObjectID:options:
registerRow:forObjectID:options:
rowForObjectID:afterTimestamp:
_registerToMany:withOrderKeys:forSourceObjectID:forProperty:options:andTimestamp:
registerToMany:withOrderKeys:forSourceObjectID:forProperty:options:andTimestamp:
initWithPersistentStore:
growRegistrationCollectionTo:
forgetAllExternalData
decrementRefCountForObjectID:
incrementRefCountForObjectID:
refCountForObjectID:
registerRow:forObjectID:
registerToMany:withOrderKeys:forSourceObjectID:forProperty:andTimestamp:
toManyInformationForSourceObjectID:forProperty:afterTimestamp:
toManyForSourceObjectID:forProperty:afterTimestamp:
ancillaryOrderKeysForSourceObjectID:forProperty:afterTimestamp:
_externalData
_capacity
_externalDataValueCallbacks
_persistentStoreCacheFlags
_registerDefaultStoreClassesAndTypes
_retainedPersistentStores
valueWithPointer:
isReadableFileAtPath:
_storeClassForStoreType:
_classForPersistentStoreAtURL:
metadataForPersistentStoreOfType:URL:options:error:
_metadataForPersistentStoreOfType:URL:options:error:
_setMetadata:forPersistentStoreOfType:URL:options:error:
_routeLightweightBlock:toStore:
_isRegisteredWithUbiquity
unregisterCoordinator:
_externalDataLinksDirectory
_checkForPostLionWriter:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
initWithPersistentStoreCoordinator:andStoreOptions:forPersistentStoreOfType:atURL:
validateOptionsWithError:
stringByExpandingTildeInPath
stringByAppendingString:
_realStoreTypeForStoreWithType:URL:options:error:
ubiquityEnabled
actualStoreFileURL
_checkForSkewedEntityHashes:metadata:
setPersistentStoreCoordinator:sourceURL:configuration:metadata:options:
_gatherDataAndPerformMigration:
setStoreWasMigrated:
_addPersistentStore:identifier:
_postStoresChangedNotificationsForStores:changeKey:options:
performCoordinatorPostStoreSetup:error:
_removePersistentStore:
removeUbiquityMetadataFromStore:
_storeTypeForStore:
_retainedAllMigratedObjectsInStore:toStore:
managedObjectIDForURIRepresentation:
_destroyPersistentStoreAtURL:withType:options:error:
_replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:
result
initWithResult:type:
_exceptionNoStoreSaveFailureForError:recommendedFrame:
_coordinator_you_never_successfully_opened_the_database_corrupted:
_coordinator_you_never_successfully_opened_the_database_schema_mismatch:
_coordinator_you_never_successfully_opened_the_database_device_locked:
_coordinator_you_never_successfully_opened_the_database_missing_directory:
_coordinator_you_never_successfully_opened_the_database_no_permission:
_coordinator_you_never_successfully_opened_the_database_cant_open:
_coordinator_you_never_successfully_opened_the_database_disk_full:
_coordinator_you_never_successfully_opened_the_database_io_error:
_coordinator_you_never_successfully_opened_the_database_so_saving_back_to_it_is_kinda_hard:
_storesForRequestRoutingFrom:
_routableStoresForContext:fromStores:
_retryHandlerCount
_setRetryHandlerCount:
_introspectLastErrorAndThrow
_coordinator_no_idea_what_kind_of_request_that_was_supposed_to_be
_checkRequestForStore:withContext:originalRequest:andOptimisticLocking:
_doPreSaveAssignmentsForObjects:intoStores:
_saveRequestForStore:withContext:originalRequest:andOptimisticLocking:
_processStoreResults:forRequest:
_retainedIdentifierFromStores:
_routeHeavyweightBlock:
sharedFactory
newMetadataManagedObjectModel
setCacheFilePresenterForUbiquityRoot:
canReadFromUbiquityRootLocation:
ubiquityRootURL
initWithFilePresenter:
removeItemAtURL:error:
moveItemAtURL:toURL:error:
coordinateWritingItemAtURL:options:writingItemAtURL:options:error:byAccessor:
_registerCoreDataStoreClass:forStoreType:
registerStoreClass:forStoreType:
metadataForPersistentStoreOfType:URL:error:
setMetadata:forPersistentStoreOfType:URL:options:error:
setMetadata:forPersistentStoreOfType:URL:error:
removeUbiquitousContentAndPersistentStoreAtURL:options:error:
setMetadata:forPersistentStore:
metadataForPersistentStore:
persistentStoreForURL:
URLForPersistentStore:
migratePersistentStore:toURL:options:withType:error:
destroyPersistentStoreAtURL:withType:options:error:
replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:
_canRouteToStore:forContext:
_miniLock
_managedObjectModel
_persistentStores
sharedApplication
beginBackgroundTaskWithExpirationHandler:
endBackgroundTask:
removeObjectIdenticalTo:
managedObjectIDFromUTF8String:length:error:
arrayByAddingObject:
_canSaveGraphRootedAtObject:intoStore:withPreviouslyChecked:withAcceptableEntities:
_assignObjects:toStore:
_newObjectGraphStyleRecordForRow:andObject:withContext:
_newConflictRecordForObject:andOriginalRow:withContext:
_conflictsWithRowCacheForObject:withContext:andStore:
lockedObjects
_fetchAllInstancesFromStore:intoContext:underlyingException:
_assignObject:toPersistentStore:forConfiguration:
ubiquityStoreURLForStoreURL:ubiquityIdentityToken:localPeerID:ubiquityName:
findContainerIDForToken:storeName:haveExistingMappings:
createDefaultLocalPeerID
createActualStoreURLForStoreURL:localPeerID:containerIdentifier:andStoreName:
_setQosClassOptions:
_qosClassOptions
_setIsRegisteredWithCloudKit:
_isRegisteredWithCloudKit
_setIsRegisteredWithUbiquity:
ubiquityStoreURLForStoreURL:ubiquityIdentityToken:ubiquityName:
_disconnectAllConnections
_destroyPersistentStoreAtURL:withType:error:
_newObjectIDForEntityDescription:pk:
_contactsIdentifierForObjectID:
_objectIDForContactsIdentifier:entityName:store:
_deleteAllRowsNoRelationshipIntegrityForEntityWithAllSubentities:
_deleteAllRowsNoRelationshipIntegrityForStore:andEntityWithAllSubentities:error:
initWithCompoundValue:
_refreshTriggerValues:
_refreshTriggerValuesInStore:error:
initWithObject:changeType:
changeType
startIndexPath
finalIndexPath
startSectionInfo
finalSectionInfo
setChangeType:
setStartSectionInfo:
setFinalSectionInfo:
setFinalIndexPath:
setStartIndexPath:
_changeType
_startIndexPath
_finalIndexPath
_startSectionInfo
_finalSectionInfo
mappingsDictForConfigurationWithName:inModel:
setDatabaseUUID:
externalMapping
_cheatAndLookAtCurrentValueOfnextPK64
_storeMetadataForSaving
_databaseUUID
_nextPK64
_mappings
_initializeExtraIVars
setOptional:
setTransient:
setValidationPredicates:withValidationWarnings:
setIndexedBySpotlight:
setStoredInExternalRecord:
_validationPredicates
_validationWarnings
_propertyDescriptionFlags
_entitysReferenceIDForProperty
_setOrdered:
isSpotlightIndexed
setSpotlightIndexed:
isStoredInTruthFile
setStoredInTruthFile:
isStoredInTruth
setStoredInTruth:
_newValidatedPropertiesToUpdate:error:
_setValidatedPropertiesToUpdate:
batchUpdateRequestWithEntityName:
propertiesToUpdate
setPropertiesToUpdate:
_columnsToUpdate
_initWithDestinationName:valueExpression:
_transformValidations
_valueExpression
_propertyMappingFlags
initWithName:valueExpression:
externalNameForPropertyName:
setProperty:
_property
setPropertyName:
propertyName
_propertyName
_prerequisiteTransform
_replaceMissingValueOnly
setMaxCount:
setMinCount:
setDestinationEntity:
setDeleteRule:
setInverseRelationship:
setOrdered:
_lazyDestinationEntityName
_inverseRelationship
_lazyInverseRelationshipName
_maxCount
_minCount
_deleteRule
_versionHash:inStyle:proxyContext:
_validateValuesAreOfDestinationEntity:source:
_setLazyDestinationEntityName:
setDestinationEntityExternalName:
setForeignKeys:
setJoins:
destinationEntityExternalName
foreignKeys
joins
joinSemantic
setJoinSemantic:
_destinationEntityExternalName
_foreignKeys
_joins
_joinSemantic
refCount
_refCount
_updatedObjects
_optimisticallyLockedObjects
initWithNestingLevel:
generateTableAlias
generateSubqueryVariableAlias
generateTempTableName
_nextTableAlias
_nextVariableAlias
_nextTempTableAlias
_tableBase
_variableBase
ubiquityRootLocationPath
pathByTruncatingBeforeLibraryMobileDocuments:
createRelativePath
removeObserver:
isRootUbiquitous
createFullURL
usesCloudDocsFramework
resourceValuesForKeys:error:
statusDidChange
initWithLocation:
checkFileURLState
logWasImported
logWasScheduled
logImportWasCancelled
logWasExported
encounteredError:
recoveredFromError
isLive
isDownloaded
isDownloading
setIsDownloading:
isUploaded
isUploading
isImported
isExported
isScheduled
isFailed
error
location
numNotifications
_isLive
_isDeleted
_isDownloaded
_isDownloading
_isUploaded
_isUploading
_isImported
_isScheduled
_isExported
_isFailed
_location
_hash
_numBytes
_numNotifications
initWithEntity:propertyDescription:
_sqlTypeForAttributeType:flags:
_setSQLType:
addUniqueAttribute:
initForReadOnlyFetching
setAllowAliasing:
triggerKeys
setByAddingObject:
initForReadOnlyFetchWithExpression:
shouldIndex
isUnique
setConstrained:
isBackedByTrigger
initWithValue:sqlType:attributeDescription:allowCoercion:
setInt64:
setUnsignedInt:
int64
unsignedInt
hasObjectValue
allowsCoercion
_sqlType
_attributeDescription
_int64
mappingGenerator
newGeneratedPropertyName:
_setColumnName:
copyValuesForReadOnlyFetch:
allowAliasing
initWithColumnName:sqlType:
roughSizeEstimate
fetchIndex
_setFetchIndex:
_setSlotIfDefault:
cloneForReadOnlyFetching
_columnName
initWithPredicate:inScope:
initWithPredicate:inScope:inContext:
disambiguatingEntity
disambiguationKeypath
disambiguationKeypathHasToMany
_generateMulticlauseStringInContext:
scope
isOrScoped
setDisambiguatingEntity:withKeypath:hasToMany:
_subclauses
_disambiguatingEntity
_disambiguationKeypath
_disambiguationKeypathHasToMany
isTargetColumnsScoped
governingEntityForKeypathExpression:
adapter
sqlTypeForExpressionConstantValue:
_lastScopedItem
isSimpleKeypath:
isVariableBasedKeypathScopedBySubquery:
propertyAtEndOfKeyPathExpression:
sqlTypeForProperty:
_addBindVarForConstId:ofType:inContext:
_addBindVarForConstVal1:inContext:
_constantValue
distantPast
distantFuture
objectIDFactoryForSQLEntity:
newObjectIDForEntity:pk:
readMagicWordFromPath:
initWithManagedObjectModel:configurationName:brokenHashVersion:
coloredLoggingDefault
initWithSQLCore:
_ensureDatabaseMatchesModel
isLocalFS
setConnectionsAreLocal:
initWithSQLCore:seedConnection:
sourceEntity
newRenameTableStatementFromManyToMany:toManyToMany:orToRandomSpot:
uniqueNameWithBase:
newCreateTableStatementForManyToMany:
newCopyAndInsertStatementForManyToMany:toManyToMany:intermediateTableName:invertColumns:
newDropTableStatementForTableNamed:
connect
beginTransaction
prepareAndExecuteSQLStatement:
commitTransaction
rollbackTransaction
_checkAndRepairCorrelationTables:storeVersionNumber:usingConnection:
whitespaceCharacterSet
stringByTrimmingCharactersInSet:
fetchTableCreationSQL
manyToManyRelationships
_dissectCorrelationTableCreationSQL:
_collectSkewedComponents:usingConnection:
_repairDatabaseCorrelationTables:brokenHashModel:storeVersionNumber:recurse:usingConnection:
fetchTableNames
isRootEntity
recreateIndices
_rebuildTriggerSchemaUsingConnection:recomputeValues:error:
rawIntegerRowsForSQL:
hasCachedModelTable
saveCachedModel:
fetchMetadata
saveMetadata:
newSimplePrimaryKeyUpdateStatementForEntity:
_updateToVersion640PrimaryKeyTableUsingStatements:connection:
newComplexPrimaryKeyUpdateStatementForEntity:
_fixPrimaryKeyTableFromEntitiesAndJoinsUsingConnection:
_fixPrimaryKeyTableFromEntitiesUsingConnection:
schemaValidationConnection
canConnect
databaseIsEmpty
_doBasicTableNameCheckUsingConnection:
_checkAndRepairSchemaUsingConnection:
_doUnboundedGrowthCheckAndConstraintUsingConnection:
_cacheModelIfNecessaryUsingConnection:
_checkAndRepairTriggersUsingConnection:
_fixPrimaryKeyTablesUsingConnection:
_setMetadata:clean:
initWithBlock:context:sqlCore:
dispatchRequest:withRetries:
_loadAndSetMetadata
_loadAndSetMetadataReadOnly
_clearBinding
disconnectAllConnections
rowCacheForGeneration:
removeRowCacheForGenerationWithIdentifier:
initWithObjectID:context:sqlCore:
exception
localError
initWithObjectID:relationship:context:sqlCore:
_newValuesForRelationship:forObjectWithID:withContext:error:
initWithRequest:context:sqlCore:idSets:columnName:
setPrefetchingSubstitutionVariables:
entityForFetchRequest:
setTransactionInMemorySequence:
transactionInMemorySequence
notificationWithName:object:userInfo:
postNotification:
entityForObject:
rootEntity
initForEntitiesAndCounts:context:sqlCore:
processFetchRequest:inContext:
processCountRequest:inContext:
processSaveChanges:forContext:
processRefreshObjects:inContext:
processBatchUpdate:inContext:error:
processBatchDelete:inContext:error:
stringByDeletingPathExtension
hasAttributesWithExternalDataReferences
externalDataLinksDirectory
fetchCachedModel
setLocalError:
sanityCheckFileAtURL:error:
cachedModelWithError:
copyItemAtURL:toURL:error:
isUbiquitized
supportsComplexFeatures
initAsQueryGenerationTrackingConnectionForSQLCore:
registerNewQueryGenerationIdentifier:
_initializeQueryGenerationTrackingConnection
currentQueryGenerationIdentifier
initWithValue:store:freeValueOnDealloc:
routeStoreRequest:
initForSQLCore:
resetExternalDataReferencesDirectories
_useModel:
setExclusiveLockingMode:
newFetchUUIDSForSubentitiesRootedAt:
dropUbiquityTables
fetchUbiquityKnowledgeVector
updateUbiquityKnowledgeVector:
updateUbiquityKnowledgeForPeerWithID:andTransactionNumber:
replaceUbiquityKnowledgeVector:
allPeerRanges
addPeerRange:
addPeerRangeForPeerID:entityName:rangeStart:rangeEnd:peerRangeStart:peerRangeEnd:
createMapOfEntityNameToPKMaxForEntitiesFromUBRangeTable:
createMapOfEntityNameToPKMaxForEntitiesFromPKTable:
createMapOfEntityNameToPKMaxForEntities:
setUbiquityTableValue:forKey:
ubiquityTableKeysAndValues
ubiquityTableValueForKey:
configureUbiquityMetadataTable
databaseValue
UUID
newStatementWithSQLString:
unregisterPersistentStore:
generateSQLStatmentForSourcesAndOrderKeysForDestination:inToMany:
generateSQLStatmentForSourcesAndOrderKeysForDestination:inManyToMany:
_forceDisconnectOnError
endFetchAndRecycleStatement:
_aContextSomewhereCaresAboutGenerations
registerCurrentQueryGenerationWithStore:
initWithEntity:sqlString:
setColoredLoggingDefault:
useConcurrentFetching
relinquishPresentedItemToReader:
relinquishPresentedItemToWriter:
savePresentedItemChangesWithCompletionHandler:
accommodatePresentedItemDeletionWithCompletionHandler:
presentedItemDidMoveToURL:
presentedItemDidChange
presentedItemDidGainVersion:
presentedItemDidLoseVersion:
presentedItemDidResolveConflictVersion:
accommodatePresentedSubitemDeletionAtURL:completionHandler:
presentedSubitemDidAppearAtURL:
presentedSubitemAtURL:didMoveToURL:
presentedSubitemDidChangeAtURL:
presentedSubitemAtURL:didGainVersion:
presentedSubitemAtURL:didLoseVersion:
presentedSubitemAtURL:didResolveConflictVersion:
presentedItemURL
presentedItemOperationQueue
primaryPresentedItemURL
newForeignKeyID:entity:
newObjectIDSetsForToManyPrefetchingRequest:andSourceObjectIDs:orderColumnName:
_newRowDataForXPCFetch:variables:context:error:
externalLocationForFileWithUUID:
safeguardLocationForFileWithUUID:
_updateAutoVacuumMetadataWithValues:
_registerNewQueryGenerationIdentifier:
dispatchManager
connectionForMigration
fileProtectionLevel
isInitialized
_cacheRows:
_uncacheRows:
shouldNotifyFOKChanges
_purgeRowCache
removeUbiquityMetadata
_ubiquityDictionaryForAttribute:onObject:
recomputePrimaryKeyMaxForEntities:
_newReservedKeysForEntities:counts:
_newObjectIDForEntity:referenceData64:
_schemaValidationConnection
_dispatchManager
_generationalRowCache
_observer
_sqlCoreStateLock
_externalDataReferencesDirectory
_transactionInMemorySequence
_metadataIsClean
_sqlCoreFlags
_queryGenerationTrackingConnection
_retainedBinding
_purgeCaches:
_core
generateTableName:
_doPostModelGenerationCleanup
isColumn
columnsToFetch
toOneRelationship
isVirtual
hasSubentities
subentityMaxID
_addRootColumnToFetch:
_addColumnToFetch:
_addForeignOrderKeyForToOne:entity:
_modelHasPrecomputedKeyOrder
_recordHasVirtualToOnes
initWithEntity:inverseToMany:
_setInverseRelationship:
_addVirtualToOneForToMany:withInheritedProperty:
_useLeopardStyleHashing
_useSnowLeopardStyleHashing
_precomputedKeyOrderForEntity:
isRelationship
relationshipDescription
_setInverseManyToMany:
_generateProperties
setSuperentity:
_addIndexedEntity:
_generateIDWithSuperEntity:nextID:
sortUsingComparator:
multicolumnUniquenessConstraints
uniqueAttributes
containsIndex:
addIndexes:
_collectFKSlots:error:
setEntityForReadOnlyFetch:
initWithModel:entityDescription:
toManyRelationships
fetchIndexForKey:
columnsToCreate
virtualForeignKeyColumns
hasInheritance
isKindOfSQLEntity:
_sqlPropertyWithRenamingIdentifier:
_generateInverseRelationshipsAndMore
_organizeConstraints
_generateMulticolumnUniquenessConstraints
_entityIsBroken:
_toOneRange
addPropertiesForReadOnlyFetch:keys:context:
propertyMapping
_hasAttributesMonitoredByTriggers
_hasAttributesBackedByTriggers
_entityDescription
_propertyAllCache
_propertiesAllToManysCache
_propertyManyToManyCache
_columnsToFetch
_ekColumns
_fkColumns
_fokColumns
_attrColumns
_virtualFKs
_primaryKey
_entityKey
_optLockKey
_mappingGenerator
_entityID
_subentityMaxID
_uniqueAttributes
_multicolumnUniquenessConstraints
_fetch_entity_plan
_odiousHashHackStorage
_sqlentityFlags
attributes
initWithExpression:allowToMany:inScope:
_allowToMany
setLimitIntermediate:
selectIntermediate
setFetchColumns:
setUseDistinct:
setIsCount:
isFunctionScoped
setJoinType:
whereIntermediate
_promoteJoinsForSubqueryScopedKeypaths
_generateJoinSQLStringInContext:
fetchIntermediateForKeypathExpression:
fetchIntermediate
isDictionaryCountFetch
setDictionaryCountFetch:
setSelectIntermediate:
groupByIntermediate
setGroupByIntermediate:
addGroupByKeypath:
groupByClauseContainsKeypath:
havingIntermediate
setHavingIntermediate:
setOffsetIntermediate:
addJoinIntermediate:atKeypathWithComponents:
finalJoinForKeypathWithComponents:
promoteToOuterJoinsAlongKeypathWithComponents:
promoteToOuterJoinAtKeypathWithComponents:
joinIntermediates
selectDistinct
_selectClause
_groupByClause
_havingClause
_offsetClause
_groupByKeypaths
_isDictionaryCountFetch
_joinIntermediates
_joinKeypaths
uppercaseString
_setName:
initWithEntity:foreignKey:
initForReadOnlyFetchingOfEntity:toOneRelationship:
setFKForReadOnlyFetch:
_foreignKey
initWithEntity:toOneRelationship:
_toOne
_addBindVarForConstVal2:inContext:
initWithConstantValue:inScope:
count:
max:
min:
average:
sum:
_generateSQLForConstantValue:inContext:
isUpdateScoped
_generateUncorrelatedSubqueryStringWithSymbol:forAttribute:inContext:
_generateCorrelatedSubqueryStringWithSymbol:forExpression:inContext:
_generateArgumentStringForCollection:inContext:
_generateSQLForSubqueryExpression:trailingKeypath:inContext:
_functionExpressionIsSubqueryFollowedByKeypath:
onlyFetchesAggregates
_generateSelectForAggregateStringWithSymbol:argument:inContext:
isHavingScoped
function
generateType1SQLString:inContext:
uppercase:
generateType2SQLString:inContext:
lowercase:
onesComplement:
generateType3SQLString:keypathOnly:inContext:
abs:
noindex:
_generateType4SQLForSymbol:inContext:
_generateSQLForCountInContext:
add:to:
_generateMathStringWithSymbol:inContext:
from:subtract:
multiply:by:
divide:by:
modulus:by:
bitwiseAnd:with:
bitwiseOr:with:
leftshift:by:
rightshift:by:
distinct:
_generateDistinctStringInContext:
_generateNowStringInContext:
length:
_generateLengthStringInContext:
functionIsAcceptableAsAggregate:
_knownPrimaryKeyForObjectID:
_knownEntityKeyForObjectID:
_hasOrderKeys
numberWithLong:
_populateOrderKeysUsingSnapshot:orderKeys:newIndexes:reorderedIndexes:
_populateOrderKeysInOrderedSet:usingSourceObjectID:inverseRelationship:newIndexes:reorderedIndexes:
_orderKeyForObject:
_orderKeyForObject:fromSourceObjectID:inverseRelationship:inOrderedSet:
initWithArray:range:copyItems:
inverseToOne
_updateOrderKeysFromOrderOfObjectIDs:
createNestedObjectFaultContextForObjectWithID:
setForeignOrderKeySlot:orderKey:
_registerChangedFOKs:deletions:forSourceObject:andRelationship:
setForeignKeySlot:int64:
initForRelationship:
_newOrderKeys
_newRowCacheRowForToManyUpdatesForRelationship:rowCacheOriginal:originalOrderKeys:originalSnapshot:value:added:deleted:sourceRowPK:properties:sourceObject:newIndexes:reorderedIndexes:
_findOrCreateChangeSnapshotForGlobalID:
isMaster
_correlationTableUpdateTrackerForRelationship:
trackInserts:deletes:reorders:forObjectWithID:
trackReorders:forObjectWithID:
_knownPrimaryKeyForObject:
_knownEntityKeyForObject:
setForeignEntityKeySlot:entityKey:
_knownOrderKeyForObject:from:inverseToMany:
_addExternalReferenceDataToDelete:
_createdByUbiquityImport
initForExternalLocation:safeguardLocation:data:protectionLevel:
_addExternalReferenceDataToSave:
_recordToManyChangesForObject:inRow:usingTimestamp:inserted:
allocForSQLEntity:
initWithSQLEntity:objectID:
_entityForObject:
_populateRow:fromObject:timestamp:inserted:
_prepareForDeletionOfExternalDataReferencesForObject:
_createCorrelationTrackerUpdatesForDeletedObject:
_createRowsForSave
_computeUpdatedRowSplit
getObjects:andKeys:count:
saveRequest
savingContext
newObjectsForFastLockConflictDetection
newObjectsForExhaustiveLockConflictDetection
newObjectsForUniquenessConflictDetectionGivenReportedFailures:
newRowsToRemoveFromRowCache
newRowsToAddToRowCache
newPrimaryRowsUpdatedForRowCache
newAncillaryRowsUpdatedForRowCache
newCorrelationTableUpdates
foreignOrderKeysBeingUpdated
foreignOrderKeysBeingDeleted
externalDataReferencesToSave
externalDataReferencesToDelete
_changeCache
_insertCache
_toManyCache
_rowsToDelete
_updatedByRequest
_updatedByForeignKey
_updatedFOKRowsInCurrentSave
_deletedFOKRowsInCurrentSave
_externalDataReferencesToSave
_externalDataReferencesToDelete
initWithUnsignedInt:
_predicateRestrictingSuperentitiesForEntity:
_predicateRestrictingToSubentitiesForEntity:
andPredicateWithSubpredicates:
_predicateForSpecificEntity:
governingAlias
initWithEntity:alias:fetchColumns:inScope:
setWhereIntermediate:
initWithSortDescriptors:inScope:
setOrderIntermediate:
initWithLimit:inScope:
initWithOffset:inScope:
initWithProperties:inScope:
allModifierPredicates
initWithEntity:alias:inScope:
generateWhereIntermediatesInContext:
generateGroupByIntermediatesForProperties:inContext:
generateHavingIntermediateForPredicate:inContext:
generateSelectIntermediateInContext:
generateOrderIntermediateInContext:
generateIntermediateForLimit:inContext:
limitIntermediate
generateIntermediateForOffset:inContext:
initWithFetchIntermediate:inScope:
setUpdateColumnsIntermediate:
initWithEntity:inScope:
generateUpdateColumnsIntermediateInContext:
updateColumnsIntermediate
predicateForRequestInContext:
initializeContextForRequest:ignoreInheritance:nestingLevel:
prefetchingSubstitutionVariables
initializeContextForFetchRequest:ignoreInheritance:nestingLevel:nestIsWhereScoped:requestContext:
initializeContextForUpdateRequest:
newStatementWithEntity:
setImpossibleCondition:
setSQLString:
generateIntermediatesForFetchInContext:countOnly:
generateIntermediatesForUpdateInContext:
setBindIntarrays:
setBindVariables:
cacheFakeEntityForFetch:
setCachedStatementInfo:
cacheStatement:
newSQLStatementForRequest:ignoreInheritance:countOnly:nestingLevel:nestIsWhereScoped:requestContext:
newSQLStatementForFetchRequest:ignoreInheritance:countOnly:nestingLevel:nestIsWhereScoped:requestContext:
newSQLStatementForUpdateRequest:
_persistentStore
initWithURI:
newUserInfoFromException:
archiver:willEncodeObject:
initWithManagedObjectModel:configurationName:
retainedConnection
disconnectConnection:
sendMessage:fromContext:interrupts:error:
remoteStoreChangedNotificationName
setupRemoteStoreObserver
propertyListWithData:options:format:error:
_setMetadata:includeVersioning:
newSecureArchivedDataWithRootObject:
date
_decodeResultSetData:forFetchRequest:options:store:context:rowCacheRows:error:
cacheFetchedRows:forManagedObjects:generation:
decodePrefetchArray:forSources:context:
encodeForXPC
decodeResults:forFetch:context:error:
_cacheNodePropertiesFromObject:
initWithObjectID:withValues:version:
encodeObjectValues:options:store:
encodeObjectsForSave:forDelete:
encodeSaveRequest:forceInsertsToUpdates:
_commitChangesForRequest:
_executeSaveRequest:forceInsertsToUpdates:withContext:interrupts:error:
isReferencingStore:
executeSaveRequest:withContext:error:
executeFetchRequest:withContext:error:
executePullChangesRequest:withContext:error:
classesForSaveArchive
_createAndCacheRowForObjectWithID:propertyValues:inContext:error:
decodeResults:forFaultOfObjectWithID:context:error:
decodeValue:forRelationship:onSource:inContext:error:
cacheContents:ofRelationship:onObjectWithID:generation:
unarchiver:didDecodeObject:
serviceName
_sanityCheckToken
_myConnection
_identifier
_remoteStoreChangedNotificationName
processName
cacheContents:ofRelationship:onObjectWithID:withTimestamp:generation:
decodePrefetchResult:forSources:context:
initWithObjectID:fromSQLRow:
updateFromSQLRow:
setSQLCore:
_cachedRowForRelationship:onObjectWithID:generation:
_updateRollbackCacheForObjectWithID:relationship:withValuesFrom:
isWhereScoped
expressionIsBasicKeypath:
keypathExpressionIsSafeLHSForIn:
_entitySpecificationKeypath
_setEntitySpecificationKeypath:
_promoteJoinsForSubqueryScopedKeypath:
promoteJoinsInKeypathsForExpression:
trueExpression
falseExpression
_promoteJoinsForKeypathExpression:
_promoteJoinsForFunctionExpression:
_promoteJoinsForAggregateExpression:
_promoteJoinsForTernaryExpression:
_generateSQLForKeyPathExpression:allowToMany:inContext:
_generateSQLForConstantCollection:inContext:
_generateSQLForVariableExpression:allowToMany:inContext:
_canDoASubselectForExpression:inContext:
bindVariables
_generateSQLForFunctionExpression:allowToMany:inContext:
_generateSQLForExpressionCollection:allowToMany:inContext:
_generateSQLForFetchExpression:allowToMany:inContext:
_generateSQLForTernaryExpression:allowToMany:inContext:
isSimpleNoIndexFunction:
_scope
isPrimaryKey
newGeneratorWithStatement:
cachedStatement
_statementForFetchRequestContext:ignoreInheritance:countOnly:nestingLevel:
newStatementWithoutEntity
typeStringForColumn:
_generateFragmentsForEntity:inArray:
columnSQLType
typeStringForSQLType:
orderColumnSQLType
newCreateIndexStatementForColumnWithName:inTableWithName:
newCreateIndexStatementForColumn:
newCreateIndexStatementForCorrelationTable:
newCreateIndexStatementForColumns:
createSQLStatementsForTriggerAttribute:withSQLEntity:
stringByReplacingOccurrencesOfString:withString:
createSQLStatementsForRTreeTriggersForLocationAttribute:withSQLEntity:andDerivedLatitude:andDerivedLongitude:existingRtreeTables:
generateCorrelationTableTriggerStatementsForRelationship:existing:correlationTableTriggers:error:
generateTriggerForEntity:alreadyCreated:correlations:fragments:error:
createCleanupSQLForRelationship:existing:correlationTableTriggers:error:
generateTriggerStatementsForEntity:usingRelationshipCleanupSQL:error:
fetchRequestForObjectsToDelete
affectedObjectIDs
newSelectStatementWithFetchRequest:ignoreInheritance:
stringByReplacingCharactersInRange:withString:
isImpossibleCondition
setTrackChangedRowCount:
bindIntarrays
_cachedTriggersForEntity:
_cacheTriggers:forEntity:
generateSubselectForColumn:givenObjects:
rtreeTableNameForEntity:attribute:
generateStatementForCheckingUniqueAttributesOnObjects:usingModel:
generateStatementForCheckingMulticolumnConstraint:onObjects:usingModel:
sqliteVersion
newInsertStatementWithRow:
newUpdateStatementWithRow:originalRow:withMask:
newConstrainedValuesUpdateStatementWithRow:
newDeleteStatementWithRow:
newSelectStatementWithFetchRequestContext:ignoreInheritance:
newCountStatementWithFetchRequestContext:
newCorrelationInsertStatementForRelationship:
newCorrelationDeleteStatementForRelationship:
newCorrelationMasterReorderStatementForRelationship:
newCorrelationMasterReorderStatementPart2ForRelationship:
newCorrelationReorderStatementForRelationship:
newCreateTableStatementForEntity:
newCreatePrimaryKeyTableStatement
newPrimaryKeyInitializeStatementForEntity:withInitialMaxPK:
newRenameTableStatementFrom:to:
newCreateIndexStatementsForEntity:
newCreateTriggersForEntity:existingRtreeTables:
generateDeleteStatementsForRequest:error:
_sqlCore
_cachedDeleteTriggersByEntity
releaseSQLStatement
clearCachedStatements
_ensureNoStatementPrepared
_ensureNoFetchInProgress
_ensureDatabaseOpen
_fetchMaxPrimaryKeyForEntity:
isOpen
openAtPath:handle:flags:module:
createTableForEntity:
createManyToManyTablesForEntity:
createIndexesForEntity:
createTriggersForEntities:
_executeSQLString:
performIntegrityCheck
query
absoluteString
setDictionary:
compare:options:
_databaseOpenURLStringForURL:
_registerExtraFunctions
_restoreBusyTimeOutSettings
_configureSynchronousMode
hasMetadataTable
_configureIntegrityCheck
createSchema
_configurePragmaOptions:createdSchema:
cachedSQLiteStatement
forceTransactionClosed
_clearTransactionCaches
_clearCachedStatements
_finalizeStatement
hasOpenTransaction
_ensureNoTransactionOpen
prepareSQLStatement:
cacheCurrentDBStatementOn:
resetSQLStatement
transactionDidBegin
_setupVacuumIfNecessary
transactionDidCommit
transactionDidRollback
statementCacheForEntity:
insertStatement
setCachedSQLiteStatement:forConnection:
cacheInsertStatement:
addVMCachedStatement:
_bindVariablesWithInsertedRow:
execute
_clearBindVariablesForInsertedRow
_rowsChangedByLastExecute
debugLogLevel
newUpdateMaskFrom:
cachedUpdateStatementForEntity:andDeltasMask:
cacheUpdateStatement:forEntity:andDeltasMask:
_bindVariablesWithUpdatedRow:andOriginalRow:forDeltasMask:
_clearBindVariablesForUpdateStatement:forDeltasMask:
cachedUpdateConstrainedValuesStatmentForEntity:
cacheUpdateConstrainedValuesStatement:forEntity:
_bindVariablesForConstrainedValuesWithRow:
_clearBindVariablesForConstrainedValuesUpdateStatement:
deletionStatement
cacheDeletionStatement:
_bindVariablesWithDeletedRow:
hasInserts
correlationInsertStatementForRelationship:
cacheCorrelationInsertStatement:forRelationship:
executeCorrelationChangesForValue1:value2:value3:value4:
enumerateInsertsUsingBlock:
hasDeletes
correlationDeleteStatementForRelationship:
cacheCorrelationDeleteStatement:forRelationship:
enumerateDeletesUsingBlock:
hasMasterReorders
correlationMasterReorderStatementForRelationship:
cacheCorrelationMasterReorderStatement:forRelationship:
enumerateMasterReordersUsingBlock:
correlationMasterReorderStatementPart2ForRelationship:
enumerateMasterReordersPart2UsingBlock:
hasReorders
correlationReorderStatementForRelationship:
cacheCorrelationReorderStatement:forRelationship:
enumerateReordersUsingBlock:
writeCorrelationInsertsFromTracker:
writeCorrelationDeletesFromTracker:
writeCorrelationMasterReordersFromTracker:
writeCorrelationReordersFromTracker:
bindTempTableForBindIntarray:
bindTempTablesForStatementIfNecessary:
_endFetch
isFetchInProgress
setIntarrayTableName:
setIntarrayTable:
intarrayTable
intarrayTableName
sqlStatement
rangeValue
_bytesPtrForStore
_bytesLengthForStore
setColumnsToFetch:
_clearOtherStatements
initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:
stringWithFileSystemRepresentation:length:
ubiquitousExternalReferenceLocationForUUID:inStore:
initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:ubiquitousLocation:
valueWithRange:
_newValueForColumn:atIndex:inStatement:
handleCorruptedDB:
entityForID:
newFetchedArray
createMetadata
dataWithPropertyList:format:options:error:
metadataColumns
_hasTableWithName:
_decompressedModelWithData:
createCachedModelTable
_compressedDataWithModel:
fetchMaxPrimaryKeyForEntity:
_configurePageSize
_configureAutoVacuum
willCreateSchema
didCreateSchema
createTablesForEntities:
createPrimaryKeyTableForModel:knownEmpty:
_getCurrentAutoVacuumValue
isEqualToNumber:
rangeStart
rangeEnd
peerStart
peerEnd
initWithOwningPeerID:entityName:rangeStart:rangeEnd:peerStart:peerEnd:
initWithLongLong:
attributesOfItemAtPath:error:
_ensureWalFileExists
beginReadTransaction
_currentQueryGenerationIdentifier:
_freeQueryGenerationIdentifier:
registerCurrentQueryGenerationWithStore:retries:
indexOfObjectPassingTest:
adoptQueryGenerationIdentifier:
_performPostSaveTasks
_setDebugFlags:
__INode_Changed_AllThatIsLeftToUsIsHonor__
connectionManager
queue
_isQueryGenerationTrackingConnection
isWriter
setIsWriter:
insertRow:
prefetchRequestCache
updateRow:forRequestContext:
updateConstrainedValuesForRow:
deleteRow:forRequestContext:
uncacheVMStatement:
writeCorrelationChangesFromTracker:
selectRowsWithStatement:cached:
selectCountWithStatement:
fetchResultSet:usingFetchPlan:
rowsChangedByLastStatement
_vmstatement
generatePrimaryKeysForEntity:batch:
hasPrimaryKeyTable
_buffersForRegisteredFunctions
executeAttributeUniquenessCheckSQLStatement:returningColumns:
executeMulticolumnUniquenessCheckSQLStatement:returningColumns:
triggerUpdatedRowInTable:withEntityID:primaryKey:columnName:newValue:
_workingURL
_dbPath
_transactionIsOpen
_useSyntaxColoredLogging
_sqlStatement
_metadataColumns
_rowsProcessedCount
_lastEntityKey
_finalEntity
_lastEntity
_fetchPKStatement
_updatePKStatement
_beginStatement
_commitStatement
_rollbackStatement
_vmCachedStatements
_pragmaSettings
_mObjectIDsUpdatedByTriggers
_statementCachesByEntity
_cachedEntityUpdateStatements
_cachedEntityConstrainedValuesUpdateStatements
_timeOutOption
_timeOutIncrement
_extraBuffersForRegisteredFunctions
_dbPathRegisteredWithBackupd
_vacuumTracker
_temporaryTables
_sqliteConnectionFlags
_debugInode
_activeGenerations
operatorWithType:modifier:options:
performOperationUsingObject:andObject:
retainedLocale
lengthOfBytesUsingEncoding:
_workBlock
destinationAlias
initForRelationship:sourceAlias:destinationAlias:correlationAlias:direct:inScope:
createToOneJoinIntermediateForProperty:lastStep:inScope:context:
createToManyJoinIntermediateForProperty:lastStep:inScope:context:
createManyToManyJoinIntermediateForProperty:direct:lastStep:inScope:context:
sourceAlias
setSourceAlias:
_generateToOneSQLStringInContext:
_generateToManySQLStringInContext:
_generateManyToManySQLStringInContext:
createJoinIntermediatesForKeypath:startEntity:startAlias:forScope:inStatementIntermediate:inContext:
isDirect
setDirect:
setDestinationAlias:
correlationAlias
joinType
_sourceAlias
_destinationAlias
_correlationAlias
_direct
_propertyDescriptionForKeypath:startingAtEntity:allowToMany:lastKeyVisited:inContext:
_propertyDescriptionsForKeypath:rootedAtEntity:allowToMany:lastKeyVisited:inContext:
_generateSQLForProperty:startEntity:startAlias:keypath:inContext:
substitutePK
setSubstitutePK:
_substitutePK
inverseManyToMany
_setCorrelationTableName:
_setOrderColumnName:
isTableSchemaEqual:
_correlationTableName
_orderColumnName
_runSanityCheckForModel:
_generateModel:error:
initWithManagedObjectModel:configurationName:retainHashHack:brokenHashVersion:
_entityMapping
_sqlEntityWithRenamingIdentifier:
_retainHashHack
_mom
_entitiesByName
_entityDescriptionToSQLMap
_brokenHashVersion
_retainLeopardStyleDictionaries
_hasVirtualToOnes
ascending
governingEntity
_generateSQLForOrderedManyToManyInverse:inContext:
_generateSQLForOrderedToManyInverse:inContext:
comparator
localizedCompare:
localizedCaseInsensitiveCompare:
localizedStandardCompare:
fetch_request
cached_sql_statement
requested_batch_size
sql_core
sql_model
statement_entity
current_context
row_cache
entity_for_ek_funptr
flags
fetchPlan
fetchStatement
totalUnitCount
isCancelled
useColoredLogging
sqlModel
newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:
storeIsUbiquitized
ubiquitousExternalReferenceLocationForUUID:
initWithSQLEntity:ownedObjectID:andTimestamp:
addFaultsThatWereFired:
environment
initWithMachServiceName:
serviceListener
setDelegate:
initWithOptions:
initWithKeyPointerFunctions:valuePointerFunctions:capacity:
willPerformRecoveryForError:fromContext:
performRecoveryForError:fromContext:
errorIsPlausiblyAnSQLiteIssue:
setupRecoveryForConnectionContext:ifNecessary:
_createCoordinator
removeCachesForConnection:
retainedCacheForConnection:
setExportedObject:
setExportedInterface:
currentConnection
shouldAcceptConnectionsFromClientWithContext:
handleMetadataRequestInContext:
handleFetchRequest:inContext:error:
handleSaveRequest:inContext:error:
handleObtainRequest:inContext:error:
handleFaultRequest:inContext:error:
handleRelationshipFaultRequest:inContext:error:
handleNotificationNameRequestInContext:error:
handlePullChangesRequest:inContext:error:
handleQueryGenerationRequestInContext:error:
handleQueryGenerationReleaseRequest:inContext:error:
initForStoreWithURL:usingModelAtURL:options:policy:
errorHandlingDelegate
setErrorHandlingDelegate:
startListening
requestHandlingPolicy
listener:shouldAcceptNewConnection:
_modelURL
_storeURL
_entitlementNames
_listener
_policy
_connectionToCoordinatorMap
initWithValue:store:
localGenerationForXPCToken:withContext:
processObtainRequest:inContext:error:
shouldAcceptMetadataChangesFromClientWithContext:
restrictingWritePredicateForEntity:fromClientWithContext:
_populateObject:withValuesFromClient:
processRequest:fromClientWithContext:error:
unpackQueryGeneration:withContext:
processFaultForRelationshipWithName:onObjectWithID:fromClientWithContext:error:
processFaultForObjectWithID:fromClientWithContext:error:
decodeFromXPCArchive:withContext:
processPullChangesRequest:fromClientWithContext:error:
XPCEncodableGenerationTokenForOriginal:inContext:
visitPredicateOperator:
keypaths
subqueries
setExpressions
_compoundPredicate
_allModifierPredicates
_setExpressions
_subqueries
initWithSQLCore:priority:seedConnection:
handleStoreRequest:
scheduleBarrierBlock:
initializationConnection
scheduleConnectionsBarrier:
cacheFaultingStatement:
createCorrelationCacheDictionary
insertOrReplaceStatement:forRelationship:inDictionary:
faultingStatement
cacheCorrelationMasterReorderStatementPart2:forRelationship:
preparedFaultingCachesForRelationship:
cacheFaultingStatement:andFetchRequest:forRelationship:
_insertStatementCache
_deletionStatementCache
_faultingStatementCache
_toManyRelationshipStatementCache
_correlationInsertCache
_correlationDeleteCache
_correlationMasterReorderCache
_correlationMasterReorderCachePart2
_correlationReorderCache
sqlTypeString
setPropertyDescription:
isAttribute
isForeignKey
isForeignEntityKey
isForeignOrderKey
isEntityKey
isOptLockKey
_propertyDescription
_fetchIndex
_slot
variable
initForReadOnlyFetchWithEntity:propertyDescription:
inverseOrderKey:
resolveVariableExpression:inContext:
_onlyFetchesAggregates
_variableToAliasMappings
_propertyToAliasMappings
_setForeignOrderKey:
_inverse
newBatchAllocation:count:withOwnedObjectIDs:
newObjectIDForToOne:
_validateToOnes
newColumnMaskFrom:columnInclusionOptions:
setObjectID:
_debug
initForCorrelationTarget:alias:fetchColumns:inScope:
setColumnAlias:
setFetchEntity:
_entityAlias
_correlationTarget
_fetchColumns
_useDistinct
_columnAlias
_isCount
_isNilExpression:
_generateSQLType3InContext:
_sqlTokenForPredicateOperator:inContext:
_cfStringOptionsFromPredicateOptions:
insertString:atIndex:
_generateSQLForString:expressionPath:wildStart:wildEnd:allowToMany:inContext:
_upperBoundSearchStringForString:context:
_generateSQLSubstringWildStart:wildEnd:inContext:
_entityDestinationIfKeyOfSomeSort:
_prefetchSourceOfUnidirectionalVirtualInverse:
_generateSQLForConstKeyArray:targetEntity:reboundFrom:inContext:
_generateSQLForConst:inManyToMany:expression:inContext:
_generateSQLForConst:inToMany:inContext:
_generateSQLForConst:inAttribute:expression:inContext:
initWithWorkingEntity:target:bounds:scope:
stringByAppendingFormat:
_generateSQLType1InContext:
_generateSQLType2InContext:
_generateSQLForMatchingOperator:inContext:
_generateSQLBeginsWithStringInContext:
_generateSQLEndsWithStringInContext:
_generateSQLContainmentStringInContext:
_generateSQLBetweenStringInContext:
_generateSQLBoundByStringInContext:
_generateSQLForWildSubStringForGlob:wildStart:wildEnd:
_comparisonPredicateScopedItem
_effectiveLeftExpression
_effectiveRightExpression
removeAllBindVariables
addBindIntarray:
removeAllBindIntarrays
fakeEntityForFetch
cachedStatementInfo
trackChangedRowCount
_bindVariables
_bindIntarrays
_isImpossibleCondition
_trackChangedRowCount
_fakeEntityForFetch
_cachedStatementInfo
_cachedSQLiteStatement
newUniqueNameWithBase:withLength:
_names
checkPredicate:
_foundKeypath
_isKeypathScopedToSubquery:
setGoverningAlias:
setCorrelationToken:
_setVariableColumn:
setGoverningEntity:
canDoDirectJoinGivenPredicate:
_createCollectionJoinsForFetchInContext:
_createSelectClauseInFetchWithContext:
_trailingKeypath
_variableExpression
_fetchIntermediate
_selectFromEntity
_selectFromCorrelationTarget
_selectEntityAlias
_governingEntityForVariable
_variableColumn
_variableAlias
_targetColumn
_targetAlias
_keypathsToPromote
_hasTrailingFunction
_onlyTrailIsCount
_subqueryHasTruePredicate
_generation
createNestedFetchRequestContextForFetch:
newSelectStatementForFetchRequest:
initWithRequest:connection:context:sqlCore:parentContext:
_createStatement
_setFetchStatement:
_cachedInfoForRequestor:
_cacheInfo:forRequestor:
_setupBindVariablesForCachedStatement:usingValues:
_fireFaultsForValue:
enumerateObjectsUsingBlock:
_preparePredicate:
objectIDsToRegisterWithContext
persistRows:
createChildContextForNestedFetchRequest:
addObjectIDsToRegister:
addObjectsToAwaken:
objectsToAwaken
sqlEntityForFetchRequest
isFaultRequest
setIsFaultRequest:
originalRequest
shouldUseBatches
faultsThatWereFired
_sqlModel
_sqlEntity
_fetchPlan
_objectIDsToRegister
_objectsToAwaken
_resultFaultsThatWereFired
_parentContext
_fileProtectionLevel
_isFaultRequest
_originalRequest
_shouldUseBatches
_storeIsUbiquitized
_statementInitialized
_concurrentFetchingPipelineRows
_prefetchingSubstitutionVariables
_idSets
initWithEntity:propertyDescription:virtualForToMany:
_foreignEntityKey
_foreignOrderKey
_isVirtual
_relatedNodes
_map
_entityName
restrictingReadPredicateForEntity:fromClientWithContext:
processFetchResults:prefetchedObjects:ofType:
prefetchRelationships:forFetch:sourceOIDs:fromClientWithContext:
_coreFaultForObjectWithID:fromClientWithContext:error:
_coreProcessFetchRequest:fromClientWithContext:error:
processRelationshipSourceObjectID:fromClientWithContext:error:
notPredicateWithSubpredicate:
processFetchRequest:fromClientWithContext:error:
processSaveRequest:fromClientWithContext:error:
restrictingPullChangeHistoryPredicateForEntity:fromClientWithContext:
_prefetchRelationshipKey:sourceEntityDescription:sourceObjectIDs:prefetchRelationshipKeys:inContext:
getIDsForEntity:count:inContext:error:
pointerFunctionsWithOptions:
setExternalName:
_externalName
capitalizedString
mappingForAttribute:forConfigurationWithName:
mappingForRelationship:forConfigurationWithName:
primaryKeyForEntity:
joinsForRelationship:
mappingForEntity:forConfigurationWithName:
mappingsForConfigurationWithName:inModel:
internalNameForEntityName:version:
internalNameForPropertyName:version:
_managedObjectReferenceURI
_aggregatedResult
_resultType
resourceBundles
sourceType
sourceOptions
sourceMetadata
setSourceMetadata:
destinationURL
destinationType
migrateStoreAtURL:toURL:storeType:options:withManager:error:
migrationStoreOptionsFromStoreOptions:
sourceModelForStoreAtURL:metadata:error:
createMigrationManagerForSourceModel:destinationModel:error:
migrateStoreAtURL:withManager:metadata:options:error:
_sourceURL
_sourceConfiguration
_sourceOptions
_sourceMetadata
_destinationURL
_destinationType
_destinationConfiguration
_destinationOptions
_resourceBundles
_workingWithSkewedSource
URLForDirectory:inDomain:appropriateForURL:create:error:
sourceConfiguration
sourceURL
stringByAppendingPathExtension:
externalDataReferencesURLForDestination:forStoreOfType:
setSourceModel:
mappingModelForSourceModel:destinationModel:error:
setMappingModel:
destinationOptionsForMigration:sourceMetadata:error:
setDestinationOptions:
destinationOptions
destinationTypeForMigration:sourceMetadata:error:
setDestinationType:
setMigrationManager:
migrationManager
destinationURLForMigrationSourceURL:createDocumentReplacementDirectory:error:
setDestinationURL:
willPerformMigrationWithManager:
handleMigrationError:inManager:
didPerformMigrationWithManager:
destinationConfiguration
addMigratedStoreToCoordinator:withType:configuration:URL:options:error:
setSourceURL:
setSourceConfiguration:
setSourceOptions:
setDestinationConfiguration:
destinationConfigurationForMigration:sourceMetadata:error:
setResourceBundles:
initWithBytes:
bits
_counter
_uuid128
_ensureLocalizationDictionaryIsInitialized
_localizedStringForKey:value:
_cachedObjectForKey:value:
_localizedPropertyNameForProperty:entity:
_localizationBundle
_modelStringsFileName
_localizationDictionary
_hasSetLocalizationDictionary
_mergedPolicies
_keyPathContainsNonPersistedProperties:
_managedObjectContextDidSave:
controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:
controller:didChangeSection:atIndex:forChangeType:
controllerDidChangeContent:
controllerWillChangeContent:
controller:sectionIndexTitleForSectionName:
_managedObjectContextDidChange:
_managedObjectContextDidChangeObjectIDs:
_restoreCachedSectionInfo
_computeSectionInfo:error:
_recursivePerformBlockAndWait:withContext:
indexAtPosition:
_sectionNameForObject:
indexPathWithIndexes:length:
sectionIndexTitles
_CoreDataSectionCachesPath
_set__PF_LINKEDAFTERNORTHSTAR:
_set__PF_LINKEDAFTERWILDCAT:
_set__PF__SkipSimulatorAsserts:
deleteCacheWithName:
initWithFetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:
performFetch:
objectAtIndexPath:
indexPathForObject:
sectionIndexTitleForSectionName:
sections
sectionForSectionIndexTitle:atIndex:
sectionNameKeyPath
cacheName
_sectionNameKeyPath
_sectionNameKey
_cacheName
_sortKeys
_sectionsByName
_sectionIndexTitles
_sectionIndexTitlesSections
_sectionCachePath
initWithContentsOfMappedFile:
dictionaryWithObjects:forKeys:
_computeSectionInfoWithGroupBy:error:
_resolveSectionIndexTitleForSectionName:
_makeMutableFetchedObjects
_indexOfFetchedID:
_objectInResults:
_createNewSectionForObject:
_insertIndexForObject:inArray:lowIdx:highIdx:sortDescriptors:
_insertObjectInFetchedObjects:atIndex:
_updateSectionOffsetsStartingAtSection:
_indexPathForIndex:
_sectionNumberForIndex:
_removeObjectInFetchedObjectsAtIndex:
_updateFetchedObjectsWithDeleteChange:
_updateFetchedObjectsWithInsertChange:
_fetchedObjectsArrayOfObjectIDs
_preprocessInsertedObjects:insertsInfo:newSectionNames:
_preprocessDeletedObjects:deletesInfo:sectionsWithDeletes:
_preprocessUpdatedObjects:insertsInfo:deletesInfo:updatesInfo:sectionsWithDeletes:newSectionNames:treatAsRefreshes:
_updateFetchedObjectsWithInsertedObjects:deletedObjects:updatedObjects:
filteredSetUsingPredicate:
_lowerMoveOperationsToUpdatesForSection:withInsertedObjects:deletedObjects:updatedObjects:
_core_managedObjectContextDidChange:
_appendAffectedStoreInfoToData:adjustedOffset:
_updateCachedStoreInfo
bundleIdentifier
compareObject:toObject:
_hasFetchedObjects
_dumpSectionInfo
_generateSQLForPredicate:inContext:
_populateSQLValuesByPropertyFromTransforms:migrationContext:
_populateSQLValuesForVirtualToOnesWithMigrationContext:
entityMigrationDescriptionForEntity:
entityMapping
_populateSQLValuesForDestinationToOne:fromSourceToOne:
_unmappedRelationshipForFormerlyVirtualToOne:migrationContext:
_generateSQLValueMappingsWithMigrationContext:
initWithEntityMapping:sourceEntity:destinationEntity:
sourceEntitiesByToOneWithNewEntityKey
sqlValueForColumnName:migrationContext:
addedManyToManys
removedManyToManys
transformedManyToManys
nextPropertyTransform
migrationType
_sqlValuesByColumnName
_sourceEntitiesByToOneWithNewEntityKey
_dstEntity
_srcEntity
_migrationType
_addedManyToManys
_removedManyToManys
_transformedManyToManys
_processedTransforms
_pendingTransforms
_intarrayTable
_intarrayTableName
orderIntermediate
_updateColumns
_originalRootsForAddedEntity:
createEntityMigrationStatements
createStatementsForUpdatingEntityKeys
generatePKTableUpdateStatements
_annotatesMigrationMetadata
validateMigratedDataFromEntityMapping:error:
_countNullsInColumn:forEntity:
_countUnreferencedPrimaryKeysForEntity:inForeignKeyColumnName:fromTable:
validateMandatoryAttribute:onEntity:error:
validateMandatoryRelationship:onEntity:error:
_populateTableMigrationDescriptions
appendStatementsToRenameTables:migrationContext:
appendStatementsToCreateOrDropTables:migrationContext:
appendStatementsToPerformMigration:migrationContext:
appendStatementsToCompleteMigration:migrationContext:
_determinePropertyDependenciesOnIDForEntity:
_determineReindexedEntitiesAndAffectedProperties
_populateEntityMigrationDescriptionsAndEntityMap
_addEntityMigration:toTableMigrationForRootEntity:tableMigrationType:
initWithRootEntity:migrationType:
addEntityMigrationDescription:
_setAnnotatesMigrationMetadata:
initWithStore:destinationModel:mappingModel:
_disconnect
performMigration:
tableMigrationDescriptionForEntity:
_addReindexedProperty:toSetForEntity:
_existingTableNames
_reindexedEntities
_reindexedPropertiesByEntity
_sourceToDestinationEntityMap
_addedEntityMigrations
_removedEntityMigrations
_transformedEntityMigrations
_copiedEntityMigrations
_tableMigrationDescriptionsByEntity
_hasPKTableChanges
_pkTableUpdateStatements
_attributeTriggersToUpdate
_sourceRootEntity
_hasTransformedTableSchema
_tempNameForTableName:
createInsertStatementForEntityMigration:migrationContext:
createFEKUpdateStatementsForEntityMigration:migrationContext:
createUpdateStatementForEntityMigration:migrationContext:
createDeleteStatementForEntityMigrations:migrationContext:
newCopyAndInsertStatementForToOne:toManyToMany:fromTableName:invertColumns:migrationContext:
_retainedRemovedSubEntitiesOfEntity:
_migrationByEntity
_tempTableNames
_affectedStores
setEstimatedResultCount:
_estimatedResultCount
forwardingTargetForSelector:
_sourceBuffer
initWithBytesNoCopy:length:
privateCopy
rangeOfData:options:range:
writeToURL:options:error:
writeToFile:atomically:
_aData
_byteCount
_updateFileDescriptorsInUseReserveNew:
constructSafeguardStringFromString:
_releaseReservedMapFileDescriptor
_doCleanup
_bytesPtrForExternalReference
newFileCoordinatorForUbiquitousExternalDataReferenceLocation:
coordinateReadingItemAtLocation:options:retryOnError:error:byAccessor:
_reserveMapFileDescriptor
_attemptToMapData:
_exceptionForReadError:
_retrieveExternalData
_isEqualHelper:
initForUbiquityDictionary:store:
_setBytesForExternalReference:
_writeExternalReferenceToInterimLocation
_moveExternalReferenceToPermanentLocation
_deleteExternalReferenceFromPermanentLocation
_externalReferenceLocationString
filename
_ubiquitousLocation
_externalDataFlags
willHandleStoreRequest:
filter
setFilter:
_filter
cStringUsingEncoding:
_initializeConnectionsWithSeed:
_checkoutConnectionOfType:
_checkinConnection:
_availableConnections
_allConnections
_poolCounter
_connectionLock
_processingQueue
_connectionsAreLocal
_assignOrderKeysUsingCount:
willChange
insertObjects:count:atIndex:
firstIndex
minusOrderedSet:
unionOrderedSet:
sortRange:options:usingComparator:
_setProcessingIdempotentKVO:
sortWithOptions:usingComparator:
_orderKeys
_grottyHack
_forcedKeys
initWithArray:copyItems:
indexOfObject:inSortedRange:options:usingComparator:
indexSetWithIndex:
moveObjectsAtIndexes:toIndex:
_connectionManagers
_cd_version
_cd_flags
_cd_nullFlags_
identifierForNewStoreAtURL:
newObjectIDForEntity:referenceObject:
_lastIdentifier
_reserveda
_reservedb
initWithValues:
_constraint:extends:
_alreadyHasChildForEntity:constraint:
initForEntity:constraint:extension:
_addChild:
extendConstraint:onParentEntity:parentCache:
keyForValues:
registerObject:forValues:
_intraStoreConflictsExistForValues:
extension
children
_extension
_knownValues
_children
updateWithValues:version:
_realFetch
initWithOrderedSet:copyItems:
intersectsOrderedSet:
isSubsetOfOrderedSet:
reverseObjectEnumerator
reversedOrderedSet
indexesOfObjectsPassingTest:
exchangeObjectAtIndex:withObjectAtIndex:
setObject:atIndex:
intersectOrderedSet:
_mutableOrderedSet
_insertObjectMethod
_insertMethod
_replaceMethod
_replaceObjectMethod
removeRowCacheForGeneration:
_primaryCache
_rowCachesByGenerationToken
transactionLogLocation
initWithPersistentStore:localPeerID:andUbiquityRootLocation:
setLogScore:
initWithTransactionLog:persistentStore:andLocalPeerID:
retainedDelegate
operation:failedWithError:
cacheWrapper
peerRangeCache
cachePeerRanges:
createMapOfManagedObjectIDsForStoreSaveSnapshot:error:
setGlobalIDToLocalIDURICache:
prefetchManagedObjectsInContext:error:
processObjects:withState:andImportContext:outError:
releaseContents:
loadComparisonMetadataWithError:
newStackForLocalPeerID:storeName:andUbiquityRootLocation:error:
metadataMOC
metadataForStoreWithName:inManagedObjectContext:
initWithStack:andStoreMetadata:
baselineHeuristics
setHeuristics:
cacheWrapperForStoreName:
setCacheWrapper:
setStack:
setStoreMetadata:
importContext
exportingPeerID
setExportingPeerID:
setStoreSaveSnapshot:
storeSaveSnapshot
transactionHistoryCache
cacheTransactionHistory:
knowledgeVector
setKnowledgeVector:
initWithStoreKnowledgeVectorDictionary:
initialStoreKnowledgeVector
operationDidFinish:
setCurrentKnowledgeVector:
updateWithKnowledgeVector:
cacheKV
minCacheKV
baselineKV
isZeroVector
purgeCacheAndWritePendingEntries:error:
createMetadataStoreKnowledgeVector:
createMinMetadataStoreKnowledgeVector:
isAncestorOfKnowledgeVector:
initWithStore:localPeerID:andUbiquityRootLocation:
recoverMetadataWithError:
stack
applyChangesFromStoreSaveSnapshot:withImportContext:withError:
peerStateForStoreName:andPeerID:inManagedObjectContext:createIfMissing:
setTransactionNumber:
setLastProcessedTransactionLogURL:
peer
updatedStoreKnowledgeVector
allPeerIDs
remoteStates
peerID
peerKey
ubiquityName
initWithStoreName:andRemotePeerID:insertIntoManagedObjectContext:
setPeer:
setStoreName:
respondToStoreTransactionStateChangeNotification:
writePendingEntries:
insertedObjectIDs
metaForStoreName:
importer
requestBaselineRollForStore:
operationWasInterruptedDuringImport:
notifyDelegateOfError:
managedObjectID
globalIDToLocalIDURICache
setManagedObjectID:
cachedTransactionHistoryForGlobalID:
conflictsWithKnowledgeVector:
filterUsingPredicate:
resolvedTypeForConflictingLogType:andLatestTransactionEntry:skipObject:
globalIDToFetchedObject
setActingPeerID:
setGlobalID:
globalID
setTransactionLogLocation:
setTransactionType:
addTransactionEntryLight:needsWrite:error:
setConflictLogDate:
setSourceObject:
setConflictingLogTransactionType:
setConflictingLogKnowledgeVector:
currentKnowledgeVector
setConflictingLogTransactionNumber:
setTransactionHistory:
setGlobalIDIndexToLocalIDURIMap:
setImportContext:
createSnapshotFromLogContent:withTransactionLog:
setConflictingLogContent:
relationshipToObjectIDsToCheck
fillManagedObject:withGlobalID:fromUbiquityDictionary:missingObjects:importContext:withError:
updatedObjectIDs
deletedObjectIDs
transactionType
createStoreKnowledgeVectorDictionary
setKv:
heuristics
initWithLocalPeerID:andKnowledgeVector:forPeerID:storeName:modelVersionHash:andUbiquityRootLocation:
scheduleReceiptFileWrite:
logScore
main
resolvedConflicts
lockedExistingCoord
setLockedExistingCoord:
setUpdatedStoreKnowledgeVector:
transactionDidRollBack
success
wroteKV
_psc
_entry
_insertedObjectIDs
_updatedObjectIDs
_deletedObjectIDs
_logScore
_resolvedConflicts
_lockedExistingCoord
_initialStoreKnowledgeVector
_updatedStoreKnowledgeVector
_importContext
_success
_transactionDidRollback
_wroteKV
_inMemorySequenceNumber
_operationError
_relationshipsToObjectIDsToCheck
setLastTransactionDate:
lastTransactionDate
managedObjectContextDidSave:
createKnowledgeVectorFromPeerStates
newKnowledgeVectorByDecrementingPeerWithID:
initWithUnsignedInteger:
transactionEntries
actingPeer
transactionLogFilename
newFileCoordinatorForUbiquityRootLocation:andLocalPeerID:
coordinateWritingItemAtURL:options:error:byAccessor:
metadataInconsistencyDetectedForStore:
cleanUpFromRolledbackPendingTransaction:withNotification:
transactionLogCache
cacheExportedLog:
createKnowledgeVectorString
initWithName:object:userInfo:
shouldRespondToSaveNotification:
timeIntervalSinceDate:
initWithLocalPeerID:andUbiquityRootLocation:
setUseLocalStorage:
initWithSaveNotification:withLocalPeerID:
createDictionaryForObjectsInSaveNotification:forTransactionOfType:withExportContext:andSaveSnapshot:
createArrayForExternalDataReferencesInSaveNotification:withExportContext:andSaveSnapshot:
storeNames
storeExportContextForStoreName:
_setFilesDeletedInTransaction:
reserveTransactionNumberWithStoreExportContext:
generatePeerStates
resetFromOptimisticLockingException
scheduleTempLogMove
initWithStoreName:andSaveSnapshot:andRootLocation:
addTransactionEntryLights:error:
storeExportContextForStore:
storeSaveSnapshotForStore:
addManagedObject:withTransactionType:andStoreExportContext:withError:
filesInsertedInTransaction
createPeerRootLocationForPeerID:withUbiquityRootLocation:
pruneTemporaryLogDirectoryForPeerRootLocation:error:
moveLogsFromTempDirectory
initWithLocalPeerID:forStoreName:ubiquityRootLocation:localRootLocation:andProcessingQueue:
currentRootLocation
beginWatchingForChangesFromStore:
stopWatchingForChanges
setUbiquityRootLocation:
pendingTempLogMove
allowTempLogStorage
setAllowTempLogStorage:
localRootLocation
useLocalStorage
throwOptimisticLockingException
setThrowOptimisticLockingException:
_lastTransactionDate
_localRootLocation
_transactionLock
_pendingTransactionsToStoreNameAndTransactionNumber
_pendingTempLogMove
_allowTempLogStorage
_useLocalStorage
_throwOptimisticLockingException
importQueue
setMaxConcurrentOperationCount:
tearDown
cancelAllOperations
setSuspended:
pendingLogLocations
initWithLocalPeerID:andGlobalIDCache:
retainedCachedLogForLocation:loadWithRetry:error:
transactionLogAtLocation:failedToOpenWithError:
transactionLogAtLocationWasIgnored:
transactionLogType
newKnowledgeVectorBySubtractingVector:
operations
canProcessTransactionLogWithScore:afterLogWithScore:
transactionLogAtLocationWasScheduled:
logLocationsToEncounteredErrors
start
addOperations:waitUntilFinished:
isMonitoring
setAllowBaselineRoll:
schedulingLock
createSortedOperationsArrayWithMetadata:isFirstImport:
failedLogLocations
checkSchedulingContextForMissingLocalPeerOperations:error:
scheduleTransactionLogOperations:synchronous:error:
scheduledLogLocations
createArrayOfSubLocationsAtLocation:error:
addPendingLogLocation:
batchDownloadTransactionLogsAtLocations:error:
schedulePendingLogs:error:
startDownloadForItems:onQueue:withBlock:
createSetOfCoordinatorsForPersistentStoreName:andLocalPeerID:atUbiquityRootLocation:
createNewSetOfObjectIDsForCoordinator:fromObjectIDs:
shouldThrottleNotificationsWithOperation:
postImportNotificationForStoreName:andLocalPeerID:withUserInfo:
removeLogsCachedForStoreNamed:withUbiquityRootLocation:
scheduleRecoveryTimer
discoverAndImportAllAvailableLogs:error:
logRestartTimer
setLogRestartTimer:
subpathsOfDirectoryAtPath:error:
allowBaselineRoll
isExecuting
addOperation:
executeBlockOnPrivateQueue:
createSetOfActiveStoreNames
createSetOfPersistentStoreCoordinatorsRegisteredForStoreName:
scheduleBaselineRecoveryOperationWithActiveBaselineOperation:
refreshPeerRangeCache:
createPrivateCoordinatorForStore:error:
addPrivateStore:toCoordinator:atURL:error:
canProcessContentsOfUbiquityRootPath:
createPrivateCoordinatorAndStoreForStore:atURL:error:
executeBlockOnRootQueue:
afterDelay:executeBlockOnRootQueue:
baselineRollOperationEncounteredAnInconsistentBaselineState:
baselineRollOperationWasUnableToLockPersistentStore:
recoveryOperation:didReplaceLocalStoreFileWithBaseline:
recoveryOperation:encounteredAnError:duringRecoveryOfBaseline:
rollResponseOperation:successfullyAdoptedBaseline:
rollResponseOperation:encounteredAnError:whileTryingToAdoptBaseline:
initWithLocalPeerID:ubiquityRootLocation:storeName:andPrivateStore:
isPeerForked:andLocalKV:
startMonitor:
compareScoreKnowledgeVector:withScoreDictionary:
scheduleBaselineRollResponseOperationForBaselineAtLocation:
throttleNotifications
setThrottleNotifications:
importOnlyActiveStores
setImportOnlyActiveStores:
schedulingContext
sideLoadCacheWrapper
setSideLoadCacheWrapper:
privatePSC
_importQueue
_privateQueue
_isMonitoring
_privatePSC
_privateStore
_schedulingContext
_sideLoadCacheWrapper
_logRestartTimer
_schedulingLock
_importOnlyActiveStores
_throttleNotifications
_numPendingNotifications
_pendingNotificationUserInfo
_allowBaselineRoll
_pendingImportOperationsCount
metadataStoreFileLocation
entryForLocalPeerID:storeName:andUbiquityRootLocation:
removeCachedCoordinatorsForLocalPeerID:storeName:andUbiquityRootLocation:
cacheEntryForLocalPeerID:storeName:andUbiquityRootLocation:error:
newMetadataEntryForLocalPeerID:storeName:andUbiquityRootLocation:error:
primaryKeyRanges
expressionWithFormat:
initWithKnowledgeVectorDictionary:
allPeersInManagedObjectContext:
peerForPeerID:inManagedObjectContext:createIfMissing:
initWithMetadataEntry:
purgeAndInitializeMetadataStoreFileWithError:
purgeMetadataForStoreMetadata:withError:
allPeers
peerForPeerID:createIfMissing:
metadataEntry
_metadataMOC
_metadataEntry
_ubiquityRootURL
_metadataStoreFileLocation
_createFetchRequestContextForObjectsToDelete
_createDeleteStatements
fetchContext
deleteStatements
setAffectedObjectIDs:
_fetchRequestForObjectsToDelete
_deleteStatements
_fetchContext
setPeerKey:
setPeerCode:
predicateWithFormat:argumentArray:
initWithStoreName:insertIntoManagedObjectContext:
peerStatesMatchingStoreName:inManagedObjectContext:
peerStateForStoreName:andPeerID:inManagedObjectContext:
peerStatesMatchingStoreName:inManagedObjectContext:omittingLocalPeerID:
forConflictAnalysis
notificationSourceObject
shouldRegisterQueryGeneration
_persistentStoreRequest
_exception
_result
_useColoredLogging
_useConcurrentFetching
setUbiquityName:
setUbiquityRootURLString:
storeMetadatasWithName:inManagedObjectContext:
setStoreURLString:
setStoreIdentifier:
setStoreType:
setStoreOptions:
setModelVersionHashString:
peerStateForPeerID:
addPeerStatesObject:
peerRanges
loadFromBaselineDictionary:
baselineRootDirectoryForUbiquityName:andUbiquityLogURL:
ubiquityRootURLString
createUbiquityLocationForRootURL:
storeOptionsBinaryPlistData
setStoreOptionsBinaryPlistData:
initWithUbiquityName:andUbiquityRootLocation:insertIntoManagedObjectContext:
updateWithStore:andRootLocation:
loadFromBaselineMetadata:withLocalPeerID:
updatePeerStatesToMatchKnowledgeVector:
storeOptions
allStoreMetadataInManagedObjectContext:
baselineStoreURLForUbiquityName:andUbiquityLogURL:
baselineModelURLForUbiquityName:andUbiquityLogURL:
baselineGCModelURLForUbiquityName:andUbiquityLogURL:
baselineMetaFileURLForUbiquityName:andUbiquityLogURL:
isBaselineRootURL:
setPeerID:
remotePeerStatesMatchingStoreName:inManagedObjectContext:
remotePeerStatesMatchingStoreName:andPeerID:inManagedObjectContext:
setPeerStart:
setPeerEnd:
setEnd:
setStart:
setPeerEntityName:
transactionTypeNum
setTransactionTypeNum:
storeMetadata
modelVersionHashString
createTransactionLogLocationForPeerID:storeName:modelVersionHash:logFilename:andUbiquityRootLocation:
initAndInsertIntoManagedObjectContext:
setTransactionLogFilename:
setActingPeer:
createGlobalIDString
setGlobalIDStr:
setLocalIDStr:
setKnowledgeVectorString:
newTransactionEntryForObjectWithCompressedGlobalID:withTransactionType:importContext:
initWithFetchRequest:
transactionLogURL
createTransactionEntriesForCompressedObjectIDs:withTransactionType:withImportContext:
transactionEntriesMatchingGlobalObjectID:inManagedObjectContext:
transactionEntriesMatchingLocalObjectID:inManagedObjectContext:
transactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:
deleteTransactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:
transactionEntriesForPeerID:withTransactionNumber:inManagedObjectContext:
transactionEntriesForPeerID:beforeTransacationNumber:forStoreNamed:inManagedObjectContext:
transactionEntryForGlobalIDString:withActingPeerID:atTransactionNumber:inManagedObjectContext:
userDefaultsChanged:
checkUserDefaults
setDesiredLogLevel:
desiredLogLevel
setLoggingLevel:
_desiredLogLevel
UUIDString
initWithEventType:
initWithCustomKey:
idString
eventType
_idString
_eventType
logLevel
logEvent:ID:message:
sharedEventLogger
createEventTrackingID:
createCustomEventTrackingID:
beginEvent:
logEventData:message:
diagnostic:message:
debug:message:
info:message:
warning:message:
error:message:
fatal:message:
endEvent:
incompleteEvents
setLogLevel:
_logEvents
_logLevel
pathWithComponents:
startDownloadingUbiquitousItemAtURL:error:
logWasExported:
logWasImported:
logImportWasCancelled:
logsWereScheduled:
setupAssistantDiscoveredPathsFromMetadataQuery:
printStatus:
sharedPrivateOperationQueue
processPendingURLs
createUbiquityLocationForURL:withUbiquityRootLocation:
isiCloudExtension:
continueCheckingDownload
checkFileDownload
continueCheckingUpload
checkSafeSaveFileUpload
usesNosyncDirectory
retainedStatusForLocation:
permanentLocation
safeSaveLocation
cloudDocsRootFolder
registerInitialSyncHandlerForURL:andContainerID:onQueue:withBlock:
initWithUbiquityRootLocation:localPeerID:storeName:processingQueue:
presentedSubitemUbiquityDidChangeAtURL:
exporterDidMoveLog:
registerSafeSaveFile:
unregisterSafeSaveFile:
locationToStatus
locationToSafeSaveFile
_presentedItemURL
_scheduledProcessingBlock
_pendingURLs
_pendingURLsLock
_locationToSafeSaveFile
_locationToStatus
setConflictingObjectGlobalIDStr:
addObjectIDsForDiff:forRelationship:
addObjectID:forRelationship:
_newNormalizedSnapshot:forObject:
setAncestorSnapshot:
transactionHistory
createSnapshotDictionaryFromLogEntry:withError:
initWithTranasctionEntry:andLogSnapshot:
addSnapshot:
calculateSnapshotDiffsWithError:
conflictingLogKnowledgeVector
electAncestorKnowledgeVectorForKnowledgeVector:withExportingPeerID:fromPeerSnapshotCollection:
snapshotForKnowledgeVector:
newKnowledgeVectorByAddingKnowledgeVector:
snapshotForPeerID:andTransactionNumber:
timeIntervalSince1970
logSnapshot
resolveMergeConflictForLogContent:previousSnapshot:andAncestorSnapshot:withOldVersion:andNewVersion:error:
diffFromPrevious
createSnapshotFromManagedObject:withSourceObject:
knowledgeVectorsForTransactionNumber:exportedByPeerWithID:
createAncestorVectorForConflictingVector:
createSnapshotFromBaselineForEntry:error:
createTransactionLogForTransactionEntry:withImportContext:error:
createSnapshotDictionaryForObjectWithEntry:inTransactionLog:withError:
initWithBaselineLocation:andLocalPeerID:
createPersistentStoreCoordinatorForCurrentBaseline:
globalIDIndexToLocalIDURIMap
createSetOfManagedObjectIDsForGlobalIDsInRelationship:withValue:withGlobalIDToLocalIDURIMap:andTransactionLog:
createStagingTransactionLogLocationFromTransactionLogLocation:
conflictingObjectGlobalIDStr
conflictingLogContent
conflictingLogTransactionType
conflictLogDate
conflictingLogTransactionNumber
_conflictingObjectGlobalIDStr
_sourceObject
_conflictingLogContent
_conflictingLogKnowledgeVector
_currentKnowledgeVector
_conflictingLogTransactionType
_conflictLogDate
_conflictingLogTransactionNumber
_transactionHistory
_globalIDIndexToLocalIDURIMap
_ancestorSnapshot
createFetchRequestContext
setForConflictAnalysis:
_forConflictAnalysis
nonretainedObjectValue
localFilePresenter
filePresenterForUbiquityRootLocation:andLocalPeerID:
addFilePresenter:
_removeFilePresenter:
removeFilePresenter:
initWithLocalPeerID:storeName:withURL:ubiquityRootLocation:andLocalRootLocation:
registerPersistentStore:withStoreName:
coordinatorWillRemoveStore:
unregisterPersistentStoreCoordinator:
activeStoreCount
entryWillBeRemovedFromSwitchboard
addEntryToPreviousEntries:
valueWithNonretainedObject:
entryForStore:
createUbiquityExternalDataReferenceFileLocationForUUID:andStore:withUbiquityRootLocation:
cacheFilePresenterForUbiquityRootLocation:andLocalPeerID:
removeFilePresenterCachedForUbiquityRootLocation:andLocalPeerID:
_addFilePresenter:
registerUbiquitizedPersistentStore:withURL:forLocalPeerID:withLocalRootLocation:andUbiquityRootLocation:error:
_quietlyMoveEntryToPreviousEntries:
removeEntryFromPreviousEntries:
releaseAllEntriesForStoreName:andPeerID:
_storeNameToLocalPeerIDToEntry
_rootLocationToLocalPeerIDToFilePresenters
_rootLocationToLocalPeerIDToPreviousEntries
_registrationLock
stopMonitor
filePresenterWasNotifiedTransactionLogs:
filePresenterNoticedBaselineFileChange:
initWithProcessingQueue:localPeerID:storeName:andUbiquityRootLocation:
containerIdentifierChanged:
initWithLocalPeerID:ubiquityRootLocation:localRootLocation:storeName:andPrivateQueue:
addPersistentStore:
removePersistentStore:
setAbortSetup:
setupFinished
containerState
monitorState
currentIdentityToken
containerIdentifier
uuidString
setContainerIdentifierUUID:forIdentityToken:forStoreName:
storeKV
exporter
synchronouslyExecuteBlockOnPrivateQueue:
containerStateChanged:
monitorStateChanged:
finishSetupForStore:withSetupAssistant:synchronously:error:finishBlock:
afterDelay:executeBlockOnPrivateQueue:
afterDelay:executeBlockOnGlobalConcurrentQueue:
setActiveStoreCount:
monitor
finishingSetupAssistant
_localFP
_monitor
_activeStoreCount
_registeredCoordinators
_metadata
_finishedSetupForStore
_hasScheduledFinishBlock
_finishedInitializingForStore
_finishLock
_finishingSetupAssistant
cacheWrapperWillBeRemovedFromEntry
initWithStoreName:privateStore:forLocalPeerID:andUbiquityRootLocation:
ubiquityIdentityToken
setUseLocalAccount:
activeModelVersionHash
useLocalAccount
_activeModelVersionHash
_stores
_importer
_exporter
_cacheWrapper
_useLocaAccount
_baselineHeuristics
_organizeValues:
_inserts
_deletes
_masterUpdates
_otherUpdates
coordinateReadingItemAtURL:options:error:byAccessor:
shouldRetryForError:ignoreFile:
newFileCoordinatorForUbiquityRootLocation:
createPeerBaselineFileSafeSaveLocationForLocalPeerID:andBaselineFileLocation:
initWithPermanentLocation:safeSaveLocation:andLocalPeerID:
createBaselineStagingLocation:forStoreName:modelVersionHash:andFilename:withUbiquityRootLocation:
baselineArchiveLocation
baselineStagingLocation
clearOutStagingLocationWithError:
gatherMetadataWithStore:andError:
storeFilenameToData
storeFilename
initWithContentsOfURL:options:error:
constructBaselineArchive:
subpathsAtPath:
createArchiveWithModel:metadata:storeFilenameToData:storeFilename:error:
currentLocation
initWithPath:options:error:
baselinePeerArchiveLocation
setCurrentLocation:
metadataFromBaselineArchive:
contentsForEntryName:
initWithData:encoding:
unpackStoreFilesToStagingLocation:
authorPeerID
haveTransactionLogsForPeer:between:and:
createPeerStoreVersionLocationForPeerID:storeName:andModelVersionHash:withUbiquityRootLocation:
initWithLocalPeerID:andReceiptFileLocation:
metadataFromCurrentBaselineForStoreWithName:peerID:modelVersionHash:andUbiquityRootLocation:withError:
downloadLatestVersion:error:
isPeerReceiptTooOld:
writeDate
timeIntervalSinceNow
replaceLocalPersistentStoreAtURL:ofType:withOptions:usingPersistentStoreCoordinator:error:
_createPersistentStoreCoordinatorForCurrentBaseline:error:
createCurrentBaselineLocation:forStoreName:peerID:andModelVersionHash:forFileNamed:withUbiquityRootLocation:
optimizedModelData
gcModelData
moveToPermanentLocation:
createManagedObjectModelFromCurrentBaseline
baselineArchive
createBaselineGCModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:
createBaselineOptimizedModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:
dataUsingEncoding:
initWithEntryNames:contents:properties:options:
createSetOfInUseExternalDataRefUUIDs:
createUbiquityExternalDataReferenceStoreLocationForStoreName:withUbiquityRootLocation:
removeFileAtLocation:error:
locationSentinel
deleteCharactersInRange:
setLocationSentinel:
createUbiquityLocationForRootPath:
createUbiquityLocationForPath:withUbiquityRootLocation:
usesCurrentBaselineDirectory
removePeerSpecificIdentifiersFromStore:withLocalPeerID:
createStringOfContentsOfBaselineFile:
prepareForBaselineRollOfPersistentStore:andLocalPeerID:error:
gatherContentsAndConstructArchiveWithError:
loadFileFromLocation:error:
canReplaceStoreAtKnowledgeVector:
isUploaded:
metadataMatchesCurrentMetadata:
importBaselineForStoreAtURL:ofType:options:withLocalPeerID:stack:andPersistentStoreCoordinator:error:
updateCurrentStoreIdentifier:error:
writeFileToLocation:error:
baselineMetadataData
createManagedObjectModel
removeUnusedExternalDataReferences:
_baselineStagingLocation
_storeFilenameToData
_storeFilename
_baselineArchive
previousKnowledgeVector
createNewLocalRangeWithRangeStart:andRangeEnd:forEntityNamed:
addDictionaryForPeerRange:
createPeerRangeDictionary:
setPreviousKnowledgeVectorFromCurrentMetadata:
_authorPeerID
_pKV
_peerRanges
_initWithValue:singleton:
_generationIdentifier
_isCompound
_unsupportedForStore
_isSingleton
_freeValueOnDealloc
initWithResultType:andObject:
updateStatement
createFetchRequestContextForObjectsToUpdate
createCountRequestContextForObjectsToUpdate
string
initWithUnsignedLong:
stringWithCapacity:
entitiesAndCounts
initWithStoreName:andUbiquityRootLocation:forLocalPeerID:
_storeNameToStoreExportContext
_ubiquityRootPathToStack
addTransactionEntryForGlobalID:andTransactionType:
_transactionEntries
updateHash
stringValueFromArray:atIndexDescribedByStringNumber:
initFromCopyWithStoreName:entityName:primaryKey:peerID:andHash:managedObjectID:primaryKeyInteger:
integerFromPrimaryKeyString:
primaryKeyInteger
initWithStoreName:entityName:primaryKeyInteger:andPeerID:
initWithCompressedString:forStoreWithName:andEntityNames:primaryKeys:peerIDs:
createCompressedStringWithEntityNameToIndex:primaryKeyToIndex:peerIDToIndex:
_owningPeerID
_managedObjectID
_primaryKeyInteger
initWithExportingPeerID:
setLocalPeerID:
initForExport:
initWithTransactionLog:
_transactionDate
_exportingPeerID
_storeNameToStoreSaveSnapshots
initWithObjectIDs:
_deleteTarget
entityNames
globalObjectIDs
managedObjectIDToGlobalObjectID
entityNameToIndex
peerIDToIndex
primaryKeyToIndex
createGlobalObjectIDForManagedObjectID:
checkIndecies:
noSyncCheckIndex:forValue:fromArrayOfValues:
initWithLong:
globalObjectIDForManagedObject:withStoreExportContext:
createUbiquityDictionary:withStoreExportContext:error:
newKnowledgeVectorByIncrementingPeerWithID:
checkIndex:forValue:fromArrayOfValues:
transactionNumberFromPeerStates:
initWithLocalPeerID:forStoreName:
createGlobalIDForCompressedString:withEntityNames:primaryKeys:peerIDs:
filesDeletedInTransaction
setEntityNames:globalObjectIDs:primaryKeys:forStoreName:withRootLocation:
prepareForGlobalIDReplacement
replaceGlobalObjectID:withGlobalObjectID:
finishGlobalIDReplacement
globalObjectIDToIndex
globalObjectIDToPermanentManagedObjectID
setStoreKV:
globalObjectIDCache
setGlobalObjectIDCache:
_entityNames
_peerIDs
_globalObjectIDs
_managedObjectIDToGlobalObjectID
_globalObjectIDToPermanentManagedObjectID
_entityNameToIndex
_peerIDToIndex
_primaryKeyToIndex
_globalObjectIDToIndex
_peerStates
_transactionNumber
_filesInsertedInTransaction
_filesDeletedInTransaction
_storeKV
_gidCache
temporaryTransactionLogLocation
createTransactionLogLocationFromTemporaryOrStagingLogLocation:
stagingTransactionLogLocation
transactionLogTypeFromLocation:
createTransactionLogFilenameForLogType:
inPermanentLocation
inTemporaryLocation
inStagingLocation
releaseInsertedObjects
releaseUpdatedObjects
releaseDeletedObjects
loadPlistAtLocation:withError:
loadContents:
initWithTimeIntervalSince1970:
createDataFromExtendedAttrsForLog:error:
initWithData:options:error:
createUbiquityExternalDataReferenceFileLocationForUUID:andLog:
useTemporaryLogLocation
updateModificationTimesForLocation:
populateContents
writeContentsOfZipArchive:intoExtendedAttributesForFile:error:
peerCode
truncateLogFilesForPeerID:storeName:modelVersionHash:beforeKnowledgeVector:withLocalPeerID:andUbiquityRootLocation:
cleanupExternalDataReferences
deleteLogFileWithError:
transactionLogFilenameUUID
truncateLogFilesBeforeBaselineMetadata:withLocalPeerID:andUbiquityRootLocation:
generateTransactionLogFilename
initWithTransactionLogURL:ubiquityRootLocation:andLocalPeerID:
rewriteToDiskWithError:
generatePeerCodeKnowledgeVectorWithManagedObjectContext:
fileProtectionOption
loadUsingRetry
setLoadUsingRetry:
loadedComparisonMetadata
loadedImportMetadata
loadedInsertedObjectData
loadedUpdatedObjectData
loadedDeletedObjectData
_contents
_transactionLogType
_useTemporaryLogLocation
_transactionLogLocation
_temporaryTransactionLogLocation
_stagingTransactionLogLocation
_fileProtectionOption
_inTemporaryLocation
_inStagingLocation
_inPermanentLocation
_knowledgeVector
_saveSnapshot
_loadUsingRetry
_loadedComparisonMetadata
_loadedImportMetadata
_loadedInsertedObjectData
_loadedUpdatedObjectData
_loadedDeletedObjectData
_loadedContents
_contentsLock
initWithStoreName:andUbiquityRootLocation:withLocalPeerID:
_stack
_actingPeer
_storeSaveSnapshot
_globalIDToLocalIDURICache
_globalIDToFetchedObject
_heuristics
initWithUbiquityRootPath:
setUbiquityRootLocationPath:
setModelVersionHash:
setFilename:
otherPathComponents
setOtherPathComponents:
setUbiquityLocationType:
setHash:
setIsRootUbiquitous:
usesBaselineStagingDirectory
fileExistsAtLocationWithLocalPeerID:error:
createStringByAppendingSubpath:toPath:
isDirectory
initFileURLWithPath:isDirectory:
__isDirectory
createUbiquityLocationForRootPath:checkIsUbiquitous:
createUbiquityLocationForPath:withUbiquityRootPath:
isUbiquityLocationPath:equalToPath:
createUbiquityExternalDataReferenceFileLocationForUUID:storeName:andUbiquityRootLocation:
localLocationSentinel
createLocalBasePathWithLocalPeerID:containerID:storeName:andStoreURL:
createUbiquityLocationForURL:withUbiquityRootURL:
createUbiquityLocationForSubpath:ofUbiquityRootPath:
createMetadataRootLocationForUbiquityRootLocation:
createMetadataStoreFileLocationForLocalPeerID:storeName:andUbiquityRootLocation:
createMetadataPeerLocationForLocalPeerID:andUbiquityRootLocation:
createMetadataPeerStoreLocationForLocalPeerID:storeName:andUbiquityRootLocation:
createMetadataUUIDLocationForLocalPeerID:storeName:UUID:andUbiquityRootLocation:
createPeerBaselineFileLocationForLocalPeerID:andBaselineFileLocation:
createStagingPeerStoreVersionLocationForExportingPeerID:storeName:andModelVersionHash:withUbiquityRootLocation:
createUbiquityPeerReceiptFileLocationForPeerWithID:storeName:andModelVersionHash:withUbiquityRootLocation:
createUbiquityPeerReceiptSafeSaveLocationFromReceiptFileLocation:
createLocalStoresPathWithLocalPeerID:containerID:storeName:andStoreURL:
createLocalContainerRootLocationWithLocalPeerID:containerID:storeName:andStoreURL:
initWithUbiquityRootURL:
usesStagingLogDirectory
usesTemporaryLogDirectory
usesBaselineDirectory
isTransactionLogLocation
fileAtLocationIsUploaded:
fileAtLocationIsDownloaded:
isEqualToURL:
_ubiquityRootLocationPath
_ubiquityLocationType
_filename
_otherPathComponents
_isDirectory
_isRootUbiquitous
coordinate
_bounds
_entitiesAndCounts
haveConsistentStateForBaselineRoll
rollBaselineWithError:
_governingEntity
_governingAlias
_correlationToken
_limitClause
_orderIntermediate
dataWithContentsOfFile:options:error:
archive:contentsForEntryName:
archive:streamForEntryName:
archive:propertiesForEntryName:
inputStreamWithData:
initWithCalendarIdentifier:
components:fromDate:
year
month
hour
minute
second
dataWithLength:
mutableBytes
archiveData
openArchiveFile:
readInt32FromBytes:offset:
addLocalFileHeaderWithBytes:offset:
addCentralDirectoryEndRecordWithBytes:offset:
addCentralDirectoryHeaderWithBytes:offset:
loadFromBytes:offset:
crc32
uncompressedSize
compressedSize
localFileHeaderRelativeOffset
totalHeaderLength
compressionMethod
compareBytes:length:withLocalFileHeader:
initWithLength:
writeInt64:toData:
writeInt32:toData:
writeInt16:toData:
readInt16FromBytes:offset:
createStringFromBytes:offset:length:
initWithEntryNames:dataProvider:options:
entryNames
streamForEntryName:
writeContentsForEntryName:toFile:options:error:
propertiesForEntryName:
archiveStream
isValid
readDataForLocalFileHeader:fromBytes:error:
createDataForEntryName:cache:error:
_data
_provider
_desc
_path
_cachedContents
_zFlags
_entryNameToData
_entryNameToLocalFileHeader
_entryNameToCentralDirectoryFileHeader
_localFileHeaders
_centralDirectoryEntries
_endRecord
setExtraFieldData:
setFileComment:
loadFromData:offset:
appendToData:
versionMadeBy
setVersionMadeBy:
versionNeededToExtract
setVersionNeededToExtract:
generalPurposeBit
setGeneralPurposeBit:
setCompressionMethod:
lastModTime
setLastModTime:
lastModDate
setLastModDate:
setCrc32:
setCompressedSize:
setUncompressedSize:
filenameLength
extraFieldLength
fileCommentLength
fileStartDiskNumber
setFileStartDiskNumber:
internalFileAttrs
setInternalFileAttrs:
externalFileAttrs
setExternalFileAttrs:
setLocalFileHeaderRelativeOffset:
extraFieldData
fileComment
_versionMadeBy
_versionNeededToExtract
_generalPurposeBit
_compressionMethod
_lastModTime
_lastModDate
_crc32
_compressedSize
_uncompressedSize
_filenameLength
_extraFieldLength
_fileCommentLength
_fileStartDiskNumber
_internalFileAttrs
_externalFileAttrs
_localFileHeaderRelativeOffset
_extraFieldData
_fileComment
setComment:
numberOfDisk
setNumberOfDisk:
diskWhereCentralDirectoryStarts
setDiskWhereCentralDirectoryStarts:
numberOfCentralDirectoryRecordsOnThisDisk
setNumberOfCentralDirectoryRecordsOnThisDisk:
totalNumberOfCentralDirectoryRecords
setTotalNumberOfCentralDirectoryRecords:
byteSizeOfCentralDirectory
setByteSizeOfCentralDirectory:
centralDirectoryOffset
setCentralDirectoryOffset:
commentLength
comment
_numberOfDisk
_diskWhereCentralDirectoryStarts
_numberOfCentralDirectoryRecordsOnThisDisk
_totalNumberOfCentralDirectoryRecords
_byteSizeOfCentralDirectory
_centralDirectoryOffset
_commentLength
_comment
setLength:
actingPeerID
initWithExportingPeerID:logSnapshot:transactionNumber:transactionDate:andKnowledgeVector:
initForRelationshipAtKey:
diffWithLogSnapshot:andPreviousSnapshot:
computeDiffToPreviousSnapshot:
removeValuesChangedByPeerSnapshot:
_logSnapshot
_diffFromPrevious
sortUsingSelector:
_peerIDToTransactionNumberToSnapshot
_peerIDToTranasctionNumberToKnowledgeVector
_kvToSnapshot
_peerSnapshots
_needSort
relationshipKey
_relationshipKey
unresolvedConflictVersionsOfItemAtURL:
replaceItemAtURL:options:error:
electBaselineURLFromVersions:withBaseline:error:
setResolved:
removeAndReturnError:
hasCurrentBaseline
conflictsExistForBaseline:
resolveConflictsForBaseline:withError:
shouldReplaceLocalStoreWithBaseline:
replaceLocalStoreWithBaseline:error:
existsAtSafeSaveLocation
electAncestorBaselineForConflictedBaselines:dissentingBaselines:
_initPrivate
allowsKeyedCoding
_constantValueClassesForSecureCoding
setRequiresSecureCoding:
classesForFetchArchive
_newDenormalizedFetchProperties:
_newNormalizedFetchProperties:
_compoundPredicateClassesForSecureCoding
_extendedExpressionClassesForSecureCoding
_operatorClassesForSecureCoding
encodableTokenForStore:queryGenerationToken:
classesForPullChangesArchive
createSetOfAllPeerIDsWithOtherVector:
createKnowledgeVectorDictionaryFromString:
_updateHash
initFromCopy:storeKVDict:hash:
initWithKnowledgeVectorDictionary:andStoreKnowledgeVectorDictionary:
initWithKnowledgeVectorString:
hasPeerIDInCommonWith:
isDescendantOfKnowledgeVector:
decrementToMinimumWithKnowledgeVector:
canMergeWithKnowledgeVector:
_storeKVDict
initWithLocalPeerID:receiptPeerID:storeName:modelVersionHash:andUbiquityRootLocation:
receiptFileLocation
setWriteDate:
_writeDate
storeWillBeRemoved:
lockDelegateLock
unlockDelegateLock
initWithStoreName:localPeerID:andUbiquityRootLocation:
_delegateLock
_lockedDelegateLock
recoverBaselineMetadataWithImportContext:error:
recoverTransactionLogMetadataWithImportContext:error:
addTransactionHistoryEntriesForObjectIDs:withImportContext:error:
cacheMetadataForTransactionLog:withImportContext:error:
canAdoptBaseline:byReplacingLocalStoreFile:withStack:withError:
fetchRequestDescribingObjectsToUpdate
_createUpdateStatement
_updateStatement
setFailSetupError:
initWithUbiquityRootLocation:peerID:ubiquityName:modelVersionHash:
alphanumericCharacterSet
characterIsMember:
doBasicSanityCheckForUbiquityRootURL:withError:
doPostValidationInit:
longDescription
getCurrentUbiquityIdentityToken
ubiquityIdentityTokenChanged:
initializeStoreKnowledgeVectorFromStore:error:
finishSetupWithRetry:
initWithLocalPeerID:storeName:andUbiquityRootLocation:
identifyContainer:
usedExistingUUIDFile
replaceIdentifierWithUUID:error:
finishSetupForStore:error:
cleanUpFromFailedSetup:
synchronize
detectAndFixForkedContainer:store:error:
initializeReceiptFile:
initializeContainerIdentifierWithStore:error:
initializeStack:
initializeBaselineForStore:error:
checkKnowledgeVectorsAndBaselineWithStore:error:
sideLoadStore:error:
respondToBaselineRoll:
attemptMetadataRecoveryForStore:error:
waitForFileToUpload:
moveLocalLogFilesToUbiquityLocation:
pruneStagingDirectoryForStore:error:
seedStore:error:
isFileUploaded:
existsAtPermanentLocation
removeFileFromLocation:error:
removeOtherVersionsOfItemAtURL:error:
removeFile:
URLForUbiquityContainerIdentifier:
initialSyncComplete
createBaselineFromMostRecentLocation:localPeerID:error:
migrationAssistant
transactionLogLocationsForModelVersionHash:
transactionLogLocationsByModelVersionHash
baselineLocationsByModelVersionHash
latestBaselineLocationSkipModelVersionHash:
updateDictionary:withShortcutSnapshot:
updateDictionary:withPhraseLearningJPSnapshot:
updateDictionary:withPhraseLearningSnapshot:
updateDictionary:withBigramSnapshot:
removeEntriesFromDictionary:withPhraseLearningJPSnapshot:
removeEntriesFromDictionary:withPhraseLearningSnapshot:
removeEntriesFromDictionary:withBigramSnapshot:
fixdictionary:withDeletes:
insertEntriesInDicitonary:inUserDictionaryManagedObjectContext:
insertEntriesInDicitonary:inLearningDictionaryManagedObjectContext:
generateMachineUUIDString
filePosixPermissions
fileIsImmutable
fileType
attributesOfFileSystemForPath:error:
migrateMetadataRoot:
setBaselineKV:
exportedLog:
tryToReplaceLocalStore:withStoreSideLoadedByImporter:
globalIDCache
purgeCache
moveItemAtPath:toPath:error:
createSetOfLocalLogLocations:
rewriteTransactionLogs:toMatchStore:error:
addPendingLogLocations:
writeFile:
URLByAppendingPathComponent:isDirectory:
initFileURLWithPath:
ubiquityMetadataTablesPresentInStore:
cleanUserDefaultsForStore:
checkAndPerformMigrationForStore:error:
removeEntriesFromDictionary:withShortcutSnapshot:
insertEntriesInDicitonary:inLearningDictionaryJPManagedObjectContext:
insertEntriesInDicitonary:inBigramManagedObjectContext:
isInitialSyncComplete
_setUbiquityRootLocation:storeName:localPeerID:andModelVersionHash:
needsMetadataRecovery
storeWasMigrated
abortSetup
retryDelaySec
setRetryDelaySec:
failSetup
setFailSetup:
failSetupError
cacheFilePresenterForUbiquityRoot
_storeType
_actualStoreFileURL
_storeMetadataDict
_needsMetadataWrite
_ubiquityEnabled
_ubiquityIdentityToken
_ubiquityRootSubpath
_ubiquityName
_ubiquityContainerIdentifier
_previousModelVersionHash
_localPeerState
_metaKV
_baseline
_baselineFileExistsInCloud
_hasUploadingBaseline
_monitorUploadingBaselineAsync
_didBaselineCopy
_baselineKV
_votedOffIsland
_reapUbiquitousLogs
_respondToBaselineRoll
_storeFileExists
_storeFileIsReadOnly
_hasStoreMetadataFile
_hasStoreMetadataEntry
_hasContainerUUID
_hasContainerUUIDInStore
_needsMetadataRecovery
_localPeerReceipt
_receiptKV
_containerIdentifier
_preStoreContainerUUID
_usedExistingUUIDMapping
_hasLocalTransactionLogs
_hasMigrationOptions
_didMigrateBaseline
_storeWasMigrated
_migrationAssistant
_replayLogsSynchronously
_useLocalAccount
_seedStore
_seedStoreURL
_haveExistingUUIDMappings
_abortSetup
_gotExportNotification
_sideLoadLock
_logLocationsExportedDuringSideLoad
_gidToRid
_entityNameToGidSet
_initialSyncSemaphore
_initialSyncComplete
_queryLocations
_notifyAboutSetupProgress
_numSetupTries
_retryDelaySec
_failSetup
_failSetupError
_gotAccountChange
_cacheFilePresenterForUbiquityRoot
writeToURL:atomically:encoding:error:
setUUIDStringFromLocation:
writeToDisk:
uuidFileLocation
_uuidString
_uuidFileLocation
_usedExistingUUIDFile
cacheSQLCorePeerRange:error:
peerRangeStartForPrimaryKey:
cachedRangeForOwningPeerID:andEntityName:withPrimaryKey:
cachedRangeForLocalPrimaryKey:ofEntityNamed:
createMapOfManagedObjectIDsForGlobalIDs:count:error:
initWithPersistentStore:andGlobalObjectIDs:
localPrimaryKeyForOwningPeerID:andEntityName:withPrimaryKey:
prepareForRangeReservationWithRangeStart:andGlobalID:andEntityName:
createLocalIDStringForStoreUUID:entityName:andPrimaryKeyString:
numRangesToReserve
createNewPeerRangesWithCache:Error:
initWithPrivateStore:storeName:andLocalPeerID:
describeCaches
describeCachesVerbose
translatedGlobalIDs
_cachedRanges
_allEntityRanges
_translatedGlobalIDs
_cachedStorePeerRanges
_rangeStart
_rangeEnd
_peerStart
_peerEnd
initWithMetadataStoreFileLocation:
initializePersistentStoreCoordinator:
createMetadataModel
newEntityForName:
newAttributeNamed:attributeType:isOptional:isTransient:withDefaultValue:andMinValue:andMaxValue:
newRelationshipNamed:withDestinationEntity:andInverseRelationship:isOptional:isToMany:andDeleteRule:
addModelingToolUserInfoToEntity:
addModelingToolUserInfoToProperty:
removeAllCoordinatorsForRootLocation:
_rootLocationToPeerIDToEntry
_rootLocationToPeerIDToEntryLock
_cachedModel
_filePresenter
peerEntityNameRangeStartSet
_peerEntityNameRangeStartSet
_globalIDToLocalURI
_unresolvedGlobalObjectIDs
_storeNameToFetchedMetadata
_numRangesToReserve
presentedItemLocation
_presentedItemLocation
_transactionLogCache
_transactionLogCacheLock
_generateIdentifier
_sanityCheckVariables:
_substitutionVariables
_cachedInfo
_hasCachedInfo
addTransactionEntry:error:
initWithTransactionEntry:ubiquityRootLocation:andGlobalIDCache:
initWithLocalPeerID:storeName:privateStore:andUbiquityRootLocation:
cachedGlobalIDs
setGlobalIDCache:
_peerIDToHistoryArray
_globalIDToHistoryArray
_peerIDToHistoryArrayLock
_entriesToWrite
_cacheKV
_minCacheKV
_globalIDCache
_hasScheduledWriteBlock
knowledgeVectorString
globalIDStr
createGlobalIDForGlobalIDString:
_globalID
_transactionType
_actingPeerID
createGlobalIDForPrimaryKeyString:entityName:andOwningPeerID:
createGlobalIDForPrimarKey:entityName:andOwningPeerID:
_peerIDToEntityNameToPrimaryKey
_peerIDToEntityNameToPrimaryKeyLock
_appWillResignActive:
writeReceiptFile:error:
peerReceipt
_peerRangeCache
_transactionHistoryCache
_peerReceipt
_pendingReceiptWrite
_receiptFileLock
_allowSchedulingOfReceiptFileWrites
isFileDownloaded:
waitForFileToDownload:
checkSafeSaveFileUploadAsync
setSafeSaveSuccess:
safeSaveFinishedUpload
replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:
setSafeSaveError:
setDownloadSuccess:
downloadFinished
setDownloadError:
safeSaveError
safeSaveSuccess
moveAfterSave
downloadSuccess
downloadError
isRegistered
_permanentLocation
_safeSaveLocation
_currentLocation
_continueCheckingDownload
_downloadSuccess
_downloadError
_continueCheckingUpload
_safeSaveSuccess
_moveAfterSave
_safeSaveError
_safeSaveSemaphore
_isRegistered
ignoredLogLocations
initWithPendingLogLocations:
failedTransactionLogAtLocationRecovered:
unionWithSchedulingContext:
_scheduledLogLocations
_pendingLogLocations
_failedLogLocations
_ignoredLogLocations
_logLocationsToEncounteredErrors
_populateBaselineAndTransactionLogLocations
receiptLocations
canUseReceipts
orderedReceipts
latestTransactionLogForModelVersionHash:
electPreviousModelVersionHashFromTransactionLogsError:
previousModelVersionHash
currentModelVersionHash
_baselineLocationsByVersionHash
_logLocationsByVersionHash
_receiptLocations
_orderedReceipts
_currentModelVersionHash
willChangeContainerState
didChangeContainerState
willChangeMonitorState
didChangeMonitorState
willChangeContainerIdentifier:
containerDeleteDetected:
didChangeContainerIdentifier:
_applicationResumed:
ubiquityIdentityChanged:
setMonitorState:
setContainerIdentifier:transitionType:
scheduleCheckBlock:
checkStoresAndContainer:
setContainerState:
_containerState
_monitorState
_hasScheduledCheckBlock
_scheduleSpinLock
_currentIdentityToken
_identityTokenOverride
Unsupported entity mapping type
entityMapping
mappingType
%s(%d): CoreData: Ubiquity:  Migrating %lu transaction log files for '%@' at '%@'
-[PFUbiquityTransactionLogMigrator migrateTransactionLogsForStoreName:andLocalPeerID:atUbiquityRootLocation:error:]
%s(%d): CoreData: Ubiquity:  Destination log file already exits in final location, skipping: %@
-[PFUbiquityTransactionLogMigrator migrateTransactionLogFromLocation:toLocation:error:]
%s(%d): CoreData: Ubiquity:  Destination log file already exits in staging location, skipping: %@
%s(%d): CoreData: Ubiquity:  Migrating src transaction log %@ to %@
%s(%d): CoreData: Ubiquity:  Destination log written succesfully
%s(%d): CoreData: Ubiquity:  Failed to move transaction log to permanent location: %@
%s(%d): CoreData: Ubiquity:  Destination log write failed with error %@
throttleLogs
TB,R,V_throttleLogs
transactionLog
T@"PFUbiquityTransactionLog",&,N,V_transactionLog
sourceStoreSaveSnapshot
T@"PFUbiquityStoreSaveSnapshot",&,N,V_sourceStoreSaveSnapshot
destinationStoreSaveSnapshot
T@"PFUbiquityStoreSaveSnapshot",&,N,V_destinationStoreSaveSnapshot
PFUbiquitySetupLogMigrationSourceModelHashKey
Failed to migrate ubiquitous content, unable to create mapping model
%s(%d): CoreData: Ubiquity:  %@
Error: %@
-[PFUbiquityMigrationManager migrateTransactionLogs:andBaselineIfNecessaryForStoreName:peerID:error:]
reason
%s(%d): CoreData: Ubiquity:  Migrating transaction logs
Failed to migrate ubiquitous content, unable to migrate transaction logs
%s(%d): CoreData: Ubiquity:  Migrating baseline (if necessary)
%s(%d): CoreData: Ubiquity:  Missing baseline archive for the migration destination data model, need to migrate baseline archive from the source version
ubbaselinestoreXXXXXX
Failed to create temp directory for migrating source baseline
errno
%s(%d): CoreData: Ubiquity:  Failed to migrate baseline: %@
src_baseline.store
dst_baseline.store
%s(%d): CoreData: Ubiquity:  Error writing out migrated baseline: %@
Error: %@
%s(%d): CoreData: Ubiquity:  Error gathering contents for migrated baseline: %@
Error: %@
%s(%d): CoreData: Ubiquity:  Missing baseline archive for the migration src data model, let the standard ubiquity awake/launch logic start a new baseline
%s(%d): CoreData: Ubiquity:  Failed to initialize src data model baseline: %@
%s(%d): CoreData: Ubiquity:  Baseline exists in the cloud, the current baseline cache will be created if it is needed.
sourceModel
T@"NSManagedObjectModel",R,V_sourceModel
destinationModel
T@"NSManagedObjectModel",R,V_destinationModel
rootLocation
T@"PFUbiquityLocation",R,V_rootLocation
metadataToWrite
T@"NSDictionary",R,N,V_metadataToWrite
savePlan
T@"NSSQLSavePlan",R,N,V_savePlan
model
T@"NSSQLModel",R,N
request
T@"NSSaveChangesRequest",R,N
faultHandler
T@"NSFaultHandler",R,N,V_faultHandler
originalCachedRows
T@"NSMutableDictionary",R,N,V_originalCachedRows
NSPullChangeHistoryRequest : < %@ >
_NSCoreDataOptimisticLockingFailureConflictsKey
NSUnderlyingException
persistentStore
Bad compound predicate predicateOperator type
Invalid predicate: nil RHS
predicate
%@.%@
Too many KVC aggregates in keypath: %@
Malformed keypath: %@
valueForKey:
valueForKeyPath:
count:
supportedKVCAggregates
Unsupported KVC aggregate in keypath: %@
average
Protocol version mismatch: someone forgot to restart something.
NSCoreDataXPCMessageCode
NSCoreDataXPCMessageBody
NSCoreDataXPCMessageToken
supportsSecureCoding
TB,R
messageCode
TQ,V_messageCode
messageBody
T@"NSData",&,V_messageBody
token
T@"NSString",&,V_token
Relationship fault for %@ on %p
Relationship objects for %@ on %p: %@
source
T@"NSManagedObject",R,N
relationship
T@"NSPropertyDescription",R,N
fault
TB,R,N,GisFault
index
TI,V_index
value
T@,&,V_value
tableName
T@"NSString",&,V_tableName
Relationship '%@' fault on managed object (%p) %@
Relationship '%@' on managed object (%p) %@ with objects %@
add%sObject:
add%s:
remove%sObject:
remove%s:
intersect%s:
set%s:
IEM_
removedProperties
addedProperties
mappedProperties
couldFailValidation
Each source entity must have a unique renaming identifier
Each destination entity must have a unique renaming identifier
manager
fetchRequestForSourceEntityNamed:predicateString:
TRUEPREDICATE
sourceContext
Each property must have a unique renaming identifier
(migration) destination model property (renaming identifier '%@') matches the renaming identifier for a different type of property (%@) in the source model. Properties cannot be mapped to other property types.
(migration) uninferrable, non-transient property type '%u' for destination model property (renaming identifier '%@'), source model property (renaming identifier '%@').
Remove
Copy
Transform
(migration) attribute mapping for (%@->%@) requires data validation during store migration, mapping a new, mandatory attribute without a default value.
property
entity
Source and destination attribute types are incompatible
(migration) attribute mapping for (%@->%@ to %@->%@) requires data validation during store migration, mapping a previously optional attribute to a mandatory attribute without a default value.
_prependExternalBlobToken:
Unable to use inferred mapping to move external reference into store.
entityPolicy
_nonNilValueOrDefaultValueForAttribute:source:destination:
destination
Reason
Unable to infer mapping for attribute
(migration) relationship mapping for (%@->%@) requires data validation during store migration, mapping a new, mandatory relationship.
(migration) relationship mapping for (%@->%@ to %@->%@) requires data validation during store migration, mapping a previously optional relationship to a mandatory relationship.
Can not map from a to-many to a to-one relationship
destinationInstancesForSourceRelationshipNamed:sourceInstances:
Unable to infer mapping for relationship
%@%@_%@
constantValue
store-file
model.mom
.support
_records
storeUUIDPath
__CD_UBIQUITY_TRANSACTIONS
__CD_UBIQUITY_BASE
objectContent
int16
int32
int64
decimal
double
float
string
bool
date
binary
UUID
encodable
_name
_indexTitle
_sectionOffset
_numberOfObjects
(NSFetchedResultsController) section '%@' not found in controller
name
T@"NSString",R,N
indexTitle
numberOfObjects
TQ,R,N
objects
T@"NSArray",R,N
sectionOffset
TQ,R,N,V_sectionOffset
sectionNumber
oldSectionNumber
TQ,N,V_oldSectionNumber
T@"NSString",R,N,V_name
T@"NSString",R,N,V_indexTitle
TQ,R,N,V_numberOfObjects
 WHERE  (1 = 1) 
INSERT INTO 
) VALUES(?, ?, ?
INSERT OR REPLACE INTO 
) VALUES (?, ?
UPDATE OR FAIL 
 SET 
 = ? WHERE 
 = ? AND 
 = ?
 WHERE 
DELETE FROM 
 WHERE Z_PK = ? AND (Z_OPT = ? OR Z_OPT IS NULL)
 WHERE Z_PK = ? AND Z_OPT = ?
 WHERE Z_PK = ?
 WHERE %@ = ? AND %@ = ?
v8@?0
limitedStatement
T@"NSSQLiteStatement",&,N,V_limitedStatement
unlimitedStatement
T@"NSSQLiteStatement",&,N,V_unlimitedStatement
substitutionBindVariableOrder
T@"NSArray",&,N,V_substVarBindOrdering
substitutionBindIntarrayOrder
T@"NSArray",&,N,V_substIntarrayBindOrdering
%@: index (%lu) beyond bounds (%lu)
iBooks
Music
batch
v32@?0@8Q16^B24
%@: index (%lu) beyond bounds (%u)
%@ (%p) of %lu items for request %@
You're doing it wrong
Skanky class can only be used skankily.
NSOrderedSet wrapper '%@' for fetch request results: %@
objectID
batched fetch array received an error %@ with userInfo %@
 batched fetch request asked to fetch %d objects but received %d objects as %@
ZT_%@_%@_%@
%@_%@_INSERT_INCREMENT
DROP TRIGGER IF EXISTS %@
CREATE TRIGGER IF NOT EXISTS %@ AFTER INSERT ON %@ FOR EACH ROW
 BEGIN
 UPDATE %@ SET %@ = IFNULL(%@,0) + 1
 WHERE NEW.%@ IN (SELECT %@ FROM %@ WHERE %@)
 AND NEW.%@ = %@;
 SELECT NSCoreDataTriggerUpdateAffectedObjectValue('%@', %@, %@, '%@', %@) FROM %@ WHERE %@ = NEW.%@;
 END
%@_UPDATE_INCREMENT
CREATE TRIGGER IF NOT EXISTS %@
 AFTER UPDATE OF %@ ON %@ FOR EACH ROW
 WHEN %@
 WHERE %@ IN (SELECT %@ FROM %@ WHERE %@ = NEW.%@ AND (%@));
%@_UPDATE_DECREMENT
 UPDATE %@ SET %@ = MAX(0,IFNULL(%@,0) - 1)
%@_%@_DELETE_DECREMENT
CREATE TRIGGER IF NOT EXISTS %@ AFTER DELETE ON %@ FOR EACH ROW
 WHERE OLD.%@ IN (SELECT %@ FROM %@ WHERE %@)
 AND OLD.%@ = %@;
 SELECT NSCoreDataTriggerUpdateAffectedObjectValue('%@', %@, %@, '%@', %@) FROM %@ WHERE %@ = OLD.%@;
%@_DELETE_DECREMENT
CREATE TRIGGER IF NOT EXISTS %@ AFTER DELETE ON %@ FOR EACH ROW WHEN %@
 WHERE %@ IN (SELECT %@ FROM %@ WHERE %@ = OLD.%@ AND (%@));
COUNT_%@
CREATE TEMP TABLE %@ AS
 SELECT %@, COUNT(DISTINCT(%@.%@)) AS COUNT
 FROM %@, %@
 WHERE %@ AND %@.%@ == %@.%@
 GROUP BY %@;
 CREATE INDEX %@_INDEX ON %@(%@,COUNT);
 UPDATE %@ SET %@ = IFNULL((SELECT COUNT FROM %@ WHERE %@ = %@),0);
 DROP TABLE %@;
%@_INSERT_INCREMENT
 AFTER INSERT ON %@ FOR EACH ROW WHEN %@
 WHERE NEW.%@ = %@;
 AFTER UPDATE OF %@ ON %@
 FOR EACH ROW WHEN (%@) AND (%@) AND (NEW.%@ == OLD.%@)
 FOR EACH ROW WHEN (%@) AND (%@) AND (OLD.%@ == NEW.%@)
 WHERE OLD.%@ = %@;
 AFTER DELETE ON %@ FOR EACH ROW WHEN %@
 UPDATE %@ SET %@ = MAX(0,IFNULL(%@,0) - 1) WHERE OLD.%@ = %@;
 AFTER INSERT ON %@ FOR EACH ROW
 UPDATE %@ SET %@ = (SELECT COUNT(%@) FROM %@ WHERE (%@ = NEW.%@) AND (%@)) WHERE %@ = NEW.%@;
%@_%@_UPDATE_INCREMENT
 AFTER UPDATE OF %@ ON %@ WHEN (%@) AND
 ((NEW.%@ IS NOT NULL AND OLD.%@ IS NULL) OR (NEW.%@ != OLD.%@))
 UPDATE %@ SET %@ = IFNULL(%@,0) + 1 WHERE %@ = NEW.%@;
%@_%@_UPDATE_DECREMENT
 ((OLD.%@ IS NOT NULL AND NEW.%@ IS NULL) OR (NEW.%@ != OLD.%@))
 UPDATE %@ SET %@ = MAX(0,IFNULL(%@,0) - 1) WHERE %@ = OLD.%@;
 FROM %@
 WHERE %@
 UPDATE %@ SET %@ = IFNULL((SELECT COUNT FROM %@ WHERE %@ = %@), 0);
 FOR EACH ROW WHEN (%@) AND (%@)
%@_%@_UPDATE_TO_NULL
 AFTER UPDATE OF %@ ON %@ WHEN
 (NEW.%@ IS NULL AND OLD.%@ IS NOT NULL)
 UPDATE %@ SET %@ = 0 WHERE %@ = NEW.%@;
 UPDATE %@ SET %@ = (SELECT COUNT(%@) FROM %@ WHERE %@ = NEW.%@ AND (%@)) WHERE %@ = NEW.%@;
 SELECT %@, COUNT(DISTINCT(%@)) AS COUNT
offendingString
Unable to parse trigger predicate to an instance of NSPredicate.
 %@ 
offendingPredicate
Invalid trigger predicate, compound predicates must be AND or OR predicates.
Invalid trigger predicate, predicate must evaluate to an instance of NSComparisonPredicate or NSCompoundPredicate.
 OR (NEW.%@ %@ %ld AND OLD.%@ %@ %ld)
(NEW.%@ %@ %ld AND OLD.%@ %@ %ld)
 OR 
NEW.%@ != OLD.%@
%@ %@ %ld
OLD.%@ %@ %ld
NEW.%@ %@ %ld
offendingAttribute
Invalid trigger predicate, unable to find the attribute specified by this predicate.
Invalid trigger predicate, this predicate appears to reference a different relationship than other predicates in this trigger.
Invalid trigger predicate, failed to find the relationship identified by the keyPath.
Invalid trigger predicate, predicate operator must be one of:
NSLessThanPredicateOperatorType,
NSLessThanOrEqualToPredicateOperatorType,
NSGreaterThanPredicateOperatorType,
NSGreaterThanOrEqualToPredicateOperatorType,
NSEqualToPredicateOperatorType,
NSNotEqualToPredicateOperatorType
Invalid trigger predicate, right exprssion must evaluate to a constant integer value.
Invalid trigger predicate, right exprssion must evaluate to an instance of NSConstantValueExpressionType.
Invalid trigger predicate, left expression must be a key-path with only two components.
Invalid trigger predicate, left expression must evaluate to an instance of NSKeyPathExpressionType.
T@"NSSQLEntity",R,V_entity
attribute
T@"NSSQLAttribute",R,V_attribute
predicateString
T@"NSString",R,V_predicateString
T@"NSPredicate",R,V_predicate
T@"NSSQLRelationship",R,V_relationship
destinationEntity
T@"NSSQLEntity",R,V_destinationEntity
destinationAttributes
T@"NSArray",R,V_destinationAttributes
sqlDropStrings
T@"NSArray",R
bulkChangeStrings
toManyInnerFetchWhereClause
T@"NSString",R
toManyDecrementWhenClause
toManyIncrementWhenClause
ofClause
oldMatchingClause
newMatchingClause
columnChangedClause
unknown
com.apple.coredata
error
warning
annotation
debug
CoreData: %s: %s
hw.activecpu
hw.cpufrequency
hw.memsize
Frameworks/CoreData.framework
Common
CoreData
 Can't find CoreData image header.
Can't find the hash for some reason, using empty data
B16@?0@"NSManagedObject"8
.interim
Can't open externalDataReference interim file : %d
Problem Path
Can't create externalDataReference interim file : %d
Can't copy interim file to permanent location : %d
Problem object
Unable to open file with path %s (%d)
Unable to open file with path: %s (%d)
Missing bytes from file at path %s, expected %lu, got %lu
Unable to read content of file with path: %s (%d)
Unable to read requested number of bytes from path: %s (got %lu)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~_
 Unable to find an instance of NSValueTransformer registered for the name: %@
 The requesting attribute is: 
self IN %@
v32@?0@8@16^B24
object
T@,R
address
Tq,R
_LOCK
B24@?0@"NSURL"8@"NSError"16
.LINKS
NSKnownKeysMappingStrategy2
Corrupted archive (unexpected data in pointer space).
Corrupted archive (failed to read row).
Corrupted branch row in optimized model detected:
details
Background Core Data task threw an exception.  Exception = %@ and userInfo = %@
_NSZombie_%s
_NSZombie_
metadataForPersistentStoreWithURL:error: must be overriden by your store class to provide metadata
NSMappedObjectStore must be initialized with initWithPersistentStoreCoordinator:configurationName:URL:options
save: must be overriden by your store class to save data to the store
load: must be overriden by your store class to load data from the store
Store %@ cannot hold instances of entity %@
newCacheNodeForManagedObject: must be overriden by your store class to create a cache node from a managed object
updateCacheNode:fromManagedObject: must be overriden by your store class to update a cache node from a managed object
Cannot retrieve referenceObject from an objectID that was not created by this store
Unknown command type %@
Unsupported fetch request: store %@ does not support GROUP BY
NSCoreDataPrimaryError
Error saving the persistent store.
/dev/null
%@ (type: %@, url: %@)
type
T@"NSString",C,V_type
configuration
T@"NSString",C,V_configuration
T@"NSURL",C,V_url
options
T@"NSDictionary",R,C,N
readOnly
TB,GisReadOnly
timeout
sqlitePragmas
shouldAddStoreAsynchronously
shouldMigrateStoreAutomatically
shouldInferMappingModelAutomatically
NSAddStoreAsynchronouslyOption
NSInvokeCompletionHandlerConcurrently
NSAtomicStoreCacheNodes must be initialized using initWithObjectID:(NSManagedObjectID *)
NSAtomicStoreCacheNodes must be created with an objectID
T@"NSManagedObjectID",R,N
propertyCache
T@"NSMutableDictionary",&,N
NSAttributeType
NSAttributeValueClassName
NSDefaultValue
NSValueTransformerName
NSIsIndexed
NSFlagsKey
NSMaxValueName
NSMinValueName
%@, attributeType %lu , attributeValueClassName %@, defaultValue %@
Can't set attributeValueClassName to nil for a non-transient attribute.
Can't set attribute type to undefined for non-transient attribute.
Can't find class for type %lu
_NSCreateIndex
SELF >= %@
SELF =< %@
length >= %@
length =< %@
timeIntervalSinceReferenceDate >= %@
timeIntervalSinceReferenceDate =< %@
self >= %@
self =< %@
attributeType
attributeValueClassName
T@"NSString",C
defaultValue
T@,&
versionHash
T@"NSData",R,C
valueTransformerName
allowsExternalBinaryDataStorage
length
timeIntervalSinceReferenceDate
no NSValueTransformer with class name '%@' was found for attribute '%@' on entity '%@'
NSTriggerKey
INTEGER
NUMERIC
DOUBLE
TEXT
BOOLEAN
TIMESTAMP
BLOB
Undefined attribute type.
"%@" %@
abstract
_NSCoreManagedObjectID
Entity name must not be nil.
Store must not be nil.
_NSObjectID_%s_%x
%@://%@/%@/p%@
x-coredata
x-coredata://
%@://%@/%@/p%qu
_NSCoreDataTaggedObjectID
-initWithObject: is not implemented on tagged objectIDs
-_referenceData is not implemented on tagged objectIDs
%@://%@/%@/t%@%d
Cannot create a binary store with a nil URL.
CoreData binary stores only support file URLs (got %@).
Error validating url for store
Attempt to add read-only file at path %@ read/write. Adding it read-only instead. This will be a hard error in the future; you must specify the NSReadOnlyPersistentStoreOption.
Attempt to add read-only store read-write
NSBinaryObjectStore only supports file URLs right now.
Can't save store to %@ (read-only store)
subresults
T@"NSArray",R,V_subresults
progress
T@"NSProgress",&,V_requestProgress
operationError
T@"NSError",&,V_requestError
requestCompletionBlock
T@,C,V_requestCompletionBlock
managedObjectContext
T@"NSManagedObjectContext",R,V_requestContext
finalResult
T@"NSArray",&,V_finalResult
intermediateResultCallback
T@?,C,V_intermediateResultCallback
fetchRequest
T@"NSAsynchronousFetchRequest",R,V_fetchRequest
metadata
mapData
NSAttributeValues
NSAttributes
Can't read binary data from file
Can't load binary data from file (file was created by an incompatible version of CoreData)
_NSStoreMapArchiveVersion
_NSStoreMapArchiveMetadata
_NSStoreMapArchiveNextPK
_NSStoreMapArchiveData
Can't load data from archived data (archived data was created by an incompatible version of CoreData)
Directory does not exist : %@
Not a directory : %@
Directory is not writable : %@
Binary store save failed.
Can't construct a node from nil.
Source object
Destination Object
Relationship
CoreData does not support persistent cross-store relationships
Can't find entity for object
_CoreDataEntityDescription
_CoreDataEntityName
NSKeyValueUndefinedSetter
NSKeyValueUndefinedGetter
+entityForName: nil is not a legal NSManagedObjectContext parameter searching for entity name '%@'
+entityForName: nil is not a legal NSPersistentStoreCoordinator for searching for entity name '%@'
+entityForName: could not locate an NSManagedObjectModel for entity name '%@'
+entityForName: could not locate an entity named '%@' in this model.
NSEntityName
NSClassNameForEntity
NSIsAbstract
NSManagedObjectModel
NSSuperentity
NSSubentities
NSProperties
NSUserInfo
NSVersionHashModifier
NSRenamingIdentifier
NSCompoundIndexes
NSUniqueTuples
(%@) name %@, managedObjectClassName %@, renamingIdentifier %@, isAbstract %u, superentity name %@, properties %@, subentities %@, userInfo %@, versionHashModifier %@, uniquenessConstraints %@
NSManagedObject
Can't add a subentity to an entity (missing name or bad properties).
Invalid property passed to setProperties: property has nil name or is an NSExpressionDescription.
Can't change name of entity from %@ to %@
self
Cannot merge uniqueness constraints { %@ } on entity '%@' due to relationship '%@' having a mandatory to-one inverse relationship '%@' and not using a cascade delete rule on '%@'
Can't find attribute named %@
Problem name
Only attributes can be uniqued
Problem property
Uniqueness constraints must be defined at the highest level possible. All properties in constraint %@ are defined on parent entity.
Problem constraint
managedObjectModel
T@"NSManagedObjectModel",R
managedObjectClassName
TB,GisAbstract
subentitiesByName
T@"NSDictionary",R,C
subentities
T@"NSArray",&
superentity
T@"NSEntityDescription",R
propertiesByName
properties
userInfo
T@"NSDictionary",&,N
attributesByName
relationshipsByName
versionHashModifier
renamingIdentifier
compoundIndexes
uniquenessConstraints
Can't add an entity to multiple superentities.
Can't add unnamed subentity.
Can't add multiple entities with duplicate names.
Can't add unnamed property to entity.
Entity already contains a property named %@.
Can't add NSExpressionDescriptions to NSEntityDescriptions
tried to add property %p '%@' to entity %p '%@' but it already belongs to entity %p '%@'
Model must be immutable before mapping strategy can be created
Can't use an entity in two models.
Unable to load class named '%@' for entity '%@'.  Class not found, using default NSManagedObject instead.
"%@" is not a subclass of NSManagedObject.
Class '%s' for entity '%@' has an illegal override of NSManagedObject -isEqual:
Class '%s' for entity '%@' has an illegal override of NSManagedObject -hash
Cannot make an immutable entity editable again.
Can't set superentity of self to self.
Bad model.  For entity '%@' superentity '%@' does not think I am a subentity
Bad model.  For entity '%@' subentity '%@' does not think I am its superentity
Bad model.  For entity '%@' subentity '%@ (%p)' is not registered in NSManagedModelModel.  Model has a reference to %@ (%p)
Cannot use uniqueness constraints { %@ } on entity '%@' due to relationship '%@' having a mandatory to-one inverse relationship '%@' and not using a cascade delete rule on '%@'
Can't remove property '%@' - doesn't belong to this entity.
Property named '%@' in entity '%@' conflicts with property inherited from parent entity '%@'
Entity '%@' has unique constraints { %@ } with relationship '%@' and mandatory to-one inverse '%@' but is not using a cascade delete rule .
inverse
Entity '%@' has unique constraints { %@ } with a relationship and mandatory to-one inverse but is not using a cascade delete rule .
Can't read entity into shell: Missing entity frontside delimiter
Root cause
Can't read entity: Not enough bytes left
Can't read entity: Missing version hash value
Can't read entity: Missing entity name
Cant' read entity: Miswired subentities dictionary
Cant' read entity: Mismatched subentity count
Cant' read entity: Properties dictionary has content
Cant' read entity: Properties buffer has content
Cant' read entity: Property entity does not match entity being decoded (1)
Cant' read entity: Property entity does not match entity being decoded (2)
Can't read entity into shell: Missing entity back-end delimiter
Relationship properties should be @dynamic, not ivars (entity %@, class %s, property %@).  This will be an error in the future.
validate%s:error:
NSMappingName
NSMappingType
NSSourceEntityName
NSSourceEntityVersionHash
NSDestinationEntityName
NSDestinationEntityVersionHash
NSSourceExpression
NSEntityMigrationPolicyClassName
NSAttributeMappings
NSRelationshipMappings
(%@), name %@, mappingType %u, sourceEntityName %@, sourceEntityVersionHash %@, destinationEntityName %@, destinationEntityVersionHash %@, attributeMappings %@, relationshipMappings %@, sourceExpression %@, entityMigrationPolicyClassName %@, userInfo %@
%@->%@
sourceEntityName
sourceEntityVersionHash
T@"NSData",C
destinationEntityName
destinationEntityVersionHash
attributeMappings
relationshipMappings
sourceExpression
T@"NSExpression",&
entityMigrationPolicyClassName
NSEntityMigrationPolicy
Couldn't create mapping policy for class named (%@)
Entity Mappings cannot become mutable after being marked immutable.
Can't modify an immutable entity mapping.
propertyMapping
Can't find source for destination in default mapping policy
More than one source for destination in default mapping policy
Unknown/unsupported type for ordered toMany relationship destination
relationshipDestinations
Unknown/unsupported type for toMany relationship destination
More than one relationship destination for a toOne relationship
Unknown/unsupported type for toOne relationship destination
%@ -> %@
property.name
"%@" INTEGER PRIMARY KEY
columnDefinition
CREATE TABLE "%@" (%@);
NSExpression
NSExpressionType
expression
expressionResultType
Conflicts
destinations
mtmObjects
NSKeyValueIvarSetter
NSKeyValueMethodSetter
NSKeyValueIvarGetter
NSKeyValueMethodGetter
During prefetching, materialized to-many relationship '%@' on object %@ was null
During prefetching, materialized to-one relationship '%@' on object %@ was not a managed object but instead %@
FETCH_SOURCE
FETCHED_PROPERTY
CoreData could not fulfill a fetched property because '%@'
Fetched Property
CoreData Debug Logging: Exception = %@ with error code = %ld and userInfo = %@
message
failed to retrieve ordering information from fault for object %@ and relationship %@ due to nil NSManagedObjectContext
An NSManagedObject must have a valid NSEntityDescription.
CoreData could not fulfill a fault for '%@'
<UNKNOWN objectID>
An NSManagedObjectContext delegate overrode fault handling behavior to silently substitute nil/0 for all property values for the object with ID '%@'.  This is very unwise.
An NSManagedObjectContext delegate returned an illegal result
 Found no possible URLs for directory type %lu
 Failed to create directory %@: %@
 File %@ already exists and is not a directory!
Failed to call designated initializer on '%@' 
momd
 Failed to load model at path: %@
 Failed to load model named %@
%@.sqlite
T@"NSString",R,C,V_name
viewContext
T@"NSManagedObjectContext",R,V_viewContext
persistentStoreCoordinator
T@"NSPersistentStoreCoordinator",R,V_storeCoordinator
persistentStoreDescriptions
T@"NSArray",C,V_storeDescriptions
Store failed to load.  %@ with error = %@ with userInfo %@
v24@?0@"NSPersistentStoreDescription"8@"NSError"16
NSFetchRequest
_NSFetchRequestEntityName
%@, fetchRequest %@
Can't use fetch request with fetched property description (entity model mismatch).
T@"NSFetchRequest",&
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
NSValuesToGroupBy
NSHavingPredicate
NSFetchOffset
NSValuesToFetch
NSEntity
NSPredicate
NSSortDescriptors
NSFetchLimit
NSBatchSize
NSRelationshipKeyPathsForPrefetching
NSResultType
NSHasFetchRequestFlags
NSFetchRequestFlags
%@ (entity: %@; predicate: (%@); sortDescriptors: (%@); 
limit: %u; 
offset: %u; 
batch size: %u; 
unknown request type
NSManagedObjectResultType
NSManagedObjectIDResultType
NSDictionaryResultType
NSCountResultType
type: %@; 
identifier
affected stores: (%@); 
includesSubentities: NO; 
includesPropertyValues: NO; 
returnsObjectsAsFaults: NO; 
includesPendingChanges: NO; 
returnsDistinctResults: YES; 
shouldRefreshRefetchedObjects: YES; 
relationshipKeyPathsForPrefetching: (%@); 
propertiesToFetch: (%@); 
havingPredicate: (%@); 
propertiesToGroupBy: (%@); 
Cannot fetch without an NSManagedObjectContext in scope
This fetch request (%p) was created with a string name (%@), and cannot respond to -entity until used by an NSManagedObjectContext
Invalid keypath %@ passed to %@
setPropertiesToGroupBy:
setPropertiesToFetch:
Invalid keypath %@ passed to setPropertiesToGroupBy:
Invalid keypath %@ passed to %@:
Invalid keypath %@ passed to %@ (non-terminal attribute)
Invalid to many relationship in setPropertiesToFetch: (%@)
Invalid keypath %@ passed to %@ (invalid property type)
Invalid property %@ passed to %@ (property is transient)
Attribute/relationship description names passed to %@ must match name on fetch entity (%@)
Invalid property (%@) passed to setPropertiesToFetch: (entity mismatch)
Invalid to many relationship (%@) passed to %@:
Invalid keypath expression (%@) passed to setPropertiesToFetch:
T@"NSEntityDescription",&,N
entityName
T@"NSPredicate",&,N
sortDescriptors
T@"NSArray",&,N
fetchLimit
TQ,N
affectedStores
resultType
includesSubentities
TB,N
includesPropertyValues
returnsObjectsAsFaults
relationshipKeyPathsForPrefetching
T@"NSArray",C,N
includesPendingChanges
returnsDistinctResults
propertiesToFetch
fetchOffset
fetchBatchSize
shouldRefreshRefetchedObjects
propertiesToGroupBy
havingPredicate
NSFetchRequest could not locate an NSEntityDescription for entity name '%@'
Can't modify a named fetch request in an immutable model.
Invalid groupByProperty type in archive
Invalid propertyToFetch type in archive
NSFRExpression
NSMOCExpression
NSCountOnlyFlag
NSFetchRequestExpression could not evaluate its request or context.
FETCH(%@, %@, %@)
Cannot substitute a nil substitution dictionary.
requestExpression
T@"NSExpression",R
contextExpression
countOnlyRequest
TB,R,GisCountOnlyRequest
NSSourceAttributeName
NSDestinationAttributeName
branch row pointer is NULL
[%d]
branch row pointer%@ = %p flags.size = %d flags.operation = %d flags.parameter = %d flags.offset = %d lowerBound = %d lowerSlot = %d upperBound = %d upperSlot = %d generalSlots pointer = %p with contents = %@
mapping table pointer is NULL
mapping table has 0 branch rows
mapping table %p has %d branch rows:
NSConstantString
__NSCFString
%@ supports a maximum of 32,768 elements.  parameter was %lu
keys
version
mapping table %p has %d branch rows: (...)
%@ (%p) table of length %d with known keys:%@ and %@
*** -%s sent to an NSKnownKeysDictionary object
searchMapping
emptyToken
values
__empty_slot_token_4c24_98dc_ac1e_b773__
The key '%@' is not defined for this NSKnownKeysDictionary
NSTargetObjectUserInfoKey
NSUnknownUserInfoKey
T^@,R,N
mapping
T@"NSKnownKeysMappingStrategy",R,N
NSDetailedErrors
NSValidationErrorObject
NSValidationErrorKey
NSValidationErrorPredicate
NSValidationErrorValue
NSAffectedStoresErrorKey
NSAffectedObjectsErrorKey
NSOriginalSnapshot
NSInsertedObjects
NSDeletedObjects
NSCurrentObjects
NSSQLiteErrorDomain
Delete: %@
Insert: %@ at index: %lu
Move: %@ to index: %lu
(...not nil..)
<relationship fault: %p '%@'>
(...and %ld more...)
%@ (entity: %@; id: %@ ; data: %@)
<fault>
%@ (entity: <null>; id: %@ ; data: <fault>)
An NSManagedObject of class '%@' must have a valid NSEntityDescription.
NSEntityDescription '%@' can only support a single custom class (tried to instantiate class '%@'). Use a subentity with 0 properties to further specialize the NSManagedObject subclass.
CoreData: error: Failed to call designated initializer on NSManagedObject class '%@' 
[<%@ %p> valueForUndefinedKey:]: the entity %@ is not key value coding-compliant for the key "%@".
Mutating a managed object %@ (%p) after it has been removed from its context.
NSManagedObjects of entity '%@' do not support -mutableArrayValueForKey: for the property '%@'
NSManagedObjects of entity '%@' do not support -mutableSetValueForKey: for the property '%@'
NSManagedObjects of entity '%@' do not support -mutableOrderedSetValueForKey: for the property '%@'
[<%@ %p> setValue:forUndefinedKey:]: the entity %@ is not key value coding-compliant for the key "%@".
[<%@ %p> setNilValueForKey]: instance of entity %@ could not set nil as the value for the key %@.
<null>
contextShouldIgnoreUnmodeledPropertyChanges
T@"NSManagedObjectContext",R,N
T@"NSEntityDescription",R,N
inserted
TB,R,N,GisInserted
updated
TB,R,N,GisUpdated
deleted
TB,R,N,GisDeleted
hasChanges
TB,R,N
hasPersistentChangedValues
faultingState
Unacceptable type of value for attribute: property = "%@"; desired type = %@; given type = %@; value = %@.
Cannot set value for attribute with undefined type: property = "%@"; entity = "%@"; value = %@
Illegal attempt to establish a relationship '%@' between objects in different contexts (source = %@ , destination = %@)
Unacceptable type of value in to-many relationship: property = "%@"; problem = %@; desired type = %@; given type = %@; value = %@.
Unacceptable type of value for %@ relationship: property = "%@"; desired type = %@; given type = %@; value = %@.
ordered to-many
to-many
Unacceptable type of value for to-one relationship: property = "%@"; desired type = %@; given type = %@; value = %@.
Impossible information to maintain inverse relationship "%@" for relationship: %@.
Insufficient information to maintain inverse relationship "%@" for relationship: %@.
Cannot maintain read-only inverse relationship "%@" for relationship: %@.
%{ENTITY}@
%{PROPERTY}@
Illegal validation warning: property = "%@"; predicate/warning index = %lu; warning = %@.
i24@?0r^v8r^v16
Object has pending changes
com.apple.CoreData.%@.%p
v12@?0i8
 Failed to setup notification listener: %d
%@: null selector
%s_%s_
%s_%s_%x
contextShouldIgnoreChangesFor
_cd_bits_%p
Incorrect ivar generation
[%dI]
class_addIvar failed
NULL _cd_rawData but the object is not being turned into a fault
automaticallyNotifiesObserversOf
managedObjectOriginal_
Property '%s' is a 64 bit scalar type on class '%s' that does not match its entity's property's 32 bit scalar type.  Implicit coercion to 32 bits in the database is not recommended.
Property '%s' is a scalar type on class '%s' that does not match its Entity's property's scalar type.  Dynamically generated accessors do not support implicit type coercion.  Cannot generate a getter method for it.
Property '%s' is a scalar type on class '%s'.  Cannot generate a getter method for it.
dynamic accessors failed to find @property implementation for '%s' for entity %@ while resolving selector '%s' on class '%s'.  Did you remember to declare it @dynamic or @synthesized in the @implementation ?
setPrimitive
primitive
Property '%s' is marked __weak on class '%s'.  Cannot generate a setter method for it.
Property '%s' is a scalar type on class '%s' that does not match its Entity's property's scalar type.  Dynamically generated accessors do not support implicit type coercion.  Cannot generate a setter method for it.
Property '%s' is a scalar type on class '%s'.  Cannot generate a setter method for it.
Property '%s' is marked copy on class '%s'.  Cannot generate a copying setter method for NSManagedObject's to-one relationship.
Property '%s' is marked readonly on entity '%@'.  Cannot generate a setter method for it.
Object:
remove
AtIndex:
removeObjectFrom
v@:Q
AtIndexes:
insert
insertObject:in
v@:@Q
:AtIndexes:
v@:@@
replace
replaceObjectIn
AtIndex:withObject:
v@:Q@
AtIndexes:with
validate
:error:
will
Change
Access
v@:@
v@:I
v24@?0@8d16
v20@?0@8f16
d16@?0@8
f16@?0@8
^v16@?0@8
@16@?0@8
@24@?0@8@16
@32@?0@8@16@24
@24@?0@8Q16
@20@?0@8I16
@32@?0@8Q16@24
v@:I@
@28@?0@8I16@20
@32@?0@8@16Q24
v@:@I
@28@?0@8@16I24
v16@?0@"NSKeyValueSetter"8
refreshed
invalidated
invalidatedAll
newQueryGeneration
_NSTriggerModifiedObjectsKey
_NSTriggerModifiedObjectIDsKey
inserted_objectIDs
updated_objectIDs
deleted_objectIDs
refreshed_objectIDs
invalidated_objectIDs
NSObjectsChangedByMergeChangesKey
NSObjectsChangedInManagingContextNotification
_NSObjectsChangedInManagingContextPrivateNotification
NSManagingContextDidSaveChangesNotification
NSManagingContextWillSaveChangesNotification
NSManagedObjectContextWillSaveFromPersistentDocumentNotification
NSManagedObjectContextDidSaveFromPersistentDocumentNotification
NSManagedObjectContextDidSaveObjectIDsNotification
_NSManagedObjectContextDidSaveObjectIDsPrivateNotification
NSManagedObjectContextDidMergeChangesObjectIDsNotification
_NSManagedObjectContextDidMergeChangesObjectIDsPrivateNotification
ImplicitObservation
com.apple.CoreData.ConcurrencyDebug
com.apple.CoreData.Logging.SyntaxColoring
com.apple.CoreData.Logging.oslog
com.apple.CoreData.Logging.stderr
assetsd
xctest
accountsd
CalendarAgent
soagent
Radio
Core Data multi-threading assertions enabled.
Context already has a coordinator;  cannot replace.
An NSManagedObjectContext's retain policy cannot be changed while it has registered objects.  Trying using reset() first.
%@: %@
NSManagedObjectContext over-release triggered improper dealloc here:
Parameter #1 to -assignObject:toPersistentStore: must be an NSManagedObject or subclass.
Can't assign an object to a store that does not contain the object's entity.
storeURL
Can't reassign an object to a different store once it has been saved.
newStoreURL
originalStoreURL
-deleteObject: requires a non-nil argument
An NSManagedObjectContext cannot delete objects in other contexts.
Context does not have a coordinator;  cannot obtain permenant ids without a coordinator.
fatal: Unable to recover from optimistic locking failure.
fatal: This NSManagedObjectContext was created on the main thread and illegally passed to a background thread.
Attempting to generate a constraint exception for non constraint error.
constraint validation failure
attempt to recursively call -save: on the context aborted
stack trace
failed to resolve optimistic locking failure: %@ with %@
failed to resolve optimistic locking failure.  Old save request was: %@
failed to resolve optimistic locking failure.  Next attempt will be: %@
nil is not a valid object ID
NSSaveChangesRequest is not supported by executeRequest:error:
%@ %@ is not a valid NSFetchRequest.
%@ A fetch request must have an entity.
NSConfinementConcurrencyType context %@ cannot support asynchronous fetch request %@.
managed objects
An NSManagedObjectContext cannot refresh objects in other contexts.
NSConcurrencyType
NSFetchTimestamp
NSRetainsRegisteredObjects
NSPropagatesDeleted
NSMergePolicy
An NSManagedObjectContext cannot detect conflicts for objects in other contexts.
Can only use -performBlock: on an NSManagedObjectContext that was created with a queue.
Can only use -performBlockAndWait: on an NSManagedObjectContext that was created with a queue.
Parent NSManagedObjectContext must not be nil.
Parent NSManagedObjectContext must use either NSPrivateQueueConcurrencyType or NSMainQueueConcurrencyType.
NSManagedObjectContext %p: 
NSManagedObjectContext %p
Child contexts inherit parent context generations and may not have their own
Automatic merging is not supported by contexts using NSConfinementConcurrencyType
T@"NSPersistentStoreCoordinator",&
parentContext
T@"NSManagedObjectContext",&
undoManager
T@"NSUndoManager",&,N
T@"NSMutableDictionary",R,N
concurrencyType
insertedObjects
T@"NSSet",R,N
updatedObjects
deletedObjects
registeredObjects
propagatesDeletesAtEndOfEvent
retainsRegisteredObjects
shouldDeleteInaccessibleFaults
stalenessInterval
mergePolicy
queryGenerationToken
T@"NSQueryGenerationToken",R,N
automaticallyMergesChangesFromParent
-performFetch:error: was called on a MOC of NSConfinementConcurrencyType unexpectedly.
cannot record object with null globalID
An NSManagedObject may only be in (or observed by) a single NSManagedObjectContext.
fatal: Failed to re-registered lost fault. fault %p with oid %@ has a moc of %p but we expected %p
deallocated NSManagedObjectContext
Could not allocate memory.
Multiple threads illegally accessing an NSManagedObjectContext (%p) during %@
The current thread is not the recognized owner of this NSManagedObjectContext(%p).  Illegal access during %@
attempt to insert a null object into this context
repairing validation failure %@ (%@) by deleting %@ because it no longer exists and the merge policy allows it
null
NSValidationErrorShouldAttemptRecoveryKey
validation recovery attempt FAILED with %@ and %@.
An observer of NSManagedObjectContextDidSaveNotification illegally threw an exception.  Objects saved = %@ and exception = %@ with userInfo = %@
Objects should not be both modified and additional
Mutating a managed object %@ (%p) that has a different context %p than the receiver %p.
Failed to process pending changes before save.  The context is still dirty after 1000 attempts.  Typically this recursive dirtying is caused by a bad validation method, -willSave, or notification handler.
Serious application error.  Exception was caught during Core Data change processing.  This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification.  %@ with userInfo %@
Serious application error.  Unidentifiable exception was caught during Core Data change processing.  This is usually a bug within an observer of NSManagedObjectContextObjectsDidChangeNotification.
SELF IN %@
Delete propagation prefetching failed with error: %@
Delete propagation prefetching failed with exception: %@
isEditing
illegally invoked -performWithOptions* on dying NSManagedObjectContext at:
-performWithOptions:andBlock: was called on a MOC of NSConfinementConcurrencyType unexpectedly.
Mismatched PSCs in parameter contexts
Context has pending changes
Destination object is not kind of [relationship destinationEntity]
Relationship must be a to-many.
Can't find the order of objects in an unordered relationship
com.apple.CoreData.NSManagedObjectContext.mainQueue
Temporary object ID refers to object in different NSPersistentStoreCoordinator
Object's persistent store is not reachable from this NSManagedObjectContext's coordinator
Invalid state for objectID or NSManagedObjectContext
%p <%@>
T@"NSPersistentStore",R,W
temporaryID
TB,R,GisTemporaryID
+mergedModelFromBundles: Failed to load model at URL %@
Can't merge models with two different entities named '%@'
Can't merge models with two different fetch request templates for name'%@'
 Cannot load NSManagedObjectModel.  nil is an illegal URL parameter
CoreData: Cannot load NSManagedObjectModel.  nil is an illegal URL parameter
 Failed to load model bundle at path '%@'
 Failed to load model as no file exists at path '%@'
 Failed to load optimized model at path '%@'
 Failed to load keyed archive model at path '%@'
 Failed to load NSManagedObjectModel with URL '%@'
NSEntities
PF_DEFAULT_CONFIGURATION_NAME
NSConfigurations
NSFetchRequestTemplates
NSVersionIdentifiers
(%@) isEditable %u, entities %@, fetch request templates %@
Can't add an entity to a managed object model (missing name or bad properties).
Entities for a configuration must already be in the model.
Cannot set fetch request template.  This model does not contain entity '%@'.
entitiesByName
entities
configurations
localizationDictionary
T@"NSDictionary",&
fetchRequestTemplatesByName
versionIdentifiers
T@"NSSet",C
entityVersionHashesByName
Unable to generate optimized model (sql model generation failed: %@)
Invalid property; can't optimize
Base error
Property
Invalid value in warnings array
Can't find hashorder for entity %@
Base Problem
Unknown archive format
Corrupted archive: malformed header
Malformed archive: skipping
Corrupted archive: Mismatched entity count
Corrupted archive: failed to read property name
Corrupted archive: Mismatched string count
Corrupted archive: failed to read entity name or warning string
Corrupted archive: Mismatched data count
Corrupted archive: failed to read data
Corrupted archive: Mismatched strategy count
Corrupted archive: failed to read kkd strategy
NSKnownKeysDictionary2
Allocation failure: unable to allocate properties buffer
Allocation failure: unable to allocate attributes buffer
Allocation failure: unable to allocate relationships buffer
Allocation failure: unable to allocate expressions buffer
Allocation failure: unable to allocate fetched properties buffer
Allocation failure: unable to allocate fetch requests buffer
Allocation failure: unable to allocate entities buffer
Allocation failure: unable to create attributes
Allocation failure: unable to create relationships
Allocation failure: unable to create expressions
Allocation failure: unable to create fetched properties
Allocation failure: unable to create fetch requests
Allocation failure: unable to create entities
Corrupt archive: mismatch between header and contents for attribute count
Corrupt archive: mismatch between header and contents for relationship count
Corrupt archive: mismatch between header and contents for expression count
Corrupt archive: mismatch between header and contents for fetched properties count
Corrupt archive: unable to read property at index: %lu
Corrupt archive: relationship with name (%@) has bad inverse index %@
Corrupt archive: mismatch between header and contents for entity count
Corrupt archive: unable to read entity at index: %lu
Corrupt archive: mismatch between header and contents for fetch request count
Corrupt archive: unable to read fetch request at index: %lu
Can't add unnamed entity to model.
Model already contains an entity named %@.
Mismatch: strategy has %lu length, archive has %u values
Mismatch: frt strategy has %d length, archive has %u values
Mismatch: frt strategy has %lu length, archive has %u values
Corrupted archive (missing pointer space).
System
Library
Models cannot become mutable after being marked immutable.
Can't modify an immutable model.
Can't remove entity - doesn't belong to this model.
momv2$[]qre9743jpo9ad3q;lj;fa38y];`0eruweijfa'etyhpa0e8hfhpaos8e
<NSXPCStoreServerConnectionInfo: 
entitlements = %@ ;
coordinator = %@>
<NSXPCStoreServerConnectionContext: 
entitlements = %@ ;
context = %@>
core data xpc: query generations
coordinator
T@"NSPersistentStoreCoordinator",R,N,V_coordinator
VersionInfo
plist
Info
Exception while loading versioned model plist for %@.
Name: %@
Reason: %@
UserInfo: %@
NSManagedObjectModel_VersionHashes
NSManagedObjectModel_CurrentVersionName
NSMappedObjectStore must be initialized with initWithPersistentStoreCoordinator:configurationName:URL:options:
file:/
-com.apple.CoreData.MigrationDebug
(migration) checking mapping model %@
 source hashes: 
 destination hashes: %@
(migration) mismatched %@%@%@ hashes for mapping model %@
 and 
(migration) no match found for %d of %d mapping model source hashes
(migration) no match found for %d of %d mapping model destination hashes
(migration) found compatible mapping model %@
(migration) looking for mapping model with 
 source hashes: 
 destination hashes: %@
(migration) no suitable mapping model found
Cannot create an inferred NSMappingModel with a nil source model
Cannot create an inferred NSMappingModel with a nil destination model
(migration) inferring a mapping model between data models with 
 source hashes: 
 destination hashes: %@
(migration) inferring mapping model failed with error: %@ userInfo: %@
NSEntityMappings
NSEntityMappingsByName
(%@), entityMappings %@
entityMappings
entityMappingsByName
Can't add unnamed entity mapping to model.
Model already contains an entity mapping named %@.
Mapping Models cannot become mutable after being marked immutable.
Can't modify an immutable mapping model.
Can't generate new column values for %@ - incompatible destination: %@
Can't generate new column value from destination: %@
 = %@
, %@ = %u
Can't generate new column values for destination - incompatible entity foreign key state: %@
%@ = %@
, %@ = %@
Can't generate new column value from value: %@
= %@
aliasGenerator
Can't generate SQL for keypath %@ : invalid location of keypath aggregate function
Can't generate SQL for keypath %@ : invalid keypath
Can't generate SQL for keypath %@ : invalid attribute name location
Can't generate SQL for keypath %@ : multiple to many keypath components
Can't generate SQL for keypath %@ : unexpected problem
Unable to generate sql for components %@
Invalid keypath for update (not an attribute or a to one) %@
Attempting to insert a relationship value into an attribute or vice versa is not supported %@/%@
Invalid keypath expression (%@) in propertiesToUpdate - joins unsupported here
Unable to generate sql for update expression %@
Can't find property %@ on entity %@
Invalid property for update (not an attribute or a to one) %@/%@
Fetch request expression evaluation (%@) failed
Invalid fetch expression (%@) in propertiesToUpdate - fetch has multiple results
Invalid new constant value %@ for %@ (not a managed object)
Invalid value expression (%@) in propertiesToUpdate : what does it mean to update a relationship to the result of a function?
Invalid expression (%@) in propertiesToUpdate
Can't generate new column value from expression %@
, Z_OPT = (Z_OPT + 1) 
serviceName
agentOrDaemon
NSXPCStoreServerEndpointFactory
 Unable to create NSXPCConnection; no service name or factory provided.
 Unable to create NSXPCConnection
 Connection interrupted.
XPC connection was invalidated
 Connection invalidated.
PSCKey
Connection is nil
reply
Created reply dict: %@
Threw obc exception handling request %@
Threw unknown exception handling request
v24@?0@"NSCoreDataXPCMessage"8@"NSData"16
Returning reply dict %@
Failed send (no reply dict).
_NSInMemoryStoreArchivedData
memory://%lx
%@ should be registered.
Bad programmer, no cookie (1)
Bad programmer, no cookie (2)
NSNewGenerationIdentifier
conflictList
object snapshot
cached row
database row
%@ (%p) for NSManagedObject (%p) with objectID '%@' with oldVersion = %d and newVersion = %d and old %@ = %@ and new %@ = %@
%@ (%p) for NSManagedObject (%p) with objectID '%@' with oldVersion = %d and newVersion = <deleted> and old %@ = %@
Coder = %@ (%@)
Delegate = %@ (%@)
This is probably not where you want to be
_source
_snapshot1
_snapshot2
_snapshot3
_oldVersion
_newVersion
snapshot
cachedRow
databaseRow
newVersion
oldVersion
sourceObject
T@"NSManagedObject",R,&,V_source
objectSnapshot
T@"NSDictionary",R,&,V_snapshot1
cachedSnapshot
T@"NSDictionary",R,&,V_snapshot2
persistedSnapshot
T@"NSDictionary",R,&,V_snapshot3
newVersionNumber
TQ,R,V_newVersion
oldVersionNumber
TQ,R,V_oldVersion
%@ (%p) for constraint %@: database: %@, conflictedObjects: %@
constraint
T@"NSArray",R,&,V_constraint
constraintValues
T@"NSDictionary",R,&,V_conflictedValues
databaseObject
T@"NSManagedObject",R,&,V_databaseObject
databaseSnapshot
T@"NSDictionary",R,&,V_databaseSnapshot
conflictingObjects
T@"NSArray",R,&,V_conflictingObjects
conflictingSnapshots
T@"NSArray",R,&,V_conflictingSnapshots
NSTypeCode
Can't merge conflict : missing context
Can't merge conflict : conflicting objects have different entities.
Can't merge conflict : resolution stage failed
That was unexpected. Error trying to get %@ from %@ (%@)
B24@?0@"NSMergeConflict"8@"NSDictionary"16
errorMergePolicy
T@"NSMergePolicy",R
rollbackMergePolicy
overwriteMergePolicy
mergeByPropertyObjectTrumpMergePolicy
mergeByPropertyStoreTrumpMergePolicy
mergeType
%@:%@
_ubiquityRootLocation: %@
transactions: %ld
size: %ld:%ld
reqs: %Lf:%ld
kv: %@:%@
%s(%d): CoreData: Ubiquity:  Tried to stat missing file: %@
-[PFUbiquityBaselineHeuristics bytesForFileAtPath:]
%s(%d): CoreData: Ubiquity:  Error getting the size of a file (%d): %@
%s(%d): CoreData: Ubiquity:  %@
This is confusing, baseline > current for peer: %@(%lu:%lu)
-[PFUbiquityBaselineHeuristics haveEnoughTransactionsToRoll]
%s(%d): CoreData: Ubiquity:  %@
This is confusing, baseline has a transaction for %@(%@) but the current kv doesn't: %@
%s(%d): CoreData: Ubiquity:  Asked to roll baseline, enough disk space has been consumed by logs.
-[PFUbiquityBaselineHeuristics logsConsumeEnoughDiskSpace]
%s(%d): CoreData: Ubiquity:  Asked to roll baseline but not enough space has been consumed yet by the transaction logs.
Store Bytes: %@
Log Bytes: %@
%s(%d): CoreData: Ubiquity:  Enough transactions have passed to roll baseline: %@
-[PFUbiquityBaselineHeuristics canRollBaseline:]
%s(%d): CoreData: Ubiquity:  Asked if rolling the baseline is possible, but the root location does not appear to exist: %@
localPeerID
T@"NSString",R,N,V_localPeerID
storeName
T@"NSString",R,N,V_storeName
ubiquityRootLocation
T@"PFUbiquityLocation",R,N,V_ubiquityRootLocation
modelVersionHash
T@"NSString",R,N,V_modelVersionHash
numRequiredTransactions
Tq,N,V_numRequiredTransactions
storeSize
Tq,R,N,V_storeSize
logSize
Tq,R,N,V_logSize
logToStoreSizeRatio
TD,N,V_logToStoreSizeRatio
minLogBytes
Tq,N,V_minLogBytes
currentBaselineKV
T@"PFUbiquityKnowledgeVector",&,N,V_currentBaselineKV
currentKV
T@"PFUbiquityKnowledgeVector",&,N,V_currentKV
currentEntityMapping
currentPropertyMapping
migrationProgress
T@"NSEntityMapping",&
T@"NSPropertyMapping",&
currentMigrationStep
Cannot create an NSMigrationManager with a nil source model
Cannot create an NSMigrationManager with a nil destination model
Manager requires an entity mapping for associations
Can't find mapping for name (%@).
(migration) got more destinations for source than we expected. (%@, %@, %@)
Property mapping %@.%@ missing required relationship name argument to destinationInstancesForSourceRelationshipNamed:sourceInstances:
Can't find relationship for name (%@) for entity (%@) in source model.
more
fewer
(migration) got %@ destinations[%lu] for sources[%lu] than we expected. (%@, %@)
(migration) got more sources for destination than we expected. (%@, %@, %@)
usesStoreSpecificMigrationManager
mappingModel
T@"NSMappingModel",R
T@"NSManagedObjectContext",R
destinationContext
T@"NSEntityMapping",R
Tf,R
Can't find entity named %@ in source model
Mismatch between mapping and source/destination models
Can't add source store
journal_mode
journal_mode]
Can't add destination store
Failed to save new store after first pass of migration.
Failed to save new store after second pass of migration.
Failed to save new store.
%@ (URL: %@)
T@"NSPersistentStoreCoordinator",R,W,N
configurationName
T@"NSDictionary",R
T@"NSURL",&
Unable to unload store file because file at path '%@' could not be removed
File appeared during sanity check; this seems suspicious
Failed to create file; code = %d
Component of path %@ is not a directory
Failed to access file: %d
Could not write to file.
Store does not support this method
NSStoreType
NSStoreUUID
NStoreMigrationPolicy
NSStoreModelVersionHashes
NSStoreModelVersionIdentifiers
added
removed
changedUUID
NSPersistentStoreCoordinatorStoresWillChangeNotification
NSPersistentStoreCoordinatorStoresDidChangeNotification
_NSPersistentStoreCoordinatorStoresDidChangePrivateNotification
NSPersistentStoreCoordinatorWillRemoveStoreNotification
NSPersistentStoreCoordinatorDidAutomigrateStoreNotification
NSPersistentStoreTypeKey
SQLite
Binary
InMemory
NSXPCStore
NSReadOnlyPersistentStoreOption
NSSQLitePragmasOption
NSSQLitePersistWALOption
NSIgnorePersistentStoreVersioningOption
NSMigratePersistentStoresAutomaticallyOption
NSInferMappingModelAutomaticallyOption
NSPersistentStoreTimeoutOption
NSPersistentStoreOSCompatibility
NSPersistentStoreConnectionPoolMaxSize
NSPersistentStoreUnlinkDestroyOption
NSPersistentStoreForceDestroyOption
NSPersistentStoreUbiquitousContentNameKey
NSPersistentStoreUbiquitousContentURLKey
NSPersistentStoreUbiquitousPeerTokenOption
NSUbiquityIdentityTokenOverrideKey
NSPersistentStoreUbiquitousTransitionTypeKey
NSUbiquityImporterPrivateStoreKey
NSPersistentStoreUbiquitousContainerIdentifierKey
NSPersistentStoreRebuildFromUbiquitousContentOption
NSPersistentStoreUbiquitousSeedStoreURLKey
NSAffectedStoresKey
NSUbiquityOptionsRemovedDuringAutomaticMigrationKey
NSPersistentStoreCoordinatorDidImportExternalRecordsNotification
NSPersistentStoreFileProtectionKey
NSPersistentStoreRemoveUbiquitousMetadataOption
NSAutomaticMigrationUseDocumentDestinationOption
NSPersistentStoreForceLightweightMigrationOption
NSExternalRecordsDirectoryOption
NSExternalRecordsFileFormatOption
NSExternalRecordExtensionOption
NSSQLiteAnalyzeOption
NSSQLiteManualVacuumOption
_NSSQLitePageCacheSizeStoreOption
_NSSQLiteTemporaryStoreOption
_NSSQLitePageSizeStoreOption
_NSNotifyObserversOfStoreChange
NSStoreModelVersionHashesVersion
NSPersistenceFrameworkVersion
NSStoreLastReferecedObjectKey
NSPersistentStoreOrderKeyUpdateNotification
Can only use -performBlock: on an NSPersistentStoreCoordinator that was created with a queue.
Can only use -performBlockAndWait: on an NSPersistentStoreCoordinator that was created with a queue.
 API Misuse: Attempt to serialize store access on non-owning coordinator (PSC = %p, store PSC = %p)
NSPersistentStoreCoordinator %p: 
NSPersistentStoreCoordinator %p
Cannot register a store class using a 'nil' type.
Store type '%@' is reserved for Core Data, and cannot be re-registered.
SQLite f
Invalid store URL: nil
This is not the API you're looking for.
This is not the API you're looking for
Can't create store
Unknown
Cannot set metadata in read-only store.
v16@?0@"NSPersistentStore"8
An NSPersistentStore illegally threw an exception from -willRemoveFromPersistentStoreCoordinator:
client failed to call designated initializer on NSPersistentStoreCoordinator
Cannot create an NSPersistentStoreCoordinator with a nil model
B16@?0@"NSError"8
Store options for external records must specify both the external records directory and the extension to be used
_UNITTESTING_IGNORE_EXTERNAL_RECORDS_PATH
/CoreData/
/Metadata/CoreData/
External records directory must live under ~/Library/CoreData/ or ~/Library/Caches/Metadata/CoreData/
Unsupported store type.
Default
Unable to initialize store.
Can't read store metadata.
The store type in the metadata does not match the specified store type.
The version hash version (and associated hashes) are incompatible with the current Core Data version.
 NOT 
Incompatible version schema for persistent store '%@'.  store metadata = %@ and current model versions = %@
(migration)
 will%@attempt automatic schema migration
CoreData: error: (migration) migration failed with error %@
Error User Info: %@
Underlying error: %@
(migration)
 Automatic schema migration succeeded for store at '%@'
The model used to open the store is incompatible with the one used to create the store
%s(%d): CoreData: Ubiquity:  Post store setup succeded. %@
-[NSPersistentStoreCoordinator addPersistentStoreWithType:configuration:URL:options:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  An error occurred while setting up the ubiquity integration: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error: A persistent store which has been previously added to a coordinator using the iCloud integration options must always be added to the coordinator with the options present in the options dictionary. If you wish to use the store without iCloud, migrate the data from the iCloud store file to a new store file in local storage. %@
This will be a fatal error in a future release.
-addPersistentStoreWithType:%@ configuration:%@ URL:%@ options:%@ ... returned error %@ with userInfo dictionary %@
NSPersistentStoreCoordinator's current model hashes are %@
store is nil or not registered with this coordinator
nil is not a valid store.
nil is not a valid persistent store
nil is not a valid persistent store URL
The specified URI is not a valid Core Data URI: %@
(unknown)
(schema mismatch or migration failure)
(corrupt file)
(device locked)
(can't open)
(permission denied)
(I/O error)
(disk full)
This NSPersistentStoreCoordinator has no persistent stores %@.  It cannot perform a save operation.
Illegal attempt to save to a file that was never opened.  "%@".  Last recorded error = %@ / %@
Illegal attempt to save to a file that was never opened. "%@". No last error recorded.
optimistic locking failure
Save partially failed: %@
NSPersistentStoreRequest
NSPersistentStore
Store returned nil but no error.
NSPersistentStores
Operation unsupported by all stores on this coordinator.
Underlying errors
One or more stores returned an error.
v16@?0@"NSArray"8
Must pass in a store name
%s(%d): CoreData: Ubiquity:  Couldn't delete store file: %@
Will still try to nuke the container.
+[NSPersistentStoreCoordinator removeUbiquitousContentAndPersistentStoreAtURL:options:error:]
OldUbiquitousContent-%@
%s(%d): CoreData: Ubiquity:  Unable to move content directory to new location: %@
New: %@
+[NSPersistentStoreCoordinator removeUbiquitousContentAndPersistentStoreAtURL:options:error:]_block_invoke
v24@?0@"NSURL"8@"NSURL"16
%s(%d): CoreData: Ubiquity:  The coordinated write to remove the ubiquitous contents failed: %@
registeredStoreTypes
persistentStores
UIApplication
URI is not a valid Core Data URI
Can't add the same store twice
Store is not valid for this context's generation
store
context
NSManagedObjectContext is nil for objects passed to obtainPermanentIDsForObjects
Can't resolve how to assign objects to stores; Coordinator does not have any stores
Can't resolve how to assign objects to stores; some objects may have been assigned to stores; use [[managedObject objectID] persistentStore] to find out what is going where now; use [managedObjectContext assignObject:toStore:] to straighten things out
problemObject
Cannot insert objects into a read only store.
Cannot update objects into a read only store.
Cannot update object that was never inserted.
Cannot delete objects into a read only store.
Cannot delete object that was never inserted.
Cannot lock object that was never inserted.
Can't find store type for store %@ (class == %@) in %@.
Cannot change an NSPersistentStoreCoordiantor's QoS after use
Fetch instances of entity %@ from store %@ failed, reason: %@
Referential integrity problem found during migratePersistentStore:toURL:options:withType:error: %@
Save failed during during migratePersistentStore:toURL:options:withType:error:, object added to store during fetch.
Save failed during migratePersistentStore:toURL:options:withType:error:, %d objects in store were removed during fetch.
Save failed.
%s(%d): CoreData: Ubiquity:  Threw while trying to create the actual store url.
token: %@
ubiquityName: %@
+[NSPersistentStoreCoordinator(_NSInternalMethods) ubiquityStoreURLForStoreURL:ubiquityIdentityToken:localPeerID:ubiquityName:]
Invalid destination store URL: nil
Invalid source store URL: nil
source and destination store are different classes of store: %@ != %@
Must supply non-nil entity name.
Invalid entity name - no entity named %@ in model.
This persistent store coordinator does not have any stores.
Must supply non-nil store parameter when multiple stores exist.
The persistent store %@ does not belong to this coordinator.
persistent store must be an SQLite store
entity must not be nil
entity must from this NSPersistentStoreCoordinator's managed object model
entity must be a root entity, not a child entity
Invalid generation token: this persistent store coordinator does not have any of the referenced stores
Provided persistent store must be of type NSSQLiteStoreType: %@
Provided persistent store must be from this coordinator: %@
Exception was caught during NSPersistentStoreCoordinator -performBlock: %@ with userInfo %@
Unidentifiable exception was caught during NSPersistentStoreCoordinator -performBlock.
Exception thrown during autorelease pool drain.
Move
Update
Delete
Insert
Unset
<%@: %p> { object: %p, type: %@%@%@ }
, startIndex: %@
, finalIndex: %@
T@"NSManagedObject",R,&,N,V_object
changeType
TQ,N,V_changeType
startIndexPath
T@"NSIndexPath",&,N,V_startIndexPath
finalIndexPath
T@"NSIndexPath",&,N,V_finalIndexPath
startSectionInfo
T@"_NSDefaultSectionInfo",&,N,V_startSectionInfo
finalSectionInfo
T@"_NSDefaultSectionInfo",&,N,V_finalSectionInfo
NSIsOptional
NSIsReadOnly
NSIsTransient
NSIndexedBySpotlight
NSIsStoredInTruth
NSIsOrdered
NSPropertyName
NSValidationPredicates
NSValidationWarnings
(%@), name %@, isOptional %d, isTransient %d, entity %@, renamingIdentifier %@, validation predicates %@, warnings %@, versionHashModifier %@
 userInfo %@
Can't change name of property from %@ to %@
Mismatch between length of validation predicates and warnings
T@"NSString",C,N
optional
TB,GisOptional
transient
TB,GisTransient
validationPredicates
validationWarnings
indexed
TB,GisIndexed
indexedBySpotlight
TB,GisIndexedBySpotlight
storedInExternalRecord
TB,GisStoredInExternalRecord
Can't read property into shell: Not enough bytes left
Can't read property into shell: Unknown type
Can't read property into shell: Missing version hash value
Corrupted archive (missing property name).
Can't read property into shell: Can't read validation predicates
Can't read property into shell: Can't read validation warnings
<NSBatchUpdateRequest : entity = %@, properties = %@, subentities = %d
This batch update request (%p) was created with a string name (%@), and cannot respond to -entity until used by an NSManagedObjectContext
Invalid string keypath %@ passed to propertiesToUpdate:
Invalid string key %@ passed to propertiesToUpdate:
Attribute/relationship description names passed to propertiesToUpdate must match name on fetch entity (%@)
Invalid property %@ passed as key to propertiesToUpdate:
Invalid expressionDescription %@ passed as key to propertiesToUpdate:
Invalid relationship (%@) passed to propertiesToUpdate:
Can't find entity for batch update (%@)
T@"NSEntityDescription",R,V_entity
T@"NSPredicate",&,V_predicate
propertiesToUpdate
T@"NSDictionary",C,V_columnsToUpdate
NSPropertyTransformMandatoryPropertyValidation
NSDestinationPropertyName
NSValueExpression
NSPropertyTransforms
(%@), name %@, valueExpression %@, userInfo %@
valueExpression
Property Mappings cannot become mutable after being marked immutable.
Can't modify an immutable property mapping.
NSPrerequisiteTransform
NSReplaceMissingValueOnly
(%@), propertyName %@, valueExpression %@, prerequisiteTransform %@, replaceMissingValueOnly %@
propertyName
T@"NSString",&,N,V_propertyName
T@"NSExpression",&,N,V_valueExpression
prerequisiteTransform
T@"NSPropertyTransform",&,N,V_prerequisiteTransform
replaceMissingValueOnly
TB,V_replaceMissingValueOnly
NSMaxCount
NSMinCount
NSDeleteRule
NSDestinationEntity
_NSDestinationEntityName
NSInverseRelationship
_NSInverseRelationshipName
%@, destination entity %@, inverseRelationship %@, minCount %lu, maxCount %lu, isOrdered %d, deleteRule %lu
T@"NSEntityDescription",N
inverseRelationship
T@"NSRelationshipDescription",N
maxCount
minCount
deleteRule
toMany
TB,R,GisToMany
ordered
TB,GisOrdered
repairing missing delete propagation for to-one relationship %@ on object %p (%@) with bad fault %p (%@)
Dangling reference to an invalid object.
Illegal container for relationship: value = %@; relationship = "%@".
repairing missing delete propagation for to-many relationship %@ on object %p (%@) with bad fault %p (%@)
"%@" INTEGER
FOREIGN KEY ("%@") REFERENCES "%@" ("%@")
T@,R,N
%@ { inserts (%@), updates (%@), deletes (%@) locks (%@) }
T@"NSSet",R
lockedObjects
n%u_t%cu
__n%u_var%cu
__var%u
_Z_intarray%u
 - %d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%ld
%s(%d): CoreData: Ubiquity:  Tried to stat a file but part of the directory structure has gone missing: %@
-[PFUbiquityLocationStatus checkFileURLState]
%s(%d): CoreData: Ubiquity:  Error trying to read file (%d): %@
%s(%d): CoreData: Ubiquity:  Error reading resource values for URL: %@
isLive
TB,R,N,V_isLive
isDeleted
TB,R,N,V_isDeleted
isDownloaded
TB,R,N,V_isDownloaded
isDownloading
TB,N,V_isDownloading
isUploaded
TB,R,N,V_isUploaded
isUploading
TB,R,N,V_isUploading
isScheduled
TB,R,N,V_isScheduled
isImported
TB,R,N,V_isImported
isExported
TB,R,N,V_isExported
isFailed
TB,R,N,V_isFailed
numBytes
Tq,R,N,V_numBytes
T@"NSError",R,N,V_error
location
T@"PFUbiquityLocation",R,N,V_location
numNotifications
Tq,R,N,V_numNotifications
NSSQLAttributeTriggerAssociationKey
triggerKeys
constrained
TB,N,GisConstrained
%@: columnName = %@, type = %d, slot = %d, fetchIndex = %d propertyType = %d
Problem with subpredicate %@
 AND 
 NOT (
Unknown compound predicate type %@
Unable to generate compound where clause for predicate (%@) (unknown problem)
entitySpecificationKeypath
entitySpecificationKeypathContainsToMany
selectBindVars
bindVars
com.apple.CoreData.SQLDebug
com.apple.CoreData.ConcurrentFetching
path's fileSystemRepresentation returned NULL
 failed to open file due to illegal URL encoding.  error = %@ with userInfo %@
Cannot create an SQL store with a nil URL.
CoreData SQL stores only support file URLs (got %@).
NSPersistentStoreRemoveStoreOnCleanup
Got a nil sqlmodel
NSXPCStoreDelegate
/var/mobile/Library/Accounts
/private/var/mobile/Library/Accounts
VersionSkewIntermediateFixTable
Bad correlation tables in read-only database
Can't find table for entity %@ in database at URL %@
Exception caught during index recreation %@ with userInfo %@
Exception caught during index recreation %@
Repairing old triggers failed with error = %@ and userInfo = %@
Exception caught during trigger recreation %@ with userInfo %@
Exception caught during trigger recreation %@
pragma auto_vacuum
pragma auto_vacuum=1
vacuum
Exception trying to update primary key table
finished upgrade checks, bumping metadata
Exception caught during _ensureDatabaseMatchesModel %@ with userInfo %@
Exception caught during _ensureDatabaseMatchesModel %@
v16@?0@"NSSQLiteConnection"8
v16@?0@"NSSQLStoreRequestContext"8
cannot find data for a temporary oid: %@
_NSSQLCoreTransactionStateChangeNotification
_NSSQLCoreTransactionType
_NSSQLCoreTransientSequenceNumber
_NSSQLCoreActiveSavingContext
-executeRequest: encountered exception = %@ with userInfo = %@
_SUPPORT
Can't write external data to non-file URL
_EXTERNAL_DATA
Can't create support directory (can't create directory)
Can't create external reference directory (file exists)
Could not connect to database.
_NSAutoVacuumLevel
Failed to delete support directory for store: %@
_transsrc_4052146efa0d85c9fbe0634c0e8bc4457ed82f7c
_transdst_878d188f109e9f52ae70b0b25413f6a38c8267a8
Failed to delete staging area for external support directory for store: %@
Failed to copy support directory from store: %@ to store: %@.  %@
Failed to delete support directory for store: %@.  %@
Failed to copy support directory from store: %@ to store: %@ (failed to move %@ to %@ due to %@)
Failed to unlink support directory %@ from old store location: %@ due to %@
YouTube
Uncaught exception while initializing query generations feature:  %@
Unsupported feature in this configuration
Failed to geta currentQueryGeneration: %@
exception handling request: %@ , %@ with userInfo of %@
Can't fetch UUIDs for non-root entities
databaseValue
UPDATE OR FAIL %@ set %@=%@ where %@ = '%@'
Invalid parameter value (missing parameter)
Invalid parameter value (bad entity)
Invalid parameter value (zero)
failed to retrieve ordering information from fault for object %@ and relationship %@
DELETE FROM %@
presentedItemURL
T@"NSURL",R,C
presentedItemOperationQueue
T@"NSOperationQueue",R,&
primaryPresentedItemURL
isInitialized
UIApplicationSuspendedNotification
Threw during attempt to purge SQL row cache data
columnName
q24@?0@8@16
<NSSQLEntity %@ id=%d>
Trying to add a non-attribute, non-to-one property to an entity: %@
storeRequest
Z_PK
SELECT
COUNT(
DISTINCT
t0.Z_PK)
FROM
SELECT COUNT(*) FROM %@
SELECT COUNT(*) FROM (
 AND (
WHERE 
GROUP BY 
HAVING 
%@%d_%@
%@%@
Unable to generate sql for %@ as part of  expression (%@)
Wrong number of arguments to function add:to: (%@)
Unable to generate sql for add:to: argument 0(%@)
Unable to generate sql for add:to: argument 1(%@)
(SELECT 
) FROM 
restrictingEntityPredicate
 WHERE (
 >= 
Can't generate sql for entityID
 <= 
Unsupported join (min/max(key.path) not allowed in updates)
Invalid keypath element (not a relationship or attribute): %@
Invalid keypath (continues after attribute name): %@
Invalid keypath (request for aggregate operation on a toOne-only keypath): %@
Invalid keypath (too many toMany relationships): %@
count
Invalid keypath (no terminal attribute in call to math aggregate): %@
Failed to generate SQL for function expression: %@
Non-attribute property passed to math function: %@
Unable to generate sql for %@, empty max/etc expression
Unable to generate sql for %@
Unable to generate sql for subquery: %@
Unsupported expression %@
Unable to generate sql for %@() : argument (%@) not supported
Unable to generate sql for %@, empty %@ expression
Unable to generate sql for %@, empty expression
Bad argument to upper/lower function (needs to be a keypath or a string) : %@
Invalid number of parameters passed to uppercase: function
Bad value
Unable to generate sql for %@, can't drop index on non-keypath
Invalid number of parameters passed to function (%@)
Invalid number of arguments to count (requires at least 1 argument)
Unable to generate SQL for count expression %@
count(*)
COUNT(*)
.@count
distinct:
Unable to generate SQL for expression: %@
COUNT (
Unsupported function expression : %@
Invalid number of arguments to avg function : %@
_NSPredicateUtilities
Bad argument to %@ (can't get the %@ of collection) : %@
Bad argument to sum (non-numeric, non-collection argument) : %@
Unable to generate SQL for keypath: %@
Bad argument to aggregate %@ in select (must be a keypath or constant value) : %@
Non-attribute property passed to sum: %@
Unable to generate SQL for subquery: %@
Unsupported argument to sum : %@
Invalid number of arguments to distinct : %@
Invalid argument to distinct : %@
Unable to generate SQL for distinct : %@
DISTINCT 
Invalid number of arguments to now function : %@
Invalid number of arguments to length: function : %@
Invalid argument to length: : %@
Unable to generate SQL for length : %@
length(
NSCoreDataToUpper(
NSCoreDataToLower(
abs(
total
 << 
 >> 
Unsupported function type passed to SQL store
Invalid rowCache row is nil
Optimistic locking failure for %@.  Original row was missing while recording to-many changes.  New row = %@
Optimistic locking failure for %@.  Original row was missing while recording to-many changes.
saveRequest
T@"NSSaveChangesRequest",R
savingContext
transactionInMemorySequence
Ti,N
externalDataReferencesToSave
T@"<_NSCoreDataCollectionWithoutKeys>",R,V_externalDataReferencesToSave
externalDataReferencesToDelete
T@"<_NSCoreDataCollectionWithoutKeys>",R,V_externalDataReferencesToDelete
ignoreInheritance
outerFetch
nestingLevel
Bad NSFetchRequestExpression (%@ propertiesToFetch)
Too few
Too many
Bad fetch request (NSManagedObjectResultType not compatible with contents of propertiesToFetch)
ZZ_PK
Unknown predicate type for predicate: %@
informationGatherer
havingPredicateAnalyser
Invalid fetch request: HAVING with no GROUP BY
Invalid fetch request: GROUP BY requires NSDictionaryResultType
substitutionVariables
Unsupported predicate %@
Unsupported nested update inside of %@
@min
@max
@sum
@avg
nestedWhereSelect
duringPrefetching
subOrder
columnSubOrder
SELECT 0 FROM %@ WHERE 0 = 1
bindIntarrays
fabricatedSQLEntityForReadOnlyFetch
bindIntarraysSubstitutionOrder
NSRemotePersistentStoreDidChangeNotification
skipModelCheck
com.apple.CoreData.XPCDebug
current
unpinned
No service name or endpoint factory supplied
XPC store does not allow models containing external data references
XPC store does not allow models containing ordered relationships
Unable to load model
Unable to initialize client
sendMessage: failed #%d
Unable to sendMessage: to server
Got reply pointer: %p
Got reply: %@
Unable to connect to server with options %@
Unable to send to server; failed after %d attempts.
Problem
 Request failed: (%@).
Send failed with no error; probably something wrong here
 Got success, but also an error. Ignoring the error (%@).
sendMessage: apparently succeeded, but no response or error
No data, cause unknown
CoreData: XPC: Can't move an XPC store from the client
CoreData: XPC: Can't change store identifier from the client
NSXPCStorePostUpdateNotifications
notificationName
generationToken
Failed to enable remote store notifications: Can't get notification name. %@
Failed to enable remote store notifications: %@
Server did not return model version info. (Unsupported configuration.)
Server schema is incompatible and ignore version enabled. (Unsupported configuration.)
Server side store changed, remove and re-add this client store
Unable to load metadata: %@
Unable to decode query generation
Nil result for query generation request
Unable to get query generation: %@
Unable to release query generation: %@
Attempt to release query generation failed: %@
Executing fetch %@
exception info
controlled exception
Fetch threw on server (%@)
Fetch retrieved %lu results from server
Fetch retrieved null, error %@
NSMetadata
locked
unexpected nested save
Attempting to resend what looks like it may be a reinsert
Reinsert hit optimistic locking error, will discard and let the next save resolve it.
Multiple identifers for the same store.
identifiers
Nil response received
Invalid request type
Something unexpected happened: %@ 
Unexpected number of property values returned from server
Firing fault %@
Returning cached value %@
Retrieved node from server %@
Decoded value for %@ - %@ : %@
Got a bad relationship value for %@, %@ (%@)
Wrong number of object IDs returned from server
Wrong number of object IDs returned from server (2)
remoteStoreChangedNotificationName
T@"NSString",R,C,V_remoteStoreChangedNotificationName
com.apple.internetaccounts
com.apple.preferences.internetaccounts.remoteservices
NSUnderlyingExceptionKey
Unsupported function expression %@
Undefined variable expression %@
Unsupported element in aggregate expression %@
Unsupported fetch request expression in update - too many results
Unsupported subquery collection expression type
subquery
Unsupported expression type (%u, %@)
disambiguatingEntity
T@"NSSQLEntity",R,N
disambiguationKeypath
disambiguationKeypathHasToMany
DECIMAL
CHAR
VARCHAR
FLOAT
CLOB
UNDEFINED
INTEGER PRIMARY KEY
entity required
statement required
empty row
missing original
missing fetch request
DELETE FROM %@ WHERE Z_PK = OLD.%@ ; 
UPDATE OR FAIL %@ SET Z_OPT = (Z_OPT + 1) WHERE Z_PK = OLD.%@ ; 
Delete rule is not supported for batch deletes
CREATE TEMPORARY TRIGGER ZQ_%@_TRIGGER AFTER DELETE ON %@ FOR EACH ROW BEGIN %@
CREATE TEMPORARY TRIGGER ZQ_%@_TRIGGER AFTER DELETE ON %@ FOR EACH ROW BEGIN %@ END
DROP TRIGGER ZQ_%@_TRIGGER
CREATE TABLE 
%@ %@ UNIQUE
%@ %@
, CONSTRAINT %@ UNIQUE (
 INTEGER PRIMARY KEY, 
 VARCHAR, 
 INTEGER, 
 INTEGER)
INSERT INTO %@(%@, %@, %@, %@) VALUES(%u, '%@', %u, %qd)
UPDATE OR FAIL %@ SET %@ = MAX((SELECT %@ FROM %@ WHERE %@ = '%@'), (SELECT CASE WHEN (SELECT COUNT(*) FROM %@ )== 0 THEN 0 ELSE (SELECT MAX(%@) FROM %@) END)) WHERE %@ = '%@'
SELECT CASE WHEN (SELECT COUNT(*) FROM %@) == 0 THEN 0 ELSE (SELECT MAX (%@) FROM %@) END
MAX((SELECT %@ FROM %@ WHERE %@ = '%@'), (%@))
MAX((SELECT %@ FROM %@ WHERE %@ = '%@'),
(%@)
UPDATE OR FAIL %@ SET %@ = (%@) WHERE %@ = '%@'
ALTER TABLE 
 RENAME TO 
) SELECT 
 FROM 
DROP TABLE 
, PRIMARY KEY (
%@_%@_INDEX
CREATE INDEX IF NOT EXISTS %@ ON %@ (%@)
CREATE INDEX IF NOT EXISTS %@ ON %@ (%@, %@)
_NSLocationAttributeDerivedComponents
DELETE FROM %@ WHERE Z_PK = OLD.%@
DELETE FROM %@ WHERE %@ = OLD.Z_PK
SELECT RAISE(FAIL, 'Batch delete failed due to mandatory OTO nullify inverse on %@/%@') FROM %@ WHERE Z_PK = OLD.%@
SELECT RAISE(FAIL, 'Batch delete failed due to manadatory OTM nullify inverse on %@/%@') FROM %@ WHERE %@ = OLD.Z_PK
UPDATE OR FAIL %@ SET %@ = NULL, %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK
UPDATE OR FAIL %@ SET %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK
WITH ZCTE_INTERMEDIATE AS (SELECT %@, %@ FROM %@ WHERE %@ = OLD.Z_PK) SELECT RAISE(FAIL, 'Batch delete failed due to mandatory MTM nullify inverse on %@/%@') FROM ZCTE_INTERMEDIATE T0 WHERE (0 == (SELECT COUNT(*) FROM %@ T1 where T1.%@ = T0.%@ and T1.%@ != OLD.Z_PK))
Can't fetch source objects
t0.Z_ENT, 
DELETE FROM %@ WHERE Z_PK IN (%@)
SELECT %@, %@, %@ FROM %@ WHERE Z_PK = %u
T1.%@
SELECT T0.%@, %@, T0.%@ from %@ T0 JOIN %@ T1 on t0.%@ = t1.Z_PK where T0.%@ = %u
SELECT %@, %@, %@ FROM %@ WHERE %@ = %u
Z_PK, Z_ENT
, %@
(%@ IN (
SELECT %@ FROM %@ WHERE 
SELECT Z_PK FROM %@ WHERE %@ IN (
SELECT %@, %@ FROM %@ WHERE Z_PK IN (
 INTERSECT 
Invalid trigger configuration.
Z_RT_%@_%@
CREATE VIRTUAL TABLE IF NOT EXISTS %@ USING RTREE (Z_PK INTEGER PRIMARY KEY, %@_MIN FLOAT, %@_MAX FLOAT, %@_MIN FLOAT, %@_MAX FLOAT)
CREATE TRIGGER IF NOT EXISTS %@_INSERT AFTER INSERT ON %@ FOR EACH ROW BEGIN INSERT OR REPLACE INTO %@ (Z_PK, %@_MIN, %@_MAX, %@_MIN, %@_MAX) VALUES (NEW.Z_PK, NEW.%@ ,NEW.%@, NEW.%@, NEW.%@) ; END
CREATE TRIGGER IF NOT EXISTS %@_UPDATE AFTER UPDATE ON %@ FOR EACH ROW BEGIN DELETE FROM %@ WHERE Z_PK = NEW.Z_PK ; INSERT INTO %@ (Z_PK, %@_MIN, %@_MAX, %@_MIN, %@_MAX) VALUES (NEW.Z_PK, NEW.%@ ,NEW.%@, NEW.%@, NEW.%@) ; END
CREATE TRIGGER IF NOT EXISTS %@_DELETE AFTER DELETE ON %@ FOR EACH ROW BEGIN DELETE FROM %@ WHERE Z_PK = OLD.Z_PK ; END
INSERT OR REPLACE INTO %@ (Z_PK, %@_MIN, %@_MAX, %@_MIN, %@_MAX) SELECT Z_PK, %@, %@, %@, %@ from %@ where %@ NOT NULL and %@ NOT NULL
NSSQLConnectionBeginTransactionNotification
NSSQLConnectionCommitTransactionNotification
NSSQLConnectionRollbackTransactionNotification
NSSQLAdapterFailureKey
NSSQLAdapterOptimisticLockingFailure
NSGeneralAdapterException
CommCenter
SQLQueue %p for %@
Failed to initialize query generation tracking connection, retries left: %d
Attempted to perform an operation without an open database
Attempted to perform another operation with a statement prepared
Attempted to perform another operation with a fetch already in progress
Nested transactions are not supported
[32msql: 
[34m
[47m%@
I/O error for database at %@.  SQLite error code:%d, '%s' errno:%d
I/O error for database at %@.  SQLite error code:%d, '%s'
Fatal error.  The database at %@ is corrupted.  SQLite error code:%d, '%s'
[31m
[47mERROR:
[31m (%d) %s
(%d) %s
error during execution of SQL string '%s' : %s
The database operation timed out after %.2f seconds.
[31m
[47mERROR:
[31m (%d) %@
(%d) %@
error during SQL execution : %@
sql execution time: 
[31m%.4f
[0ms
sql execution time: %.4fs
SELECT MAX(%@) FROM %@
Fetching maximum primary key for entity failed
Y_UBRANGE
synchronous
integrity_check
CREATE TABLE %@ (%@ INTEGER PRIMARY KEY, %@ VARCHAR(255), %@ BLOB)
CREATE TABLE %@ (%@ BLOB)
CREATE TABLE IF NOT EXISTS Y_UBMETA (Y_PK INTEGER PRIMARY KEY ASC, YPEERID VARCHAR UNIQUE, YTRANSACTIONNUMBER INTEGER)
CREATE TABLE IF NOT EXISTS Y_UBRANGE (Y_PK INTEGER PRIMARY_KEY ASC, YPEERID VARCHAR, YENTITYNAME VARCHAR, YRANGESTART INTEGER, YRANGEEND INTEGER, YPEERSTART INTEGER, YPEEREND INTEGER)
CREATE TABLE IF NOT EXISTS Y_UBKVS (Y_PK INTEGER PRIMARY KEY ASC, YKEY VARCHAR UNIQUE, YVALUE VARCHAR)
page_size
pragma %@=%@
pragma %@
pragma recursive_triggers=1
Database failed integrity check.  Corrupted SQLite database at path: %@
lock_proxy_file
pragma %@='%@'
pragma %@=''
auto_vacuum
incremental
:memory:
Connecting to sqlite database file at "%@"
recursive_triggers
webdav
delete
memory
File at path does not appear to be a SQLite database: %@
Cannot create a new database file with the read only option at path: %@
ANALYZE
VACUUM
:auto:
pragma lock_proxy_file='%@'
Failed to set file locking on source database
Failed to open source database
Failed to set file locking on destination database
Failed to open destination database
Failed to replace destination database
Source database Path
%@ failed to close destination database %@
%@ failed to close source database %@
-journal
-wal
ignoring unsupported page_size specified as truncate option: %@
full
unsupported auto_vacuum setting specified as truncate option: %@
-shm
-conch
Failed to truncate database
Disconnecting from sqlite database due to an error.
Disconnecting from sqlite database.
Disconnected from database with pending transactions: %@
Un-finalized statement: %p
BEGIN EXCLUSIVE
BEGIN TRANSACTION
%@ -- %@ %p: attempted to commit a transaction while a fetch was in progress
COMMIT
%@ -- %@ %p: attempted to rollback a transaction while a fetch was in progress
ROLLBACK
Can't demote a connection from being a writer
Optimistic locking failure for %@.  During updateRow.  Original row = %@ New Row = %@ context version match = %d
Optimistic locking failure for %@. During updateRow.  Original row = %p context version match = %d
Optimistic locking failure for %@.  During updateRow, rows processed = %d.  Original row = %@ New row = %@
Optimistic locking failure for %@.  During updateRow, rows processed = %d.
Optimistic locking failure for %@.  During updateConstrainedValuesForRow, rows processed = %d.  New Row = %@
Optimistic locking failure for %@.  During updateConstrainedValuesForRow, rows processed = %d.  Row was updated.
Optimistic locking failure for %@.  During deleteRow.  Original row = %@ New Row = %@ context version match = %d
Optimistic locking failure for %@. During deleteRow. version match = %d
correlation bindings: %qu, %qu, %qu, %qu
v48@?0Q8Q16Q24Q32^B40
correlation bindings:  %qu, %qu
v32@?0Q8Q16^B24
correlation bindings: %qu, %qu, %qu
v40@?0Q8Q16Q24^B32
statement is still active
error during prepareSQL for SQL string '%s' : %s
CoreData: SQLite: error: Can't bind intarray. SQLite error code: %d
Bound intarray %@
Bound intarray value %lu at %d
Bound intarray values.
sqlite3_bind* failed
SQLite bind[%ld] = %@
<NSData len=%lu>
SQLite bind[%ld] = "%@"
SQLite bind[%ld] = (timestamp)%f
SQLite bind[%ld] = (int64)%qd
SQLite bind[%ld] = nil
binding not implemented for this SQLType %d
%lu/%lu
fetching not implemented for this value type
[31m
[47mERROR:
[31m %@
The database appears corrupt.  (invalid entity key)
The database appears corrupt.  (invalid primary key)
Row (pk = %lld) for entity '%@' is missing mandatory text data for property '%@'
pragma locking_mode=EXCLUSIVE
pragma locking_mode=NORMAL
pragma integrity_check
SELECT TBL_NAME FROM SQLITE_MASTER WHERE TYPE = "table" ORDER BY TBL_NAME
TBL_NAME
Encountered exception %@ with userInfo %@ while fetchTableNames from store: %@
SELECT TBL_NAME, SQL FROM SQLITE_MASTER WHERE TYPE = "table" ORDER BY TBL_NAME
Ubiquity: Encountered exception %@ with userInfo %@ while fetchTableCreationSQL from store: %@
SELECT 
 FROM %@ WHERE (
(%@ >= ?)
SELECT TBL_NAME FROM SQLITE_MASTER WHERE TBL_NAME = '%@'
Encountered exception %@ with userInfo %@ while checking table name from store: %@
metadata is not a dictionary: %@
The metadata is not a dictionary: %@
DELETE FROM %@ WHERE %@ = ?
failure writing metadata plist with data bytes: %@
An error %@ occurred converting the metadata plist data: %@
INSERT INTO %@ (%@, %@, %@) VALUES (?, ?, ?)
Saving new meta data; version = %@ ; UUID = %@
SELECT %@, %@, %@ FROM %@
failure reading metadata plist with data bytes: %@
Metadata table is missing database UUID.
Could not initialize compression decoder.
Failed to decompress model cache.
SELECT %@ FROM %@
Could not initialize compression encoder.
INSERT INTO %@ (%@) VALUES (?)
Saving new model cache
unable to cache model: %@
An internal error occurred while configuring functions in the SQLite database.
primary keys must be generated within a transaction
SELECT %@ FROM %@ WHERE %@ = ?
getting max pk for entityID = %u
Fetching maximum primary key failed
UPDATE OR FAIL %@ SET %@ = ? WHERE %@ = ? AND %@ = ?
updating max pk for entityID = %u with old = %qd and new = %qd
Updating max pk failed: %@
pragma auto_vacuum=%@
pragma page_size=%d
pragma journal_mode=wal
creating schema.
Creating primary key table.
re-adding all indices
pragma page_count
pragma freelist_count
pragma incremental_vacuum(%d)
pragma wal_checkpoint(TRUNCATE)
select YPEERID, YTRANSACTIONNUMBER, Y_PK from Y_UBMETA
YPEERID
YTRANSACTIONNUMBER
Y_PK
%s(%d): CoreData: Ubiquity:  Database not open: %@
-[NSSQLiteConnection fetchUbiquityKnowledgeVector]
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Had trouble fetching ubiquity knowledge vector from store: %@
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while fetching ubiquity knowledge vector from store: %@
OLDYTRANSACTIONNUMBER
UPDATE OR FAIL Y_UBMETA set YPEERID="%@", YTRANSACTIONNUMBER=%@ where YTRANSACTIONNUMBER=%@ AND Y_PK=%@
INSERT INTO Y_UBMETA(YPEERID, YTRANSACTIONNUMBER) VALUES("%@", %@)
offendingPeerID
import
offendingOperation
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while updating ubiquity knowledge vector from store: %@
-[NSSQLiteConnection updateUbiquityKnowledgeVector:]
DELETE FROM Y_UBMETA WHERE YPEERID = "%@"
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while replacing ubiquity knowledge vector from store: %@
-[NSSQLiteConnection replaceUbiquityKnowledgeVector:]
UPDATE OR FAIL Y_UBMETA set YPEERID="%@", YTRANSACTIONNUMBER=%@ WHERE YPEERID="%@"
export
sqlString
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while updating ubiquity knowledge for peer from store: %@
-[NSSQLiteConnection updateUbiquityKnowledgeForPeerWithID:andTransactionNumber:]
%s(%d): CoreData: Ubiquity:  Peer already exists in the local knownledge vector
INSERT INTO Y_UBRANGE(YPEERID, YENTITYNAME, YRANGESTART, YRANGEEND, YPEERSTART, YPEEREND) VALUES("%@", "%@", %@, %@, %@, %@)
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while adding peer range for store: %@
-[NSSQLiteConnection addPeerRangeForPeerID:entityName:rangeStart:rangeEnd:peerRangeStart:peerRangeEnd:]
SELECT YPEERID, YENTITYNAME, YRANGESTART, YRANGEEND, YPEERSTART, YPEEREND FROM Y_UBRANGE
YENTITYNAME
YRANGESTART
YRANGEEND
YPEERSTART
YPEEREND
-[NSSQLiteConnection allPeerRanges]
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while fetching all peer ranges for store: %@
Z_NAME
SELECT Z_NAME, Z_MAX FROM Z_PRIMARYKEY WHERE Z_NAME IN (
, '%@'
'%@'
) GROUP BY Z_NAME
Got the wrong number of rows back for the range max query
fetchResultRows
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while creating maps for entities for store: %@
-[NSSQLiteConnection createMapOfEntityNameToPKMaxForEntitiesFromPKTable:]
SELECT YENTITYNAME, MAX(YRANGEEND) FROM Y_UBRANGE WHERE YENTITYNAME IN (
) GROUP BY YENTITYNAME
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while creating maps for entities with range for store: %@
-[NSSQLiteConnection createMapOfEntityNameToPKMaxForEntitiesFromUBRangeTable:]
REPLACE INTO Y_UBKVS(YKEY, YVALUE) VALUES("%@", "%@")
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while setting value in ubiquity table for store: %@
-[NSSQLiteConnection setUbiquityTableValue:forKey:]
select YKEY, YVALUE from Y_UBKVS
YKEY
YVALUE
-[NSSQLiteConnection ubiquityTableKeysAndValues]
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Encountered exception %@ with userInfo %@ while fetching ubiquity table and keys from store: %@
select YVALUE from Y_UBKVS where YKEY = "%@"
-[NSSQLiteConnection ubiquityTableValueForKey:]
DROP TABLE IF EXISTS Y_UBMETA
DROP TABLE IF EXISTS Y_UBRANGE
DROP TABLE IF EXISTS Y_KVS
Ubiquity: Encountered exception %@ with userInfo %@ while dropping tables from store: %@
INSERT INTO Z_METADATA (Z_VERSION) VALUES (999)
DELETE FROM Z_METADATA where Z_VERSION = 999
B32@?0@8Q16^B24
Something is wrong here 1
main
More code needs to be written
connection %p created snapshot: %p
Failed to get sqlite3_snapshot
Something is wrong here 3
connection %p adopting snapshot: %p
Failed to free sqlite3_snapshot
Connection can't register generation: Uncaught exception: %@
isWriter
queue
T@"NSObject<OS_dispatch_queue>",R,N
SQLite format 3
Invalid class type '%@' for lock_proxy_file pragma value, must be an NSNull or NSString
Constraint violation
Constraint violation: %s
no message
error during SQL execution : %s
NSCoreDataPrependExternalReferenceMarker
NSCoreDataLike
NSCoreDataStringSearch
NSCoreDataToUpper
NSCoreDataToLower
NSCoreDataMatches
NSCoreDataStringCompare
NSCollateNoCase
NSCollateNumericallyNoCase
NSCollateLocaleSensitive
NSCollateLocaleSensitiveNoCase
NSCollateFinderlike
NSCoreDataTriggerUpdateAffectedObjectValue
NSCoreDataPrependExternalReferenceMarker: malloc failure
NSCoreDataPrependExternalReferenceMarker: wrong number of parameters
NSCoreDataLike: variant must be an integer in the range [0,3]
NSCoreDataLike: requres 3 arguments (value, pattern, variant)
NSCoreStringSearch: requires 4 arguments (string1, string2, flags, localized)
NSCoreDataTo(Uppercase|Lowercase): requires one argument
NSCoreDataMatches: variant must be an integer in the range [0,3]
NSCoreDataMatches: requres 3 arguments (value, pattern, variant)
NSCoreDataStringCompare: unknown operation type
NSCoreDataStringCompare: incorrect number of arguments
Join being created outside a fetch scope for keypath %@ entity %@
subqueryCollectionContext
Join being created inside an update scope for keypath %@ entity %@
source (%@, %@), destination (%@, %@), correlation (%@)
INNER 
LEFT OUTER 
JOIN 
 ON 
 INNER
 LEFT OUTER
 JOIN 
Unsupported property %@ in update
Unsupported property %@ in update - no joins allowed here
keypathExpressionDestinationRelationship
transient property used in fetch request
to-many key not allowed here
multiple to-many keys not allowed here
this should be inside a fetch or an update
keypaths (joins) not supported in batch update statements
invalid keypath : %@
invalid keypath %@
ambiguous keypath %@
found
propertyDescription
Ambiguous keypath %@
keypath %@ not found in entity %@
LastKeyPathWasTransientProperty
Keypath containing KVC aggregate where there shouldn't be one; failed to handle %@
SELECT clauses in queries with GROUP BY components can only contain properties named in the GROUP BY or aggregate functions (%@ is not in the GROUP BY)
substitutePK
TB,N,V_substitutePK
Unable to generate SQL - non-constant expression for limit substitution.
Unable to generate SQL - non-NSNumber value for limit substitution.
Invalid variable substitution - multiple values not supported for limit %@
 LIMIT %@
 LIMIT -1
 LIMIT %lu
%@_%d%@
REFLEXIVE
FOK_REFLEXIVE
Found a non-transient location property in the SQL store. Unsupported, failing now.
Can't find %@, master for %@ on entity %@. Unsupported, failing now.
Master %@ for %@ is transient. Unsupported, failing now.
Master %@ for %@ isn't an attribute. Unsupported, failing now.
Master %@ for %@ isn't a double. Unsupported, failing now.
Model check failed.
Unsupported join (offsets not allowed in updates)
Invalid SQL (must specify a limit with an offset)
Unable to generate SQL - non-constant expression for offset substitution.
Unable to generate SQL - non-NSNumber value for offset substitution.
 OFFSET %@
 OFFSET %lu
Unsupported join (ordering by mtm not allowed in updates): %@
Unsupported join (ordering by tm not allowed in updates): %@
ORDER BY
unsupported NSSortDescriptor (comparator blocks are not supported)
 COLLATE NSCollateNoCase 
 COLLATE NSCollateNumericallyNoCase 
 COLLATE NSCollateLocaleSensitive 
 COLLATE NSCollateLocaleSensitiveNoCase 
 COLLATE NSCollateFinderlike 
unsupported NSSortDescriptor selector: %@
 DESC
sql connection fetch time: 
[31m%.4f
[0ms
sql connection fetch time: %.4fs
exception raised during multi-threaded fetch %@ (%@)
unidentifiable exception during multi-threaded fetch
result array has %lu entries, but we fetched %d rows
fetch using %@ returned %lu rows
 with values: %@
total fetch execution time: 
[31m%.4f
[0ms for %d rows.
total fetch execution time: %.4fs for %d rows.
Fetch cancelled.  Total fetch execution time: 
[31m%.4f
[0ms.
Fetch cancelled.  Total fetch execution time: %.4fs.
exception %@ raised processing result of multi-threaded fetch (%@)
unidentifiable processing result of multi-threaded fetch
exception %@ raised processing result of multi-threaded fetch while prepopulating objects (%@)
unidentifiable processing result of multi-threaded fetch while prepopulating objects
NSXPCStoreEntitlementNames
NSXPCStoreDaemonize
NSXPCStoreServiceName
NSXPCStoreListener
Can't create server - misconfigured server : %@, %@
Can't create server - misconfigured server : no service name supplied
Options dict contains service name and anonymous listener, using name
Can't create server - unable to load model at path %@
dispatch_queue_attr_make_with_qos_class() returned NULL in %s
com.apple.CoreData.NSXPCStoreServer.%p
Attempting to create non-mach listener with service name.
Listening
Unable to find model
Can't create coordinator - attempting SQLite recovery
Can't create coordinator - just failing
Unable to load store: %@
 Server Connection invalidated.
 Server Incoming connection.
Unable to create stack
Unable to create connection context
NSConnectionInfo
Starting event handler
XPCStore server handling request: %@
Policy rejected connection from client: %@
Token mismatch
Metadata
Fetch
Save
Fault
Rel fault
Request notification name
Illegal input: %u from connection %p
SQLite exception on server: %@, recovery to be attempted
SQLite exception on server: %@, no recovery attempt
SQLite exception on server: %@, no recovery attempt (weird)
Unexpected Core Data exception on server: %@
Unexpected exception on server: %@
Unexpected unknown exception on server
Done event handler
request failed, store identifier mismatch
request failed, insufficient permission
request failed, exception raised during processing
SQLite error on server: %@, recovery being attempted
SQLite error on server: %@, no recovery being attempted
request failed (no result, no error)
Reply handler threw: %@, %@, %@
Request failed, threw in request handler logic (check console for details)
CoreData: XPC: Reply handler threw unknown exception.
Request failed, threw in request handler logic (unknown exception)
Sending reply %p, %p
Sent reply
Failed to set query generation on context: %@ -> %@ (%@)
Got oid  request for %@
Returning result %@
Got save request: %@
Updating metadata
Locking objects :%@
Not locking %@ because it's not in the db
Locking %@
Deleting object :%@
Inserting object with ID %@
Made save request: %@
Got relationship fault request: %@
Can't fulfill relationship fault request: can't find query generation: %@
unrecognized query generation
generation
Attempting to fire fault for %@, %@
originalRequest
Wrong in all kinds of ways. Less colloquially, that should be an object ID, but it's an instance of %@ instead
Fired relationship fault %@ - %@, returning values: %@
Attempted to fire relationship fault %@ - %@, no such luck
Attempting to fire fault for %@
Can't fulfill fault request: can't find query generation: %@
target
missing objectID
Got a fetch request %@
Can't fulfill fetch request: can't find query generation: %@
Which had result %d (%d)
Which archived %d (%d)
Fetch failed returning error %@
Fetch failed with no error.
no store
Got metadata %@
Which archives to %@
Got pull changes result %@
Nil result from pull changes %@
Got queryGeneration %@/%@
Attempting to free nothing (or too many things) %@
T@"NSEntityDescription",R,D
T@"NSManagedObjectID",R,D
<%@ %@ (%@)>
Unable to resolve variable expression: %@
Can't generate select target token for expression: %@
Constant select targets must be values, not collections
Can't generate select target token for constant: %@
Can't generate select target token for fetch request expression: %@
Can't generate SQL for ternary expression: %@
Currently unsupported (%@), try again later
Unsupported value passed to valuesToFetch: (%@) not supported
 AS %@
%@{%@ %d-%qd-%qi
 %@=NULL
 %@=<NSData len=%lu>
 %@="%@"
 %@=%@
 %@=%qd
 %@=%u
 and to-manys=%p}
unexpected key found for: %@
COUNT( 
Unknown predicate operator type parameter
illegal comparison with NULL
IS NULL
IS NOT NULL
Unable to generate SQL for predicate (%@) (problem on LHS)
Unable to generate SQL for predicate (%@) (problem on RHS)
Unable to generate SQL for predicate (%@) (problem with operator)
You really shouldn't be here
NSCoreDataStringCompare(
 , %d, %lu, %d)
%lu) 
Unimplemented SQL generation for predicate (%@)
Unimplemented SQL generatio for predicate (%@)
 NSCoreDataStringSearch(
%lu, %u)
unimplemented SQL generation for predicate (%@).
Invalid input string
Unknown error during string conversion
Malformed string (%@)
Bad string
Malformed string 2 (%@)
%@%C
Unsupported join (not allowed in updates): %@
Unsupported clause (not allowed in updates): %@.
 IN (SELECT 
(SELECT * FROM %@) 
unimplemented SQL generation for predicate : (%@) (bad LHS)
unimplemented SQL generation for predicate : (%@) (bad RHS)
unimplemented SQL generation for predicate : (%@) (LHS and RHS both keypaths)
 IN 
unimplemented SQL generation for predicate : (%@)
 BETWEEN 
Unimplemented SQL generation for predicate : (%@)
Unsupported predicate, LHS of boundedBy: must be a keypath
Unsupported predicate, LHS of boundedBy: is a bad keypath a keypath
Unsupported predicate, LHS of boundedBy: has a keypath (can't find %@)
Malformed keypath: non-terminal attribute %@
Unsupported predicate, LHS of boundedBy: does not terminate with a location attribute
Bad LHS attribute, missing derived lat/long names
Unsupported predicate, LHS of boundedBy: does not terminate with a location
Unsupported predicate, LHS of boundedBy: can't find location attribute
%@.Z_PK IN 
(%@) 
ALL modifier is not implemented
can't use NULL on left hand side
 NSCoreDataLike(
 NSCoreDataMatches(
Unknown/unsupported comparison predicate operator type
Unable to generate where clause for predicate (%@) (unknown problem)
%s <%p> on entity '%@' with sql text '%@'
cachedStatementInfo
T@"NSCachedFetchRequestInfo",&,N,V_cachedStatementInfo
trackChangedRowCount
TB,N,V_trackChangedRowCount
Z_ENT
Z_OPT
Z_FOK
_ent
_opt
Z_METADATA
Z_VERSION
Z_UUID
Z_PLIST
Z_MODELCACHE
Z_CONTENT
Z_PRIMARYKEY
Z_SUPER
Z_MAX
%c%@
@count
COUNT(%@)
COUNT(%@.%@)
@total
Aggregate functions need to work on attributes: %@
Unsupported KVC function in trailing keypath %@, %@
Can't have a non-relationship collection element in a subquery%@
Bad collection keypath (%@) can't find property named (%@) 
Only allowed one toMany/manyToMany relationship in subquery expression collection (%@)
Bad collection keypath in subquery %@ (attribute in non-terminal position)
Unsupported subquery with multiple joins in update columns %@
Unsupported subquery collection type (%@)
Unsupported subquery (too many functions): %@
.@min
.@max
.@sum
.@avg
Unsupported subquery (non-aggregate not allowed in select or update column): %@
Unknown predicate type
origin
storeIdentifier
NSGenerationToken[%@:%qu:%qu]
T@"NSRelationshipDescription",R,N,V_relationship
T@"NSManagedObjectID",R,N,V_objectID
sqlModel
missing variable binding for %@
bad substitution variable for %@, must be a constant value
bad substitution variable for %@, must not be a collection
bad substitution variable for %@, must be a collection
bad substitution variable for %@, must be a collection of objects or objectIDs
oid = %@ [oid class] = %s expecting entity %@
sql cached statement %@ failed due to %@
sql cached statement %@ failed due to %@ with expecting bindings %@ but actual substitution variables %@
T@"NSSQLFetchRequestContext",R,N,V_parentContext
T@"NSFetchRequest",R,N
fetchStatement
T@"NSSQLiteStatement",R,N
T@"NSFetchRequest",R,N,V_originalRequest
storeIsUbiquitized
TB,R,N,V_storeIsUbiquitized
externalDataReferencesDirectory
T@"NSString",R,N,V_externalDataReferencesDirectory
externalDataLinksDirectory
T@"NSString",R,N,V_externalDataLinksDirectory
fileProtectionLevel
Ti,R,N,V_fileProtectionLevel
T@"NSSQLModel",R,N,V_sqlModel
sqlEntityForFetchRequest
T@"NSSQLEntity",R,N,V_sqlEntity
fetchPlan
T@"_PFFetchPlanHeader",R,N,V_fetchPlan
objectIDsToRegisterWithContext
objectsToAwaken
isFaultRequest
TB,N,V_isFaultRequest
shouldUseBatches
TB,R,N,V_shouldUseBatches
prefetchingSubstitutionVariables
T@"NSDictionary",&,N,V_prefetchingSubstitutionVariables
faultsThatWereFired
T@"NSArray",R,&,N,V_resultFaultsThatWereFired
%d%@
NSPrimaryKey64
NSKey
NSRelatedNodes
Can't find entity %@ in model %@
Coalesced prefetch keypaths to : %@
Process fetch request got nil result (check system log for details).
Process fetch request got %d results.
Source object %@ does not exist for relationship fault.
Source object does not match restricting predicate, so returning an error
Threw evaluating predicate for %@: %@
relationship name
self == %@
%@ IN %K
%K == %@
Prefetching inverse to-one relationship "%@".
Prefetched for many-to-many relationship "%@".  Got %lu rows
Which means oidSets %@
Prefetched for one-to-many relationship "%@".  Got %lu rows
Decoding prefetched rows for fetch %@
Prefetched %@/%@ and got no results, stopping now
Prefetched %@/%@ and got %@
swallowed an exception during prefetching of %@, %@: %@
Prefetched for source entity %@, key '%@'.  Got data with length %lu.
Recursively prefetching subkeys %@ of fetch %@ using OIDs %@ for objects %@
swallowed an exception during recursive prefetching for %@, %@: %@
Done prefetching for %@, %@
Process fetch request aborting (predicate is nil)
Process fetch request returning no results (predicate is false)
Saving.
Inserted = %@
Updated = %@
Deleted = %@
Request description was nil.
Request
self in %@
Prefetching keypaths %@, for fetch %@, sources %@
Prefetching %@, subkeypaths = %@
sourceAttributeName
NSManagedObjectIDURI
NSConnectionContext
XPC: Possible API misuse: Unable to find object for managed object URI %@, returning null instead
XPC: Missing oid uri
NSMOIDArchivingToken escaping un-de-tokenized (secured %d).
result
T@,R,V_aggregatedResult
TQ,R,V_resultType
Can't find model for source store
force
Can't find or automatically infer mapping model for migration
Can't find mapping model for migration
.migrationdestination_41b5a6b5c6e848c462a8480cd24caef3
_NSAutomaticMigrationResourceBundlesOption
Unable to delete file (backup external data references URL)
Migration source and destination URLs must be different
sourceURL
destinationURL
(migration) Failed to remove orphaned, partially migrated store file %@: %@
(migration) leaving incompletely migrated store on disk after automatic migration failure. (%@)
NSTemporaryObjectID
NSTemporaryObjectID_default
%s_%x
%@://%@/%@/t%@
strings
Contents
Model
Entity/
Property/
/Entity/
ErrorString/
An instance of %@ requires a non-nil fetchRequest and managedObjectContext
An instance of %@ requires a fetch request with sort descriptors
%@ does not support both change tracking and fetch request's with NSDictionaryResultType
NSFetchedResultsController: cannot access fetched objects before -performFetch:
NSFetchedResultsController: no section at index %lu in sections list
cannot access fetched objects before -performFetch:
no section at index %lu
NSFetchedResultsController: no object at index %lu in section at index %lu
no object at index %lu in section at index %lu
invalid Section Index offset%li
Index title at %li is not equal to '%@'
T@"NSFetchRequest",R,N,V_fetchRequest
T@"NSManagedObjectContext",R,N,V_managedObjectContext
sectionNameKeyPath
T@"NSString",R,N,V_sectionNameKeyPath
cacheName
T@"NSString",R,N,V_cacheName
delegate
T@"<NSFetchedResultsControllerDelegate>",N,V_delegate
fetchedObjects
sectionIndexTitles
sections
The fetched object at index %lu has an out of order section name '%@. Objects must be sorted by section name'
(%@) %@
sectionCount
Fetching ERROR during section computation with request = %@ and error = %@ and userInfo = %@
(NSFetchedResultsController) A section returned nil value for section name key path '%@'. Objects will be placed in unnamed section
q24@?0@"_PFChangeInfo"8@"_PFChangeInfo"16
(NSFetchedResultsController) rebuilding section caches
(NSFetchedResultsController) error refetching objects after context update: %@
B24@?0@"_PFChangeInfo"8@"NSDictionary"16
Serious application error.  An exception was caught from the delegate of NSFetchedResultsController during a call to -controllerDidChangeContent:.  %@ with userInfo %@
Serious application error.  Unidentifiable exception was caught from the delegate of NSFetchedResultsController during a call to -controllerDidChangeContent:.
 (%@): couldn't read cache file to update store info timestamps
 (%@): error writing section cached info at %@ with error %d
 (%@): couldn't create section info cache directory at %@ : %@
 (%@): couldn't create section info file at %@ : %d
.CoreDataCaches
SectionInfoCaches
Name: %@ offset: :%lu count: %lu
sectionInfo
41b5a6b5c6e848c462a8480cd24caef3
Can't generate intermediate for ternary expression predicate.
Can't generate intermediate for ternary expression predicate (unknown type)
(CASE (
Can't generate SQL for ternary expression predicate.
) when 1 then (
Can't generate SQL for ternary expression trueExpression.
) else (
Can't generate SQL for ternary expression falseExpression.
) end)
%@ : %@ -> %@
Unrecognized destination property type in transform
transform
Invalid constant expression type for property type in transform
Unrecognized source property type in transform
NSCoreDataPrependExternalReferenceMarker(length(%@), %@)
Invalid source property type in transform
Unsupported value expression type in transform
Entity mapping includes property transform with unresolved prerequisite
pendingTransforms
sourceEntity
T@"NSSQLEntity",R,V_srcEntity
T@"NSSQLEntity",R,V_dstEntity
T@"NSEntityMapping",R,V_entityMapping
migrationType
Ti,R,V_migrationType
intarrayTable
T^{sqlite3_intarray=},V_intarrayTable
intarrayTableName
T@"NSString",&,V_intarrayTableName
UPDATE OR FAIL %@ SET 
_T_REINDEXINGTABLE
OLD_EN
NEW_EN
ALTER TABLE %@ RENAME TO %@_ORIG
UPDATE OR FAIL %@ SET %@ = (SELECT %@ FROM %@_ORIG WHERE %@ = %d) WHERE %@ = %d
UPDATE OR FAIL %@ SET %@ = 0 WHERE %@ = %d
DROP TABLE %@_ORIG
Failed to generate statements to perform migration
NSSQLiteInPlaceMigrationManager
migrationManagerClass
Failed to create migration statements
Failed to execute migration statements
constraint violation during attempted migration
SELECT count(*) FROM 
 is NULL
 = %d
 NOT IN (SELECT 
 IS NOT NULL)
Validation error missing attribute values on mandatory destination attribute
Validation error missing attribute values on mandatory destination relationship
Validation error missing relationship values on mandatory destination destination
Unrecognized transform validation in property mapping
Z_RT_
 = ( CASE
 WHEN 
 = %d THEN %d
 ELSE 
 END ) WHERE 
 IN (
Can't find entity migration description for entity
adapter
T@"NSSQLiteAdapter",R,V_adapter
%@ : %@ 
Unrecognized entity migration type
entityMigration
Cannot merge multiple root entity source tables into one destination entity root table
sourceRootEntities
destinationRootEntity
Unrecognized source property type for many-to-many migration
sourceRelationship
Unrecognized column in entity
column
Wrong number of columns in migration insert statement
Mismatched columns and values in migration insert statement
_T_%@
 = (SELECT _EKT.
 _EKT WHERE 
 = _EKT.
 WHERE %@ is NULL
, 2000
 IS NOT NULL
 NOT IN (
rootEntity
T@"NSSQLEntity",R,V_rootEntity
NSSQLiteInPlaceMigrationManager requires that the source and destination stores to be NSSQLiteStoreType
(migration) failed to copy store file from %@ to %@. (%@)
Can't copy source store to destination store path
Failed to open the store
Invalid destination data model
Cannot migrate store in-place: 
Cannot migrate store in-place
(migration) leaving incompletely migrated store on disk after in-place migration error. (%@, %@)
unknown error
(migration) in-place migration completed successfully in %2.2f seconds
Unsupported clause (group by not allowed in updates)
Failed to generate SQL for group by property: %@
Unknown predicate type for having predicate: %@
Unsupported clause (having not allowed in updates)
requestType
%@ with fetch request %@
T@"NSFetchRequest",R,V_fetchRequest
completionBlock
T@?,R,V_requestCompletionBlock
estimatedResultCount
Tq,N,V_estimatedResultCount
NSUnderlyingProperty
NSReferenceID
NSEntityDescription
Proxy for prop named %@ on ed %@, real %@
Data may not be nil
%@_%p
v16@?0@"NSURL"8
External data reference can't find underlying file.
File URL
External data reference; unknown problem.
External data reference can't load ubiquitous file.
External Data Reference: <self = %p ; path = %s ; length = %qu>
External Data Reference: <self = %p ; path = nil ; length = %qu>
range {%lu, %lu} exceeds data length %lu
B16@?0@"NSSQLStoreRequestContext"8
filter
T@?,C,N,V_filter
SQLQueue: %@ : %p
 NSSQLConnectionManager tried to blow a lock
Caught a non-object exception in the connectionManager
Cannot mutate an immutable faulting NSOrderedSet
Index of object > number of objects
_NSFaultingMutableOrderedSet
nil order keys and %d objects in real set
bad input oidsAndLocations => should have an even number
%@_%@
_CDSnapshot
_cd_nullFlags2_
[%dC]
_cd_nullFlags_
<deferred relationship fault>
snapshot is marked read only
warning snapshot_get_value_as_object called on NULL
warning snapshot_set_value_as_object called on NULL
_NSMetadataLastIdentifier
Failed to load metadata
Keyspace exhausted
<NSConstraintCacheKey: %@>
<NSConstraintCache : entity = %@, constraint = %@, extension = %@>
v32@?0@8@"NSArray"16^B24
T@"NSArray",R,&,N,V_constraint
extension
T@"NSArray",R,&,N,V_extension
children
T@"NSArray",R,&,N,V_children
%@ - %u
Unable to generate SQL for fetch
Bad request
SELECT COUNT(*) from (%@)
insertObject:in%sAtIndex:
insert%s:atIndexes:
removeObjectFrom%sAtIndex:
remove%sAtIndexes:
replaceObjectIn%sAtIndex:withObject:
replace%sAtIndexes:with%s
%s(%d): CoreData: Ubiquity:  %@
Successfully prefetched managed objects.
-[_PFUbiquityRecordImportOperation applyChangesFromStoreSaveSnapshot:withImportContext:withError:]
%s(%d): CoreData: Ubiquity:  %@
 Error pre-fetching managed objects: %@
 User Info: %@
The operation will attempt to continue, but may fail if it cannot talk to the database.
%s(%d): CoreData: Ubiquity:  %@: Beginning parse of log file: %@
-[_PFUbiquityRecordImportOperation main]
%s(%d): CoreData: Ubiquity:  Aborting cancelled operation: %@
%s(%d): CoreData: Ubiquity:  %@
 Cancelling due to missing switchboard entry
%s(%d): CoreData: Ubiquity:  Error loading comparison metadata for transaction log: %@
%s(%d): CoreData: Ubiquity:  Threw trying to get the knowledge vector from the store: %@
-[_PFUbiquityRecordImportOperation main]_block_invoke
%s(%d): CoreData: Ubiquity:  Ignoring log: %@
The local database has already seen this transaction log: %@
%s(%d): CoreData: Ubiquity:  %@ - Cache KV: %@ matches initial KV: %@
%s(%d): CoreData: Ubiquity:  %@ - Knowledge Vector mismatch, reloading cache
%s(%d): CoreData: Ubiquity:  %@
Metadata store doesn't match local store: (%@:%@)
%s(%d): CoreData: Ubiquity:  import operation's context lost its stack's managedobjectcontext
import operation's context lost its stack
%s(%d): CoreData: Ubiquity:  About to apply changes from log contents.
%s(%d): CoreData: Ubiquity:  %@
Deleting conflict loser because it was orphaned (%@): %@
%s(%d): CoreData: Ubiquity:  Changes applied for transaction log content, managed object context changes: 
inserted: %@
updated: %@
deleted: %@.
Error encountered while importing transaction log at URL: %@, an error occurred saving changes to the persistent store mutated during the import process.
%s(%d): CoreData: Ubiquity:  %@
Successfully wrote changes.
%s(%d): CoreData: Ubiquity:  Import operation: %@
Was beat to the database, rolling back and retrying later.
%s(%d): CoreData: Ubiquity:  Error saving managed object context changes for transaction log: %@
Error: %@
 User Info: %@
 Managed Object Context Changes, inserted: %@
updated: %@
deleted: %@
%s(%d): CoreData: Ubiquity:  About to save stack updates, metadata moc changes: 
inserted: %@
updated: %@
deleted: %@.
%s(%d): CoreData: Ubiquity:  %@
Successfully wrote metadata changes.
%s(%d): CoreData: Ubiquity:  %@
Error writing pending entries: %@
%s(%d): CoreData: Ubiquity:  Error updating peer metadata during import of log file: %@ error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Rolling back metadata changes due to rolled back transaction: %@
%s(%d): CoreData: Ubiquity:  Executing SQL hack to fix primary key issue in SQLite database in import operation: %@
%s(%d): CoreData: Ubiquity:  About to issue update command to primary key table for store: %@
%s(%d): CoreData: Ubiquity:  Import operation interrupted during import: %@
%s(%d): CoreData: Ubiquity:  %@
Bailing because a required external data reference failed to download: %@
%s(%d): CoreData: Ubiquity:  Error importing transaction log: %@, exception: %@
 User Info: %@
exception
CoreData: Ubiquity: Could not find local URI for global ID index: %@
%s(%d): CoreData: Ubiquity:  %@
Got transaction history: %@
For object: %@
Object ID: %@
Initial KV: %@
Import Context: %@
-[_PFUbiquityRecordImportOperation processObjects:withState:andImportContext:outError:]
B24@?0@8@"NSDictionary"16
%s(%d): CoreData: Ubiquity:  %@
Skipping object: %@
Resolved type: %d / %d
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Can't find entity for name: %@ in model: %@
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Unable to locate updated or deleted object with ID: %@, translated from global ID: %@, error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  %@
Object (%@): %@ was resolved to a delete and will not be processed.
%s(%d): CoreData: Ubiquity:  Transaction log: %@ appears an updated object: %@ was deleted.
%s(%d): CoreData: Ubiquity:  Object (%d): %@ which resolved to a delete but appears to already have been deleted from the local store.
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Transaction log: %@
 Error creating object to work with (with state: %d), skipping %@, globalID: %@
%s(%d): CoreData: Ubiquity:  %@
Got nil content for comprssed globalID Index: %@
%s(%d): CoreData: Ubiquity:  Error encountered trying to resolve conflict: %@, error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  %@ successfully applied changes for object with global id: %@
Object ID: %@
%s(%d): CoreData: Ubiquity:  %@ had trouble applying changes for object with global id: %@
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Couldn't find missing object for objectID string: %@
%s(%d): CoreData: Ubiquity:  Transaction log: %@
 Couldn't find missing object for objectID: %@
%s(%d): CoreData: Ubiquity:  %@
 Unable to find relationship destination object: %@
localPeerID: %@
logScore: %@
transactionLog: %@
T@"NSManagedObjectContext",R,V_moc
T@"NSPersistentStoreCoordinator",R,V_psc
T@"PFUbiquityTransactionLog",R,N,V_transactionLog
insertedObjectIDs
T@"NSMutableSet",R,N,V_insertedObjectIDs
updatedObjectIDs
T@"NSMutableSet",R,N,V_updatedObjectIDs
deletedObjectIDs
T@"NSMutableSet",R,N,V_deletedObjectIDs
resolvedConflicts
T@"NSMutableDictionary",R,N,V_resolvedConflicts
logScore
T@"PFUbiquityKnowledgeVector",&,N,V_logScore
T@"NSObject<_PFUbiquityRecordImportOperationDelegate>"
lockedExistingCoord
TB,V_lockedExistingCoord
initialStoreKnowledgeVector
T@"PFUbiquityKnowledgeVector",R,V_initialStoreKnowledgeVector
updatedStoreKnowledgeVector
T@"PFUbiquityKnowledgeVector",&,N,V_updatedStoreKnowledgeVector
importContext
T@"PFUbiquityImportContext",&,N,V_importContext
transactionDidRollBack
TB,R,N,V_transactionDidRollback
success
TB,R,N,V_success
T@"NSError",R,N,V_operationError
wroteKV
TB,R,N,V_wroteKV
PFUbiquityExporterDidMoveTransactionLogNotification
PFUbiquityExporterWillUpdateKnowledgeVectorNotification
localPeerID: %@
ubiquityRootLocation: %@
lastTransactionDate: %@
%s(%d): CoreData: Ubiquity:  Exporter considering response to save: %@
Store: %@
Options: %@
-[_PFUbiquityRecordsExporter shouldRespondToSaveNotification:]
_NSSQLCoreActiveSaveRequest
%s(%d): CoreData: Ubiquity:  Exporter: %@
Will respond.
%s(%d): CoreData: Ubiquity:  Didn't find peer state for local peer ID: %@ after transacation rolled back: %@
-[_PFUbiquityRecordsExporter cleanUpFromRolledbackPendingTransaction:withNotification:]
%s(%d): CoreData: Ubiquity:  %@
Looks like log file was never written: %@
-[_PFUbiquityRecordsExporter cleanUpFromRolledbackPendingTransaction:withNotification:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error deleting invalidated log file at url: %@
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Error trying to recover store metadata from rolled back transaction: %@
 User Info: %@
Store Metadata: %@
Transaction log: %@
%s(%d): CoreData: Ubiquity:  Got notification that store is about to commit: %@
-[_PFUbiquityRecordsExporter managedObjectContextDidSave:]
debug.kvStr
exportingPeerID
%s(%d): CoreData: Ubiquity:  %@
Error moving log to permanent location: %@
Error: %@
 User Info: %@
Just testing
%s(%d): CoreData: Ubiquity:  %@
Failed to save to the database after 100 tries to optimistically lock the knowledge vector: %@
%s(%d): CoreData: Ubiquity:  %@ Successfully wrote transaction log: %@
%s(%d): CoreData: Ubiquity:  %@
Skipping transaction history caching, using local storage.
%s(%d): CoreData: Ubiquity:  %@
Transaction Entries: %@
%s(%d): CoreData: Ubiquity:  Added transaction entries to cache
%s(%d): CoreData: Ubiquity:  Error caching transaction entries after export: %@
%s(%d): CoreData: Ubiquity:  Wrote pending entries to disk and purged cache, it will be rebuilt
%s(%d): CoreData: Ubiquity:  Error purging cache for transaction entries: %@
%s(%d): CoreData: Ubiquity:  No transaction history cache found for store: %@
transactionNumber
%s(%d): CoreData: Ubiquity:  Error writing transaction log: %@.
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Export of save notification encountered the following errors: %@, 
Save Notification: %@
%s(%d): CoreData: Ubiquity:  An exception occurred during a log file export: %@ save notification contents: %@
_NSSQLCoreTransactionExternalDataReferencesToDelete
%s(%d): CoreData: Ubiquity:  %@ exporting inserted objects: %@
-[_PFUbiquityRecordsExporter createDictionaryForObjectsInSaveNotification:forTransactionOfType:withExportContext:andSaveSnapshot:]
%s(%d): CoreData: Ubiquity:  %@ exporting updated objects: %@
%s(%d): CoreData: Ubiquity:  %@ exporting deleted objects: %@
%s(%d): CoreData: Ubiquity:  Skipping object from a store that this exporter is not responsible for. Object ID: %@, exporter: %@
%s(%d): CoreData: Ubiquity:  Unable to delete ubiquitous external reference file during aborted transaction: %@
 User Info: %@
-[_PFUbiquityRecordsExporter createDictionaryForObjectsInSaveNotification:forTransactionOfType:withExportContext:andSaveSnapshot:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error adding object to save snapshot: %@
 User Info: %@
 Object: %@
offendingObject
CoreData: Ubiquity: Unable to export content for managed object.
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Exception trying to transfer logs from temporary directory to ubiquity sync'd directory. Exception: %@
 User Info: %@
-[_PFUbiquityRecordsExporter moveLogsFromTempDirectory]
%s(%d): CoreData: Ubiquity:  %@
Encountered an error while trying to move logs out of the temporary directory: %@
 Rescheduling move timer.
%s(%d): CoreData: Ubiquity:  %@
Asked to schedule a temporary log move without a queue
-[_PFUbiquityRecordsExporter scheduleTempLogMove]
T@"PFUbiquityLocation",&,N,V_ubiquityRootLocation
localRootLocation
T@"PFUbiquityLocation",R,N,V_localRootLocation
currentRootLocation
T@"PFUbiquityLocation",R,N
lastTransactionDate
T@"NSDate",&,V_lastTransactionDate
pendingTempLogMove
TB,R,N,V_pendingTempLogMove
allowTempLogStorage
TB,N,V_allowTempLogStorage
useLocalStorage
TB,N,V_useLocalStorage
throwOptimisticLockingException
TB,N,V_throwOptimisticLockingException
com.apple.coredata.ubiquity.importer.didfinishimport
com.apple.coredata.ubiquity.monitorqueue.root
com.apple.coredata.ubiquity.importer.privateQueue
ubiquityRootLocation: %@
localPeerID: %@
%s(%d): CoreData: Ubiquity:  Log locations: %@
-[_PFUbiquityRecordsImporter createSortedOperationsArrayWithMetadata:isFirstImport:]
%s(%d): CoreData: Ubiquity:  Skipping (storeName): %@
%s(%d): CoreData: Ubiquity:  Skipping (model version hash): %@
%s(%d): CoreData: Ubiquity:  Transaction log went missing: %@
%s(%d): CoreData: Ubiquity:  Error loading comparison metadata for transaction log: %@
Error: %@
 User Info: %@
%s(%d): CoreData: Ubiquity:  Transaction log was ignored because it could not be opened, there was no error, so this probably means it was unreadable by the local peer (a different type than this peer accepts). %@
%s(%d): CoreData: Ubiquity:  %@
Skipping log because it is of unknown type: %@
%s(%d): CoreData: Ubiquity:  %@
Skipping log because it has already been imported into the local store: %@
storeKV: %@
logKV: %@
%s(%d): CoreData: Ubiquity:  Couldn't find transaction number in log at URL: %@
Log Contents: %@
%s(%d): CoreData: Ubiquity:  Created operations: %@
%s(%d): CoreData: Ubiquity:  %@ will process operation: %@
%s(%d): CoreData: Ubiquity:  %@
Skipping incompatible operation (%@): %@
%s(%d): CoreData: Ubiquity:  Checking for forked Peer from op %@ and local KV %@
-[_PFUbiquityRecordsImporter isPeerForked:andLocalKV:]
%s(%d): CoreData: Ubiquity:  Peer only knew of itself...forking
%s(%d): CoreData: Ubiquity:  Peer has possibly never been seen...forking
%s(%d): CoreData: Ubiquity:  Peer has never been seen...forking
%s(%d): CoreData: Ubiquity:  Peer has not been seen in a long while...forking
%s(%d): CoreData: Ubiquity:  Peers are not that far off from each other, maybe the logs are on their way
%s(%d): CoreData: Ubiquity:  Peer not found in all peers - has never been seen...forking
%s(%d): CoreData: Ubiquity:  %@
Can't process log with score: %@ after log with score: %@
 It is ahead of the local peer.
-[_PFUbiquityRecordsImporter canProcessTransactionLogWithScore:afterLogWithScore:]
%s(%d): CoreData: Ubiquity:  %@
Cannot process log with score: %@ after log with score: %@
It will attempt to increment two peers simultaneously.
%s(%d): CoreData: Ubiquity:  %@
Encountered errors trying to download logs, but can continue import: %@
-[_PFUbiquityRecordsImporter checkSchedulingContextForMissingLocalPeerOperations:error:]
Unable to import logs because of failed requisit foreign peer logs.
schedulingContext
%s(%d): CoreData: Ubiquity:  %@ importing operations: 
-[_PFUbiquityRecordsImporter scheduleTransactionLogOperations:synchronous:error:]
%s(%d): CoreData: Ubiquity:  Import operation failed while synchronously restoring logs, aborting: %@
Error: %@
 User Info: %@
Operations: %@
%s(%d): CoreData: Ubiquity:  %@
Asked to schedule but nothing to schedule in the context: %@
-[_PFUbiquityRecordsImporter schedulePendingLogs:error:]
%s(%d): CoreData: Ubiquity:  Ignoring pending log (exisitng op): %@
%s(%d): CoreData: Ubiquity:  %@
No more logs to schedule
%s(%d): CoreData: Ubiquity:  %@
Created sorted operations (%d): %@
%s(%d): CoreData: Ubiquity:  %@
Scheduling operations (%d): %@
%s(%d): CoreData: Ubiquity:  %@
Finished scheduling logs with context: %@
%s(%d): CoreData: Ubiquity:  %@
Will reschedule pending logs: %@
Container may be forked
Container is forked
%s(%d): CoreData: Ubiquity:  Starting scan of location: %@
-[_PFUbiquityRecordsImporter discoverAndImportAllAvailableLogs:error:]
%s(%d): CoreData: Ubiquity:  Started download for logs: %@
-[_PFUbiquityRecordsImporter discoverAndImportAllAvailableLogs:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error while starting download for logs: %@
Logs: %@
%s(%d): CoreData: Ubiquity:  Exception while scanning for logs to import: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Librian returned a serious error for starting downloads %@ with userInfo %@
-[_PFUbiquityRecordsImporter batchDownloadTransactionLogsAtLocations:error:]_block_invoke
v16@?0@"NSError"8
-[_PFUbiquityRecordsImporter batchDownloadTransactionLogsAtLocations:error:]
%s(%d): CoreData: Ubiquity:  Initiated download for urls: %@
%s(%d): CoreData: Ubiquity:  %@
Didn't get an object ID back for the application's coordinator: %@
-[_PFUbiquityRecordsImporter createNewSetOfObjectIDsForCoordinator:fromObjectIDs:]
%s(%d): CoreData: Ubiquity:  %@
Got set of persistent store coordinators for store named: %@
Coordinators: %@
-[_PFUbiquityRecordsImporter postImportNotificationForStoreName:andLocalPeerID:withUserInfo:]
NSApplication
%s(%d): CoreData: Ubiquity:  Posting import notification: %@
For coordinator: %p
-[_PFUbiquityRecordsImporter postImportNotificationForStoreName:andLocalPeerID:withUserInfo:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@ throttling notification for operation: %@
-[_PFUbiquityRecordsImporter operationDidFinish:]
%s(%d): CoreData: Ubiquity:  %@
Operation missing transaction log location: %@
%s(%d): CoreData: Ubiquity:  %@
Wrote pending entries to disk after imports finished.
%s(%d): CoreData: Ubiquity:  %@
Error attempting to write pending transaction history to disk: %@
User Info: %@
%s(%d): CoreData: Ubiquity:  Import operation encountered had trouble importing log file, %@
 User Info: %@
 The log file is at: %@.
Operation: %@
-[_PFUbiquityRecordsImporter operation:failedWithError:]
%s(%d): CoreData: Ubiquity:  Import operation was beat into the data store: %@
%s(%d): CoreData: Ubiquity:  Import operation had trouble with the fileystem, %@
 User Info: %@
 The log file is at: %@.
Operation: %@
%s(%d): CoreData: Ubiquity:  Import operation had trouble with conflict resolution: %@
userInfo: %@
 It appears that the operation was beat to the database.
%s(%d): CoreData: Ubiquity:  Import operation encountered an error: %@
userInfo: %@. While trying to import the log file at the URL: %@
%s(%d): CoreData: Ubiquity:  Operation was interrutped by import: %@
-[_PFUbiquityRecordsImporter operationWasInterruptedDuringImport:]
%s(%d): CoreData: Ubiquity:  Restart timer fired for importer: %@
-[_PFUbiquityRecordsImporter scheduleRecoveryTimer]_block_invoke
%s(%d): CoreData: Ubiquity:  Ubiquity root url: %@ did not pass processing sanity check. Error: %@
userInfo: %@
+[_PFUbiquityRecordsImporter canProcessContentsOfUbiquityRootPath:]
.cdmetadata
%s(%d): CoreData: Ubiquity:  Scheduling response to baseline: %@
-[_PFUbiquityRecordsImporter scheduleBaselineRollResponseOperationForBaselineAtLocation:]
%s(%d): CoreData: Ubiquity:  Registered coordinators: %@
%s(%d): CoreData: Ubiquity:  store name: %@ - %@
%s(%d): CoreData: Ubiquity:  Store: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to schedule baseline roll response operation for location (store active but not found): %@
%s(%d): CoreData: Ubiquity:  Adding operation
%s(%d): CoreData: Ubiquity:  %@
Unable to schedule roll response operation for location (store not active): %@
%s(%d): CoreData: Ubiquity:  %@
Unable to schedule roll response operation for location (monitoring): %@
%s(%d): CoreData: Ubiquity:  %@
Scheduling baseline recovery operation on behalf of: %@
-[_PFUbiquityRecordsImporter scheduleBaselineRecoveryOperationWithActiveBaselineOperation:]
%s(%d): CoreData: Ubiquity:  %@
Refreshed peer range cache after baseline roll.
-[_PFUbiquityRecordsImporter recoveryOperation:didReplaceLocalStoreFileWithBaseline:]
%s(%d): CoreData: Ubiquity:  %@
Error attempting to refresh peer range cache: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully adopted baseline: %@
-[_PFUbiquityRecordsImporter rollResponseOperation:successfullyAdoptedBaseline:]
%s(%d): CoreData: Ubiquity:  Refreshed peer range cache
%s(%d): CoreData: Ubiquity:  %@
Encountered an error while trying to respond to the roll of baseline: %@
Error: %@
userInfo: %@
-[_PFUbiquityRecordsImporter rollResponseOperation:encounteredAnError:whileTryingToAdoptBaseline:]
%s(%d): CoreData: Ubiquity:  %@
Successfully recovered metadata for store: %@
-[_PFUbiquityRecordsImporter metadataInconsistencyDetectedForStore:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Error during metadata recovery for store: %@
Error: %@
User Info: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully recached transaction history
%s(%d): CoreData: Ubiquity:  %@
Error attempting to recache transaction history: %@
User Info: %@
%s(%d): CoreData: Ubiquity:  %@
Error attempting to drop the transaction history cache: %@
%s(%d): CoreData: Ubiquity:  %@
Error scheduling root scan after metadata recovery: %@
%s(%d): CoreData: Ubiquity:  Error while trying to create the import coordinator as store URL is nil.
+[_PFUbiquityRecordsImporter addPrivateStore:toCoordinator:atURL:error:]
%s(%d): CoreData: Ubiquity:  Error while trying to create the import coordinator: %@
importQueue
T@"NSOperationQueue",R,V_importQueue
T@"NSString",R,V_localPeerID
T@"NSString",R,V_storeName
isMonitoring
TB,R,V_isMonitoring
logRestartTimer
T@"NSObject<OS_dispatch_source>",V_logRestartTimer
schedulingLock
T@"NSRecursiveLock",R,N,V_schedulingLock
importOnlyActiveStores
TB,V_importOnlyActiveStores
throttleNotifications
TB,V_throttleNotifications
allowBaselineRoll
TB,V_allowBaselineRoll
T@"PFUbiquityRecordsImporterSchedulingContext",R,N,V_schedulingContext
sideLoadCacheWrapper
T@"PFUbiquitySwitchboardCacheWrapper",&,N,V_sideLoadCacheWrapper
privateStore
T@"NSPersistentStore",R,N,V_privateStore
privatePSC
T@"NSPersistentStoreCoordinator",R,N,V_privatePSC
.cdmetadata.nosync
metadata.nosync
metadata.store
%s(%d): CoreData: Ubiquity:  Initializing stack(%@) with metadata entry: %@
-[_PFUbiquityStack initWithMetadataEntry:]
%s(%d): CoreData: Ubiquity:  Setting up metadataMOC for stack: %@
%@: 
localPeerID: %@
ubiquityRootURL: %@
metadataContainerURL: %@
-[_PFUbiquityStack purgeAndInitializeMetadataStoreFileWithError:]
max:(transactionNumber)
PFUbiquityTransactionEntry
actingPeer.peerKey
%s(%d): CoreData: Ubiquity:  Error getting knowledge vector from metadata store: %@
-[_PFUbiquityStack createMetadataStoreKnowledgeVector:]
min:(transactionNumber)
-[_PFUbiquityStack createMinMetadataStoreKnowledgeVector:]
metadataMOC
T@"NSManagedObjectContext",R,N,V_metadataMOC
metadataEntry
T@"PFUbiquityMetadataFactoryEntry",R,N,V_metadataEntry
ubiquityRootURL
T@"PFUbiquityLocation",R,N,V_ubiquityRootURL
metadataStoreFileLocation
T@"PFUbiquityLocation",R,N,V_metadataStoreFileLocation
T@"NSBatchDeleteRequest",R,N
fetchRequestForObjectsToDelete
T@"NSFetchRequest",R,&,N
deleteStatements
T@"NSArray",R,&,N,V_deleteStatements
fetchContext
T@"NSSQLFetchRequestContext",R,&,N
affectedObjectIDs
T@"NSArray",&,N,V_deletedObjectIDs
PFUbiquityPeer
peerKey == %@
%s(%d): CoreData: Ubiquity:  Error getting peer: %@
+[PFUbiquityPeer(UbiquityMethods) peerForPeerID:inManagedObjectContext:createIfMissing:]
%s(%d): CoreData: Ubiquity:  Found more than one peer object for peer ID: %@
peerCode
%s(%d): CoreData: Ubiquity:  Error getting all peers: %@
+[PFUbiquityPeer(UbiquityMethods) allPeersInManagedObjectContext:]
PFUbiquityPeerState
storeName == %@ AND peer.peerKey == %@ AND storeMetadata.ubiquityName == %@
%s(%d): CoreData: Ubiquity:  Error or too many peer states: %@, error: %@
+[PFUbiquityPeerState(UbiquityMethods) peerStateForStoreName:andPeerID:inManagedObjectContext:createIfMissing:]
storeName == %@ AND peer.peerKey != %@
%s(%d): CoreData: Ubiquity:  Error while fetching all peer states: %@
+[PFUbiquityPeerState(UbiquityMethods) peerStatesMatchingStoreName:inManagedObjectContext:omittingLocalPeerID:]
storeName == %@
+[PFUbiquityPeerState(UbiquityMethods) peerStatesMatchingStoreName:inManagedObjectContext:]
lastProcessedTransactionLogURL
T@"NSString",&,D,N
T@"NSNumber",&,D,N
peer
T@"PFUbiquityPeer",&,D,N
storeMetadata
T@"PFUbiquityStoreMetadata",&,D,N
API misuse: there shouldn't be a connection here
*RequestContext connection may not be reset
sqlCore
T@"NSSQLCore",R,N
connection
T@"NSSQLiteConnection",&,N,V_connection
persistentStoreRequest
T@"NSPersistentStoreRequest",R,N,V_persistentStoreRequest
T@"NSManagedObjectContext",R,N,V_context
localError
T@"NSError",&,N,V_error
debugLogLevel
Ti,R,N
useColoredLogging
TB,R,N,V_useColoredLogging
useConcurrentFetching
TB,R,N,V_useConcurrentFetching
T@,&,N,V_result
T@,&,N,V_exception
rowCache
T@"NSSQLRowCache",R,N
isWritingRequest
shouldRegisterQueryGeneration
PFUbiquityStoreMetadata
%s(%d): CoreData: Ubiquity:  Error locating metadata for local persistent store: %@, stores: %@
+[PFUbiquityStoreMetadata(UbiquityMethods) allStoreMetadataInManagedObjectContext:]
ubiquityName == %@
+[PFUbiquityStoreMetadata(UbiquityMethods) storeMetadatasWithName:inManagedObjectContext:]
%s(%d): CoreData: Ubiquity:  Looks like the container URL moved for store metadata: %@
New Container URL: %@
Old: %@
-[PFUbiquityStoreMetadata(UbiquityMethods) updateWithStore:andRootLocation:]
PFUbiquityPeerRange
%s(%d): CoreData: Ubiquity:  loadFromBaselineMetadata: lost its stack and failed.
-[PFUbiquityStoreMetadata(UbiquityMethods) loadFromBaselineMetadata:withLocalPeerID:]
peer.peerKey == %@ AND storeName == %@
%s(%d): CoreData: Ubiquity:  Error fetching peer state for peerID: %@, error: %@
-[PFUbiquityStoreMetadata(UbiquityMethods) peerStateForPeerID:]
%s(%d): CoreData: Ubiquity:  Error fetching peer state for peerID: %@, too many peer states found: %@
baseline.store
baseline.model
baseline.gcmodel
meta.plist
.baseline
CoreData: Ubiquity: baseline directory unreachable: %@
%s(%d): CoreData: Ubiquity:  Error setting store options on store metadata: %@, options: %@
NSKeyedUnarchiveFromData transformer returned nil
-[PFUbiquityStoreMetadata(UbiquityMethods) setStoreOptions:]
storeOptions
T@"NSURL",R,N
T@"PFUbiquityLocation",R
PFUbiquityRemotePeerState
%s(%d): CoreData: Ubiquity:  Error while fetching all remote peer states for store name: %@
error: %@
+[PFUbiquityRemotePeerState(UbiquityMethods) remotePeerStatesMatchingStoreName:inManagedObjectContext:]
storeName == %@ AND peerID == %@
%s(%d): CoreData: Ubiquity:  Error while fetching all remote peer states for store identifier: %@
error: %@
+[PFUbiquityRemotePeerState(UbiquityMethods) remotePeerStatesMatchingStoreName:andPeerID:inManagedObjectContext:]
peerID
peerStart
peerEnd
rangeStart
rangeEnd
globalIDStr == %@
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Trouble fetching transaction entries from metadata store: %@
userInfo: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesMatchingGlobalObjectID:inManagedObjectContext:]
localIDStr == %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesMatchingLocalObjectID:inManagedObjectContext:]
(actingPeer.peerKey == %@ AND transactionNumber > %@ AND storeMetadata.ubiquityName == %@)
transactionDate
globalIDStr
knowledgeVectorString
%s(%d): CoreData: Ubiquity:  Conflict metadata fetch failed with error: %@
userInfo: %@
 Conflict resolution will not work. Original Fetch Request: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:]
+[PFUbiquityTransactionEntry(UbiquityMethods) deleteTransactionEntriesAfterPeerState:forStoreName:inManagedObjectContext:]
actingPeer.peerKey == %@ AND transactionNumber == %@
%s(%d): CoreData: Ubiquity:  CoreData: Ubiquity: Error fetching transaction entries: %@
userInfo: %@ with fetch request: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesForPeerID:withTransactionNumber:inManagedObjectContext:]
(actingPeer.peerKey == %@ AND transactionNumber < %@ AND storeMetadata.ubiquityName == %@)
%s(%d): CoreData: Ubiquity:  Got nil transaction entries for fetch request: %@
Error: %@
userInfo: %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntriesForPeerID:beforeTransacationNumber:forStoreNamed:inManagedObjectContext:]
actingPeer.peerKey == %@ AND transactionNumber == %@ AND globalIDStr == %@
+[PFUbiquityTransactionEntry(UbiquityMethods) transactionEntryForGlobalIDString:withActingPeerID:atTransactionNumber:inManagedObjectContext:]
transactionType
transactionLogURL
T@"NSURL",R
com.apple.coredata.ubiquity.logLevel
%s(%d): CoreData: Ubiquity:  Checking log level threw: %@
-[PFUbiquityLogging init]_block_invoke
desiredLogLevel
Ti,N,V_desiredLogLevel
Invalid EventType %u
%@:%@
idString
T@"NSString",R,N,V_idString
Tq,R,N,V_hash
eventType
Tq,R,N,V_eventType
%@:%@->%ld:%@
Begin
Diagnostic
Debug
Warning
Error
Fatal
logLevel
Tq,V_logLevel
PFUbiquitySetup
PFUbiquityTransactionExport
PFUbiquityTransactionImport
PFUbiquityTransactionConflict
PFUbiquityBaselineRoll
PFUbiquityFilePresenterDiscoveredLogLocationsNotification
PFUbiquityFilePresenterBaselineFileChangedNotification
PFUbiquityFilePresenterReceiptFileChangedNotification
PFUbiquityLocationsWereScheduledNotification
PFUbiquityLocationImportCancelledNotification
PFUbiquityLocationWasImportedNotification
PFUbiquityLocationWasExportedNotification
PFUbiquityFilePresenterAddPathsNotification
PFUbiquityFilePresenterPrintStatusNotification
PFLogLocationsKey
PFReceiptLocationKey
PFBaselineLocationKey
/System/Library/PrivateFrameworks/CloudDocs.framework/CloudDocs
BRStartDownloadForItems
CloudDocs.framework missing symbol BRStartDownloadForItems
BRRegisterInitialSyncHandlerForContainer
CloudDocs.framework missing symbol BRRegisterInitialSyncHandlerForContainer
BRUbiquitousContainersRootFolderName
CloudDocs.framework missing symbol BRUbiquitousContainersRootFolderName
Unable to dynamically link CloudDocs.framework
Mobile Documents
com.apple.coredata.ubiquity.fpqueue
ubiquityRootLocation: %@
localPeerID: %@
%s(%d): CoreData: Ubiquity:  %@
Got change notification for url: %@
-[PFUbiquityFilePresenter presentedSubitemDidChangeAtURL:]
%s(%d): CoreData: Ubiquity:  %@
Processing pending urls: %@
-[PFUbiquityFilePresenter processPendingURLs]
%s(%d): CoreData: Ubiquity:  Didn't get a location back for url: %@
%s(%d): CoreData: Ubiquity:  Skipping location (wrong root location): %@
%s(%d): CoreData: Ubiquity:  Skipping location (wrong store name): %@
%s(%d): CoreData: Ubiquity:  Skipping location (imported):
%s(%d): CoreData: Ubiquity:  Skipping location (exported):
%s(%d): CoreData: Ubiquity:  URL is a promise file, skipping file URL state check for:%@
%s(%d): CoreData: Ubiquity:  Starting download for promise base dir: %@
%s(%d): CoreData: Ubiquity:  Starting download for: %@
%s(%d): CoreData: Ubiquity:  File isn't live yet: %@
.nosync
%s(%d): CoreData: Ubiquity:  Starting download for file that is not live: %@
%s(%d): CoreData: Ubiquity:  Librarian returned a serious error for starting downloads %@ with userInfo %@ for these urls: %@
-[PFUbiquityFilePresenter processPendingURLs]_block_invoke
%s(%d): CoreData: Ubiquity:  Found transaction log locations: %@
%s(%d): CoreData: Ubiquity:  %@
Status: %@
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while processing pending logs: %@
%s(%d): CoreData: Ubiquity:  %@
Export notification was missing transaction log location: %@
-[PFUbiquityFilePresenter logWasExported:]
-[PFUbiquityFilePresenter logWasImported:]
-[PFUbiquityFilePresenter logImportWasCancelled:]
%s(%d): CoreData: Ubiquity:  %@ logs were scheduled: %@
-[PFUbiquityFilePresenter logsWereScheduled:]_block_invoke
-[PFUbiquityFilePresenter logsWereScheduled:]
-[PFUbiquityFilePresenter setupAssistantDiscoveredPathsFromMetadataQuery:]
%@:%ld: 
live:
not-live:
deleted:
imported:
exported:
downloaded:
downloading:
uploaded:
uploading:
failed:
unknown status
%s(%d): CoreData: Ubiquity:  %@
-[PFUbiquityFilePresenter printStatus:]_block_invoke
T@"PFUbiquityLocation",R,V_ubiquityRootLocation
T@"NSOperationQueue",R
locationToStatus
T@"NSDictionary",R,N,V_locationToStatus
locationToSafeSaveFile
T@"NSDictionary",R,N,V_locationToSafeSaveFile
%s(%d): CoreData: Ubiquity:  Resulting source object: %@
-[PFUbiquityRecordImportConflict resolveMergeConflictForLogContent:previousSnapshot:andAncestorSnapshot:withOldVersion:andNewVersion:error:]
%s(%d): CoreData: Ubiquity:  Resolve conflict called on: %@
-[PFUbiquityRecordImportConflict resolveConflict:]
%s(%d): CoreData: Ubiquity:  %@ aborting conflict resolution, unable to create snapshot for transaction entry: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Elected ancestor vector: %@ and snapshot: %@
New vector: %@
%s(%d): CoreData: Ubiquity:  Got nil snapshot for peerID: %@ and transaction number: %@
new knowledge vector: %@
import conflict: %@
%s(%d): CoreData: Ubiquity:  Sorting snapshots: %@
%s(%d): CoreData: Ubiquity:  Comparing:
%f - %@
%f - %@
-[PFUbiquityRecordImportConflict resolveConflict:]_block_invoke
%s(%d): CoreData: Ubiquity:  Got snapshots to merge: %@
%s(%d): CoreData: Ubiquity:  Error encountered trying to reset the source object to the ancestor state: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Merging snapshot into current snapshot: %@
%s(%d): CoreData: Ubiquity:  Merging current snapshot: %@
With previous snapshot: %@
 and ancestor snapshot: %@
%s(%d): CoreData: Ubiquity:  Error encountered trying to resolve conflict: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Done resolving conflict: %@
%s(%d): CoreData: Ubiquity:  Exception encountered while performing setup for conflict: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unknown Exception encountered while performing setup for conflict: %@
%s(%d): CoreData: Ubiquity:  Skipping inserted object with globalID: %@ because it was later deleted, and the re-inserted by the transaction with entry: %@
+[PFUbiquityRecordImportConflict resolvedTypeForConflictingLogType:andLatestTransactionEntry:skipObject:]
%s(%d): CoreData: Ubiquity:  Skipping inserted object with globalID: %@ because it was later deleted by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Skipping updated object with globalID: %@ because it was later inserted (meaning it had to have also been deleted by some prior transaction) by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Skipping updated object with globalID: %@ because it was later deleted by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Object with globalID: %@ was later inserted by the transaction with entry: %@
%s(%d): CoreData: Ubiquity:  Skipping deleted object with globalID: %@ because it was already deleted, and then deleted by the transaction with entry: %@ and thus no longer exists in the store.
%s(%d): CoreData: Ubiquity:  Deleting existing object with globalID: %@ because previously deleted in a log file.
%s(%d): CoreData: Ubiquity:  Unknown property type: %@
+[PFUbiquityRecordImportConflict createSnapshotFromManagedObject:withSourceObject:]
-[PFUbiquityRecordImportConflict createSnapshotFromLogContent:withTransactionLog:]
Unable to map objectIDs
%s(%d): CoreData: Ubiquity:  Unable to find transaction log for entry: %@
+[PFUbiquityRecordImportConflict createTransactionLogForTransactionEntry:withImportContext:error:]
%s(%d): CoreData: Ubiquity:  Unknown change type for transaction entry: %@
conflictingObjectGlobalIDStr: %@
sourceObject: %@
conflictingLogContent: %@
conflictingLogTransactionType: %d
conflictLogDate: %@
conflictingLogKnowledgeVector: %@
transactionHistory: %@
globalIDStrToLocalIDURIMap: %@
conflictingObjectGlobalIDStr
T@"NSString",&,N,V_conflictingObjectGlobalIDStr
T@"NSManagedObject",&,N,V_sourceObject
conflictingLogContent
T@"NSDictionary",&,N,V_conflictingLogContent
conflictingLogKnowledgeVector
T@"PFUbiquityKnowledgeVector",&,N,V_conflictingLogKnowledgeVector
currentKnowledgeVector
T@"PFUbiquityKnowledgeVector",&,N,V_currentKnowledgeVector
conflictingLogTransactionType
Ti,N,V_conflictingLogTransactionType
conflictLogDate
T@"NSDate",&,N,V_conflictLogDate
conflictingLogTransactionNumber
T@"NSNumber",&,N,V_conflictingLogTransactionNumber
transactionHistory
T@"NSArray",&,N,V_transactionHistory
globalIDIndexToLocalIDURIMap
T@"NSDictionary",&,N,V_globalIDIndexToLocalIDURIMap
relationshipToObjectIDsToCheck
T@"NSDictionary",R,N,V_relationshipsToObjectIDsToCheck
ancestorSnapshot
T@"NSDictionary",&,V_ancestorSnapshot
forConflictAnalysis
TB,N,V_forConflictAnalysis
com.apple.coredata.ubiquity.eat
%@: 
storeNameToEntry: %@
rootLocationToFilePresenter: %@
All stores registered with the same NSPersistentStoreUbiquitousContentNameKey must use the same location on the file system.
%s(%d): CoreData: Ubiquity:  %@
Asked to unregister non-ubiquitized store: %@
-[PFUbiquitySwitchboard unregisterPersistentStore:]
com.apple.coredata.ubiquity.entry.pq
%@: 
localPeerID: %@
ubiquityRootURL: %@
registeredCoordinators: %@
%s(%d): CoreData: Ubiquity:  %@
Scheduled logs for importer: %@
-[PFUbiquitySwitchboardEntry filePresenterWasNotifiedTransactionLogs:]
%s(%d): CoreData: Ubiquity:  Unable to import transaction log: %@
%s(%d): CoreData: Ubiquity:  %@
Scheduling encountered an error: %@
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while processing transaction logs: %@ with userInfo: %@
%s(%d): CoreData: Ubiquity:  Error purging transaction history cache after account change: %@
-[PFUbiquitySwitchboardEntry containerIdentifierChanged:]
%s(%d): CoreData: Ubiquity:  Error loading new temporary coordinator after account change with options { %@ } and URL %@ and error = %@
keyboardservicesd
%s(%d): CoreData: Ubiquity:  Error loading new store metadata after account change: %@
-[PFUbiquitySwitchboardEntry containerIdentifierChanged:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Registered store: %@ with entry: %@
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while trying to recover from account change: %@ (%@)
%s(%d): CoreData: Ubiquity:  %@
Exception encountered while trying to recover from account change: %@
%s(%d): CoreData: Ubiquity:  Beginning to watch for changes from: %@
-[PFUbiquitySwitchboardEntry finishSetupForStore:withSetupAssistant:synchronously:error:finishBlock:]
activeStoreCount
TQ,V_activeStoreCount
T@"PFUbiquityLocation",R,V_localRootLocation
filePresenter
T@"PFUbiquityFilePresenter",R,V_fp
localFilePresenter
T@"PFUbiquityFilePresenter",R,V_localFP
monitor
T@"PFUbiquityContainerMonitor",R,V_monitor
finishingSetupAssistant
T@"PFUbiquitySetupAssistant",R,V_finishingSetupAssistant
T@"PFUbiquitySwitchboardEntryMetadata",&,N,V_metadata
-[PFUbiquitySwitchboardEntryMetadata addPersistentStore:]
%s(%d): CoreData: Ubiquity:  %@:%@
Using local storage: %d for new NSFileManager current token %@
-[PFUbiquitySwitchboardEntryMetadata setUseLocalStorage:]
cacheWrapper
T@"PFUbiquitySwitchboardCacheWrapper",&,N,V_cacheWrapper
importer
T@"_PFUbiquityRecordsImporter",R,N,V_importer
exporter
T@"_PFUbiquityRecordsExporter",R,N,V_exporter
stores
T@"NSSet",R,N,V_stores
activeModelVersionHash
T@"NSString",R,N,V_activeModelVersionHash
T@"NSSQLCore",R,N,V_privateStore
useLocalAccount
TB,N,V_useLocaAccount
baselineHeuristics
T@"PFUbiquityBaselineHeuristics",R,N,V_baselineHeuristics
T@"NSSQLManyToMany",R,V_relationship
%s(%d): CoreData: Ubiquity:  Error checking the uploaded status for: %@
Error: %@
-[PFUbiquityFileCoordinator coordinateReadingItemAtLocation:options:retryOnError:error:byAccessor:]
%s(%d): CoreData: Ubiquity:  Unlinking orphaned file: %@
%s(%d): CoreData: Ubiquity:  %@
Replacing error with file upload error: %@
%s(%d): CoreData: Ubiquity:  %@
Coordinated read returned an error: %@
userInfo: %@
 Retrying (%u).
LibrarianErrorDomain
%s(%d): CoreData: Ubiquity:  %@
Encountered unknown librarian error: %@
userInfo: %@
-[PFUbiquityFileCoordinator shouldRetryForError:ignoreFile:]
UBErrorDomain
%s(%d): CoreData: Ubiquity:  %@
Encountered unknown ubiquity error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Encountered unrecoverable error: %@
userInfo: %@
com.apple.coredata.ubiquity.baseline.roll
com.apple.coredata.ubiquity.baseline.peerUpload
baseline.zip
baseline.meta
current.nosync
staging.nosync
storeName: %@
modelVersionHash: %@
baselineArchiveLocation: %@
%s(%d): CoreData: Ubiquity:  %@ Successfully removed contents of staging area.
-[PFUbiquityBaseline clearOutStagingLocationWithError:]
%s(%d): CoreData: Ubiquity:  %@
Error while preparing for baseline roll: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully created staging directory: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to create staging directory path, failing now: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully copied store to staging directory: %@
-[PFUbiquityBaseline prepareForBaselineRollOfPersistentStore:andLocalPeerID:error:]
%s(%d): CoreData: Ubiquity:  Unable to open staging store as URL is nil
%s(%d): CoreData: Ubiquity:  %@
Error removing the orphaned -shm file: %@
%s(%d): CoreData: Ubiquity:  %@
Error connecting to the staged baseline store file: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to copy store file to staging directory: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  No store file found at url: %@
Baseline: %@
Error: %@
userInfo: %@
-[PFUbiquityBaseline gatherContentsFromMigratedBaseline:withStoreFileURL:error:]
%s(%d): CoreData: Ubiquity:  Got more than one path component for subpath: %@ of baseline staging directory: %@
-[PFUbiquityBaseline gatherContentsAndConstructArchiveWithError:]
%s(%d): CoreData: Ubiquity:  Got nil data for staged store file at path: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to crate compressed archive of baseline contents: %@
userInfo: %@
-[PFUbiquityBaseline constructBaselineArchive:]
Coordinated read of baseline archive file succeeded, but the file could not be read: %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Coordinated read of baseline archive file: %@ did not succed: %@
userInfo: %@
-[PFUbiquityBaseline loadFileFromLocation:error:]
%s(%d): CoreData: Ubiquity:  Encountered baseline without any metadata in it's archive: %@
offendingBaseline
gcmodel
%s(%d): CoreData: Ubiquity:  Encountered baseline without any model data in it's archive: %@
storeFilenameToData
storeFilename
%s(%d): CoreData: Ubiquity:  Encountered baseline without any filenames data in it's archive: %@
%s(%d): CoreData: Ubiquity:  Encountered baseline without any filename data in it's archive: %@
%s(%d): CoreData: Ubiquity:  Encountered baseline without any file data in it's archive for file named: %@
Baseline: %@
-[PFUbiquityBaseline unpackStoreFilesToStagingLocation:]
offendingFilename
%s(%d): CoreData: Ubiquity:  Failed to clear out staging directory after store replacement: %@
userInfo: %@
-[PFUbiquityBaseline replaceLocalPersistentStoreAtURL:ofType:withOptions:usingPersistentStoreCoordinator:error:]
%s(%d): CoreData: Ubiquity:  %@
Checking to see if it can replace store with knowledge vector: %@
-[PFUbiquityBaseline canReplaceStoreAtKnowledgeVector:]
%s(%d): CoreData: Ubiquity:  %@
Local store is current with the baseline
%s(%d): CoreData: Ubiquity:  %@
Local store has a zero vector
%s(%d): CoreData: Ubiquity:  %@
Local store is an ancestor of the baseline
%s(%d): CoreData: Ubiquity:  %@
Baseline is an ancestor of the local store
%s(%d): CoreData: Ubiquity:  %@
Beginning knowledge vector inspection
%s(%d): CoreData: Ubiquity:  %@
Finished check: %d
%s(%d): CoreData: Ubiquity:  %@
Need logs for peer %@ between %ld and %ld to adopt
-[PFUbiquityBaseline haveTransactionLogsForPeer:between:and:]
%s(%d): CoreData: Ubiquity:  %@
Unable to load log: %@ while checking for baseline adoption: %@
%s(%d): CoreData: Ubiquity:  We are forked from baseline...force it
Unable to find missing transaction files
%s(%d): CoreData: Ubiquity:  we found some logs but the peer is still behind...should we force fork??
%s(%d): CoreData: Ubiquity:  %@
Didn't find all the required logs for baseline adoption, giving up
offendingPeers
%s(%d): CoreData: Ubiquity:  Receipt file has no write date: %@
+[PFUbiquityBaseline isPeerReceiptTooOld:]
%s(%d): CoreData: Ubiquity:  Error encountered making this baseline: %@ the current baseline: %@
userInfo: %@
-[PFUbiquityBaseline importBaselineForStoreAtURL:ofType:options:withLocalPeerID:stack:andPersistentStoreCoordinator:error:]
%s(%d): CoreData: Ubiquity:  Error initializing the baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Didn't get persistent store from the baseline coordinator: %@
-[PFUbiquityBaseline updateCurrentStoreIdentifier:error:]
%s(%d): CoreData: Ubiquity:  %@
Making current: %@
-[PFUbiquityBaseline makeCurrentBaselineWithError:]
%s(%d): CoreData: Ubiquity:  Error attempting to create the stores directory for the current baseline: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error attempting to create the directory for the current baseline: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error cleaning out current baseline directory: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error creating directory for baseline file: %@
Error: %@
userInfo: %@
-[PFUbiquityBaseline writeFileToLocation:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error writing new baseline file to URL: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error attempting to write new baseline archive to url: %@, error: %@
userInfo: %@
-[PFUbiquityBaseline writeFileToLocation:error:]
%s(%d): CoreData: Ubiquity:  Removing identifiers from: %@
+[PFUbiquityBaseline removePeerSpecificIdentifiersFromStore:withLocalPeerID:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Unable to open store file: %@
-[PFUbiquityBaseline _createPersistentStoreCoordinatorForCurrentBaseline:error:]
%s(%d): CoreData: Ubiquity:  %@
Unable to open store file: %@ as URL is nil
%s(%d): CoreData: Ubiquity:  Got nil model for baseline: %@
Error: %@
userInfo: %@
-[PFUbiquityBaseline createManagedObjectModel]
%s(%d): CoreData: Ubiquity:  Couldn't load optimized model at url: %@
+[PFUbiquityBaseline createBaselineOptimizedModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Cannot find optimized model at URL: %@.
It appears there is no current baseline.
%s(%d): CoreData: Ubiquity:  Couldn't load model at url: %@
+[PFUbiquityBaseline createBaselineGCModelForStoreName:peerID:modelVersionHash:andUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Cannot find model at URL: %@.
It appears there is no current baseline.
%s(%d): CoreData: Ubiquity:  Didn't get baseline metadata back from metadata url: %@
Error: %@
userInfo: %@
+[PFUbiquityBaseline metadataFromCurrentBaselineForStoreWithName:peerID:modelVersionHash:andUbiquityRootLocation:withError:]
%s(%d): CoreData: Ubiquity:  Error getting data for optimized encoding: %@
userInfo: %@
Model: %@
+[PFUbiquityBaseline createArchiveWithModel:metadata:storeFilenameToData:storeFilename:error:]
%s(%d): CoreData: Ubiquity:  Error getting data for regular encoding: %@
userInfo: %@
Model: %@
/.baseline
%s(%d): CoreData: Ubiquity:  %@ does not appear to be a baseline path
+[PFUbiquityBaseline createStringOfContentsOfBaselineFile:]
1234UUID
storeFilename: %@
storeName: %@
modelVersionHash: %@
%s(%d): CoreData: Ubiquity:  Couldn't read contents of baseline: %@
%s(%d): CoreData: Ubiquity:  Couldn't get metadata from current location: %@
baselineArchiveLocation
baselineStagingLocation
T@"PFUbiquityLocation",R,V_baselineStagingLocation
baselinePeerArchiveLocation
T@"PFUbiquityBaselineMetadata",R,V_metadata
T@"NSDictionary",R,V_storeFilenameToData
T@"NSString",R,V_storeFilename
T@"NSString",R,V_modelVersionHash
baselineArchive
T@"_PFZipFileArchive",R,V_baselineArchive
T@"NSPersistentStore",R,V_store
storeName: %@
authorPeerID: %@
modelVersionHash: %@
knowledgeVector: %@
peerRanges: %@
%s(%d): CoreData: Ubiquity:  Got a bad gap for range: %@
Previous range: %@
Store: %@
-[PFUbiquityBaselineMetadata gatherMetadataWithStore:andError:]
exception %@ with userInfo %@ during -gatherMetadataWithStore:andError:
authorPeerID
peerStates
%s(%d): CoreData: Ubiquity:  Not sure what to do with baseline metadata knowledge vector object: %@
-[PFUbiquityBaselineMetadata initWithCoder:]
previousKnowledgeVector
peerRanges
T@"NSString",R,V_authorPeerID
T@"PFUbiquityKnowledgeVector",R,N,V_pKV
knowledgeVector
T@"PFUbiquityKnowledgeVector",R,V_kv
T@"NSDictionary",R,V_peerRanges
nostore
<NSQueryGenerationToken: %p>
currentQueryGenerationToken
T@"NSQueryGenerationToken",R
unsupported
<NSQueryGenerationToken : {
, %p
<NSQueryGenerationToken : %@>
<NSQueryGenerationToken : %p>
_NSXPCQueryGenerationTokenToken
_NSXPCQueryGenerationTokenStoreIdentifier
XPC: Possible API misuse: Unable to find store for identifier :%@, replacing generation with current
_NSXPCQueryGenerationToken can't be decoded (missing token or identifier); replacing with current. (%@, %@)
_NSXPCQueryGenerationToken can't be decoded (missing psc); replacing with current.
_NSXPCQueryGenerationToken can't be decoded (unknown reason); replacing with current.
exception fetching row for object with ID: %@ with userInfo of %@
failed to resolve fault to exactly one object for %@
fault fulfilled from database for : %@ with row values: %@
fault fulfilled from database for : %@
orderKey
exception during newFetchedPKsForSourceID: %@ with userInfo of %@
to-many relationship fault "%@" for objectID %@ fulfilled from database.  Got %d rows with values: %@
to-many relationship fault "%@" for objectID %@ fulfilled from database.  Got %d rows
Unable to generate updateStatement for affected object IDs (cause unknown)
Short-circuiting batch update: impossible condition in where clause (2)
error: Unable to fetch affected object IDs : %@
Unable to fetch affected affected object IDs
Underlying issue
, %qi
SELECT %@,%@ FROM %@ WHERE %@ IN (%@) ORDER BY %@
Optimistic locking failure for %@.  Row was deleted.  Original row = %@ New Row = <deleted>
Optimistic locking failure for %@.  Row was deleted.
Optimistic locking failure for %@.  Row was updated.  Original row = %@ New Row = %@
Optimistic locking failure for %@.  Row was updated.
Optimistic locking failure for %@.  During write changes, deletion failed.  Row was updated.  Original row = %@ New Row = %@
Optimistic locking failure for %@.  During write changes, deletion failed.  Row was updated.
SaveChanges: NSSQLCore: %p Transactions cannot be nested
requestContext
Missing transaction scope for commit changes.
addedOrUpdated
logically false count request %@ short circuits.
count request %@ returned %d
total count request execution time: 
[31m%.4f
[0ms for count of %d.
total count request execution time: %.4fs for count of %d.
%@ %@ JOIN %@ %@ %@%@
SELECT %@%@, %@%@ FROM 
SELECT %@%@ FROM 
SELECT 0, %@%@ FROM 
 %qi
 %@, %@
, %@.%@
%@ IN ( 
%qu, 
%qu ) 
AND 
q24@?0@"NSManagedObjectID"8@"NSManagedObjectID"16
Prefetching from join table for many-to-many relationship "%@" from database.  Got %lu rows with values: %@
Prefetching from join table for many-to-many relationship "%@" from database.  Got %lu rows
Prefeching threw : %@
Prefetching with request %@.  Got %lu rows with values: %@
Prefetching with key '%@'.  Got %lu rows.
logically false fetch request %@ short circuits.
sql connection fetch statement: '%@'
Fetch raised an exception : %@
unable to generate primary keys
localPeerID: %@
storeNameToStoreExportContext: %@
ubiquityRootLocation: %@
localPeerID: %@
storeName: %@
transactionEntries: %@
transactionEntries
T@"NSSet",R,N,V_transactionEntries
T@"NSSQLCore",&,N,V_store
p%lu
%@ (%@)
T@"NSString",R,N,V_entityName
primaryKey
T@"NSString",R,N,V_primaryKey
owningPeerID
T@"NSString",R,N,V_owningPeerID
TQ,R,N,V_hash
managedObjectID
T@"NSManagedObjectID",&,N,V_managedObjectID
primaryKeyInteger
TQ,R,N,V_primaryKeyInteger
transactionDate: %@
modelVersionHash: %@
exportingPeerID: %@
storeNameToSaveSnapshots: %@
T@"NSDate",&,N,V_transactionDate
T@"NSString",R,N,V_exportingPeerID
storeNames
Must supply a non-zero number of objectIDs to request during initialization
mismatched objectIDs in batch delete initializer
objectIDs
Must supply a fetch request during initialization
Fetch must have an entity
<NSBatchDeleteRequest : resultType : %ld, fetch :%@ >
TQ,V_resultType
T@"NSFetchRequest",R,C
Mismatched result types during aggregation of batch delete results
Results
com.apple.coredata.ubiquity.snapshot
entityNames: %@
peerIDs: %@
globalObjectIDs: %@
primaryKeys: %@
managedObjectIDToGlobalObjectID: %@
entityNameToIndex: %@
peerIDToIndex: %@
primaryKeyToIndex: %@
insertedObjects: %@
updatedObjects: %@
deletedObjects: %@
peerStates: %@
transactionNumber: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to convert compressed object ID string: %@ to index number.
-[PFUbiquityStoreSaveSnapshot globalObjectIDFromCompressedObjectID:]
%s(%d): CoreData: Ubiquity:  %@
Reserved transaction knowledge vector: %@ (%@)
-[PFUbiquityStoreSaveSnapshot reserveTransactionNumberWithStoreExportContext:]
%s(%d): CoreData: Ubiquity:  %@
Generating Peer States: %@
-[PFUbiquityStoreSaveSnapshot generatePeerStates]
%s(%d): CoreData: Ubiquity:  Hrm found something in empty array did you? %@
i: %lu
NSNotFound: %lu
-[PFUbiquityStoreSaveSnapshot replaceGlobalObjectID:withGlobalObjectID:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@ replacing global object id:
old: %@
new: %@
%s(%d): CoreData: Ubiquity:  %@ wasn't in this snapshot: %@
Failed to copy external reference to ubiquity container
Underlying error
%s(%d): CoreData: Ubiquity:  Got final value for relationship: %@
Object: %@
-[PFUbiquityStoreSaveSnapshot createUbiquityDictionary:withStoreExportContext:error:]
entityNames
T@"NSArray",R,N,V_entityNames
peerIDs
T@"NSArray",R,N,V_peerIDs
globalObjectIDs
T@"NSArray",R,N,V_globalObjectIDs
primaryKeys
T@"NSArray",R,N,V_primaryKeys
T@"NSDictionary",R,N,V_insertedObjects
T@"NSDictionary",R,N,V_updatedObjects
T@"NSDictionary",R,N,V_deletedObjects
T@"NSDictionary",R,N,V_peerStates
T@"NSNumber",&,N,V_transactionNumber
T@"NSString",&,N,V_exportingPeerID
T@"NSString",&,N,V_localPeerID
storeKV
T@"PFUbiquityKnowledgeVector",&,N,V_storeKV
globalObjectIDToPermanentManagedObjectID
T@"NSDictionary",R,N,V_globalObjectIDToPermanentManagedObjectID
managedObjectIDToGlobalObjectID
T@"NSDictionary",R,N,V_managedObjectIDToGlobalObjectID
entityNameToIndex
T@"NSDictionary",R,N,V_entityNameToIndex
peerIDToIndex
T@"NSDictionary",R,N,V_peerIDToIndex
primaryKeyToIndex
T@"NSDictionary",R,N,V_primaryKeyToIndex
globalObjectIDToIndex
T@"NSDictionary",R,N,V_globalObjectIDToIndex
globalObjectIDCache
T@"PFUbiquityGlobalObjectIDCache",&,N,V_gidCache
tempLogs.nosync
.stage.nosync
com.apple.coredata.log
Core Data: Ubiquity: Unable to process transaction log location: %@, doesn't appear to actually represent a transaction log location.
transactionLogLocation: %@
transactionNumber: %@
%s(%d): CoreData: Ubiquity:  Error encountered while trying to load the comparison metadata for transaction log: %@
Error: %@
userInfo: %@
-[PFUbiquityTransactionLog loadContents:]
%s(%d): CoreData: Ubiquity:  %@
Missing transaction date from contents: %@
-[PFUbiquityTransactionLog loadComparisonMetadataWithError:]
compressedGlobalIDs
%s(%d): CoreData: Ubiquity:  Got nil zip archive: %@
Error: %@
-[PFUbiquityTransactionLog loadPlistAtLocation:withError:]
%s(%d): CoreData: Ubiquity:  %@
Unable to read data from extended attributes: %@
missingFile
Error encountered trying to read data inside coordinated accessor: %@
userInfo: %@, local error: %@
userInfo: %@
Error reading the log file at location: %@
userInfo: %@
contents
Error during property list parsing during import or opening of log file at location: %@, error: %@
Error getting data during property list parsing during import or opening of log file at location: %@
externalDataReferencesInfo
%s(%d): CoreData: Ubiquity:  Encountered an error attempting to remove external data reference (%@): %@
userInfo: %@
-[PFUbiquityTransactionLog cleanupExternalDataReferences]_block_invoke
%s(%d): CoreData: Ubiquity:  Error deleting log file: %@
Error: %@
userInfo: %@
-[PFUbiquityTransactionLog deleteLogFileWithError:]
CoreData: Ubiquity: Error writing export log to file: %@
error: %@
userInfo: %@
-[PFUbiquityTransactionLog moveFileToPermanentLocationWithError:]
CoreData: Ubiquity: Error creating data for export: %@
userInfo: %@
 from transaction log: %@
-[PFUbiquityTransactionLog writeToDiskWithError:andUpdateFilenameInTransactionEntries:]
CoreData: Ubiquity: Error writing export log to file (%d:%d): %@
error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Error deleting existing log file: %@
-[PFUbiquityTransactionLog rewriteToDiskWithError:]
%s(%d): CoreData: Ubiquity:  %@
Error deleting existing log file (t): %@
%s(%d): CoreData: Ubiquity:  %@
Error deleting existing log file (s): %@
%s(%d): CoreData: Ubiquity:  Log file truncation failed to get a stack: %@
userInfo: %@
+[PFUbiquityTransactionLog truncateLogFilesForPeerID:storeName:modelVersionHash:beforeKnowledgeVector:withLocalPeerID:andUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Successfully deleted transaction entries before %@ for peer %@
%s(%d): CoreData: Ubiquity:  Error deleting transaction entries before %@ for peer %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error trying to inspect log files after baseline roll at location: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error encountered attempting to delete an old log file after the baseline rolled: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Error moving transaction log from temporary location: %@ to permanent location:
+[PFUbiquityTransactionLog pruneTemporaryLogDirectoryForPeerRootLocation:error:]
%@.%d.%@
cdVersion
kvStr
%s(%d): CoreData: Ubiquity:  Error encountered while updating the modification time for file (%d): %@
+[PFUbiquityTransactionLog updateModificationTimesForLocation:]
useTemporaryLogLocation
TB,N,V_useTemporaryLogLocation
inTemporaryLocation
TB,R,N,V_inTemporaryLocation
inStagingLocation
TB,R,N,V_inStagingLocation
inPermanentLocation
TB,R,N,V_inPermanentLocation
fileProtectionOption
T@"NSString",R,N,V_fileProtectionOption
T@"NSNumber",R,N
transactionLogFilename
transactionLogType
Ti,R,N,V_transactionLogType
transactionLogLocation
T@"PFUbiquityLocation",R,N,V_transactionLogLocation
temporaryTransactionLogLocation
T@"PFUbiquityLocation",R,N,V_temporaryTransactionLogLocation
stagingTransactionLogLocation
T@"PFUbiquityLocation",R,N,V_stagingTransactionLogLocation
saveSnapshot
T@"PFUbiquitySaveSnapshot",R,N,V_saveSnapshot
currentLocation
T@"PFUbiquityKnowledgeVector",R,N,V_knowledgeVector
loadUsingRetry
TB,N,V_loadUsingRetry
loadedComparisonMetadata
TB,R,N,V_loadedComparisonMetadata
loadedImportMetadata
TB,R,N,V_loadedImportMetadata
loadedInsertedObjectData
TB,R,N,V_loadedInsertedObjectData
loadedUpdatedObjectData
TB,R,N,V_loadedUpdatedObjectData
loadedDeletedObjectData
TB,R,N,V_loadedDeletedObjectData
%s(%d): CoreData: Ubiquity:  %@ didn't get entity description back for entity named: %@
MOC: %@
PSC: %@
-[PFUbiquityImportContext prefetchManagedObjectsInContext:error:]
stack
T@"_PFUbiquityStack",&,N,V_stack
T@"PFUbiquityStoreMetadata",&,N,V_storeMetadata
actingPeer
T@"PFUbiquityPeer",R,N,V_actingPeer
T@"PFUbiquityKnowledgeVector",&,N,V_kv
storeSaveSnapshot
T@"PFUbiquityStoreSaveSnapshot",&,N,V_storeSaveSnapshot
globalIDToLocalIDURICache
T@"NSDictionary",&,N,V_globalIDToLocalIDURICache
globalIDToFetchedObject
T@"NSMutableDictionary",R,N,V_globalIDToFetchedObject
heuristics
T@"PFUbiquityBaselineHeuristics",&,N,V_heuristics
.externalData
container
ubRoot
Library/Mobile Documents
CoreDataUbiquitySupport
/private
%s(%d): CoreData: Ubiquity:  Path: %@ is a ubiquity root url.
Matches: %@
+[PFUbiquityLocation createUbiquityLocationForPath:withUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Path: %@ does not appear to be a descendant of the root url: %@
%s(%d): CoreData: Ubiquity:  It appears the store file is nested inside the container log directory. This is a really bad idea: %@
%s(%d): CoreData: Ubiquity:  Truncated path: %@ is a ubiquity root url.
Matches: %@
.icloud
%s(%d): CoreData: Ubiquity:  Changing path component to remove promise suffix previous: %@
%s(%d): CoreData: Ubiquity:  Changing path component to remove promise suffix new: %@
EXTERNAL_DATA
.0.cdt
.0.cdt.nosync
.cdt
.cdt.nosync
%s(%d): CoreData: Ubiquity:  Unable to continue parse components of URL: %@
Confused by: %@
%s(%d): CoreData: Ubiquity:  Ignoring private file: %@
%d is not a valid baseline location type.
%d is not a valid current baseline location type.
%@.0.cdt.nosync
%@.0.cdt
%@/%@
Core Data's ubiquity integration requires that the value for NSPersistentStoreUbiquitousContentURLKey point inside ~/Library/Mobile Documents. Given value: %@
offendingPath
%s(%d): CoreData: Ubiquity:  Got nil location for subpath: %@ of location: %@
+[PFUbiquityLocation createArrayOfSubLocationsAtLocation:error:]
ubiquityRootLocationPath
T@"NSString",R,N,V_ubiquityRootLocationPath
isRootUbiquitous
TB,R,N,V_isRootUbiquitous
ubiquityLocationType
Ti,R,N,V_ubiquityLocationType
filename
T@"NSString",R,N,V_filename
usesStagingLogDirectory
usesTemporaryLogDirectory
usesCurrentBaselineDirectory
usesBaselineStagingDirectory
usesBaselineDirectory
usesNosyncDirectory
otherPathComponents
T@"NSArray",R,N,V_otherPathComponents
isTransactionLogLocation
TB,R,N,GisTransactionLogLocation
isDirectory
TB,R,N,V_isDirectory
Unsupported predicate, RHS of boundBy: must contain 2 values
Unsupported predicate, topLeft parameter of boundBy: RHS must be a constant or keypath
Unsupported predicate, bottomRight parameter of boundBy: RHS must be a constant or keypath
Unsupported predicate, RHS of boundBy: must be an aggregate or constant
Unsupported predicate, constant topLeft parameter of boundBy: RHS must respond to coordinate
Unsupported predicate, constant lowerRight parameter of boundBy: RHS must respond to coordinate
SELECT %@.Z_PK FROM %@ %@ WHERE ? <= %@.%@_MAX AND %@.%@_MIN <= ? AND ? <= %@.%@_MAX AND %@.%@_MIN <= ?
entitiesAndCounts
T@"NSDictionary",R,N,V_entitiesAndCounts
T@"NSSQLModel",R,N,V_model
%s(%d): CoreData: Ubiquity:  Successfully initialized baseline: %@
-[PFUbiquityBaselineRollOperation haveConsistentStateForBaselineRoll]
%s(%d): CoreData: Ubiquity:  Error attempting to initialize baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Didn't download latest version: %@
%s(%d): CoreData: Ubiquity:  Got nil metadata for current baseline in operation: %@
%s(%d): CoreData: Ubiquity:  %@
Got an unknown error back from canRollBaseline: %@
-[PFUbiquityBaselineRollOperation rollBaselineWithError:]
%s(%d): CoreData: Ubiquity:  %@ successfully rolled baseline: %@
%s(%d): CoreData: Ubiquity:  %@ successfully rolled baseline but encountered an error trying to make it the current baseline: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Removed unused external data references
%s(%d): CoreData: Ubiquity:  %@
Error removing unused external data references: %@
%s(%d): CoreData: Ubiquity:  %@ encountered an error trying to write the baseline archive to disk: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@ Error encountered trying to roll baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unable to delete transaction log for peer: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to remove logs from peer: %@
%s(%d): CoreData: Ubiquity:  Exception encountered while trying to roll the baseline for operation: %@
Exception: %@
-[PFUbiquityBaselineRollOperation main]
T@"NSObject<PFUbiquityBaselineRollOperationDelegate>"
NSZipFileArchiveHeaderOffset
NSZipFileArchiveCompressionType
NSZipFileArchiveCRC
NSZipFileArchiveCompressedLength
NSZipFileArchiveUncompressedLength
CoreData: Ubiquity: Error writing file '%@', rename failed with errno %d
offsetOfConfusingBytes
readError
statError
closeError
CRC Mismatch: %@
1.2.8
lseekError
openError
entryNames
%@ - %@
versionMadeBy
TS,N,V_versionMadeBy
versionNeededToExtract
TS,N,V_versionNeededToExtract
generalPurposeBit
TS,N,V_generalPurposeBit
compressionMethod
TS,N,V_compressionMethod
lastModTime
TS,N,V_lastModTime
lastModDate
TS,N,V_lastModDate
crc32
TI,N,V_crc32
compressedSize
TI,N,V_compressedSize
uncompressedSize
TI,N,V_uncompressedSize
filenameLength
TS,R,N,V_filenameLength
extraFieldLength
TS,R,N,V_extraFieldLength
fileCommentLength
TS,R,N,V_fileCommentLength
fileStartDiskNumber
TS,N,V_fileStartDiskNumber
internalFileAttrs
TS,N,V_internalFileAttrs
externalFileAttrs
TI,N,V_externalFileAttrs
localFileHeaderRelativeOffset
TI,N,V_localFileHeaderRelativeOffset
T@"NSString",&,N,V_filename
extraFieldData
T@"NSData",&,N,V_extraFieldData
fileComment
T@"NSString",&,N,V_fileComment
%@ - %d:%d:%d:%d:%d:%d
numberOfDisk
TS,N,V_numberOfDisk
diskWhereCentralDirectoryStarts
TS,N,V_diskWhereCentralDirectoryStarts
numberOfCentralDirectoryRecordsOnThisDisk
TS,N,V_numberOfCentralDirectoryRecordsOnThisDisk
totalNumberOfCentralDirectoryRecords
TS,N,V_totalNumberOfCentralDirectoryRecords
byteSizeOfCentralDirectory
TI,N,V_byteSizeOfCentralDirectory
centralDirectoryOffset
TI,N,V_centralDirectoryOffset
commentLength
TS,R,N,V_commentLength
comment
T@"NSString",&,N,V_comment
totalHeaderLength
TI,R,N
peerKey
remoteStates
T@"NSSet",&,D,N
primaryKeyRanges
localPeerStates
transactionTypeNum
localIDStr
T@"NSDate",&,D,N
%@: %@
exportingPeerID: %@, transactionNumber: %@, transactionDate: %@
Log Snapshot: %@
Diff: %@
logSnapshot
T@"NSDictionary",R,N,V_logSnapshot
diffFromPrevious
T@"NSDictionary",R,N,V_diffFromPrevious
T@"PFUbiquityKnowledgeVector",R,N,V_kv
T@"NSNumber",R,N,V_transactionNumber
T@"NSDate",R,N,V_transactionDate
%s(%d): CoreData: Ubiquity:  Generated diff for snapshot: %@
 Previous snapshot: %@
-[PFUbiquityPeerSnapshotCollection calculateSnapshotDiffsWithError:]
insertedObjectIDs: %@
deletedObjectIDs: %@
relationshipKey
T@"NSString",R,N,V_relationshipKey
%s(%d): CoreData: Ubiquity:  %@
Error removing version: %@
Error: %@
userInfo: %@
-[PFUbiquityBaselineRecoveryOperation resolveConflictsForBaseline:withError:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
 Got nil store metadata for store named: %@
-[PFUbiquityBaselineRecoveryOperation replaceLocalStoreWithBaseline:error:]
%s(%d): CoreData: Ubiquity:  %@
Error trying to load the baseline archive: %@
userInfo: %@
-[PFUbiquityBaselineRecoveryOperation main]
%s(%d): CoreData: Ubiquity:  Found conflicts for baseline: %@
%s(%d): CoreData: Ubiquity:  Successfully resolved conflicts for baseline: %@
%s(%d): CoreData: Ubiquity:  Unable to resolve conflicts for baseline: %@, the baseline will not be adopted.
%s(%d): CoreData: Ubiquity:  %@
Current baseline directory exists however an error was encountered while trying to read the current metadata: %@
userInfo: %@
Will attempt to adopt the existing baseline.
%s(%d): CoreData: Ubiquity:  %@
Adopted older baseline: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to adopt older baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Encountered an error trying to replace the local store file with a baseline: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unable to safe save peer baseline file: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Error trying to read peer baseline file: %@
%s(%d): CoreData: Ubiquity:  %@
Got nil for current baseline metadata, %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Will attempt to adopt existing baseline: %@.
%s(%d): CoreData: Ubiquity:  Exception encountered while trying to clean up baseline: %@
Exception: %@
userInfo: %@
T@"NSObject<PFUbiquityBaselineRecoveryOperationDelegate>"
storeOptionsBinaryPlistData
T@"NSData",&,D,N
modelVersionHashString
storeURLString
ubiquityName
storeType
ubiquityRootURLString
ubiquityRelativePath
~~[[NO CHANGE]]~~
NSPredicates and NSExpressions cannot be encoded by non-keyed archivers
NSConstantValue_XPCStoreObjectIDs
NSConstantValue
NSPredicates and NSExpressions cannot be decoded by non-keyed archivers
root
NSRemotePersistentStoreDidChange_%@
Seriously what? Got a non-singleton generational token, but can't find my part
Someone tried to log something but failed because they didn't tell me what to log.
CoreData: XPC: %@
_NSXPCStoreObjectIDArrayConstantValueExpression
exception name
exception reason
Error: Exception raised: %@
Error: Callstack: %@
Error: UserInfo: %@
Array with content where there should be a set.
CoreData: XPC: Suspect response from server (bad size)
CoreData: XPC: Suspect response from server (no result)
CoreData: XPC: Suspect response from server (missing size)
CoreData: XPC: Suspect response from server (not enough room for fetch results header)
CoreData: XPC: Suspect response from server (not enough room for buffers and sizes)
CoreData: XPC: Suspect response from server (not enough room for first row)
Decoding failed: No oids.
Decoding failed: No rows.
CoreData: XPC: Suspect response from server (not enough room for row %d)
CoreData: XPC: Suspect response from server (remaining space for %d smaller than estimated size)
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (1))
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (2))
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (3))
CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (4))
peerEntityName
start
%s(%d): CoreData: Ubiquity:  Unable to create knowledge vector from string: %@
-[PFUbiquityKnowledgeVector initWithKnowledgeVectorString:]
%s(%d): CoreData: Ubiquity:  Got empty knowledge vector from string: %@
kvDict
receipt.0.cdt
kv: %@
%s(%d): CoreData: Ubiquity:  Successfully loaded receipt: %@
-[PFUbiquityPeerReceipt loadFileFromLocation:error:]
%s(%d): CoreData: Ubiquity:  Unable to load knowledge vector from location: %@. Error (%d): %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Unable to load receipt file: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@: Successfully wrote to file.
-[PFUbiquityPeerReceipt writeFileToLocation:error:]
%s(%d): CoreData: Ubiquity:  %@: Unable to write receipt file. Error: %@
userInfo: %@
receiptFileLocation
writeDate
T@"NSDate",&,N,V_writeDate
localPeerID: %@
storeName: %@
ubiquityRootLocation: %@
T@"NSPersistentStore",R,N,V_store
T@"NSObject"
%s(%d): CoreData: Ubiquity:  Beginning metadata recovery for store: %@
-[PFUbiquityStoreMetadataMedic recoverMetadataWithError:]
%s(%d): CoreData: Ubiquity:  Metadata recovery for store: %@
Creating new store metadata.
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Created new store metadata: %@
Moving on to recreating the peer ranges.
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Finished creating new peer ranges, moving to knowledge vector, peer states, and transaction entries.
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Fetched knowledge vector: %@
%s(%d): CoreData: Ubiquity:  %@
Metadata recovery for store: %@
Finished.
%s(%d): CoreData: Ubiquity:  %@
No global ID for managed object ID: %@
-[PFUbiquityStoreMetadataMedic addTransactionHistoryEntriesForObjectIDs:withImportContext:error:]
%s(%d): CoreData: Ubiquity:  addTransactionHistoryEntriesForObjectIDs: lost its stack
%s(%d): CoreData: Ubiquity:  %@ skipping non-transaction log location returned from sub locations: %@
-[PFUbiquityStoreMetadataMedic recoverTransactionLogMetadataWithImportContext:error:]
%s(%d): CoreData: Ubiquity:  Successfully rebuilt metadata for log: %@
%s(%d): CoreData: Ubiquity:  %@
Had trouble loading the deleted objects for a the transaction log: %@
Error: %@
userInfo: %@
Failing now.
-[PFUbiquityStoreMetadataMedic cacheMetadataForTransactionLog:withImportContext:error:]
%s(%d): CoreData: Ubiquity:  %@
Had trouble loading the updated objects for a the transaction log: %@
Error: %@
userInfo: %@
Failing now.
%s(%d): CoreData: Ubiquity:  %@
Had trouble loading the inserted objects for a the transaction log: %@
Error: %@
userInfo: %@
Failing now.
T@"NSSQLiteConnection",R,N
localStoreKV
baseline
%s(%d): CoreData: Ubiquity:  Responding to baseline: %@
-[PFUbiquityBaselineRollResponseOperation main]
%s(%d): CoreData: Ubiquity:  Didn't get latest version: %@
%s(%d): CoreData: Ubiquity:  %@
Error trying to load the current metadata: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Current baseline matches the baseline archive, returning.
%s(%d): CoreData: Ubiquity:  Can adopt: %d replace: %d
kv: %@
%s(%d): CoreData: Ubiquity:  Adopted: %d
%s(%d): CoreData: Ubiquity:  Made current w/o replace: %d
%s(%d): CoreData: Ubiquity:  %@
Error while attempting to load the baseline in response to a baseline roll: %@
userInfo: %@
T@"NSObject<PFUbiquityBaselineRollResponseOperationDelegate>"
modelVersionHash: %@
T@"NSManagedObjectModel",R,N,V_model
T@"NSBatchUpdateRequest",R,N
createFetchRequestContextForObjectsToUpdate
T@"NSSQLFetchRequestContext",R,N
createCountRequestContextForObjectsToUpdate
T@"NSSQLCountRequestContext",R,N
updateStatement
com.apple.coredata.ubiquity.ubiquitized
com.apple.coredata.ubiquity.localImportComplete
com.apple.coredata.ubiquity.token
com.apple.coredata.ubiquity.baseline.timestamp
PFUbiquitySetupPreviousModelVersionHashKey
PFUbiquitySetupContainerIdentifierKey
PFUbiquitySetupSynchronousSideLoadKey
PFUbiquitySetupTokenAndIDArray
PFUbiquitySetupOriginalStoreURLAbsoluteStringKey
PFUbiquitySetupUbiquityURLOverrideKey
PFUbiquitySetupFinishedSleepKey
PFUbiquitySetupCopyExistingStoreFileKey
PFUbiquitySetupNotifyAboutProgressKey
PFUbiquitySetupAllowExporterBaselineRollKey
PFSetupLocalPeerIDOverride
PFSetupLocationSentinelOverrideKey
PFUbiquitySetupMigrateTransactionLogsKey
PFUbiquitySetupCheckForFork
PFUbiquitySetupDoFork
PFUbiquitySetupStoreFilePeerIDKey
PFUbiquitySetupWillInitializeReceiptNotification
PFUbiquitySetupWillInitializeBaselineNotification
PFUbiquitySetupWillCheckReceiptNotificaton
PFUbiquitySetupWillSideLoadStoreNotification
PFUbiquitySetupWillFinishNotification
PFUbiquitySetupDidFinishNotification
PFUbiquitySetupWillSeedStoreNotification
PFUbiquitySetupDidSeedStoreNotification
options: %@
psc: %@
store: %@
storeURL: %@
actualStoreURL: %@
storeMetadata: %@
storeKV: %@
storeFileExists: %d
storeFileIsReadOnly: %d
ubiquityEnabled: %d
ubiquityIdentityToken: %@
ubiquityRootURL: %@
ubiquityRootSubpath: %@
ubiquityName: %@
ubiquityContainerIdentifier: %@
localPeerID: %@
ubiquityRootLocation: %@
localRootLocation: %@
metaKV: %@
baseline: %@
baselineFileExists: %d
hasUploadingBaseline: %d
monitorBaslineUploadAsync: %d
didBaselineCopy: %d
baselineKV: %@
hasStoreMetadataFile: %d
hasStoreMetadataEntry: %d
hasContainerUUID: %d
hasContainerUUIDInStore: %d
needsMetadataRecovery: %d
localPeerReceipt: %@
receiptKV: %@
containerIdentifier: %@
preStoreContainerUUID: %@
usedExistingUUIDMapping: %d
hasLocalTransactionLogs: %d
votedOffIsland: %d
reapUbiquitousLogs: %d
respondToBaselineRoll: %d
hasMigrationOptions: %d
didMigrateBaseline: %d
storeWasMigrated: %d
replayLogsSynchronously: %d
useLocalAccount: %d
abortSetup: %d
gotExportNotification: %d
%s(%d): CoreData: Ubiquity:  Invalid option: the value for NSPersistentStoreUbiquitousContentNameKey should not contain periods: %@
-[PFUbiquitySetupAssistant validateOptionsWithError:]
The %@ persistent store type does not support iCloud integration.
No value for NSPersistentStoreUbiquitousContentNameKey was given however there is a value for NSPersistentStoreUbiquitousContentURLKey, did you forget to pass the value for NSPersistentStoreUbiquitousContentNameKey to the options dictionary for this store?
NSPersistentStoreUbiquitousPeerTokenOption must be an alpha numeric string, %@ has invalid characters
%s(%d): CoreData: Ubiquity:  Invalid value for NSPersistentStoreUbiquitousPeerTokenOption: %@
Unable to generate a peer ID for this peer.
The value passed for NSPersistentStoreUbiquitousContentURLKey cannot be the same as the store URL.
NSPersistentStoreUbiquitousContentNameKey: %@
storeURL: %@
The value passed for NSPersistentStoreUbiquitousContentURLKey cannot be inside a .nosync, nothing will ever sync.
%@ is not a valid value for NSPersistentStoreUbiquitousContentURLKey, it must be a relative path.
%@ is not a valid value for NSPersistentStoreUbiquitousContentURLKey, it must be an instance of NSString or NSURL.
%@ is not a valid file URL
The provided ubiquity name is already in use.
Received a nil or non file URL value for the store URL.
Core Data Ubiquity integration can only be enabled on SQLite stores, you must pass store type NSSQLiteStoreType to -addPersistentStoreWithType:configuration:URL:storeURL:options:error:.
Unable to get a model version hash from this coordinator's managed object model: %@
%s(%d): CoreData: Ubiquity:  No model version hash for coordinator: %@
Model: %@
%s(%d): CoreData: Ubiquity:  Current identity token: %@
-[PFUbiquitySetupAssistant doPostValidationInit:]
%s(%d): CoreData: Ubiquity:  %@
Store file exists: %d - %@
%s(%d): CoreData: Ubiquity:  Unable to destroy persistent store: %@
The store name: %@ is already in use.
Store URL: %@
In Use Store URL: %@
-[PFUbiquitySetupAssistant performCoordinatorPostStoreSetup:error:]
%s(%d): CoreData: Ubiquity:  %@
No one agrees
container: %@
preStore: %@
store: %@
-[PFUbiquitySetupAssistant initializeContainerIdentifierWithStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Couldn't identify container: %@
%s(%d): CoreData: Ubiquity:  Setup failed because of a missing file, retrying(%ld): %@
-[PFUbiquitySetupAssistant finishSetupWithRetry:]
%s(%d): CoreData: Ubiquity:  %@: Retrying after delay: %ld
%s(%d): CoreData: Ubiquity:  %@
Couldn't clean up from failed setup, giving up until the next time -addPersistentStore is called: %@
-[PFUbiquitySetupAssistant finishSetupWithRetry:]_block_invoke
-[PFUbiquitySetupAssistant finishSetupForStore:error:]
setupAssistant
UserDictionary
PhraseLearning_zh_Han
com.apple.CoreData.ForceUbiquityForkRecovery
%s(%d): CoreData: Ubiquity:  %@
User Defaults didn't synchronize fork removal
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to read the ubiquity root location.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the receipt file.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the container identifier.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the metadata stack.
%s(%d): CoreData: Ubiquity:  %@
Error encountered while preparing store metadata: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to initialize the baseline.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to check the knowledge vectors.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to side load the store.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting metadata recovery.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to cache the metadata entry.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after waiting for the baseline file to upload.
%s(%d): CoreData: Ubiquity:  %@
Moved local log files.
%s(%d): CoreData: Ubiquity:  %@
Error moving local log files to the ubiquity directory: %@
%s(%d): CoreData: Ubiquity:  %@
Pruned staging directory
%s(%d): CoreData: Ubiquity:  %@
Error prungin the staging directory: %@
%s(%d): CoreData: Ubiquity:  %@
Started Monitor
%s(%d): CoreData: Ubiquity:  %@
Error starting monitor: %@
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to finish setup.
%s(%d): CoreData: Ubiquity:  %@
Setup failed after attempting to save the metadata changes.
%s(%d): CoreData: Ubiquity:  CoreData: error: Caught Exception %@ with userInfo %@ in -finishSetupForSet:error:
failed finishing setup for store during asynchronous iCloud initialization
%s(%d): CoreData: Ubiquity:  %@
Local peer receipt exists in cloud: %@
-[PFUbiquitySetupAssistant initializeReceiptFile:]
%s(%d): CoreData: Ubiquity:  %@
Removed dangling temporary peer receipt: %@
%s(%d): CoreData: Ubiquity:  %@
Error attempting to remove dangling temporary peer receipt: %@
Error: %@
UserInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Removed conflicting versions of receipt file: %@
%s(%d): CoreData: Ubiquity:  %@
Error attempting to remove conflicts for the receipt file: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Error reading receipt file, will remove so it can be replaced later: %@
%s(%d): CoreData: Ubiquity:  %@
Error checking receipt file status: %@
%s(%d): CoreData: Ubiquity:  %@
Error removing peer receipt from safe save location: %@
Didn't get a container URL back from URLForUbiquityContainerIdentifier:, giving up now. Please ensure the application is signed with the proper entitlements to read from the container.
%s(%d): CoreData: Ubiquity:  Coordinated read finished for ubiquity root url: %@
-[PFUbiquitySetupAssistant canReadFromUbiquityRootLocation:]_block_invoke
%s(%d): CoreData: Ubiquity:  Read finished: %d
-[PFUbiquitySetupAssistant canReadFromUbiquityRootLocation:]
%s(%d): CoreData: Ubiquity:  Read finished: %d / %d / %@
%s(%d): CoreData: Ubiquity:  Blocking for initial sync: %@
%s(%d): CoreData: Ubiquity:  Initial sync handler called, %@
 iCloud: Error: failed to receive initial sync notification call back in 90 seconds
%s(%d): CoreData: Ubiquity:  Initial sync complete: %@
 iCloud: Error: initial sync notification returned an error (%@)
%s(%d): CoreData: Ubiquity:  Found Peer: %@
%s(%d): CoreData: Ubiquity:  Starting download of all known peers: %@
%s(%d): CoreData: Ubiquity:  Attempting to download Peers hit a serious error for peers to download %@ with userInfo %@
%s(%d): CoreData: Ubiquity:  %@
Unable to scan root location: %@
%s(%d): CoreData: Ubiquity:  %@
All the faults are live
%s(%d): CoreData: Ubiquity:  Store file exists: %d
%s(%d): CoreData: Ubiquity:  Error attempting to read ubiquity root url: %@.
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Starting download on root URL: %@
%s(%d): CoreData: Ubiquity:  Attempting to download root URL (%@) hit a serious error: %@ with userInfo: %@
-[PFUbiquitySetupAssistant canReadFromUbiquityRootLocation:]_block_invoke_2
%s(%d): CoreData: Ubiquity:  %@
Baseline exists: %d
-[PFUbiquitySetupAssistant initializeBaselineForStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Unable to find a previous baseline file to use for migration. %@
%s(%d): CoreData: Ubiquity:  %@
Can't perform migration because there is no previous baseline file from which to get the managed object model: %@
%s(%d): CoreData: Ubiquity:  Baseline migration failed for store with ubiquity name: %@
Error: %@
userInfo: %@
Failed to migrate baseline, unable to create ubiquity migration manager
%s(%d): CoreData: Ubiquity:  %@
Found existing baseline file that needs to upload (%d, %d): %@
%s(%d): CoreData: Ubiquity:  %@
Baseline file is still uploading: %@
%s(%d): CoreData: Ubiquity:  %@
The baseline file exists, but could not be read: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
The baseline file exists but could not be downloaded: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Purged temporary store directory.
%s(%d): CoreData: Ubiquity:  %@
Unable to remove temporary store directory: %@
%s(%d): CoreData: Ubiquity:  %@
Created temporary store directory: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to create temproary store directory: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to create store for baseline: %@
%s(%d): CoreData: Ubiquity:  Transaction log migration failed for store: %@
Error: %@
userInfo: %@
-[PFUbiquitySetupAssistant checkAndPerformMigrationForStore:error:]
Failed to migrate ubiquitous content, unable to create ubiquity migration manager
%s(%d): CoreData: Ubiquity:  %@
Successfully recovered metadata
-[PFUbiquitySetupAssistant attemptMetadataRecoveryForStore:error:]
Store metadata recovery appears to have failed, please try adding the store to the coordinator again. If that is unsuccessful, migrate the data to a new ubiquitized persistent store.
%s(%d): CoreData: Ubiquity:  gethostuuid returned -1. Giving up now.
+[PFUbiquitySetupAssistant generateMachineUUIDString]
%s(%d): CoreData: Ubiquity:  Detecting Fork and is force:%@
-[PFUbiquitySetupAssistant detectAndFixForkedContainer:store:error:]
%s(%d): CoreData: Ubiquity:  Fork detected, will fork now
fork~%@
%s(%d): CoreData: Ubiquity:  Removed old fork directory: %@
-[PFUbiquitySetupAssistant detectAndFixForkedContainer:store:error:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error moving log: %@
%s(%d): CoreData: Ubiquity:  Unable to load baseline from %@
%@:1
fork~%@.nosync
%s(%d): CoreData: Ubiquity:  Unable to delete forked contents: %@
timestamp
shortcut
phrase
partOfSpeech
UserDictionaryEntry
defaultReading
extraInteger1
extraInteger2
extraString1
extraString2
frequency
reading
seed
surface
syllables
LearningDictionaryEntry
firstSurface
secondReading
secondSurface
nobody
~sim
affectedDirectory
fileAttributes
CoreData: Ubiquity: must be able to write to the affected path as a directory.
CoreData: Ubiquity: requires at least 1mb of free space to allocate it's metadata storage.
%s(%d): CoreData: Ubiquity:  Metadata migration failed: %@
-[PFUbiquitySetupAssistant migrateMetadataRoot:]
%s(%d): CoreData: Ubiquity:  %@
Error fetching metadata store knowledge vector, metadata will be recovered: %@
-[PFUbiquitySetupAssistant initializeStack:]
%s(%d): CoreData: Ubiquity:  %@
Error trying to open metadata store: %@
CoreDataStores
sideLoad.store
%s(%d): CoreData: Ubiquity:  Cleared out store for side-load: %@
-[PFUbiquitySetupAssistant sideLoadStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Error removing side-load store %@: %@
%s(%d): CoreData: Ubiquity:  %@
Error removing side-load store: %@
%s(%d): CoreData: Ubiquity:  Cleared out directory for side-load: %@
%s(%d): CoreData: Ubiquity:  %@
Error removing side-load directory: %@
%s(%d): CoreData: Ubiquity:  Created directory for side-load: %@
%s(%d): CoreData: Ubiquity:  %@
Error creating side-load directory: %@
%s(%d): CoreData: Ubiquity:  %@
Pruned local root directory: %@
%s(%d): CoreData: Ubiquity:  %@
Error pruning local root directory: %@
%s(%d): CoreData: Ubiquity:  %@
Pruned ubiquity root directory: %@
%s(%d): CoreData: Ubiquity:  %@
Error pruning ubiquity root directory: %@
%s(%d): CoreData: Ubiquity:  Import started (Side load)
%s(%d): CoreData: Ubiquity:  Import finished (Side load)
%s(%d): CoreData: Ubiquity:  %@
Purged history cache
%s(%d): CoreData: Ubiquity:  %@
Error purging history cache: %@
%s(%d): CoreData: Ubiquity:  Side load finish: %@ / %@
%s(%d): CoreData: Ubiquity:  %@
Error reading local log directory: %@
-[PFUbiquitySetupAssistant createSetOfLocalLogLocations:]
%s(%d): CoreData: Ubiquity:  Created ubiquity peer log directory: %@
-[PFUbiquitySetupAssistant moveLocalLogFilesToUbiquityLocation:]
%s(%d): CoreData: Ubiquity:  %@
Unable to write to peer transaction log directory: %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Moved local log: %@ to %@
%s(%d): CoreData: Ubiquity:  %@
Error moving local log: %@ to %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Error trying to read peer version directory: %@
%s(%d): CoreData: Ubiquity:  Rewriting save snapshot (%@)
-[PFUbiquitySetupAssistant rewriteTransactionLogs:toMatchStore:error:]
%s(%d): CoreData: Ubiquity:  Finished rewriting save snapshot (%@)
%s(%d): CoreData: Ubiquity:  %@
 Rewrote log: %@
%s(%d): CoreData: Ubiquity:  %@
 Error rewriting log: %@
%s(%d): CoreData: Ubiquity:  %@
Moved log to temporary location: %@
%s(%d): CoreData: Ubiquity:  %@
 Error moving log: %@
%s(%d): CoreData: Ubiquity:  %@
Removed old local log: %@
%s(%d): CoreData: Ubiquity:  %@
File went missing: %@
%s(%d): CoreData: Ubiquity:  %@
Error deleting old local log: %@
%s(%d): CoreData: Ubiquity:  %@
Moved log file to local directory: %@
%s(%d): CoreData: Ubiquity:  %@
Error moving log file to local directory: %@
%s(%d): CoreData: Ubiquity:  Error moving local log: %@
-[PFUbiquitySetupAssistant rewriteTransactionLogs:toMatchStore:error:]_block_invoke_3
%s(%d): CoreData: Ubiquity:  Tried deleting file: %@
%s(%d): CoreData: Ubiquity:  %@
Imported local logs: %@
-[PFUbiquitySetupAssistant tryToReplaceLocalStore:withStoreSideLoadedByImporter:]
%s(%d): CoreData: Ubiquity:  %@
Error side loading local logs: %@
Error: %@
%s(%d): CoreData: Ubiquity:  Looks like the store was changed in will change, trying again: %@
%s(%d): CoreData: Ubiquity:  %@
Attempting to replace store: %@ with store: %@
%s(%d): CoreData: Ubiquity:  %@
Replaced %@ with %@
-[PFUbiquitySetupAssistant tryToReplaceLocalStore:withStoreSideLoadedByImporter:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error loading new store metadata after side load: %@
%s(%d): CoreData: Ubiquity:  %@
Updated store knowledge vector to: %@
%s(%d): CoreData: Ubiquity:  %@
Refreshed peer range cache: %@
%s(%d): CoreData: Ubiquity:  %@
Error refreshing peer range cache: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to reinitialize store knowledge vector: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to replace %@ with side loaded store: %@
Error: %@
%s(%d): CoreData: Ubiquity:  %@
Successfully wrote peer receipt file: %@
-[PFUbiquitySetupAssistant checkKnowledgeVectorsAndBaselineWithStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Error writing local peer receipt file to disk: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Local store knowledge vector matches receipt knowledge vector.
%s(%d): CoreData: Ubiquity:  %@
Local store file is behind receipt.
Store: %@
Receipt: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to get the mod time for baseline (%d): %@
%s(%d): CoreData: Ubiquity:  Moved orphaned log to sync'd directory: %@
-[PFUbiquitySetupAssistant pruneStagingDirectoryForStore:error:]
%s(%d): CoreData: Ubiquity:  %@
Unable to move log to permanent location: %@
%s(%d): CoreData: Ubiquity:  Deleted orphaned log: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to delete log: %@
%s(%d): CoreData: Ubiquity:  Successfully migrated seed store: %@
-[PFUbiquitySetupAssistant seedStore:error:]
failed to seed store during asynchronous iCloud setup
%s(%d): CoreData: Ubiquity:  Couldn't load baseline metadata from baseline: %@
-[PFUbiquitySetupAssistant respondToBaselineRoll:]
%s(%d): CoreData: Ubiquity:  Looks like we were passed the full URL, not the store file URL: %@
+[PFUbiquitySetupAssistant createActualStoreURLForStoreURL:localPeerID:containerIdentifier:andStoreName:]
%s(%d): CoreData: Ubiquity:  Created actual store url: %@
for url: %@
%s(%d): CoreData: Ubiquity:  Using the original store URL (linked on or after 10.9 / 7.0): %@
%s(%d): CoreData: Ubiquity:  %@
User Defaults didn't synchronize
+[PFUbiquitySetupAssistant setContainerIdentifierUUID:forIdentityToken:forStoreName:]
+[PFUbiquitySetupAssistant cleanUserDefaultsForStore:]
%s(%d): CoreData: Ubiquity:  Unable to load baseline: %@
+[PFUbiquitySetupAssistant createBaselineFromMostRecentLocation:localPeerID:error:]
%s(%d): CoreData: Ubiquity:  %@
Error checking uploaded status of baseline file: %@
%s(%d): CoreData: Ubiquity:  %@
Aborting setup because store removed from coordinator. %@
-[PFUbiquitySetupAssistant coordinatorWillRemoveStore:]
T@"NSDictionary",R,N,V_options
ubiquityEnabled
TB,R,N,V_ubiquityEnabled
needsMetadataRecovery
TB,R,N,V_needsMetadataRecovery
T@"NSURL",R,N,V_ubiquityRootURL
containerIdentifier
T@"PFUbiquityContainerIdentifier",R,N,V_containerIdentifier
TB,R,N,V_useLocalAccount
storeWasMigrated
TB,N,V_storeWasMigrated
actualStoreFileURL
T@"NSURL",R,N,V_actualStoreFileURL
abortSetup
TB,N,V_abortSetup
T@"PFUbiquityKnowledgeVector",R,N,V_storeKV
retryDelaySec
TQ,N,V_retryDelaySec
cacheFilePresenterForUbiquityRoot
TB,N,V_cacheFilePresenterForUbiquityRoot
failSetup
TB,N,V_failSetup
failSetupError
T@"NSError",&,N,V_failSetupError
containerId
PFUbiquityContainerIdentifierDeleteNotificaton
local
uuidString
T@"NSString",R,N,V_uuidString
uuidFileLocation
T@"PFUbiquityLocation",R,N,V_uuidFileLocation
usedExistingUUIDFile
TB,R,N,V_usedExistingUUIDFile
T@"NSURL",R,C,V_presentedItemURL
localPeerID: %@
storeName: %@
Cached Ranges:
All Entity Ranges: %lu
Translated Global IDs: %lu
Cached Ranges:
All Entity Ranges: %@
Translated Global IDs: %@
peerStart <= %@ AND peerEnd >= %@
rangeStart <= %@ AND %@ <= rangeEnd
%s(%d): CoreData: Ubiquity:  %@
Found multiple ranges for entity: %@ and local primary key: %@
-[PFUbiquityPeerRangeCache cachedRangeForLocalPrimaryKey:ofEntityNamed:]
Couldn't parse numeric primary key out of the provided object ID.
rangeStart <= %@ AND rangeEnd >= %@
p%ld
Unable to resolve global object IDs: %@
translatedGlobalIDs
T@"NSDictionary",R,N,V_translatedGlobalIDs
owningPeerID: %@
entityName: %@
rangeStart: %@
rangeEnd: %@
peerStart: %@
peerEnd: %@
T@"NSNumber",R,N,V_rangeStart
T@"NSNumber",R,N,V_rangeEnd
T@"NSNumber",R,N,V_peerStart
T@"NSNumber",R,N,V_peerEnd
rootLocationToPeerIDToEntry: %@
%s(%d): CoreData: Ubiquity:  %@ unable to construct metadata entry.
Entry: %@
localPeerID: %@
rootLocation: %@
Error: %@
userInfo: %@
-[PFUbiquityMetadataFactory newMetadataEntryForLocalPeerID:storeName:andUbiquityRootLocation:error:]
metadataStoreFileLocation: %@
psc: %@
store: %@
filePresenter: %@
%s(%d): CoreData: Ubiquity:  Creating file: %@
-[PFUbiquityMetadataFactoryEntry initializePersistentStoreCoordinator:]
%s(%d): CoreData: Ubiquity:  %@
Error removing metaDataStore: %@
%s(%d): CoreData: Ubiquity:  %@
Trouble adding the metadata store to the coordinator: %@
userInfo: %@
T@"PFUbiquityMetadataFactoryFilePresenter",R,N,V_filePresenter
T@"NSPersistentStoreCoordinator",R,N,V_psc
x-coredata://%@/%@/%@
T@"NSManagedObjectContext",R,N,V_moc
numRangesToReserve
Tq,R,N,V_numRangesToReserve
peerEntityNameRangeStartSet
T@"NSDictionary",R,N,V_peerEntityNameRangeStartSet
%s(%d): CoreData: Ubiquity:  Got delete for metadata store: %@
-[PFUbiquityMetadataFactoryFilePresenter accommodatePresentedItemDeletionWithCompletionHandler:]
presentedItemLocation
T@"PFUbiquityLocation",R,N,V_presentedItemLocation
%s(%d): CoreData: Ubiquity:  %@
 Error loading transaction log: %@
Error: %@
userInfo: %@
-[PFUbiquityTransactionLogCache retainedCachedLogForLocation:loadWithRetry:error:]
logLocation
FETCH_REQUEST_LIMIT_SUBSTITUTION
FETCH_REQUEST_OFFSET_SUBSTITUTION
Unsupported substitution variable type for key %@
Mismatched variables dictionaries (count)
Mismatched variables dictionaries (missing value)
Mismatch: that which was once a collection is no longer (%@)
_identifier
T@,R,N,V_identifier
T@"NSDictionary",C,N
Invalid variable substitution - multiple values not supported here %@
unable to resolve variable expression: %@
localPeerID: %@
storeName: %@
cacheKV: %@
minCacheKV: %@
Cached Entries:
Global ID To History: %lu
Entries to write: %lu
peerIDToHistoryArray: %@
globalIDToHistoryArray: %@
entriesToWrite: %@
%s(%d): CoreData: Ubiquity:  %@
Error while writing pending transaction history entries to disk: %@
userInfo: %@
-[PFUbiquityTransactionHistoryCache purgeCacheAndWritePendingEntries:error:]_block_invoke
T@"PFUbiquityLocation",R,N,V_rootLocation
globalIDCache
T@"PFUbiquityGlobalObjectIDCache",&,N,V_globalIDCache
cacheKV
T@"PFUbiquityKnowledgeVector",R,N,V_cacheKV
minCacheKV
T@"PFUbiquityKnowledgeVector",R,N,V_minCacheKV
cachedGlobalIDs
Baseline
storeName: %@
actingPeerID: %@
transactionNumber: %@
transactionDate: %@
transactionType: %d
globalID: %@
knowledgeVector: %@
transactionLogLocation: %@
globalID
T@"PFUbiquityGlobalObjectID",&,N,V_globalID
Ti,N,V_transactionType
actingPeerID
T@"NSString",&,N,V_actingPeerID
T@"NSString",&,N,V_storeName
T@"PFUbiquityLocation",&,N,V_transactionLogLocation
%s(%d): CoreData: Ubiquity:  %@
Registering for application will resign active.
-[PFUbiquitySwitchboardCacheWrapper initWithStoreName:privateStore:forLocalPeerID:andUbiquityRootLocation:]
UIApplicationWillResignActiveNotification
%s(%d): CoreData: Ubiquity:  %@
Unregistering for application will resign active.
-[PFUbiquitySwitchboardCacheWrapper cacheWrapperWillBeRemovedFromEntry]
%s(%d): CoreData: Ubiquity:  %@
 Error purging transaction history cache: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  %@
Receipt file write failed: %@
%s(%d): CoreData: Ubiquity:  %@ ignoring schedule request because it is not allowed: %@
-[PFUbiquitySwitchboardCacheWrapper scheduleReceiptFileWrite:]
%s(%d): CoreData: Ubiquity:  %@ encountered an error while trying to write receipt: %@ to disk: %@
userInfo: %@
-[PFUbiquitySwitchboardCacheWrapper scheduleReceiptFileWrite:]_block_invoke
%s(%d): CoreData: Ubiquity:  Error writing receipt file before switchboard removal: %@
userInfo: %@
-[PFUbiquitySwitchboardCacheWrapper writeReceiptFile:error:]
-[PFUbiquitySwitchboardCacheWrapper _appWillResignActive:]
T@"PFUbiquityGlobalObjectIDCache",R,N,V_globalIDCache
peerRangeCache
T@"PFUbiquityPeerRangeCache",R,N,V_peerRangeCache
transactionLogCache
T@"PFUbiquityTransactionLogCache",R,N,V_transactionLogCache
transactionHistoryCache
T@"PFUbiquityTransactionHistoryCache",R,N,V_transactionHistoryCache
peerReceipt
T@"PFUbiquityPeerReceipt",R,N,V_peerReceipt
T@"PFUbiquityKnowledgeVector",&,V_kv
baselineKV
T@"PFUbiquityKnowledgeVector",&,V_baselineKV
%@(%d)
permanentLocation: %@
safeLocation: %@
currentLocation: %@
%s(%d): CoreData: Ubiquity:  %@
Unable to remove file at location: %@
errno: %d
-[PFUbiquitySafeSaveFile removeFileFromLocation:error:]
The file upload timed out.
%s(%d): CoreData: Ubiquity:  %@
Safe save failed for file, error: %@
-[PFUbiquitySafeSaveFile waitForFileToUpload:]
%s(%d): CoreData: Ubiquity:  %@
Successfully moved file from: %@ to: %@
-[PFUbiquitySafeSaveFile moveToPermanentLocation:]_block_invoke
%s(%d): CoreData: Ubiquity:  %@
Had trouble file from: %@ to: %@
Error: %@
userInfo: %@
%s(%d): CoreData: Ubiquity:  Checking peer file upload: %@
-[PFUbiquitySafeSaveFile checkSafeSaveFileUpload]
The file download timed out.
%s(%d): CoreData: Ubiquity:  %@
Download failed for file, error: %@
-[PFUbiquitySafeSaveFile waitForFileToDownload:]
%s(%d): CoreData: Ubiquity:  %@
Checking file download: %@
-[PFUbiquitySafeSaveFile checkFileDownload]
permanentLocation
T@"PFUbiquityLocation",R,N,V_permanentLocation
safeSaveLocation
T@"PFUbiquityLocation",R,N,V_safeSaveLocation
T@"PFUbiquityLocation",&,N,V_currentLocation
safeSaveError
T@"NSError",R,N,V_safeSaveError
isRegistered
TB,R,N,V_isRegistered
continueCheckingUpload
TB,R,N,V_continueCheckingUpload
safeSaveSuccess
TB,R,N,V_safeSaveSuccess
moveAfterSave
TB,R,N,V_moveAfterSave
existsAtSafeSaveLocation
existsAtPermanentLocation
existsInCloud
downloadSuccess
TB,R,N,V_downloadSuccess
continueCheckingDownload
TB,R,N,V_continueCheckingDownload
downloadError
T@"NSError",R,N,V_downloadError
pendingLogs: %@
scheduledLogs: %@
failedLogs: %@
ignoredlogs: %@
encounteredErrors: %@
%s(%d): CoreData: Ubiquity:  Ignoring file: %@
Error: %@
-[PFUbiquityRecordsImporterSchedulingContext transactionLogAtLocation:failedToOpenWithError:]
pendingLogLocations
T@"NSSet",R,N,V_pendingLogLocations
scheduledLogLocations
T@"NSSet",R,N,V_scheduledLogLocations
failedLogLocations
T@"NSSet",R,N,V_failedLogLocations
ignoredLogLocations
T@"NSSet",R,N,V_ignoredLogLocations
logLocationsToEncounteredErrors
T@"NSDictionary",R,N,V_logLocationsToEncounteredErrors
%s(%d): CoreData: Ubiquity:  Failed to get sublocations for %@ %@, %@
-[PFUbiquityMigrationAssistant _populateBaselineAndTransactionLogLocations]
previousModelVersionHash
T@"NSString",R,N,V_previousModelVersionHash
currentModelVersionHash
T@"NSString",R,N,V_currentModelVersionHash
com.apple.coredata.ubiquity.monitor.token
com.apple.coredata.ubiquity.monitor.tokenToUUID
com.apple.coredata.ubiquity.container.state.willChange
com.apple.coredata.ubiquity.container.state.didChange
com.apple.coredata.ubiquity.monitor.state.willChange
PFUbiquityContainerMonitorWillChangeContainerIdentifierNotification
PFUbiquityContainerMonitorDidChangeContainerIdentifierNotification
currentIdentityToken: %@
%s(%d): CoreData: Ubiquity:  %@
Registering for application resumed notification.
-[PFUbiquityContainerMonitor startMonitor:]
UIApplicationResumedNotification
%s(%d): CoreData: Ubiquity:  Trouble identifying container: %@
-[PFUbiquityContainerMonitor containerDeleteDetected:]
%s(%d): CoreData: Ubiquity:  %@
Application resumed, scheduling check.
-[PFUbiquityContainerMonitor _applicationResumed:]
-[PFUbiquityContainerMonitor checkStoresAndContainer:]
containerState
Ti,N,V_containerState
monitorState
Ti,N,V_monitorState
currentIdentityToken
T@"<NSObject><NSCopying><NSCoding>",R,N,V_currentIdentityToken
PFUbiquityTransactionLogMigrator
_PFUbiquityMigrationContext
PFUbiquityMigrationManager
NSSQLSaveChangesRequestContext
NSPullChangeHistoryRequest
_NSCoreDataException
_NSCoreDataOptimisticLockingException
_NSCoreDataConstraintViolationException
_NSCoreDataSQLPredicateCategories
NSCoreDataXPCMessage
NSSecureCoding
NSCoding
_NSFaultingMutableArray
NSSQLBindIntarray
_NSFaultingMutableSet
_NSFaultingMutableSetMutationMethods
_NSMappingModelBuilder
_NSMemoryStorePredicateRemapper
_NSChildContextPredicateRemapper
_NSXPCStorePredicateRemapper
_NSNotifyingWrapperMutableSet
_CoreData_Extensions
_nop_missing_selectors
_NSPersistenceUtilities
_NSDefaultSectionInfo
NSFetchedResultsSectionInfo
_NSProxyWrapperMutableSet
_NSSQLGenerator
NSCachedFetchRequestThunk
NSCachedFetchRequestInfo
_PFArray
_PFBatchFaultingArray
_PFMutableProxyArray
_PFEncodedArray
_PFFetchedResultOrderedSetWrapper
_PFCachedNumber
NSSQLAttributeTrigger
_PFContextMapTable
_PFTask
NSPrivateCoreDataClassForFindingBundle
_PFRoutines
_PFWeakReference
_PFLock
NSLocking
_PFGarbageManager
_PFString
_PFEncodedString
NSAtomicStore
_NSInternalMethods
NSPersistentStoreDescription
NSCopying
NSAtomicStoreCacheNode
NSAttributeDescription
_NSAttributeDescriptionPrivateMethods
NSAttributeStoreMapping
_NSCoreManagedObjectID
NSBasicObjectID
_NSScalarObjectID
NSScalarObjectID64
NSScalarObjectID48
_NSCoreDataTaggedObjectID
_NSCoreDataTaggedObjectIDFactory
NSBinaryObjectStore
NSPersistentStoreResult
NSUnknownRequestTypeResult
NSPersistentStoreAsynchronousResult
NSAsynchronousFetchResult
NSBinaryObjectStoreFile
NSDictionaryMapNode
NSDictionaryStoreMap
NSEntityDescription
NSFastEnumeration
_NSEntityDescriptionPrivateMethods
NSEntityMapping
NSEntityMigrationPolicy
NSEntityStoreMapping
NSExpressionDescription
NSConstraintValidator
NSSQLitePrefetchRequestCache
NSPersistentCacheRow
NSXPCRow
NSFaultHandler
NSPersistentContainer
CoreDataSPI
NSFetchedPropertyDescription
NSFetchedResultSupport
NSFetchRequestResult
NSObject
NSFetchRequest
_NSCoreDataSPI
NSFetchRequestExpression
NSJoin
NSKnownKeysMappingStrategy1
NSKnownKeysMappingStrategy2
NSKnownKeysDictionary1
_NSKnownKeysEnumerator
NSKnownKeysDictionary2
NSKnownKeysMappingStrategy
NSKnownKeysDictionary
_NSOrderedSetDiff
_NSOrderedSetDiffDelete
_NSOrderedSetDiffChange
_NSOrderedSetDiffInsert
_NSOrderedSetDiffMove
NSManagedObject
_PhotosOrderKeyUpdateSupport
NSXPCStoreNotificationObserver
_PFDynamicAccessorsAndPropertySupport
_NSManagedObject_st
NSManagedObjectContext
_NSInternalAdditions
_NSInternalChangeProcessing
_NSInternalNotificationHandling
NSEditorAndEditorRegistration
_PFManagedObjectReferenceQueue
_NestedContextSupport
_PFTempNestedSnapshot
NSManagedObjectID
NSManagedObjectModel
_NSManagedObjectModelPrivateMethods
NSXPCStoreConnectionInfo
InternalMethods
NSXPCStoreServerConnectionContext
NSXPCStoreServerPerConnectionCache
NSManagedObjectModelBundle
NSMappedObjectStore
NSMappingModel
NSSQLUpdateColumnsIntermediate
NSXPCServerProtocol
NSXPCStoreConnection
NSMemoryObjectStore
NSXPCStoreServerNotificationManager
NSMemoryStoreEqualityPredicateOperator
NSMemoryStoreInPredicateOperator
NSMergeConflict
NSConstraintConflict
NSMergePolicy
PFUbiquityBaselineHeuristics
NSMigrationContext
NSMigrationManager
NSPersistentStore
NSPersistentStoreCache
NSPersistentStoreCoordinator
_NSPersistentStoreCoordinatorPrivateMathods
_NSPersistentStoreCoordinatorPrivateMethodsForContacts
_NSPersistentStoreCoordinatorPrivateMethodsForDuet
QueryGenerations
Triggers
_PFChangeInfo
NSPersistentStoreMap
NSPropertyDescription
_NSPropertyDescriptionPrivateMethods
NSBatchUpdateRequest
NSPredicatedStoreRequest
NSPropertyMapping
NSPropertyStoreMapping
NSPropertyTransform
NSRelationshipDescription
_NSRelationshipDescriptionPrivateMethods
NSRelationshipStoreMapping
_PFRefCountableValue
NSSaveChangesRequest
NSSaveChangesRequest_Internal
NSSQLAliasGenerator
PFUbiquityLocationStatus
NSSQLAttribute
NSSQLBindVariable
NSSQLColumn
NSSQLCompoundWhereIntermediate
NSSQLConstantValueIntermediate
NSSQLCore
NSFilePresenter
_NSSQLCoreConnectionObsever
NSSQLEntity
porting
NSSQLEntityKey
NSSQLExpressionIntermediate
NSSQLFetchCountIntermediate
NSSQLFetchIntermediate
NSSQLForeignEntityKey
NSSQLForeignKey
NSSQLForeignKeyIntermediate
NSSQLFunctionExpressionIntermediate
NSSQLSavePlan
NSSQLGenerator
NSXPCStore
Internal
NSSQLIntermediate
NSSQLiteAdapter
NSSQLiteConnection
NSSQLBlockRequestContext
NSSQLJoinIntermediate
NSSQLKeypathExpressionIntermediate
NSSQLLimitIntermediate
NSSQLManyToMany
NSSQLModel
NSSQLOffsetIntermediate
NSSQLOptLockKey
NSSQLOrderIntermediate
_PFFetchPlanHeader
NSXPCStoreServer
NSSQLPredicateAnalyser
NSPredicateVisitor
NSSQLUbiquitizedStoreConnectionManager
NSSQLiteStatementCache
NSSQLPrimaryKey
NSManagedImmutableObject
NSSQLProperty
NSSQLReadOnlySelectIntermediate
NSSQLRelationship
NSSQLRow
NSSQLRowCache
NSSQLSelectIntermediate
NSSQLSimpleWhereIntermediate
NSSQLiteStatement
NSSQLStoreMappingGenerator
NSSQLSubqueryExpressionIntermediatePredicateVisitor
NSSQLSubqueryExpressionIntermediate
NSSQLToMany
NSGenerationToken
CoreDataInternal
NSSQLRelationshipFaultRequestContext
NSSQLFetchRequestContext
NSSQLXPCFetchRequestContext
NSSQLObjectIDSetFetchRequestContext
NSSQLToOne
NSSQLWhereIntermediate
NSStoreMapNode
NSXPCStoreServerRequestHandlingPolicy
NSStoreMapping
NSStoreMappingGenerator
NSXPCStoreManagedObjectArchivingToken
NSBatchUpdateResult
NSStoreMigrationPolicy
_NS128bitWrapper
NSTemporaryObjectID
_NSTemporaryObjectID2
NSValidationErrorLocalizationPolicy
NSMergedPolicyLocalizationPolicy
NSFetchedResultsController
PrivateMethods
NSSQLTernaryExpressionIntermediate
_NSSQLEntityMigrationDescription
NSSQLiteIntarrayTable
NSSQLUpdateIntermediate
_NSSQLiteStoreMigrator
_NSSQLTableMigrationDescription
NSSQLiteInPlaceMigrationManager
NSSQLGroupByIntermediate
NSSQLHavingIntermediate
NSPersistentStoreRequest
NSAsynchronousFetchRequest
_NSPropertyDescriptionProxy
_NSPropertyDescriptionProxy2
_PFEncodedData
_PFExternalReferenceData
NSSQLCountRequestContext
NSSQLConnectionManager
NSSQLDefaultConnectionManager
_NSFaultingMutableOrderedSet
NSSQLCoreDispatchManager
NSSQLForeignOrderKey
_CDSnapshot
NSMutableCopying
NSIncrementalStore
NSConstraintCacheKey
NSConstraintCache
NSIncrementalStoreNode
NSSQLFetchDictionaryCountIntermediate
_NSNotifyingWrapperMutableOrderedSet
_NSFaultingMutableOrderedSetMutationMethods
_NSProxyWrapperMutableOrderedSet
NSGenerationalRowCache
_PFUbiquityRecordImportOperation
NSManagedObjectContextFaultingDelegate
_PFUbiquityRecordsExporter
_PFUbiquityRecordsImporter
_PFUbiquityRecordImportOperationDelegate
PFUbiquityBaselineRollOperationDelegate
PFUbiquityBaselineRecoveryOperationDelegate
PFUbiquityBaselineRollResponseOperationDelegate
_PFUbiquityStack
NSSQLBatchDeleteRequestContext
UbiquityMethods
PFUbiquityPeerState
NSSQLStoreRequestContext
PFUbiquityRemotePeerState
PFUbiquityLogging
PFUBLogEventID
PFUbiquityEventLogging
PFUbiquityFilePresenter
PFUbiquityRecordImportConflict
PFUbiquityMergeConflict
PFUbiquityMergePolicy
NSSQLObjectFaultRequestContext
PFUbiquitySwitchboard
PFUbiquitySwitchboardEntry
PFUbiquitySwitchboardEntryMetadata
NSSQLCorrelationTableUpdateTracker
PFUbiquityFileCoordinator
PFUbiquityBaseline
PFUbiquityBaselineMetadata
NSQueryGenerationToken
_NSQueryGenerationToken
_NSXPCQueryGenerationToken
PFUbiquityExportContext
PFUbiquityStoreExportContext
PFUbiquityGlobalObjectID
PFUbiquitySaveSnapshot
NSBatchDeleteRequest
NSBatchDeleteResult
PFUbiquityStoreSaveSnapshot
PFUbiquityTransactionLog
PFUbiquityImportContext
PFUbiquityLocation
NSSQLBoundedByIntermediate
NSSQLObjectIDRequestContext
PFUbiquityBaselineRollOperation
NSSQLStatementIntermediate
_PFZipFileArchive
PFZipCentralDirectoryFileHeader
PFZipEndOfCentralDirectoryRecord
PFZipLocalFileHeader
PFUbiquityPeer
PFUbiquityTransactionEntry
PFUbiquityPeerSnapshot
PFUbiquityPeerSnapshotCollection
PFUbiquityToManyConflictDiff
PFUbiquityBaselineRecoveryOperation
PFUbiquityStoreMetadata
_NSNoChangeToken
_NSXPCStoreObjectIDArrayConstantValueExpression
XPCStoreSupport
_NSXPCStoreUtilities
PFUbiquityPeerRange
PFUbiquityKnowledgeVector
PFUbiquityPeerReceipt
PFUbiquityImportOperation
PFUbiquityStoreMetadataMedic
PFUbiquityBaselineRollResponseOperation
PFUbiquityBaselineOperation
NSSQLBatchUpdateRequestContext
PFUbiquitySetupAssistant
PFUbiquityContainerIdentifier
PFUbiquityPeerRangeCache
PFUbiquitySQLCorePeerRange
PFUbiquityMetadataFactory
PFUbiquityMetadataFactoryEntry
PFUbiquityPeerRangeReservationContext
PFUbiquityMetadataFactoryFilePresenter
PFUbiquityTransactionLogCache
NSCachingFetchRequest
NSSQLVariableExpressionIntermediate
PFUbiquityTransactionHistoryCache
PFUbiquityTransactionEntryLight
PFUbiquityGlobalObjectIDCache
PFUbiquitySwitchboardCacheWrapper
PFUbiquitySafeSaveFile
PFUbiquityRecordsImporterSchedulingContext
PFUbiquityMigrationAssistant
PFUbiquityContainerMonitor
@48@0:8@16@24@32@40
v16@0:8
B48@0:8@16@24@32^@40
B40@0:8@16@24^@32
@24@0:8@16
@40@0:8@16@24@32
@32@0:8@16@24
B16@0:8
@"NSManagedObjectModel"
@"NSMappingModel"
@"NSString"
@"NSDictionary"
@"NSSet"
@16@0:8
v24@0:8@16
@"PFUbiquityTransactionLog"
@"PFUbiquityStoreSaveSnapshot"
@56@0:8@16@24@32@40@48
B44@0:8B16@20@28^@36
@"PFUbiquityLocation"
v32@0:8@16@24
@"NSSQLSavePlan"
@"NSFaultHandler"
@"NSMutableDictionary"
Q16@0:8
@"NSArray"
@48@0:8@16q24@32@40
q16@0:8
B32@0:8@16@24
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
v24@0:8Q16
@"NSData"
@24@0:8^{_NSZone=}16
Vv16@0:8
@36@0:8@16@24B32
@32@0:8@16Q24
@24@0:8Q16
Q40@0:8^{?=Q^@^Q[5Q]}16^@24Q32
v32@0:8Q16@?24
v40@0:8@16Q24@?32
Q32@0:8Q16@?24
Q40@0:8@16Q24@?32
@32@0:8Q16@?24
@40@0:8@16Q24@?32
v32@0:8@16Q24
v32@0:8Q16@24
v24@0:8^@16
@"NSMutableArray"
@"NSManagedObject"
@"NSPropertyDescription"
{_NSFaultingMutableArrayFlags="_isFault"b1"_reserved"b31}
I16@0:8
v20@0:8I16
B24@0:8@16
v24@0:8:16
v32@0:8:16@24
#16@0:8
{_NSFaultingMutableSetFlags="_isFault"b1"_mustPropagateDelete"b1"_reserved"b14"_relationship"b16}
@32@0:8#16@24
^{objc_method=}
i16@0:8
v20@0:8i16
@24@0:8^@16
B32@0:8Q16Q24
@"NSEntityMapping"
@"NSError"
@"NSManagedObjectContext"
@"NSMutableSet"
q24@0:8@16
B40@0:8@16@24@32
Q24@0:8@16
@"NSString"16@0:8
@"NSArray"16@0:8
@48@0:8@16@24@32Q40
@"NSFetchedResultsController"
@"_NSFaultingMutableSetMutationMethods"
v32@0:8@16q24
v40@0:8@16@24^{__CFBitVector=}32
@"NSSQLiteStatement"
@"NSSQLiteAdapter"
@"NSMutableString"
@32@0:8r^@16Q24
@32@0:8^@16I24I28
@40@0:8^@16I24I28@32
^@16@0:8
Q40@0:8@16{_NSRange=QQ}24
@32@0:8{_NSRange=QQ}16
v40@0:8^@16{_NSRange=QQ}24
v20@0:8B16
@"_PFWeakReference"
{_PFArrayFlags="shouldRetain"b1"shouldRelease"b1"useExtendedRelease"b1"freeBackingArray"b1"copyBackingArray"b1"managedObjects"b1"_RESERVED"b27}
@36@0:8{_NSRange=QQ}16B32
@32@0:8^?16^v24
@40@0:8^?16^v24@32
@24@0:8:16
@24@0:8@?16
@"_PFArray"
@"NSCachingFetchRequest"
{_PFBatchFaultingArrayFlags="_LRUIndex"b8"_uniformEntity"b1"_RESERVED"b23}
@40@0:8@16{_NSRange=QQ}24
^{__CFArray=}
r^@16@0:8
@32@0:8r^v16r*24
v24@0:8^v16
r*16@0:8
c16@0:8
C16@0:8
s16@0:8
S16@0:8
f16@0:8
d16@0:8
B24@0:8^@16
B32@0:8@16^@24
B24@0:8Q16
@"NSPredicate"
@"NSSQLEntity"
@"NSSQLAttribute"
@"NSSQLRelationship"
@20@0:8B16
Q24@0:8^@16
v28@0:8Q16I24
^{__CFDictionary=}
^^{__CFDictionary}
{_contextMapTableFlags="_usesWeakReferences"b1"_garbageCollectionEnabled"b1"_reservedFlags"b30}
@36@0:8^?16^v24i32
{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}
{_opaque_pthread_cond_t="__sig"q"__opaque"[40c]}
B40@0:8@16^@24^@32
@32@0:8@16@?24
B36@0:8r*16^Q24i32
^v24@0:8@16
v48@0:8@16^v24{_NSRange=QQ}32
q24@0:8r*16
B36@0:8r*16r*24i32
v24@0:8r*16
v28@0:8r*16i24
v40@0:8@16@24@32
v40@0:8^I16@24@32
@40@0:8@16@24Q32
@40@0:8#16@24@32
@40@0:8@16@24#32
^{__CFDictionary=}28@0:8@16B24
^{__CFDictionary=}24@0:8@16
^{_opaque_pthread_t=q^{__darwin_pthread_handler_rec}[8176c]}
S24@0:8Q16
v24@0:8^S16
v40@0:8^S16{_NSRange=QQ}24
r*20@0:8B16
v24@0:8*16
@32@0:8@16^@24
@40@0:8@16@24^@32
@48@0:8@16@24@32^@40
v24@0:8d16
@"NSURL"
@"NSManagedObjectID"
@40@0:8@16Q24@32
B36@0:8@16@24i32
q32@0:8@16@24
B48@0:8^@16@24@32^@40
v32@0:8*16Q24
v72@0:8@16@24@32@40@48@56@64
*16@0:8
#32@0:8@16@24
I28@0:8^@16I24
@32@0:8r*16Q24
q32@0:8*16q24
@24@0:8q16
@20@0:8I16
@"NSProgress"
@48@0:8@16@24@32@?40
@?16@0:8
v24@0:8@?16
@"NSAsynchronousFetchRequest"
@32@0:8^@16@24
@"NSEntityDescription"
^{_NSRange=QQ}
{__entityDescriptionFlags="_isAbstract"b1"_shouldValidateOnSave"b1"_isImmutable"b1"_isFlattened"b1"_skipValidation"b1"_hasPropertiesIndexedBySpotlight"b1"_hasPropertiesStoredInTruthFile"b1"_rangesAreInDataBlob"b1"_hasAttributesWithExternalDataReferences"b1"_hasNonstandardPrimitiveProperties"b2"_hasUniqueProperties"b1"_validationUniqueProperties"b1"_reservedEntityDescription"b19}
@40@0:8@16q24@32
^{_NSRange=QQ}16@0:8
Q36@0:8Q16@24B32
^v24@0:8Q16
^v16@0:8
v24@0:8q16
@"NSExpression"
{__entityMappingFlags="_isInUse"b1"_reservedEntityMapping"b31}
@"NSSQLModel"
@28@0:8I16d20
d24@0:8@16
v44@0:8@16@24I32d36
{_externalRefFlags_st="_invalidToOnes"b1"_hasTemporaryID"b1"_backgroundDealloc"b1"_reservedFlags"b1"_virtualfk_count"b14"_ordkey_count"b14}
@"NSPersistentStoreCoordinator"
@"NSFetchRequest"
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8@"Protocol"16
B24@0:8:16
^{_NSZone=}16@0:8
@36@0:8@16B24^@28
{_fetchRequestFlags="distinctValuesOnly"b1"includesSubentities"b1"includesPropertyValues"b1"resultType"b3"returnsObjectsAsFaults"b1"excludePendingChanges"b1"isInUse"b1"entityIsName"b1"refreshesRefetched"b1"propertiesValidated"b1"disableCaching"b1"_RESERVED"b19}
{_fetchExpressionFlags="isCountOnly"b1"_RESERVED"b31}
^{__CFArray=}32@0:8r^*16Q24
v32@0:8r^@16Q24
@32@0:8^@16Q24
@48@0:8^@16Q24^v32@40
@40@0:8^@16^@24Q32
@28@0:8@16B24
v28@0:8^@16B24
Q44@0:8^{?=Q^@^Q[5Q]}16^@24Q32B40
v32@0:8^@16^@24
@"NSKnownKeysMappingStrategy"
[0@]
@60@0:8r^@16@24r^@32{_NSRange=QQ}40B56
{_NSRange="location"Q"length"Q}
v40@0:8Q16@24@32
v40@0:8@16Q24@32
B40@0:8^@16@24^@32
@36@0:8^I16^I24B32
v32@0:8{_NSRange=QQ}16
v40@0:8@16@24Q32
@40@0:8@16q24q32
v48@0:8@16@24@32@40
v48@0:8@16@24Q32@40
v32@0:8@16^@24
@52@0:8i16@20@28@36@44
B56@0:8^@16@24@32Q40^@48
v72@0:8@16@24^@32^@40^@48^@56^@64
v28@0:8@16B24
@"NSObject<OS_dispatch_queue>"
B32@0:8^@16^@24
^?24@0:8:16
v48@0:8@16@24q32q40
^{?=i^v@QCQ^v@*{_moFactoryClassFlags=b1b1b1b1b1b1b26}}16@0:8
#24@0:8@16
I36@0:8^@16@24I32
@36@0:8@16@24I32
v48@0:8@16@24@32^v40
Q32@0:8@16^@24
B36@0:8@16B24@28
{_managedObjectContextFlags="_registeredForCallback"b1"_propagatesDeletesAtEndOfEvent"b1"_exhaustiveValidation"b1"_processingChanges"b1"_useCommittedSnapshot"b1"_registeredUndoTransactionID"b1"_retainsAllRegisteredObjects"b1"_savingInProgress"b1"_wasDisposed"b1"_unprocessedChangesPending"b1"_isDirty"b1"_ignoreUndoCheckpoints"b1"_propagatingDeletes"b1"_isNSEditorEditing"b1"_isMainThreadBlessed"b1"_isImportContext"b1"_preflightSaveInProgress"b1"_disableDiscardEditing"b1"_isParentStoreContext"b1"_postSaveNotifications"b1"_isMerging"b1"_concurrencyType"b1"_deleteInaccessible"b1"_priority"b2"_autoMerge"b1"_reservedFlags"b6}
Q48@0:8@16@24@32^@40
v32@0:8@16B24B28
v36@0:8^@16Q24B32
I48@0:8^@16I24^@28@36B44
v36@0:8@16@24B32
B44@0:8@16I24^@28B36B40
v28@0:8I16Q20
v40@0:8:16@24@32
v60@0:8@16@24@32@40@48B56
@32@0:8@16^#24
v32@0:8@16:24
v56@0:8@16@24:32B40^v44B52
v40@0:8@16:24^v32
v36@0:8@16B24^{?=@:^v}28
B24@0:8^{__CFArray=}16
^{__CFRunLoopObserver=}
@"NSKnownKeysDictionary"
{__managedObjectModelFlags="_isInUse"b1"_isImmutable"b1"_isOptimizedForEncoding"b1"_hasEntityWithConstraints"b1"_reservedEntityDescription"b28}
B40@0:8@16Q24@32
v28@0:8B16Q20
{?=[8I]}16@0:8
@"NSXPCStoreServerPerConnectionCache"
{?="val"[8I]}
@64@0:8{?=[8I]}16@48@56
@"NSXPCStoreConnectionInfo"
@"NSSQLitePrefetchRequestCache"
@"NSObject<OS_os_transaction>"
@"NSBundle"
@"NSPersistentStoreMap"
{__modelMappingFlags="_isInUse"b1"_reservedModelMapping"b31}
@36@0:8@16B24@28
Vv32@0:8@16@?24
Vv32@0:8@"NSCoreDataXPCMessage"16@?<v@?@"NSCoreDataXPCMessage"@"NSData">24
@"NSXPCStore"
@"NSXPCConnection"
@"NSObject<OS_dispatch_semaphore>"
@56@0:8@16Q24Q32@40@48
@64@0:8@16Q24Q32@40@48@56
B36@0:8@16@24B32
v52@0:8@16@24@32@40B48
D16@0:8
v32@0:8D16
@"PFUbiquityKnowledgeVector"
@"NSMigrationManager"
@"NSPropertyMapping"
B80@0:8@16@24@32@40@48@56@64^@72
@"NSMigrationContext"
{_migrationManagerFlags="_migrationWasCancelled"b1"_usesStoreSpecificMigrationManager"b1"_reservedMigrationManager"b30}
{_objectStoreFlags="isReadOnly"b1"cleanOnRemove"b1"isMDDirty"b1"_RESERVED"b29}
B56@0:8@16@24@32@40^@48
B56@0:8@16^B24^B32^@40@48
@28@0:8^v16B24
i24@0:8@16
v36@0:8@16@24I32
@32@0:8@16d24
v60@0:8@16@24@32@40I48d52
v56@0:8@16@24@32@40d48
@40@0:8@16@24d32
^{?=q^?^?^?^?}
{persistentStoreCacheFlags="_preserveToManyRelationships"b1"_reserved"b31}
v32@0:8#16@24
v32@0:8@?16@24
v32@0:8@16@?24
@56@0:8@16@24@32@40^@48
B64@0:8@16@24@32@40@48^@56
@32@0:8@16^i24
{_persistentStoreCoordinatorFlags="_isRegistered"b1"_canUseDirectDispatch"b1"_reservedFlags"b30}
@40@0:8r*16Q24^@32
B48@0:8@16@24^{__CFSet=}32^{__CFSet=}40
@24@0:8^Q16
@36@0:8i16@20@28
@"NSIndexPath"
@"_NSDefaultSectionInfo"
@"NSMappedObjectStore"
{__propertyDescriptionFlags="_isReadOnly"b1"_isTransient"b1"_isOptional"b1"_isIndexed"b1"_skipValidation"b1"_isIndexedBySpotlight"b1"_isStoredInExternalRecord"b1"_extraIvarsAreInDataBlob"b1"_isOrdered"b1"_hasMaxValueInExtraIvars"b1"_hasMinValueInExtraIvars"b1"_storeBinaryDataExternally"b1"_reservedAttributeFlagOne"b1"_reservedPropertyDescription"b3}
^{_NSExtraPropertyIVars=@qq}16@0:8
v64@0:8@16@24@32@40@48@56
@"NSEntityDescription"16@0:8
@"NSPredicate"16@0:8
{_requestFlags="includesSubentities"b1"resultType"b2"entityIsName"b1"_RESERVED"b28}
{__propertyMappingFlags="_isInUse"b1"_reservedPropertyMapping"b31}
@"NSPropertyTransform"
@"NSRelationshipDescription"
v40@0:8*16Q24@32
C32@0:8Q16Q24
@36@0:8@16C24@28
@40@0:8@16C24@28B36
@28@0:8q16C24
@24@0:8I16C20
@"NSAttributeDescription"
@28@0:8@16C24
v20@0:8C16
@44@0:8@16C24@28@36
B36@0:8@16C24@28
C24@0:8@16
v24@0:8@?<v@?@?<v@?>>16
v24@0:8@?<v@?@"NSError">16
v24@0:8@"NSURL"16
v24@0:8@"NSFileVersion"16
v32@0:8@"NSURL"16@?<v@?@"NSError">24
v32@0:8@"NSURL"16@"NSURL"24
v32@0:8@"NSURL"16@"NSFileVersion"24
@"NSURL"16@0:8
@"NSOperationQueue"16@0:8
^{_NSScalarObjectID=#}32@0:8@16q24
@32@0:8@16q24
^{_NSScalarObjectID=#}32@0:8q16@24
v52@0:8@16@24@32B40@44
v36@0:8B16@20@28
^{__CFArray=}24@0:8@16
B36@0:8@16B24^@28
@"NSSQLiteConnection"
@"NSSQLCoreDispatchManager"
@"NSGenerationalRowCache"
{_sqlCoreFlags="useSyntaxColoredLogging"b1"checkedExternalReferences"b1"fileProtectionType"b3"notifyFOKChanges"b1"initializationComplete"b1"connectionsAreLocal"b1"isXPCDelegate"b1"queryGenerationInitializationFailed"b1"_RESERVED"b22}
@"NSSQLCore"
I24@0:8@16
I28@0:8@16I24
{_NSRange=QQ}16@0:8
@"NSSQLPrimaryKey"
@"NSSQLEntityKey"
@"NSSQLOptLockKey"
@"NSSQLStoreMappingGenerator"
{__sqlentityFlags="_hasAttributesWithExternalDataReferences"b1"_hasAttributesMonitoredByTriggers"b1"_hasAttributesBackedByTriggers"b1"_reserved"b29}
@"NSSQLSelectIntermediate"
@"NSSQLGroupByIntermediate"
@"NSSQLHavingIntermediate"
@"NSSQLOffsetIntermediate"
@"NSSQLForeignKey"
@"NSSQLToOne"
v56@0:8@16@24@32^^Q40^*48
I48@0:8@16@24@32@40
I40@0:8@16@24@32
@112@0:8@16@24@32@40@48@56@64q72@80@88^^Q96^*104
v44@0:8@16@24d32B40
@"NSSQLSaveChangesRequestContext"
{_sqlSaveFlags="notifyFOKChanges"b1"hasChanges"b1"reserved"b30}
@32@0:8@16B24I28
@44@0:8@16B24I28B32@36
@48@0:8@16B24B28I32B36@40
@48@0:8@16@24^Q32^@40
@52@0:8@16B24@28^Q36^@44
@"NSXPCStoreConnection"
@"NSXPCStoreNotificationObserver"
@"NSGenerationToken"
v56@0:8@16@24@32d40@48
@"NSSQLIntermediate"
@20@0:8C16
@40@0:8@16@24^{__CFBitVector=}32
@36@0:8@16B24B28I32
B48@0:8@16^{__CFDictionary=}24^{__CFDictionary=}32^@40
@44@0:8@16@24@32B40
@48@0:8@16^{__CFDictionary=}24^{__CFDictionary=}32^@40
B56@0:8@16^{__CFDictionary=}24^{__CFDictionary=}32@40^@48
i44@0:8r*16^^{sqlite3}24i32r*36
i24@0:8r*16
r*24@0:8@16
v24@0:8i16B20
v32@0:8@16^{__CFBitVector=}24
@32@0:8@16^{__CFBitVector=}24
v48@0:8Q16Q24Q32Q40
@36@0:8@16I24^{sqlite3_stmt=}28
i32@0:8^v16@24
^{sqlite3_stmt=}16@0:8
q28@0:8@16I24
^^v16@0:8
v56@0:8r*16q24q32r*40q48
^{sqlite3=}
^{sqlite3_stmt=}
[5^v]
{__sqliteConnectionFlags="_readyToBind"b1"_fetchInProgress"b1"_fileSystemType"b2"_proxyLocking"b1"_vacuumSetupNeeded"b1"_usingWAL"b1"_disallowReconnect"b1"_isWriter"b1"_reserved"b23}
@40@0:8@?16@24@32
@52@0:8@16B24@28@36@44
@64@0:8@16@24@32@40@48@56
@60@0:8@16@24@32@40B48@52
@52@0:8@16@24B32^@36@44
@32@0:8Q16@24
@44@0:8@16@24B32Q36
@"NSPersistentStore"
@"NSSQLRowCache"
{?="principal_entity_has_subentities"b1"fetch_only_primary_keys"b1"fetch_results_style"b3"use_clean_memory"b1"_reserved"b26}
q48@0:8@16@24@32@40
@"NSXPCListener"
@"NSXPCStoreServerRequestHandlingPolicy"
@"NSMapTable"
@"NSXPCStoreServerNotificationManager"
v24@0:8@"NSPredicate"16
v24@0:8@"NSExpression"16
v24@0:8@"NSPredicateOperator"16
^{__CFDictionary=}16@0:8
v40@0:8@16@24^{__CFDictionary=}32
{_sqlColumnFlags="_allowAliasing"b1"_unique"b1"_constrained"b1"_backedByTrigger"b1"_reservedFlags"b12}
I52@0:8^@16I24@28^^{_NSScalarObjectID}36d44
@32@0:8@16^{_NSScalarObjectID=#}24
@40@0:8@16^{_NSScalarObjectID=#}24d32
^{_NSScalarObjectID=#}24@0:8@16
^{_NSScalarObjectID=#}16@0:8
v24@0:8^{_NSScalarObjectID=#}16
v28@0:8I16q20
v24@0:8I16I20
q20@0:8I16
I20@0:8I16
^{__CFBitVector=}32@0:8@16Q24
^{__CFBitVector=}24@0:8@16
^{__CFBitVector=}16@0:8
@"_CDSnapshot"
q24@0:8Q16
@32@0:8@16B24B28
@52@0:8@16@24B32B36B40@44
@32@0:8B16B20@24
v32@0:8^{sqlite3_stmt=}16@24
@"NSCachedFetchRequestInfo"
@32@0:8^S16Q24
@"NSSQLFetchIntermediate"
@"NSSQLColumn"
@"_PFFetchPlanHeader"
@"NSSQLFetchRequestContext"
@"NSSQLForeignEntityKey"
@"NSSQLForeignOrderKey"
@28@0:8@16i24
v56@0:8@16@24@32@40@48
@64@0:8@16@24@32@40@48^@56
@24@0:8*16
{_double_quad_uint="high64"Q"low64"Q}
@"_NS128bitWrapper"
@32@0:8@16^v24
q32@0:8@16q24
{_fetchResultsControllerFlags="_sendObjectChangeNotifications"b1"_sendSectionChangeNotifications"b1"_sendDidChangeContentNotifications"b1"_sendWillChangeContentNotifications"b1"_sendSectionIndexTitleForSectionName"b1"_changedResultsSinceLastSave"b1"_hasMutableFetchedResults"b1"_hasBatchedArrayResults"b1"_hasSections"b1"_usesNonpersistedProperties"b1"_includesSubentities"b1"_reservedFlags"b21}
Q24@0:8Q16
v32@0:8@16^q24
Q56@0:8@16@24q32q40@48
v24@0:8{_NSSQLMigrationContext=@}16
@32@0:8@16{_NSSQLMigrationContext=@}24
v32@0:8@16{_NSSQLMigrationContext=@}24
^{sqlite3_intarray=}16@0:8
v24@0:8^{sqlite3_intarray=}16
^{sqlite3_intarray=}
@"NSSQLUpdateColumnsIntermediate"
q40@0:8@16@24@32
v36@0:8@16@24i32
@52@0:8@16@24@32B40{_NSSQLMigrationContext=@}44
@"NSNumber"
@"NSSQLWhereIntermediate"
r^v16@0:8
v32@0:8^v16Q24
v40@0:8^v16{_NSRange=QQ}24
{_NSRange=QQ}48@0:8@16Q24{_NSRange=QQ}32
B40@0:8@16Q24^@32
B28@0:8@16B24
B20@0:8B16
@44@0:8@16@24@32i40
@52@0:8r^v16Q24@32@40i48
@60@0:8r^v16Q24@32@40i48@52
v24@0:8r^v16
{__externalDataFlags="_isStoredExternally"b1"_hasMappedData"b1"_cleanupOnDealloc"b1"_dataProtectionLevel"b3"_isStoredUbiquitously"b1"_createdByUbiquityImport"b1"_reserved"b24}
v48@0:8@16@24^^Q32^*40
v40@0:8r^@16Q24Q32
v48@0:8{_NSRange=QQ}16Q32@?40
{_NSFaultingMutableOrderedSetFlags="_isFault"b1"_mustPropagateDelete"b1"_ignoringIdempotentKVO"b1"_mustCopyOnWrite"b1"_isImmutableCopy"b1"_reserved"b11"_relationship"b16}
I36@0:8^@16I24^@28
{_snapshotFlags_st="_readOnly"b1"_reservedFlags"b7}
Q24@0:8@?16
Q56@0:8@16{_NSRange=QQ}24Q40@?48
v32@0:8Q16Q24
v40@0:8^@16Q24Q32
v48@0:8{_NSRange=QQ}16r^@32Q40
@"NSMutableOrderedSet"
@"_NSFaultingMutableOrderedSetMutationMethods"
@"NSPersistentStoreCache"
q48@0:8@"NSManagedObjectContext"16@"NSManagedObject"24@"NSManagedObjectID"32@"NSPropertyDescription"40
B44@0:8@16i24@28^@36
@"PFUbiquitySwitchboardEntry"
@"PFUbiquityImportContext"
@44@0:8@16i24@28@36
@"NSDate"
@"NSLock"
v32@0:8d16@?24
v24@0:8@"_PFUbiquityRecordImportOperation"16
v32@0:8@"_PFUbiquityRecordImportOperation"16@"NSError"24
v24@0:8@"PFUbiquityBaselineRollOperation"16
v32@0:8@"PFUbiquityBaselineRecoveryOperation"16@"PFUbiquityBaseline"24
v40@0:8@"PFUbiquityBaselineRecoveryOperation"16@"NSError"24@"PFUbiquityBaseline"32
v32@0:8@"PFUbiquityBaselineRollResponseOperation"16@"PFUbiquityBaseline"24
v40@0:8@"PFUbiquityBaselineRollResponseOperation"16@"NSError"24@"PFUbiquityBaseline"32
B28@0:8B16^@20
@"NSOperationQueue"
@"PFUbiquityRecordsImporterSchedulingContext"
@"PFUbiquitySwitchboardCacheWrapper"
@"NSObject<OS_dispatch_source>"
@"NSRecursiveLock"
@"PFUbiquityMetadataFactoryEntry"
@"NSPersistentStoreRequest"
@"NSException"
@36@0:8@16i24@28
B20@0:8i16
@20@0:8i16
v40@0:8@16@24@?32
v48@0:8@16@24@32@?40
i36@0:8i16@20^B28
B56@0:8@16@24@32I40I44^@48
B52@0:8@16@24B32^@36@?44
@"PFUbiquityFilePresenter"
@"PFUbiquityContainerMonitor"
@"PFUbiquitySwitchboardEntryMetadata"
@"PFUbiquitySetupAssistant"
@"_PFUbiquityRecordsImporter"
@"_PFUbiquityRecordsExporter"
@"PFUbiquityBaselineHeuristics"
@"NSSQLManyToMany"
v52@0:8@16Q24B32^@36@?44
B32@0:8@16^B24
B40@0:8@16q24q32
B72@0:8@16@24@32@40@48@56^@64
@28@0:8B16^@20
@"PFUbiquityBaselineMetadata"
@"_PFZipFileArchive"
@40@0:8Q16Q24@32
@48@0:8@16@24Q32@40
@72@0:8@16@24@32@40Q48@56Q64
@44@0:8@16i24@28^@36
@"PFUbiquityGlobalObjectIDCache"
B32@0:8^@16@24
@"PFUbiquitySaveSnapshot"
@"_PFUbiquityStack"
@"PFUbiquityStoreMetadata"
@"PFUbiquityPeer"
@44@0:8i16@20@28@36
@60@0:8i16@20@28@36@44@52
@"NSSQLLimitIntermediate"
@"NSSQLOrderIntermediate"
v28@0:8I16@20
v28@0:8S16@20
I32@0:8r*16^Q24
S32@0:8r*16^Q24
@40@0:8r*16^Q24Q32
@40@0:8@16Q24^@32
B48@0:8@16@24Q32^@40
B32@0:8r*16Q24
B40@0:8@16r^v24^@32
B36@0:8r*16I24@28
i24@0:8^@16
{__zFlags="providerSuppliesContents"b1"providerSuppliesStreams"b1"providerSuppliesProperties"b1"noContentsCaching"b1"fileOpen"b1"reserved"b27}
@"PFZipEndOfCentralDirectoryRecord"
Q32@0:8@16Q24
Q32@0:8r*16Q24
v20@0:8S16
@72@0:8@16@24Q32@40@48^@56^@64
@"NSObject"
B48@0:8@16^B24@32^@40
@40@0:8@16@24^B32
B36@0:8B16@20^@28
@"<NSObject><NSCopying><NSCoding>"
@"PFUbiquityPeerState"
@"PFUbiquityBaseline"
@"PFUbiquityPeerReceipt"
@"PFUbiquityContainerIdentifier"
@"PFUbiquityMigrationAssistant"
@"PFUbiquityMigrationManager"
Q40@0:8@16@24Q32
@40@0:8@16q24^@32
@64@0:8@16Q24B32B36@40@48@56
@56@0:8@16@24@32B40B44Q48
@"PFUbiquityMetadataFactoryFilePresenter"
@"PFUbiquityGlobalObjectID"
@40@0:8Q16@24@32
@"PFUbiquityPeerRangeCache"
@"PFUbiquityTransactionLogCache"
@"PFUbiquityTransactionHistoryCache"
B32@0:8B16B20^@24
333333
@@(#)PROGRAM:CoreData  PROJECT:PersistenceFramework-753
%{public}s: %{public}s
CoreData: %{public}s: %{public}s
