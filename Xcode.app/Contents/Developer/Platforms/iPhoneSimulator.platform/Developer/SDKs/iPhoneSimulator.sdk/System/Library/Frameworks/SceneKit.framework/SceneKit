x?333333
bplist
0E333333
MbP?
zC(kn
(knN
>333?
>fff?
MbP?V
?333333
VUU
VUU
i\)7.
blnOq
sy2-
i\)7.
blnOq
sy2-
KTX 11
Mb`?
Ga==
MAa[
8?Sx
tWxCE
fff@
>fff?
?ffffff
fff?
?333?
?333?
fff@
v36@?0c8q12*20q28
v140@?0{__C3DShapeVertex={CGPoint=dd}{CGPoint=dd}{CGPoint=dd}{CGPoint=dd}dBi}8{CGPoint=dd}88f104{CGPoint=dd}108{CGPoint=dd}124
C3DFXStereoscopyTechnique_3DDisplay_SideBySide.json
C3DFXStereoscopyTechnique_3DDisplay_TopBottom.json
interaxialDistance
Td,N
displayLayout
Tq,R,N
C3DFXStereoscopyTechnique_Hmd.json
inputScale
outputScale
lensCenterOffset
hmdWarpParam
barrelDistortionInputScale
barrelDistortionOutputScale
barrelDistortionLensCenter
T{CGPoint=dd},N
barrelDistortionWarpCoefficients
T{SCNVector4=ffff},N
v8@?0
v32@?0@8@16^B24
C3DKeyValueStore
<C3DKeyValueStore>
triggerOptionsForRealtimeViewer
kSceneSourceMaximumMemoryForImages
kSceneSourceAutoLimitMemoryForImages
kSceneSourceCreateNewLibrary
kSceneSourceInvertMaterialOpacity
kSceneSourceCreateCameraIfAbsent
kSceneSourceCreateLightIfAbsent
kSceneSourceCreateNormalsIfAbsent
kSceneSourceAdjustInvalidClippingPlanes
kSceneSourceFlattenScene
kSceneSourceSplitMeshesForGLES
kSceneSourcePreloadImages
kSceneSourceBakeKeyframing
kSceneSourceConvertToYUpIfNeeded
kSceneSourceConvertToUnit
kSceneSourceAnimationLoadingMode
keepSeparate
playRepeatedly
playOnce
playUsingSceneTime
kSceneSourceCleanupMeshes
kSceneSourceRemoveConstantAnimations
kSceneSourceRemoveAllLights
kSceneSourceRemoveColorArrays
kSceneSourceInterleaveSources
kSceneSourceMakeSourcesCheaper
kSceneSourceSkipConsistencyCheck
kSceneSourceCheckConsistency
kC3DIOSceneSourceWasExportedBySceneKit
kSceneSourceUseSafeMode
kSceneSourceAssetDirectoryURLs
kSceneSourceOverrideAssetURLs
kSceneSourceStrictConformanceKey
kSceneSourceVerboseMode
kSceneSourceFormatHint
kSceneSourceProcessIsSandboxed
kSceneSourceSkipSandboxValidation
kSceneSourceSkipImagePathResolution
contributors
created
modified
up_axis
unit
authoring_tool
author
unitName
unitMeter
com.apple.SceneKit
kEnclosingDirectoryURL
file
Collada is not supported by this version of SceneKit
Unknown or missing file
Could not load the scene
The document does not appear to be a valid COLLADA file. Please check that is has not been corrupted.
The document does not appear to be valid. Please re-create it from your original COLLADA assets.
C3DSceneSource
<C3DSceneSource >
uniform 
.<>?:/|&^*/+-=%!~
Symbol
String
Number
Operator
AssignementOperator
OpenParent
CloseParent
OpenBracket
CloseBracket
OpenSBracket
CloseSBracket
Comments
Comma
SemiColon
Blank
NewLine
MacroHash
float2
vec3
float3
float4
ivec2
int2
ivec3
int3
ivec4
int4
uvec2
uint2
uvec3
uint3
uvec4
uint4
mat2
float2x2
mat3
float3x3
mat4
mat2x4
float2x4
mat3x2
float3x2
mat3x3
mat4x2
float4x2
mat3x4
float3x4
u_time
scn_frame.time
u_viewTransform
scn_frame.viewTransform
u_inverseViewTransform
scn_frame.inverseViewTransform
u_projectionTransform
scn_frame.projectionTransform
u_inverseProjectionTransform
scn_frame.inverseProjectionTransform
u_cameraPosition
scn_frame.cameraPosition
u_viewToCubeWorld
scn_frame.viewToCubeWorld
u_inverseResolution
scn_frame.inverseResolution
u_modelTransform
scn_node.modelTransform
u_inverseModelTransform
scn_node.inverseModelTransform
u_modelViewTransform
scn_node.modelViewTransform
u_inverseModelViewTransform
scn_node.inverseModelViewTransform
u_normalTransform
scn_node.normalTransform
u_modelViewProjectionTransform
scn_node.modelViewProjectionTransform
u_inverseModelViewProjectionTransform
scn_node.inverseModelViewProjectionTransform
u_boundingBox
scn_node.boundingBox
u_worldBoundingBox
scn_node.worldBoundingBox
texture1d
sampler2D
texture2d
sampler3D
texture3d
texturecube
discard
discard_fragment()
gl_FragCoord
in.fragmentPosition
gl_FragColor
_output.color
texture1D
filter::linear
texture1DProj
texture1DLod
texture1DProjLod
texture2D
texture2DLod
textureLod
texture2DProj
texture2DProjLod
texture3D
texture3DProj
texture3DLod
texture3DProjLod
textureCube
textureCubeLod
shadow1D
shadow1DProj
shadow1DLod
shadow1DProjLod
shadow2D
shadow2DProj
shadow2DLod
shadow2DProjLod
GetGLSLToMetalSampler
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Engine/AppleEngine/C3DShaderConverter.mm
it != mpStatics->mTextureFunc.end()
uniform
ParseUniform
mToken.mString == "uniform"
pragma
arguments
declaration
body
const
constant
Parse
mpTokenizer == nullptr
#pragma arguments
#pragma body
#pragma declaration
.sample(
Sampler
, level(
, bias(
float2(
float3(
float4(
sampler 
Sampler
_hide
C3DParticleSystemInstance
<C3DParticleSystemInstanceRef>
<%@:%p "%@"
  mesh: %@
  mat%d: %@
bindInfos
name
type
address
semantic
mesh
overrideMaterial
materials
levelsOfDetail
SceneID
C3DGeometry
unknown
aoCoord
lightmapCoord
bitangent
blendShape%d
normal%d
textureCoordinate%d
color%d
ambient
diffuse
specular
reflective
opacity
metalness
roughness
transform
AO_%@_%@.png
@"NSString"16@?0@"SCNNode"8
v32@?0@"SCNNode"8@"SCNGeometry"16@"NSArray"24
aoTexture
lightmapTexture
/tmp/ModelKit_AO_%@.png
xFov
yFov
focalDistance
fstop
SCNSceneKitAssociatedObject
Color
Texture
C3DMeshElement
<C3DMeshElement %p type:%@ primCount:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>
triangles
triangleStrip
lines
points
polygons
triangleFan
invalid
doubleSided
linesArray
trianglesArray
pointsArray
trianglesStrip
polygonsArray
indexes
subElementsCount
bytesPerIndex
primitiveNormals
bbox[0]
bbox[1]
__writeIndexInBuffer
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Core/C3DMeshElement.c
(index + 1) * bytesPerIndex <= dataLength
__readIndexInBuffer
%@-splitContainer
splitContainer
B8@?0
q16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}8
B16@?0@?<v@?>8
C3DGetResidentMeshElement
v16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}8
v28@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8c16q20
default camera
Kernel debug
SceneKit
Compressed Intervals (count:%d|emptyspan:%ld|sources:%ld) = [%ld] (used:%d%%/real:%d%%) (min:%d|max%d|avg:%d)
%@-split%d
v20@?0^I8I16
v16@?0d8
scene
T^{__C3DScene=},R,V_scene
customAudioNode
TB,R,V_customAudioNode
completed
TB,V_completed
audioPlayer
T@"AVAudioPlayerNode",R,V_audioPlayer
willStartPlayback
T@?,C,N,VwillStartPlayback
didFinishPlayback
T@?,C,N,VdidFinishPlayback
audioNode
T@"AVAudioNode",R,N,V_audioNode
audioSource
T@"SCNAudioSource",R,N,V_audioSource
caff
aiff
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DKit/classes/SCNAudioSource.m
<Unknown File>
Error reading file into buffer, %@
volume
rate
reverbBlend
positional
loops
shouldStream
supportsSecureCoding
TB,R
TB,N,GisPositional,Vpositional
Tf,N,Vvolume
Tf,N,Vrate
Tf,N,VreverbBlend
TB,N,V_loops
TB,N,V_shouldStream
v32@?0@"SCNRenderTarget"8Q16^B24
v32@?0@8@"NSMutableArray"16^B24
v32@?0@8@"NSArray"16^B24
numberOfRenderTargets
C3DHitTestResult
<C3DHitTestResult>
C3DListNode
<C3DListNode %p>
C3DList
<C3DList %p: head %p, tail %p, %ld objects>
halfExtent
strength
falloffExponent
minimumDistance
active
scope
usesEllipsoidalExtent
exclusive
offset
TB,N,GisActive
TB,N,GisExclusive
T{SCNVector3=fff},N
TB,N
Tq,N
direction
categoryBitMask
TQ,N
block
smoothness
animationSpeed
v24@?0^{__C3DNode=}8^B16
C3DFXFloorPass.plist
SceneKit_renderMirroredScene
SceneKit_renderFloor
u_floorNormal
u_floorTangent
u_floorCenter
u_floorExtent
u_floor_viewport
u_floorReflectivity
u_floorFalloffStart
u_floorFalloff
u_floorPlane
u_floorMVP_i
FloorGeomImpl.glsl
FloorGeomImpl-metal.h
USE_FALLOFF
USE_FALLOFF_START
USE_TRANSPARENCY
FloorImpl.glsl
FloorImpl-metal.h
com.apple.scenekit.jitteringUpdateQueue
enabled
TB,N,GisEnabled
C3DStack
<C3DStack>
C3DTransforms
<C3DTransforms>
matrix
scale
quaternion
axisAngle
euler
pivot
pivot_combinedMatrix
matrix4x4
position
rotation
bodyA
bodyB
axisA
axisB
anchorA
anchorB
T@"SCNPhysicsBody",R,N
C3DTransformsStack
<C3DTransformsStack>
v20@?0S8r^(C3DMatrix4x4=[16f][4])12
v32@?0@8Q16^B24
_prepareSnapToAlignDataForAxis - unexpected axis
B24@?0@"SCNNode"8^B16
authoringEnvironment
T@"SCNAuthoringEnvironment",R
T{SCNMatrix4=ffffffffffffffff},R
targets
T@"NSOrderedSet",&,N
target
T@"SCNNode",&,N
xAlignment
Tq,N,V_xAlignment
yAlignment
Tq,N,V_yAlignment
zAlignment
Tq,N,V_zAlignment
readonly
TB,N,V_readonly
location
initFromPath
relativePath
runtimePath
geometryData
mappingChannelsCount
mappingCountChannel0
vertexCount
componentsPerValue
componentsType
valuesCount
data
kGeometrySourceSemanticVertex
kGeometrySourceSemanticNormal
kGeometrySourceSemanticColor
kGeometrySourceSemanticTexcoord
stride
padding
sourceID
sourceTypeID
vertex
normal
color
texcoord
textangent
texbinormal
joints
weights
vertexArrayID
elementsID
commonProfile
Apple Engine
geometryID
materialsID
facesCount
kAnimationsKey
kBindingsKey
kActionsKey
kLightKey
kSkinnerKey
kMorpherKey
kCameraKey
kSplineKey
kConstraints
kParticleSystem
kAudioPlayer
kLightmapInfoKey
kRenderingPriorityKey
kShaderModifiers
kPivotKey
libraryStorage
kMeshKey
rendererDelegate
kFilterKey
kTechniqueKey
kFloorPass
geometry
geometryElement
geometryElements
geometryVertexArray
geometrySource
genericSource
node
material
effect
image
keyframedAnimations
animation
camera
light
skin
morph
linear
easeIn
easeOut
easeInEaseOut
default
kSupportsWrapModes
kTextureUnit
function
avoidsOverlighting
double sided
cullMode
cullBack
cullFront
lambert
phong
blinn
physicallyBased
emission
transparent
filter
ambientOcclusion
selfIllumination
emissionColor
ambientColor
diffuseColor
specularColor
reflectiveColor
transparentColor
normalColor
filterColor
emissionImageID
ambientImageID
diffuseImageID
specularImageID
reflectiveImageID
transparentImageID
filterImageID
normalImageID
shininessImageID
emissionTextureSampler
ambientTextureSampler
diffuseTextureSampler
specularTextureSampler
reflectiveTextureSampler
transparentTextureSampler
filterTextureSampler
normalTextureSampler
shininessTextureSampler
emissionUVSet
ambientUVSet
diffuseUVSet
specularUVSet
reflectiveUVSet
transparentUVSet
normalUVSet
filterUVSet
shininessUVSet
ambientOcclusionUVSet
selfIlluminationUVSet
metalnessUVSet
roughnessUVSet
shininess
reflectivity
transparency
indexOfRefraction
fresnelExponent
transparencyMode
A_ONE
RGB_ZERO
minFilter
magFilter
mipFilter
wrapS
wrapT
wrapP
imageType
textureType
anisotropy
SCNKitErrorDomain
mipmaping
env-mapping
SMAA
SSAO
SSAOParameters
frustumCulling
defaultLight
defaultCamera
probeRendering
pointOfView
rootNode
mirrorNode
floorNode
doClear
noJittering
renderInColorBuffer
frameHistoryCount
ignoreInfiniteFloor
combineRGBParameter
factor
mult
multfloat
pass-program
programName
kHitTestFirstFoundOnly
kHitTestSortResults
kHitTestClipToZRange
kHitTestSkipTransparentNode
kHitTestSkipHiddenNode
kHitTestCategoryBitMask
kHitTestBackFaceCulling
kHitTestBoundingBoxOnly
kHitTestIgnoreChildNodes
kHitTestRootNode
kHitTestAllLayers
kNotificationMeshSourceWillDie
kNotificationMeshElementWillDie
kNotificationImageWillDie
kNotificationImageProxyWillDie
kNotificationTextureSamplerWillDie
kNotificationProgramWillDie
kNotificationGeometryWillDie
kNotificationMorphWillDie
kNotificationMaterialWillDie
kNotificationMeshWillDie
kNotificationNodeWillDie
kNotificationPassWillDie
kC3DNotificationEngineContextInvalidatePasses
kC3DNotificationEngineContextPassesDidUpdate
kNotificationProfileWillDie
kNotificationProfileDidDie
kNotificationEntityAttributeDidChange
kNotificationRendererElementWillDie
kC3DSceneDidUpdateNotification
hidden
attributes
translation
filters
focalBlurRadius
focalSize
aperture
orthographicScale
zFar
projectionTransform
zNear
firstMaterial
selfIlluminationOcclusion
multiply
litPerPixel
lockAmbientWithDiffuse
texture
contentsTransform
borderColor
intensity
shadowColor
shadowRadius
gobo
attenuationStart
attenuationEnd
attenuationFalloffExponent
spotInnerAngle
spotOuterAngle
spotFalloffExponent
morpher
shaderModifiers
background
environment
customProperty
animations
influenceFactor
targetPosition
a_position
a_normal
a_tangent
a_color
a_skinningJoints
a_skinningWeights
a_texCoord0
a_texCoord1
a_texCoord2
a_texCoord3
a_texCoord4
a_texCoord5
a_texCoord6
a_texCoord7
<%@: %p
 '%@'
 point(%f %f %f)
 normal(%f %f %f)
 impulse(%f)
 distance:%f
nodeA
T@"SCNNode",R,N
nodeB
contactPoint
T{SCNVector3=fff},R,N
contactNormal
collisionImpulse
Td,R,N
penetrationDistance
%f %f %f
%f %f %f %f
vertexCrease
edgeCrease
v[%d] : %d,%d,%d,%d
type debugging not implemented
C3DMeshSource
<C3DMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%d stride:%d
mkSemantic
accessor
C3D-GaussianBlur
#define unshareIndex %d
#define MAX_SAMPLE %d
#define COMPONENT %c
GaussianBlur_vert
GaussianBlur_frag
C3D-blur-radiusH
C3D-blur-radiusV
C3D-blur-offsets
C3D-blur-weights
C3D-blur-samples
B32@?0@8Q16^B24
C3DAnimationManager
<C3DAnimationManager>
%p-%d
C3DKeyframeController
<C3DKeyframeController>
keyframeVersion
keyframeType
keyCount
keyframes
keytimes
keytimes-data
values
values-data
timingFunctions
timingFunctions-data
interpolationModes
interpolationModes-data
tensionValues
tensionValues-data
continuityValues
continuityValues-data
biasValues
biasValues-data
inTangents
inTangents-data
outTangents
outTangents-data
interpolationMode
calculationMode
0.12
SCNAction: Run block actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
SCNAction: Run block actions can not be properly decoded, Objective-C blocks do not support NSSecureCoding.
Format: %@ ; Size: %gx%g ; Texture: <%p> ; [rc:%ld/ts:%ld]
Name: %@ ; %@
T@,&,N,V_texture
T@"NSString",C,N,V_name
referenceCount
Tq,N,V_referenceCount
timeStamp
Tq,N,V_timeStamp
viewportDependant
TB,R,N
renderBufferFormat
TC,R,N
C3DTimingFunction
<C3DTimingFunction>
C3DFXDefaultPass
sequence
passes
symbols
depth
stereoscopy
relativeViewportsAffectAspectRatio
leftEyeRelativeViewport
%f %f %f %f
rightEyeRelativeViewport
program
metalLibraryFile
metalVertexShader
metalFragmentShader
clientProgram
inputs
owners
outputs
COLOR
SceneKit_stereo-leftColor
SceneKit_stereo-rightColor
SceneKit_stereoLeftEye
SceneKit_stereoRightEye
C3DFXDefaultPass.plist
C3DFXDeferredShadingDefaultPass.plist
C3DFXTechnique
<C3DFXTechnique>
pass %d
plist
self
C3DAnimationStack
<C3DAnimationStack>
_audioSource
_wait
C3DKeyframedAnimation
<C3DKeyframedAnimation>
keyframeController
keyframedAnimation
failed to load technique from dictionary: %@
animations.%@.speed
description
valueForSymbol
hash
TQ,R
superclass
T#,R
T@"NSString",R,C
debugDescription
animationKeys
T@"NSArray",R
dictionaryRepresentation
T@"NSDictionary",R
C3DAnimationNode
<C3DAnimationNode %p>
SceneKit-CI-nodetree-color-
SceneKit-CI-effect-color-
SceneKit_renderCINodeTree-
SceneKit-CI-nodetree-depth
SceneKit_ApplyCIFilter
SceneKit_renderCIQuad
C3D-CIFilter_middleZ
C3D-CIFilter_extent
SceneKit-CI-nodetree-color
SceneKit-CI-effect-color
SceneKit_renderCINodeTree
^{__CFString=}16@?0^{__CFString=}8
C3DFXCIFilterPassMetal.json
C3DFXCIFilterPass.json
NSNumber
CICrop
inputRectangle
C3D-CIFilter_modelMatrix
C3DDelegatedAnimation
<C3DDelegatedAnimation>
delegatedAnimation
WireFrame
u_color
u_transform
SCNPhysicsShapeTypeKey
SCNPhysicsShapeKeepAsCompoundKey
SCNPhysicsShapeScaleKey
SCNPhysicsShapeCollisionMarginKey
boundingBox
convexHull
concaveMesh
convexDecomposition
v32@?0@"SCNPhysicsShape"8Q16^B24
q16@?0^{__C3DNode=}8
transformsCount
transform%d
referenceObject
options
T@"NSDictionary",R,N
sourceObject
T@,R,N,V_referenceObject
transforms
T@"NSArray",R,N
physicsShape[%f,%f,%f]
physicsShape
SCNDefaultPhysicsShape
btTriangleInfoData
btTriangleInfoMapData
isAttachment
C3DImage
<C3DImage src:%@ [%fx%f]>
<C3DImage src:%p [%fx%f]>
imageData
imageRelativePath
distantImageURL
cgImage
clientImage
bitmap
hasAlpha
size
pvrtc
minificationFilter
magnificationFilter
maxAnisotropy
C3DTextureSampler
<C3DTextureSampler>
nearest
clamp
repeat
clampToBorder
Resource Manager Flush
C3D-EnvMap2D
textureSampler0
u_textureMatrix
C3D-EnvMapCube
u_mvp
u_zfar
C3DEngineContext
<C3DEngineContext>
velocity
jumpSpeed
draw :%4d vertices:%8d primitives:%8d
program   count:%4d memory:%8d Kb
vbuffer   count:%4d memory:%8d Kb
ibuffer   count:%4d memory:%8d Kb
cbuffer   count:%4d memory:%8d Kb
texture   count:%4d memory:%8d Kb
C3DGeometryOsdGetCPUSubdividedC3DMesh
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Core/C3DGeometryOpenSubdivSupport.cpp
vertexCountPerFaceCurrentIndex == context.topologyDescriptor.numFaces
vertIndicesPerFaceCurrentIndex == totalIndexCount
currentIndex == totalIndexCount
faceVertexIndices.size() == 4
Interpolate
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/far/primvarRefiner.h
level>0 and level<=(int)_refiner._refinements.size()
interpFromEdges
refinement.getNumChildVerticesFromFaces() > 0
Vtr::IndexIsValid(cVertOfFace)
interpFromVerts
vMask.AreFaceWeightsForFaceCenters()
assignSmoothMaskForVertex
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/far/../sdc/catmarkScheme.h
vertex.GetNumFaces() == vertex.GetNumEdges()
CombineVertexVertexMasks
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/far/../sdc/../sdc/scheme.h
this->AreFaceWeightsForFaceCenters() == dst.AreFaceWeightsForFaceCenters()
InterpolateVarying
InterpolateFaceVarying
interpFVarFromEdges
eFaceIndex == i
interpFVarFromVerts
pSibling == cSibling
CreateMeshSources
faceVaryingVertexIndices.size() == 4
faceVertexCount == 4
_CreateMeshSourceForSource
Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.
limit
tan1Mask.GetNumFaceWeights() == tan2Mask.GetNumFaceWeights()
tan1Mask.GetNumEdgeWeights() == tan2Mask.GetNumEdgeWeights()
assignSmoothLimitMask
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/far/../sdc/loopScheme.h
valence != 2
C3DRendererElementState
<C3DRendererElementState>
v24@?0^{__CFString=}8^v16
uv_set
Reset all states
%02x
v16@?0^{__C3DRenderTarget={__CFRuntimeBase=Q[4C]I}{?=CCCb1b1b1b1b1[4C]}^{__C3DTexture}Iq^vQIII}8
v24@?0q8r^v16
C3DRendererContext
<C3DRendererContext>
v24@?0C8^{__CFArray=}12I20
v20@?0I8r*12
v20@?0C8r*12
__drawCall
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Engine/AppleEngine/OpenGL/C3DRendererContextGL.c
ParticleSystem_MeshElement
C3D-ParticleSystem_Trail
C3D-ParticleSystem
C3D-ParticleSystem_PointSprite
%@%1d%c%c%c%c%c%c%c%1dO%1d%c
C3D-Particles.metal
ENABLE_LIGHTING
ENABLE_COLOR_RAMP
ENABLE_CUBE_MAP
ENABLE_STRETCH
ENABLE_BILLBOARD_VIEW
ENABLE_ORIENTATION_FREE
ENABLE_BILLBOARD_Y
ENABLE_FOG
ENABLE_ANIMATION
ENABLE_SOFT
particle_vert
particle_frag
.vsh
.fsh
precision highp float;
precision mediump float;
#define ENABLE_LIGHTING
#define ENABLE_COLOR_RAMP
#define ENABLE_CUBE_MAP
#define ENABLE_STRETCH
#define ENABLE_BILLBOARD_VIEW
#define ENABLE_ORIENTATION_FREE
#define ENABLE_BILLBOARD_Y
#define ENABLE_BILLBOARD_SCREEN
#define ENABLE_FOG
#define ENABLE_ANIMATION %d
#define ENABLE_SOFT
BlackPass
viewTransform
u_fresnelExponent
u_lightPosition0
u_lightColor0
u_colorRamp
u_stretchFactor
u_frameSize
u_softParameters
u_invProj
u_depthSampler0
u_fogParameters
u_fogColor
u_textureSampler0
C3DParticleManager
<C3DParticleManagerRef>
C3DFXJitteringPass.plist
SceneKit_JitterCopyFirstFrame
SceneKit_JitterToEven
SceneKit_JitterToOdd
SceneKit_JitterResolve
Copy_vert
Copy_frag
C3D-Copy
C3D-jitter-factor
IncrementalAverage_vert
IncrementalAverage_frag
C3D-IncrementalAverage
C3DBufferObject
<C3DBufferObject vbo:%ld  addr:0x%x lockCount:%d target:%d retainCount:%d>
block:%p offset:%d size:%d used:%d
free block:%p offset:%d size:%d used:%d
C3DCustomAllocator
<C3DCustomAllocator>
** dump allocator **
all blocks following head
free list ordered by size
C3DCustomAllocatorGroup
<C3DCustomAllocatorGroup>
referenceRoot
<%@: %p url=%@>
referenceURL
loadingPolicy
T@"NSURL",C,N
Tq,N,V_loadingPolicy
loaded
TB,R,GisLoaded
referenceSceneName
T@"NSString",C,N,VreferenceSceneName
referenceNodeName
T@"NSString",C,N,VreferenceNodeName
referenceName
repeatCount
repeatDuration
usesSceneTimeBase
T@"NSString",C,N,VreferenceName
SCNReferenceLoadingStack
rgba16f
rgba32f
r16f
rg16
rg16f
rgba
framebufferColor
depth24
depth24stencil8
C3DFramebuffer
slot%d: %@ 
<C3DFramebuffer %p: color=%@ - depth=%@ color-samples=%d depth-samples=%d renderTargets:%@>
C3DMeshPacker
<C3DMeshPacker>
C3DRectanglePacker
<C3DRectanglePacker>
com.apple.scenekit.resourceManagerDeletionQueue
C3DResourceManager
<C3DResourceManager>
kResourceManagerPendingMeshElementRemoval
kResourceManagerPendingImageRemoval
kResourceManagerPendingImageProxyRemoval
kResourceManagerPendingProgramRemoval
kResourceManagerPendingMeshRemoval
kResourceManagerPendingMeshSourceRemoval
C3DTexture
<C3DTexture>
C3DTexturePacker
<C3DTexturePacker>
C3DImageProxy
<C3DImageProxy>
C3DTextureProxy
<C3DTextureProxy>
-[NSData(SCNExtensions) scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DKit/utils/NSData+SCNExtensions.m
-[NSData(SCNExtensions) scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataEncodingDeltaWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataDecodingDeltaWithBytesPerIndex:]
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}8^{__C3DLightRuntimeData=If(C3DMatrix4x4=[16f][4])^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}16
C3DEnginePipeline
<C3DEnginePipeline %p>
C3DFXProgramDelegate
<C3DFXProgramDelegate %p>
SCN_ENABLE_COLLECTION
scenekit.fps
scenekit.primcnt
scenekit.frmtime
scenekit.phytime
scenekit.prttime
scenekit.animtime
scenekit.clientTime
scenekit.consttime
scenekit.rendertime
scenekit.cpuidletime
scenekit.cawaittime
scenekit.deviceutil
scenekit.rendererutil
scenekit.tilerutil
IOAcceleratorES
PerformanceStatistics
__scnPerformanceData
v24@?0{_CSTypeRef=QQ}8
Device Utilization %
Renderer Utilization %
Tiler Utilization %
none
float
bool
char
double
C3DFloat
float4x4
color4
short
half
uchar
ushort
ucharn
charn
10a2n
u10a2n
uchar4
char4
uchar4n
char4n
ushort2
ushort3
ushort4
shorn
short2
short3
short4
ushortn
ushort2n
ushort3n
ushort4n
short2n
short3n
short4n
half2
half3
half4
#ext
define
undef
ifndef
ifdef
else
elif
endif
hw.optional.sse2
hw.optional.sse3
hw.optional.supplementalsse3
hw.optional.sse4_1
hw.optional.sse4_2
hw.optional.avx1_0
hw.optional.fma
internalSettings
com.apple.scenekit
forceGLES
forceMetal
showsStatistics
cameraControlEnabled
batchMaxCount
disableLinearSpaceRendering
disableWideGamut
enablePostMorphUnifyNormals
com.apple.sceneKit.isolateCacheMissShader
SCNDisableLinearSpaceRendering
SCNDisableWideGamut
SKESceneDocument
sampler1D
samplerCube
vec2
vec4
mat44
#define %@ %@
defined
wrong syntax : defined() with no token
wrong syntax : unknown token
parsing error : extra parenthesis found
parsing error : parenthesis mismatch
C3DFXShader
<C3DFXShader %@>
source
stage
C3DLightProbesSystem
<C3DLightProbesSystem %p>
C3DEffectPropertyGetSemanticForColorIsRawFloatValue
C3DEffectCommonProfile
<C3DCommonProfileEffect %p : 
lightingModel : %d
perPixelLit : %d
isOpaque : %d
transparencyMode : %d
Emission
Ambient
Diffuse
Specular
Reflective
Transparent
Filter
Normal
Shininess
Reflectivity
Transparency
Fresnel
[%@] texture:%d xform:%d
versionNumber
ambientIntensity
diffuseIntensity
specularIntensity
emissionIntensity
multiplyIntensity
transparentIntensity
normalIntensity
ambientOcclusionIntensity
selfIlluminationIntensity
reflectiveIntensity
locksAmbientWithDiffuse
Intensity
lightingModel
imagesCount
effectProperty
C3DEffectSlot
<C3DEffectSlot>
sampler
mtltexture
imageProxy
uvSet
_target
_selector
threshold
thresholdType
C3DLOD
<C3DLOD>
C3DSpline
<C3DSpline %p>
_duration
_timingMode
_beginTime
_pausedTime
_isRunning
_finished
duration
timingMode
timingFunction
T@?,N
speed
T{SCNVector3=fff},N,Vposition
T{SCNVector3=fff},N,Veuler
T{SCNVector3=fff},N,Vscale
T{SCNVector4=ffff},N,Vrotation
usesEuler
TB,N,VusesEuler
Tf,N,Vopacity
SCNActionCacheKey
T@"SKScene",&,N,V_scene
C3DEdgeArray
<C3DEdgeArray>
C3DTriangulationInfo
<C3DTriangulationInfo>
C3DMeshElementEditor
<C3DMeshElementEditor>
script
JSContext
elapsedTime
viewport
T@"SCNNode",&,N,Vnode
component
T@,&,N,Vcomponent
elementIndex
TQ,N,VelementIndex
T{SCNMatrix4=ffffffffffffffff},N
elementPosition
C3DIndexSet
indexSet 
(no index)
[number of indexes: %lu (in %lu ranges), indexes: (
-%lu
mass
charge
friction
restitution
rollingFriction
damping
angularVelocity
angularDamping
velocityFactor
angularVelocityFactor
ignoreGravity
explicitMomentOfInertia
momentOfInertia
collisionBitMask
contactTestBitMask
allowsResting
isDefaultShape
usesDefaultMomentOfInertia
T@"SCNPhysicsShape",&,N
isResting
affectedByGravity
TB,N,GisAffectedByGravity
autoreverses
additive
cumulative
isAnimationClip
removeOnCompletion
sceneTimeBased
fillModeMask
timeOffset
beginTime
fadeInDuration
fadeOutDuration
simpleAnimation
C3DAnimation
<C3DAnimation>
C3DSimpleAnimation
<C3DSimpleAnimation>
baseType
startValue
byValue
endValue
C3DLightAddLightSHContribution
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Core/C3DLight.c
C3DLight
<C3DLight %p> type:%d IES:%d
attenuationEndDistance
attenuationStartDistance
shadowBias
temperature
property3
property4
castShadow
znear
zfar
shadowSoftenFactor
category
shadowMapSize
directionalExtent
shadowMaxSampleCount
sh_eval_direction
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Math/sh_math.h
order < kSHMinOrder || order > kSHMaxOrder
sh_accumulate_omni_light
C3DCamera
<C3DCamera>
averageGray
bloomBlurRadius
bloomIntensity
bloomThreshold
colorFringeStrength
colorFringeIntensity
contrast
exposureAdaptationBrighteningSpeedFactor
exposureAdaptationDarkeningSpeedFactor
exposureAdaptationDuration
exposureOffset
maximumExposure
minimumExposure
motionBlurIntensity
saturation
vignettingIntensity
vignettingPower
whitePoint
ortho
customProj
autoZRange
xfov
yfov
xMag
aspectRatio
orthoScale
%s%p
 [inconsistent parent: %p != %p]
C3DNode
<C3DNode:%p "%@"
  geometry: %@
  skinner: %@
  morpher: %@
alpha
isJoint
kC3D
firstChild
nextSibling
parent
skinner
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}8^B16
_opacityTarget
_opacityTargetReversed
_lastOpacity
_isRelative
sources
primarySourcesInfo
subIDs
C3DMesh
<C3DMesh %p "%@"
  element%d: %@
  semantic:%@%d (%d) : %@
  semantic:%@ (%d) : %@
baseSourceLocators
verticesMask
boundingSphere
meshElements
effectID
C3DMaterial
<C3DMaterial %p : "%@"
common profile %@
custom %@
__library__
enableWriteInDepthBuffer
enableReadsFromDepthBuffer
fillMode
nodeConstraints-%p
C3DScene
<C3DScene>
fogColor
fogDensityExponent
fogEndDistance
fogStartDistance
startTime
endTime
frameRate
upAxis
nodeTree
nodeID
childs
root
playbackSpeed
animationManager
sceneID
lightingSystem
results
backfaceCulling
closest
behaviors
gravity
timeStep
contactDelegate
T@"<SCNPhysicsContactDelegate>"
allBehaviors
ccdPenetration
{CGPoint=dd}
SKGlobalSharedContextRegistry
SCNLightAttenuationStartKey
SCNLightAttenuationEndKey
SCNLightAttenuationFalloffExponentKey
SCNLightSpotInnerAngleKey
SCNLightSpotOuterAngleKey
SCNLightSpotFalloffExponentKey
SCNLightShadowNearClippingKey
SCNLightShadowFarClippingKey
SCNLightGoboProjectShadows
SCNLightConstantAttenuationKey
SCNLightLinearAttenuationKey
SCNLightQuadraticAttenuationKey
SCNLightFallOffAngleKey
SCNLightFallOffExponentKey
SCNLightHotspotBeamKey
quadratic
omni
directional
spot
probe
<%@: %p '%@' | type=%@>
<%@: %p | type=%@>
%@.%@
usesDeferredShadows
lightCategoryBitMask
spotFallOffExponent
version
goboProjectShadows
castsShadow
usesModulatedMode
baked
shouldBakeDirectLighting
shouldBakeIndirectLighting
sphericalHarmonics
shadowSampleCount
shadowSampleCount2
IESProfileURL
technique
T@"SCNTechnique",C,N
T@"NSString",C,N
T@,&,N
T{CGSize=dd},N
shadowMode
T@"SCNMaterialProperty",R,N
T@"NSURL",&,N
VertexCache
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Core/C3DMeshElement_Tools.cpp
cacheSize < kMaxCacheSize
C3DFramebufferRegistry
<C3DFramebufferRegistry>
(null)
C3DLightingSystem
<C3DLightingSystem %p>
offsetX
offsetY
SCNLightingModelPhysicallyBased
SCNLightingModelBlinn
SCNLightingModelPhong
SCNLightingModelLambert
SCNLightingModelConstant
SCNLightingModelNone
mappingChannel
  %@=%@
.color
contents
content
diffuse.
ambient.
specular.
emission.
transparent.
reflective.
multiply.
normal.
diffuse.color
diffuse.contents
shaderModifiers.
valuesForUndefinedKeys
failed to archive material's custom attributes. %@ %@
lightingModelName
shadableHelper
avoidsOverLighting
writesToDepthBuffer
readsFromDepthBuffer
blendMode
T@"SCNProgram",&,N
T@"NSDictionary",C,N
TB,N,GisLitPerPixel
TB,N,GisDoubleSided
Position
Angle
RotationAxis
Velocity
AngularVelocity
Life
Opacity
Size
Frame
FrameRate
Bounce
Friction
Charge
ContactPoint
ContactNormal
scnp
failed to unarchive particle data at %@ (%@)
birthRate
birthRateVariation
dampingFactor
emissionDuration
emissionDurationVariation
fixedTimeStep
idleDuration
idleDurationVariation
imageSequenceColumnCount
imageSequenceFrameRate
imageSequenceFrameRateVariation
imageSequenceInitialFrame
imageSequenceInitialFrameVariation
imageSequenceRowCount
isLocal
particleAngle
particleAngleVariation
particleAngularVelocity
particleAngularVelocityVariation
particleBounce
particleBounceVariation
particleCharge
particleChargeVariation
particleColor
particleFriction
particleFrictionVariation
particleLifeSpan
particleLifeSpanVariation
particleMass
particleMassVariation
particleSize
particleSizeVariation
particleVelocity
particleVelocityVariation
speedFactor
spreadingAngle
stretchFactor
warmupDuration
particleColorVariation
emittingDirection
acceleration
particleImage
emitterShape
birthLocation
birthDirection
affectedByPhysicsFields
physicsCollisionsEnabled
lightingEnabled
softParticlesEnabled
particleDiesOnCollision
blackPassEnabled
systemSpawnedOnCollision
systemSpawnedOnDying
systemSpawnedOnLiving
seed
renderingMode
orientationMode
imageSequenceAnimationMode
particleGeometries
colliderNodes
propertyControllers
sortingMode
T@"SCNGeometry",&,N
local
TB,N,GisLocal
T@"SCNParticleSystem",&,N
T@"UIColor",&,N
TB,N,GisBlackPassEnabled
TB,N,GisLightingEnabled
T@"NSArray",C,N
width
height
length
kProjectionTransform
kModelTransform
kViewTransform
kModelViewProjectionTransform
kModelViewTransform
kNormalTransform
kRenderPassName
Tq,N,Vtype
next
T@"SCNNodeComponent",&,N,Vnext
%s%s {
dump node tree (%@)
------------------------------------------------------
rotation.quaternion
rotation.euler
rotation.axisAngle
eulerAngles
orientation
transform.pivot
 pos(%f %f %f)
 rot(%f %f %f %f)
 scale(%f %f %f)
 light=%@
 camera=%@
 geometry=%@
 | no child
 | 1 child
 | %d children
nodeNamed(
childNodes[
particleSystems[
constraints[
filters[
children[
children
childNodes
rotation.axisAngle%@
rotation.quaternion%@
rotation.euler%@
filters.
SceneKit - circular scene graph
attempt to add a parent node as a child node
action %p #%d
Error: physicsBody %@ already has a owner: %@ that is not %@
constraints
physicsBody
physicsField
particleSystem
fixedBoundingBoxExtrema[0]
fixedBoundingBoxExtrema[1]
paused
action-keys
actions
clientAttributes
failed to archive node's client attributes. %@ %@
movabilityHint
renderingOrder
hasActions
actionKeys
T@"SCNLight",&,N
T@"SCNCamera",&,N
T@"SCNSkinner",&,N
T@"SCNMorpher",&,N
worldTransform
T{SCNMatrix4=ffffffffffffffff},R,N
TB,N,GisHidden
parentNode
T@"SCNPhysicsBody",&,N
T@"SCNPhysicsField",&,N
T@"NSArray",C
presentationNode
TB,N,GisPaused
T@"<SCNNodeRendererDelegate>",N
kSceneStartTimeAttributeKey
kSceneEndTimeAttributeKey
kSceneFrameRateAttributeKey
kSceneUpAxisAttributeKey
org.khronos.collada.digital-asset-exchange
scnz
com.apple.scenekit.scene
MDLAsset
physicsWorld
userAttributes
T@"SCNPhysicsWorld",R,N
lightingEnvironment
SCNRendererOffscreenSampleCount
transition pass
outgoingScene
T@"SCNScene",&,N,V_outgoingScene
transition
T@"SKTransition",&,N,V_transition
transitionStartTime
Td,N,V_transitionStartTime
outgoingPointOfView
T@"SCNNode",&,N,V_outgoingPointOfView
com.apple.scenekit.renderingQueue.%@%p
SKSCNRenderer
<SCNRenderer %p: scene = %@, pointOfView = %@, sceneTime = %f, context = %p>
clearPass
SceneKit - Delete Framebuffer
SceneKit - Create Framebuffer
camera.xFov
camera.yFov
camera.orthographicScale
camera.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DKit/context/SCNRenderer.m
We should have an engine context at this stage
No C Scene associated with %@
Metal implementation not done
sceneTime
SpriteKit - Draw Overlay
SceneKit - Flush
SceneKit - Jitter
T@"SCNScene",&,N
delegate
T@"<SCNSceneRendererDelegate>",N
playing
TB,GisPlaying
autoenablesDefaultLighting
jitteringEnabled
TB,N,GisJitteringEnabled
debugOptions
overlaySKScene
T@"SKScene",&,N
renderingAPI
TQ,R,N
context
T^v,R,N
audioEngine
T@"AVAudioEngine",R,N
audioEnvironmentNode
T@"AVAudioEnvironmentNode",R,N
audioListener
nextFrameTime
textureID
TI,R,N
antialiasingMode
path
flatness
entityID
basic
keyframe
group
class
keyPath
animation-keys
.app/Contents/
SKEDocumentSanitizer
imageNamed
imageNamed://
v24@?0@"SCNNode"8^B16
Error: ranges and strings arrays must be of the same size
Error: ranges must be ordered
Error: incorrect ranges : cumulated size larger than the original string
SCNAnimationCommitOnCompletion
SCN_CAKeyframeAnimation %p (duration=%f, keyPath:%@)
c3dAnimation
commitsOnCompletion
removedOnCompletion
animationEvents
q24@?0@"SCNAnimationEvent"8@"SCNAnimationEvent"16
CAKeyframeAnimation based on CGPath are not supported
can'add an animation with no path
SCNAnimationAnimatesUsingSceneTimeKey
SCNAnimationFadeInDurationKey
SCNAnimationFadeOutDurationKey
SCNAnimationEventsKey
geometryMemory
textureMemory
kSceneSourceCacheScenesByURLKey
kSceneSourceSceneIndexKey
kSceneSourceForceMorphNormals
kSceneSourcePreserveOriginalTopology
SCNDetailedErrorsKey
SCNConsistencyElementIDErrorKey
SCNConsistencyElementTypeErrorKey
SCNConsistencyLineNumberErrorKey
kSceneSourceFormat
SCNSceneSourceInputSource
SCNSceneExportDestinationURL
SCNSceneExportUTIKey
SCNSceneExportCompressGeometryElements
[SCNSceneSource scenesSourceWithURL:] nil URL
<%@: %p | URL='%@'>
<%@: %p>
The document "%@" could not be opened.
The document data could not be read.
v32@?0f8i12^{__CFError=}16^B24
failed to unarchive data at %@ (%@)
failed to unarchive scene at %@ - unknown decoded object class (%@)
failed to unarchive scene at %@ (%@)
v36@?0f8q12@"NSError"20^B28
@16@?0^v8
T@"NSURL",R
T@"NSData",R
T@"NSDictionary",&,N,V_context
assetCatalog
T@"SCNAssetCatalog",&,N,V_assetCatalog
lookUpKey
T@"NSString",&,N,VlookUpKey
lookUpFoundInstance
T@,&,N,VlookUpFoundInstance
T@"NSDictionary",C,N,Voptions
bplist
sampleCount
contentScaleFactor
wantsWideGamut
isOpaque
currentFrameIndex
showsAuthoringEnvironment
enablesDeferredShading
features
profile
Ti,R,N
renderTargetRegistry
T@"SCNRenderTargetRegistry",R,N
resourceManager
T@"<SCNResourceManager>",R,N
Tq,N,VsampleCount
Td,N,VcontentScaleFactor
TB,N,VwantsWideGamut
TB,N,VisOpaque
TB,N,VenablesDeferredShading
T@"SCNRenderTargetRegistry",R,N,V_renderTargetRegistry
textureCoordinate is deprecated - use textureCoordinateWithMappingChannel instead
<%@: %p | geometryIndex=%d node=%@ bone=%@>
geometryIndex
faceIndex
localCoordinates
worldCoordinates
localNormal
worldNormal
modelTransform
boneNode
a_vertexColor
a_TexTangent
a_diffuseTexcoord
a_ambientTexcoord
a_specularTexcoord
a_emissionTexcoord
a_filterTexcoord
a_transparentTexcoord
a_normalTexcoord
a_lightmapTexcoord
u_nodeOpacity
u_skinningJointMatrices
u_materialShininess
u_ambientColor
u_ambientIntensity
u_ambientTexture
u_ambientTextureMatrix
u_diffuseColor
u_diffuseIntensity
u_diffuseTexture
u_diffuseTextureMatrix
u_specularColor
u_specularIntensity
u_specularTexture
u_specularTextureMatrix
u_emissionColor
u_emissionIntensity
u_emissionTexture
u_emissionTextureMatrix
u_multiplyColor
u_multiplyIntensity
u_multiplyTexture
u_multiplyTextureMatrix
u_transparency
u_transparentColor
u_transparentIntensity
u_transparentTexture
u_transparentTextureMatrix
u_normalTexture
u_normalIntensity
u_normalTextureMatrix
u_shininessTexture
u_shininessTextureMatrix
u_lightmapTexture
u_reflectiveColor
u_reflectiveIntensity
u_reflectiveTexture
u_reflectiveTextureMatrix
u_fresnel
u_ambientLightColor
u_shCoefficients
u_light%d_attenuation
u_light%d_spotAttenuation
u_light%d_color
u_light%d_position
u_light%d_direction
u_light%d_up
u_light%d_right
u_light%d_gobo
u_light%d_goboMatrix
u_light%d_goboIntensity
u_light%d_iesMatrix
u_light%d_iesTex
u_light%d_shadow
u_light%d_shadowMatrix
u_light%d_shadowRadius
u_light%d_shadowColor
u_zRange
u_orientationPreserved
u_shadowKernel
AuthEnv2Root
_layerRoot
_lightRoot
_cameraRoot
_particlesRoot
_jointsRoot
lightAuth
particlesAuth
jointSubAuth
jointAuth
kSCNFreeViewCameraName
cameraAuth
cameraFrustumAuth
cameraNearPlaneAuth
lightInnerAuth
lightOuterAuth
lightArrowAuth
lightSpotAuth
oa:%f ia:%f s:%f e:%f
AuthEnvHash
displayMask
DBGLightType
C3DFXOutline.plist
pickedObjects
C3DFXOutlineRetina.plist
C3DFXAuthoring.plist
--OutlineMaterial--
PickedObject.glsl
ControllerAnimation
ControllerVariableMode
ControllerVariableOverLife
ControllerVariableOverDistance
ControllerVariableOverOtherProperty
ControllerVariableOrigin
ControllerVariableScale
ControllerVariableBias
C3DParticleSystem
<C3DParticleSystemRef>
InvLifeSpan
BirthTime
SortingIndices
Mass
TempData
EventIndex
C3DLibrarySubStorage
<C3DLibrarySubStorage>
C3DLibrary
<C3DLibrary>
kPrimitiveGenerateMappingCoordinates
kPrimitiveVertexTransformation
kPrimitiveGenerateSmoothedEdges
kPrimitiveWidthSegments
kPrimitiveHeightSegments
kPrimitiveLengthSegments
kPrimitiveChamferSegments
kPrimitiveRotationSegments
kPrimitiveCapSegments
kPrimitiveRingSegments
kPrimitivePipeSegments
kPrimitiveSphereType
kPrimitiveSphereSegments
kPrimitiveTypeSphere
kPrimitiveTypeGeosphere
kPrimitiveTypeHemisphere
kPrimitiveGeosphereBase
kPrimitiveTypeTetrahedron
kPrimitiveTypeHexahedron
kPrimitiveTypeOctahedron
kPrimitiveTypeIcosahedron
widthSegmentCount
heightSegmentCount
lengthSegmentCount
chamferSegmentCount
segmentCount
radialSegmentCount
ringSegmentCount
pipeSegmentCount
reflectionFalloffEnd
reflectionFalloffStart
reflectionCategoryBitMask
reflectionResolutionScaleFactor
C3DFloor
<C3DFloor>
resolutionScaleFactor
reflectionBitMask
<%@: %p '%@'>
usesOrthographicProjection
automaticallyAdjustsZRange
colorGrading
wantsHDR
wantsExposureAdaptation
glID
TI,N,VglID
TI,N,Vtarget
T^v,N,Vcontext
T{CGSize=dd},N,Vsize
invalid wrapS value: %d
invalid wrapT value: %d
<%@: %p | contents=%@>
<data %p>
imageArray
layer
skscene
sktexture
attachment
isCommonProfileProperty
propertyType
customSlotName
SKScene
SKTexture
GLKTextureInfo
%@: %p '%@'
%@: %p
 | %d elements
<%@>
geometrySourceForSemantic is deprecated - use geometrySourcesForSemantic instead
materials[
q24@?0@8@16
elements
failed to archive geometry's custom attributes. %@ %@
subdivisionLevel
edgeCreasesSource
edgeCreasesElement
subdivisionSettings
T@"SCNMaterial",&,N
geometrySources
geometryElementCount
T@"SCNGeometryElement",&,N
T@"SCNGeometrySource",&,N
C3DFXGLSLProgramObject
<C3DFXGLSLProgramObject %p>
SCNErrorDomain
scnasset
.scnassets
SCNScene
catalogURL
T@"NSURL",R,N,V_catalogURL
inputMode
inputBias
inputOrigin
inputProperty
T@"CAAnimation",&,N
T@"SCNNode",W,N
SCNSkinner: inconsistent weights and indices.
SCNSkinner: bone weights must be float
SCNSkinner: bone indices length must be 1 or 2 bytes
SCNSkinner: bone indices length must be 1 or 2 bytes with no stride
SCNSkinner: bone weight must be float with no stride
mismatch between the vertex count and the number of bones per vertex
skeleton
baseGeometry
baseGeometryBindTransform
bones
compressedSkinData
boneWeights
boneIndices
baseGeometryBindTransform-%d
boneInverseBindTransforms
T@"SCNGeometrySource",R,N
preferredFrameRate
Tf,N
C3DSkinner
<C3DSkinner %p skeleton:%p jointCount:%d cpuReady:%d gpuReady:%d
  skin:%p skinnedMesh:%p calcMode:%d
  JointBbox[%d] {%f,%f,%f} {%f,%f,%f}
skeletonID
skinID
meshCreated
bboxDirty
skinnedMesh
verticesJointsMatrices[%d]
normalsJointsMatrices[%d]
 %f %f %f %f
C3DSkin
<C3DSkin %p joint:%d weight:%d vertexCount:%d
  maxInf:%d morpher:%p
defaultShapeMatrix
inverseBindMatrix
jointsCount
maxInfluences
inverseBindMatrices
baseMeshID
weightsCount
vertexWeightIndices
jointsForVertexWeights
vertexWeights
maxInfluencesPerVertex
influencingMorpher
vertexWeightIndices[%d]
vertexWeights[%d]
jointsForVertexWeights[%d]
C3DIONSZipFileArchiveHeaderOffset
C3DIONSZipFileArchiveCompressionType
C3DIONSZipFileArchiveCRC
C3DIONSZipFileArchiveCompressedLength
C3DIONSZipFileArchiveUncompressedLength
1.2.8
C3DSourceAccessor
<C3DSourceAccessor %lx>
componentsCountPerValue
count
<C3DGenericSource %lx>
delegationBlock
C3DGenericSource
C3DResourceCache
<C3DResourceCache 0x%lx>
C3DAnimationGroup
<C3DAnimationGroup %p>
channels
subAnimations
normals
vehicle
wheelIndex
suspensionStiffness
suspensionCompression
suspensionDamping
maximumSuspensionTravel
frictionSlip
maximumSuspensionForce
connectionPosition
steeringAxis
axle
radius
suspensionRestLength
isFront
T@"SCNNode",R
T{SCNVector3=fff}
T@,&,N,VsourceObject
keyPathSrc
T@"NSString",&,N,VkeyPathSrc
keyPathDst
T@"NSString",&,N,VkeyPathDst
T@"NSDictionary",&,N,Voptions
C3DAnimationChannel
<C3DAnimationChannel>
targetPath
v40@?0q8q16q24q32
v24@?0d8f16f20
v28@?0f8f12f16f20f24
C3DTransformsArray
<C3DTransformsArray %p>
cornerRadius
cornerSegmentCount
<%@ | width=%.3f height=%.3f>
primitiveType
chamferRadius
<%@ | width=%.3f height=%.3f length=%.3f chamferRadius=%.3f>
boxwidth
boxheight
boxlength
boxchamferRadius
boxwidthSegmentCount
boxheightSegmentCount
boxlengthSegmentCount
boxchamferSegmentCount
boxprimitiveType
<%@ | width=%.3f height=%.3f length=%.3f>
pyramidwidth
pyramidheight
pyramidlength
pyramidwidthSegmentCount
pyramidheightSegmentCount
pyramidlengthSegmentCount
pyramidprimitiveType
radialSpan
<%@ | radius=%.3f>
sphereradius
sphereradialSpan
spheresegmentCount
sphereprimitiveType
spheregeodesic
spherehemispheric
geodesic
TB,N,GisGeodesic
<%@ | radius=%.3f height=%.3f>
cylinderradius
cylinderheight
cylinderradialSpan
cylinderheightSegmentCount
cylinderradialSegmentCount
cylinderprimitiveType
bottomRadius
topRadius
<%@ | topRadius=%.3f bottomRadius=%.3f height=%.3f>
conetopRadius
conebottomRadius
coneheight
coneheightSegmentCount
coneradialSegmentCount
coneprimitiveType
innerRadius
outerRadius
<%@ | innerRadius=%.3f outerRadius=%.3f height=%.3f>
tubeinnerRadius
tubeouterRadius
tubeheight
tuberadialSpan
tubeheightSegmentCount
tuberadialSegmentCount
tubeprimitiveType
capRadius
capSegmentCount
<%@ | capRadius=%.3f height=%.3f>
capsulecapRadius
capsuleheight
capsuleheightSegmentCount
capsuleradialSegmentCount
capsulecapSegmentCount
capsuleprimitiveType
pipeRadius
ringRadius
<%@ | ringRadius=%.3f pipeRadius=%.3f>
torusringRadius
toruspipeRadius
torusradialSpan
torusringSegmentCount
toruspipeSegmentCount
torusprimitiveType
SCNAction: Custom actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
SCNAction: Custom actions can not be properly decoded, Objective-C blocks do not support NSCoding.
_C3DParametricGeometryCreateCacheHash_not_thread_safe
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Core/C3DParametricGeometry.c
size <= sizeof(C3DParametricGeometryType) + sizeof(C3DParametricGeometryParameters)
C3DParametricGeometry
vec2(
vec3(
vec4(
%g,%g
%g,%g,%g
%g,%g,%g,%g
C3DValue
<C3DValue %p - type:%d bytes:%p >
value
C3DFXSampler
<C3DFXSampler>
preferredExtensions
v16@?0^{__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}8
B24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}8^B16
nodeFromflattenedMesh
0.10
0.11
kEnclosingFolderURL
kSceneSourceInputLibrary
kC3DIOSerializationExportDelegate
kCreatePropertyListShouldZipOption
kCreatePropertyListShouldKeepReferencesToFilesOption
readerMinimumRequiredVersion
library
Could not get the data for the serialized property list
Could not zip the serialized property list
zippedData
zipped
%.1f %.1f %.1f
meter
unnamed animation #%d
kIDKey
kNameKey
entity-name
entity-ID
_kvc
C3DEntity
<C3DEntity:%p>
C3DEngineNotificationQueue
<C3DEngineNotificationQueue %p>
C3DDynamicBatchingSystem
<C3DDynamicBatchingSystem %p>
SCNPreferredRenderingAPIKey
SCNPreferredDeviceKey
SCNPreferLowPowerDeviceKey
PrefersOpenGL
ibPreferredRenderingAPI
ibWantsMultisampling
allowsCameraControl
backgroundColor
ibSceneName
background.contents
SceneKit - SCNView Draw
renderer.%@
v24@?0@"SCNView"8d16
<%@: %p | scene=%@ sceneTime=%f frame=%@ pointOfView=%@>
_UIHostedWindow
preferredFramesPerSecond
eaglContext
T@"EAGLContext",&,N
kSCNViewObservingContext
SceneKit-spotShadowDepth-%p
SceneKit-spotShadowDepth
C3DFXDeferredShadowPass.json
C3DFXForwardShadowPass.json
SceneKit_renderSceneFromLight
SceneKit_applyDeferredShadows
--ShadowMaterial--
lightDepthSampler
METAL
TARGET_OS_IPHONE
MAX_SAMPLE
SPOT_SHADOW
USE_PCF
C3D-spotShadow.metal
C3D-spotShadow
#define TARGET_OS_IPHONE 1
#define MAX_SAMPLE %d
#define unshareIndex %d
#define SPOT_SHADOW 1
#define USE_PCF 1
C3D-u_lightPos-symbol
C3D-u_lightDir-symbol
C3D-u_lightSpotAtt-symbol
C3D-light_MVP-symbol
C3D-camera_MVP_i-symbol
C3D-shadowRadius-symbol
C3D-shadowColor-symbol
C3D-shadowKernel-symbol
v16@?0^{__C3DGenericSource={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}8
C3DMorph
<C3DMorph %p "%@"
  calc:%d morphNrm:%d targets:%ld
[%ld] weight:%f %@
morphingType
weightsID
targetIDs
weightsData
<unnamed %d>
C3DMorpher
<C3DMorpher %p baseGeom:%p morphedMesh:%p state:%d
  morph:%@
morphID
C3DFXContext
<C3DFXContext>
%d - %@
 (resolve)
 (%dx)
NoName
USE_%@
USE_%@_COLOR
USE_%@_INTENSITY
USE_%@TEXCOORD
USE_%@_MAP
USE_%@_CUBEMAP
C3D-DefaultProgram
C3DFXGLSLProgram
<C3DFXGLSLProgram %p>
vertexShader
fragmentShader
attributeNamesToIndexes
uniformNamesToIndexes
#extension
C3DRendererDelegate
<C3DRendererDelegate %p>
USE_SPECULAR
USE_VIEW
USE_SHININESS
SCNShaderLightDecl.glsl
uniform vec4 u_shadowKernel[%d];
USE_FOG
USE_POSITION
USE_FRESNEL
USE_NORMAL
AVOID_OVERLIGHTING
USE_AMBIENT_LIGHTING
USE_LIGHTING
USE_PER_PIXEL_LIGHTING
USE_MODULATE
USE_PER_VERTEX_LIGHTING
USE_VERTEX_COLOR
SCNShaderSurfaceDecl.glsl
USE_AMBIENT_AS_AMBIENTOCCLUSION
USE_EMISSION_AS_SELFILLUMINATION
USE_TANGENT
USE_BITANGENT
    vec2 %@Texcoord;
    _surface.%@Texcoord = v_texcoord%d;
USE_DISCARD
} _surface;
varying vec2 v_texcoord%d;
uniform mat4 u_%@TextureMatrix;
v_texcoord%d = (u_%@TextureMatrix * vec4(_geometry.texcoords[%d], 0., 1.)).xy;
v_texcoord%d = _geometry.texcoords[%d];
NEED_IN_TEXCOORD%d
USE_TEXCOORD
#extension GL_EXT_shadow_samplers : require
C3D-UberShader.vsh
SCNShaderGeometryDecl.glsl
SEPARATE_PROJECTION
__DoTexcoord__
#define kSCNTexcoordCount %ld
USE_SKINNING
MAX_BONE_INFLUENCES
USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
__DoLighting__
#extension GL_OES_standard_derivatives : enable
C3D-UberShader.fsh
USE_SURFACE_MODIFIER
__DoSurfaceModifier__
USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
LOCK_AMBIENT_WITH_DIFFUSE
USE_DOUBLE_SIDED
USE_NODE_OPACITY
DIFFUSE_PREMULTIPLIED
USE_TRANSPARENCY_RGBZERO
u_light%ld
    SCNShaderLight _light;
    _light.intensity = vec4(1.);
uniform vec4 %@_color;
    _light.intensity = %@_color;
uniform vec4 %@_direction;
    _light.direction = %@_direction.xyz;
uniform vec4 %@_position;
    vec3 _D = %@_position.xyz - _surface.position;
    _light.dist = length(_D);
    _light.direction = _D / _light.dist;
    _light.direction = normalize(%@_position.xyz - _surface.position);
    _light.dir = %@_direction.xyz;
//Unsupported
    _light._att = 1.;
uniform vec4 %@_attenuation;
    vec3 _att = %@_attenuation.xyz;
uniform vec4 %@_spotAttenuation;
    vec3 _spot = %@_spotAttenuation.xyz;
uniform sampler2DShadow %@_shadow;
uniform mat4 %@_shadowMatrix;
uniform float %@_shadowRadius;
uniform vec4 %@_shadowColor;
    _light._att *= (1. - _shadowingTerm * %@_shadowColor.a);
    _light._att *= (1. - _shadowingTerm);
uniform sampler2D %@_gobo;
uniform mat4 %@_goboMatrix;
uniform float %@_goboIntensity;
uniform sampler2D %@_iesTex;
uniform vec4 %@_up;
uniform vec4 %@_right;
uniform samplerCube %@_iesTex;
uniform mat4 %@_iesMatrix;
    _lightingContribution.modulate *= _light._att * _light.intensity.rgb;
    _light._att *= step(_light.dist, _att.x);
    _light._att *= clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    float _dstatt = clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    _light._att *= (_dstatt  * _dstatt);
    _light._att *= pow(clamp(_light.dist * _att.x + _att.y, 0.0, 1.0), _att.z);
    _light._att *= step(_spot.x, dot(_light.direction, _light.dir));
    _light._att *= clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    float _sptatt = clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    _light._att *= _sptatt * _sptatt;
    _light._att *= pow(clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0), _spot.z);
    float _shadowingTerm = 0.0;
    vec4 _lightScreen = (%@_shadowMatrix * vec4(_surface.position, 1.));
    float _filteringSizeFactor = %@_shadowRadius * _lightScreen.w;
    for(int i=0; i < %d; i++){
        _shadowingTerm += __shadow2DProj(%@_shadow, _lightScreen + (u_shadowKernel[i] * _filteringSizeFactor));
    }
    _shadowingTerm /= float(%d);
    float _shadowingTerm = __shadow2DProj(%@_shadow, (%@_shadowMatrix * vec4(_surface.position, 1.)));
    _light.intensity *= mix(vec4(1.), texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.))), %@_goboIntensity);
    _light.intensity *= %@_goboIntensity * texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.)));
    _light.intensity *= texture2D(%@_iesTex, vec2(acos(dot(_light.direction, _light.dir))*_spot.x,0.));
 float vertAngle = acos(dot(_light.direction, _light.dir));
 vec3 surfaceRay = _surface.position-%@_position.xyz;
 vec3 projPos = normalize(surfaceRay - dot(surfaceRay,_light.dir)*_light.dir);
 vec2 texCoord = vec2(dot(projPos,%@_right.xyz),dot(projPos,%@_up.xyz))*vertAngle*_spot.x;
_light.intensity *= texture2D(%@_iesTex, texCoord*0.5+0.5);
    _light.intensity *= textureCube(%@_iesTex, (%@_iesMatrix * vec4(_surface.position, 1.)).xyz);
    _light.intensity = 0;
    _light.intensity.rgb *= _light._att * max(0.0, dot(_surface.normal, _light.direction));
    _lightingContribution.diffuse += _light.intensity.rgb;
    vec3 _R = reflect(-_light.direction, _surface.normal);
    _lightingContribution.specular += pow(max(0.0, dot(_R, _surface.view)), _surface.shininess) * _light.intensity.rgb;
    vec3 _halfVector = normalize(_light.direction + _surface.view);
    _lightingContribution.specular += pow(max(0.0, dot(_surface.normal, _halfVector)), _surface.shininess) * _light.intensity.rgb;
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return shadow2DProjEXT( tex, coord );}
  vec4 %@;
struct SCNShaderLightingContribution {vec3 ambient; vec3 diffuse; vec3 specular; vec3 modulate;} _lightingContribution;
uniform %@ %@;
C3DFXDOFPass.plist
SceneKit_downSample4x
SceneKit_DOF_blurCoc_H
SceneKit_DOF_blurCoc_V
SceneKit_blurColor4x_H
SceneKit_blurColor4x_V
C3D-dof-lerpBias
C3D-dof-lerpScale
C3D-dof-cocScaleBias
C3D-dof-invertPixelSize
SceneKit: C3DProgressDebugger fractionCompleted > 1.0
fractionCompleted
C3DNotificationCenter
<C3DNotificationCenter %p>
<SCNMorpher %p>
weights[%d]
weightID
useSparseTargets
shouldMorphNormals
com.apple.scenekit.programHashCodeQueue
C3DRendererElementProgramHashCode
<C3DRendererElementProgramHashCode %p : 
SM_Mat,
SM_Geo,
Aone,
Acst,
opq,
tgt,
lgh,
amb,
prob,
fog,
dynB,
pntR,
Constant
Lambert
Phong
Blinn
None
[%@:
PerPix|
Double|
OverLght|
WrNrm|
Nrmliz|
WriteDepth|
LinDepth|
LockAmb|
TrspA
TrspRGB
[Node:
skn(%d)|
LightMap|
VrtCol|
AmbientOcclusion
SelfIllumination
Metalness
Roughness
Tex|
rgb0|
rgb1|
flt0|
texA|
int|
mat|
(1D)
(2D)
(3D)
(Cube)
[Lighting:
Soft(%d)
bbox %p - min:[%f %f %f] max:[%f %f %f]
T{SCNVector3=fff},N,Vmin
T{SCNVector3=fff},N,Vmax
bsphere %p - center:[%f %f %f] radius:%f
center
T{SCNVector3=fff},N,Vcenter
Td,N,Vradius
_actions
_mycaction->_animIndex
SCNUITreeDidChange
uiView
T@,&,N,V_uiView
uiWindow
T@,&,N,V_uiWindow
SCN_isBackingUIView
T@,&,N,V_source
_lastRatio
_posTarget.x
_posTarget.y
_posTarget.z
_posTargetReversed.x
_posTargetReversed.y
_posTargetReversed.z
_posStart.x
_posStart.y
_posStart.z
_isReversed
C3DParticleModifier
<C3DParticleModifierRef>
C3DCommandQueue
<C3DCommandQueue>
C3DTransaction
<C3DTransaction>
com.apple.scenekit.postAnimationCompleteQueue
transition-0x
UITrackingRunLoopMode
animationTimingFunction not implemented for Javascript
animationDuration
animationTimingFunction
T@"CAMediaTimingFunction",C,N
disableActions
completionBlock
T@?,C,N
kGeometrySourceSemanticTangent
kGeometrySourceSemanticVertexCrease
kGeometrySourceSemanticEdgeCrease
kGeometrySourceSemanticBoneWeights
kGeometrySourceSemanticBoneIndices
<%@: %p | semantic=%@ vectors=%d %@x%d>
vectorCount
floatComponents
bytesPerComponent
componentType
componentsPerVector
dataOffset
dataStride
_geometrySourceWithSource - Conversion failed
T@"NSData",R,N
T@"NSString",R,N
mutableData
T@"NSMutableData",R,N
compressedElementData
elementData
primitiveCount
renderingAlgorithm
obstruction
occlusion
T{AVAudio3DPoint=fff},N
C3D-wireframe
ManipulatorWireframe_vert
ManipulatorWireframe_frag
Sources
Elements
Textures
Uniforms
SceneKit - Draw Statistics
AuthEnvStats
v32@?0^q8^{CGSize=dd}16^^{?}24
v24@?0{CGSize=dd}8
Animations
Physics
Constraints
Particles
Delegate
Rendering
Metal flush
GL flush
--- ms
%2.1f s
%2.1f ms
$3$%@ $4$%@
Mt %s%dfps
GL %s%dfps
sceneRenderer
T@"<SCNSceneRenderer>",R
selectedNodes
selectionIsReadonly
selecting
TB,R,N,V_selecting
manipulator
T@"SCNManipulator",R,N
shouldSnapOnGrid
TB,N,V_shouldSnapOnGrid
shouldSnapToAlign
TB,N,V_shouldSnapToAlign
graphicalSelectionEnabled
TB,N,V_graphicalSelectionEnabled
surroundToSelect
TB,N,V_surroundToSelect
authoringDisplayMask
gridUnit
Td,R,N,V_gridUnit
editingSpace
Tq,N,V_editingSpace
viewMatrix
T@"<SCNAuthoringEnvironmentDelegate>",W,N,V_delegate
C3DManipulatorColorAndTexture
C3DManipulatorColorOnly
C3DManipulator
C3DManipulatorLightProbe
ManipulatorColorAndTexture_vert
ManipulatorColorAndTexture_frag
ManipulatorColorOnly_vert
ManipulatorColorOnly_frag
Manipulator_vert
Manipulator_frag
ManipulatorLightProbe_vert
ManipulatorLightProbe_frag
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
Menlo
Menlo-Bold
%2.1fms
%zuB
%.3gKB
%.3gMB
%.3gGB
%.3gK
%.3gM
%.3gG
AuthEnvDraw
u_sampler
AuthEnvDrawTEXTURED
view
T@"SCNView",R
enableFreeCamera
autoSwitchToFreeCamera
freeCamera
setGimbalLockVector is deprecated
Camera
gimbalLockMode
gimbalLockVector
stickyAxis
enableInertia
allowsTranslation
automaticCameraTarget
cameraTarget
_axisRot
_rotX
_rotY
_rotZ
_lastRotX
_lastRotY
_lastRotZ
_isAxisAngle
_isUnitArc
_qRot
http
SCNLayerTreeDidChange
T@"CALayer",&,N,V_layer
kCARendererFlags
T@,&,N,V_delegate
kExportPointOfViewAttribute
SCNExportSceneIdentifier
minLinearLimit
maxLinearLimit
minAngularLimit
maxAngularLimit
motorTargetLinearVelocity
motorMaximumForce
motorTargetAngularVelocity
motorMaximumTorque
minimumLinearLimit
maximumLinearLimit
minimumAngularLimit
maximumAngularLimit
C3DGlyphCreate
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Primitives/Text/C3DGlyph.c
shapeParams.cgPath == NULL
C3DGlyph
<C3DGlyph '%@' in '%@'>
Active uniforms %d for program id %d
u_%-2d location:%-2d name:%-*s type:%-12s (%d bytes)
Active attributes %d
a_%-2d location:%-2d name:%-*s type:%-12s (%d bytes)
C3DTextFrame
<C3DTextFrame>
C3DRasterizerStates
<C3DRasterizerStates %p>
B24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}qqddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}qqddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}qqddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}qqddddi}16
v32@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}qqddddi}8q16q24
C3DAppendPointToPath
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Primitives/Text/C3DShapeUtils.c
origin != C3DShapeVertexOriginCurveStart
C3DComputeLinesIntersection
denom != 0
C3DComputeLinesIntersectionForPoints
C3DTextLine
<C3DTextLine>
astc
_scaleTarget
_scaleTargetReversed
_deltaScale
C3DShapeTriangulationCheckConsistency
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Primitives/Text/C3DShapeTriangulation.c
neighborB != t
neighborB != UNDEFINED_NEIGHBOR
neighborA == neighborB
neighborCount == 0
t->constrain[j] == false
neighborCount == 1
neighborA->neighbors[link] == t
neighborA->constrain[link] == t->constrain[j]
C3DLinkIndexFromTriangleToTriangle
C3DVertexNotSharedByTriangles
C3DShapeConnectedComponentTriangulatePseudopolygon
list->count > 1
C3DShapeTriangulationAddEdge
recycledTriangles.count == 0
Futura-Medium
C3DShape debug
v16@?0@?<v@?>8
C3DSpokeCreate
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Primitives/Text/C3DShapeStraightSkeleton.c
CGPointEqualToPoint(origin, prev) == false
CGPointEqualToPoint(origin, next) == false
!isnan(spoke.direction.x)
!isnan(spoke.direction.y)
intersectionForSpokeAndSpoke
fabs(CGPointNorm(spoke1->direction) - 1) < epsilon
fabs(CGPointNorm(spoke2->direction) - 1) < epsilon
intersectionForSpokeAndEdge
spoke != edgeStart
spoke != edgeEnd
splitJoinFace
event.type == C3DStraightSkeletonEventSplit
spoke->boundaryOfVerticesIndex != -1
other->boundaryOfVerticesIndex != -1
d != -1
f != -1
C3DOffsetBuild
newFace.boundaries == NULL
T@,&
frame
T{CGRect={CGPoint=dd}{CGSize=dd}}
bounds
T{CGSize=dd}
vector3
T{SCNVector3=fff},R
vector4
T{SCNVector4=ffff},R
matrix4
SCNInitializeJavascriptContext is deprecated - use SCNExportJavaScriptModule instread
JSValue
{SCNVector4=ffff}
{SCNVector3=fff}
{SCNMatrix4=ffffffffffffffff}
toVector4
toVector3
toTransform3D
valueWithVector3:inContext:
valueWithVector4:inContext:
valueWithTransform3D:inContext:
_SceneKitIsLoaded
SCNMaterialProperty
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNColor
CAMediaTimingFunction
CABasicAnimation
CAAnimationGroup
CAKeyframeAnimation
CALayer
SCNImage
SCNValue
SCNView
SCNPhysicsBehavior
SCNParticlePropertyController
SCNPhysicsHingeJoint
SCNPhysicsContact
SCNProgram
SCNTorus
SCNMorpher
SCNCapsule
SCNLevelOfDetail
SCNRenderer
SCNCylinder
SCNFloor
SCNNode
SCNPlane
SCNPhysicsBallSocketJoint
SCNCone
SCNSphere
SCNGeometry
SCNConstraint
SCNPhysicsSliderJoint
SCNLight
SCNMaterial
SCNParticleSystem
SCNHitTestResult
SCNPhysicsVehicle
SCNTube
SCNLookAtConstraint
SCNPhysicsShape
SCNGeometryElement
SCNGeometrySource
SCNShape
SCNSceneSource
SCNPyramid
SCNCamera
SCNPhysicsField
SCNIKConstraint
SCNTechnique
SCNPhysicsWorld
SCNPhysicsBody
SCNBox
SCNTransformConstraint
SCNAnimationEvent
SCNAction
SCNPhysicsVehicleWheel
SCNText
SCNActionTimingModeLinear
SCNActionTimingModeEaseIn
SCNActionTimingModeEaseOut
SCNActionTimingModeEaseInEaseOut
SCNGeometryPrimitiveTypeTriangles
SCNGeometryPrimitiveTypeTriangleStrip
SCNGeometryPrimitiveTypeLine
SCNGeometryPrimitiveTypePoint
SCNGeometryPrimitiveTypePolygon
SCNLevelOfDetailThresholdModeWorldSpaceDistance
SCNLevelOfDetailThresholdModeScreenSpaceRadius
SCNShadowModeForward
SCNShadowModeDeferred
SCNShadowModeModulated
SCNMorpherCalculationModeNormalized
SCNMorpherCalculationModeAdditive
SCNMovabilityHintFixed
SCNMovabilityHintMovable
SCNChamferModeBoth
SCNChamferModeFront
SCNChamferModeBack
SCNParticleSortingModeNone
SCNParticleSortingModeProjectedDepth
SCNParticleSortingModeDistance
SCNParticleSortingModeOldestFirst
SCNParticleSortingModeYoungestFirst
SCNParticleBlendModeAdditive
SCNParticleBlendModeSubtract
SCNParticleBlendModeMultiply
SCNParticleBlendModeScreen
SCNParticleBlendModeAlpha
SCNParticleBlendModeReplace
SCNParticleOrientationModeBillboardScreenAligned
SCNParticleOrientationModeBillboardViewAligned
SCNParticleOrientationModeFree
SCNParticleOrientationModeBillboardYAligned
SCNParticleBirthLocationSurface
SCNParticleBirthLocationVolume
SCNParticleBirthLocationVertex
SCNParticleBirthDirectionConstant
SCNParticleBirthDirectionSurfaceNormal
SCNParticleBirthDirectionRandom
SCNParticleImageSequenceAnimationModeRepeat
SCNParticleImageSequenceAnimationModeClamp
SCNParticleImageSequenceAnimationModeAutoReverse
SCNParticleInputModeOverLife
SCNParticleInputModeOverDistance
SCNParticleInputModeOverOtherProperty
SCNParticleModifierStagePreDynamics
SCNParticleModifierStagePostDynamics
SCNParticleModifierStagePreCollision
SCNParticleModifierStagePostCollision
SCNParticleEventBirth
SCNParticleEventDeath
SCNParticleEventCollision
SCNParticleRenderingModeSprite
SCNParticleRenderingModePointSprite
SCNParticleRenderingModeTrail
SCNParticleRenderingModeBeam
SCNParticleRenderingModeGeometry
SCNReferenceLoadingPolicyImmediate
SCNReferenceLoadingPolicyOnDemand
SCNRenderingAPIMetal
SCNRenderingAPIOpenGLES2
SCNSceneSourceStatusParsing
SCNSceneSourceStatusValidating
SCNSceneSourceStatusProcessing
SCNSceneSourceStatusComplete
SCNSceneSourceStatusError
SCNAntialiasingModeNone
SCNAntialiasingModeMultisampling2X
SCNAntialiasingModeMultisampling4X
SCNCullBack
SCNCullFront
SCNBufferFrequencyPerFrame
SCNBufferFrequencyPerNode
SCNBufferFrequencyPerShadable
SCNCullModeBack
SCNCullModeFront
SCNTransparencyModeAOne
SCNTransparencyModeRGBZero
SCNBlendModeAlpha
SCNBlendModeAdd
SCNBlendModeSubtract
SCNBlendModeMultiply
SCNBlendModeScreen
SCNBlendModeReplace
SCNFillModePoint
SCNFillModeWireframe
SCNFillModeSolid
SCNFilterModeNone
SCNFilterModeNearest
SCNFilterModeLinear
SCNWrapModeClamp
SCNWrapModeRepeat
SCNWrapModeMirror
SCNPhysicsBodyTypeStatic
SCNPhysicsBodyTypeDynamic
SCNPhysicsBodyTypeKinematic
SCNPhysicsFieldScopeInsideExtent
SCNPhysicsFieldScopeOutsideExtent
fromValue
toValue
T@"NSString",C
TB,GisAdditive
TB,GisCumulative
T@"CAMediaTimingFunction",&
TB,GisRemovedOnCompletion
T^{CGPath=}
keyTimes
T@,C,N
currentTime
T@,N
TB,N,GisPlaying
tessellationControlShader
tessellationEvaluationShader
geometryShader
vertexFunctionName
fragmentFunctionName
opaque
TB,N,GisOpaque
T@"<SCNProgramDelegate>",N
T@"<MTLLibrary>",&,N
presentationMorpher
T@"SCNMorpher",R,N
T@"SCNGeometry",R
screenSpaceRadius
Td,R
worldSpaceDistance
audioPlayers
particleSystems
hemispheric
TB,N,GisHemispheric
presentationLight
T@"SCNLight",R,N
presentationMaterial
T@"SCNMaterial",R,N
speedInKilometersPerHour
wheels
chassisBody
gimbalLockEnabled
T@,R,N
extrusionDepth
chamferMode
chamferProfile
chainRootNode
string
font
wrapped
TB,N,GisWrapped
containerFrame
T{CGRect={CGPoint=dd}{CGSize=dd}},N
textSize
T{CGSize=dd},R,N
truncationMode
alignmentMode
SCNJS%@JSExport
SCN%@JSExport
%@JSExport
_hasFired
C3DRenderTarget
<C3DRenderTarget %p - texture:%@ rbo:%d>
C3D-UberShader_probes_sh.fsh
C3D-Add.fsh
C3D-wireframe.vsh
C3D-DefaultProgram.fsh
C3D-EnvMap2D.fsh
C3D-Copy.vsh
C3D-dof-Resolve.vsh
C3D-CommonProfile_probes_sh.metal
C3D-dof-downSample4x.vsh
C3DManipulator.vsh
C3D-GaussianBlurAlpha.fsh
C3D-IncrementalAverage.vsh
C3DFXPostProcess.json
C3D-Stereoscopy-ResolveAnaglyph.vsh
C3D-DeferredShadingCommon.h
C3D-OutlineMax.vsh
OpenSubdiv_gl3.glsl
C3D-DeferredShading_Lighting.metal
C3D-spotShadow.vsh
C3D-GaussianBlur.vsh
C3D-BlendAuthoring.vsh
C3D-Copy.fsh
C3D-OutlineRetina.vsh
C3D-CIFilterComposite.fsh
OpenSubdiv.glsl
C3D-EnvMap2D.vsh
C3DFXMotionBlur.plist
C3D-Morph.metal
C3DManipulator.fsh
C3D-CIFilter.metal
C3DFXJitteringPassFloat.plist
C3DFXStereoscopyTechnique_sharedFBO_noResolve.json
C3D-Outline.vsh
C3D-Stereoscopy-ResolveHmd.fsh
C3D-DeferredShading_Debug.metal
C3D-dof-ComputeNearCoc.fsh
C3D-PBR_compute.metal
C3DFXSSAO.json
C3D-VertexTransform.metal
C3D-GaussianBlurAlpha.vsh
C3D-WarmupTexture.vsh
C3D-PickedObjects.vsh
C3D-ParticlesUber.metal
C3D-OutlineMax.fsh
C3D-Background.metal
C3D-IncrementalAverage.fsh
C3D-spotShadow.fsh
C3D-CubemapUtils.metal
C3D-BlendAuthoring.fsh
C3D-EnvMapCube.vsh
C3D-Stereoscopy-ResolveAnaglyph.fsh
C3D-CIFilterComposite.vsh
C3DManipulatorLightProbe.vsh
C3D-DrawQuad.metal
C3D-CommonProfile.metal
C3D-Stereoscopy-ResolveHmd.vsh
C3D-dof-ComputeNearCoc.vsh
C3D-GaussianBlur.metal
C3D-dof-generateNearCoc.fsh
C3D-WarmupTexture.fsh
C3DFXCopyPass.plist
C3DFXStereoscopyTechnique_separateFBO_withResolve.json
SCNShaderLightingContribution.glsl
C3D-DeferredShading_N.metal
C3DManipulatorColorOnly.vsh
C3D-Jittering.metal
C3D-Mult_float.fsh
C3D-EnvMapCube.fsh
C3D-dof-Resolve.fsh
C3D-Debug.metal
C3D-dof-Blur5x5.fsh
C3D-Stereoscopy.metal
C3D-MeshUtils.metal
C3D-Outline.metal
C3D-ParticleSystem_Trail.vsh
C3D-PostProcess.metal
C3DManipulatorColorAndTexture.fsh
C3D-wireframe.fsh
C3D-DefaultProgram.vsh
C3DManipulatorLightProbe.fsh
C3D-dof-generateNearCoc.vsh
C3D-PickedObjects.fsh
scn_util.h
C3D-PBR.metal
C3D-dof-downSample4x.fsh
C3D-Mult_float.vsh
C3D-Add.vsh
C3D-SphericalHarmonics.metal
C3D-ParticleSystem.fsh
C3D-Default.metal
scn_metal
C3D-dof-Blur5x5.vsh
C3D-DeferredShading.metal
C3D-GaussianBlur.fsh
C3DManipulatorColorOnly.fsh
C3D-SSAO.metal
C3D-PostProcess.h
C3D-dof.metal
C3D-MotionBlur.metal
C3D-AuthoringEnvironment.metal
C3D-ParticleSystem.vsh
C3D-Outline.fsh
C3D-OutlineRetina.fsh
C3D-ParticleSystem_Trail.fsh
C3D-ColorGrading.metal
C3DManipulatorColorAndTexture.vsh
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
//#define C3D_USE_PBR
#if defined(USE_POSITION) && (USE_POSITION == 2)
varying vec3 v_position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
varying vec3 v_normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
varying vec3 v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
varying vec3 v_bitangent;
#endif
#ifdef USE_AMBIENT_LIGHTING
uniform vec4 u_ambientLightColor;
#endif
#ifdef USE_DIFFUSE_MAP
uniform sampler2D u_diffuseTexture;
#ifdef USE_DIFFUSE_INTENSITY
uniform float u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
uniform vec4 u_diffuseColor;
#endif
#ifdef USE_NORMAL_MAP
uniform sampler2D u_normalTexture;
#ifdef USE_NORMAL_INTENSITY
uniform float u_normalIntensity;
#endif
#endif
#ifdef USE_SHININESS
uniform float u_materialShininess;
#endif
#ifdef USE_SPECULAR
#ifdef USE_SPECULAR_MAP
uniform sampler2D u_specularTexture;
#ifdef USE_SPECULAR_INTENSITY
uniform float u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
uniform vec4 u_specularColor;
#endif
#endif // USE_SPECULAR
#ifdef USE_AMBIENT_MAP
uniform sampler2D u_ambientTexture;
#ifdef USE_AMBIENT_INTENSITY
uniform float u_ambientIntensity;
#endif
#elif defined(USE_AMBIENT_COLOR)
uniform vec4 u_ambientColor;
#endif
#ifdef USE_REFLECTIVE_MAP
uniform sampler2D u_reflectiveTexture;
#elif defined(USE_REFLECTIVE_COLOR)
uniform vec4 u_reflectiveColor;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform samplerCube u_reflectiveTexture;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP) || defined(USE_PROBES_LIGHTING)
uniform mat4 u_viewToCubeWorld;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
uniform float u_reflectiveIntensity;
#endif
#ifdef USE_FRESNEL
uniform vec3 u_fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
#endif
#ifdef USE_EMISSION_MAP
uniform sampler2D u_emissionTexture;
#ifdef USE_EMISSION_INTENSITY
uniform float u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
uniform vec4 u_emissionColor;
#endif
#ifdef USE_MULTIPLY_MAP
uniform sampler2D u_multiplyTexture;
#ifdef USE_MULTIPLY_INTENSITY
uniform float u_multiplyIntensity;
#endif
#elif defined(USE_MULTIPLY_COLOR)
uniform vec4 u_multiplyColor;
#endif
#ifdef USE_TRANSPARENT_MAP
uniform sampler2D u_transparentTexture;
#ifdef USE_TRANSPARENT_INTENSITY
uniform float u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
uniform vec4 u_transparentColor;
#endif
#ifdef USE_VERTEX_COLOR
varying vec4 v_vertexColor;
#endif
#ifdef USE_NODE_OPACITY // only for RGB_ZERO
uniform float u_nodeOpacity;
#endif
#ifdef USE_TRANSPARENCY // only for RGB_ZERO
uniform float u_transparency;
#endif
#ifdef USE_DOUBLE_SIDED
uniform float u_orientationPreserved;
#endif
#ifdef USE_TIME
uniform float u_time;
#endif
#ifdef USE_FOG
uniform vec4 u_fogColor;
uniform vec3 u_fogParameters; // x:-1/(end-start) y:1-start*x z:exp
#endif
// SH tool functions
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
uniform vec4 u_shCoefficients[7];
vec3 shEvalDirection(vec4 dir)
    vec3 x1, x2, x3;
    
    // Linear + constant polynomial terms
    x1.r = dot(u_shCoefficients[0], dir);
    x1.g = dot(u_shCoefficients[1], dir);
    x1.b = dot(u_shCoefficients[2], dir);
    
    // 4 of the quadratic polynomials
    vec4 vB = dir.xyzz * dir.yzzx;
    x2.r = dot(u_shCoefficients[3], vB);
    x2.g = dot(u_shCoefficients[4], vB);
    x2.b = dot(u_shCoefficients[5], vB);
    
    // Final quadratic polynomial
    float vC = dir.x * dir.x - dir.y * dir.y;
    x3 = u_shCoefficients[6].rgb * vC;
    
    return x1 + x2 + x3;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
// these are SH coef for a single component
struct sh2_vector
    vec4 V;
struct sh2_vector_rgb
    sh2_vector R;
    sh2_vector G;
    sh2_vector B;
uniform vec4 u_shCoefficients[3];
struct sh3_vector
    vec4 V0;
    vec4 V1;
    float V2;
struct sh3_vector_rgb
    sh3_vector R;
    sh3_vector G;
    sh3_vector B;
struct sh3_vector_rgb_packed
    vec4 ar;
    vec4 ag;
    vec4 ab;
    vec4 br;
    vec4 bg;
    vec4 bb;
    vec4 c;
sh2_vector sh2_basis(vec3 InputVector)
    sh2_vector Result;
    // These are derived from simplifying SHBasisFunction in C++
    Result.V.x = 0.282095f;
    Result.V.y = -0.488603f * InputVector.y;
    Result.V.z = 0.488603f * InputVector.z;
    Result.V.w = -0.488603f * InputVector.x;
    return Result;
sh3_vector sh3_basis(vec3 InputVector)
    sh3_vector Result;
    // These are derived from simplifying SHBasisFunction in C++
    Result.V0.x = 0.282095f;
    Result.V0.y = -0.488603f * InputVector.y;
    Result.V0.z = 0.488603f * InputVector.z;
    Result.V0.w = -0.488603f * InputVector.x;
    
    vec3 VectorSquared = InputVector * InputVector;
    Result.V1.x = 1.092548f * InputVector.x * InputVector.y;
    Result.V1.y = -1.092548f * InputVector.y * InputVector.z;
    Result.V1.z = 0.315392f * (3.0f * VectorSquared.z - 1.0f);
    Result.V1.w = -1.092548f * InputVector.x * InputVector.z;
    Result.V2 = 0.546274f * (VectorSquared.x - VectorSquared.y);
    
    return Result;
float PI = 3.141592653f;
sh2_vector sh2_compute_diffuse_transfer(vec3 Normal, float Exponent)
    sh2_vector Result = sh2_basis(Normal);
    
    // These formula are scaling factors for each SH band that convolve a SH with the circularly symmetric function
    // max(0,cos(theta))^Exponent
    float L0 =
2 * PI / (1 + 1 * Exponent
    float L1 =
2 * PI / (2 + 1 * Exponent
    
    // Multiply the coefficients in each band with the appropriate band scaling factor.
    Result.V.x *= L0;
    Result.V.yzw *= L1;
    
    return Result;
sh3_vector sh3_compute_diffuse_transfer(vec3 Normal, float Exponent)
    sh3_vector Result = sh3_basis(Normal);
    
    // These formula are scaling factors for each SH band that convolve a SH with the circularly symmetric function
    // max(0,cos(theta))^Exponent
    float L0 =
2 * PI / (1 + 1 * Exponent
    float L1 =
2 * PI / (2 + 1 * Exponent
    float L2 = Exponent *
2 * PI / (3 + 4 * Exponent + Exponent * Exponent
    float L3 = (Exponent - 1) *
2 * PI / (8 + 6 * Exponent + Exponent * Exponent
    
    // Multiply the coefficients in each band with the appropriate band scaling factor.
    Result.V0.x *= L0;
    Result.V0.yzw *= L1;
    Result.V1.xyzw *= L2;
    Result.V2 *= L2;
    
    return Result;
vec3 sh2_dot(sh2_vector_rgb A, sh2_vector B)
    vec3 Result = vec3(0);
    Result.r = dot(A.R.V, B.V);
    Result.g = dot(A.G.V, B.V);
    Result.b = dot(A.B.V, B.V);
    return Result;
float DotSH3(sh3_vector A,sh3_vector B)
    float Result = dot(A.V0, B.V0);
    Result += dot(A.V1, B.V1);
    Result += A.V2 * B.V2;
    return Result;
vec3 sh3_dot(sh3_vector_rgb_packed A,sh3_vector B)
    vec3 Result = vec3(0);
    sh3_vector rsh;
    rsh.V0 = A.ar;
    rsh.V1 = A.br;
    rsh.V2 = A.c.x;
    
    sh3_vector gsh;
    gsh.V0 = A.ag;
    gsh.V1 = A.bg;
    gsh.V2 = A.c.y;
    
    sh3_vector bsh;
    bsh.V0 = A.ab;
    bsh.V1 = A.bb;
    bsh.V2 = A.c.z;
    
    Result.r = DotSH3(rsh,B);
    Result.g = DotSH3(gsh,B);
    Result.b = DotSH3(bsh,B);
    return Result;
vec3 sh2_evaluate_diffuse(vec3 dir)
    sh2_vector_rgb cachedSH;
    cachedSH.R.V = u_shCoefficients[0];
    cachedSH.G.V = u_shCoefficients[1];
    cachedSH.B.V = u_shCoefficients[2];
    
    // Compute SH for the normal
    sh2_vector diffSH = sh2_compute_diffuse_transfer(dir.xyz, 1.);
    
    // Compute lighting for this SH directions
    return max(vec3(0,0,0), sh2_dot(cachedSH, diffSH)) / PI;
vec3 sh3_evaluate_diffuse(vec3 dir, sh3_vector_rgb_packed cachedSH)
    // Compute SH for the normal
    sh3_vector diffSH = sh3_compute_diffuse_transfer(dir.xyz, 1.);
    
    // Compute lighting for this SH directions
    return max(vec3(0,0,0), sh3_dot(cachedSH, diffSH)) / PI;
#endif
#ifdef C3D_USE_PBR
// ----- BEGIN -----
//  PhysicallyPlausibleCommon.fsh
//  ModelKitViewer
// Uniforms and constants
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;
uniform vec4 u_baseColor;
uniform float u_metallic;
uniform float u_sheen;
uniform float u_sheenTint;
uniform float u_roughness;
uniform float u_anisotropic;
uniform float u_specular;
uniform float u_specularTint;
uniform float u_clearcoat;
uniform float u_clearcoatGloss;
uniform float u_subsurface;
// controlMask.x = 1 means suppress A0, 0 means use it
// controlMask.y = 1 means suppress diffuse, 0 means use it
uniform vec4 controlMask;
uniform sampler2D baseColorTexture;
uniform sampler2D aoTexture;
uniform samplerCube reflectiveEnvironmentSampler;
uniform samplerCube irradianceSampler;
const float PI = 3.1415926535897932384626433832795;
// Structures
struct ShadingValues {
    vec3 surfacePosition;
    vec3 N;
    vec3 V;
    vec3 L;
    vec3 shadingBasisX;
    vec3 shadingBasisY;
struct DerivedShadingValues {
    vec3 H;
    vec3 reflected;
    float NdotL;
    float NdotV;
    float NdotH;
    float LdotH;
    float FL;
    float FV;
    float FH;
    float diffuseRoughness;
    vec3 irradianceColor;
    vec3 reflectedColor;
    vec3 environmentColor;
struct MaterialValues {
    vec3 baseColor;
    vec3 baseColorHueSat;
    vec3 aoValue;
    float baseColorLuminance;
    float specular;
    float specularTint;
    float metallic;
    float sheen;
    float sheenTint;
    float roughness;
    float anisotropic;
    float clearcoat;
    float clearcoatGloss;
    float subsurface;
// Utility
float sqr(float a) {
    return a * a;
vec4 srgbToLinear(vec4 c) {
    vec4 gamma = vec4(1.0/2.2);
    return pow(c, gamma);
vec4 linearToSrgba(vec4 c) {
    vec4 gamma = vec4(2.2);
    return pow(c, gamma);
float SchlickFresnel(float u) {
    float m = clamp(1.0 - u, 0.0, 1.0);
    return pow(m, 5.0);
float smithG_GGX(float Ndotv, float alphaG) {
    float a = alphaG*alphaG;
    float b = Ndotv*Ndotv;
    return 1.0 / (Ndotv + sqrt(a + b - a*b));
// Generalized Trowbridge-Reitz
float GTR1(float NdotH, float a) {
    if (a >= 1.0) return 1.0/PI;
    float a2 = a*a;
    float t = 1.0 + (a2-1.0)*NdotH*NdotH;
    return (a2-1.0) / (PI*log(a2)*t);
// Generalized Trowbridge-Reitz, with GGX divided out
float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {
    return 1.0 / ( PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));
MaterialValues materialValues(vec4 surfaceDiffuse, vec4 surfaceMultiply, vec2 aoCoordinate) {
    MaterialValues mv;
    mv.baseColor = surfaceDiffuse.xyz;
    
    mv.aoValue = surfaceMultiply.xyz;
    
    mv.baseColorLuminance = 0.3 * mv.baseColor.x + 0.6 * mv.baseColor.y + 0.1 * mv.baseColor.z; // approximation of luminance
    mv.baseColorHueSat = mv.baseColorLuminance > 0.0 ? mv.baseColor / mv.baseColorLuminance : vec3(1); // remove luminance
    
    mv.specular = 0.6;//u_specular;
    mv.specularTint = 0.0;// u_specularTint;
    mv.metallic = 0.2;// u_metallic;
    mv.sheen = 0.3;// u_sheen;
    mv.sheenTint = 0.1;//u_sheenTint;
    mv.roughness = 0.7;//u_roughness;
    mv.anisotropic = 0.0;// u_anisotropic;
    mv.clearcoat = 0.8;//u_clearcoat;
    mv.clearcoatGloss = 0.5;//u_clearcoatGloss;
    mv.subsurface = 0;//u_subsurface;
    return mv;
DerivedShadingValues derivedShadingValues(MaterialValues mv, ShadingValues sv) {
    DerivedShadingValues dsv;
    dsv.H = normalize(sv.L + sv.V);
    dsv.reflected = reflect(-sv.V, sv.N);
    dsv.NdotL = max(0.0, dot(sv.N, sv.L));
    dsv.NdotV = max(0.0, dot(sv.N, sv.V));
    dsv.NdotH = max(0.0, dot(sv.N, dsv.H));
    dsv.LdotH = max(0.0, dot(sv.L, dsv.H));
    dsv.FL = SchlickFresnel(dsv.NdotL);
    dsv.FV = SchlickFresnel(dsv.NdotV);
    dsv.FH = SchlickFresnel(dsv.LdotH);
    
    dsv.diffuseRoughness = mv.roughness;
    
    dsv.irradianceColor = vec3(0.4,0.4,0.4);// srgbToLinear(texture(irradianceSampler, dsv.reflected, mv.roughness * 8.0)).xyz;
    dsv.reflectedColor = vec3(0.5,0.5,0.5);//srgbToLinear(texture(reflectiveEnvironmentSampler, dsv.reflected)).xyz;
    dsv.environmentColor = vec3(0.5,0.5,0.5);//srgbToLinear(texture(reflectiveEnvironmentSampler, dsv.reflected)).xyz;
    
    // add in a spot to represent the sun
    dsv.environmentColor += vec3(min(1.0, dsv.FL));
    return dsv;
vec3 diffuseOutput(MaterialValues mv, ShadingValues sv, DerivedShadingValues dsv) {
    // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing
    // and mix in diffuse retro-reflection based on roughness
    float Fd90 = 0.5 + 2.0 * sqr(dsv.LdotH) * dsv.diffuseRoughness;
    float Fd = mix(1.0, Fd90, dsv.FL) + mix(1.0, Fd90, dsv.FV);
    
    // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf
    // 1.25 scale is used to (roughly) preserve albedo
    // Fss90 used to "flatten" retroreflection based on roughness
    float Fss90 = sqr(dsv.LdotH) * dsv.diffuseRoughness;
    float Fss = mix(1.0, Fss90, dsv.FL) * mix(1.0, Fss90, dsv.FV);
    // 1.25 scale is used to (roughly) preserve albedo
    float ss = 1.25 * (Fss * (1.0 / (dsv.NdotL + dsv.NdotV) - 0.5) + 0.5);
    
    vec3 diffuseOutput = ((1.0/PI) * mix(Fd, ss, mv.subsurface) * mv.baseColor) * (1.0 - mv.metallic);
    return diffuseOutput;
vec3 clearcoatOutput(MaterialValues mv, ShadingValues sv, DerivedShadingValues dsv) {
    // clearcoat (ior = 1.5 -> F0 = 0.04)
    float Dr = GTR1(dsv.NdotH, mix(.6, 0.001, mv.clearcoatGloss));
    float Fr = mix(0.1, 0.4, dsv.FH);
    float clearcoatRoughness = sqr(dsv.diffuseRoughness * 0.5 + 0.5);
    float Gr = smithG_GGX(dsv.NdotL, clearcoatRoughness) * smithG_GGX(dsv.NdotV, clearcoatRoughness);
    
    vec3 clearcoatOutput = mv.clearcoat * Gr * Fr * Dr * dsv.environmentColor;
    return clearcoatOutput;
vec3 specularOutput(MaterialValues mv, ShadingValues sv, DerivedShadingValues dsv) {
    //float specularRoughness = dsv.diffuseRoughness * (1.0 - mv.metallic) + mv.metallic;
    float specularRoughness = mv.roughness * 0.5 + 0.5;
    float aspect = sqrt(1.0 - mv.anisotropic * 0.9);
    //float alphaAniso = specularRoughness;
    float alphaAniso = sqr(specularRoughness);
    float ax = max(0.0001, alphaAniso / aspect);
    float ay = max(0.0001, alphaAniso * aspect);
    float Ds = GTR2_aniso(dsv.NdotH, dot(dsv.H, sv.shadingBasisX), dot(dsv.H, sv.shadingBasisY), ax, ay);
    vec3 Cspec0 = mv.specular * mix(vec3(1.0), mv.baseColorHueSat, mv.specularTint);
    vec3 Fs = mix(Cspec0, vec3(1), dsv.FH);
    float alphaG = sqr(specularRoughness * 0.5 + 0.5);
    float Gs = smithG_GGX(dsv.NdotL, alphaG) * smithG_GGX(dsv.NdotV, alphaG);
    
    vec3 specularOutput = (Ds * Gs * Fs * dsv.irradianceColor) * (1.0 + mv.metallic * mv.baseColor) + mv.metallic * dsv.irradianceColor * mv.baseColor;
    return specularOutput;
vec3 sheenOutput(MaterialValues mv, ShadingValues sv, DerivedShadingValues dsv) {
    vec3 Csheen = mix(vec3(1.0), mv.baseColorHueSat, mv.sheenTint);
    vec3 Fsheen = Csheen * dsv.FV * mv.sheen;
    
    vec3 light_color = vec3(9.0) * dsv.NdotL + (vec3(3.0) * dsv.irradianceColor * (1.0 - dsv.NdotL));
    //vec3 sheenOutput = Fsheen * (1.0 - mv.metallic);
    vec3 sheenOutput = Fsheen;
    return sheenOutput;
// Illuminate
// all input colors must be linear, not SRGB.
vec4 illuminate(int sampleNumber, float sampleDivisor,
                MaterialValues mv, ShadingValues sv, DerivedShadingValues dsv) {
    
    // DIFFUSE
    // 2pi to integrate the entire dome, 0.5 as intensity
    vec3 light_color = vec3(2.0 * PI * 0.3) * (dsv.NdotL + dsv.irradianceColor * (1.0 - dsv.NdotL) * mv.aoValue);
    vec3 diffuseOut = diffuseOutput(mv, sv, dsv) * light_color;
    
    // AMBIENCE
    const float environmentContribution = 0.0;
    vec3 ambienceOutput = mv.baseColor * dsv.environmentColor * environmentContribution * mv.aoValue;
    
    // CLEARCOAT
    vec3 clearcoatOut = clearcoatOutput(mv, sv, dsv);
    
    // SPECULAR
    vec3 specularOut = specularOutput(mv, sv, dsv);
    
    // SHEEN
    vec3 sheenOut = sheenOutput(mv, sv, dsv) * light_color;
    
    return vec4(diffuseOut + ambienceOutput + clearcoatOut + specularOut + sheenOut, 1);
// ---- END ----
#endif
vec4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    vec4 color = vec4(0.,0.,0., surface.diffuse.a);
    
    vec3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    D += lighting.ambient * surface.ambient.rgb;
#elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
    D += lighting.ambient;
#endif
#endif //  defined(USE_AMBIENT_LIGHTING)
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    
    // Do we want to clamp there ????
    
    color.rgb = surface.diffuse.rgb * D;
#if 1 // NEW_REFLECTIVE_BEHAVIOR
#ifdef USE_SPECULAR
    vec3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    vec3 S = vec3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambient.rgb;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif // NEW_REFLECTIVE_BEHAVIOR
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
struct SCNOutput
    vec4 color;
} _output;
void main(void)
#ifdef USE_TEXCOORD
__DoTexcoord__
#endif
#ifdef USE_AMBIENT_MAP
    _surface.ambient = texture2D(u_ambientTexture, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambient.rgb = mix(vec3(1.), _surface.ambient.rgb, u_ambientIntensity);
#else
    _surface.ambient.rgb *= u_ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = u_ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = vec4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= v_vertexColor;
#endif
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = texture2D(u_diffuseTexture, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = u_diffuseColor;
#elif defined(USE_DIFFUSE)
    _surface.diffuse = vec4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= v_vertexColor;
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = texture2D(u_specularTexture, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular.rgb *= u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = u_specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = vec4(0.);
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = texture2D(u_emissionTexture, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission.rgb *= u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = u_emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = vec4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = texture2D(u_multiplyTexture, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply.rgb = mix(vec3(1.), _surface.multiply.rgb, u_multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = u_multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = vec4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = texture2D(u_transparentTexture, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = u_transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = vec4(1.);
#endif
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(v_normal.xyz) * u_orientationPreserved * ((float(gl_FrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(v_normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = v_bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = v_position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-v_position);
#endif
#ifdef USE_NORMAL_MAP
    mat3 ts2vs = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = texture2D(u_normalTexture, _surface.normalTexcoord).rgb * 2. - 1.;
    // _surface.normal.z = 1. - sqrt(_surface.normal.x * _surface.normal.x + _surface.normal.y * _surface.normal.y);
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(vec3(0., 0., 1.), _surface._normalTS, u_normalIntensity);
#endif
    // transform the normal in view space
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = vec3(0., 0., 0.);
#endif
#ifdef USE_REFLECTIVE_MAP
    vec3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = texture2D(u_reflectiveTexture,vec2(vec2(refl.x,-refl.y) / m) + 0.5) ;
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    vec3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = textureCube(u_reflectiveTexture, mat3(u_viewToCubeWorld) * refl); // sample the cube map in world space
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = u_reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = vec4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = u_fresnel.x + u_fresnel.y * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), u_fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = u_materialShininess;
#endif
    
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    // Lighting
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = u_ambientLightColor.rgb;
#elif defined(USE_AMBIENT)
    _lightingContribution.ambient = vec3(0.);
#endif
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    _lightingContribution.diffuse = sh2_evaluate_diffuse(mat3(u_viewToCubeWorld) * _surface.normal);
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    _lightingContribution.diffuse = shEvalDirection(vec4(mat3(u_viewToCubeWorld) * _surface.normal, 1.));
#else
    _lightingContribution.diffuse = vec3(0.);
#endif
    
#ifdef USE_MODULATE
    _lightingContribution.modulate = vec3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = vec3(0.);
#endif
__DoLighting__
#else // USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = v_diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = v_specular;
#endif
#endif
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = clamp(_lightingContribution.diffuse, vec3(0.), vec3(1.));
#ifdef USE_SPECULAR
    _lightingContribution.specular = clamp(_lightingContribution.specular, vec3(0.), vec3(1.));
#endif // USE_SPECULAR
#endif // AVOID_OVERLIGHTING
#else // USE_LIGHTING
    _lightingContribution.diffuse = vec3(1.);
#endif // USE_LIGHTING
    
    // Combine
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * u_fogParameters.x + u_fogParameters.y, 0., u_fogColor.a), u_fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, u_fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
#ifdef USE_TRANSPARENT // Either a map or a color
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= u_transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= u_nodeOpacity;
#endif
    // compute luminance
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (vec4(1.) - _surface.transparent);
#else // ALPHA_ONE
    _output.color *= _surface.transparent.a;
#endif
#else
#ifdef USE_TRANSPARENCY // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
    _output.color *= u_transparency;
#endif
#endif
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) // we could set a different limit here
        discard;
#endif
    
#ifdef C3D_USE_PBR
    vec3 lightPosition = vec3(0.1, 0.9, 0.0);
    vec3 surfacePos = _surface.position;
    vec3 cameraPos = _surface.view;
    vec3 surfaceToCamera = normalize(cameraPos - surfacePos);
    vec3 surfaceToLight = normalize(lightPosition);
    
    vec3 X = normalize(dFdx(_surface.position));
    vec3 Y = normalize(cross(X, _surface.normal));
    
    vec4 surfaceColor = _surface.diffuse;//srgbToLinear(texture(baseColorTexture, varTexcoord, 0.0) * u_baseColor);
#if defined(USE_MULTIPLY_MAP) || defined(USE_MULTIPLY_INTENSITY) || defined(USE_MULTIPLY_COLOR)
    MaterialValues mv = materialValues(_surface.diffuse, _surface.multiply, vec2(0));
#else
    MaterialValues mv = materialValues(_surface.diffuse, vec4(1), vec2(0));
#endif
    
    ShadingValues sv;
    sv.surfacePosition = surfacePos;
    sv.N = _surface.normal;
    sv.V = surfaceToCamera;
    sv.L = surfaceToLight;
    sv.shadingBasisX = X;
    sv.shadingBasisY = Y;
    
    DerivedShadingValues dsv = derivedShadingValues(mv, sv);
    
    vec4 final_output = illuminate(0, 1.0, mv, sv, dsv);
    
    gl_FragColor = final_output;//clamp(linearToSrgba(final_output), 0.0, 1.0);
    
#else
    
    gl_FragColor = _output.color;
    
#endif
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(textureSampler0,TexCoord) + texture2D(textureSampler1,TexCoord);
uniform mat4 u_modelViewProjectionTransform;
attribute vec4 a_position;
attribute vec4 a_color;
varying vec3 v_vertexCenter;
void main()
    vec3 pos = a_position.xyz;
    int id = int(a_position.w); //  Position stores the vertex ID in the current triangle. Yup, a bit ugly.
    gl_Position = (u_modelViewProjectionTransform * vec4(pos, 1.0));
    
    float s = 1.;
    mat3 centers = mat3(vec3(s, 0. ,0.), vec3(0., s, 0.), vec3(0., 0., s));
    v_vertexCenter = centers[id];
void main (void)
gl_FragColor =
vec4(1.0,0.0,1.0,1.0);
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord);
attribute vec3 a_position;
varying vec2 TexCoord;
void main(void)
gl_Position = vec4(a_position, 1.0);
TexCoord = (a_position.xy + 1.0) * 0.5;
attribute vec4 a_position;
varying vec2 v_texCoord;
void main(void)
gl_Position = a_position;
    v_texCoord = (a_position.xy + 1.0) * 0.5;
#import <metal_stdlib>
using namespace metal;
// Include do not work in online compilation...
//#import <SceneKit/scn_metal>
// All this declarations should be in the "scn_metal" file
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3,
    SCNVertexSemanticTexcoord4,
    SCNVertexSemanticTexcoord5,
    SCNVertexSemanticTexcoord6,
    SCNVertexSemanticTexcoord7
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; // transform from view space to world space
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; // transform from view space to cube texture space (canonical Y Up space)
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; // x:-1/(end-start) y:1-start*x z:exp
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
// end "scn_metal"
// Tool function
inline float3x3 mat3(float4x4 mat4)
    return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);
inline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
inline float shadow2DProj(depth2d<float> tex, float4 uv)
    constexpr sampler linear_sampler(filter::linear, mip_filter::none, compare_func::greater_equal);
    //constexpr sampler linear_sampler(filter::linear, mip_filter::none, compare_func::none);
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(linear_sampler, uvp.xy, uvp.z);
// these are SH coef for a single component
struct sh2_vector
    float4 V;
struct sh3_vector
    float4 V0;
    float4 V1;
    float V2;
// these are packed SH3 for RGB components
struct sh2_coefficients
    sh2_vector R;
    sh2_vector G;
    sh2_vector B;
#define USE_PACKED_SH3 1
#if USE_PACKED_SH3
struct sh3_coefficients
    float4 ar;
    float4 ag;
    float4 ab;
    float4 br;
    float4 bg;
    float4 bb;
    float4 c;
#else
struct sh3_coefficients
    sh3_vector R;
    sh3_vector G;
    sh3_vector B;
#endif
constant half PI = 3.141592653f;
inline half sh3_dot(sh3_vector A,sh3_vector B)
    half Result = dot(A.V0, B.V0);
    Result += dot(A.V1, B.V1);
    Result += A.V2 * B.V2;
    return Result;
inline half3 sh3_dot(sh3_coefficients A,sh3_vector B)
    half3 Result = 0;
    sh3_vector rsh;
    rsh.V0 = A.ar;
    rsh.V1 = A.br;
    rsh.V2 = A.c.x;
    sh3_vector gsh;
    gsh.V0 = A.ag;
    gsh.V1 = A.bg;
    gsh.V2 = A.c.y;
    sh3_vector bsh;
    bsh.V0 = A.ab;
    bsh.V1 = A.bb;
    bsh.V2 = A.c.z;
    Result.r = sh3_dot(rsh,B);
    Result.g = sh3_dot(gsh,B);
    Result.b = sh3_dot(bsh,B);
    return Result;
inline half3 sh2_dot(sh2_coefficients A,sh2_vector B)
    half3 Result = 0;
    Result.r = dot(A.R.V, B.V);
    Result.g = dot(A.G.V, B.V);
    Result.b = dot(A.B.V, B.V);
    return Result;
inline sh2_vector sh2_basis(half3 dir)
    sh2_vector res;
    res.V.x = 0.282095f;
    res.V.y = -0.488603f * dir.y;
    res.V.z = 0.488603f * dir.z;
    res.V.w = -0.488603f * dir.x;
    return res;
inline sh3_vector sh3_basis(half3 dir)
    sh3_vector res;
    res.V0.x = 0.282095f;
    res.V0.y = -0.488603f * dir.y;
    res.V0.z = 0.488603f * dir.z;
    res.V0.w = -0.488603f * dir.x;
    
    half3 VectorSquared = dir * dir;
    res.V1.x = 1.092548f * dir.x * dir.y;
    res.V1.y = -1.092548f * dir.y * dir.z;
    res.V1.z = 0.315392f * (3.0f * VectorSquared.z - 1.0f);
    res.V1.w = -1.092548f * dir.x * dir.z;
    res.V2 = 0.546274f * (VectorSquared.x - VectorSquared.y);
    return res;
inline sh2_vector sh2_compute_diffuse_transfer(half3 normal, half Exponent)
    sh2_vector res = sh2_basis(normal);
    half L0 = 2 * PI / (1 + 1 * Exponent);
    half L1 = 2 * PI / (2 + 1 * Exponent);
    res.V.x *= L0;
    res.V.yzw *= L1;
    return res;
inline sh3_vector sh3_compute_diffuse_transfer(half3 normal, half Exponent)
    sh3_vector res = sh3_basis(normal);
    half L0 =
2 * PI / (1 + 1 * Exponent
    half L1 =
2 * PI / (2 + 1 * Exponent
    half L2 = Exponent *
2 * PI / (3 + 4 * Exponent + Exponent * Exponent
    res.V0.x *= L0;
    res.V0.yzw *= L1;
    res.V1.xyzw *= L2;
    res.V2 *= L2;
    return res;
#if (USE_PROBES_LIGHTING == 2)
inline float3 shEvalDirection(float4 dir, sh2_coefficients cachedSH)
    const float Exponent = 1;
    
    // Compute SH for the normal
    sh2_vector diffSH = sh2_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    // Compute lighting for this SH directions
    half3 lighting = max(half3(0,0,0), sh2_dot(cachedSH, diffSH)) / PI;
    
    //    lighting = half3(diffSH.V0.yzw * 0.5 + 0.5);
    
    return float3(lighting);
#elif (USE_PROBES_LIGHTING == 3)
#if USE_PACKED_SH3
inline float3 shEvalDirection(float4 dir, sh3_coefficients sh)
    float3 x1, x2, x3;
    
    // Linear + constant polynomial terms
    x1.r = dot(sh.ar, dir);
    x1.g = dot(sh.ag, dir);
    x1.b = dot(sh.ab, dir);
    
    // 4 of the quadratic polynomials
    float4 vB = dir.xyzz * dir.yzzx;
    x2.r = dot(sh.br, vB);
    x2.g = dot(sh.bg, vB);
    x2.b = dot(sh.bb, vB);
    
    // Final quadratic polynomial
    float vC = dir.x * dir.x - dir.y * dir.y;
    x3 = sh.c.xyz * vC;
    
    return x1 + x2 + x3;
#else
inline float3 shEvalDirection(float4 dir, sh3_coefficients cachedSH)
    const float Exponent = 1;
    
    // Compute SH for the normal
    sh3_vector diffSH = sh3_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    // Compute lighting for this SH directions
    half3 lighting = max(half3(0,0,0), DotSH3(cachedSH, diffSH)) / PI;
    
    //    lighting = half3(diffSH.V0.yzw * 0.5 + 0.5);
    
    return float3(lighting);
#endif // USE_PACKED_SH3
#endif // USE_PROBES_LIGHTING
// Inputs
typedef struct {
#ifdef USE_MODELTRANSFORM
    float4x4 modelTransform;
#endif
#ifdef USE_INVERSEMODELTRANSFORM
    float4x4 inverseModelTransform;
#endif
#ifdef USE_MODELVIEWTRANSFORM
    float4x4 modelViewTransform;
#endif
#ifdef USE_INVERSEMODELVIEWTRANSFORM
    float4x4 inverseModelViewTransform;
#endif
#ifdef USE_NORMALTRANSFORM
    float4x4 normalTransform;
#endif
#ifdef USE_MODELVIEWPROJECTIONTRANSFORM
    float4x4 modelViewProjectionTransform;
#endif
#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM
    float4x4 inverseModelViewProjectionTransform;
#endif
#ifdef USE_BOUNDINGBOX
    float2x3 boundingBox;
#endif
#ifdef USE_WORLDBOUNDINGBOX
    float2x3 worldBoundingBox;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    float orientationPreserved;
#endif
#ifdef USE_SKINNING
    float4 skinningJointMatrices[60]; // Consider having a separate buffer ?
#endif
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    sh2_coefficients shCoefficients;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    sh3_coefficients shCoefficients;
#endif
    
} commonprofile_node;
typedef struct {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
    float4 color            [[attribute(SCNVertexSemanticColor)]];
    float4 skinningWeights  [[attribute(SCNVertexSemanticBoneWeights)]];
    uint4  skinningJoints   [[attribute(SCNVertexSemanticBoneIndices)]];
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];
    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];
    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];
    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];
} commonprofile_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 fragmentPosition [[position]]; // The window relative coordinate (x, y, z, 1/w) values for the fragment
#ifdef USE_VERTEX_COLOR
    float4 vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
    float3 diffuse;
#ifdef USE_SPECULAR
    float3 specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    float3 position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
    float3 normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    float3 tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    float3 bitangent;
#endif
#ifdef USE_TEXCOORD
    __TexcoordDecl__
#endif
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                // Direction from the point on the surface toward the camera (V)
    float3 position;            // Position of the fragment
    float3 normal;              // Normal of the fragment (N)
    float2 normalTexcoord;      // Normal texture coordinates
    float3 tangent;             // Tangent of the fragment
    float3 bitangent;           // Bitangent of the fragment
    float4 ambient;             // Ambient property of the fragment
    float2 ambientTexcoord;     // Ambient texture coordinates
    float4 diffuse;             // Diffuse property of the fragment. Alpha contains the opacity.
    float2 diffuseTexcoord;     // Diffuse texture coordinates
    float4 specular;            // Specular property of the fragment
    float2 specularTexcoord;    // Specular texture coordinates
    float4 emission;            // Emission property of the fragment
    float2 emissionTexcoord;    // Emission texture coordinates
    float4 multiply;            // Multiply property of the fragment
    float2 multiplyTexcoord;    // Multiply texture coordinates
    float4 transparent;         // Transparent property of the fragment
    float2 transparentTexcoord; // Transparent texture coordinates
    float4 reflective;          // Reflective property of the fragment
    float shininess;            // Shininess property of the fragment.
    float fresnel;              // Fresnel property of the fragment.
    float3 _normalTS;           // UNDOCUMENTED in tangent space
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
        D += lighting.ambient * surface.ambient.rgb;
    #elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
        D += lighting.ambient;
    #endif
#endif //  defined(USE_AMBIENT_LIGHTING)
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    // Do we want to clamp there ????
    color.rgb = surface.diffuse.rgb * D;
#if 1 // NEW_REFLECTIVE_BEHAVIOR
#ifdef USE_SPECULAR
    float3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    float3 S = float3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambient.rgb;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif // NEW_REFLECTIVE_BEHAVIOR
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
// Structure to gather property of a light, packed to give access in a light shader modifier
struct SCNShaderLight {
    float4 intensity; // lowp, light intensity
    float3 direction; // mediump, vector from the point toward the light
    float  _att;
    float3 _spotDirection; // lowp, vector from the point to the light for point and spot, dist attenuations
    float  _distance; // mediump, distance from the point to the light (same coord. than range)
struct  commonprofile_lights {
#ifdef USE_LIGHTING
    __LightingDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float2 texcoords[8]; // MAX_UV
struct  commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    
    float materialShininess;
    float transparency;
    float3 fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
#ifdef TEXTURE_TRANSFORM_COUNT
    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
//    float4x4 u_viewToCubeWorld;
#endif
// Shader modifiers declaration (only enabled if one modifier is present)
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
// Vertex shader function
vertex commonprofile_io commonprofile_vert(commonprofile_vertex_t in [[ stage_in ]],
                                           constant SCNSceneBuffer& scn_frame [[buffer(0)]],
#ifdef USE_INSTANCING
                                           constant commonprofile_node* scn_node [[buffer(1)]]
                                           , uint instanceID [[ instance_id ]]
#else
                                           constant commonprofile_node& scn_node [[buffer(1)]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                           , constant commonprofile_lights& scn_lights [[buffer(2)]]
#endif
// used for texture transform and materialShininess in case of perVertexLighting
                                           , constant commonprofile_uniforms& scn_commonprofile [[buffer(3)]]
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
__VertexExtraArguments__
#endif
                                           )
    SCNShaderGeometry _geometry;
    // OPTIM in could be already float4?
    _geometry.position = float4(in.position, 1.0);
#ifdef USE_NORMAL
    _geometry.normal = in.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = in.tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = in.texcoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = in.texcoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = in.texcoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = in.texcoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = in.texcoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = in.texcoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = in.texcoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = in.texcoord7;
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = in.color;
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#ifdef USE_SKINNING
    {
        float3 pos = 0.0;
#ifdef USE_NORMAL
        float3 nrm = 0.0;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        float3 tgt = 0.0;
#endif
        for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
            float weight = 1.0;
#else
            float weight = in.skinningWeights[i];
#endif
            int idx = int(in.skinningJoints[i]) * 3;
            float4x4 jointMatrix = float4x4(scn_node.skinningJointMatrices[idx],
                                            scn_node.skinningJointMatrices[idx+1],
                                            scn_node.skinningJointMatrices[idx+2],
                                            float4(0., 0., 0., 1.));
            
            pos += (_geometry.position * jointMatrix).xyz * weight;
#ifdef USE_NORMAL
            nrm += _geometry.normal * mat3(jointMatrix) * weight;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * mat3(jointMatrix) * weight;
#endif
        }
        
        _geometry.position.xyz = pos;
#ifdef USE_NORMAL
        _geometry.normal = nrm;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = tgt;
#endif
    }
#endif
    
#ifdef USE_GEOMETRY_MODIFIER
// DoGeometryModifier START
__DoGeometryModifier__
// DoGeometryModifier END
#endif
    
#ifdef USE_INSTANCING
    constant commonprofile_node& node = scn_node[instanceID];
#else
    constant commonprofile_node& node = scn_node;
#endif
    
    // Transform the geometry elements in view space
#if defined(USE_POSITION) || defined(USE_NORMAL) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    _surface.position = (node.modelViewTransform * _geometry.position).xyz;
#endif
#ifdef USE_NORMAL
    _surface.normal = normalize(mat3(node.normalTransform) * _geometry.normal);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _surface.tangent = normalize(mat3(node.normalTransform) * _geometry.tangent.xyz);
    _surface.bitangent = /*_geometry.tangent.w **/ cross(_surface.tangent, _surface.normal); // no need to renormalize since tangent and normal should be orthogonal
    // old code : _surface.bitangent =  normalize(cross(_surface.normal,_surface.tangent));
#endif
    
    //if USE_VIEW is 2 we may also need to set _surface.view. todo: make USE_VIEW a mask
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    commonprofile_io out;
    
#ifdef USE_PER_VERTEX_LIGHTING
    // Lighting
    SCNShaderLightingContribution _lightingContribution;
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
__VertexDoLighting__
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
    
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
#ifdef USE_TEXCOORD
__VertexDoTexcoord__
#endif
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) // this means that the geometry are still in model space : we can transform it directly to NDC space
    out.fragmentPosition = node.modelViewProjectionTransform * _geometry.position;
#endif
    
    return out;
struct SCNOutput
    float4 color;
// Fragment shader function
fragment half4 commonprofile_frag(commonprofile_io in [[stage_in]],
                                  constant commonprofile_uniforms& scn_commonprofile [[buffer(0)]],
                                  constant SCNSceneBuffer& scn_frame [[buffer(1)]]
#ifdef USE_PER_PIXEL_LIGHTING
                                  , constant commonprofile_lights& scn_lights [[buffer(2)]]
#endif
#ifdef USE_EMISSION_MAP
                                  , texture2d<float> u_emissionTexture [[texture(0)]]
                                  , sampler          u_emissionTextureSampler [[sampler(0)]]
#endif
#ifdef USE_AMBIENT_MAP
                                  , texture2d<float> u_ambientTexture [[texture(1)]]
                                  , sampler          u_ambientTextureSampler [[sampler(1)]]
#endif
#ifdef USE_DIFFUSE_MAP
                                  , texture2d<float> u_diffuseTexture [[texture(2)]]
                                  , sampler          u_diffuseTextureSampler [[sampler(2)]]
#endif
#ifdef USE_SPECULAR_MAP
                                  , texture2d<float> u_specularTexture [[texture(3)]]
                                  , sampler          u_specularTextureSampler [[sampler(3)]]
#endif
#ifdef USE_REFLECTIVE_MAP
                                  , texture2d<float> u_reflectiveTexture [[texture(4)]]
                                  , sampler          u_reflectiveTextureSampler [[sampler(4)]]
#elif defined(USE_REFLECTIVE_CUBEMAP)
                                  , texturecube<float> u_reflectiveTexture [[texture(4)]]
                                  , sampler            u_reflectiveTextureSampler [[sampler(4)]]
#endif
#ifdef USE_TRANSPARENT_MAP
                                  , texture2d<float> u_transparentTexture [[texture(5)]]
                                  , sampler          u_transparentTextureSampler [[sampler(5)]]
#endif
#ifdef USE_MULTIPLY_MAP
                                  , texture2d<float> u_multiplyTexture [[texture(6)]]
                                  , sampler          u_multiplyTextureSampler [[sampler(6)]]
#endif
#ifdef USE_NORMAL_MAP
                                  , texture2d<float> u_normalTexture [[texture(7)]]
                                  , sampler          u_normalTextureSampler [[sampler(7)]]
#endif
                                  , constant commonprofile_node& scn_node [[buffer(3)]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
#if defined(USE_DOUBLE_SIDED)
                                  , bool isFrontFacing [[front_facing]]
#endif
                                  )
    SCNShaderSurface _surface;
#ifdef USE_TEXCOORD
__FragmentDoTexcoord__
#endif
#ifdef USE_AMBIENT_MAP
    _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambient.rgb = mix(float3(1.), _surface.ambient.rgb, scn_commonprofile.ambientIntensity);
#else
    _surface.ambient.rgb *= scn_commonprofile.ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = scn_commonprofile.ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = float4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= in.vertexColor;
#endif
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = scn_commonprofile.diffuseColor;
#else
    _surface.diffuse = float4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= in.vertexColor;
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular.rgb *= scn_commonprofile.specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = scn_commonprofile.specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = float4(0.);
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission.rgb *= scn_commonprofile.emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = scn_commonprofile.emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = float4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply.rgb = mix(float3(1.), _surface.multiply.rgb, scn_commonprofile.multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = scn_commonprofile.multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = float4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= scn_commonprofile.transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = scn_commonprofile.transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = float4(1.);
#endif
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(in.normal.xyz) * scn_node.orientationPreserved * ((float(isFrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(in.normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = in.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = in.bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = in.position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-in.position);
#endif
#ifdef USE_NORMAL_MAP
    float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb * 2. - 1.;
    // _surface.normal.z = 1. - sqrt(_surface.normal.x * _surface.normal.x + _surface.normal.y * _surface.normal.y);
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(float3(0., 0., 1.), _surface._normalTS, scn_commonprofile.normalIntensity);
#endif
    // transform the normal in view space
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = float3(0.);
#endif
    
#ifdef USE_REFLECTIVE_MAP
    float3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5);
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    float3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); // sample the cube map in world space
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = scn_commonprofile.reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = float4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.0 - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = scn_commonprofile.materialShininess;
#endif
    
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    // Lighting
    SCNShaderLightingContribution _lightingContribution = {0};
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
#ifdef USE_PROBES_LIGHTING
    _lightingContribution.diffuse = shEvalDirection(float4(scn::mat4_mult_float3(scn_frame.viewToCubeTransform, _surface.normal), 1.), scn_node.shCoefficients);
#else
    _lightingContribution.diffuse = float3(0.);
#endif
#ifdef USE_MODULATE
    _lightingContribution.modulate = float3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = float3(0.);
#endif
__FragmentDoLighting__
#else // USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = in.diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = in.specular;
#endif
#endif
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
#ifdef USE_SPECULAR
    _lightingContribution.specular = saturate(_lightingContribution.specular);
#endif // USE_SPECULAR
#endif // AVOID_OVERLIGHTING
#else // USE_LIGHTING
    _lightingContribution.diffuse = float3(1.);
#endif // USE_LIGHTING
    
    // Combine
    SCNOutput _output;
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
#ifdef USE_TRANSPARENT // Either a map or a color
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= scn_commonprofile.transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= scn_node.nodeOpacity;
#endif
    // compute luminance
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (float4(1.) - _surface.transparent);
#else // ALPHA_ONE
#ifdef USE_NODE_OPACITY
    _output.color *= (scn_node.nodeOpacity * _surface.transparent.a);
#else
    _output.color *= _surface.transparent.a;
#endif
#endif
#else
#ifdef USE_TRANSPARENCY // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
#ifdef USE_NODE_OPACITY
    _output.color *= (scn_node.nodeOpacity * scn_commonprofile.transparency);
#else
    _output.color *= scn_commonprofile.transparency;
#endif // NODE_OPACITY
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) // we could set a different limit here
        discard_fragment();
#endif
    
    return half4(_output.color);
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    v_tcColor0 = tc + vec2( -1.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcColor1 = tc + vec2( +0.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcDepth0 = tc + vec2( -2., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth1 = tc + vec2( -1., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth2 = tc + vec2( +0., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth3 = tc + vec2( +1., -2. ) * u_inversePixelSize * 0.25;
float hash(vec2 p)
    p  = fract(p * vec2(443.8975,397.2973));
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
#pragma body
float x = hash(u_modelTransform[3].xy);
_output.color = vec4(x+1./255.);
#import <metal_stdlib>
using namespace metal;
// Include do not work in online compilation...
//#import <SceneKit/scn_metal>
inline float3 mat4_mult_float3(float4x4 matrix, float3 src)
    float3 dst  =  src.xxx * matrix[0].xyz;
    dst         += src.yyy * matrix[1].xyz;
    dst         += src.zzz * matrix[2].xyz;
    return dst;
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; // transform from view space to world space
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; // transform from view space to cube texture space (canonical Y Up space)
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; // x:-1/(end-start) y:1-start*x z:exp
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    float       environmentIntensity;
// end of manual inclusion of scn_metal
/// Utils
constexpr sampler linear_sampler(filter::linear, mip_filter::nearest, address::clamp_to_edge);
#ifdef ENABLE_ORIENTATION_FREE
static float3x3 axisangle_to_matrix(float4 axis_angle)
    float c;
    float s = sincos(axis_angle.w, c);
    float t = 1. - c;
    
    float3x3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
    float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
#endif
#ifdef ENABLE_ANIMATION
constexpr sampler anim_sampler(filter::linear, mip_filter::nearest, address::repeat);
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
float4 ComputeUVS(float2 iNormUV, float iFrame, float4 iFrameSize)
    float4 outUV;
    
#if ENABLE_ANIMATION == CLAMP
    
    iFrame = clamp(iFrame, 0., iFrameSize.w - 1.); // clamp frame
    
    float intFrame;
    float frameFrac = modf(iFrame, intFrame);
    float2 frame;
    float intPart;
    frame.x = modf(intFrame * iFrameSize.x, intPart);
    frame.y = intPart * iFrameSize.y;
    
    outUV.xy = frame + iNormUV * iFrameSize.xy;
    outUV.w = frameFrac;
    outUV.z = step(0.9999, frame.x + iFrameSize.x); // next row or not
#elif ENABLE_ANIMATION == REPEAT
    
    float tmp = iFrame * iFrameSize.x;
    
    float2 frame;
    frame.y = tmp - fract(tmp);
    frame.x = fract(tmp) * iFrameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * iFrameSize.xy;
    outUV.w = frameFrac;
    outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
#else // AUTOREVERSE
    
    float invFrameCount = iFrameSize.x * iFrameSize.y;
    float normFrame = iFrame * invFrameCount;
    float lastFrame = iFrameSize.w - 1.;
    float frameIndex = fract(normFrame) * iFrameSize.w;
    if (fract(normFrame * 0.5) > 0.5) {
        frameIndex = (lastFrame-frameIndex);
    }
    
    frameIndex = clamp(frameIndex, 0., lastFrame); // clamp frame
    
    float tmp = frameIndex * iFrameSize.x;
    
    float2 frame;
    frame.y = tmp - fract(tmp);
    
    frame.x = fract(tmp) * iFrameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * iFrameSize.xy;
    
    outUV.w = frameFrac;
    outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
#endif
    return outUV;
#endif
typedef struct {
    // vertex data
    float2 texCoord1 [[attribute(SCNVertexSemanticTexcoord1)]]; // x:cornerX y:cornerY
    
    // instance data
    float4 position [[attribute(SCNVertexSemanticPosition)]]; // xyz: position, w:angle
    float3 texCoord0 [[attribute(SCNVertexSemanticTexcoord0)]]; // x:life y:size z:frame (texture animation)
    float4 color [[attribute(SCNVertexSemanticColor)]]; // particle color
#ifdef ENABLE_STRETCH
    float4 texCoord2 [[attribute(SCNVertexSemanticTexcoord2)]]; // velocity of the particle in .xyz
#elif defined(ENABLE_ORIENTATION_FREE)
    float4 texCoord2 [[attribute(SCNVertexSemanticTexcoord2)]]; // orientation in free mode as an axis angle
#endif
} particle_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 vertexColor;
#ifdef ENABLE_ANIMATION
    float3 uv0;
    float2 uv1;
#else
    float2 uv0;
#endif
#ifdef ENABLE_FOG
    float fogFactor;
#endif
#ifdef ENABLE_CUBE_MAP
    float3 normal;
#endif
} particle_io;
typedef struct {
    float4x4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
#if 0 // ENABLE_SOFT
    float u_eyeLinearZ;
#endif
#ifdef ENABLE_CUBE_MAP
    float u_fresnelExponent;
#endif
#ifdef ENABLE_STRETCH
    float u_stretchFactor;
#endif
#ifdef ENABLE_LIGHTING
    float3 u_lightPosition0; // in modelViewSpace already
    float4 u_lightColor0;
#endif
#ifdef ENABLE_ANIMATION
    float4 u_frameSize; // 1/dimX, 1/dimY, dimX, dimX*dimY
#endif
} particle_uniforms;
vertex particle_io particle_vert(particle_vertex_t in [[ stage_in ]],
#ifdef ENABLE_COLOR_RAMP
                                 texture2d<float> u_colorRamp [[texture(0)]],
#endif
                                 constant SCNSceneBuffer& scn_frame     [[buffer(0)]],
                                 constant particle_uniforms& scn_part   [[buffer(1)]])
    particle_io out;
    
    // transform the particle in view space
    float4 viewPos = scn_part.viewTransform * float4(in.position.xyz, 1);
    float3 N; // used for lighting and cubemaps
    
#ifdef ENABLE_STRETCH
    // compute the trail direction in viewSpace
    float4 viewDir = scn_part.viewTransform * float4(in.texCoord2.xyz, 0);
    viewDir *= scn_part.u_stretchFactor;
    
    // move the top vertices to the end of the trail
    viewPos.xyz += (in.texCoord1.y > 0.) ? viewDir.xyz : float3(0.);
    
    // compute the billboarding offsets
    //    float len = length(viewDir.xy);
    //    vec2 u = (len > 0.) ? viewDir.xy/len : vec2(0,1);
    float2 u = normalize(viewDir.xy); // divide by 0 seems to work.. otherwise replace by code commented beneath
    float2 r = float2(-u.y, u.x);
    float2 off = r * in.texCoord1.x + u * in.texCoord1.y ; // offset
    viewPos.xy += off * in.texCoord0.y; // * size
    
    N = normalize(float3(-off.x, -off.y, -2));
    
#else // ENABLE_STRETCH
    
    // TODO only rotate if needed (angle != 0)
    float cs;
    float sn = sincos(in.position.w, cs);
    // expand the quad corners
    float2 dir = { in.texCoord1.x * cs - in.texCoord1.y * sn,  in.texCoord1.y * cs + in.texCoord1.x * sn };
    dir *= in.texCoord0.y;
    
#ifdef ENABLE_ORIENTATION_FREE
    // TODO : we should work in world space then ? the transform is in worldSpace or localSpace...
    // TODO with version 120 we would not need this....
    float3x3 vt = float3x3(scn_part.viewTransform[0].xyz, scn_part.viewTransform[1].xyz, scn_part.viewTransform[2].xyz);
    float3x3 mat = vt * axisangle_to_matrix(in.texCoord2); // mat3(viewTransform)
    
#ifdef ENABLE_CUBE_MAP
    N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
    viewPos.xy += dir;
#else
    float3 off = mat[0] * dir.x + mat[1] * dir.y;
    viewPos.xyz += off;
#endif
    
    // TODO we should also tranform the normal for the lighting !!!!!
    
#elif defined(ENABLE_BILLBOARD_VIEW)
    float3 u = float3(0,1,0);
    float3 r = normalize(cross(u, -viewPos.xyz));
    float3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
    
#elif defined(ENABLE_BILLBOARD_Y)
    float3 u = (scn_part.viewTransform * float4(0, 1, 0, 0)).xyz;
    float3 r = normalize(cross(u, float3(0,0,1))); // Screen Aligned
    //    vec3 r = normalize(cross(u, -viewPos.xyz)); // ViewAligned
    float3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
    
#else // defined(ENABLE_BILLBOARD_SCREEN)
    viewPos.xy += dir;
    N = normalize(float3(-dir.x, -dir.y, -2));
    
#endif // ENABLE_ORIENTATION_FREE
    
#endif // ENABLE_STRETCH
    
#ifdef ENABLE_CUBE_MAP
#ifdef ENABLE_ORIENTATION_FREE
    out.normal.xyz = N;
#else
    float3 refl = reflect( viewPos.xyz, N );
    out.normal.xyz = mat4_mult_float3(scn_frame.viewToCubeTransform, refl);
#endif // ENABLE_ORIENTATION_FREE
#endif
    
#ifdef ENABLE_COLOR_RAMP
    constexpr sampler ramp_sampler(filter::linear, mip_filter::none, address::clamp_to_edge);
    out.vertexColor = in.color * u_colorRamp.sample(ramp_sampler, in.texCoord0.xx);
#else // use vertex color (TODO : use constant color if needed)
    out.vertexColor = in.color;
#endif
    
#ifndef ENABLE_BLACKPASS
    #ifdef ENABLE_LIGHTING
        float3 L = normalize(viewPos.xyz - scn_part.u_lightPosition0);
        
        #if defined(ENABLE_ORIENTATION_FREE) && !defined(ENABLE_CUBE_MAP)
            // if we want to bend the normal (but free orientation doesn't need too right ?)
            // vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? -normalize(-mat[2] + 0.1 * off) : -normalize(mat[2] + 0.1 * off);
            //    vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? mat[2] : -mat[2];
            N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
            
            // simple lambertian + back light diffusion
            float NdotL = dot(N, L);
            //    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * max(0., -NdotL));
            float3 diff = scn_part.u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
            
            // Specular
            float _shininess = 100.0;
            float3 halfVector = normalize(L + viewPos.xyz);
            float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
            out.vertexColor.rgb = out.vertexColor.rgb * diff + spec;
        #else
            // simple lambertian
            float3 diff = float3(max(0.0, dot(N, L))) * scn_part.u_lightColor0.rgb;
            
            // trilight model (lambertian + wrap around + hemispheric)
            //vec3 diff = lightColor0 * max(0., NdotL) + lightColor1 * (1. - abs(NdotL)) + lightColor2 * max(0., -NdotL);
            
            // todo : support ambient !!!!!!!!!!
            // diff += vec3(0.5);
            
            out.vertexColor.rgb *= diff;
        #endif // ENABLE_ORIENTATION_FREE
    #endif // ENABLE_LIGHTING
#endif // ENABLE_BLACKPASS
    
    // TexCoord
#ifdef ENABLE_ANIMATION
    float4 animUVS = ComputeUVS(in.texCoord1.xy * float2(0.5, -0.5) + 0.5, in.texCoord0.z, scn_part.u_frameSize);
    out.uv0 = animUVS.xyw;
    out.uv1 = animUVS.xy + scn_part.u_frameSize.xy * float2(1.0, animUVS.z);// + float2(-animUVS.z, 0); add this if you don't want wrap behavior in the sampler
#else
    out.uv0 = in.texCoord1.xy * float2(0.5, -0.5) + 0.5;
#endif
    
#ifndef ENABLE_BLACKPASS
#ifdef ENABLE_FOG
    out.fogFactor = pow(clamp(abs(viewPos.z) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0.0, scn_frame.fogColor.a), scn_frame.fogParameters.z);
#endif // ENABLE_FOG
#endif // ENABLE_BLACKPASS
    
#if 0 // ENABLE_SOFT
    out.eyeLinearZ = viewPos.z;
#endif
    
    out.position = scn_frame.projectionTransform * viewPos;
    return out;
// Fragment shader function
#if 0 // ENABLE_SOFT
uniform sampler2D u_depthSampler0;
uniform vec4 u_softParameters; // x: scale, y: power/contrast, zw : 1/viewPortSize
uniform mat4 u_invProj; // inverse of the projection transform, to reconstruct viewPos from screenPos
varying float v_eyeLinearZ;
float ComputeSoftFactor()
    vec2 normalizedFragCoord = gl_FragCoord.xy * u_softParameters.zw;
    float depthValue = texture2D(u_depthSampler0, gl_FragCoord.xy * u_softParameters.zw).x;
    
    vec3 screenPos = vec3(normalizedFragCoord, depthValue);
    vec4 viewPos = u_invProj * vec4(screenPos * 2. - 1., 1.);
    viewPos /= viewPos.w;
    
    float factor = clamp((v_eyeLinearZ - viewPos.z) * u_softParameters.x ,0. , 1.);
    
    // Do we really need this pow?
    // factor = pow(factor, u_softParameters.y);
    
    return factor;
#endif
fragment half4 particle_frag(particle_io in [[stage_in]],
                             constant particle_uniforms& pass [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame     [[buffer(1)]],
#ifdef ENABLE_CUBE_MAP
                             texturecube<float> u_textureSampler0 [[texture(0)]]
#else
                             texture2d<float> u_textureSampler0 [[texture(0)]]
#endif
                             )
#ifdef ENABLE_CUBE_MAP
    float2 p = in.uv0.xy * 2. - 1.;
    float r = dot(p,p); // len^2
    //    vec4 tex = vec4(normalize(v_normal.xyz), 1.) * step(r, 1.);
    float4 tex = u_textureSampler0.sample(linear_sampler, in.normal.xyz) * saturate(9.6 - 10. * r);
    // fresnel modulation
    tex.rgb *= pow(r, pass.u_fresnelExponent);
#else // ENABLE_CUBE_MAP
#ifdef ENABLE_ANIMATION // blend between two frames
    float4 tex = mix(u_textureSampler0.sample(anim_sampler, in.uv0.xy),
                   u_textureSampler0.sample(anim_sampler, in.uv1.xy), in.uv0.z);
#else
    float4 tex = u_textureSampler0.sample(linear_sampler, in.uv0.xy);
    
#endif // ENABLE_ANIMATION
#endif // ENABLE_CUBE_MAP
#if 0 // ENABLE_SOFT
    tex *= ComputeSoftFactor();
#endif
    
    float4 fragColor;
#ifdef ENABLE_CUBE_MAP
    fragColor.a = in.vertexColor.a * tex.a; // texture and colors need to be premultiplied
#ifdef ENABLE_FOG
    fragColor.rgb = mix(in.vertexColor.rgb + tex.rgb, scn_frame.fogColor.rgb, in.fogFactor) * fragColor.a; // texture and colors need to be premultiplied
#else
    fragColor.rgb = (in.vertexColor.rgb + tex.rgb) * fragColor.a; // texture and colors need to be premultiplied
#endif // ENABLE_FOG
#else
    fragColor = in.vertexColor * tex; // texture and colors need to be premultiplied
#ifdef ENABLE_FOG
    fragColor.rgb = mix(fragColor.rgb, scn_frame.fogColor.rgb * fragColor.a, in.fogFactor); // fog needs to be premultiplied too
#endif // ENABLE_FOG
#endif
    return half4(fragColor);
uniform mat4 u_modelViewProjectionTransform;
uniform mat4 u_transform;
uniform vec4 u_color;
attribute vec3 a_position;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * u_transform * vec4(a_position, 1.);
    v_vertexColor = u_color;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2  offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
const float alphaThreshold = 0.9;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    float total = 0.0;
    for(i=0;i<n_sample;i++){
        vec4 c = texture2D(textureSampler0, TexCoord+offsets[i]);
        c.rgb *= c.a;
        accum += c * weights[i];
        total += weights[i] * c.a;
    }
    accum /= total;
gl_FragColor = accum;
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR",
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
attribute vec4 a_position;
varying vec2 uv;
void main(void)
gl_Position = a_position;
    uv = (a_position.xy + 1.0) * 0.5;
#import <simd/simd.h>
#ifdef __cplusplus
using namespace simd;
// Should we do uniforms buffers per light type ?
// would be cleaner...
struct LightData {
    float4 positionVS_invSquareRadius; // needed for attenuation windowing
    float4 color_unscaledRadius; // needed for vertices expansion
    float4 direction_tanConeAngle; // only valid for directional lights and spot lights
    float2 spotAttenuation; // only valid for spot lights
    // should move in the SceneBuffer
    float4x4 invProjectionTransform;
struct commonprofile_uniforms_ds {
    
    float4 diffuseIntensity;
    float4 emissionIntensity;
    
    float ambientIntensity;
    float normalIntensity;
    float roughnessIntensity;
    float metalnessIntensity;
    
    float3x2 diffuseTransform;
    float3x2 ambientTransform;
    float3x2 emissionTransform;
    float3x2 normalTransform;
    
#endif
attribute vec4 a_position;
varying vec2 uv;
void main(void)
    gl_Position = a_position;
    uv = (a_position.xy + 1.0) * 0.5;
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
layout(std140) uniform Transform {
    mat4 ModelViewMatrix;
    mat4 ProjectionMatrix;
    mat4 ModelViewProjectionMatrix;
    mat4 ModelViewInverseMatrix;
//--------------------------------------------------------------
// Vertex Shader
//--------------------------------------------------------------
#ifdef VERTEX_SHADER
layout (location=0) in vec4 position;
out vec4 vPosition;
#ifdef VARYING_COLOR
layout (location=1) in vec3 color;
out vec3 vColor;
#endif
void main()
    vPosition = ModelViewMatrix * position;
#ifdef VARYING_COLOR
    vColor = color;
#endif
#endif
//--------------------------------------------------------------
// Geometry Shader
//--------------------------------------------------------------
#ifdef GEOMETRY_SHADER
#ifdef PRIM_QUAD
    layout(lines_adjacency) in;
    #define EDGE_VERTS 4
#endif // PRIM_QUAD
#ifdef  PRIM_TRI
    layout(triangles) in;
    #define EDGE_VERTS 3
#endif // PRIM_TRI
    layout(triangle_strip, max_vertices = EDGE_VERTS) out;
    in vec4 vPosition[EDGE_VERTS];
#ifdef VARYING_COLOR
    in vec3 vColor[EDGE_VERTS];
#endif
out vec4 gPosition;
out vec3 gNormal;
noperspective out vec4 gEdgeDistance;
#ifdef VARYING_COLOR
    out vec3 gColor;
#endif
void emit(int index, vec3 normal)
    gPosition = vPosition[index];
#ifdef SMOOTH_NORMALS
    gNormal = vNormal[index];
#else
    gNormal = normal;
#endif
#ifdef VARYING_COLOR
    gColor = vColor[index];
#endif
    gl_Position = ProjectionMatrix * vPosition[index];
    EmitVertex();
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
const float VIEWPORT_SCALE = 1024.0; // XXXdyu
float edgeDistance(vec4 p, vec4 p0, vec4 p1)
    return VIEWPORT_SCALE *
        abs((p.x - p0.x) * (p1.y - p0.y) -
            (p.y - p0.y) * (p1.x - p0.x)) / length(p1.xy - p0.xy);
void emit(int index, vec3 normal, vec4 edgeVerts[EDGE_VERTS])
    gEdgeDistance[0] =
        edgeDistance(edgeVerts[index], edgeVerts[0], edgeVerts[1]);
    gEdgeDistance[1] =
        edgeDistance(edgeVerts[index], edgeVerts[1], edgeVerts[2]);
#ifdef PRIM_TRI
    gEdgeDistance[2] =
        edgeDistance(edgeVerts[index], edgeVerts[2], edgeVerts[0]);
#endif
#ifdef PRIM_QUAD
    gEdgeDistance[2] =
        edgeDistance(edgeVerts[index], edgeVerts[2], edgeVerts[3]);
    gEdgeDistance[3] =
        edgeDistance(edgeVerts[index], edgeVerts[3], edgeVerts[0]);
#endif
    emit(index, normal);
#endif
void main()
    gl_PrimitiveID = gl_PrimitiveIDIn;
#ifdef PRIM_POINT
    emit(0, vec3(0));
#endif
    
#ifdef PRIM_QUAD
    vec3 A = (vPosition[0] - vPosition[1]).xyz;
    vec3 B = (vPosition[3] - vPosition[1]).xyz;
    vec3 C = (vPosition[2] - vPosition[1]).xyz;
    vec3 n0 = normalize(cross(B, A));
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
    vec4 edgeVerts[EDGE_VERTS];
    edgeVerts[0] = ProjectionMatrix * vPosition[0];
    edgeVerts[1] = ProjectionMatrix * vPosition[1];
    edgeVerts[2] = ProjectionMatrix * vPosition[2];
    edgeVerts[3] = ProjectionMatrix * vPosition[3];
    edgeVerts[0].xy /= edgeVerts[0].w;
    edgeVerts[1].xy /= edgeVerts[1].w;
    edgeVerts[2].xy /= edgeVerts[2].w;
    edgeVerts[3].xy /= edgeVerts[3].w;
    emit(0, n0, edgeVerts);
    emit(1, n0, edgeVerts);
    emit(3, n0, edgeVerts);
    emit(2, n0, edgeVerts);
#else
    emit(0, n0);
    emit(1, n0);
    emit(3, n0);
    emit(2, n0);
#endif
#endif // PRIM_QUAD
#ifdef PRIM_TRI
    vec3 A = (vPosition[1] - vPosition[0]).xyz;
    vec3 B = (vPosition[2] - vPosition[0]).xyz;
    vec3 n0 = normalize(cross(B, A));
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
    vec4 edgeVerts[EDGE_VERTS];
    edgeVerts[0] = ProjectionMatrix * vPosition[0];
    edgeVerts[1] = ProjectionMatrix * vPosition[1];
    edgeVerts[2] = ProjectionMatrix * vPosition[2];
    edgeVerts[0].xy /= edgeVerts[0].w;
    edgeVerts[1].xy /= edgeVerts[1].w;
    edgeVerts[2].xy /= edgeVerts[2].w;
    emit(0, n0, edgeVerts);
    emit(1, n0, edgeVerts);
    emit(2, n0, edgeVerts);
#else
    emit(0, n0);
    emit(1, n0);
    emit(2, n0);
#endif
#endif // PRIM_TRI
    EndPrimitive();
#endif
//--------------------------------------------------------------
// Fragment Shader
//--------------------------------------------------------------
#ifdef FRAGMENT_SHADER
in vec4 gPosition;
in vec3 gNormal;
noperspective in vec4 gEdgeDistance;
#ifdef VARYING_COLOR
    in vec3 gColor;
#endif
out vec4 outColor;
#define NUM_LIGHTS 2
struct LightSource {
    vec4 position;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
layout(std140) uniform Lighting {
    LightSource lightSource[NUM_LIGHTS];
uniform vec4 diffuseColor = vec4(1);
uniform vec4 ambientColor = vec4(1);
vec4
lighting(vec4 diffuse, vec3 Peye, vec3 Neye)
    vec4 color = vec4(0);
    for (int i = 0; i < NUM_LIGHTS; ++i) {
        vec4 Plight = lightSource[i].position;
        vec3 l = (Plight.w == 0.0)
                    ? normalize(Plight.xyz) : normalize(Plight.xyz - Peye);
        vec3 n = normalize(Neye);
        vec3 h = normalize(l + vec3(0,0,1));    // directional viewer
        float d = max(0.0, dot(n, l));
        float s = pow(max(0.0, dot(n, h)), 500.0f);
        color += lightSource[i].ambient * ambientColor
            + d * lightSource[i].diffuse * diffuse
            + s * lightSource[i].specular;
    }
    color.a = 1;
    return color;
#ifdef PRIM_POINT
uniform vec4 fragColor;
void
main()
    outColor = fragColor;
#endif
vec4
edgeColor(vec4 Cfill, vec4 edgeDistance)
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
#ifdef PRIM_TRI
    float d =
        min(gEdgeDistance[0], min(gEdgeDistance[1], gEdgeDistance[2]));
#endif
#ifdef PRIM_QUAD
    float d =
        min(min(gEdgeDistance[0], gEdgeDistance[1]),
            min(gEdgeDistance[2], gEdgeDistance[3]));
#endif
    vec4 Cedge = vec4(1.0, 1.0, 0.0, 1.0);
    float p = exp2(-2 * d * d);
#if defined(GEOMETRY_OUT_WIRE)
    if (p < 0.25) discard;
#endif
    Cfill.rgb = mix(Cfill.rgb, Cedge.rgb, p);
#endif
    return Cfill;
#if defined(PRIM_QUAD) || defined(PRIM_TRI)
void
main()
    vec3 N = (gl_FrontFacing ? gNormal : -gNormal);
#ifdef VARYING_COLOR
    vec4 color = vec4(gColor, 1);
#else
    vec4 color = diffuseColor;
#endif
    vec4 Cf = lighting(color, gPosition.xyz, N);
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
    Cf = edgeColor(Cf, gEdgeDistance);
#endif
    outColor = Cf;
#endif
#endif
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-DeferredShadingCommon.h"
#import "C3D-PBR.metal"
struct LightUniforms {
    float4x4 modelTransform;
    float4x4 modelViewTransform;
    float4x4 normalTransform;
struct LightVertex {
    float3 position [[attribute(0)]];
struct LightIO {
    float4 position [[position]];
    float3 positionVS;
// everything stored in view space
struct Surface {
    SCNPBRSurface pbr;
    
    float   depth;
    float3  position;
    float4  xxxx; // unusued yet
// IOS only
// fragment FragmentOutput ds_default_frag(light_io in [[stage_in]], FragmentOutput gBuffers)
// Desktop version : surface created from fetching textures
static Surface createSurface(float4 positionSS, texture2d<float> albedo_roughness, texture2d<float> normal_depth, texture2d<float> texture3)
    Surface s;
    
#if 0 // normalized sampling
    constexpr sampler gbufferSampler(filter::nearest);
    float2 uv = positionSS.xy / float2(texture1.get_width(), texture1.get_height());
#else // pixel sampling
    constexpr sampler gbufferSampler(coord::pixel, filter::nearest);
    float2 uv = positionSS.xy;
#endif
    float4 a_r = albedo_roughness.sample(gbufferSampler, uv);
    s.pbr.albedo = a_r.rgb;
    s.pbr.roughness = a_r.a;
    s.pbr.metalness = 1.0; // TODO
    
    float4 n_d = normal_depth.sample(gbufferSampler, uv);
    s.pbr.n = normalize(n_d.xyz);
    s.depth = n_d.w;
    // no need to rescale since we store in fp texture
    // gb.normal_depth.xyz = gb.normal_depth.xyz * 2. - 1.;
    
    s.xxxx = texture3.sample(gbufferSampler, uv);
    
    return s;
static float distanceAttenuation(float3 lightVector, float invLightSquareRadius)
    float sqrDist = dot(lightVector, lightVector);
    float att = 1. / max(sqrDist, 0.0001);
    // smoothing factor to avoid hard clip of the lighting
    float factor = saturate(1. - sqrDist * invLightSquareRadius);
    factor *= factor;
    return att * factor;
static float angleAttenuation(float3 L, float3 lightDir, float2 spotAttenuation)
    float d = dot(lightDir, L);
    float att = saturate(d * spotAttenuation.x + spotAttenuation.y);
    return att * att;
#if USE_PBR
static float Fr_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness)
    float energyBias = mix(0, 0.5, linearRoughness);
    float energyFactor = mix(1.0, 1.0 / 1.51, linearRoughness);
    float fd90 = energyBias + 2.0 * LdotH*LdotH * linearRoughness;
    float3 f0 = float3(1.0f, 1.0f, 1.0f);
    float lightScatter = F_Schlick(f0, fd90, NdotL).r;
    float viewScatter = F_Schlick(f0, fd90, NdotV).r;
    
    return lightScatter * viewScatter * energyFactor;
#endif
// Glossary
// N: surface normal (unit vector)
// V: view vector: surface to eye (unit vector)
// L: light vector: light to surface
static float3 illuminate(Surface surface, float3 L, float3 lightColor)
    float3 N        = surface.normal;
    float3 V        = surface.view;
    
#if USE_PBR // PBR
    const float PI  = 3.14159265;
    // Should come from material / GBuffer
    float roughness = 1 - surface.roughness * surface.roughness;
    float3 f0       = float3(1.0);
    float f90       = saturate(50.0 * dot(f0, 0.33));
    
    float NdotV     = abs(dot(N,V)) + 1e-5f; // avoid artifact
    float3 H        = normalize(V + L);
    float LdotH     = saturate(dot(L, H));
    float NdotH     = saturate(dot(N, H));
    float NdotL     = saturate(dot(N, L));
    
    // Specular BRDF
    float3 F        = F_Schlick(f0, f90, LdotH);
    float vis       = V_SmithGGXCorrelated(NdotV, NdotL, roughness);
    float D         = D_GGX(NdotH, roughness);
    float3 Fr       = D * F * vis / PI;
    
    float Fd        = Fr_DisneyDiffuse(NdotV, NdotL, LdotH, roughness);
    
    return lightColor * (surface.albedo * Fd + Fr);
#else
    // diffuse
    float diff = saturate(dot(N, L));
    
    // specular
    float shininess = surface.roughness * 128.;
    float3 H = normalize(V + L);
    float3 spec = pow(saturate(dot(N, H)), shininess);
    
    float3 luminance = lightColor * ((surface.albedo + spec) * diff);
    return luminance;
#endif
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_dir_vert(constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                           constant LightData& lightData [[buffer(2)]],
                           uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = 1.0 - (float)(v_id % 2) * 2.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    LightIO out;
    out.position = in_position;
    
    float3 positionVS = (lightData.invProjectionTransform * in_position).xyz;
    out.positionVS = float3(positionVS.xy / -positionVS.z, -1.);
    
    return out;
// Fragment shader function
fragment half4 ds_light_frag(LightIO in [[stage_in]] ,
                             constant LightData& lightData [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                             texture2d<float> gBuffer1 [[texture(1)]],
                             texture2d<float> gBuffer2 [[texture(2)]],
                             texture2d<float> gBuffer3 [[texture(3)]])
    Surface surface = createSurface(in.position, gBuffer1, gBuffer2, gBuffer3);
    
    // TODO Optimize -> store in SceneBuffer
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    float farClip = d / (1.f + c);
    
    float scene_z = surface.depth * farClip;
    surface.position = in.positionVS * scene_z;
    surface.pbr.v    = -normalize(surface.position);
    
//    float3 lightColor = lightData.color_unscaledRadius.rgb;
//    float3 lightDir = lightData.direction_tanConeAngle.xyz;
    // Debugging
    /*
    if (in.position.x < 300) {
//        return half4(gb.normal_depth.w);
        return half4(float4(v, 1.0));
    } else {
        return half4(float4(gb.roughness.xyz, 1.0));
//    } else if (in.texcoord.x < 0.75) {
//        return half4(abs(dot(n, lightDir)));
    }
     */
    
    float4 light = 1.;
//    light.rgb = PBR_illuminate(lightColor, lightDir, surface.pbr);
// TODO
    
    return half4( light );
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_omni_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    float4 in_position = float4(in.position * lightData.color_unscaledRadius.w, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_omni_frag(LightIO in [[stage_in]],
                            constant LightData& lightData [[buffer(0)]],
                            constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                            texture2d<float> gBuffer1 [[texture(1)]],
                            texture2d<float> gBuffer2 [[texture(2)]],
                            texture2d<float> gBuffer3 [[texture(3)]]
                            )
    Surface surface = createSurface(in.position, gBuffer1, gBuffer2, gBuffer3);
    
    // TODO Optimize -> store in SceneBuffer
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    float farClip = d / (1.f + c);
    
    float scene_z = surface.depth * farClip;
    surface.position = in.positionVS * (scene_z / -in.positionVS.z);
    surface.pbr.v    = -normalize(surface.position);
    
    float3 lightColor = lightData.color_unscaledRadius.rgb;
    float3 lightPosition = lightData.positionVS_invSquareRadius.xyz;
    float  lightInvSquareRadius = lightData.positionVS_invSquareRadius.w;
    
    float3 unnormalizedLightVector = lightPosition - surface.position;
    float att = distanceAttenuation(unnormalizedLightVector, lightInvSquareRadius);
    float4 light(0.);
//    light.rgb = att * PBR_illuminate(lightColor, normalize(unnormalizedLightVector), surface.pbr);
// TODO
    light.rgb = att * lightColor;
    
//    result.xyz = half3(lightData.color.xyz);
    return half4( light );
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_spot_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    // Transform the cone (original apex in 0,1,0) and scale it with cone properties
    float3 pt = float3(in.position.x, - in.position.z, in.position.y - 0.5);
    pt.z *= lightData.color_unscaledRadius.w; // attenuation/radius
    pt.xy *= lightData.direction_tanConeAngle.w * pt.z; // expansion radial
    
    float4 in_position = float4(pt, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_spot_frag(LightIO in [[stage_in]],
                            constant LightData& lightData [[buffer(0)]],
                            constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                            texture2d<float> gBuffer1 [[texture(1)]],
                            texture2d<float> gBuffer2 [[texture(2)]],
                            texture2d<float> gBuffer3 [[texture(3)]]
                            )
    Surface surface = createSurface(in.position, gBuffer1, gBuffer2, gBuffer3);
    
    // TODO Optimize -> store in SceneBuffer
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    float farClip = d / (1.f + c);
    
    float scene_z = surface.depth * farClip;
    
    surface.position = in.positionVS * (scene_z / -in.positionVS.z);
    surface.pbr.v    = -normalize(surface.position);
//    return half4(float4(surface.view.rg, 1.0, 1.0));
    float3 lightColor = lightData.color_unscaledRadius.rgb;
    float3 lightPosition = lightData.positionVS_invSquareRadius.xyz;
    float3 lightDirection = lightData.direction_tanConeAngle.xyz;
    float  lightInvSquareRadius = lightData.positionVS_invSquareRadius.w;
    
    float3 unnormalizedLightVector = lightPosition - surface.position;
    float att = distanceAttenuation(unnormalizedLightVector, lightInvSquareRadius);
    
    att *= angleAttenuation(normalize(unnormalizedLightVector), lightDirection, lightData.spotAttenuation);
    
    //
    float4 light(0.);
//    light.rgb = att * PBR_illuminate(lightColor, normalize(unnormalizedLightVector), surface.pbr);
// TODO
    light.rgb = lightColor * att;
    
    //    result.xyz = half3(lightData.color.xyz);
    return half4( light );
struct SCNShaderSurface
vec3 view; // in view space
vec3 position; // in view space
vec3 normal; // in view space
vec3 tangent; // in view space
vec3 bitangent; // in view space
float shininess;
    float fresnel;
    float ambientOcclusion;
vec3 _normalTS; // UNDOCUMENTED in tangent space
uniform sampler2D u_color;
uniform sampler2D u_depth;
uniform float     u_middleZ;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(u_color,TexCoord);
    
#ifndef GL_ES
    gl_FragDepth = texture2D(u_depth,TexCoord).r;
    
    if(gl_FragDepth == 1.0){
        gl_FragDepth = u_middleZ;
    }
#endif
    
    //gl_FragColor.g = 0.3;
    //gl_FragColor = vec4(0.0,1.0,0.0,1.0);
    
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#if defined(VARYING_COLOR) || defined(FACEVARYING_COLOR)
#undef OSD_USER_VARYING_DECLARE
#define OSD_USER_VARYING_DECLARE \
    vec3 color;
#undef OSD_USER_VARYING_ATTRIBUTE_DECLARE
#define OSD_USER_VARYING_ATTRIBUTE_DECLARE \
    layout(location = 1) in vec3 color;
#undef OSD_USER_VARYING_PER_VERTEX
#define OSD_USER_VARYING_PER_VERTEX() \
    outpt.color = color
#undef OSD_USER_VARYING_PER_CONTROL_POINT
#define OSD_USER_VARYING_PER_CONTROL_POINT(ID_OUT, ID_IN) \
    outpt[ID_OUT].color = inpt[ID_IN].color
#undef OSD_USER_VARYING_PER_EVAL_POINT
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d) \
    outpt.color = \
        mix(mix(inpt[a].color, inpt[b].color, UV.x), \
            mix(inpt[c].color, inpt[d].color, UV.x), UV.y)
#else
#define OSD_USER_VARYING_DECLARE
#define OSD_USER_VARYING_ATTRIBUTE_DECLARE
#define OSD_USER_VARYING_PER_VERTEX()
#define OSD_USER_VARYING_PER_CONTROL_POINT(ID_OUT, ID_IN)
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d)
#endif
//--------------------------------------------------------------
// Vertex Shader
//--------------------------------------------------------------
#ifdef VERTEX_SHADER
layout (location=0) in vec4 position;
OSD_USER_VARYING_ATTRIBUTE_DECLARE
out block {
    OutputVertex v;
    OSD_USER_VARYING_DECLARE
} outpt;
void main()
    outpt.v.position = ModelViewMatrix * position;
    OSD_USER_VARYING_PER_VERTEX();
#endif
//--------------------------------------------------------------
// Geometry Shader
//--------------------------------------------------------------
#ifdef GEOMETRY_SHADER
#ifdef PRIM_QUAD
    layout(lines_adjacency) in;
    #define EDGE_VERTS 4
#endif // PRIM_QUAD
#ifdef  PRIM_TRI
    layout(triangles) in;
    #define EDGE_VERTS 3
#endif // PRIM_TRI
layout(triangle_strip, max_vertices = EDGE_VERTS) out;
in block {
    OutputVertex v;
    OSD_USER_VARYING_DECLARE
} inpt[EDGE_VERTS];
out block {
    OutputVertex v;
    noperspective out vec4 edgeDistance;
    OSD_USER_VARYING_DECLARE
} outpt;
void emit(int index, vec3 normal)
    outpt.v.position = inpt[index].v.position;
#ifdef SMOOTH_NORMALS
    outpt.v.normal = inpt[index].v.normal;
#else
    outpt.v.normal = normal;
#endif
#ifdef VARYING_COLOR
    outpt.color = inpt[index].color;
#endif
#ifdef FACEVARYING_COLOR
#ifdef LOOP  // ----- scheme : LOOP
    vec2 uv;
    OSD_COMPUTE_FACE_VARYING_TRI_2(uv, /*fvarOffste=*/0, index);
#else        // ----- scheme : CATMARK / BILINEAR
#ifdef UNIFORM_SUBDIVISION
    vec2 quadst[4] = vec2[](vec2(0,0), vec2(1,0), vec2(1,1), vec2(0,1));
    vec2 st = quadst[index];
#else
    vec2 st = inpt[index].v.tessCoord;
#endif
    vec2 uv;
    OSD_COMPUTE_FACE_VARYING_2(uv, /*fvarOffset=*/0, st);
#endif      // ------ scheme
    outpt.color = vec3(uv.s, uv.t, 0);
#endif
    gl_Position = ProjectionMatrix * inpt[index].v.position;
    EmitVertex();
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
const float VIEWPORT_SCALE = 1024.0; // XXXdyu
float edgeDistance(vec4 p, vec4 p0, vec4 p1)
    return VIEWPORT_SCALE *
        abs((p.x - p0.x) * (p1.y - p0.y) -
            (p.y - p0.y) * (p1.x - p0.x)) / length(p1.xy - p0.xy);
void emit(int index, vec3 normal, vec4 edgeVerts[EDGE_VERTS])
    outpt.edgeDistance[0] =
        edgeDistance(edgeVerts[index], edgeVerts[0], edgeVerts[1]);
    outpt.edgeDistance[1] =
        edgeDistance(edgeVerts[index], edgeVerts[1], edgeVerts[2]);
#ifdef PRIM_TRI
    outpt.edgeDistance[2] =
        edgeDistance(edgeVerts[index], edgeVerts[2], edgeVerts[0]);
#endif
#ifdef PRIM_QUAD
    outpt.edgeDistance[2] =
        edgeDistance(edgeVerts[index], edgeVerts[2], edgeVerts[3]);
    outpt.edgeDistance[3] =
        edgeDistance(edgeVerts[index], edgeVerts[3], edgeVerts[0]);
#endif
    emit(index, normal);
#endif
void main()
    gl_PrimitiveID = gl_PrimitiveIDIn;
#ifdef PRIM_QUAD
    vec3 A = (inpt[0].v.position - inpt[1].v.position).xyz;
    vec3 B = (inpt[3].v.position - inpt[1].v.position).xyz;
    vec3 C = (inpt[2].v.position - inpt[1].v.position).xyz;
    vec3 n0 = normalize(cross(B, A));
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
    vec4 edgeVerts[EDGE_VERTS];
    edgeVerts[0] = ProjectionMatrix * inpt[0].v.position;
    edgeVerts[1] = ProjectionMatrix * inpt[1].v.position;
    edgeVerts[2] = ProjectionMatrix * inpt[2].v.position;
    edgeVerts[3] = ProjectionMatrix * inpt[3].v.position;
    edgeVerts[0].xy /= edgeVerts[0].w;
    edgeVerts[1].xy /= edgeVerts[1].w;
    edgeVerts[2].xy /= edgeVerts[2].w;
    edgeVerts[3].xy /= edgeVerts[3].w;
    emit(0, n0, edgeVerts);
    emit(1, n0, edgeVerts);
    emit(3, n0, edgeVerts);
    emit(2, n0, edgeVerts);
#else
    emit(0, n0);
    emit(1, n0);
    emit(3, n0);
    emit(2, n0);
#endif
#endif // PRIM_QUAD
#ifdef PRIM_TRI
    vec3 A = (inpt[1].v.position - inpt[0].v.position).xyz;
    vec3 B = (inpt[2].v.position - inpt[0].v.position).xyz;
    vec3 n0 = normalize(cross(B, A));
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
    vec4 edgeVerts[EDGE_VERTS];
    edgeVerts[0] = ProjectionMatrix * inpt[0].v.position;
    edgeVerts[1] = ProjectionMatrix * inpt[1].v.position;
    edgeVerts[2] = ProjectionMatrix * inpt[2].v.position;
    edgeVerts[0].xy /= edgeVerts[0].w;
    edgeVerts[1].xy /= edgeVerts[1].w;
    edgeVerts[2].xy /= edgeVerts[2].w;
    emit(0, n0, edgeVerts);
    emit(1, n0, edgeVerts);
    emit(2, n0, edgeVerts);
#else
    emit(0, n0);
    emit(1, n0);
    emit(2, n0);
#endif
#endif // PRIM_TRI
    EndPrimitive();
#endif
//--------------------------------------------------------------
// Fragment Shader
//--------------------------------------------------------------
#ifdef FRAGMENT_SHADER
in block {
    OutputVertex v;
    noperspective in vec4 edgeDistance;
    OSD_USER_VARYING_DECLARE
} inpt;
out vec4 outColor;
#define NUM_LIGHTS 2
struct LightSource {
    vec4 position;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
layout(std140) uniform Lighting {
    LightSource lightSource[NUM_LIGHTS];
uniform vec4 diffuseColor = vec4(1);
uniform vec4 ambientColor = vec4(1);
vec4
lighting(vec4 diffuse, vec3 Peye, vec3 Neye)
    vec4 color = vec4(0);
    for (int i = 0; i < NUM_LIGHTS; ++i) {
        vec4 Plight = lightSource[i].position;
        vec3 l = (Plight.w == 0.0)
                    ? normalize(Plight.xyz) : normalize(Plight.xyz - Peye);
        vec3 n = normalize(Neye);
        vec3 h = normalize(l + vec3(0,0,1));    // directional viewer
        float d = max(0.0, dot(n, l));
        float s = pow(max(0.0, dot(n, h)), 500.0f);
        color += lightSource[i].ambient * ambientColor
            + d * lightSource[i].diffuse * diffuse
            + s * lightSource[i].specular;
    }
    color.a = 1;
    return color;
vec4
edgeColor(vec4 Cfill, vec4 edgeDistance)
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
#ifdef PRIM_TRI
    float d =
        min(inpt.edgeDistance[0], min(inpt.edgeDistance[1], inpt.edgeDistance[2]));
#endif
#ifdef PRIM_QUAD
    float d =
        min(min(inpt.edgeDistance[0], inpt.edgeDistance[1]),
            min(inpt.edgeDistance[2], inpt.edgeDistance[3]));
#endif
    vec4 Cedge = vec4(1.0, 1.0, 0.0, 1.0);
    float p = exp2(-2 * d * d);
#if defined(GEOMETRY_OUT_WIRE)
    if (p < 0.25) discard;
#endif
    Cfill.rgb = mix(Cfill.rgb, Cedge.rgb, p);
#endif
    return Cfill;
#if defined(PRIM_QUAD) || defined(PRIM_TRI)
void
main()
    vec3 N = (gl_FrontFacing ? inpt.v.normal : -inpt.v.normal);
#if defined(VARYING_COLOR)
    vec4 color = vec4(inpt.color, 1);
#elif defined(FACEVARYING_COLOR)
    // generating a checkerboard pattern
    vec4 color = vec4(inpt.color.rg,
                      int(floor(20*inpt.color.r)+floor(20*inpt.color.g))&1, 1);
#else
    vec4 color = diffuseColor;
#endif
    vec4 Cf = lighting(color, inpt.v.position.xyz, N);
#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)
    Cf = edgeColor(Cf, inpt.edgeDistance);
#endif
    outColor = Cf;
#endif
#endif
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>pickedObjects</string>
<string>outline</string>
</array>
<key>passes</key>
<dict>
<key>pickedObjects</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Outline</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outline_vert</string>
<key>metalFragmentShader</key>
<string>outline_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
#import <metal_stdlib>
using namespace metal;
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    invertViewTransform; // transform from view space to world space
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; // x:-1/(end-start) y:1-start*x z:exp
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    float       environmentIntensity;
#ifndef MAX_SAMPLE
#define MAX_SAMPLE 1
#endif
#ifndef TARGET_OS_IPHONE
#ifdef SPOT_SHADOW
#define USE_SPOT_ATTENUATION 1
#else
#define USE_SPOT_ATTENUATION 0
#endif
#else
#define USE_SPOT_ATTENUATION 0
#endif
    
float3 unprojectPoint(float3 screenPos, float4x4 camera_MVP_i);
static float _shadow2DProj(depth2d<float> tex, float4 uv)
    constexpr sampler shadow_sampler(coord::normalized, filter::linear, address::clamp_to_edge, compare_func::greater_equal);
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);
struct shadowMap_io {
    float4 position [[position]];
    float2 texcoord;
struct shadowMap_uniforms {
    float4 u_kernel[MAX_SAMPLE];
    float4x4  camera_MVP_i;
    float4x4  light_MVP;
    float3  u_lightPos;
    float3  u_lightDir;
    float3  u_lightSpotAtt;
    float shadowRadius;
    float4 shadowColor;
vertex shadowMap_io shadowMap_vert(uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    shadowMap_io out;
    out.position = in_position;
    out.texcoord = in_position.xy * float2(0.5, -0.5) + 0.5;
    return out;
// Fragment shader function
float3 unprojectPoint(float3 screenPos, float4x4 camera_MVP_i)
    float4 pTmp;
    
    pTmp.xy = (2.0 * screenPos.xy) - 1.0;
    pTmp.z = screenPos.z;
    pTmp.w = 1.0;
    
    pTmp = camera_MVP_i * pTmp;
    pTmp /= pTmp.w;
    
    return pTmp.xyz;
fragment half4 shadowMap_frag(shadowMap_io in [[stage_in]],
                              texture2d<float> colorSampler [[texture(0)]],
                              depth2d<float> depthSampler [[texture(1)]],
                              depth2d<float> lightDepthSampler [[texture(2)]],
                              constant shadowMap_uniforms& uniforms [[buffer(0)]]
                              )
    constexpr sampler samp(filter::nearest);
    
    //get color (no blur mode)
    float4 color = colorSampler.sample(samp, in.texcoord);
    
    //get z (need a bias on the read z value....)
    float depthValue = depthSampler.sample(samp, in.texcoord) - 0.00001;
    
    //unproject to get world position
    float3 worldPos = unprojectPoint(float3(in.texcoord.x, 1. - in.texcoord.y, depthValue), uniforms.camera_MVP_i);
    
    //project into light space
    float4 lightScreen =  uniforms.light_MVP * float4(worldPos, 1.0);
    
#if 0
    if (abs(lightScreen.x / lightScreen.w) > 1.)
        return half4(0., 1., 0., 1.);
    
    if (abs(lightScreen.y / lightScreen.w) > 1.)
        return half4(0., 0., 1., 1.);
    
    if ((lightScreen.z / lightScreen.w) > 1.)
        return half4(0., 1., 1., 1.);
    
    if ((lightScreen.z / lightScreen.w) < 0.)
        return half4(1., 1., 0., 1.);
#endif
    // compute spot attenuation ---------------------------------------------------------------------------------------------
#if USE_SPOT_ATTENUATION
    float3 lightToFragment = normalize(uniforms.u_lightPos - uniforms.worldPos);
    
    // TODO we should also consider also distance attenuation and GOBO...
    float att;
    if (uniforms.u_lightSpotAtt.z == 0.0)
        att = step(uniforms.u_lightSpotAtt.x, dot(uniforms.lightToFragment, uniforms.u_lightDir) + 0.00004);
    else
        att = pow(clamp(dot(uniforms.lightToFragment, uniforms.u_lightDir) * uniforms.u_lightSpotAtt.x + uniforms.u_lightSpotAtt.y, 0.0, 1.0), u_lightSpotAtt.z);
    
    if (att == 0.) {
        return half4(color.rgba);
    }
#endif // USE_SPOT_ATTENUATION
    //-----------------------------------------------------------------------------------------------------------------------
    
#if MAX_SAMPLE == 1
    float shadow = _shadow2DProj(lightDepthSampler, lightScreen);
#else
    // penumbra
    float filteringSizeFactor = uniforms.shadowRadius * lightScreen.w;//(distLight - lightDepth)*shadowRadius / lightDepth ;
    
    //smooth all samples
    float totalAccum = 0.0;
    for(int i=0; i < MAX_SAMPLE; i++){
        totalAccum += _shadow2DProj(lightDepthSampler, lightScreen + (uniforms.u_kernel[i] * filteringSizeFactor));
//        totalAccum += _shadow2DProj(lightDepthSampler, lightScreen + (uniforms.u_kernel[i] * filteringSizeFactor));
    }
    
//    float shadow = totalAccum;
    float shadow = totalAccum / float(MAX_SAMPLE);
#endif
    
#if !USE_SPOT_ATTENUATION
    shadow *= step(0., lightScreen.w);
#endif
    
    //    vec2 clamp = step(lightScreen.xy * lightScreen.xy, vec2(1.));
    //    shadow *= clamp.x * clamp.y;
    shadow *= uniforms.shadowColor.a;
#if USE_SPOT_ATTENUATION
    shadow = shadow * att;
#endif
    
    //apply shadow on color buffer
    return half4(mix(color.rgba, float4(uniforms.shadowColor.rgb, 1.0),  shadow));
  struct scn_floor {
    float2 u_floor_viewport;
    float u_floorReflectivity;
#ifdef USE_FALLOFF
    float4x4 u_floorMVP_i;
    float4 u_floorPlane;
    float u_floorFalloff;
#ifdef USE_FALLOFF_START
    float u_floorFalloffStart;
#endif
#endif
static inline float3 floorUnprojectPoint(float3 screenPos, float4x4 mvp_i)
    float4 pTmp = mvp_i * float4(screenPos.xy * 2.0 - 1.0, screenPos.z, 1.0);
    return pTmp.xyz / pTmp.w;
#pragma arguments
scn_floor scn_floorSurf
texture2d u_floorReflectionColor;
depth2d u_floorReflectionDepth;
#pragma body
float2 normalizedFragCoord = in.fragmentPosition.xy * scn_floorSurf.u_floor_viewport;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
constexpr sampler linear_sampler(filter::linear);
float4 floorColor = u_floorReflectionColor.sample(linear_sampler, normalizedFragCoord);
float reflectionFactor = scn_floorSurf.u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = u_floorReflectionDepth.sample(linear_sampler, normalizedFragCoord);
float3  floorPW = floorUnprojectPoint(float3(normalizedFragCoord.x, 1. - normalizedFragCoord.y, floorDepth), scn_floorSurf.u_floorMVP_i);
float floorDist = -dot(floorPW.xyz, scn_floorSurf.u_floorPlane.xyz) - scn_floorSurf.u_floorPlane.w;;
#ifdef USE_FALLOFF_START
floorDist -= scn_floorSurf.u_floorFalloffStart; // Falloff has been updated in CPU
#endif // USE_FALLOFF_START
reflectionFactor *= 1.0 - clamp(floorDist / scn_floorSurf.u_floorFalloff, 0.0, 1.0);
#endif // USE_FALLOFF
floorColor *= reflectionFactor; // integrate reflection factor
_output.color.rgb *= (1. - floorColor.a); // obscure existing color with reflection opacity
_output.color.rgba += floorColor.rgba; // additive blending with premultiplied alpha
attribute vec3 a_position;
varying vec2 TexCoord;
uniform mat4 u_textureMatrix;
void main(void)
gl_Position = vec4(a_position, 1.0);
    TexCoord = (u_textureMatrix * vec4(a_position.xy, 0., 1.)).xy * 0.5 + 0.5;
TexCoord.y = 1.0 - TexCoord.y;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>computeVelocity</string>
<string>blur1</string>
<string>blur2</string>
<string>renderMovableNodes</string>
</array>
<key>passes</key>
<dict>
<key>computeVelocity</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>velocity-target</string>
</dict>
<key>inputs</key>
<dict>
<key>depthBuffer</key>
<string>DEPTH</string>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_oldViewProjectionTransform</key>
<string>C3D-oldViewProjectionTransform-symbol</string>
<key>u_viewProjectionInverseTransform</key>
<string>C3D-viewProjectionInverseTransform-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_compute_velocity</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>blur1</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorBuffer</key>
<string>COLOR</string>
<key>velocityBuffer</key>
<string>velocity-target</string>
<key>a_position</key>
<string>a_position-symbol</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_6samples</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>blur2</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorBuffer</key>
<string>COLOR</string>
<key>velocityBuffer</key>
<string>velocity-target</string>
<key>a_position</key>
<string>a_position-symbol</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_12samples</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>renderMovableNodes</key>
<dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>onlyMovableNodes</key>
<true/>
<key>samples</key>
<integer>1</integer>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>C3D-MotionBlur-Intensity-symbol</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-oldViewProjectionTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>C3D-viewProjectionInverseTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>velocity-target</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rg16f</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
</dict>
</dict>
</plist>
uniform float u_floorReflectivity;
uniform sampler2D u_floorReflectionColor;
uniform vec2 u_floor_viewport;
#ifdef USE_FALLOFF
uniform mat4 u_floorMVP_i;
uniform vec4 u_floorPlane;
uniform float u_floorFalloff;
#ifdef USE_FALLOFF_START
uniform float u_floorFalloffStart;
#endif
uniform sampler2D u_floorReflectionDepth;
vec3 floorUnprojectPoint(vec3 screenPos)
    vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
    pTmp.w = 1.0;
    pTmp = u_floorMVP_i * pTmp;
    pTmp /= pTmp.w;
    return vec3(pTmp);
#endif // USE_FALLOFF
#pragma body
vec2 normalizedFragCoord = gl_FragCoord.xy * u_floor_viewport;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
vec4 floorColor = texture2D(u_floorReflectionColor, normalizedFragCoord);
float reflectionFactor = u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = texture2D(u_floorReflectionDepth, normalizedFragCoord).x;
vec3  floorPW = floorUnprojectPoint(vec3(normalizedFragCoord, floorDepth));
float floorDist = - dot(vec4(floorPW.xyz, 1.0), u_floorPlane);
#ifdef USE_FALLOFF_START
floorDist -= u_floorFalloffStart; // Falloff has been updated in CPU
#endif // USE_FALLOFF_START
reflectionFactor *= 1.0 - clamp(floorDist / u_floorFalloff, 0.0, 1.0);
#endif // USE_FALLOFF
floorColor *= reflectionFactor; // integrate reflection factor
_output.color.rgb *= (1. - floorColor.a); // obscure existing color with reflection opacity
_output.color.rgba += floorColor.rgba; // additive blending with premultiplied alpha
  "passes" : {
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "ignoreFloors" : true,
      "draw" : "DRAW_NODE",
      "node" : "self"
    },
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_m" : "C3D-CIFilter_modelMatrix",
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "program" : "C3D-CIFilterComposite",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    }
  },
  "sequence" : [
    "SceneKit_renderCINodeTree",
    "SceneKit_ApplyCIFilter",
    "SceneKit_renderCIQuad"
  ],
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_modelMatrix" : {
      "type" : "mat4"
    }
  },
  "targets" : {
    "SceneKit-CI-effect-color" : {
      "type" : "color"
    },
    "SceneKit-CI-nodetree-color" : {
      "target" : "texture_rectangle",
      "type" : "color"
    },
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    }
#import <metal_stdlib>
using namespace metal;
struct blend_uniforms {
    float weights[8];
    uint  maxIndex;
// Position only
kernel void blend_init_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                    device packed_float3* outP       [[ buffer(0) ]],
                                    constant blend_uniforms& uniforms[[ buffer(3) ]],
                                    device packed_float3* base     [[ buffer(4) ]],
                                    device packed_float3* delta0   [[ buffer(5) ]],
                                    device packed_float3* delta1   [[ buffer(6) ]],
                                    device packed_float3* delta2   [[ buffer(7) ]],
                                    device packed_float3* delta3   [[ buffer(8) ]],
                                    device packed_float3* delta4   [[ buffer(9) ]],
                                    device packed_float3* delta5   [[ buffer(10) ]],
                                    device packed_float3* delta6   [[ buffer(11) ]],
                                    device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] = base[index]
    + uniforms.weights[0] * delta0[index]
    + uniforms.weights[1] * delta1[index]
    + uniforms.weights[2] * delta2[index]
    + uniforms.weights[3] * delta3[index]
    + uniforms.weights[4] * delta4[index]
    + uniforms.weights[5] * delta5[index]
    + uniforms.weights[6] * delta6[index]
    + uniforms.weights[7] * delta7[index];
kernel void blend_add_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                   device packed_float3* outP       [[ buffer(0) ]],
                                   constant blend_uniforms& uniforms[[ buffer(3) ]],
                                   device packed_float3* delta0   [[ buffer(5) ]],
                                   device packed_float3* delta1   [[ buffer(6) ]],
                                   device packed_float3* delta2   [[ buffer(7) ]],
                                   device packed_float3* delta3   [[ buffer(8) ]],
                                   device packed_float3* delta4   [[ buffer(9) ]],
                                   device packed_float3* delta5   [[ buffer(10) ]],
                                   device packed_float3* delta6   [[ buffer(11) ]],
                                   device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] += uniforms.weights[0] * delta0[index]
    + uniforms.weights[1] * delta1[index]
    + uniforms.weights[2] * delta2[index]
    + uniforms.weights[3] * delta3[index]
    + uniforms.weights[4] * delta4[index]
    + uniforms.weights[5] * delta5[index]
    + uniforms.weights[6] * delta6[index]
    + uniforms.weights[7] * delta7[index];
// Position + Normal
typedef struct
    packed_float3 position;
    packed_float3 normal;
} morph_target_PN;
kernel void blend_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                    device packed_float3* outP       [[ buffer(0) ]],
                                    device packed_float3* outN       [[ buffer(1) ]],
                                    constant blend_uniforms& uniforms[[ buffer(3) ]],
                                    device morph_target_PN* base     [[ buffer(4) ]],
                                    device morph_target_PN* delta0   [[ buffer(5) ]],
                                    device morph_target_PN* delta1   [[ buffer(6) ]],
                                    device morph_target_PN* delta2   [[ buffer(7) ]],
                                    device morph_target_PN* delta3   [[ buffer(8) ]],
                                    device morph_target_PN* delta4   [[ buffer(9) ]],
                                    device morph_target_PN* delta5   [[ buffer(10) ]],
                                    device morph_target_PN* delta6   [[ buffer(11) ]],
                                    device morph_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] = base[index].position
    + uniforms.weights[0] * delta0[index].position
    + uniforms.weights[1] * delta1[index].position
    + uniforms.weights[2] * delta2[index].position
    + uniforms.weights[3] * delta3[index].position
    + uniforms.weights[4] * delta4[index].position
    + uniforms.weights[5] * delta5[index].position
    + uniforms.weights[6] * delta6[index].position
    + uniforms.weights[7] * delta7[index].position;
    
    outN[index] = base[index].normal
    + uniforms.weights[0] * delta0[index].normal
    + uniforms.weights[1] * delta1[index].normal
    + uniforms.weights[2] * delta2[index].normal
    + uniforms.weights[3] * delta3[index].normal
    + uniforms.weights[4] * delta4[index].normal
    + uniforms.weights[5] * delta5[index].normal
    + uniforms.weights[6] * delta6[index].normal
    + uniforms.weights[7] * delta7[index].normal;
kernel void blend_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                   device packed_float3* outP       [[ buffer(0) ]],
                                   device packed_float3* outN       [[ buffer(1) ]],
                                   constant blend_uniforms& uniforms[[ buffer(3) ]],
                                   device morph_target_PN* delta0   [[ buffer(5) ]],
                                   device morph_target_PN* delta1   [[ buffer(6) ]],
                                   device morph_target_PN* delta2   [[ buffer(7) ]],
                                   device morph_target_PN* delta3   [[ buffer(8) ]],
                                   device morph_target_PN* delta4   [[ buffer(9) ]],
                                   device morph_target_PN* delta5   [[ buffer(10) ]],
                                   device morph_target_PN* delta6   [[ buffer(11) ]],
                                   device morph_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] += uniforms.weights[0] * delta0[index].position
    + uniforms.weights[1] * delta1[index].position
    + uniforms.weights[2] * delta2[index].position
    + uniforms.weights[3] * delta3[index].position
    + uniforms.weights[4] * delta4[index].position
    + uniforms.weights[5] * delta5[index].position
    + uniforms.weights[6] * delta6[index].position
    + uniforms.weights[7] * delta7[index].position;
    
    outN[index] += uniforms.weights[0] * delta0[index].normal
    + uniforms.weights[1] * delta1[index].normal
    + uniforms.weights[2] * delta2[index].normal
    + uniforms.weights[3] * delta3[index].normal
    + uniforms.weights[4] * delta4[index].normal
    + uniforms.weights[5] * delta5[index].normal
    + uniforms.weights[6] * delta6[index].normal
    + uniforms.weights[7] * delta7[index].normal;
/// Packed_Normal
static inline float4 unpack_snorm10a2_to_float(uint n) {
    const float4 scale = { 1 / 511.f, 1 / 511.f, 1 / 511.f, 1 / 3.f };
    short4 i = { short(((int)n << 22) >> 22), short(((int)n << 12) >> 22), short(((int)n << 2) >> 22), short(n >> 30) };
    float4 f = float4(i);
    return f * scale;
static inline uint pack_float_to_snorm10a2(float4 v) {
//    v = clamp(v, float4(-1), float4(1));
    const float4 scale = { 511.f, 511.f, 511.f, 3.f };
    const uint4 mask = { 0x3ff, 0x3ff, 0x3ff, 0x3 };
    const uint4 iv = as_type<uint4>(int4(v * scale)) & mask;
    return (iv.x<<0)|(iv.y<<10)|(iv.z<<20)|(iv.w<<30);
static inline float4 unpack_snorm10a2_to_float(uint n) {
    return unpack_unorm10a2_to_float(n) * 2. - 1.;
static inline uint pack_float_to_snorm10a2(float4 v) {
    return pack_float_to_unorm10a2(v * 0.5 + 0.5);
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blendpack_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        device packed_float3* outN       [[ buffer(1) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device float4* base     [[ buffer(4) ]],
                                        device float4* delta0   [[ buffer(5) ]],
                                        device float4* delta1   [[ buffer(6) ]],
                                        device float4* delta2   [[ buffer(7) ]],
                                        device float4* delta3   [[ buffer(8) ]],
                                        device float4* delta4   [[ buffer(9) ]],
                                        device float4* delta5   [[ buffer(10) ]],
                                        device float4* delta6   [[ buffer(11) ]],
                                        device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 base_val = base[index];
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = base_val.xyz
    + w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    
    outP[index] = pos;
    outN[index] = normal;
kernel void blendpack_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       device packed_float3* outN       [[ buffer(1) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device float4* delta0   [[ buffer(5) ]],
                                       device float4* delta1   [[ buffer(6) ]],
                                       device float4* delta2   [[ buffer(7) ]],
                                       device float4* delta3   [[ buffer(8) ]],
                                       device float4* delta4   [[ buffer(9) ]],
                                       device float4* delta5   [[ buffer(10) ]],
                                       device float4* delta6   [[ buffer(11) ]],
                                       device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
// PackedNormal10a2
// Output interleaved
// we store position (xyz) and normal (stored as a 10a2) in (w) component for morph targets
// we output a single float4 where xyz contains float position values and normal is stored
// as a 10a2 stored in w component.
kernel void blendpack_dstint_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                            //                                            device packed_float3* outP       [[ buffer(0) ]],
                                            //                                            device packed_float3* outN       [[ buffer(1) ]],
                                            device float4* outPN       [[ buffer(0) ]],
                                            constant blend_uniforms& uniforms[[ buffer(3) ]],
                                            device float4* base     [[ buffer(4) ]],
                                            device float4* delta0   [[ buffer(5) ]],
                                            device float4* delta1   [[ buffer(6) ]],
                                            device float4* delta2   [[ buffer(7) ]],
                                            device float4* delta3   [[ buffer(8) ]],
                                            device float4* delta4   [[ buffer(9) ]],
                                            device float4* delta5   [[ buffer(10) ]],
                                            device float4* delta6   [[ buffer(11) ]],
                                            device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float4 base_val = base[index];
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = base_val.xyz
    + uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    float3 normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outPN[index] = float4(pos, as_type<float>(pack_float_to_snorm10a2(float4(normal, 1.0f))));
// we store position (xyz) and normal (stored as a 10a2) in (w) component for morph targets
// we output a single float4 where xyz contains float position values and normal is stored
// as a 10a2 stored in w component.
kernel void blendpack_dstint_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                           device float4* outPN       [[ buffer(0) ]],
                                           constant blend_uniforms& uniforms[[ buffer(3) ]],
                                           device float4* delta0   [[ buffer(5) ]],
                                           device float4* delta1   [[ buffer(6) ]],
                                           device float4* delta2   [[ buffer(7) ]],
                                           device float4* delta3   [[ buffer(8) ]],
                                           device float4* delta4   [[ buffer(9) ]],
                                           device float4* delta5   [[ buffer(10) ]],
                                           device float4* delta6   [[ buffer(11) ]],
                                           device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    float3 normal = uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    float4 old_PN_val = outPN[index];
    old_PN_val.xyz += pos;
    normal += unpack_snorm10a2_to_float(as_type<uint>(old_PN_val.w)).xyz;
    
    old_PN_val.w = as_type<float>(pack_float_to_snorm10a2(float4(normal, 1.0f)));
    outPN[index] = old_PN_val;
/// Packed Half
// Need this packing instruction because alignment otherwise is 16 bytes
struct __attribute__((__packed__)) morphpackhalf_target_PN
    half4 position;
    uint normal;
kernel void blendpackhalf_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        device packed_float3* outN       [[ buffer(1) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device morphpackhalf_target_PN* base     [[ buffer(4) ]],
                                        device morphpackhalf_target_PN* delta0   [[ buffer(5) ]],
                                        device morphpackhalf_target_PN* delta1   [[ buffer(6) ]],
                                        device morphpackhalf_target_PN* delta2   [[ buffer(7) ]],
                                        device morphpackhalf_target_PN* delta3   [[ buffer(8) ]],
                                        device morphpackhalf_target_PN* delta4   [[ buffer(9) ]],
                                        device morphpackhalf_target_PN* delta5   [[ buffer(10) ]],
                                        device morphpackhalf_target_PN* delta6   [[ buffer(11) ]],
                                        device morphpackhalf_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    half3 pos = base[index].position.xyz
    + uniforms.weights[0] * delta0[index].position.xyz
    + uniforms.weights[1] * delta1[index].position.xyz
    + uniforms.weights[2] * delta2[index].position.xyz
    + uniforms.weights[3] * delta3[index].position.xyz
    + uniforms.weights[4] * delta4[index].position.xyz
    + uniforms.weights[5] * delta5[index].position.xyz
    + uniforms.weights[6] * delta6[index].position.xyz
    + uniforms.weights[7] * delta7[index].position.xyz;
    outP[index] = float3(pos);
    
    outN[index] = unpack_snorm10a2_to_float(base[index].normal).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(delta0[index].normal).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(delta1[index].normal).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(delta2[index].normal).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(delta3[index].normal).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(delta4[index].normal).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(delta5[index].normal).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(delta6[index].normal).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(delta7[index].normal).xyz;
kernel void blendpackhalf_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       device packed_float3* outN       [[ buffer(1) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device morphpackhalf_target_PN* delta0   [[ buffer(5) ]],
                                       device morphpackhalf_target_PN* delta1   [[ buffer(6) ]],
                                       device morphpackhalf_target_PN* delta2   [[ buffer(7) ]],
                                       device morphpackhalf_target_PN* delta3   [[ buffer(8) ]],
                                       device morphpackhalf_target_PN* delta4   [[ buffer(9) ]],
                                       device morphpackhalf_target_PN* delta5   [[ buffer(10) ]],
                                       device morphpackhalf_target_PN* delta6   [[ buffer(11) ]],
                                       device morphpackhalf_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    half3 pos = uniforms.weights[0] * delta0[index].position.xyz
    + uniforms.weights[1] * delta1[index].position.xyz
    + uniforms.weights[2] * delta2[index].position.xyz
    + uniforms.weights[3] * delta3[index].position.xyz
    + uniforms.weights[4] * delta4[index].position.xyz
    + uniforms.weights[5] * delta5[index].position.xyz
    + uniforms.weights[6] * delta6[index].position.xyz
    + uniforms.weights[7] * delta7[index].position.xyz;
    outP[index] += float3(pos.xyz);
    
    outN[index] += uniforms.weights[0] * unpack_snorm10a2_to_float(delta0[index].normal).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(delta1[index].normal).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(delta2[index].normal).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(delta3[index].normal).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(delta4[index].normal).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(delta5[index].normal).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(delta6[index].normal).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(delta7[index].normal).xyz;
///////////////////////
// Pack x2
kernel void blendpackx2_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                          uint gsize          [[ threads_per_grid ]],
                                          
                                          device packed_float3* outP       [[ buffer(0) ]],
                                          device packed_float3* outN       [[ buffer(1) ]],
                                          constant blend_uniforms& uniforms[[ buffer(3) ]],
                                          device float4* base     [[ buffer(4) ]],
                                          device float4* delta0   [[ buffer(5) ]],
                                          device float4* delta1   [[ buffer(6) ]],
                                          device float4* delta2   [[ buffer(7) ]],
                                          device float4* delta3   [[ buffer(8) ]],
                                          device float4* delta4   [[ buffer(9) ]],
                                          device float4* delta5   [[ buffer(10) ]],
                                          device float4* delta6   [[ buffer(11) ]],
                                          device float4* delta7   [[ buffer(12) ]])
    float4 base_val = base[index];
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = base_val.xyz
    + uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    float3 normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] = pos;
    outN[index] = normal;
    
    index += gsize;
    if (index >= uniforms.maxIndex)
        return;
    
    base_val = base[index];
    delta0_val = delta0[index];
    delta1_val = delta1[index];
    delta2_val = delta2[index];
    delta3_val = delta3[index];
    delta4_val = delta4[index];
    delta5_val = delta5[index];
    delta6_val = delta6[index];
    delta7_val = delta7[index];
    
    pos = base_val.xyz
    + uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] = pos;
    outN[index] = normal;
kernel void blendpackx2_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                         uint gsize          [[ threads_per_grid ]],
                                         device packed_float3* outP       [[ buffer(0) ]],
                                         device packed_float3* outN       [[ buffer(1) ]],
                                         constant blend_uniforms& uniforms[[ buffer(3) ]],
                                         device float4* delta0   [[ buffer(5) ]],
                                         device float4* delta1   [[ buffer(6) ]],
                                         device float4* delta2   [[ buffer(7) ]],
                                         device float4* delta3   [[ buffer(8) ]],
                                         device float4* delta4   [[ buffer(9) ]],
                                         device float4* delta5   [[ buffer(10) ]],
                                         device float4* delta6   [[ buffer(11) ]],
                                         device float4* delta7   [[ buffer(12) ]])
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    float3 normal = uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
    
    index += gsize;
    if (index >= uniforms.maxIndex)
        return;
    
    delta0_val = delta0[index];
    delta1_val = delta1[index];
    delta2_val = delta2[index];
    delta3_val = delta3[index];
    delta4_val = delta4[index];
    delta5_val = delta5[index];
    delta6_val = delta6[index];
    delta7_val = delta7[index];
    
    pos = uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    normal = uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
kernel void blend_inc_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       device packed_float3* outN       [[ buffer(1) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device float4* delta0   [[ buffer(5) ]],
                                       device float4* delta1   [[ buffer(6) ]],
                                       device float4* delta2   [[ buffer(7) ]],
                                       device float4* delta3   [[ buffer(8) ]],
                                       device float4* delta4   [[ buffer(9) ]],
                                       device float4* delta5   [[ buffer(10) ]],
                                       device float4* delta6   [[ buffer(11) ]],
                                       device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blend_inc_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        device packed_float3* outN       [[ buffer(1) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device float4* delta0   [[ buffer(5) ]],
                                        device float4* delta1   [[ buffer(6) ]],
                                        device float4* delta2   [[ buffer(7) ]],
                                        device float4* delta3   [[ buffer(8) ]],
                                        device float4* delta4   [[ buffer(9) ]],
                                        device float4* delta5   [[ buffer(10) ]],
                                        device float4* delta6   [[ buffer(11) ]],
                                        device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] = pos;
    outN[index] = normal;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Position only
kernel void blend_inc_add_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device packed_float3* delta0   [[ buffer(5) ]],
                                       device packed_float3* delta1   [[ buffer(6) ]],
                                       device packed_float3* delta2   [[ buffer(7) ]],
                                       device packed_float3* delta3   [[ buffer(8) ]],
                                       device packed_float3* delta4   [[ buffer(9) ]],
                                       device packed_float3* delta5   [[ buffer(10) ]],
                                       device packed_float3* delta6   [[ buffer(11) ]],
                                       device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float3 delta0_val = delta0[index];
    float3 delta1_val = delta1[index];
    float3 delta2_val = delta2[index];
    float3 delta3_val = delta3[index];
    float3 delta4_val = delta4[index];
    float3 delta5_val = delta5[index];
    float3 delta6_val = delta6[index];
    float3 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    outP[index] += pos;
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blend_inc_init_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device packed_float3* delta0   [[ buffer(5) ]],
                                        device packed_float3* delta1   [[ buffer(6) ]],
                                        device packed_float3* delta2   [[ buffer(7) ]],
                                        device packed_float3* delta3   [[ buffer(8) ]],
                                        device packed_float3* delta4   [[ buffer(9) ]],
                                        device packed_float3* delta5   [[ buffer(10) ]],
                                        device packed_float3* delta6   [[ buffer(11) ]],
                                        device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float3 delta0_val = delta0[index];
    float3 delta1_val = delta1[index];
    float3 delta2_val = delta2[index];
    float3 delta3_val = delta3[index];
    float3 delta4_val = delta4[index];
    float3 delta5_val = delta5[index];
    float3 delta6_val = delta6[index];
    float3 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    outP[index] = pos;
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
// sparse
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
struct sps_uniforms {
    float weight;
    uint  maxIndex;
// interleaved version
// use float4 instead of struct as inputs because it is way faster!!!
// simple copy kernel
kernel void copy_interleaved_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                                 device float4* dst             [[ buffer(0) ]],
                                                 device float4* src             [[ buffer(1) ]],
                                                 constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    dst[index] = src[index];
kernel void blend_interleaved_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                                  device float4* dst             [[ buffer(0) ]],
                                                  device float4* src             [[ buffer(1) ]],
                                                  constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float4 dstVal   = dst[index];
    float3 pos      = dstVal.xyz;
    float4 nrm      = unpack_snorm10a2_to_float(as_type<uint>(dstVal.w));
    
    float4 val      = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w));
    
    float nrmPack = as_type<float>(pack_float_to_snorm10a2(normalize(nrm)));
    //    nrmPack = dstVal.w;
    dst[index] = float4(pos, nrmPack);
kernel void blend_interleaved_sparse_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                                         device float4* dst             [[ buffer(0) ]],
                                                         device float4* src             [[ buffer(1) ]],
                                                         device uint* indices           [[ buffer(2) ]],
                                                         constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    uint dstInd = indices[index];
    
    float4 dstVal   = dst[dstInd];
    float3 pos      = dstVal.xyz;
    float4 nrm      = unpack_snorm10a2_to_float(as_type<uint>(dstVal.w));
    float4 val  = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w));
    float nrmPack = as_type<float>(pack_float_to_snorm10a2(normalize(nrm)));
//    float nrmPack = dstVal.w;
    dst[dstInd] = float4(pos, nrmPack);
// non interleaved version
// simple copy kernel
kernel void copy_pos_float3_nrm_10a2(uint index                      [[ thread_position_in_grid ]],
                                     device packed_float3* outP      [[ buffer(0) ]],
                                     device float4* src              [[ buffer(1) ]],
                                     constant sps_uniforms& uniforms [[ buffer(3) ]],
                                     device packed_float3* outN      [[ buffer(4) ]]
                                     )
    if (index >= uniforms.maxIndex)
        return;
    float4 srcVal = src[index];
    outP[index] = srcVal.xyz;
    outN[index] = unpack_snorm10a2_to_float(as_type<uint>(srcVal.w)).xyz;
kernel void blend_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                      device packed_float3* outP     [[ buffer(0) ]],
                                      device float4* src             [[ buffer(1) ]],
                                      constant sps_uniforms& uniforms[[ buffer(3) ]],
                                      device packed_float3* outN     [[ buffer(4) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float3 pos      = outP[index];
    float3 nrm      = outN[index];
    
    float4 val      = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w)).xyz;
    
    // should we?
    // nrm = normalize(nrm);
    outP[index] = pos;
    outN[index] = nrm;
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blend_sparse_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                             device packed_float3* outP     [[ buffer(0) ]],
                                             device float4* src             [[ buffer(1) ]],
                                             device uint* indices           [[ buffer(2) ]],
                                             constant sps_uniforms& uniforms[[ buffer(3) ]],
                                             device packed_float3* outN     [[ buffer(4) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    uint dstInd = indices[index];
    
    float3 pos      = outP[dstInd];
    float3 nrm      = outN[dstInd];
    float4 val  = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w)).xyz;
    
    // should we?
    // nrm = normalize(nrm);
    outP[dstInd] = pos;
    outN[dstInd] = nrm;
varying vec4 v_vertexColor;
void main()
    gl_FragColor = v_vertexColor;
#import <metal_stdlib>
using namespace metal;
struct scn_filterComposite_uniforms_t {
    float4   u_extent;
    float    u_middleZ;
struct scn_filterComposite_io_t {
    float4 position [[ position ]];
    float2 uv;
    float2 uvDepth;
vertex scn_filterComposite_io_t scn_filterCompositeVert(uint v_id [[ vertex_id ]],
                                                        constant scn_filterComposite_uniforms_t& uniforms [[ buffer(0) ]])
    scn_filterComposite_io_t out;
    
    float x = uniforms.u_extent.x + uniforms.u_extent.z * (v_id/2);
    float y = uniforms.u_extent.y + uniforms.u_extent.w * (v_id%2);
    
    out.position = float4(x, y, 0., 1.0);
    
    float uvx = uniforms.u_extent.z * (v_id/2);
    float uvy = uniforms.u_extent.w * ((1+v_id)%2);
    
    out.uv = float2(uvx, uvy) * float2(0.5, 0.5);
    out.uvDepth = float2(x, y) * float2(0.5, -0.5) + float2(0.5, 0.5);
    
    return out;
struct scn_filterCompositeOut {
    half4 color [[ color(0) ]];
    float depth [[ depth(any) ]]; // TODO optimize with greater or less
fragment scn_filterCompositeOut scn_filterCompositeFrag(scn_filterComposite_io_t in [[ stage_in ]],
                                                        texture2d<float> u_color   [[texture(0)]],
                                                        depth2d<float> u_depth   [[texture(1)]],
                                                        constant scn_filterComposite_uniforms_t& uniforms [[ buffer(0) ]]                                                        )
    scn_filterCompositeOut out;
    constexpr sampler linear_sampler(filter::nearest, address::clamp_to_zero);
    out.color = half4(u_color.sample(linear_sampler, in.uv));
    out.depth = u_depth.sample(linear_sampler, in.uvDepth);
    
    if(out.depth == 1.0)
        out.depth = uniforms.u_middleZ;//* 0.5 + 0.5;
    
//    out.color.rgb = half3(out.depth);
    
    return out;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
<key>factor</key>
<string>C3D-jitter-factor-resolve</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor-resolve</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight"
  ],
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "global" : true,
      "type" : "depth"
    }
    "sequence" : ["SceneKit_stereoLeftEye", "SceneKit_stereoRightEye"],
    "passes" : {
        "SceneKit_stereoLeftEye" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "true",
                "clearColor" : "sceneBackground"
            },
            "depthStates" : {
                "clear" : "true"
            }
        },
        "SceneKit_stereoRightEye" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "false"
            },
            "depthStates" : {
                "clear" : "true"
            }
        }
    },
    "symbols" : {
        "interaxialDistance" : {
            "type" : "float"
        }
    }
uniform sampler2D colorSampler;
varying vec2 uv; // [-1, +1]x[-1, +1]
uniform vec4 viewport;
uniform float eye;
uniform float inputScale;
uniform float outputScale;
uniform vec2 lensCenterOffset;
uniform vec4 hmdWarpParam;
void main()
    vec2 inputScaleVec  = inputScale  * vec2(1.0, viewport.w / (0.5 * viewport.z));
    vec2 outputScaleVec = outputScale * vec2(1.0, (0.5 * viewport.z) / viewport.w);
    
    vec2 lensCenter = lensCenterOffset * vec2(-eye, 1.0);
    
    // https://github.com/dghost/glslRiftDistort/blob/master/glsl110/texture-lookup/ovr_make_texture.frag
    vec2 delta = (uv - lensCenter) * inputScaleVec;
    float distance = delta.x * delta.x + delta.y * delta.y;
    vec2 rvector = delta * (hmdWarpParam.x +
                            hmdWarpParam.y * distance +
                            hmdWarpParam.z * distance * distance +
                            hmdWarpParam.w * distance * distance * distance);
    
    vec2 distortion = lensCenter + outputScaleVec * rvector;
    
    if (any(greaterThan(abs(distortion), vec2(1.0)))) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        distortion = 0.5 * distortion + vec2(0.5); // back to [0, 1] for texture fetch
        
#if 1
        const vec4 ChromAbParam = vec4(0.996, -0.004, 1.014, 0.0);
        
        vec2 thetaRed = rvector * (ChromAbParam.x + ChromAbParam.y * distance);
        vec2 thetaBlue = rvector * (ChromAbParam.z + ChromAbParam.w * distance);
        vec2 tcRed = lensCenter + outputScaleVec * thetaRed;
        vec2 tcGreen = lensCenter + outputScaleVec * rvector;
        vec2 tcBlue = lensCenter + outputScaleVec * thetaBlue;
        
        float r = texture2D(colorSampler, 0.5 * tcRed + vec2(0.5)).r;
        float g = texture2D(colorSampler, 0.5 * tcGreen + vec2(0.5)).g;
        float b = texture2D(colorSampler, 0.5 * tcBlue + vec2(0.5)).b;
        gl_FragColor = vec4(r, g, b, 1.0);
#else
        gl_FragColor = texture2D(colorSampler, distortion);
#endif
    }
    
    //gl_FragColor = texture2D(colorSampler, uv*0.5+0.5);
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "C3D-DeferredShadingCommon.h"
struct LightUniforms {
    float4x4 modelTransform;
    float4x4 modelViewTransform;
    float4x4 normalTransform;
struct LightVertex {
    float3 position [[attribute(0)]];
struct LightIO {
    float4 position [[position]];
    float3 positionVS;
// IOS only
// fragment FragmentOutput ds_default_frag(light_io in [[stage_in]], FragmentOutput gBuffers)
struct GBuffer {
    float4 normal_depth; // stored in view space
    float4 albedo;
    float4 roughness;
class Text {
#define CHAR_SIZE float2(8, 12)
#define CHAR_SPACING float2(8, 12)
    
    constant constexpr static float4 ch_1 = float4(0x001030,0xF03030,0x303030,0xFC0000);
    float2 print_pos;
    
    float4 characters[59] = {
        float4(0x000000,0x000000,0x000000,0x000000), // Space 32
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0xC4CC18,0x3060CC,0x8C0000), // 37 '%'
        float4(0x000000,0x000000,0x000000,0x000000), // 38
        float4(0x0070D8,0xD870FA,0xDECCDC,0x760000), // 39 amp
        float4(0x003030,0x306000,0x000000,0x000000), // 40 ch_apo
        float4(0x000C18,0x306060,0x603018,0x0C0000),
        float4(0x006030,0x180C0C,0x0C1830,0x600000),
        float4(0x000000,0x663CFF,0x3C6600,0x000000),
        float4(0x000000,0x18187E,0x181800,0x000000),
        float4(0x000000,0x000000,0x000038,0x386000),
        float4(0x000000,0x0000FE,0x000000,0x000000),
        float4(0x000000,0x000000,0x000038,0x380000),
        float4(0x000002,0x060C18,0x3060C0,0x800000),
        float4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000), // 48 '0'
        float4(0x001030,0xF03030,0x303030,0xFC0000), //
        float4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000), // 50
        float4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000),
        float4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000),
        float4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000),
        float4(0x003860,0xC0C0F8,0xCCCCCC,0x780000),
        float4(0x00FEC6,0xC6060C,0x183030,0x300000),
        float4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000),
        float4(0x0078CC,0xCCCC7C,0x181830,0x700000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000), // 60
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000), // A
        float4(0x00FC66,0x66667C,0x666666,0xFC0000),
        float4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000),
        float4(0x00F86C,0x666666,0x66666C,0xF80000),
        float4(0x00FE62,0x60647C,0x646062,0xFE0000),
        float4(0x00FE66,0x62647C,0x646060,0xF00000),
        float4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000),
        float4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000),
        float4(0x007830,0x303030,0x303030,0x780000),
        float4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000),
        float4(0x00E666,0x6C6C78,0x6C6C66,0xE60000),
        float4(0x00F060,0x606060,0x626666,0xFE0000),
        float4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000),
        float4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000),
        float4(0x00386C,0xC6C6C6,0xC6C66C,0x380000),
        float4(0x00FC66,0x66667C,0x606060,0xF00000),
        float4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00),
        float4(0x00FC66,0x66667C,0x6C6666,0xE60000),
        float4(0x0078CC,0xCCC070,0x18CCCC,0x780000),
        float4(0x00FCB4,0x303030,0x303030,0x780000),
        float4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000),
        float4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000),
        float4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000),
        float4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000),
        float4(0x00CCCC,0xCCCC78,0x303030,0x780000),
        float4(0x00FECE,0x981830,0x6062C6,0xFE0000) // Z
    };
    
    float4 _textColor;
    float4 _shadowColor;
public:
    Text() {
        _textColor = float4(1.);
        _shadowColor = float4(0., 0., 0., 1.);
    }
    
    void setPrintPos(float2 pos) {
        print_pos = pos;
    }
    
    //Extracts bit b from the given number.
    //Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).
    float extract_bit(float n, float b)
    {
        b = clamp(b,-1.0,24.0);
        return floor(fmod(floor(n / pow(2.0,floor(b))),2.0));
    }
    
    //Returns the pixel at uv in the given bit-packed sprite.
    float sprite(float4 spr, float2 size, float2 uv)
    {
        uv = floor(uv);
        
        //Calculate the bit to extract (x + y * width) (flipped on x-axis)
        float bit = (size.x-uv.x-1.0) + uv.y * size.x;
        
        //Clipping bound to remove garbage outside the sprite's boundaries.
        bool bounds = all(uv >= float2(0)) && all(uv < size);
        
        float pixels = 0.0;
        pixels += extract_bit(spr.x, bit - 72.0);
        pixels += extract_bit(spr.y, bit - 48.0);
        pixels += extract_bit(spr.z, bit - 24.0);
        pixels += extract_bit(spr.w, bit - 00.0);
        
        return bounds ? pixels : 0.0;
    }
    //Prints a character and moves the print position forward by 1 character width.
    float printChar(float4 ch, float2 uv)
    {
        /*
         if( TEXT_MODE == INVERT )
         {
         //Inverts all of the bits in the character.
         ch = pow(2.0,24.0)-1.0-ch;
         }
         if( TEXT_MODE == UNDERLINE )
         {
         //Makes the bottom 8 bits all 1.
         //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,
         //then shifts it left 8 bits and adds 255 (binary 11111111).
         ch.w = floor(ch.w/256.0)*256.0 + 255.0;
         }
         */
        
        float px = sprite(ch, CHAR_SIZE, uv - print_pos);
        print_pos.x += CHAR_SPACING.x;
        return px;
    }
    //Prints a character and moves the print position forward by 1 character width.
    float printCh(char ch, float2 uv)
    {
        /*
         if( TEXT_MODE == INVERT )
         {
         //Inverts all of the bits in the character.
         ch = pow(2.0,24.0)-1.0-ch;
         }
         if( TEXT_MODE == UNDERLINE )
         {
         //Makes the bottom 8 bits all 1.
         //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,
         //then shifts it left 8 bits and adds 255 (binary 11111111).
         ch.w = floor(ch.w/256.0)*256.0 + 255.0;
         }
         */
        
        float px = sprite(characters[ch - ' '], CHAR_SIZE, uv - print_pos);
        print_pos.x += CHAR_SPACING.x;
        return px;
    }
    float printString(char str[], int count, float2 uv)
    {
        float px = 0.;
        for (int i =0; i < count; ++i) {
            px += printCh(str[i], uv);
        }
        return px;
    }
    float printStr4(const char constant str[4], float2 uv)
    {
        float px = 0.;
        px += printCh(str[0], uv);
        px += printCh(str[1], uv);
        px += printCh(str[2], uv);
        px += printCh(str[3], uv);
        return px;
    }
    float printStr(const char constant str[6], float2 uv)
    {
        float px = 0.;
        px += printCh(str[0], uv);
        px += printCh(str[1], uv);
        px += printCh(str[2], uv);
        px += printCh(str[3], uv);
        px += printCh(str[4], uv);
        px += printCh(str[5], uv);
        return px;
    }
    //Returns the digit sprite for the given number.
    float4 getDigit(float d)
    {
        int id = int(floor(d));
        if(id == 0) return characters['0' - 32];
        if(id == 1) return characters['1' - 32];
        if(id == 2) return characters['2' - 32];
        if(id == 3) return characters['3' - 32];
        if(id == 4) return characters['4' - 32];
        if(id == 5) return characters['5' - 32];
        if(id == 6) return characters['6' - 32];
        if(id == 7) return characters['7' - 32];
        if(id == 8) return characters['8' - 32];
        if(id == 9) return characters['9' - 32];
        return float4(0.0);
    }
    
    //Prints out the given number starting at pos.
    float printFloat(float number, float2 uv, int precision = 2)
    {
        float result = 0.0;
        
        if (number < 0.) {
            result += printChar(characters['-' - 32], uv);
            number = fabs(number);
        }
        
        for(int i = 3;i >= -precision;i--)
        {
            float digit = fmod( number / pow(10.0, float(i)) , 10.0);
            
            if(i == -1) //Add a decimal point.
            {
                result += printChar(characters['.' - 32],uv);
            }
            
            if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.
            {
                result += printChar(getDigit(digit),uv);
            }
        }
        return result;
    }
    
    #define MAX_INT_DIGITS 4
    float printInteger(float number, int zeros, float2 uv)
    {
        float result = 0.0;
        
        for(int i = MAX_INT_DIGITS;i >= 0;i--)
        {
            float digit = fmod( number / pow(10.0, float(i)) , 10.0);
            
            if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.
            {
                result += printChar(getDigit(digit),uv);
            }
        }   
        return result;
    }
    
    
    void setTextColor(float4 color) {
        _textColor = color;
    }
    void setShadowColor(float4 color) {
        _shadowColor = color;
    }
    
    float4 printStrShadow(const char constant str[6], float2 uv)
    {
        float2 oldPrintPos = print_pos;
        float4 col = _shadowColor * printStr(str, uv + float2(-2, 2));
        print_pos = oldPrintPos;
        col += _textColor * printStr(str, uv);
        return col;
    }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_debug_vert(constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                           constant LightData& lightData [[buffer(2)]],
                           uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = 1.0 - (float)(v_id % 2) * 2.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    LightIO out;
    out.position = in_position;
    
    float4 vs = (lightData.invProjectionTransform * in_position);
    out.positionVS = vs.xyz / vs.w;
    
    return out;
// Fragment shader function
fragment float4 ds_debug_frag(LightIO in [[stage_in]] ,
                             constant LightData& lightData [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                             texture2d<float> gBuffer1 [[texture(1)]],
                             texture2d<float> gBuffer2 [[texture(2)]],
                             texture2d<float> gBuffer3 [[texture(3)]])
    float2 scale = float2(4.);
    
    constexpr sampler gbufferSampler(filter::nearest, address::clamp_to_zero);
    float2 resolution = float2(gBuffer1.get_width(), gBuffer1.get_height());
    float2 invResolution = 1. / resolution;
    float2 uv = in.position.xy * invResolution;
    
    float4 color = 0.;
    if (uv.y < 0.25) { // vignette display
        float2 vignetteUV = uv * scale;
        if (uv.x < 0.25) { // normal [-1..1]
            color.rgb = gBuffer2.sample(gbufferSampler, vignetteUV).rgb * 0.5 + 0.5;
        } else if (uv.x < 0.5) { // depth [0..1]
            color.rgb = gBuffer2.sample(gbufferSampler, vignetteUV).www;
        } else if (uv.x < 0.75) { // albedo
            color.rgb = gBuffer1.sample(gbufferSampler, vignetteUV).rgb;
        } else { // roughness
            color.rgb = gBuffer1.sample(gbufferSampler, vignetteUV).www;
        }
    }
    
    // albedo
//    color += gBuffer1.sample(gbufferSampler, uv * scale);
    // normal
//    color.rgb += gBuffer2.sample(gbufferSampler, uv * scale + float2(-1, 0.)).rgb * 0.5 + 0.5;
//    color += gBuffer2.sample(gbufferSampler, uv * scale + float2(-2, 0.)).wwww;
//    color += gBuffer3.sample(gbufferSampler, uv * scale + float2(-3, 0.));
    color = saturate(color);
    
    float2 gridUV = fmod(uv, 1. / scale);
    float grid = (1. - step(invResolution.x, gridUV.x)) + (1. - step(invResolution.y, gridUV.y));
    float mask = step(uv.y, 1. / scale.y + invResolution.y);
    mask *= step(uv.x, 4. / scale.x + invResolution.x);
    color +=  grid * mask;
    color.a = mask;
    
    float2 pos = in.position.xy;
    pos.y = resolution.y - pos.y;
#if SHOW_LABELS
    Text text;
    float4 textMask = 0.;
    
    text.setPrintPos(float2(4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("ALBEDO", pos);
    text.setPrintPos(float2(4 + resolution.x / 4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("NORMAL", pos);
    text.setPrintPos(float2(4 + 2 * resolution.x / 4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("ROUGH ", pos);
    text.setPrintPos(float2(4 + 3 * resolution.x / 4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("DEPTH ", pos);
//    color = mix(color, textColor, textMask);
    color += textMask;
#endif
    
    return color;
////////////////////////////////////////////////////////////////////////////
// Omni debug shader
////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_omni_debug_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    float4 in_position = float4(in.position * lightData.color_unscaledRadius.w, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_omni_debug_frag( LightIO in [[stage_in]] )
    return half4( 0.05 );
////////////////////////////////////////////////////////////////////////////
// Spot debug shader
////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_spot_debug_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    // Transform the cone (original apex in 0,1,0) and scale it with cone properties
    float3 pt = float3(in.position.x, - in.position.z, in.position.y - 0.5);
    pt.z *= lightData.color_unscaledRadius.w; // attenuation/radius
    pt.xy *= lightData.direction_tanConeAngle.w * pt.z; // expansion radial
    
    float4 in_position = float4(pt, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_spot_debug_frag( LightIO in [[stage_in]] )
    return half4( 0.05 );
uniform sampler2D downSampler;
uniform sampler2D blurSampler;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    vec4 blur = texture2D( blurSampler, v_texCoord);
    float coc = max( down.a, 2. * blur.a - down.a );
gl_FragColor = vec4(down.rgb, coc);
    // debug
    //gl_FragColor = vec4(coc, 0., 0., 1.);
#import <metal_stdlib>
#import <simd/simd.h>
using namespace metal;
#import "scn_util.h"
#import "C3D-PBR.metal"
// MARK: Specular: Pre-integrated DFG
kernel void compute_specularPreIntegratedDFG(texture2d<float, access::write> texture [[ texture(0) ]],
                                             uint3                           index   [[ thread_position_in_grid ]])
    if (index.x < texture.get_width() && index.y < texture.get_height()) {
        
        float u = float(index.x + 0.5) / float(texture.get_width());
        float v = float(index.y + 0.5) / float(texture.get_height());
        
        float cosThetaV = u; // cos([0, pi/2]) = [0, 1]
        float roughness = v;
        float2 DFG = scn_specularDFG(cosThetaV, roughness);
        
        texture.write(float4(DFG, 0.0, 0.0), index.xy);
        
    }
// MARK: Specular: Pre-integrated LD
// Precompute direction on a hammersley pattern, with sampleCount dependant of the roughness?
// more rough means cone is wider but in the meantime sample is in a lower mip
struct scn_specularLD_lut_t
    float4      samples[1024]; // dir:xyz, weight:w
    uint        sampleCount;
    float       roughness;
    float       weightSum;
inline float3 scn_specularLD_lut(constant scn_specularLD_lut_t&     uniforms,
                                 texturecube<float, access::sample> environment,
                                 float3                             n)
    constexpr sampler linearSampler(filter::linear);
    
    float3 LD = float3(0.0);
    float3 tangent, bitangent;
    scn::generate_basis(n, &tangent, &bitangent);
    
    for (ushort i = 0; i < uniforms.sampleCount; ++i) {
        float4 s = uniforms.samples[i];
        float3 l = tangent * s.x + bitangent * s.y + n * s.z;
        float3 Li = environment.sample(linearSampler, l, level(0)).rgb;
        Li = min(Li, 65504.); // max float16/half representable value
        
        LD  += Li * s.w;
    }
    
    return LD / uniforms.weightSum;
#if SCN_METAL_SHADING_LANGUAGE_SUPPORTED_OSX
kernel void compute_specularPreIntegratedLD(texturecube<float, access::write>  texture          [[ texture(0) ]],
                                            texturecube<float, access::sample> environmentProbe [[ texture(1) ]],
                                            constant float&                    roughness        [[ buffer(0) ]],
                                            uint3                              index            [[ thread_position_in_grid ]])
    uint width = texture.get_width();
    uint height = texture.get_height();
    if (index.x >= width && index.y >= height)
        return;
    constexpr sampler linearSampler(filter::linear);
    
    float u = float(index.x) / float(width - 1);
    float v = float(index.y) / float(height - 1);
    
    uint face = index.z;
    float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
    float3 n = normalize(dir);
    
    float3 LD = scn_specularLD_cube(roughness, environmentProbe, n);
    
    texture.write(float4(LD, 1.0), index.xy, face);
#endif
kernel void compute_specularPreIntegratedLD_texture2d(texture2d<float, access::write>    texture          [[ texture(0) ]],
                                                      texturecube<float, access::sample> environmentProbe [[ texture(1) ]],
                                                      constant float&                    roughness        [[ buffer(0) ]],
                                                      constant uint&                     face             [[ buffer(1) ]],
                                                      uint3                              index            [[ thread_position_in_grid ]])
    if (index.x < texture.get_width() && index.y < texture.get_height()) {
        
        constexpr sampler linearSampler(filter::linear);
        
        float u = float(index.x) / float(texture.get_width() - 1);
        float v = float(index.y) / float(texture.get_height() - 1);
        
        float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
        float3 n = normalize(dir);
        
        float3 LD = scn_specularLD_cube(roughness, environmentProbe, n);
        texture.write(float4(LD, 1.0), index.xy, 0);
        
    }
fragment float4 draw_specularPreIntegratedLD_fragment(scn::draw_quad_io_t                 in               [[ stage_in ]],
                                                      texturecube<float, access::sample>  environmentProbe [[ texture(1) ]],
                                                      constant float&                     roughness        [[ buffer(0) ]],
                                                      constant uint&                      face             [[ buffer(1) ]])
    constexpr sampler linearSampler(filter::linear);
    
    float u = in.uv.x;
    float v = in.uv.y;
    
    float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
    float3 n = normalize(dir);
    
    float3 LD = scn_specularLD_cube(roughness, environmentProbe, n);
    return float4(LD, 1.0);
// MARK: Diffuse: Pre-integration
kernel void compute_diffusePreIntegrated_texture2d(texture2d<float, access::write>    texture          [[ texture(0) ]],
                                                   texturecube<float, access::sample> environmentProbe [[ texture(1) ]],
                                                   constant uint&                     samplingMipLevel [[ buffer(0) ]],
                                                   constant uint&                     face             [[ buffer(1) ]],
                                                   uint3                              index            [[ thread_position_in_grid ]])
    if (index.x < texture.get_width() && index.y < texture.get_height()) {
        
        constexpr sampler linearSampler(filter::linear);
        
        float u = float(index.x) / float(texture.get_width() - 1);
        float v = float(index.y) / float(texture.get_height() - 1);
        
        float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
        float3 n = normalize(dir);
        
        float3 L = scn_irradiance_cube(environmentProbe, samplingMipLevel, n);
        texture.write(float4(L, 1.0), index.xy, 0);
    }
fragment float4 draw_diffusePreIntegrated_fragment(scn::draw_quad_io_t                 in               [[ stage_in ]],
                                                   texturecube<float, access::sample>  environmentProbe [[ texture(1) ]],
                                                   constant uint&                      samplingMipLevel [[ buffer(0) ]],
                                                   constant uint&                      face             [[ buffer(1) ]])
    constexpr sampler linearSampler(filter::linear);
    
    float u = in.uv.x;
    float v = in.uv.y;
    
    float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
    float3 n = normalize(dir);
    
    float3 L = scn_irradiance_cube(environmentProbe, samplingMipLevel, n);
    return float4(L, 1.0);
    "passes" : {
        "SceneKit_renderDepth" : {
            "outputs" : {
                "depth" : "depth-target",
                "color" : "normal-target"
            },
            "depthStates" : {
                "clear" : true
            },
            "samples" : 1,
            "onlyShadowCasters" : true,
            "__clientProgram" : "NO",
            "__metalFragmentShader" : "render_normals_lineardepth_fragment",
            "draw" : "DRAW_SCENE",
            "__metalVertexShader" : "render_normals_lineardepth_vertex",
            "__program" : "renderNormalsAndLinearDepth"
        },
        "SceneKit_composeSSAO" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "aoSampler" : "ssao-target",
                "colorSampler" : "COLOR",
                "a_position" : "a_position-symbol"
            },
            "metalVertexShader" : "compose_ssao_vertex",
            "metalFragmentShader" : "compose_ssao_fragment",
            "debugMetalLibraryFile" : "C3D-SSAO.metal",
            "program" : "compose-ssao",
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO"
        },
        "SceneKit_computeSSAO" : {
            "outputs" : {
                "color" : "ssao-target"
            },
            "inputs" : {
                "depthMap" : "depth-target",
                "factor" : "factor",
                "rnm" : {
                    "target" : "rnm-symbol",
                    "sampler" : {
                        "wrapS" : "repeat",
                        "magnificationFilter" : "linear",
                        "minificationFilter" : "linear",
                        "wrapT" : "repeat"
                    }
                },
                "ssaoParams" : "ssaoParams",
                "normalMap" : "normal-target",
                "a_position" : "a_position-symbol",
                "inv_ZRange" : "inv_ZRange-symbol"
            },
            "metalVertexShader" : "compute_ssao_vertex",
            "metalFragmentShader" : "compute_ssao_fragment",
            "debugMetalLibraryFile" : "C3D-SSAO.metal",
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO"
        },
        "SceneKit_blurSSAOH" : {
            "outputs" : {
                "color" : "ssao-target-tmp"
            },
            "inputs" : {
                "aoMap" : "ssao-target",
                "depthMap" : "depth-target",
                "normalMap" : "normal-target",
                "ssaoParams" : "ssaoParams",
                "offsets" : "C3D-blur-offsets",
                "weights" : "C3D-blur-weights",
                "n_sample" : "C3D-blur-samples"
            },
            "metalVertexShader" : "draw_quad_vertex",
            "metalFragmentShader" : "blur_ssao_frag",
            "debugMetalLibraryFile" : "C3D-SSAO.metal",
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO"
        },
        "SceneKit_blurSSAOV" : {
            "outputs" : {
                "color" : "ssao-target"
            },
            "inputs" : {
                "aoMap" : "ssao-target-tmp",
                "depthMap" : "depth-target",
                "normalMap" : "normal-target",
                "ssaoParams" : "ssaoParams",
                "offsets" : "C3D-blur-offsets",
                "weights" : "C3D-blur-weights",
                "n_sample" : "C3D-blur-samples"
            },
            "metalVertexShader" : "draw_quad_vertex",
            "metalFragmentShader" : "blur_ssao_frag",
            "debugMetalLibraryFile" : "C3D-SSAO.metal",
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO"
        }
    },
    "sequence" : [
                  "SceneKit_renderDepth",
                  "SceneKit_computeSSAO",
                  "SceneKit_blurSSAOH",
                  "SceneKit_blurSSAOV"
                  ],
    "symbols" : {
        "rnm-symbol" : {
            "image" : "noise.png",
            "type" : "sampler2D"
        },
        "factor" : {
            "type" : "float"
        },
        "a_position-symbol" : {
            "semantic" : "vertex"
        },
        "a_normal-symbol" : {
            "semantic" : "normal"
        },
        "inv_ZRange-symbol" : {
            "type" : "float"
        },
        "u_sphereSamples-symbol" : {
            "type" : "none"
        },
        "u_normalTransform-symbol" : {
            "semantic" : "normalTransform"
        },
        "u_modelViewProjectionTransform-symbol" : {
            "semantic" : "modelViewProjectionTransform"
        },
        "ssaoParams" : {
            "type" : "vec4"
        },
        "C3D-blur-offsets" : {
            "type" : "vec2[31]"
        },
        "C3D-blur-weights" : {
            "type" : "float[31]"
        },
        "C3D-blur-samples" : {
            "type" : "int"
        },
        "noiseSampler-symbol" : {
            "type" : "none"
        },
        "u_modelViewTransform-symbol" : {
            "semantic" : "modelViewTransform"
        },
        "u_inverseProjectionTransform-symbol" : {
            "semantic" : "projectionInverseTransform"
        }
    },
    "targets" : {
        "depth-target" : {
            "type" : "depth"
        },
        "normal-target" : {
            "format" : "rgba",
            "type" : "color"
        },
        "ssao-target" : {
            "format" : "r8",
            "type" : "color",
            "global" : "true"
        },
        "ssao-target-tmp" : {
            "format" : "r8",
            "type" : "color"
        }
    }
#import <metal_stdlib>
using namespace metal;
///////////////////////////////////////////////////////////////////////////////////
// Compute kernels
typedef struct
    packed_float3 position;
} morphvertex_t;
kernel void morph_copy_kernel(uint index          [[ thread_position_in_grid ]],
                         device morphvertex_t* out      [[ buffer(0) ]],
                         device morphvertex_t* base     [[ buffer(4) ]])
    out[index].position = base[index].position;
kernel void morph_blend_kernel(uint index          [[ thread_position_in_grid ]],
                          device morphvertex_t* out      [[ buffer(0) ]],
                          device morphvertex_t* delta    [[ buffer(4) ]],
                          constant float& weight         [[ buffer(3) ]])
    out[index].position += weight * delta[index].position;
// Position + Normal
typedef struct
    packed_float3 position;
    packed_float3 normal;
} morph_target_PN;
kernel void morph_copy_pn_kernel(uint index          [[ thread_position_in_grid ]],
                              device packed_float3* outP       [[ buffer(0) ]],
                              device packed_float3* outN       [[ buffer(1) ]],
                              device morph_target_PN* src      [[ buffer(4) ]])
    outP[index] = src[index].position;
//    outN[index][0] = srcN[index][0];
//    outN[index][1] = 0; //srcN[index][1]; break in Muir220 !!!!
//    outN[index][2] = srcN[index][2];
//    = float3(0,1,0);
    outN[index] = src[index].normal;
kernel void morph_blend_pn_kernel(uint index          [[ thread_position_in_grid ]],
                               device packed_float3* outP       [[ buffer(0) ]],
                               device packed_float3* outN       [[ buffer(1) ]],
                               constant float& weight         [[ buffer(3) ]],
                               device morph_target_PN* delta  [[ buffer(4) ]])
    outP[index] += weight * delta[index].position;
    outN[index] += weight * delta[index].normal;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>color1</key>
<string>ALBEDO</string>
<key>color2</key>
<string>NORMAL_DEPTH</string>
<key>color3</key>
<string>DS3</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>drawSceneIncludesOverlays</key>
<true/>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
<key>targets</key>
<dict>
<key>ALBEDO</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>NORMAL_DEPTH</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba32f</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>DS3</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba32f</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
// Attributes
attribute vec4 a_position;
//uniforms
uniform mat4 u_modelViewProjectionTransform;
void main()
    gl_Position = u_modelViewProjectionTransform * a_position;
    "sequence" : ["SceneKit_stereoLeftEye", "SceneKit_stereoRightEye", "SceneKit_stereoResolveLeft", "SceneKit_stereoResolveRight"],
    "passes" : {
        "SceneKit_stereoLeftEye" : {
            "outputs" : {
                "color" : "SceneKit_stereo-leftColor",
                "depth" : "SceneKit_stereo-leftDepth"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "true",
                "clearColor" : "sceneBackground"
            },
            "depthStates" : {
                "clear" : "true"
            }
        },
        "SceneKit_stereoRightEye" : {
            "outputs" : {
                "color" : "SceneKit_stereo-rightColor",
                "depth" : "SceneKit_stereo-rightDepth"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "true",
                "clearColor" : "sceneBackground"
            },
            "depthStates" : {
                "clear" : "true"
            }
        },
        "SceneKit_stereoResolveLeft" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorSampler" : "SceneKit_stereo-leftColor",
                "interaxialDistance" : "interaxialDistance",
                "eye" : "eye",
                "viewport" : "viewport",
                "inputScale" : "inputScale",
                "outputScale" : "outputScale",
                "lensCenterOffset" : "lensCenterOffset",
                "hmdWarpParam" : "hmdWarpParam"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "false",
            },
            "depthStates" : {
                "clear" : "false"
            },
            "program" : "C3D-Stereoscopy-ResolveHmd",
            "metalVertexShader" : "C3DStereoscopy_ResolveHmd_vert",
            "metalFragmentShader" : "C3DStereoscopy_ResolveHmd_frag"
        },
        "SceneKit_stereoResolveRight" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorSampler" : "SceneKit_stereo-rightColor",
                "interaxialDistance" : "interaxialDistance",
                "eye" : "eye",
                "viewport" : "viewport",
                "inputScale" : "inputScale",
                "outputScale" : "outputScale",
                "lensCenterOffset" : "lensCenterOffset",
                "hmdWarpParam" : "hmdWarpParam"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "false",
            },
            "depthStates" : {
                "clear" : "false"
            },
            "program" : "C3D-Stereoscopy-ResolveHmd",
            "metalVertexShader" : "C3DStereoscopy_ResolveHmd_vert",
            "metalFragmentShader" : "C3DStereoscopy_ResolveHmd_frag"
        }
    },
    "symbols" : {
        "interaxialDistance" : {
            "type" : "float"
        },
        "eye" : {
            "type" : "float"
        },
        "inputScale" : {
            "type" : "float"
        },
        "outputScale" : {
            "type" : "float"
        },
        "lensCenterOffset" : {
            "type" : "vec2"
        },
        "hmdWarpParam" : {
            "type" : "vec4"
        },
        "viewport" : {
            "type" : "vec4"
        }
    },
    "targets" : {
        "SceneKit_stereo-leftColor" : {
            "type" : "color"
        },
        "SceneKit_stereo-rightColor" : {
            "type" : "color"
        },
        "SceneKit_stereo-leftDepth" : {
            "type" : "depth"
        },
        "SceneKit_stereo-rightDepth" : {
            "type" : "depth"
        }
    },
    "stereoscopy" : {
        "relativeViewportsAffectAspectRatio" : "true",
        "leftEyeRelativeViewport" : "0.0 0.0 0.5 1.0",
        "rightEyeRelativeViewport" : "0.5 0.0 0.5 1.0"
    }
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
varying vec3 v_position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
varying vec3 v_normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
varying vec3 v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
varying vec3 v_bitangent;
#endif
#ifdef USE_AMBIENT_LIGHTING
uniform vec4 u_ambientLightColor;
#endif
#ifdef USE_DIFFUSE_MAP
uniform sampler2D u_diffuseTexture;
#ifdef USE_DIFFUSE_INTENSITY
uniform float u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
uniform vec4 u_diffuseColor;
#endif
#ifdef USE_NORMAL_MAP
uniform sampler2D u_normalTexture;
#ifdef USE_NORMAL_INTENSITY
uniform float u_normalIntensity;
#endif
#endif
#ifdef USE_SHININESS
uniform float u_materialShininess;
#endif
#ifdef USE_SPECULAR
#ifdef USE_SPECULAR_MAP
uniform sampler2D u_specularTexture;
#ifdef USE_SPECULAR_INTENSITY
uniform float u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
uniform vec4 u_specularColor;
#endif
#endif // USE_SPECULAR
#ifdef USE_AMBIENT_MAP
uniform sampler2D u_ambientTexture;
#ifdef USE_AMBIENT_INTENSITY
uniform float u_ambientIntensity;
#endif
#elif defined(USE_AMBIENT_COLOR)
uniform vec4 u_ambientColor;
#endif
#ifdef USE_REFLECTIVE_MAP
uniform sampler2D u_reflectiveTexture;
#elif defined(USE_REFLECTIVE_COLOR)
uniform vec4 u_reflectiveColor;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform samplerCube u_reflectiveTexture;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform mat4 u_viewToCubeWorld;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
uniform float u_reflectiveIntensity;
#endif
#ifdef USE_FRESNEL
uniform vec3 u_fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
#endif
#ifdef USE_EMISSION_MAP
uniform sampler2D u_emissionTexture;
#ifdef USE_EMISSION_INTENSITY
uniform float u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
uniform vec4 u_emissionColor;
#endif
#ifdef USE_MULTIPLY_MAP
uniform sampler2D u_multiplyTexture;
#ifdef USE_MULTIPLY_INTENSITY
uniform float u_multiplyIntensity;
#endif
#elif defined(USE_MULTIPLY_COLOR)
uniform vec4 u_multiplyColor;
#endif
#ifdef USE_TRANSPARENT_MAP
uniform sampler2D u_transparentTexture;
#ifdef USE_TRANSPARENT_INTENSITY
uniform float u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
uniform vec4 u_transparentColor;
#endif
#ifdef USE_VERTEX_COLOR
varying vec4 v_vertexColor;
#endif
#ifdef USE_NODE_OPACITY // only for RGB_ZERO
uniform float u_nodeOpacity;
#endif
#ifdef USE_TRANSPARENCY // only for RGB_ZERO
uniform float u_transparency;
#endif
#ifdef USE_DOUBLE_SIDED
uniform float u_orientationPreserved;
#endif
#ifdef USE_TIME
uniform float u_time;
#endif
#ifdef USE_FOG
uniform vec4 u_fogColor;
uniform vec3 u_fogParameters; // x:-1/(end-start) y:1-start*x z:exp
#endif
float saturate(float x) {
    return clamp(x, 0., 1.);
vec2 saturate(vec2 x) {
    return clamp(x, vec2(0.), vec2(1.));
vec3 saturate(vec3 x) {
    return clamp(x, vec3(0.), vec3(1.));
vec4 saturate(vec4 x) {
    return clamp(x, vec4(0.), vec4(1.));
vec4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    vec4 color = vec4(0.,0.,0., surface.diffuse.a);
    
    vec3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    D += lighting.ambient * surface.ambientOcclusion;
#elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
    D += lighting.ambient;
#endif
#endif //  defined(USE_AMBIENT_LIGHTING)
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    
    // Do we want to clamp there ????
    
    color.rgb = surface.diffuse.rgb * D;
#if 1 // NEW_REFLECTIVE_BEHAVIOR
#ifdef USE_SPECULAR
    vec3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    vec3 S = vec3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambientOcclusion;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif // NEW_REFLECTIVE_BEHAVIOR
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
struct SCNOutput
    vec4 color;
} _output;
void main(void)
#ifdef USE_TEXCOORD
    __DoTexcoord__
#endif
    
    _surface.ambientOcclusion = 1.0;
    
    //ambient
#ifdef USE_AMBIENT_MAP
    _surface.ambient = texture2D(u_ambientTexture, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambientOcclusion = mix(1., _surface.ambient.r, u_ambientIntensity);
#else
    _surface.ambient *= u_ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = u_ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = vec4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= v_vertexColor;
#endif
    
    //diffuse
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = texture2D(u_diffuseTexture, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = u_diffuseColor;
#elif defined(USE_DIFFUSE)
    _surface.diffuse = vec4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= v_vertexColor;
#endif
    
    //specular
#ifdef USE_SPECULAR_MAP
    _surface.specular = texture2D(u_specularTexture, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = u_specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = vec4(0.);
#endif
    
    //emission
#ifdef USE_EMISSION_MAP
    _surface.emission = texture2D(u_emissionTexture, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = u_emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = vec4(0.);
#endif
    
    //multiply
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = texture2D(u_multiplyTexture, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(vec4(1.), _surface.multiply, u_multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = u_multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = vec4(1.);
#endif
    
    //transparent
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = texture2D(u_transparentTexture, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = u_transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = vec4(1.);
#endif
    
    //normal
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(v_normal.xyz) * u_orientationPreserved * ((float(gl_FrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(v_normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = v_bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = v_position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-v_position);
#endif
#ifdef USE_NORMAL_MAP
    mat3 ts2vs = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = texture2D(u_normalTexture, _surface.normalTexcoord).rgb * 2. - 1.;
    // _surface.normal.z = 1. - sqrt(_surface.normal.x * _surface.normal.x + _surface.normal.y * _surface.normal.y);
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(vec3(0., 0., 1.), _surface._normalTS, u_normalIntensity);
#endif
    // transform the normal in view space
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = vec3(0., 0., 0.);
#endif
    
    //reflective
#ifdef USE_REFLECTIVE_MAP
    vec3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = texture2D(u_reflectiveTexture,vec2(vec2(refl.x,-refl.y) / m) + 0.5) ;
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    vec3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = textureCube(u_reflectiveTexture, mat3(u_viewToCubeWorld) * refl); // sample the cube map in world space
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = u_reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = vec4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = u_fresnel.x + u_fresnel.y * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), u_fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = u_materialShininess;
#endif
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    
    
    // Lighting
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = u_ambientLightColor.rgb;
#elif defined(USE_AMBIENT)
    _lightingContribution.ambient = vec3(0.);
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = vec3(0.);
#ifdef USE_MODULATE
    _lightingContribution.modulate = vec3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = vec3(0.);
#endif
    
    __DoLighting__
    
#else // USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = v_diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = v_specular;
#endif
#endif
    
    
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = clamp(_lightingContribution.diffuse, vec3(0.), vec3(1.));
#ifdef USE_SPECULAR
    _lightingContribution.specular = clamp(_lightingContribution.specular, vec3(0.), vec3(1.));
#endif // USE_SPECULAR
#endif // AVOID_OVERLIGHTING
#else // USE_LIGHTING
    _lightingContribution.diffuse = vec3(1.);
#endif // USE_LIGHTING
    
    // Combine
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * u_fogParameters.x + u_fogParameters.y, 0., u_fogColor.a), u_fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, u_fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
#ifdef USE_TRANSPARENT // Either a map or a color
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= u_transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= u_nodeOpacity;
#endif
    // compute luminance
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (vec4(1.) - _surface.transparent);
#else // ALPHA_ONE
    _output.color *= _surface.transparent.a;
#endif
#else
#ifdef USE_TRANSPARENCY // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
    _output.color *= u_transparency;
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) // we could set a different limit here
        discard;
#endif
    
    gl_FragColor = _output.color;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
constant bool enableLighting        [[ function_constant(0) ]];
constant bool enableColorRamp       [[ function_constant(1) ]];
constant bool enableCubeMap         [[ function_constant(2) ]];
constant bool enableStretch         [[ function_constant(3) ]];
constant bool enableFog             [[ function_constant(4) ]];
constant bool enableAnimation       [[ function_constant(5) ]];
constant uint orientation           [[ function_constant(6) ]];
constant uint animationMode         [[ function_constant(7) ]];
constant uint blendMode             [[ function_constant(8) ]];
/// Enums
enum {
    kC3DParticleBlendModeAdditive,
    kC3DParticleBlendModeSubtract,
    kC3DParticleBlendModeMultiply,
    kC3DParticleBlendModeScreen,
    kC3DParticleBlendModeAlpha,
    kC3DParticleBlendModeReplace
enum  {
    kC3DParticleOrientationModeBillboardScreenAligned,
    kC3DParticleOrientationModeBillboardViewAligned,
    kC3DParticleOrientationModeFree, 
   // free on all axis
    kC3DParticleOrientationModeBillboardYAligned // fixed on Y axis
constexpr sampler linear_sampler(filter::linear, mip_filter::nearest, address::clamp_to_edge);
static float3x3 axisangle_to_matrix(float4 axis_angle)
    float c;
    float s = sincos(axis_angle.w, c);
    float t = 1. - c;
    
    float3x3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
    float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
constexpr sampler anim_sampler(filter::linear, mip_filter::nearest, address::repeat);
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
static inline float4 ComputeUVS(float2 iNormUV, float iFrame, float4 iFrameSize)
    float4 outUV;
    
    switch (animationMode)
    {
        case CLAMP:
        {
            iFrame = clamp(iFrame, 0., iFrameSize.w - 1.); // clamp frame
            
            float intFrame;
            float frameFrac = modf(iFrame, intFrame);
            float2 frame;
            float intPart;
            frame.x = modf(intFrame * iFrameSize.x, intPart);
            frame.y = intPart * iFrameSize.y;
            
            outUV.xy = frame + iNormUV * iFrameSize.xy;
            outUV.w = frameFrac;
            outUV.z = step(0.9999, frame.x + iFrameSize.x); // next row or not
        } break;
         
        case REPEAT:
        {
            float tmp = iFrame * iFrameSize.x;
            
            float2 frame;
            frame.y = tmp - fract(tmp);
            frame.x = fract(tmp) * iFrameSize.z;
            
            float frameFrac = fract(frame.x);
            frame.x -= frameFrac;
            
            outUV.xy = (frame + iNormUV) * iFrameSize.xy;
            outUV.w = frameFrac;
            outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
        } break;
            
        default: // AUTOREVERSE
        {
            float invFrameCount = iFrameSize.x * iFrameSize.y;
            float normFrame = iFrame * invFrameCount;
            float lastFrame = iFrameSize.w - 1.;
            float frameIndex = fract(normFrame) * iFrameSize.w;
            if (fract(normFrame * 0.5) > 0.5) {
                frameIndex = (lastFrame-frameIndex);
            }
            
            frameIndex = clamp(frameIndex, 0., lastFrame); // clamp frame
            
            float tmp = frameIndex * iFrameSize.x;
            
            float2 frame;
            frame.y = tmp - fract(tmp);
            
            frame.x = fract(tmp) * iFrameSize.z;
            
            float frameFrac = fract(frame.x);
            frame.x -= frameFrac;
            
            outUV.xy = (frame + iNormUV) * iFrameSize.xy;
            
            outUV.w = frameFrac;
            outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
        }
    }
    return outUV;
typedef struct {
    // vertex data
    float2 texCoord1 [[attribute(SCNVertexSemanticTexcoord1)]]; // x:cornerX y:cornerY
    
    // instance data
    float4 position [[attribute(SCNVertexSemanticPosition)]]; // xyz: position, w:angle
    float3 texCoord0 [[attribute(SCNVertexSemanticTexcoord0)]]; // x:life y:size z:frame (texture animation)
    float4 color [[attribute(SCNVertexSemanticColor)]]; // particle color
    // only valid if enableStretch or orientationFree
    float4 texCoord2 [[attribute(SCNVertexSemanticTexcoord2)]]; // velocity of the particle in .xyz
} particle_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 vertexColor;
    float3 uv0;
    float2 uv1;
    float fogFactor;
    
    float3 normal;
} particle_io;
typedef struct {
    float4x4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
    float u_fresnelExponent;
    float u_stretchFactor;
    // enableLighting
    float3 u_lightPosition0; // in modelViewSpace already
    float4 u_lightColor0;
    float4 u_frameSize; // 1/dimX, 1/dimY, dimX, dimX*dimY
} particle_uniforms;
vertex particle_io uberparticle_vert(particle_vertex_t in               [[ stage_in ]],
                                 texture2d<float> u_colorRamp           [[texture(0)]],
                                 constant SCNSceneBuffer& scn_frame     [[buffer(0)]],
                                 constant particle_uniforms& scn_part   [[buffer(1)]])
    particle_io out;
    
    // transform the particle in view space
    float4 viewPos = scn_part.viewTransform * float4(in.position.xyz, 1);
    float3 N; // used for lighting and cubemaps
    
    if (enableStretch) {
        
        // compute the trail direction in viewSpace
        float4 viewDir = scn_part.viewTransform * float4(in.texCoord2.xyz, 0);
        viewDir *= scn_part.u_stretchFactor;
        
        // move the top vertices to the end of the trail
        viewPos.xyz += (in.texCoord1.y > 0.) ? viewDir.xyz : float3(0.);
        
        // compute the billboarding offsets
        //    float len = length(viewDir.xy);
        //    vec2 u = (len > 0.) ? viewDir.xy/len : vec2(0,1);
        float2 u = normalize(viewDir.xy); // divide by 0 seems to work.. otherwise replace by code commented beneath
        float2 r = float2(-u.y, u.x);
        float2 off = r * in.texCoord1.x + u * in.texCoord1.y ; // offset
        viewPos.xy += off * in.texCoord0.y; // * size
        
        N = normalize(float3(-off.x, -off.y, -2));
        
    } else { // enableStretch
        
        // TODO only rotate if needed (angle != 0)
        float cs;
        float sn = sincos(in.position.w, cs);
        
        // expand the quad corners
        float2 dir = { in.texCoord1.x * cs - in.texCoord1.y * sn,  in.texCoord1.y * cs + in.texCoord1.x * sn };
        dir *= in.texCoord0.y;
        
        switch (orientation) {
            case kC3DParticleOrientationModeFree:
            {
                // TODO : we should work in world space then ? the transform is in worldSpace or localSpace...
                // TODO with version 120 we would not need this....
                float3x3 vt = float3x3(scn_part.viewTransform[0].xyz, scn_part.viewTransform[1].xyz, scn_part.viewTransform[2].xyz);
                float3x3 mat = vt * axisangle_to_matrix(in.texCoord2); // mat3(viewTransform)
                
                if (enableCubeMap) {
                    N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
                    viewPos.xy += dir;
                } else {
                    N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
                    
                    float3 off = mat[0] * dir.x + mat[1] * dir.y;
                    viewPos.xyz += off;
                }
                
                // TODO we should also tranform the normal for the lighting !!!!!
            } break;
                
            case kC3DParticleOrientationModeBillboardViewAligned:
            {
                float3 u = float3(0,1,0);
                float3 r = normalize(cross(u, -viewPos.xyz));
                float3 off = dir.x * r + dir.y * u;
                viewPos.xyz += off;
                N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
            } break;
                
            case kC3DParticleOrientationModeBillboardYAligned:
            {
                float3 u = (scn_part.viewTransform * float4(0, 1, 0, 0)).xyz;
                float3 r = normalize(cross(u, float3(0,0,1))); // Screen Aligned
                //    vec3 r = normalize(cross(u, -viewPos.xyz)); // ViewAligned
                float3 off = dir.x * r + dir.y * u;
                viewPos.xyz += off;
                N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
            } break;
                
            default: // ScreenAligned
            {
                viewPos.xy += dir;
                N = normalize(float3(-dir.x, -dir.y, -2));
            } break;
        }
    } // enableStretch
    
    if (enableCubeMap) {
        if (orientation == kC3DParticleOrientationModeFree)
            out.normal.xyz = N;
        else {
            float3 refl = reflect( viewPos.xyz, N );
            out.normal.xyz = scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl);
        }
    }
    
    if (enableColorRamp) {
        constexpr sampler ramp_sampler(filter::linear, mip_filter::none, address::clamp_to_edge);
        out.vertexColor = in.color * u_colorRamp.sample(ramp_sampler, in.texCoord0.xx);
    } else {
        // use vertex color (OPTIM : use constant color if not varying)
        out.vertexColor = in.color;
    }
    
#ifndef ENABLE_BLACKPASS
    if (enableLighting) {
        float3 L = normalize(viewPos.xyz - scn_part.u_lightPosition0);
        
        if ((orientation == kC3DParticleOrientationModeFree) && !enableCubeMap) {
            // if we want to bend the normal (but free orientation doesn't need too right ?)
            // vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? -normalize(-mat[2] + 0.1 * off) : -normalize(mat[2] + 0.1 * off);
            //    vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? mat[2] : -mat[2];
            
            // simple lambertian + back light diffusion
            float NdotL = dot(N, L);
            //    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * max(0., -NdotL));
            float3 diff = scn_part.u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
            
            // Specular
            float _shininess = 100.0;
            float3 halfVector = normalize(L + viewPos.xyz);
            float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
            out.vertexColor.rgb = out.vertexColor.rgb * diff + spec;
        } else {
            // simple lambertian
            float3 diff = float3(max(0.0, dot(N, L))) * scn_part.u_lightColor0.rgb;
            
            // trilight model (lambertian + wrap around + hemispheric)
            //vec3 diff = lightColor0 * max(0., NdotL) + lightColor1 * (1. - abs(NdotL)) + lightColor2 * max(0., -NdotL);
            
            // todo : support ambient !!!!!!!!!!
            // diff += vec3(0.5);
            
            out.vertexColor.rgb *= diff;
        }
    }
#endif // ENABLE_BLACKPASS
    
    // TexCoord
    if (enableAnimation) {
        float4 animUVS = ComputeUVS(in.texCoord1.xy * float2(0.5, -0.5) + 0.5, in.texCoord0.z, scn_part.u_frameSize);
        out.uv0 = animUVS.xyw;
        out.uv1 = animUVS.xy + scn_part.u_frameSize.xy * float2(1.0, animUVS.z);// + float2(-animUVS.z, 0); add this if you don't want wrap behavior in the sampler
    } else {
        out.uv0.xy = in.texCoord1.xy * float2(0.5, -0.5) + 0.5;
    }
    
#ifndef ENABLE_BLACKPASS
    if (enableFog) {
        float fogFactor = pow(clamp(abs(viewPos.z) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0.0, scn_frame.fogColor.a), scn_frame.fogParameters.z);
        switch (blendMode) {
            case kC3DParticleBlendModeMultiply:
            case kC3DParticleBlendModeAlpha:
                out.fogFactor = fogFactor;
                break;
            case kC3DParticleBlendModeReplace:
                out.vertexColor.rgb = mix(out.vertexColor.rgb, scn_frame.fogColor.rgb, fogFactor);
                break;
            case kC3DParticleBlendModeAdditive:
            case kC3DParticleBlendModeSubtract:
            case kC3DParticleBlendModeScreen:
                out.vertexColor.rgb *= (1 - fogFactor);
                break;
        }
    } // enableFog
#endif // ENABLE_BLACKPASS
    
    out.position = scn_frame.projectionTransform * viewPos;
    return out;
// Fragment shader function
fragment half4 uberparticle_frag(particle_io in [[stage_in]],
                                 constant particle_uniforms& pass       [[buffer(0)]],
                                 constant SCNSceneBuffer& scn_frame     [[buffer(1)]],
                                 texture2d<float> u_textureSampler0     [[texture(0)]]
                             )
    float4 tex;
    if (enableAnimation) { // blend between two frames
        tex = mix(u_textureSampler0.sample(anim_sampler, in.uv0.xy),
                         u_textureSampler0.sample(anim_sampler, in.uv1.xy), in.uv0.z);
    } else {
        tex = u_textureSampler0.sample(linear_sampler, in.uv0.xy);
    }
    float4 fragColor = in.vertexColor * tex; // texture and colors need to be premultiplied
    if (enableFog) {
        
        switch(blendMode) {
            case kC3DParticleBlendModeAlpha:
                fragColor.rgb = mix(fragColor.rgb, scn_frame.fogColor.rgb * fragColor.a, in.fogFactor); // fog needs to be premultiplied too
                break;
            case kC3DParticleBlendModeMultiply:
                fragColor.rgb = mix(fragColor.rgb, float3(1), in.fogFactor);
                break;
        }
    }
    return half4(fragColor);
fragment half4 uberparticleCube_frag(particle_io in [[stage_in]],
                                 constant particle_uniforms& pass       [[buffer(0)]],
                                 constant SCNSceneBuffer& scn_frame     [[buffer(1)]],
                                 texturecube<float> u_textureSampler0   [[texture(0)]]
                                 )
    float2 p = in.uv0.xy * 2. - 1.;
    float r = dot(p,p); // len^2
    //    vec4 tex = vec4(normalize(v_normal.xyz), 1.) * step(r, 1.);
    float4 tex = u_textureSampler0.sample(linear_sampler, in.normal.xyz) * saturate(9.6 - 10. * r);
    // fresnel modulation
    tex.rgb *= pow(r, pass.u_fresnelExponent);
    
    float4 fragColor;
    fragColor.a = in.vertexColor.a * tex.a; // texture and colors need to be premultiplied
    
    if (enableFog) {
        fragColor.rgb = mix(in.vertexColor.rgb + tex.rgb, scn_frame.fogColor.rgb, in.fogFactor) * fragColor.a; // texture and colors need to be premultiplied
    } else {
        fragColor.rgb = (in.vertexColor.rgb + tex.rgb) * fragColor.a; // texture and colors need to be premultiplied
    }
    return half4(fragColor);
uniform sampler2D colorBuffer;
uniform sampler2D outlineColorBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    vec4 pixel = vec4(0.);
    float alpha = 0.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
    {
        vec4 tex = texture2D(outlineColorBuffer, uv+vec2(i,j)*u_inverseResolution);
        pixel = max(pixel, tex );
        alpha += tex.a/9.;
    }
    alpha = mix(alpha, pixel.a, 0.5);
    
    //Final antialiased mix
    gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(pixel.rgb,1.), vec4(smoothstep(0.,1.,alpha)) );
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
typedef struct
    float4x4 modelViewProjectionTransform;
    float4x4 viewToCubeTransform;
    float zfar;
} background_vertex_uniforms_t;
typedef struct
    float3 position [[attribute(0)]];
} background_vertex_t;
typedef struct {
    float4 position [[position]];
    float2 texcoord;
} background_2D_io;
typedef struct {
    float4 position [[position]];
    float3 texcoord;
} background_cube_io;
vertex background_2D_io background_2D_vert(background_vertex_t in [[ stage_in ]],
                                              constant background_vertex_uniforms_t& uniforms [[buffer(0)]])
    float4 in_position = float4(in.position, 1.0);
    background_2D_io out;
    out.position = in_position;
    out.texcoord = (uniforms.modelViewProjectionTransform * in_position).xy * float2(0.5, -0.5) + 0.5;
    return out;
vertex background_2D_io background_2D_vertid(constant background_vertex_uniforms_t& uniforms [[buffer(0)]],
                                             uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = 1.0 - (float)(v_id % 2) * 2.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    background_2D_io out;
    out.position = in_position;
    out.texcoord = (uniforms.modelViewProjectionTransform * in_position).xy * float2(0.5, -0.5) + 0.5;
    return out;
// Fragment shader function
fragment half4 background_2D_frag(background_2D_io in [[stage_in]],
                                  texture2d<float> tex2D [[texture(0)]],
                                  sampler samp [[sampler(0)]])
    float4 color = tex2D.sample(samp, in.texcoord);
    return half4(color);
vertex background_cube_io background_cube_vert(background_vertex_t in [[ stage_in ]],
                                        constant background_vertex_uniforms_t& uniforms [[buffer(0)]])
    float4 in_position = float4(in.position, 1.0);
    background_cube_io out;
    out.position = (uniforms.modelViewProjectionTransform * in_position);
    out.texcoord = scn::mat4_mult_float3(uniforms.viewToCubeTransform, in_position.xyz);
    return out;
vertex background_cube_io background_cube_vertid(constant background_vertex_uniforms_t& uniforms [[buffer(0)]],
                                                 uint v_id [[ vertex_id ]])
    float4 in_position;
    // generate cube vertices
    in_position.x = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id / 4) * 2.0 - 1.0;
    in_position.z = (float)((v_id % 4) / 2) * 2.0 - 1.0;
    in_position.w = 1.0;
    
    // need to rescale the cube
    in_position.xyz *= uniforms.zfar;
    
    background_cube_io out;
    out.position = (uniforms.modelViewProjectionTransform * in_position);
    out.texcoord = scn::mat4_mult_float3(uniforms.viewToCubeTransform, in_position.xyz);
    out.position.z = out.position.w * 0.999998; // we have to scale a little due to float imprecisions (zb~=1)
    return out;
// Fragment shader function
fragment half4 background_cube_frag(background_cube_io in [[stage_in]],
                                    texturecube<float> texCube [[texture(0)]],
                                    sampler samp [[sampler(0)]])
    float4 color = texCube.sample(samp, in.texcoord);
    return half4(color);
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
uniform float factor;
varying vec2 TexCoord;
void main (void)
    vec4 newFragment = texture2D(textureSampler0,TexCoord);
    vec4 oldColor = texture2D(textureSampler1,TexCoord);
    
    gl_FragColor = (factor-1.0)*(oldColor/factor) + newFragment/factor;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers // GL_ES 2
#extension GL_EXT_shadow_samplers : require
#endif
#endif
#if MAX_SAMPLE > 1
uniform vec4 u_kernel[MAX_SAMPLE];
#endif
uniform vec4 shadowColor;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers // GL_ES 2
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProjEXT( tex, coord )
#elif __VERSION__ <= 120 // GL Compatibility Profile
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProj( tex, coord ).x
#else // GL Core Profile or GL_ES 3
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) textureProj( tex, coord )
#endif
#else // NO PCF
    uniform sampler2D lightDepthSampler;
    #define __shadow2DProj(tex, coord) clamp(coord.z - texture2DProj(tex, coord).x * coord.w, 0.0, 1.0);
#endif
uniform mat4  camera_MVP_i;
uniform mat4  light_MVP;
uniform vec3  u_lightPos;
uniform vec3  u_lightDir;
uniform vec3  u_lightSpotAtt;
uniform float shadowRadius;
// shadow spot attenuation
#ifndef TARGET_OS_IPHONE
    #ifdef SPOT_SHADOW
        #define USE_SPOT_ATTENUATION 1
    #else
        #define USE_SPOT_ATTENUATION 0
    #endif
#else
    #define USE_SPOT_ATTENUATION 0
#endif
varying vec2 TexCoord;
vec3 unprojectPoint(vec3 screenPos)
vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
pTmp.w = 1.0;
pTmp = camera_MVP_i * pTmp;
    pTmp /= pTmp.w;
return vec3(pTmp);
void main (void)
    //get color (no blur mode)
    vec4 color = texture2D(colorSampler, TexCoord);
    
//get z
float depthValue = texture2D(depthSampler, TexCoord).x;
//unproject to get world position
vec3 worldPos = unprojectPoint(vec3(TexCoord, depthValue));
//project into light space
vec4 lightScreen =  light_MVP * vec4(worldPos, 1.0);
    
    // compute spot attenuation ---------------------------------------------------------------------------------------------
#if USE_SPOT_ATTENUATION
    vec3 lightToFragment = normalize(u_lightPos - worldPos);
    
    // TODO we should also consider also distance attenuation and GOBO...
    float att;
    if (u_lightSpotAtt.z == 0.0)
        att = step(u_lightSpotAtt.x, dot(lightToFragment, u_lightDir) + 0.00004);
    else
        att = pow(clamp(dot(lightToFragment, u_lightDir) * u_lightSpotAtt.x + u_lightSpotAtt.y, 0.0, 1.0), u_lightSpotAtt.z);
    
    if (att == 0.) {
        gl_FragColor = color.rgba;
        return;
    }
#endif // USE_SPOT_ATTENUATION
    //-----------------------------------------------------------------------------------------------------------------------
    
#if MAX_SAMPLE == 1
    float shadow = __shadow2DProj(lightDepthSampler, lightScreen);
#else
    // penumbra
    float filteringSizeFactor = shadowRadius * lightScreen.w;//(distLight - lightDepth)*shadowRadius / lightDepth ;
    
    //smooth all samples
    float totalAccum = 0.0;
    for(int i=0; i<MAX_SAMPLE; i++){
        totalAccum += __shadow2DProj(lightDepthSampler, lightScreen + (u_kernel[i] * filteringSizeFactor));
    }
    
    float shadow = totalAccum / float(MAX_SAMPLE);
#endif
    
#if !USE_SPOT_ATTENUATION
    shadow *= step(0., lightScreen.w);
#endif
    
    //    vec2 clamp = step(lightScreen.xy * lightScreen.xy, vec2(1.));
    //    shadow *= clamp.x * clamp.y;
    shadow *= shadowColor.a;
#if USE_SPOT_ATTENUATION
    shadow = shadow * att;
#endif
    
    //apply shadow on color buffer
    gl_FragColor = mix(color.rgba, vec4(shadowColor.rgb, 1.0),  shadow);
#import <metal_stdlib>
#import <metal_compute>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
// for cubemap utilities
#import "C3D-PBR.metal"
// MARK: lat-long to cubemap
kernel void compute_cubemap_from_latlong_views(texture2d<float, access::sample> latlongTexture [[ texture(0) ]],
                                               texture2d<float, access::write>  cubeFace0      [[ texture(1) ]],
                                               texture2d<float, access::write>  cubeFace1      [[ texture(2) ]],
                                               texture2d<float, access::write>  cubeFace2      [[ texture(3) ]],
                                               texture2d<float, access::write>  cubeFace3      [[ texture(4) ]],
                                               texture2d<float, access::write>  cubeFace4      [[ texture(5) ]],
                                               texture2d<float, access::write>  cubeFace5      [[ texture(6) ]],
                                               uint3                            index          [[ thread_position_in_grid ]])
    uint width = cubeFace0.get_width();
    uint height = cubeFace0.get_height();
    if (index.x >= width && index.y >= height)
        return;
    
    constexpr sampler smp = sampler(filter::linear, address::repeat);
    
    uint face = index.z;
    
    // uv in [0, 1]
    float2 uv = float2(float(index.x) / float(width - 1),
                       float(index.y) / float(height - 1));
    
    float3 dir = normalize(scn::cubemap_dir_from_uv(face, uv));
    
    float x = atan2(-dir.z, dir.x) / (2.0f * scn::PI);
    float y = acos(dir.y) / scn::PI;
    
    float4 color = latlongTexture.sample(smp, float2(x, y));
    
    switch(face) {
        case 0: cubeFace0.write(color, index.xy); break;
        case 1: cubeFace1.write(color, index.xy); break;
        case 2: cubeFace2.write(color, index.xy); break;
        case 3: cubeFace3.write(color, index.xy); break;
        case 4: cubeFace4.write(color, index.xy); break;
        case 5: cubeFace5.write(color, index.xy); break;
    }
#if SCN_METAL_SHADING_LANGUAGE_SUPPORTED_OSX
kernel void compute_cubemap_from_latlong(texture2d<float, access::sample>  latlongTexture [[ texture(0) ]],
                                         texturecube<float, access::write> texture        [[ texture(1) ]],
                                         uint3                             index          [[ thread_position_in_grid ]])
    uint width = texture.get_width();
    uint height = texture.get_height();
    if (index.x >= width && index.y >= height)
        return;
    
    constexpr sampler smp = sampler(filter::linear, address::repeat);
    
    uint face = index.z;
    
    // uv in [0, 1]
    float2 uv = float2(float(index.x) / float(width - 1),
                       float(index.y) / float(height - 1));
    
    float3 dir = normalize(scn::cubemap_dir_from_uv(face, uv));
    
    float x = atan2(-dir.z, dir.x) / (2.0f * scn::PI);
    float y = acos(dir.y) / scn::PI;
    
    float4 color = latlongTexture.sample(smp, float2(x, y));
    texture.write(color, index.xy, face);
#endif // SCN_METAL_SHADING_LANGUAGE_SUPPORTED_OSX
// MARK: cubemap to lat-long
kernel void compute_latlong_from_cubemap(texturecube<float, access::sample> cubemap        [[ texture(0) ]],
                                         texture2d<float, access::write>    latlongTexture [[ texture(1) ]],
                                         uint2                              index          [[ thread_position_in_grid ]])
    constexpr sampler smp = sampler(filter::linear, address::repeat);
    
    // uv in [0, 1]
    float2 uv = float2(float(index.x) / float(latlongTexture.get_width() - 1),
                       float(index.y) / float(latlongTexture.get_height() - 1));
    
    float theta = uv.y * scn::PI;
    float phi   = uv.x * 2.0f * scn::PI;
    
    float x = cos(phi) * sin(theta);
    float y = cos(theta);
    float z = sin(phi) * sin(theta);
    
    float4 color = cubemap.sample(smp, float3(x, y, -z));
    latlongTexture.write(color, index.xy);
uniform sampler2D sceneColor;
uniform sampler2D authoringColor;
uniform sampler2D sceneDepth;
uniform sampler2D authoringDepth;
varying vec2 uv;
void main()
    vec4 scene = texture2D(sceneColor, uv);
    vec4 authoring = texture2D(authoringColor, uv);
    float scene_depth = texture2D(sceneDepth, uv).r;
    float authoring_depth = texture2D(authoringDepth, uv).r;
    if(scene_depth < authoring_depth){
        authoring.rgb *= 0.75;
//        authoring.rgb = mix(authoring.rgb, vec3(dot(authoring.rgb, authoring.rgb)), 0.5);
    }
    
    gl_FragColor = mix(scene, authoring, authoring.a);
attribute vec3 a_position;
uniform mat4 u_mvp;
uniform float u_zfar;
varying vec3 TexCoord;
void main()
gl_Position = (u_mvp * vec4(a_position * u_zfar, 1.)).xyww;
//gl_Position = u_mvp * vec4(a_position, 1.);
//gl_Position.z = gl_Position.w*0.9999;
TexCoord = vec3(a_position.x, a_position.y, -a_position.z);
// dir.y *= -1.0;
uniform sampler2D leftEyeColorSampler;
uniform sampler2D rightEyeColorSampler;
varying vec2 uv;
void main()
    vec4 leftEyeColor = texture2D(leftEyeColorSampler, uv);
    vec4 rightEyeColor = texture2D(rightEyeColorSampler, uv);
#if 0
    //
    const mat4 leftEyeFilterMatrix = mat4(0.437, -0.062, -0.048, 0.0, // column first
                                          0.449, -0.062, -0.050, 0.0,
                                          0.164, -0.024, -0.017, 0.0,
                                          0.0, 0.0, 0.0, 0.5);
    
    const mat4 rightEyeFilterMatrix = mat4(-0.011, 0.377, -0.026, 0.0, // column first
                                           -0.032, 0.761, -0.093, 0.0,
                                           -0.007, 0.009, 1.234, 0.0,
                                           0.0, 0.0, 0.0, 0.5);
    
    gl_FragColor = leftEyeFilterMatrix * leftEyeColor + rightEyeFilterMatrix * rightEyeColor;
#endif
    
#if 0
    // http://www.david-romeuf.fr/3D/Anaglyphes/TCAnaglypheLSDubois/TransformationCouleursPourAnaglyphe.html
    // "A uniform metric for anaglyph computation" http://www.david-romeuf.fr/3D/Anaglyphes/TCAnaglypheLSDubois/ei06.pdf
    
    const mat4 leftEyeFilterMatrix = mat4(0.4154, -0.0458 , -0.0547, 0.0, // column first
                                          0.4710, -0.0484, -0.0615, 0.0,
                                          0.1669, -0.0257, 0.0128, 0.0,
                                          0.0, 0.0, 0.0, 0.5);
    
    const mat4 rightEyeFilterMatrix = mat4(-0.0109, 0.3756, -0.0651, 0.0, // column first
                                           -0.0364, 0.7333, -0.1287, 0.0,
                                           -0.0060, 0.0111, 1.2971, 0.0,
                                           0.0, 0.0, 0.0, 0.5);
    
    gl_FragColor = leftEyeFilterMatrix * leftEyeColor + rightEyeFilterMatrix * rightEyeColor;
#endif
    
#if 1
    // http://www.david-romeuf.fr/3D/Anaglyphes/TCAnaglypheLSDubois/TransformationCouleursPourAnaglyphe.html
    // "Producing anaglyphs from synthetic images" http://www.david-romeuf.fr/3D/Anaglyphes/TCAnaglypheLSDubois/ei03.pdf
    
    const mat4 leftEyeFilterMatrix = mat4(0.4561000, -0.0400822, -0.0152161, 0.0, // column first
                                          0.5004840, -0.0378246, -0.0205971, 0.0,
                                          0.1763810, -0.0157589, -0.0054686, 0.0,
                                          0.0, 0.0, 0.0, 0.5);
    
    const mat4 rightEyeFilterMatrix = mat4(-0.0434706, 0.3784760, -0.0721527, 0.0, // column first
                                           -0.0879388, 0.7336400, -0.1129610, 0.0,
                                           -0.00155529, -0.0184503, 1.2264000, 0.0,
                                           0.0, 0.0, 0.0, 0.5);
    
    gl_FragColor = leftEyeFilterMatrix * leftEyeColor + rightEyeFilterMatrix * rightEyeColor;
#endif
    
#if 0
    vec3 intensity = vec3(0.299, 0.587, 0.114);
    float leftIntensity = dot(intensity, leftEyeColor.rgb);
    float rightIntensity = dot(intensity, rightEyeColor.rgb);
    gl_FragColor = vec4(leftIntensity,
                        0.5 * leftIntensity + 0.5 * rightIntensity,
                        rightIntensity,
                        1.0);
#endif
    
#if 0
    // Optimized
    gl_FragColor = vec4(dot(vec2(0.7, 0.3), leftEyeColor.gb),
                        rightEyeColor.g,
                        rightEyeColor.b,
                        1.0);
#endif
    
#if 0
    // Half color
    gl_FragColor = vec4(dot(vec3(0.299, 0.587, 0.114), leftEyeColor.rgb),
                        rightEyeColor.g,
                        rightEyeColor.b,
                        1.0);
#endif
attribute vec3 a_position;
uniform mat4 u_m;
varying vec2 TexCoord;
void main(void)
gl_Position = u_m * vec4(a_position, 1.0);
TexCoord = (gl_Position.xy + 1.0) * 0.5;
  "sequence" : [
    "SceneKit_renderCINodeTree",
    "SceneKit_ApplyCIFilter",
    "SceneKit_renderCIQuad"
  ],
  "targets" : {
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-nodetree-color" : {
      "type" : "color"
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "draw" : "DRAW_NODE",
      "node" : "self",
      "ignoreFloors" : true,
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
        "colorStates" : {
            "clear" : true
        },
        "depthStates" : {
            "clear" : true
        },
    }
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
//    v_vertexColor = a_color;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>authoring</string>
<string>authoringBlend</string>
</array>
<key>targets</key>
<dict>
<key>authoring-color</key>
<dict>
<key>type</key>
<string>color</string>
</dict>
<key>authoring-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
</dict>
<key>passes</key>
<dict>
<key>authoring</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>authoring-color</string>
<key>depth</key>
<string>authoring-depth</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>0 0 0 0</string>
</dict>
</dict>
<key>authoringBlend</key>
<dict>
<key>clientProgram</key>
<string>NO</string>
<key>program</key>
<string>C3D-BlendAuthoring</string>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>sceneColor</key>
<string>COLOR</string>
<key>sceneDepth</key>
<string>DEPTH</string>
<key>authoringColor</key>
<string>authoring-color</string>
<key>authoringDepth</key>
<string>authoring-depth</string>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalVertexShader</key>
<string>blendAuthoring_vert</string>
<key>metalFragmentShader</key>
<string>blendAuthoring_frag</string>
</dict>
</dict>
</dict>
</plist>
#import <metal_stdlib>
using namespace metal;
#import "scn_util.h"
vertex scn::draw_quad_io_t scn_draw_quad_vertex(uint v_id [[ vertex_id ]])
    scn::draw_quad_io_t out;
    
    out.position = float4((v_id / 2) * 2.0 - 1.0,
                          (v_id % 2) * 2.0 - 1.0,
                          0.0,
                          1.0);
    
    out.uv = float2(v_id / 2,
                    1 - v_id % 2);
    
    return out;
fragment float4 scn_draw_quad_fragment(scn::draw_quad_io_t    in    [[ stage_in ]],
                                       texture2d<float> input_tex   [[texture(0)]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    return input_tex.sample(linear_sampler, in.uv);
static inline float correct_srgb_to_linear(float c)
    return (c <= 0.04045) ? c / 12.92 : powr((c + 0.055) / 1.055, 2.4);
static inline float3 correct_srgb_to_linear(float3 c)
    return float3(correct_srgb_to_linear(c.x),
                  correct_srgb_to_linear(c.y),
                  correct_srgb_to_linear(c.z)
    );
inline float3 correct_linear_to_srgb(float3 v) {
    
    // not needed since saturate should do the good thing
    // if (isnan(c))
    // return 0.f;
    
    v = saturate(v);
    
    v.x = (v.x < 0.0031308f) ? (12.92f * v.x) : (1.055f * pow(v.x, 1.f/2.4) - 0.055f);
    v.y = (v.y < 0.0031308f) ? (12.92f * v.y) : (1.055f * pow(v.y, 1.f/2.4) - 0.055f);
    v.z = (v.z < 0.0031308f) ? (12.92f * v.z) : (1.055f * pow(v.z, 1.f/2.4) - 0.055f);
    
    return v;
fragment float4 scn_draw_quad_fragment_sk(scn::draw_quad_io_t    in    [[ stage_in ]],
                                                   texture2d<float> input_tex   [[texture(0)]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float4 col = input_tex.sample(linear_sampler, in.uv);
    
    // spritekit alpha seems to be in gamma space -> need to linearize it
    col.a =  correct_srgb_to_linear(col.a);
    
    return col;
fragment float4 scn_draw_quad_gamma_fragment(scn::draw_quad_io_t    in   [[ stage_in ]],
                                       texture2d<float> input_tex      [[texture(0)]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float4 col = input_tex.sample(linear_sampler, in.uv);
    col.rgb = correct_srgb_to_linear(col.rgb);
    return col;
// initial geometry is [-1,1] in XY plane (so z is always 0)
  uniform vec3 u_floorNormal;
  uniform vec4 u_floorTangent;
  uniform vec3 u_floorCenter;
  uniform vec2 u_floorExtent;
#pragma body
  vec3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
  _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
  _geometry.normal = u_floorNormal;
  _geometry.tangent = u_floorTangent;
  // we could check if the texCoord are really needed with ifdef USE_xxxx_MAP , or, better, work only on texcoordN [0..1]
  vec2 tc;
  if (u_floorNormal.y != 0.)
    tc = _geometry.position.xz * 0.01;
  else if (u_floorNormal.z != 0.)
    tc = _geometry.position.xy * 0.01;
  else
    tc = _geometry.position.yz * 0.01;
  for (int i = 0; i < kSCNTexcoordCount; ++i)
    _geometry.texcoords[i] = tc;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PBR.metal"
// Inputs
typedef struct {
#ifdef USE_MODELTRANSFORM
    float4x4 modelTransform;
#endif
#ifdef USE_INVERSEMODELTRANSFORM
    float4x4 inverseModelTransform;
#endif
#ifdef USE_MODELVIEWTRANSFORM
    float4x4 modelViewTransform;
#endif
#ifdef USE_INVERSEMODELVIEWTRANSFORM
    float4x4 inverseModelViewTransform;
#endif
#ifdef USE_NORMALTRANSFORM
    float4x4 normalTransform;
#endif
#ifdef USE_MODELVIEWPROJECTIONTRANSFORM
    float4x4 modelViewProjectionTransform;
#endif
#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM
    float4x4 inverseModelViewProjectionTransform;
#endif
#ifdef USE_BOUNDINGBOX
    float2x3 boundingBox;
#endif
#ifdef USE_WORLDBOUNDINGBOX
    float2x3 worldBoundingBox;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    float orientationPreserved;
#endif
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    sh2_coefficients shCoefficients;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    sh3_coefficients shCoefficients;
#endif
#ifdef USE_SKINNING // need to be last since we may cut the buffer size based on the real bone number
    float4 skinningJointMatrices[765]; // Consider having a separate buffer ?
#endif
} commonprofile_node;
typedef struct {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
    float4 color            [[attribute(SCNVertexSemanticColor)]];
    float4 skinningWeights  [[attribute(SCNVertexSemanticBoneWeights)]];
    uint4  skinningJoints   [[attribute(SCNVertexSemanticBoneIndices)]];
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];
    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];
    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];
    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];
} scn_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 fragmentPosition [[position]]; // The window relative coordinate (x, y, z, 1/w) values for the fragment
#ifdef USE_POINT_RENDERING
    float fragmentSize [[point_size]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
    float3 diffuse;
#ifdef USE_SPECULAR
    float3 specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    float3 position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
    float3 normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    float3 tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    float3 bitangent;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    float orientationPreserved;
#endif
#ifdef USE_TEXCOORD
    __TexcoordDecl__
#endif
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                // Direction from the point on the surface toward the camera (V)
    float3 position;            // Position of the fragment
    float3 normal;              // Normal of the fragment (N)
    float3 geometryNormal;      // Normal of the fragment - not taking into account normal map
    float2 normalTexcoord;      // Normal texture coordinates
    float3 tangent;             // Tangent of the fragment
    float3 bitangent;           // Bitangent of the fragment
    float4 ambient;             // Ambient property of the fragment
    float2 ambientTexcoord;     // Ambient texture coordinates
    float4 diffuse;             // Diffuse property of the fragment. Alpha contains the opacity.
    float2 diffuseTexcoord;     // Diffuse texture coordinates
    float4 specular;            // Specular property of the fragment
    float2 specularTexcoord;    // Specular texture coordinates
    float4 emission;            // Emission property of the fragment
    float2 emissionTexcoord;    // Emission texture coordinates
    float4 multiply;            // Multiply property of the fragment
    float2 multiplyTexcoord;    // Multiply texture coordinates
    float4 transparent;         // Transparent property of the fragment
    float2 transparentTexcoord; // Transparent texture coordinates
    float4 reflective;          // Reflective property of the fragment
    float  metalness;           // Metalness
    float2 metalnessTexcoord;   // Metalness texture coordinates
    float  roughness;           // Roughness
    float2 roughnessTexcoord;   // Metalness texture coordinates
    float shininess;            // Shininess property of the fragment.
    float fresnel;              // Fresnel property of the fragment.
    float ambientOcclusion;     // Ambient occlusion term of the fragment
    float3 _normalTS;           // UNDOCUMENTED in tangent space
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
// Structure to gather property of a light, packed to give access in a light shader modifier
struct SCNShaderLight {
    float4 intensity; // lowp, light intensity
    float3 direction; // mediump, vector from the point toward the light
    float  _att;
    float3 _spotDirection; // lowp, vector from the point to the light for point and spot, dist attenuations
    float  _distance; // mediump, distance from the point to the light (same coord. than range)
#ifdef USE_PBR
inline SCNPBRSurface SCNShaderSurfaceToSCNPBRSurface(SCNShaderSurface surface)
    SCNPBRSurface s;
    
    s.n = surface.normal;
    s.v = surface.view;
    s.albedo = surface.diffuse.xyz;
    
#ifdef USE_EMISSION
    s.emission = surface.emission.xyz;
#else
    s.emission = float3(0.);
#endif
    
    s.metalness = surface.metalness;
    s.roughness = surface.roughness;
    s.ao = surface.ambientOcclusion;
    return s;
static float4 scn_pbr_combine(SCNPBRSurface                      pbr_surface,
                              SCNShaderLightingContribution      lighting,
                              texture2d<float, access::sample>   specularDFG,
                              texturecube<float, access::sample> specularLD,
#ifdef USE_PROBES_LIGHTING
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
                              sh2_coefficients                   shCoefficients,
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
                              sh3_coefficients                   shCoefficients,
#endif
#else
                              texturecube<float, access::sample> irradiance,
#endif
                              constant SCNSceneBuffer&           scn_frame)
#ifdef USE_PROBES_LIGHTING
    float3 pbr_color = scn_pbr_color_IBL(pbr_surface, specularDFG, specularLD, shCoefficients, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#else
    float3 pbr_color = scn_pbr_color_IBL(pbr_surface, specularDFG, specularLD, irradiance, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
    
    float4 color;
    color.rgb = (lighting.ambient * pbr_surface.ao + lighting.diffuse) * pbr_surface.albedo.rgb + lighting.specular + pbr_color;
    
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += pbr_surface.emission.rgb;
#endif
    
    return color;
static void scn_pbr_lightingContribution(SCNShaderSurface                   surface,
                                         SCNShaderLight                     light,
                                         constant SCNSceneBuffer&           scn_frame,
                                         thread float3&                     lightingContributionDiffuse,
                                         thread float3&                     lightingContributionSpecular)
    SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(surface);
    
    float3 diffuseOut, specularOut;
    scn_pbr_lightingContribution_pointLight(light.direction, pbr_surface.n, pbr_surface.v, pbr_surface.albedo, pbr_surface.metalness, pbr_surface.roughness, diffuseOut, specularOut);
    
    float3 lightFactor = light.intensity.rgb * light._att;
    lightingContributionDiffuse += diffuseOut * lightFactor;
    lightingContributionSpecular += specularOut * lightFactor;
#else // ifdef USE_PBR
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))
    D += lighting.ambient * surface.ambientOcclusion;
#endif
    
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    // Do we want to clamp there ????
    color.rgb = surface.diffuse.rgb * D;
    #ifdef USE_SPECULAR
        float3 S = lighting.specular;
    #elif defined(USE_REFLECTIVE)
        float3 S = float3(0.);
    #endif
    #ifdef USE_REFLECTIVE
        S += surface.reflective.rgb * surface.ambientOcclusion;
    #endif
    #ifdef USE_SPECULAR
        S *= surface.specular.rgb;
    #endif
    #if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
        color.rgb += S;
    #endif
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
#endif
struct  commonprofile_lights {
#ifdef USE_LIGHTING
    __LightingDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float2 texcoords[8]; // MAX_UV
struct  commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float metalness;
    float roughness;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    float metalnessIntensity;
    float roughnessIntensity;
    
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
#ifdef TEXTURE_TRANSFORM_COUNT
    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
//    float4x4 u_viewToCubeWorld;
#endif
// Shader modifiers declaration (only enabled if one modifier is present)
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
// Vertex shader function
vertex commonprofile_io commonprofile_vert(scn_vertex_t in [[ stage_in ]],
                                           constant SCNSceneBuffer& scn_frame [[buffer(0)]],
#ifdef USE_INSTANCING
                                           // we use device here to override the 64Ko limit of constant buffers on NV hardware
                                           device commonprofile_node* scn_nodeInstances [[buffer(1)]]
                                           , uint instanceID [[ instance_id ]]
#else
                                           constant commonprofile_node& scn_node [[buffer(1)]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                           , constant commonprofile_lights& scn_lights [[buffer(2)]]
#endif
// used for texture transform and materialShininess in case of perVertexLighting
                                           , constant commonprofile_uniforms& scn_commonprofile [[buffer(3)]]
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
__VertexExtraArguments__
#endif
                                           )
#ifdef USE_INSTANCING
    device commonprofile_node& scn_node = scn_nodeInstances[instanceID];
#endif
    SCNShaderGeometry _geometry;
    // OPTIM in could be already float4?
    _geometry.position = float4(in.position, 1.0);
#ifdef USE_NORMAL
    _geometry.normal = in.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = in.tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = in.texcoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = in.texcoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = in.texcoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = in.texcoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = in.texcoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = in.texcoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = in.texcoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = in.texcoord7;
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = in.color;
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
#ifdef USE_SKINNING
#if 0 // Alternate Skinning method, linear combining the joint matrices. Not fully tested yet
    {
        float4 joint0 = 0.;
        float4 joint1 = 0.;
        float4 joint2 = 0.;
        uint4 idx3 = in.skinningJoints * 3;
        for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
            int idx = idx3[i];
#if MAX_BONE_INFLUENCES == 1
            float boneWeight = 1.;
#else
            float boneWeight = in.skinningWeights[i];
#endif
            joint0 += boneWeight * scn_node.skinningJointMatrices[idx];
            joint1 += boneWeight * scn_node.skinningJointMatrices[idx+1];
            joint2 += boneWeight * scn_node.skinningJointMatrices[idx+2];
        }
        float4x4 jointMatrix = float4x4(joint0, joint1, joint2, float4(0., 0., 0., 1.));
        _geometry.position.xyz = (_geometry.position * jointMatrix).xyz;
#ifdef USE_NORMAL
        _geometry.normal = _geometry.normal * scn::mat3(jointMatrix);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = _geometry.tangent.xyz * scn::mat3(jointMatrix);
#endif
    }
#else
    {
        float3 pos = 0.0;
#ifdef USE_NORMAL
        float3 nrm = 0.0;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        float3 tgt = 0.0;
#endif
        for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
            float weight = 1.0;
#else
            float weight = in.skinningWeights[i];
            if (weight <= 0.f)
                continue;
#endif
            int idx = int(in.skinningJoints[i]) * 3;
            float4x4 jointMatrix = float4x4(scn_node.skinningJointMatrices[idx],
                                            scn_node.skinningJointMatrices[idx+1],
                                            scn_node.skinningJointMatrices[idx+2],
                                            float4(0., 0., 0., 1.));
            
            pos += (_geometry.position * jointMatrix).xyz * weight;
#ifdef USE_NORMAL
            nrm += _geometry.normal * scn::mat3(jointMatrix) * weight;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * scn::mat3(jointMatrix) * weight;
#endif
        }
        
        _geometry.position.xyz = pos;
#ifdef USE_NORMAL
        _geometry.normal = nrm;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = tgt;
#endif
    }
#endif
#endif // USE_SKINNING
    
#ifdef USE_GEOMETRY_MODIFIER
// DoGeometryModifier START
__DoGeometryModifier__
// DoGeometryModifier END
#endif
    
    // Transform the geometry elements in view space
#if defined(USE_POSITION) || defined(USE_NORMAL) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;
#endif
#ifdef USE_NORMAL
    _surface.normal = normalize(scn::mat3(scn_node.normalTransform) * _geometry.normal);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _surface.tangent = normalize(scn::mat3(scn_node.normalTransform) * _geometry.tangent.xyz);
    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); // no need to renormalize since tangent and normal should be orthogonal
    // old code : _surface.bitangent =  normalize(cross(_surface.normal,_surface.tangent));
#endif
    
    //if USE_VIEW is 2 we may also need to set _surface.view. todo: make USE_VIEW a mask
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    commonprofile_io out;
    
#ifdef USE_PER_VERTEX_LIGHTING
    // Lighting
    SCNShaderLightingContribution _lightingContribution;
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
__VertexDoLighting__
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
    
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
#ifdef USE_TEXCOORD
__VertexDoTexcoord__
#endif
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) // this means that the geometry are still in model space : we can transform it directly to NDC space
    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
#endif
#ifdef USE_NODE_OPACITY
    out.nodeOpacity = scn_node.nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    out.orientationPreserved = scn_node.orientationPreserved;
#endif
#ifdef USE_POINT_RENDERING
    out.fragmentSize = 1.;
#endif
    return out;
struct SCNOutput
    float4 color;
// Fragment shader function
fragment half4 commonprofile_frag(commonprofile_io in [[stage_in]],
                                  constant commonprofile_uniforms& scn_commonprofile [[buffer(0)]],
                                  constant SCNSceneBuffer& scn_frame [[buffer(1)]]
#ifdef USE_PER_PIXEL_LIGHTING
                                  , constant commonprofile_lights& scn_lights [[buffer(2)]]
#endif
#ifdef USE_EMISSION_MAP
                                  , texture2d<float> u_emissionTexture [[texture(0)]]
                                  , sampler          u_emissionTextureSampler [[sampler(0)]]
#endif
#ifdef USE_AMBIENT_MAP
                                  , texture2d<float> u_ambientTexture [[texture(1)]]
                                  , sampler          u_ambientTextureSampler [[sampler(1)]]
#endif
#ifdef USE_DIFFUSE_MAP
                                  , texture2d<float> u_diffuseTexture [[texture(2)]]
                                  , sampler          u_diffuseTextureSampler [[sampler(2)]]
#endif
#ifdef USE_SPECULAR_MAP
                                  , texture2d<float> u_specularTexture [[texture(3)]]
                                  , sampler          u_specularTextureSampler [[sampler(3)]]
#endif
#ifdef USE_REFLECTIVE_MAP
                                  , texture2d<float> u_reflectiveTexture [[texture(4)]]
                                  , sampler          u_reflectiveTextureSampler [[sampler(4)]]
#elif defined(USE_REFLECTIVE_CUBEMAP)
                                  , texturecube<float> u_reflectiveTexture [[texture(4)]]
                                  , sampler            u_reflectiveTextureSampler [[sampler(4)]]
#endif
#ifdef USE_TRANSPARENT_MAP
                                  , texture2d<float> u_transparentTexture [[texture(5)]]
                                  , sampler          u_transparentTextureSampler [[sampler(5)]]
#endif
#ifdef USE_MULTIPLY_MAP
                                  , texture2d<float> u_multiplyTexture [[texture(6)]]
                                  , sampler          u_multiplyTextureSampler [[sampler(6)]]
#endif
#ifdef USE_NORMAL_MAP
                                  , texture2d<float> u_normalTexture [[texture(7)]]
                                  , sampler          u_normalTextureSampler [[sampler(7)]]
#endif
#ifdef USE_PBR
#ifdef USE_METALNESS_MAP
                                  , texture2d<float> u_metalnessTexture [[texture(3)]]
                                  , sampler          u_metalnessTextureSampler [[sampler(3)]]
#endif
#ifdef USE_ROUGHNESS_MAP
                                  , texture2d<float> u_roughnessTexture [[texture(4)]]
                                  , sampler          u_roughnessTextureSampler [[sampler(4)]]
#endif
                                  , texturecube<float> u_irradianceTexture [[texture(8)]]
                                  , texturecube<float> u_radianceTexture [[texture(9)]]
                                  , texture2d<float>   u_specularDFGTexture [[texture(10)]]
#endif
#ifdef USE_SSAO
                                  , texture2d<float> u_ssaoTexture [[texture(11)]]
#endif
                                  , constant commonprofile_node& scn_node [[buffer(3)]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
#if defined(USE_DOUBLE_SIDED)
                                  , bool isFrontFacing [[front_facing]]
#endif
                                  )
    SCNShaderSurface _surface;
#ifdef USE_TEXCOORD
__FragmentDoTexcoord__
#endif
    _surface.ambientOcclusion = 1.f; // default to no AO
#ifdef USE_AMBIENT_MAP
    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
        _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambientOcclusion = saturate(mix(1., _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        #endif
    #else // AMBIENT_MAP
        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambient *= scn_commonprofile.ambientIntensity;
        #endif
    #endif // USE_AMBIENT_AS_AMBIENTOCCLUSION
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = scn_commonprofile.ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = float4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= in.vertexColor;
#endif
#if  defined(USE_SSAO)
    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
#endif
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = scn_commonprofile.diffuseColor;
#else
    _surface.diffuse = float4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= in.vertexColor;
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= scn_commonprofile.specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = scn_commonprofile.specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = float4(0.);
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= scn_commonprofile.emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = scn_commonprofile.emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = float4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = scn_commonprofile.multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = float4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= scn_commonprofile.transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = scn_commonprofile.transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = float4(1.);
#endif
    
#ifdef USE_METALNESS_MAP
    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;
#ifdef USE_METALNESS_INTENSITY
    _surface.metalness *= scn_commonprofile.metalnessIntensity;
#endif
#elif defined(USE_METALNESS_COLOR)
    _surface.metalness = scn_commonprofile.metalness;
#else
    _surface.metalness = 0;
#endif
    
#ifdef USE_ROUGHNESS_MAP
    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
#ifdef USE_ROUGHNESS_INTENSITY
    _surface.roughness *= scn_commonprofile.roughnessIntensity;
#endif
#elif defined(USE_ROUGHNESS_COLOR)
    _surface.roughness = scn_commonprofile.roughness;
#else
    _surface.roughness = 0;
#endif
    
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.geometryNormal = normalize(in.normal.xyz) * in.orientationPreserved * ((float(isFrontFacing) * 2.0) - 1.0);
#else
    _surface.geometryNormal = normalize(in.normal.xyz);
#endif
    _surface.normal = _surface.geometryNormal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = in.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = in.bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = in.position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-in.position);
#endif
#ifdef USE_NORMAL_MAP
    float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb * 2. - 1.;
    // _surface.normal.z = 1. - sqrt(_surface.normal.x * _surface.normal.x + _surface.normal.y * _surface.normal.y);
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(float3(0., 0., 1.), _surface._normalTS, scn_commonprofile.normalIntensity);
#endif
    // transform the normal in view space
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = float3(0.);
#endif
    
#ifdef USE_REFLECTIVE_MAP
    float3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5);
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    float3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); // sample the cube map in world space
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = scn_commonprofile.reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = float4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.0 - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = scn_commonprofile.materialShininess;
#endif
    
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    // Lighting
    SCNShaderLightingContribution _lightingContribution = {0};
    
    
    // Lighting
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = float3(0.);
#ifdef USE_MODULATE
    _lightingContribution.modulate = float3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = float3(0.);
#endif
__FragmentDoLighting__
#else // USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = in.diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = in.specular;
#endif
#endif
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
#ifdef USE_SPECULAR
    _lightingContribution.specular = saturate(_lightingContribution.specular);
#endif // USE_SPECULAR
#endif // AVOID_OVERLIGHTING
#else // USE_LIGHTING
    _lightingContribution.diffuse = float3(1.);
#endif // USE_LIGHTING
    // Combine
    SCNOutput _output;
#ifdef USE_PBR
    SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(_surface);
    pbr_surface.selfIlluminationOcclusion = scn_commonprofile.selfIlluminationOcclusion;
#ifdef USE_PROBES_LIGHTING
    _output.color = scn_pbr_combine(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, scn_node.shCoefficients, scn_frame);
#else
    _output.color = scn_pbr_combine(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, u_irradianceTexture, scn_frame);
#endif
    _output.color.a = _surface.diffuse.a;
#else
    _output.color = illuminate(_surface, _lightingContribution);
#endif
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
#endif
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
#ifdef USE_TRANSPARENT // Either a map or a color
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= scn_commonprofile.transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= in.nodeOpacity;
#endif
    // compute luminance
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (float4(1.) - _surface.transparent);
#else // ALPHA_ONE
#ifdef USE_NODE_OPACITY
    _output.color *= (in.nodeOpacity * _surface.transparent.a);
#else
    _output.color *= _surface.transparent.a;
#endif
#endif
#else
#ifdef USE_TRANSPARENCY // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
#ifdef USE_NODE_OPACITY
    _output.color *= (in.nodeOpacity * scn_commonprofile.transparency);
#else
    _output.color *= scn_commonprofile.transparency;
#endif // NODE_OPACITY
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
//#ifdef USE_SSAO
//    _output.color.rgb = float3(_surface.ambientOcclusion);
//#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) // we could set a different limit here
        discard_fragment();
#endif
    return half4(_output.color);
attribute vec4 a_position;
varying vec2 uv;
void main(void)
gl_Position = a_position;
    uv = a_position.xy; // [-1, +1]x[-1, +1]
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderMirroredScene</string>
<string>SceneKit_renderFloor</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderMirroredScene</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>SceneKit-Floor-depth</string>
<key>color</key>
<string>SceneKit-Floor-color</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>SceneKit_renderFloor</key>
<dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>inputs</key>
<dict>
<key>u_floorReflectionDepth</key>
<string>SceneKit-Floor-depth</string>
<key>u_floorReflectionColor</key>
<string>SceneKit-Floor-color</string>
<key>u_floorNormal</key>
<string>u_floorNormal</string>
<key>u_floorTangent</key>
<string>u_floorTangent</string>
<key>u_floorCenter</key>
<string>u_floorCenter</string>
<key>u_floorExtent</key>
<string>u_floorExtent</string>
<key>u_floorReflectivity</key>
<string>u_floorReflectivity</string>
<key>u_floor_viewport</key>
<string>u_floor_viewport</string>
<key>u_floorMVP_i</key>
<string>u_floorMVP_i</string>
<key>u_floorPlane</key>
<string>u_floorPlane</string>
<key>u_floorFalloff</key>
<string>u_floorFalloff</string>
<key>u_floorFalloffStart</key>
<string>u_floorFalloffStart</string>
</dict>
<key>draw</key>
<string>DRAW_GEOMETRY</string>
<key>installViewport</key>
<false/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>u_floorNormal</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorTangent</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorCenter</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorExtent</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>u_floor_viewport</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>u_floorReflectivity</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorMVP_i</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>u_floorPlane</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorFalloff</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorFalloffStart</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-Floor-depth</key>
<dict>
<key>type</key>
<string>color</string>
</dict>
<key>SceneKit-Floor-color</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
</dict>
</dict>
</plist>
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#ifndef MAX_SAMPLE
#define MAX_SAMPLE 32
#endif
struct GaussianBlur_io {
    float4 position [[position]];
    float2 texCoord;
struct GaussianBlur_uniforms {
    float2 offsets[MAX_SAMPLE];
    float weights[MAX_SAMPLE];
    int n_sample;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GaussianBlur
vertex GaussianBlur_io GaussianBlur_vert(
                                         uint v_id [[ vertex_id ]]
                                         )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    GaussianBlur_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 GaussianBlur_frag(
                                 GaussianBlur_io in [[stage_in]],
                                 texture2d<float> textureSampler0 [[texture(0)]],
                                 constant GaussianBlur_uniforms& uniforms [[buffer(0)]]
                                 )
    constexpr sampler samp(filter::linear);
    int i;
    
    float4 accum = float4(0.0);
    
    for (i=0; i < uniforms.n_sample; i++) {
        float4 c = textureSampler0.sample(samp, in.texCoord + uniforms.offsets[i]);
        accum += c * uniforms.weights[i];
    }
    
    return half4(accum);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GaussianBlurAlpha
vertex GaussianBlur_io GaussianBlurAlpha_vert(
                                                   uint v_id [[ vertex_id ]]
                                                   )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    GaussianBlur_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 GaussianBlurAlpha_frag(
                                      GaussianBlur_io in [[stage_in]],
                                      texture2d<float> textureSampler0 [[texture(0)]],
                                      constant GaussianBlur_uniforms& uniforms [[buffer(0)]]
                                      )
    constexpr sampler samp(filter::linear);
    int i;
    
    float4 accum = float4(0.0);
    float total = 0.0;
    
    for (i=0; i < uniforms.n_sample; i++) {
        float4 c = textureSampler0.sample(samp, in.texCoord + uniforms.offsets[i]);
        c.rgb *= c.a;
        accum += c * uniforms.weights[i];
        total += uniforms.weights[i] * c.a;
    }
    
    accum /= total;
    return half4(accum);
uniform sampler2D downSampler;
uniform sampler2D depthSampler;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    float depth = texture2D( depthSampler, v_texCoord).r;
    float coc = step(0., (depth * CocScaleBias.x + CocScaleBias.y)); // keep only near coc
gl_FragColor = vec4(down.rgb, coc * down.a);
    // debug
    //gl_FragColor = vec4(depth, 0., 0., 1.);
#extension GL_ARB_shader_texture_lod : enable
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2DLod(textureSampler0,TexCoord, 0.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 1.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 2.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 3.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 4.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 5.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 6.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 7.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 8.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 9.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 10.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 11.0);    
    gl_FragColor /= 12.0;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_copy</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_copy</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Copy</string>
<key>clientProgram</key>
<false/>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
</dict>
</dict>
</plist>
    "sequence" : ["SceneKit_stereoLeftEye", "SceneKit_stereoRightEye", "SceneKit_stereoResolveLeft", "SceneKit_stereoResolveRight"],
    "passes" : {
        "SceneKit_stereoLeftEye" : {
            "outputs" : {
                "color" : "SceneKit_stereo-leftColor",
                "depth" : "SceneKit_stereo-leftDepth"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "true",
                "clearColor" : "sceneBackground"
            },
            "depthStates" : {
                "clear" : "true"
            }
        },
        "SceneKit_stereoRightEye" : {
            "outputs" : {
                "color" : "SceneKit_stereo-rightColor",
                "depth" : "SceneKit_stereo-rightDepth"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "true",
                "clearColor" : "sceneBackground"
            },
            "depthStates" : {
                "clear" : "true"
            }
        },
        "SceneKit_stereoResolveLeft" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorSampler" : "SceneKit_stereo-leftColor"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "false",
        },
        "SceneKit_stereoResolveRight" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorSampler" : "SceneKit_stereo-rightColor",
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "false",
        }
    },
    "symbols" : {
        "interaxialDistance" : {
            "type" : "float"
        }
    },
    "targets" : {
        "SceneKit_stereo-leftColor" : {
            "type" : "color"
        },
        "SceneKit_stereo-rightColor" : {
            "type" : "color"
        },
        "SceneKit_stereo-leftDepth" : {
            "type" : "depth"
        },
        "SceneKit_stereo-rightDepth" : {
            "type" : "depth"
        }
    }
struct SCNShaderLightingContribution
vec3 ambient;
vec3 diffuse;
vec3 specular;
} _lightingContribution;
#ifdef USE_SKINNING
uniform vec4 u_skinningJointMatrices[60];
attribute vec4 a_skinningWeights;
attribute vec4 a_skinningJoints;
#endif
// Attributes
attribute vec4 a_position;
#ifdef USE_NORMAL
attribute vec3 a_normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
attribute vec4 a_tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
attribute vec2 a_texCoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
attribute vec2 a_texCoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
attribute vec2 a_texCoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
attribute vec2 a_texCoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
attribute vec2 a_texCoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
attribute vec2 a_texCoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
attribute vec2 a_texCoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
attribute vec2 a_texCoord7;
#endif
#ifdef USE_VERTEX_COLOR
attribute vec4 a_color;
varying vec4 v_vertexColor;
#endif
// Varyings
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) || defined(USE_VIEW)
varying vec3 v_position;
#endif
#ifdef USE_NORMAL
varying vec3 v_normal;
#endif
#ifdef USE_TANGENT
varying vec3 v_tangent;
#endif
#ifdef USE_BITANGENT
varying vec3 v_bitangent;
#endif
#if defined(USE_SPECULAR) && defined(USE_PER_VERTEX_LIGHTING)
uniform float u_materialShininess;
#endif
void main(void)
  _geometry.position = a_position;
  #ifdef USE_NORMAL
  _geometry.normal = a_normal;
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _geometry.tangent = a_tangent;
  #endif
  #ifdef NEED_IN_TEXCOORD0
  _geometry.texcoords[0] = a_texCoord0;
  #endif
  #ifdef NEED_IN_TEXCOORD1
  _geometry.texcoords[1] = a_texCoord1;
  #endif
  #ifdef NEED_IN_TEXCOORD2
  _geometry.texcoords[2] = a_texCoord2;
  #endif
  #ifdef NEED_IN_TEXCOORD3
  _geometry.texcoords[3] = a_texCoord3;
  #endif
  #ifdef NEED_IN_TEXCOORD4
  _geometry.texcoords[4] = a_texCoord4;
  #endif
  #ifdef NEED_IN_TEXCOORD5
  _geometry.texcoords[5] = a_texCoord5;
  #endif
  #ifdef NEED_IN_TEXCOORD6
  _geometry.texcoords[6] = a_texCoord6;
  #endif
  #ifdef NEED_IN_TEXCOORD7
  _geometry.texcoords[7] = a_texCoord7;
  #endif
#ifdef USE_VERTEX_COLOR
  _geometry.color = a_color;
#endif
  #ifdef USE_SKINNING
    vec3 pos = vec3(0.);
    #ifdef USE_NORMAL
    vec3 nrm = vec3(0.);
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    vec3 tgt = vec3(0.);
    #endif
    for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
        float weight = 1.0;
#else
        float weight = a_skinningWeights[i];
        
#endif
      int idx = int(a_skinningJoints[i]) * 3;
      mat4 jointMatrix = mat4(u_skinningJointMatrices[idx], u_skinningJointMatrices[idx+1], u_skinningJointMatrices[idx+2], vec4(0., 0., 0., 1.));
            pos += (_geometry.position * jointMatrix).xyz * weight;
      #ifdef USE_NORMAL
            nrm += _geometry.normal * mat3(jointMatrix) * weight;
      #endif
      #if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * mat3(jointMatrix) * weight;
      #endif
    }
    
    _geometry.position.xyz = pos;
    #ifdef USE_NORMAL
    _geometry.normal = nrm;
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent.xyz = tgt;
    #endif
  #endif
  #ifdef USE_GEOMETRY_MODIFIER
// DoGeometryModifier START
__DoGeometryModifier__
// DoGeometryModifier END
  #endif
  // Transform the geometry elements in view space
  #ifdef USE_POSITION
  _surface.position = (u_modelViewTransform * _geometry.position).xyz;
  #endif
  #ifdef USE_NORMAL
  _surface.normal = normalize(mat3(u_normalTransform) * _geometry.normal);
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _surface.tangent = normalize(mat3(u_normalTransform) * _geometry.tangent.xyz);
  _surface.bitangent = /*_geometry.tangent.w **/ cross(_surface.tangent, _surface.normal); // no need to renormalize since tangent and normal should be orthogonal
    // old code : _surface.bitangent =  normalize(cross(_surface.normal,_surface.tangent));
  #endif
  //if USE_VIEW is 2 we may also need to set _surface.view. todo: make USE_VIEW a mask
  #ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
  #endif
  #ifdef USE_PER_VERTEX_LIGHTING
  _lightingContribution.diffuse = vec3(0.);
  #ifdef USE_SPECULAR
  _lightingContribution.specular = vec3(0.);
  _surface.shininess = u_materialShininess;
  #endif
  // Lighting
__DoLighting__
  v_diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
  v_specular = _lightingContribution.specular;
  #endif
  #endif
  #if defined(USE_POSITION) && (USE_POSITION == 2)
  v_position = _surface.position;
  #endif
  #if defined(USE_NORMAL) && (USE_NORMAL == 2)
  v_normal = _surface.normal;
  #endif
  #if defined(USE_TANGENT) && (USE_TANGENT == 2)
  v_tangent = _surface.tangent;
  #endif
  #if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
  v_bitangent = _surface.bitangent;
  #endif
  #ifdef USE_VERTEX_COLOR
  v_vertexColor = _geometry.color;
  #endif
#ifdef USE_TEXCOORD
__DoTexcoord__
#endif
    
  // this means that the geometry are still in model space
  #if defined(SEPARATE_PROJECTION) && SEPARATE_PROJECTION
  gl_Position = u_projectionTransform * vec4(_surface.position, 1.);
  #else
  gl_Position = u_modelViewProjectionTransform * _geometry.position;
  #endif
#define USE_NORMAL_MAP
#define FUNC_VERT ds_default_vert_N
#define FUNC_FRAG ds_default_frag_N
#import "C3D-DeferredShading.metal"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_downSample4x</string>
<string>SceneKit_DOF_generateNearCoc</string>
<string>SceneKit_DOF_blurCoc_H</string>
<string>SceneKit_DOF_blurCoc_V</string>
<string>SceneKit_blurColor4x_H</string>
<string>SceneKit_blurColor4x_V</string>
<string>SceneKit_DOF_computeNearCoc</string>
<string>SceneKit_DOF_smallBlur</string>
<string>SceneKit_DOF_resolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_downSample4x</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-downSample4x</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-downSample4x</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>DownSample4x_vert</string>
<key>metalFragmentShader</key>
<string>DownSample4x_frag</string>
</dict>
<key>SceneKit_DOF_generateNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>target</key>
<string>SceneKit-color-downSample4x</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>depthSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>DEPTH</string>
</dict>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-generateNearCoc</string>
<key>metalVertexShader</key>
<string>GenerateNearCoc_vert</string>
<key>clientProgram</key>
<false/>
<key>metalFragmentShader</key>
<string>GenerateNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_blurCoc_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-nearCoc</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_blurCoc_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-downSample4x</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>textureSampler0</key>
<string>SceneKit_blurColor4x_H_output</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_computeNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>blurSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-ComputeNearCoc</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ComputeNearCoc_vert</string>
<key>metalFragmentShader</key>
<string>ComputeNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_smallBlur</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<dict>
<key>target</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Blur5x5</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>Blur5x5_vert</string>
<key>metalFragmentShader</key>
<string>Blur5x5_frag</string>
</dict>
<key>SceneKit_DOF_resolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>smallBlurSampler</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
<key>largeBlurSampler</key>
<string>SceneKit_blurColor4x_V_output</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>dofLerpScale</key>
<string>C3D-dof-lerpScale</string>
<key>dofLerpBias</key>
<string>C3D-dof-lerpBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Resolve</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ResolveDOF_vert</string>
<key>metalFragmentShader</key>
<string>ResolveDOF_frag</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-color-downSample4x</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>SceneKit-color-nearCoc</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>SceneKit_DOF_blurCoc_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>SceneKit_DOF_blurCoc_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>SceneKit_blurColor4x_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>SceneKit_blurColor4x_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>SceneKit_DOF_computeNearCoc-output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>SceneKit_DOF_smallBlur-ouput</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-dof-cocScaleBias</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>C3D-dof-invertPixelSize</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>C3D-dof-lerpScale</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-dof-lerpBias</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-blur-radiusV</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-radiusH</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-offsets</key>
<dict>
<key>type</key>
<string>vec2[31]</string>
</dict>
<key>C3D-blur-weights</key>
<dict>
<key>type</key>
<string>float[31]</string>
</dict>
<key>C3D-blur-samples</key>
<dict>
<key>type</key>
<string>int</string>
</dict>
</dict>
</dict>
</plist>
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
// initial geometry is [-1,1] in XY plane (so z is always 0)
struct scn_floor_t {
    float3 u_floorNormal;
    float4 u_floorTangent;
    float3 u_floorCenter;
    float2 u_floorExtent;
#pragma arguments
    scn_floor_t scn_fg
#pragma body
    float3 u_floorNormal = scn_fg.u_floorNormal;
    float4 u_floorTangent = scn_fg.u_floorTangent;
    float3 u_floorCenter = scn_fg.u_floorCenter;
    float2 u_floorExtent = scn_fg.u_floorExtent;
    float3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
    _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
    _geometry.normal = u_floorNormal;
    _geometry.tangent = u_floorTangent;
    // we could check if the texCoord are really needed with ifdef USE_xxxx_MAP , or, better, work only on texcoordN [0..1]
    float2 tc;
    if (u_floorNormal.y != 0.)
        tc = _geometry.position.xz * 0.01;
    else if (u_floorNormal.z != 0.)
        tc = _geometry.position.xy * 0.01;
    else
        tc = _geometry.position.yz * 0.01;
    for (int i = 0; i < kSCNTexcoordCount; ++i)
        _geometry.texcoords[i] = tc;
    "sequence" : ["SceneKit_stereoLeftEye", "SceneKit_stereoRightEye"],
    "passes" : {
        "SceneKit_stereoLeftEye" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "true",
                "clearColor" : "sceneBackground"
            },
            "depthStates" : {
                "clear" : "true"
            }
        },
        "SceneKit_stereoRightEye" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "false"
            },
            "depthStates" : {
                "clear" : "true"
            }
        }
    },
    "symbols" : {
        "interaxialDistance" : {
            "type" : "float"
        }
    },
    "stereoscopy" : {
        "leftEyeRelativeViewport" : "0.0 0.5 1.0 0.5",
        "rightEyeRelativeViewport" : "0.0 0.0 1.0 0.5"
    }
    "sequence" : ["SceneKit_stereoLeftEye", "SceneKit_stereoRightEye"],
    "passes" : {
        "SceneKit_stereoLeftEye" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "true",
                "clearColor" : "sceneBackground"
            },
            "depthStates" : {
                "clear" : "true"
            }
        },
        "SceneKit_stereoRightEye" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "draw" : "DRAW_SCENE",
            "clientProgram" : "false",
            "colorStates" : {
                "clear" : "false"
            },
            "depthStates" : {
                "clear" : "true"
            }
        }
    },
    "symbols" : {
        "interaxialDistance" : {
            "type" : "float"
        }
    },
    "stereoscopy" : {
        "leftEyeRelativeViewport" : "0.0 0.0 0.5 1.0",
        "rightEyeRelativeViewport" : "0.5 0.0 0.5 1.0"
    }
#import <metal_stdlib>
using namespace metal;
////////////////
// Add
struct Add_io {
    float4 position [[position]];
    float2 texCoord;
vertex Add_io Add_vert(
                                         uint v_id [[ vertex_id ]]
                                         )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    Add_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 Add_frag(
                        Add_io in [[stage_in]],
                        texture2d<float> textureSampler0 [[texture(0)]],
                        texture2d<float> textureSampler1 [[texture(1)]]
                        )
    constexpr sampler samp(filter::linear);
    return half4(textureSampler0.sample(samp, in.texCoord) + textureSampler1.sample(samp, in.texCoord));
////////////////////
// Copy
struct Copy_io {
    float4 position [[position]];
    float2 texCoord;
vertex Copy_io Copy_vert(
                       uint v_id [[ vertex_id ]]
                       )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    Copy_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 Copy_frag(
                        Copy_io in [[stage_in]],
                        texture2d<float> textureSampler0 [[texture(0)]]
                        )
    constexpr sampler samp(filter::linear);
    return half4(textureSampler0.sample(samp, in.texCoord));
/////////////////////
// Mult (float)
struct Mult_io {
    float4 position [[position]];
    float2 texCoord;
struct Mult_uniforms {
    float factor;
vertex Mult_io Mult_vert(
                         uint v_id [[ vertex_id ]]
                         )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    Mult_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 Mult_frag(
                         Mult_io in [[stage_in]],
                         texture2d<float> textureSampler0 [[texture(0)]],
                         constant Mult_uniforms& uniforms [[buffer(0)]]
                         )
    constexpr sampler samp(filter::linear);
    return half4(textureSampler0.sample(samp, in.texCoord) * uniforms.factor);
/////////////////////////
// IncrementalAverage
struct IncrementalAverage_io {
    float4 position [[position]];
    float2 texCoord;
struct IncrementalAverage_uniforms {
    float factor;
vertex IncrementalAverage_io IncrementalAverage_vert(
                       uint v_id [[ vertex_id ]]
                       )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    IncrementalAverage_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 IncrementalAverage_frag(
                        IncrementalAverage_io in [[stage_in]],
                        texture2d<float> textureSampler0 [[texture(0)]],
                        texture2d<float> textureSampler1 [[texture(1)]],
                        constant IncrementalAverage_uniforms& uniforms [[buffer(0)]]
                        )
    constexpr sampler samp(filter::linear);
    float4 newFragment = textureSampler0.sample(samp, in.texCoord);
    float4 oldColor = textureSampler1.sample(samp, in.texCoord);
    const float factor = uniforms.factor;
    return half4((factor - 1.0) * (oldColor / factor) + newFragment / factor);
uniform sampler2D textureSampler0;
uniform float factor;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord) * factor;
uniform samplerCube textureSampler0;
varying vec3 TexCoord;
#if __VERSION__ > 120 // GL Compatibility Profile
#define textureCube(tex,coord) texture( tex, coord )
#endif
void main (void)
    
gl_FragColor = textureCube(textureSampler0,TexCoord);
#import <metal_stdlib>
#import <simd/simd.h>
using namespace metal;
// MARK: Debug functions
typedef struct {
    float4 position [[ position ]];
    float2 uv;
} quad_io_t;
vertex quad_io_t quad_vertex(uint             v_id [[ vertex_id ]],
                             constant float4& rect [[ buffer(0) ]])
    quad_io_t out;
    
    float2 uv = float2(v_id / 2, v_id % 2);
    float2 ruv = rect.xy +  uv * rect.zw;
    out.position = float4(ruv.x * 2.0 - 1.0,
                          ruv.y * 2.0 - 1.0,
                          0.0,
                          1.0);
    
    out.uv = float2( uv.x, 1 - uv.y ) ;
    return out;
static float3 cubemap_sampling_coordinates(uint face, float2 uv)
    uv = 2.0f * uv - 1.0f; // [0, 1] -> [-1, 1]
    
    switch(face) {
        case 0:
            return float3(+1.0f, -uv.y, -uv.x);
            
        case 1:
            return float3(-1.0f, -uv.y, uv.x);
            
        case 2:
            return float3(uv.x, +1.0f, uv.y);
            
        case 3:
            return float3(uv.x, -1.0f, -uv.y);
            
        case 4:
            return float3(uv.x, -uv.y, +1.0f);
            
        case 5:
            return float3(-uv.x, -uv.y, -1.0f);
    }
    
    return float3(0.0);
inline bool isInRect(float4 rect, float2 p) {
    return
    rect.x <= p.x && p.x <= rect.x + rect.z &&
    rect.y <= p.y && p.y <= rect.y + rect.w;
inline float2 barycentricCoordinates(float4 rect, float2 p) {
    return float2((p.x - rect.x) / rect.z,  (p.y - rect.y) / rect.w);
inline float4 subrect(float4 rect, int i, int j) {
    return float4(rect.x + i * rect.z / 4.0,
                  rect.y + j * rect.w / 3.0,
                  rect.z / 4.0,
                  rect.w / 3.0);
static float4 sampleTexture(float2 uv, float4 mipLevelRect, uint mipLevel, texture2d<float> texture)
    constexpr sampler linearSampler(filter::linear, mip_filter::nearest);
    
    if (isInRect(mipLevelRect, uv)) {
        float2 faceUV = barycentricCoordinates(mipLevelRect, uv);
        return texture.sample(linearSampler, faceUV, level(mipLevel));
    }
    
    return float4(-1.0);
static float4 sampleCubemap(float2 uv, float4 mipLevelRect, uint mipLevel, texturecube<float> texture)
    constexpr sampler linearSampler(filter::linear, mip_filter::nearest);
    
    if (isInRect(mipLevelRect, uv)) {
        float4 faceSubrect;
        float2 faceUV;
        
        // +X
        faceSubrect = subrect(mipLevelRect, 2, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(0, faceUV), level(mipLevel));
        }
        
        // -X
        faceSubrect = subrect(mipLevelRect, 0, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(1, faceUV), level(mipLevel));
        }
        
        // +Y
        faceSubrect = subrect(mipLevelRect, 1, 0);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(2, faceUV), level(mipLevel));
        }
        
        // -Y
        faceSubrect = subrect(mipLevelRect, 1, 2);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(3, faceUV), level(mipLevel));
        }
        
        // +Z
        faceSubrect = subrect(mipLevelRect, 1, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(4, faceUV), level(mipLevel));
        }
        
        // -Z
        faceSubrect = subrect(mipLevelRect, 3, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(5, faceUV), level(mipLevel));
        }
    }
    
    return float4(-1.0);
fragment half4 quad_display_texture2D(quad_io_t        in      [[ stage_in ]],
                                      texture2d<float> texture [[ texture(0) ]])
    float4 rect = float4(2.0 / 3.0, 0.0, 1.0 / 3.0, 0.5);
    
    uint mipLevelCount = texture.get_num_mip_levels();
    for (uint mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {
        
        float4 mipLevelRect = rect;
        if (mipLevel == 0) {
            mipLevelRect = float4(0.0, 0.0, (mipLevelCount != 1 ? 2.0 / 3.0 : 1.0), 1.0);
        }
        
        float4 color = sampleTexture(in.uv, mipLevelRect, mipLevel, texture);
        if (color.w != -1.0) {
            return half4(color);
        }
        
        if (mipLevel != 0) {
            rect = float4(rect.x,
                          rect.y + rect.w,
                          0.5 * rect.z,
                          0.5 * rect.w);
        }
    }
    
    discard_fragment();
    return half4(0.0);
fragment half4 quad_display_cube(quad_io_t          in      [[ stage_in ]],
                                 texturecube<float> texture [[ texture(0) ]])
    float4 rect = float4(0.0, 0.0, 1.0, 1.0);
//    float4 col = rect;
//    col.rg = in.uv;
//    return half4(col);
    
    
    uint mipLevelCount = texture.get_num_mip_levels();
    
    for (uint mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {
        
        float4 mipLevelRect = float4(rect.x, rect.y, rect.z, (mipLevelCount != 1 ? 0.75f : 1.0f) * rect.w);
//        float4 mipLevelRect = float4(rect.x, rect.y, rect.z, rect.w);
        
        float4 color = sampleCubemap(in.uv, mipLevelRect, mipLevel, texture);
        if (color.w != -1.0) {
            return half4(color);
        }
        
        rect = float4(rect.x + 0.5f * rect.z,
                      rect.y + 0.5f * rect.w,
                      0.5f * rect.z,
                      0.5f * rect.w);
    }
    
    {
        discard_fragment();
        return half4(0.0);
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>pickedObjects</string>
<string>outline</string>
<string>max</string>
</array>
<key>passes</key>
<dict>
<key>pickedObjects</key>
<dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>outline-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineRetina</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineRetina_vert</string>
<key>metalFragmentShader</key>
<string>outlineRetina_frag</string>
</dict>
<key>max</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>outlineColorBuffer</key>
<string>outline-color</string>
<key>colorBuffer</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineMax</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineMax_vert</string>
<key>metalFragmentShader</key>
<string>outlineMax_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>outline-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.5</real>
</dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<real>0.5</real>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<real>0.5</real>
</dict>
</dict>
</dict>
</plist>
// This pixel shader applies a 3 x 3 blur to the image in
// colorMapSampler, which is the same size as the render target.
// The sample weights are 1/16 in the corners, 2/16 on the edges,
// and 4/16 in the center.
uniform sampler2D colorSampler;
varying vec4 v_texCoord;
void main (void)
    // Use bilinear filtering to average 4 color samples for free.
    vec4 color;
    color  = texture2D( colorSampler, v_texCoord.xz );
    color += texture2D( colorSampler, v_texCoord.yz );
    color += texture2D( colorSampler, v_texCoord.xw );
    color += texture2D( colorSampler, v_texCoord.yw );
    color *= 0.25;
    
gl_FragColor = vec4(color);
#import <metal_stdlib>
using namespace metal;
struct C3DStereoscopy_io {
    float4 position [[position]];
    float2 texCoord;
struct C3DStereoscopy_uniforms {
    float4 viewport;
    float4 hmdWarpParam;
    float2 lensCenterOffset;
    float eye;
    float inputScale;
    float outputScale;
vertex C3DStereoscopy_io C3DStereoscopy_ResolveHmd_vert(uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    C3DStereoscopy_io out;
    out.position = in_position;
    out.texCoord = in_position.xy * float2(1.0, -1.0); // [-1, +1]x[-1, +1]
    
    return out;
fragment half4 C3DStereoscopy_ResolveHmd_frag(C3DStereoscopy_io in [[stage_in]],
                                              texture2d<float> colorSampler [[texture(0)]],
                                              constant C3DStereoscopy_uniforms &uniforms [[buffer(0)]])
    float2 inputScaleVec  = uniforms.inputScale  * float2(1.0, uniforms.viewport.w / (0.5 * uniforms.viewport.z));
    float2 outputScaleVec = uniforms.outputScale * float2(1.0, (0.5 * uniforms.viewport.z) / uniforms.viewport.w);
    
    float2 lensCenter = uniforms.lensCenterOffset * float2(-uniforms.eye, 1.0);
    
    // https://github.com/dghost/glslRiftDistort/blob/master/glsl110/texture-lookup/ovr_make_texture.frag
    float2 delta = (in.texCoord - lensCenter) * inputScaleVec;
    float distance = delta.x * delta.x + delta.y * delta.y;
    float2 rvector = delta * (uniforms.hmdWarpParam.x +
                              uniforms.hmdWarpParam.y * distance +
                              uniforms.hmdWarpParam.z * distance * distance +
                              uniforms.hmdWarpParam.w * distance * distance * distance);
    
    float2 distortion = lensCenter + outputScaleVec * rvector;
    
    half4 color;
    if (any(abs(distortion) > float2(1.0))) {
        color = half4(0.0, 0.0, 0.0, 1.0);
    } else {
        distortion = 0.5 * distortion + float2(0.5); // back to [0, 1] for texture fetch
        constexpr sampler samp;
        color = half4(colorSampler.sample(samp, distortion));
    }
    
//    constexpr sampler samp;
//    color = half4(colorSampler.sample(samp, in.texCoord*0.5+0.5));
    return color;
#import <metal_stdlib>
using namespace metal;
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Unify normals
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// vertTri is [start, start,]
// sharedTri is [(i0,i1,i2), t1, t2, ...]
kernel void unify_u16(uint index                     [[ thread_position_in_grid ]],
                      device packed_float3* pos      [[ buffer(0) ]],
                      device packed_float3* nrm      [[ buffer(1) ]],
                      device uint* vertTopology      [[ buffer(2) ]],
                      device ushort* sharedTriangles [[ buffer(3) ]],
                      constant uint& vertexCount     [[ buffer(4) ]])
    if (index >= vertexCount)
        return;
    uint start = vertTopology[index    ] * 3;
    uint end   = vertTopology[index + 1] * 3;
    float3 averageNrm = 0;
    for (uint faceIndex = start; faceIndex < end; ) {
        ushort i0 = sharedTriangles[faceIndex++];
        ushort i1 = sharedTriangles[faceIndex++];
        ushort i2 = sharedTriangles[faceIndex++];
        
        float3 v0 = pos[i0];
        float3 v1 = pos[i1];
        float3 v2 = pos[i2];
        
        // scale the normal by the triangle area -> remove the normalize
        // http://www.iquilezles.org/www/articles/normals/normals.htm
        float3 faceNormal = cross(v1 - v0, v2 - v0);
        
        // TODO consider crease threshold here
        averageNrm += faceNormal;
    }
    nrm[index] = normalize(averageNrm);
kernel void unify_u32(uint index                     [[ thread_position_in_grid ]],
                      device packed_float3* pos      [[ buffer(0) ]],
                      device packed_float3* nrm      [[ buffer(1) ]],
                      device uint* vertTopology      [[ buffer(2) ]],
                      device uint* sharedTriangles   [[ buffer(3) ]],
                      constant uint& vertexCount     [[ buffer(4) ]])
    if (index >= vertexCount)
        return;
    
    uint start = vertTopology[index];
    uint end   = vertTopology[index + 1];
    
    float3 averageNrm = 0;
    for (uint faceIndex = start; faceIndex < end; ++faceIndex) {
        
        uint i0 = sharedTriangles[faceIndex * 3 + 0];
        uint i1 = sharedTriangles[faceIndex * 3 + 1];
        uint i2 = sharedTriangles[faceIndex * 3 + 2];
        
        float3 v0 = pos[i0];
        float3 v1 = pos[i1];
        float3 v2 = pos[i2];
        
        // scale the normal by the triangle area -> remove the normalize
        // http://www.iquilezles.org/www/articles/normals/normals.htm
        float3 faceNormal = cross(v1 - v0, v2 - v0);
        
        // TODO consider crease threshold here
        averageNrm += faceNormal;
    }
    
    nrm[index] = normalize(averageNrm);
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PickedObject
#define MOD2 float2(443.8975,397.2973)
static inline float hash(float2 p)
    p  = fract(p * MOD2);
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
struct pickedObject_node_uniforms_t
    float4x4 modelTransform;
    float4x4 modelViewProjectionTransform;
struct pickedObject_io
    float4 position [[position]];
    float color;
struct pickedObject_vertex_t
    float3 position [[attribute(SCNVertexSemanticPosition)]];
vertex pickedObject_io pickedObject_vert(pickedObject_vertex_t in [[ stage_in ]], constant SCNSceneBuffer& frameUniforms [[buffer(0)]], constant pickedObject_node_uniforms_t& scn_node [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    pickedObject_io out;
    out.position = (scn_node.modelViewProjectionTransform * in_position);
    out.color = hash(scn_node.modelTransform[3].xy)+1./255.;
    return out;
// Pixel
fragment half pickedObject_frag(pickedObject_io in [[stage_in]])
    return half(in.color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Outline
struct outline_io {
    float4 position [[position]];
    float2 texCoord;
vertex outline_io outline_vert( uint v_id [[ vertex_id ]] )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    outline_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 outline_frag( outline_io in [[stage_in]],
                             texture2d<half> pickedColorBuffer [[texture(0)]],
                             texture2d<half> colorBuffer [[texture(1)]],
                            depth2d<float> depthBuffer [[texture(2)]],
                            depth2d<float> pickedDepthBuffer [[texture(3)]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    //Sobel
    float texels[9];
    texels[0] = pickedColorBuffer.sample(samp, uv, int2(-1,-1)).r;
    texels[1] = pickedColorBuffer.sample(samp, uv, int2( 0,-1)).r;
    texels[2] = pickedColorBuffer.sample(samp, uv, int2( 1,-1)).r;
    texels[3] = pickedColorBuffer.sample(samp, uv, int2(-1, 0)).r;
    texels[4] = pickedColorBuffer.sample(samp, uv).r;
    texels[5] = pickedColorBuffer.sample(samp, uv, int2( 1, 0)).r;
    texels[6] = pickedColorBuffer.sample(samp, uv, int2(-1, 1)).r;
    texels[7] = pickedColorBuffer.sample(samp, uv, int2( 0, 1)).r;
    texels[8] = pickedColorBuffer.sample(samp, uv, int2( 1, 1)).r;
    
    //A little hack for multi-objects selection
    float3 a = float3(texels[0],texels[3],texels[6]);
    float3 b = float3(texels[2],texels[5],texels[7]);
    bool3 tmp = a == b;
    float3 retLin = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    a = float3(texels[0],texels[1],texels[2]);
    b = float3(texels[6],texels[7],texels[8]);
    tmp = a == b;
    float3 retCol = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    float4 last = step(float4(0.002), float4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    //Get min depth around 5x5 pixels
    float depth = 1.;
//    for(int i=-2; i<3; i++)
//        for(int j=-2; j<3; j++)
//            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    //Get min depth around 3x3 pixels
    for(int i=-1; i<2; i++)
        for(int j=-1; j<2; j++)
            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    
    //Outline color
    half4 color = colorBuffer.sample(samp, uv);
    half4 outline = half4(1.,.6,.2,1.);
    if ( depthBuffer.sample(samp, uv) < depth-0.000001  && texels[4] > 0.)
        return mix(color, outline, half4(.25));
    else
        return mix( color, outline, half4(min(magnitude/4.,1.)) );
vertex outline_io outlineRetina_vert( uint v_id [[ vertex_id ]] )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    outline_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 outlineRetina_frag( outline_io in [[stage_in]],
                             texture2d<half> pickedColorBuffer [[texture(0)]],
                             depth2d<float> depthBuffer [[texture(1)]],
                             depth2d<float> pickedDepthBuffer [[texture(2)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    //Sobel
    float texels[9];
    texels[0] = pickedColorBuffer.sample(samp, uv, int2(-1,-1)).r;
    texels[1] = pickedColorBuffer.sample(samp, uv, int2( 0,-1)).r;
    texels[2] = pickedColorBuffer.sample(samp, uv, int2( 1,-1)).r;
    texels[3] = pickedColorBuffer.sample(samp, uv, int2(-1, 0)).r;
    texels[4] = pickedColorBuffer.sample(samp, uv).r;
    texels[5] = pickedColorBuffer.sample(samp, uv, int2( 1, 0)).r;
    texels[6] = pickedColorBuffer.sample(samp, uv, int2(-1, 1)).r;
    texels[7] = pickedColorBuffer.sample(samp, uv, int2( 0, 1)).r;
    texels[8] = pickedColorBuffer.sample(samp, uv, int2( 1, 1)).r;
    
    //A little hack for multi-objects selection
    float3 a = float3(texels[0],texels[3],texels[6]);
    float3 b = float3(texels[2],texels[5],texels[7]);
    bool3 tmp = a == b;
    float3 retLin = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    a = float3(texels[0],texels[1],texels[2]);
    b = float3(texels[6],texels[7],texels[8]);
    tmp = a == b;
    float3 retCol = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    float4 last = step(float4(0.002), float4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    //Get min depth around 5x5 pixels
    float depth = 1.;
//    for(int i=-2; i<3; i++)
//        for(int j=-2; j<3; j++)
//            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    //Get min depth around 3x3 pixels
    for(int i=-1; i<2; i++)
        for(int j=-1; j<2; j++)
            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    
    
    //Outline color
    half3 outline = half3(1.,.4,.0);
    if ( depthBuffer.sample(samp, uv) < depth-0.000001  && texels[4]> 0.)
        return half4(outline, .25);
    else
        return half4(outline,min(magnitude/4.,1.));
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Outline Max
vertex outline_io outlineMax_vert( uint v_id [[ vertex_id ]] )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    outline_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment half4 outlineMax_frag( outline_io in [[stage_in]],
                             texture2d<float> colorBuffer [[texture(0)]],
                             texture2d<float> outlineColorBuffer [[texture(1)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    float4 pixel = float4(0.);
    float alpha = 0.;
    float4 tex;
    
    tex = outlineColorBuffer.sample(samp, uv, int2(-1,-1));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(0,-1));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(1,-1));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(-1,0));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(0,0));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(1,0));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(-1,1));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(0,1));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    tex = outlineColorBuffer.sample(samp, uv, int2(1,1));
    pixel = max(pixel, tex );
    alpha += tex.a/9.;
    
    alpha = mix(alpha, pixel.a, 0.5);
    
    //Final antialiased mix
    return mix( half4(colorBuffer.sample(samp,uv)), half4(float4(pixel.rgb,1.)), half4(smoothstep(0,1,alpha)) );
attribute vec4 a_position;
attribute vec4 a_texCoord0; // x:life y:size z:cornerX w:cornerY
attribute vec4 a_texCoord1; // xyz:velocity w:cornerY
attribute vec4 a_color; // particle color
uniform mat4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
uniform mat4 u_projectionTransform;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main()
    // transform the particle in view space
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
    vec2 dir0 = normalize((viewTransform * vec4(normalize(a_texCoord1.xyz), 0)).xy);
    vec2 tangent = vec2(-dir0.y, dir0.x);
    
    viewPos.xy += tangent * a_texCoord0.y * a_texCoord1.w;
    v_vertexColor = a_color;
    v_uv0 = vec2(a_texCoord0.x, a_texCoord1.w * 0.5 + 0.5);
    
    gl_Position = u_projectionTransform * viewPos;
#import <metal_stdlib>
using namespace metal;
#import "C3D-PostProcess.h"
#import "scn_metal"
#import "scn_util.h"
using namespace scn;
#define USE_LUMINANCE_REINHARD 0
#define USE_REINHARD 1
#define USE_FILMIC 0
#define USE_ACES 0
#define ADAPTATIVE_DECAY 1
// MARK: color conversion
inline float3 rgb_to_Yxy(float3 rgb) {
    // RGB -> XYZ conversion (following ITU-R BT.709)
    const float3x3 RGB2XYZ = {
        {0.4125, 0.3576, 0.1805},
        {0.2126, 0.7152, 0.0722},
        {0.0193, 0.1192, 0.9505},
    };
    
    float3 XYZ = RGB2XYZ * max(rgb, 0.00001);
    
    // XYZ -> Yxy conversion
    
    float3 Yxy;
    Yxy.r = XYZ.g;
    
    // x = X / (X + Y + Z)
    // y = X / (X + Y + Z)
    Yxy.gb = XYZ.rg / dot(1.0, XYZ.rgb);
    
    return Yxy;
inline float3 Yxy_to_rgb(float3 Yxy) {
    
    Yxy.b = max(Yxy.b, 0.00001);
    
    float3 XYZ;
    // Yxy -> XYZ conversion
    XYZ.r = Yxy.r * Yxy.g / Yxy.b;
    
    // X = Y * x / y
    XYZ.g = Yxy.r;
    
    // copy luminance Y
    XYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b;
    
    // Z = Y * (1-x-y) / y
    
    // XYZ -> RGB conversion (following ITU-R BT.709)
    const float3x3 XYZ2RGB = {
        { 3.2410, -1.5374, -0.4986 },
        { -0.9692, 1.8760, 0.0416  },
        { 0.0556, -0.2040, 1.0570  }
    };
    
    return XYZ2RGB * XYZ;
inline float luminance(float3 color)
    // https://en.wikipedia.org/wiki/Relative_luminance
    return color.r * 0.212671 + color.g * 0.715160 + color.b * 0.072169;
inline float linearLuminanceToPerceptual(float luminance)
    return log(max(luminance, 0.001f));
inline float perceptualLuminanceToLinear(float luminance)
    return exp(luminance);
// MARK: Blending operators
inline float3 blend_add(float3 base, float3 blend)
    return min(base + blend, 1.0);
inline float3 blend_lighten(float3 base, float3 blend)
    return max(blend, base);
inline float3 blend_screen(float3 base, float3 blend)
    return (1.0 - ((1.0 - base) * (1.0 - blend)));
// MARK: Tonemapping operators
// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
inline float3 aces(float3 color)
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return saturate((color * (a * color + b)) / (color * ( c * color + d) + e));
// Jim Heijl 2015
inline float3 filmic(float3 color, float whitePoint)
    
    float4 vh = float4(color, whitePoint);
    float4 va = (1.425 * vh) + 0.05f;
    float4 vf = ((vh * va + 0.004f) / ((vh * (va + 0.55f) + 0.0491f))) - 0.0821f;
    return vf.rgb / vf.www;
inline float3 simpleReinhardToneMapping(float3 color, float exposure)
    color *= exposure/(1. + color / exposure);
    //    color = pow(color, float3(1. / gamma));
    return color;
inline float3 reinhardToneMapping(float3 col, float exposure, float whitePoint)
    col *= exposure;
    return (col * (1.f + col / whitePoint)) / (1.f + col);
inline float3 luminanceReinhardToneMapping(float3 col, float exposure, float whitePoint)
    float3 Yxy = rgb_to_Yxy(col.rgb);
    float lumScaled = Yxy.r * exposure;
    float lumCompressed = (lumScaled * (1.f + lumScaled / whitePoint)) / (1.f + lumScaled);
    Yxy.x = lumCompressed;
    return Yxy_to_rgb(Yxy);
// MARK: utility functions
inline bool pointInRect(float2 pt, float4 rect) {
    return all(pt > rect.xy) && all((pt - rect.xy) < rect.zw);
inline float2 rescalePointInRect(float2 pt, float4 rect) {
    return (pt - rect.xy) / rect.zw;
inline float toLogLum(float lum)
    //  we need the precise version of the log otherwise we do get NaNs....
    return precise::log(1 + lum);
inline float fromLogLum(float lum)
    return precise::exp(lum) - 1;
static float scn_exposure(constant scn_postprocess_uniforms_t& uni, float averageLum)
#if 0 // Auto compute middle grey
    
    // auto generate middleGrey based on averageLum [Krawczyk]
    float middleGrey = 1.03 - 2. / (2 + log10(uni.averageLuminance + 1));
    
#else
    float middleGrey = uni.averageLuminance;
#endif
    
    float exposure =  middleGrey / (averageLum + 0.000001);
    exposure = clamp(exposure, uni.minimumExposure, uni.maximumExposure) * uni.exposureOffset;
    
    return exposure;
static float3 scn_tonemap(float3 col, float whitePoint, float exposure)
#if USE_LUMINANCE_REINHARD
    return luminanceReinhardToneMapping(col, exposure, whitePoint);
#elif USE_REINHARD
    return reinhardToneMapping(col, exposure, whitePoint);
#elif USE_FILMIC
    return filmic(col * exposure, whitePoint);
#elif USE_ACES
    return aces(col * exposure);
#endif
    
static float3 scn_tonemap_threshold(float3 col, constant scn_postprocess_uniforms_t& uni, float exposure)
    float3 Yxy = rgb_to_Yxy(col.rgb);
    
    float LumScaled = Yxy.r * exposure;
    float lumthreshold = max(LumScaled * (1.f + LumScaled / uni.whitePoint) - uni.bloomThreshold, 0.);
    Yxy.x = precise::saturate(lumthreshold / (lumthreshold + uni.bloomOffset));
    
    return Yxy_to_rgb(Yxy);
static float3 scn_colorgrading(float3 col, float intensity, texture3d<float> tex)
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear, address::clamp_to_edge);
    float3 corrected = tex.sample(linear_sampler, col).rgb;
    return mix(col, corrected, intensity);
static half4 draw_tonemap_curve(float2 uv, constant scn_postprocess_uniforms_t& uni, constant scn_postprocess_output_t& buffer)
    float lumCompressed = scn_tonemap(uv.xxx, uni.whitePoint, buffer.exposure).x;
    
    float4 col = float4(0.1, 0, 0, 1);
    // average lum
    col += step(abs(uv.y - saturate(buffer.averageLum / 4.)), 0.01) * float4(1);
    col += step(abs(uv.y - buffer.averageLum / 2.), 0.01) * float4(0., 1., 1., 1.);
    col += step(abs(uv.y - uni.minimumExposure / 2.), 0.01) * float4(0., 0., 1., 1.);
    col += step(abs(uv.y - uni.maximumExposure / 2.), 0.01) * float4(0., 1., 0., 1.);
    
    col += smoothstep(0.01, 0.0, abs(uv.y - lumCompressed)) * float4(1, 0, 0, 1);
    return half4(col);
// MARK: Fragment Shaders
fragment float scn_hdr_luminance_frag(scn::draw_quad_io_t in    [[stage_in]],
                                texture2d<float> input_tex      [[texture(0)]])
//    in.uv.y = 1. - in.uv.y;
    
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float4 col = input_tex.sample(linear_sampler, in.uv);
    
    float3 Yxy = rgb_to_Yxy(col.rgb);
    float lum = toLogLum(Yxy.r);
    return lum;
#if USE_UBERSHADER
constant bool enableBloom           [[ function_constant(0) ]];
constant bool enableVignetting      [[ function_constant(1) ]];
constant bool enableColorGrading    [[ function_constant(2) ]];
constant bool enableSaturation      [[ function_constant(3) ]];
constant bool enableContrast        [[ function_constant(4) ]];
constant bool enableColorFringe     [[ function_constant(5) ]];
constant bool enableDebug           [[ function_constant(6) ]];
constant bool enableTonemapping     [[ function_constant(7) ]];
#else
constant bool enableBloom           = true;
constant bool enableVignetting      = true;
constant bool enableColorGrading    = true;
constant bool enableSaturation      = true;
constant bool enableContrast        = true;
constant bool enableColorFringe     = true;
constant bool enableDebug           = false;
constant bool enableTonemapping     = true;
#endif
// Final gather (adaptation + tonemap + bloom + colorgrading)
fragment half4 scn_postprocess(scn::draw_quad_io_t in [[stage_in]],
                               texture2d<float> input_tex           [[texture(0)]],
                               texture2d<float> bloom_tex           [[texture(1)]],
                               texture3d<float> colorGrading_tex    [[texture(2)]],
                               texture2d<float> framelum_tex        [[texture(3)]],
                               texture1d<float> avglum_tex          [[texture(4)]],
                               
                               constant scn_postprocess_uniforms_t& uni       [[ buffer(0) ]],
                               constant scn_postprocess_output_t& buffer      [[ buffer(1) ]])
    constexpr sampler linear_sampler(filter::linear);
    float4 col;
    col = input_tex.sample(linear_sampler, in.uv);
    if (enableColorFringe) {
        float ca = length_squared(in.uv - 0.5) * uni.fringeStrength;
        float3 aberrationShift = float3(16. / input_tex.get_width(), 0., -16. / input_tex.get_width()) * ca;
        float3 fringe = col.rgb;
        fringe.x = input_tex.sample(linear_sampler, in.uv + float2( aberrationShift.x, 0) ).x;
        fringe.z = input_tex.sample(linear_sampler, in.uv + float2( aberrationShift.z, 0) ).z;
        col.rgb = mix(col.rgb, fringe.rgb, uni.fringeIntensity);
    }
    
    if (enableTonemapping) {
        col.rgb = scn_tonemap(col.rgb, uni.whitePoint, buffer.exposure);
    }
    
    // Bloom
    if (enableBloom) {
        float3 bloom = bloom_tex.sample(linear_sampler, in.uv).rgb;
        col.rgb += bloom.rgb * uni.bloomIntensity;
    }
    
    // Color Grading
    if (enableColorGrading) {
        col.rgb = scn_colorgrading(col.rgb, uni.colorGradingIntensity, colorGrading_tex);
    }
    
    // contrast
    if (enableContrast) {
        float3 satCol = saturate(col.rgb);
        col.rgb = satCol - uni.contrast * (satCol - 1.) * satCol * (satCol - 0.5);
    }
    
    // saturate
    if (enableSaturation) {
        float lum = dot(col.rgb, float3(0.2126, 0.7152, 0.0722));
        col.rgb = mix(float3(lum), col.rgb, uni.saturation);
    }
    
    // vignette
    if (enableVignetting) {
        col.rgb *= (1. - uni.vignettingIntensity) + uni.vignettingIntensity * pow(16.0 * in.uv.x*in.uv.y*(1.0-in.uv.x)*(1.0-in.uv.y), uni.vignettingPower );
    }
    if (enableDebug) {
        constexpr sampler nearest_sampler(filter::nearest, mip_filter::nearest);
        float2 screenuv = { in.uv.x, 1. - in.uv.y };
        { // debug frame lum
            float4 rect = { 0.0, 0.0, 0.2, 0.2 };
            if (pointInRect(screenuv, rect)) {
                float2 uv = rescalePointInRect(screenuv, rect);
                int l = framelum_tex.get_num_mip_levels() - 3;
                uv.y = 1. - uv.y;
                return half4(framelum_tex.sample(nearest_sampler, uv, level(l)).x);
            }
        }
        { // debug avg lum
            float4 rect = { 0.2, 0.0, 0.2, 0.2 };
            if (pointInRect(screenuv, rect)) {
                float2 uv = rescalePointInRect(screenuv, rect);
                return half4(avglum_tex.sample(nearest_sampler, uv.x).x);
            }
        }
        { // debug tonemap
            float4 rect = { 0.4, 0.0, 0.2, 0.2 };
            if (pointInRect(screenuv, rect)) {
                return draw_tonemap_curve(rescalePointInRect(screenuv, rect), uni, buffer);
            }
        }
        if (enableBloom) { // debug bloom
            float4 rect = { 0.6, 0.0, 0.2, 0.2 };
            if (pointInRect(screenuv, rect)) {
                float2 uv = rescalePointInRect(screenuv, rect);
                uv.y = 1. - uv.y;
                return half4(bloom_tex.sample(linear_sampler, uv));
            }
        }
        if (enableColorGrading) { // debug color_grading
            float4 rect = { 0.8, 0.0, 0.2, 0.2 };
            constexpr sampler smp(filter::nearest, mip_filter::nearest, address::clamp_to_zero);
            float2 alluv = rescalePointInRect(float2(in.uv.x, 1. - in.uv.y), rect);
            for (uint z = 0; z < 16; ++z) {
                float x = z % 4;
                float y = z / 4;
                float2 uv = rescalePointInRect(alluv, float4(x * 0.25, y * 0.25, 0.25, 0.25));
                float4 grad = colorGrading_tex.sample(smp, float3(uv.x, 1. - uv.y, z / 15.1));
                col.rgb = grad.rgb * grad.a + col.rgb * (1. - grad.a); // over operator
            }
        }
        
    }
    
    return half4(col);
// MARK: Compute Kernels
////////////////////////////////////////////////////////////
// Adaptative luminance
kernel void frame_luminance(uint2 index                                 [[ thread_position_in_grid ]],
                            texture2d<float, access::sample> input_tex    [[ texture(0) ]],
                            texture2d<float, access::write> output_tex  [[ texture(1) ]]
                            )
    if (index.x >= output_tex.get_width() || index.y >= output_tex.get_height())
        return;
    
    // TODO we should go through the last line/colum
    uint2 tileSize = uint2(input_tex.get_width(), input_tex.get_height()) / uint2(output_tex.get_width(), output_tex.get_height());
    uint2 srcIndex = index * tileSize;
    
    float4 sumCol = 0.f;
    for (uint y = 0; y < tileSize.y; ++y) {
        for (uint x = 0; x < tileSize.x; ++x) {
            sumCol += input_tex.read(srcIndex + uint2(x,y));
        }
    }
    sumCol /= (tileSize.x * tileSize.y);
    
    float3 Yxy = rgb_to_Yxy(sumCol.rgb);
    float lum = toLogLum(Yxy.x);
    output_tex.write(lum, index);
kernel void sliding_lum(constant scn_postprocess_uniforms_t& uni      [[ buffer(0) ]],
                        texture1d<float, access::write> avgLumTex   [[ texture(0) ]],
                        texture2d<float> frameLumTex                [[ texture(1) ]]
                        )
    // read in the middle of the last mip of the frame texture mipmap chain
    constexpr sampler smp(filter::nearest, mip_filter::nearest);
    int l = frameLumTex.get_num_mip_levels() - 1;
    float frameLum = frameLumTex.sample(smp, float2(0.5), level(l)).r;
    
    // write it at the current frame
    avgLumTex.write(frameLum, uni.adaptationCurrentFrame);
kernel void adaptative_lum(constant scn_postprocess_uniforms_t& uni      [[ buffer(0) ]],
                           device   scn_postprocess_output_t& output     [[ buffer(1) ]],
                           texture1d<float, access::read> avgLumTex    [[ texture(0)]])
    // now compute the sliding average
    float avgSum = 0.f;
    uint count = uni.adaptationFrameCount;
    for (uint i = 0; i < count; ++i) {
        avgSum += avgLumTex.read(i).x;
    }
    
#if ADAPTATIVE_DECAY
    float targetLum = fromLogLum(avgSum / count);
    
    // adaptation rate.
    float tau = mix(uni.exposureAdaptationDarkeningSpeedFactor, uni.exposureAdaptationBrighteningSpeedFactor, step(targetLum, output.averageLum));
    output.averageLum += (targetLum - output.averageLum) * (1 - exp(-uni.dt * tau));
#else
    output.averageLum   = fromLogLum(avgSum / count);
#endif
    output.averageLum   = precise::max(output.averageLum, 0.00001);
    output.exposure     = scn_exposure(uni, output.averageLum);
kernel void fixed_lum(constant scn_postprocess_uniforms_t& uni    [[ buffer(0) ]],
                      device   scn_postprocess_output_t& output   [[ buffer(1) ]])
    output.averageLum   = 0.18; // default value for average gray, to match the adaptation
    output.exposure     = scn_exposure(uni, output.averageLum);
#define USE_SAMPLING 1
kernel void bright_pass_downsample1(uint2 index                                 [[ thread_position_in_grid ]],
                                    texture2d<float, access::read> input_tex    [[ texture(0) ]],
                                    texture2d<float, access::write> output_tex  [[ texture(1) ]],
                                    constant scn_postprocess_uniforms_t& uni      [[ buffer(0)  ]],
                                    constant scn_postprocess_output_t& outbuf     [[ buffer(1)  ]])
    if (index.x >= output_tex.get_width() || index.y >= output_tex.get_height())
        return;
    
    float4 color = input_tex.read(index);
    color.rgb = scn_tonemap_threshold(color.rgb, uni, outbuf.exposure);
    output_tex.write(color, index);
kernel void bright_pass_downsample2(uint2 index                                 [[ thread_position_in_grid ]],
#if USE_SAMPLING
                                    texture2d<float, access::sample> input_tex  [[ texture(0) ]],
#else
                                    texture2d<float, access::read> input_tex    [[ texture(0) ]],
#endif
                                    texture2d<float, access::write> output_tex  [[ texture(1) ]],
                                    constant scn_postprocess_uniforms_t& uni      [[ buffer(0)  ]],
                                    constant scn_postprocess_output_t& outbuf     [[ buffer(1)  ]])
    if (index.x >= output_tex.get_width() || index.y >= output_tex.get_height())
        return;
    
    uint2 srcIndex = index * 2;
    
#if USE_SAMPLING
    constexpr sampler linear_sampler(filter::linear);
    float2 invRes = 1. / float2( (float)input_tex.get_width(), (float)input_tex.get_height() );
    float2 uv = (float2(srcIndex) + 1.5) * invRes;
    float4 color = input_tex.sample(linear_sampler, uv);
#else
    float4 color = 0.f;
    color += input_tex.read(srcIndex);
    color += input_tex.read(srcIndex + uint2(1, 0));
    color += input_tex.read(srcIndex + uint2(0, 1));
    color += input_tex.read(srcIndex + uint2(1, 1));
    color /= 4;
#endif
    
    color.rgb = scn_tonemap_threshold(color.rgb, uni, outbuf.exposure);
    
    output_tex.write(color, index);
kernel void bright_pass_downsample4(uint2 index                                 [[ thread_position_in_grid ]],
#if USE_SAMPLING
                                    texture2d<float> input_tex                  [[ texture(0) ]],
#else
                                    texture2d<float, access::read> input_tex    [[ texture(0) ]],
#endif
                                    texture2d<float, access::write> output_tex  [[ texture(1) ]],
                                    constant scn_postprocess_uniforms_t& uni      [[ buffer(0)  ]],
                                    constant scn_postprocess_output_t& outbuf     [[ buffer(1)  ]])
    if (index.x >= output_tex.get_width() || index.y >= output_tex.get_height())
        return;
    
    uint2 srcIndex = index * 4;
    float4 color = 0.f;
#if USE_SAMPLING
    
    float2 invRes = 1. / float2( (float)input_tex.get_width(), (float)input_tex.get_height() );
    float2 uv = (float2(srcIndex) + 3.) * invRes;
    // force the clamping to zero to fix an IG issue : rdar://problem/26389307
    constexpr sampler linear_sampler(filter::linear, address::clamp_to_zero);
    color += input_tex.sample(linear_sampler, uv, int2(0, 0));
    color += input_tex.sample(linear_sampler, uv, int2(2, 0));
    color += input_tex.sample(linear_sampler, uv, int2(0, 2));
    color += input_tex.sample(linear_sampler, uv, int2(2, 2));
    color /= 4;
    
#else // use reading
    color += input_tex.read(srcIndex);
    color += input_tex.read(srcIndex + uint2(1, 0));
    color += input_tex.read(srcIndex + uint2(2, 0));
    color += input_tex.read(srcIndex + uint2(3, 0));
    
    color += input_tex.read(srcIndex + uint2(0, 1));
    color += input_tex.read(srcIndex + uint2(1, 1));
    color += input_tex.read(srcIndex + uint2(2, 1));
    color += input_tex.read(srcIndex + uint2(3, 1));
    
    color += input_tex.read(srcIndex + uint2(0, 2));
    color += input_tex.read(srcIndex + uint2(1, 2));
    color += input_tex.read(srcIndex + uint2(2, 2));
    color += input_tex.read(srcIndex + uint2(3, 2));
    
    color += input_tex.read(srcIndex + uint2(0, 3));
    color += input_tex.read(srcIndex + uint2(1, 3));
    color += input_tex.read(srcIndex + uint2(2, 3));
    color += input_tex.read(srcIndex + uint2(3, 3));
    color /= 16;
#endif
    color.rgb = scn_tonemap_threshold(color.rgb, uni, outbuf.exposure);
    output_tex.write(color, index);
#pragma MARK Bloom Blur
static half4 bloom_blur_frag(uint pairCount,
                             scn::draw_quad_io_t in [[stage_in]],
                             texture2d<float> textureSampler0,
                             constant scn_bloom_uniforms_t& uniforms
                             )
    constexpr sampler samp(filter::linear);
    
    uint index = 0;
    float4 c = textureSampler0.sample(samp, in.uv);
    float4 accum = c * uniforms.offsets_weight[index].z;
    float total = uniforms.offsets_weight[index].z;
    
    for (uint i = 0; i < pairCount; ++i) {
        float3 ow = uniforms.offsets_weight[1 + i];
        accum += textureSampler0.sample(samp, in.uv + ow.xy) * ow.z;
        accum += textureSampler0.sample(samp, in.uv - ow.xy) * ow.z;
        total += 2.f * ow.z;
    }
    
    accum /= total;
    return half4(accum);
fragment half4 bloom_blur_frag_1(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(1, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_2(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(2, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_3(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(3, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_4(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(4, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_5(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(5, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_6(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(6, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_7(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(7, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_8(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(8, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_9(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(9, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_10(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(10, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_11(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(11, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_12(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(12, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_13(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(13, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_14(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(14, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_15(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(15, in, textureSampler0, uniforms);
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
uniform sampler2D u_sampler;
void main()
    vec4 mask = texture2D(u_sampler, v_texCoord);
    gl_FragColor = v_vertexColor * mask;
#extension GL_OES_standard_derivatives : enable
precision highp float; 
uniform vec4 u_color;
varying vec3 v_vertexCenter;
#if 0
// Fragment shader function
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x);
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x)
    vec3 t = clamp((x - edge0)/(edge1 - edge0), vec3(0.), vec3(1));
    return t * t * (3. - 2. * t);
#endif
void main()
    vec3 d = fwidth(v_vertexCenter);
    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, v_vertexCenter);
    //    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, in.center);
    float edge =  min(min(a3.x, a3.y), a3.z);
    if (edge >= 1.0)
        discard;
    gl_FragColor = u_color * (1.0 - edge) * 0.95;
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main(void)
gl_Position = u_modelViewProjectionTransform * a_position;
struct SCNShaderLight
vec4 intensity; // lowp, light intensity
vec3 direction; // mediump, vector from the point toward the light
    
    // private
    float _att;
    vec3 dir; // lowp, vector from the point to the light for point and spot, dist attenuations
    float dist; // mediump, distance from the point to the light (same coord. than range)
void main()
    gl_FragColor = vec4(1.,0.,0.,1.);
uniform mat4 u_modelTransform;
#define MOD2 vec2(443.8975,397.2973)
float hash(vec2 p)
    p  = fract(p * MOD2);
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
void main()
    float x = hash(u_modelTransform[3].xy);
gl_FragColor = vec4(vec3(x+1./255.),1.);
// Utility
// Tool function
namespace scn {
    
    inline float3x3 mat3(float4x4 mat4)
    {
        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);
    }
    
    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return normalize(dst);
    }
    
    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return dst;
    }
    
    inline void generate_basis(float3 inR, thread float3 *outS, thread float3 *outT)
    {
        float3 dir = abs(inR.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
        *outS = normalize(cross(dir, inR));
        *outT = cross(inR, *outS);
    }
    // MARK: Drawing quads
    
    struct draw_quad_io_t {
        float4 position [[ position ]];
        float2 uv;
    };
    
inline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
inline float shadow2DProj(depth2d<float> tex, float4 uv)
    constexpr sampler linear_sampler(filter::linear, mip_filter::none, compare_func::greater_equal);
    //constexpr sampler linear_sampler(filter::linear, mip_filter::none, compare_func::none);
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(linear_sampler, uvp.xy, uvp.z);
uniform vec3 CocScaleBias;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
void main (void)
    // "rowOfs" reduces how many moves PS2.0 uses to emulate swizzling.
//    vec2 dofRowDelta = vec2(0., 0.25 * invPixelSize.y);
    vec4 dofRowDelta = vec4(0., 1., 2., 3.) * u_inversePixelSize.y * 0.25;
    vec2 rowOfs[4];
    rowOfs[0] = dofRowDelta.xx; // 0,0 useless...
    rowOfs[1] = dofRowDelta.xy;
    rowOfs[2] = dofRowDelta.xz;
    rowOfs[3] = dofRowDelta.xw;
    
    // Use bilinear filtering to average 4 color samples for free.
    vec3 color;
    color  = texture2D( colorSampler, v_tcColor0.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor0.xy + rowOfs[2] ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy + rowOfs[2] ).rgb;
    color *= 0.25;
    
    vec4 depth;
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[0] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[0] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[0] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[0] ).r;
    vec4 coc = abs(depth * CocScaleBias.x + CocScaleBias.y);
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[1] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[1] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[1] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[1] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[2] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[2] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[2] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[2] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[3] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[3] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[3] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[3] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    float maxCoc = max( max( coc.x, coc.y ), max( coc.z, coc.w ) );
    //
    // this pass should be use to mark the zone not to blur = the zone which are in focus
gl_FragColor = vec4(color, maxCoc);
#import <metal_stdlib>
#import <metal_compute>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
// for cubemap utilities
#import "C3D-PBR.metal"
// MARK: Structures
#define USE_PRECISE_SOLIDANGLE 0
namespace scn {
    struct sh3_vector {
        float4 V0;
        float4 V1;
        float  V2;
    };
    
    struct sh3_rgb {
        float red[9];
        float green[9];
        float blue[9];
    };
    
    inline float dot_sh3_vector(sh3_vector A, sh3_vector B)
    {
        float Result = dot(A.V0, B.V0);
        Result += dot(A.V1, B.V1);
        Result += A.V2 * B.V2;
        return Result;
    }
    
    inline sh3_vector shVectorFromSh(float const constant sh[9])
    {
        sh3_vector res;
        res.V0 = float4(sh[0], sh[1], sh[2], sh[3]);
        res.V1 = float4(sh[4], sh[5], sh[6], sh[7]);
        res.V2 = sh[8];
        return res;
    }
// MARK: SH computation (from cubemap)
// warning: these functions works with the degree of the basis -> degree == order - 1
inline void sh_eval_basis(int shOrder, float3 dir, float b[9])
    if (shOrder > 0) {
        b[0] = 0.282095f;
    }
    if (shOrder > 1) {
        b[1] =-0.488603f *  dir.y;
        b[2] = 0.488603f *  dir.z;
        b[3] =-0.488603f *  dir.x;
    }
    if (shOrder > 2) {
        float3 d2 = dir * dir;
        b[4] = 1.092548f *  dir.x * dir.y;
        b[5] =-1.092548f *  dir.y * dir.z;
        b[6] = 0.315392f * (3 * d2.z - 1);
        b[7] =-1.092548f *  dir.x * dir.z;
        b[8] = 0.546274f * (d2.x - d2.y);
    }
inline void sh_eval_basis_3(float x,float y,float z, float b[16])
    const float z2 = z*z;
    
    /* m=0 */
    const float p_0_0 = 0.282094791773878140;
    b[  0] = p_0_0; // l=0,m=0
    const float p_1_0 = 0.488602511902919920 * z;
    b[  2] = p_1_0; // l=1,m=0
    const float p_2_0 = 0.946174695757560080 * z2 + -0.315391565252520050;
    b[  6] = p_2_0; // l=2,m=0
    const float p_3_0 = z*(1.865881662950577000 * z2 + -1.119528997770346200);
    b[ 12] = p_3_0; // l=3,m=0
    
    
    /* m=1 */
    const float s1 = y;
    const float c1 = x;
    const float p_1_1 = -0.488602511902919920;
    b[  1] = p_1_1*s1; // l=1,m=-1
    b[  3] = p_1_1*c1; // l=1,m=+1
    const float p_2_1 = -1.092548430592079200 * z;
    b[  5] = p_2_1*s1; // l=2,m=-1
    b[  7] = p_2_1*c1; // l=2,m=+1
    const float p_3_1 = -2.285228997322328800 * z2 + 0.457045799464465770;
    b[ 11] = p_3_1*s1; // l=3,m=-1
    b[ 13] = p_3_1*c1; // l=3,m=+1
    
    /* m=2 */
    const float s2 = x*s1 + y*c1;
    const float c2 = x*c1 - y*s1;
    const float p_2_2 = 0.546274215296039590;
    b[  4] = p_2_2*s2; // l=2,m=-2
    b[  8] = p_2_2*c2; // l=2,m=+2
    const float p_3_2 = 1.445305721320277100 * z;
    b[ 10] = p_3_2*s2; // l=3,m=-2
    b[ 14] = p_3_2*c2; // l=3,m=+2
    
    
    /* m=3 */
    const float s3 = x*s2 + y*c2;
    const float c3 = x*c2 - y*s2;
    const float p_3_3 = -0.590043589926643520;
    b[  9] = p_3_3*s3; // l=3,m=-3
    b[ 15] = p_3_3*c3; // l=3,m=+3
#if USE_PRECISE_SOLIDANGLE
inline float3 vector(int f, float x, float y, float z)
    float3 X, Y, Z;
    switch (f) {
        case 0:
            X = (float3){ 0.0,  0.0,  1.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){-1.0,  0.0,  0.0 };
            break;
        case 1:
            X = (float3){ 0.0,  0.0, -1.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){ 1.0,  0.0,  0.0 };
            break;
        case 2:
            X = (float3){-1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  0.0, -1.0 };
            Z = (float3){ 0.0, -1.0,  0.0 };
            break;
        case 3:
            X = (float3){-1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  0.0,  1.0 };
            Z = (float3){ 0.0,  1.0,  0.0 };
            break;
        case 4:
            X = (float3){-1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){ 0.0,  0.0, -1.0 };
            break;
        case 5:
            X = (float3){ 1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){ 0.0,  0.0,  1.0 };
            break;
            
    }
    
    float3 w;
    w.x = X[0] * x + Y[0] * y + Z[0] * z;
    w.y = X[1] * x + Y[1] * y + Z[1] * z;
    w.z = X[2] * x + Y[2] * y + Z[2] * z;
    
    return normalize(w);
inline float solid_angle(const float3 a,
                   const float3 b,
                   const float3 c)
    float n = fabs(a[0] * (b[1] * c[2] - b[2] * c[1]) +
                    a[1] * (b[2] * c[0] - b[0] * c[2]) +
                    a[2] * (b[0] * c[1] - b[1] * c[0]));
    
    float d = 1.0 + a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
    + a[0] * c[0] + a[1] * c[1] + a[2] * c[2]
    + b[0] * c[0] + b[1] * c[1] + b[2] * c[2];
    
    return 2.0 * atan2(n, d);
inline float calc_domega(const float3 v00,
                         const float3 v01,
                         const float3 v10,
                         const float3 v11)
    return (solid_angle(v00, v11, v01) +
            solid_angle(v11, v00, v10)) / (4 * scn::PI);
#endif
// MARK: sh sums
typedef enum {
    kCubeFaceCount = 6
} kCubeFaceCountEnum;
// Unoptimized version, without local thread group (for debugging)
static void sh_from_cubemap(uint                               shOrder,
                            texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                            device float*                      outputSH    [[ buffer(0) ]])
    uint edgeSize = cubemap.get_width();
    
    float fEdgeSize = float(cubemap.get_width());
    float fB = -1. + 1. / fEdgeSize;
    float fS = 2. * ( 1. - 1. / fEdgeSize ) / ( fEdgeSize - 1.);
    
    constexpr sampler smp;
    
    float fWt = 0.0f;
    uint numCoeff = shOrder * shOrder;
    
    //
    const uint maxSHOrder = 4;
    float localSH[maxSHOrder * maxSHOrder];
    
    float3 localSHRGB[maxSHOrder * maxSHOrder] = { float3(0.f) };
    float invSurfaceArea = 4.0f / (fEdgeSize * fEdgeSize);
    
    //--- Process each face of the cubemap
    for (uint face=0; face < 6; ++face )
    {
        for( uint y=0; y < edgeSize; ++y )
        {
            for( uint x=0; x < edgeSize; ++x )
            {
    #if USE_PRECISE_SOLIDANGLE
                float y0  = (2.0 * (y      ) - fEdgeSize) / fEdgeSize;
                float y_  = (2.0 * (y + 0.5) - fEdgeSize) / fEdgeSize;
                float y1  = (2.0 * (y + 1.0) - fEdgeSize) / fEdgeSize;
                float x0  = (2.0 * (x      ) - fEdgeSize) / fEdgeSize;
                float x_  = (2.0 * (x + 0.5) - fEdgeSize) / fEdgeSize;
                float x1  = (2.0 * (x + 1.0) - fEdgeSize) / fEdgeSize;
                
                float3 v00 = vector(face, x0, y0, 1.f);
                float3 v01 = vector(face, x0, y1, 1.f);
                float3 v10 = vector(face, x1, y0, 1.f);
                float3 v11 = vector(face, x1, y1, 1.f);
                float3 dir = vector(face, x_, y_, 1.f);
                const float fDiffSolid = 4.0f * scn::PI * calc_domega(v00, v01, v10, v11);
    #else
                
                float2 uv( x * fS + fB, y * fS + fB );
                float3 dir = normalize(scn::cubemap_dir_from_sampleCoord(face, uv));
                
                const float fDiffSolid = invSurfaceArea / ((1. + dot(uv, uv)) * sqrt(1. + dot(uv, uv) ));
    #endif
                fWt += fDiffSolid;
                // compute SH
                sh_eval_basis(shOrder, dir, localSH);
                
                float4 col = cubemap.sample(smp, dir) * fDiffSolid;
                for( uint i=0; i < numCoeff; ++i ) {
                    localSHRGB[i] += col.xyz * localSH[i];
                }
            }
        }
    }
    
    // Output (scaling not needed since fWt should sum to 1)
    uint rOffset = 0;
    uint gOffset = numCoeff;
    uint bOffset = numCoeff * 2;
    for (uint j = 0; j < numCoeff; ++j) {
        float3 sh = localSHRGB[ j ];
        outputSH[j + rOffset] = sh.x;
        outputSH[j + gOffset] = sh.y;
        outputSH[j + bOffset] = sh.z;
    }
// generate version depending on a constant SH order (for compilation optimization to kick in)
kernel void compute_sh2_from_cubemap(texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                                     device float*                      outputSHRGB [[ buffer(0) ]]
    sh_from_cubemap(2, cubemap, outputSHRGB);
kernel void compute_sh3_from_cubemap(texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                                     device float*                      outputSHRGB [[ buffer(0) ]]
    sh_from_cubemap(3, cubemap, outputSHRGB);
kernel void compute_sh4_from_cubemap(texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                                     device float*                      outputSHRGB [[ buffer(0) ]]
    sh_from_cubemap(4, cubemap, outputSHRGB);
// Version with threadgroup mem
typedef enum {
    kMaxThreadsPerThreadgroup = 64
} kMaxThreadsPerThreadgroupEnum;
static void sh_from_cubemap_threadgroup_mem(uint                               shOrder,
                                            texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                            device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                            threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                            uint                               index                  [[ threadgroup_position_in_grid ]],
                                            uint                               lid                    [[ thread_position_in_threadgroup ]],
                                            uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    uint edgeSize = cubemap.get_width();
    
    
    float fEdgeSize = float(cubemap.get_width());
    float fB = -1. + 1. / fEdgeSize;
    float fS = 2. * ( 1. - 1. / fEdgeSize ) / ( fEdgeSize - 1.);
    
    constexpr sampler smp;
    
    float fWt = 0.0f;
    uint numCoeff = shOrder * shOrder;
    
    float localSH[16]; //used to be numCoeff but: <rdar://problem/27330922> GPUCompiler-600.0.48.21 makes SceneKit-373 fail to build due to SceneKit use of VLA (variable length array)
    
    uint baseIndex = lid * numCoeff;
    for (uint i = 0; i < numCoeff; ++i) {
        localSHRGB[baseIndex + i] = float3(0.0f);
    }
    
    // Do we need this barrier since each thread write in a different memory location
    // threadgroup_barrier(mem_flags::mem_threadgroup);
    float invSurfaceArea = 4.0f / (fEdgeSize * fEdgeSize);
    
    uint face = index;
    for( uint y=0; y < edgeSize; ++y )
    {
        //        for( uint x=lid; x < edgeSize; x+=kThreadsPerThreadGroup )
        uint wcount = edgeSize / kThreadsPerThreadGroup;
        uint lastX = min((lid + 1) * wcount, edgeSize);
        for (uint x = lid * wcount; x <  lastX; ++x)
        {
            float2 uv( x * fS + fB, y * fS + fB );
            float3 dir = normalize(scn::cubemap_dir_from_sampleCoord(face, uv));
            
            const float fDiffSolid = invSurfaceArea / ((1. + dot(uv, uv)) * sqrt(1. + dot(uv, uv) ));
            fWt += fDiffSolid;
            // compute SH
            sh_eval_basis(shOrder, dir, localSH);
            
            float4 col = cubemap.sample(smp, dir) * fDiffSolid;
            for( uint i=0; i < numCoeff; ++i ) {
                localSHRGB[baseIndex + i] += col.xyz * localSH[i];
            }
        }
    }
    
    threadgroup_barrier(mem_flags::mem_threadgroup);
    
    // do the final sum
    if (lid == 0)
    {
        for (uint ti = 1; ti < kThreadsPerThreadGroup; ++ti)
        {
            for( uint i=0; i < numCoeff; ++i ) {
                localSHRGB[i] += localSHRGB[ti * numCoeff + i];
            }
        }
        
        // output
        for( uint i=0; i < numCoeff; ++i )
        {
            uint ind = numCoeff * index + i;
            outputSHRGB[ind] = localSHRGB[i].rgb;
        }
    }
kernel void compute_sh2_from_cubemap_threadgroup_mem(texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                                     device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                                     threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                                     uint                               index                  [[ threadgroup_position_in_grid ]],
                                                     uint                               lid                    [[ thread_position_in_threadgroup ]],
                                                     uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    sh_from_cubemap_threadgroup_mem(2, cubemap, outputSHRGB, localSHRGB, index, lid, kThreadsPerThreadGroup);
kernel void compute_sh3_from_cubemap_threadgroup_mem(texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                                     device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                                     threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                                     uint                               index                  [[ threadgroup_position_in_grid ]],
                                                     uint                               lid                    [[ thread_position_in_threadgroup ]],
                                                     uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    sh_from_cubemap_threadgroup_mem(3, cubemap, outputSHRGB, localSHRGB, index, lid, kThreadsPerThreadGroup);
kernel void compute_sh4_from_cubemap_threadgroup_mem(texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                                     device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                                     threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                                     uint                               index                  [[ threadgroup_position_in_grid ]],
                                                     uint                               lid                    [[ thread_position_in_threadgroup ]],
                                                     uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    sh_from_cubemap_threadgroup_mem(4, cubemap, outputSHRGB, localSHRGB, index, lid, kThreadsPerThreadGroup);
static void sh_sum(uint                  shOrder,
                   device float*         outputSH   [[ buffer(0) ]],
                   device packed_float3* inputSHRGB [[ buffer(1) ]])
    enum { kCubeFaceCount = 6 };
    uint numCoeff = shOrder * shOrder;
    
    // first clear
    for (uint j = 0; j < (numCoeff * 3); ++j) {
        outputSH[j] = 0;
    }
    
    uint rOffset = 0;
    uint gOffset = numCoeff;
    uint bOffset = numCoeff * 2;
    for (uint i = 0; i < kCubeFaceCount; ++i) {
        for (uint j = 0; j < numCoeff; ++j) {
            uint srcindex = i * numCoeff + j;
            float3 sh = inputSHRGB[srcindex];
            outputSH[j + rOffset] += sh.x;
            outputSH[j + gOffset] += sh.y;
            outputSH[j + bOffset] += sh.z;
        }
    }
kernel void sum_sh2(device float*         outputSH   [[ buffer(0) ]],
                    device packed_float3* inputSHRGB [[ buffer(1) ]])
    sh_sum(2, outputSH, inputSHRGB);
kernel void sum_sh3(device float*         outputSH   [[ buffer(0) ]],
                    device packed_float3* inputSHRGB [[ buffer(1) ]])
    sh_sum(3, outputSH, inputSHRGB);
kernel void sum_sh4(device float*         outputSH   [[ buffer(0) ]],
                    device packed_float3* inputSHRGB [[ buffer(1) ]])
    sh_sum(4, outputSH, inputSHRGB);
// MARK: Cubemap generation (from SH)
inline scn::sh3_vector sh3_basis(half3 dir)
    scn::sh3_vector res;
    res.V0.x = 0.282095f;
    res.V0.y = -0.488603f * dir.y;
    res.V0.z = 0.488603f * dir.z;
    res.V0.w = -0.488603f * dir.x;
    
    half3 VectorSquared = dir * dir;
    res.V1.x = 1.092548f * dir.x * dir.y;
    res.V1.y = -1.092548f * dir.y * dir.z;
    res.V1.z = 0.315392f * (3.0f * VectorSquared.z - 1.0f);
    res.V1.w = -1.092548f * dir.x * dir.z;
    res.V2 = 0.546274f * (VectorSquared.x - VectorSquared.y);
    return res;
inline scn::sh3_vector sh3_compute_diffuse_transfer(half3 normal, half Exponent)
    scn::sh3_vector res = sh3_basis(normal);
    half L0 =
 2 * scn::PI / (1 + 1 * Exponent);
    half L1 =
 2 * scn::PI / (2 + 1 * Exponent);
    half L2 = Exponent * 2 * scn::PI / (3 + 4 * Exponent + Exponent * Exponent);
    
    res.V0.x *= L0;
    res.V0.yzw *= L1;
    res.V1.xyzw *= L2;
    res.V2 *= L2;
    return res;
fragment float4 cubemap_from_sh(scn::draw_quad_io_t    in   [[ stage_in ]],
                                constant scn::sh3_rgb& sh   [[ buffer(0) ]],
                                constant uint&         face [[ buffer(1) ]])
    float3 dir = normalize(scn::cubemap_dir_from_uv(face, in.uv));
    
    const float Exponent = 1;
    
    // Compute SH for the normal
    scn::sh3_vector diffSH = sh3_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    float r = dot_sh3_vector(scn::shVectorFromSh(sh.red), diffSH) / scn::PI;
    float g = dot_sh3_vector(scn::shVectorFromSh(sh.green), diffSH) / scn::PI;
    float b = dot_sh3_vector(scn::shVectorFromSh(sh.blue), diffSH) / scn::PI;
    
    return float4(max(0.0f, r), max(0.0f, g), max(0.0f, b), 1.0);
// MARK: Drawing
struct ProbeSphere_in
    float4 position [[ attribute(SCNVertexSemanticPosition) ]];
    float3 normal   [[ attribute(SCNVertexSemanticNormal) ]];
struct ProbeSphere_node
    float4x4 modelTransform;
    float4x4 modelViewProjectionTransform;
struct ProbeSphere_io
    float4 position [[ position ]];
    float3 dir;
vertex ProbeSphere_io scn_probesphere_from_sh_vertex(ProbeSphere_in             in        [[ stage_in ]],
                                                     constant SCNSceneBuffer&   scn_frame [[ buffer(0) ]],
                                                     constant ProbeSphere_node& scn_node  [[ buffer(1) ]])
    ProbeSphere_io out;
    
    out.position = scn_node.modelViewProjectionTransform * in.position;
    out.dir = scn::mat4_mult_float3(scn_frame.viewToCubeTransform, scn::mat4_mult_float3(scn_frame.viewTransform, in.normal));
    
    return out;
fragment float4 scn_probesphere_from_sh_fragment(ProbeSphere_io         in [[ stage_in ]],
                                                 constant scn::sh3_rgb& sh [[ buffer(0) ]])
    const float Exponent = 1;
    
    // Compute SH for the normal
    scn::sh3_vector diffSH = sh3_compute_diffuse_transfer(half3(in.dir), Exponent);
    
    float r = dot_sh3_vector(scn::shVectorFromSh(sh.red), diffSH) / scn::PI;
    float g = dot_sh3_vector(scn::shVectorFromSh(sh.green), diffSH) / scn::PI;
    float b = dot_sh3_vector(scn::shVectorFromSh(sh.blue), diffSH) / scn::PI;
    
    return float4(max(0.0f, r), max(0.0f, g), max(0.0f, b), 1.0);
#ifdef ENABLE_CUBE_MAP
uniform samplerCube u_textureSampler0;
uniform float u_fresnelExponent;
varying vec4 v_normal;
#ifdef ENABLE_FOG
uniform vec4 u_fogColor;
#endif
#else // ENABLE_CUBE_MAP
uniform sampler2D u_textureSampler0;
#endif
varying vec4 v_vertexColor;
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
#if __VERSION__ > 120 // GL Compatibility Profile
#ifndef texture2D
#define texture2D(tex,coord) texture( tex, coord )
#endif
#define textureCube(tex,coord) texture( tex, coord )
#endif
#ifdef ENABLE_SOFT
uniform sampler2D u_depthSampler0;
uniform vec4 u_softParameters; // x: scale, y: power/contrast, zw : 1/viewPortSize
uniform mat4 u_invProj; // inverse of the projection transform, to reconstruct viewPos from screenPos
varying float v_eyeLinearZ;
float ComputeSoftFactor()
    vec2 normalizedFragCoord = gl_FragCoord.xy * u_softParameters.zw;
float depthValue = texture2D(u_depthSampler0, gl_FragCoord.xy * u_softParameters.zw).x;
    
    vec3 screenPos = vec3(normalizedFragCoord, depthValue);
vec4 viewPos = u_invProj * vec4(screenPos * 2. - 1., 1.);
viewPos /= viewPos.w;
    
    float factor = clamp((v_eyeLinearZ - viewPos.z) * u_softParameters.x ,0. , 1.);
    // Do we really need this pow?
    // factor = pow(factor, u_softParameters.y);
    
    return factor;
#endif
void main(){
#ifdef ENABLE_CUBE_MAP
    vec2 p = v_uv0 * 2. - 1.;
    float r = dot(p,p); // len^2
    vec4 tex = textureCube(u_textureSampler0, v_normal.xyz) * clamp(9.6 - 10. * r, 0., 1.0);
    // fresnel modulation
    tex.rgb *= pow(r, u_fresnelExponent);
#else // ENABLE_CUBE_MAP
#ifdef ENABLE_ANIMATION // belnd between two frames
    vec4 tex = mix(texture2D(u_textureSampler0, v_uv0.xy),
                   texture2D(u_textureSampler0, v_uv1.xy), v_uv0.z);
#else
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
#endif // ENABLE_ANIMATION
#endif // ENABLE_CUBE_MAP
#ifdef ENABLE_SOFT
    tex *= ComputeSoftFactor();
#endif
    
    
#ifdef ENABLE_CUBE_MAP
    gl_FragColor.a = v_vertexColor.a * tex.a; // texture and colors need to be premultiplied
#ifdef ENABLE_FOG
    gl_FragColor.rgb = mix(v_vertexColor.rgb + tex.rgb, u_fogColor.rgb, v_normal.a) * gl_FragColor.a; // texture and colors need to be premultiplied
#else
    gl_FragColor.rgb = (v_vertexColor.rgb + tex.rgb) * gl_FragColor.a; // texture and colors need to be premultiplied
#endif // ENABLE_FOG
#else
    gl_FragColor = v_vertexColor * tex; // texture and colors need to be premultiplied
#endif
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
typedef struct {
    float4x4 modelTransform;
} debug_node;
typedef struct {
    float3 position [[attribute(0)]];
} debug_vertex_t;
// Vertex shader function
vertex float4 debug_vert(debug_vertex_t in [[ stage_in ]],
                                              constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                                              constant debug_node& scn_node [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    return  scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
// Fragment shader function
fragment half4 debug_frag()
    return half4(1.0, 0.0, 1.0, 1.0);
fragment half4 debug_isolate_frag()
    return half4(1.0, 0.0, 0.0, 1.0);
////////////////////////////////////////////////////////////////////////////
typedef struct {
    float3 position [[attribute(0)]];
    float3 normal [[attribute(1)]];
} debug_normal_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 color;
} debug_normal_io;
// Vertex shader function
vertex debug_normal_io debug_normal_vert(debug_normal_vertex_t in [[ stage_in ]],
                               constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                               constant debug_node& scn_node [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    debug_normal_io out;
    out.position = scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
    //    float d = max(dot(in.normal, float3(0,0,1)), 0.0);
    //    out.color = float4(d);
    out.color.a = 1.0;
    out.color.rgb = in.normal.xyz * 0.5 + 0.5;
    return out;
// Fragment shader function
fragment half4 debug_normal_frag(debug_normal_io in [[stage_in]])
    return half4(in.color);
#ifndef __SCNMetalDefines__
#define __SCNMetalDefines__
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3,
    SCNVertexSemanticTexcoord4,
    SCNVertexSemanticTexcoord5,
    SCNVertexSemanticTexcoord6,
    SCNVertexSemanticTexcoord7
// This structure hold all the informations that are constant through a render pass
// In a shader modifier, it is given both in vertex and fragment stage through an argument named "scn_frame".
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; // transform from view space to world space
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; // transform from view space to cube texture space (canonical Y Up space)
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; // x:-1/(end-start) y:1-start*x z:exp
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    // new in macOS 10.12 and iOS 10
    float       environmentIntensity;
    float4x4    inverseProjectionTransform;
    float4x4    inverseViewProjectionTransform;
// In custom shaders or in shader modifiers, you also have access to node relative information.
// This is done using an argument named "scn_node", which must be a struct with only the necessary fields
// among the following list:
// float4x4 modelTransform;
// float4x4 inverseModelTransform;
// float4x4 modelViewTransform;
// float4x4 inverseModelViewTransform;
// float4x4 normalTransform; // This is the inverseTransposeModelViewTransform, need for normal transformation
// float4x4 modelViewProjectionTransform;
// float4x4 inverseModelViewProjectionTransform;
// float2x3 boundingBox;
// float2x3 worldBoundingBox;
#endif /* defined(__SCNMetalDefines__) */
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec4 v_texCoord;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    vec4 offset = vec4(-0.5, 0.5, -0.5, 0.5);
    v_texCoord = tc.xxyy + offset * u_inversePixelSize.xyxy;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-DeferredShadingCommon.h"
#import "C3D-PBR.metal"
/// PBR shareable
#define str(a,b) a##b
#if defined(FUNC_VERT) && defined(FUNC_FRAG)
//#define tokenize(a) (#a)
//#define vertex_name   str(ds_default_vert_,tokenize(SHADER_SUFFIX))
//#define fragment_name   str(ds_default_frag_, tokenize(SHADER_SUFFIX))
#define vertex_name   FUNC_VERT
#define fragment_name FUNC_FRAG
#else
#define vertex_name   ds_default_vert
#define fragment_name ds_default_frag
#endif
inline float4 AmbientContribution(SCNPBRSurface surface, texturecube<float> irradianceTexture, texturecube<float> radianceTexture, constant SCNSceneBuffer& scn_frame, float4 vpos)
    float3 indirect = 0.0; //PBR_indirect(surface, irradianceTexture, radianceTexture, scn_frame);
    // TODO
    
    float4 color = float4(0., 0., 0., 1.);
    // ambient lighting (maybe kill it if irradiance map present)
    color.rgb  = (scn_frame.ambientLightingColor.rgb * surface.ao) * surface.albedo;
    // IBL irradiance + radiance
    color.rgb += indirect;
    // Emission
    color.rgb += surface.emission;
    
    return color;
struct GBufferUniforms {
    float4x4 modelTransform;
    float4x4 modelViewTransform;
    float4x4 normalTransform;
struct GBufferVertex {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
    float4 color            [[attribute(SCNVertexSemanticColor)]];
    float4 skinningWeights  [[attribute(SCNVertexSemanticBoneWeights)]];
    uint4  skinningJoints   [[attribute(SCNVertexSemanticBoneIndices)]];
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
struct GBufferIO {
    float4 position [[position]];
    
    float4 positionVS;
    float3 normalVS;
#ifdef USE_NORMAL_MAP
    float3 tangentVS;
    float3 bitangentVS;
#endif
    float2 albedoTexcoord;
    float2 ambientTexcoord;
    float2 emissionTexcoord;
    float2 normalTexcoord;
struct FragmentOutput {
    float4 lighting [[ color(0) ]]; // accumulation of ambient, emissive, then later the lights themselves
    float4 albedo_roughness [[ color(1) ]]; // albedo + roughness
    float4 normal_depth [[ color(2) ]]; // in view space
    float4 xxxx [[ color(3) ]];
// Vertex shader function
vertex GBufferIO ds_default_vert(GBufferVertex in [[ stage_in ]],
                                 constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                                 constant GBufferUniforms& scn_node [[buffer(1)]],
                                 constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(2)]])
    float4 in_position = float4(in.position, 1.0);
    
    GBufferIO out;
    out.position = scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
    
    // view space position
    out.positionVS.xyz =  (scn_node.modelViewTransform * in_position).xyz;
    // far clip : OPTIM : we should store it in uniform (SceneBuffer) and access it in the fragment shader
    // for now compute it based on the projection matrix
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    out.positionVS.w = d / (1.f + c);
    
    // normal
    out.normalVS =  in.normal.xxx * scn_node.normalTransform[0].xyz;
    out.normalVS += in.normal.yyy * scn_node.normalTransform[1].xyz;
    out.normalVS += in.normal.zzz * scn_node.normalTransform[2].xyz;
    out.normalVS = normalize(out.normalVS); // * 0.5 + 0.5; // Normalization here is incorrect, should be done in the fragment shader
    
    // texcoord
    // TODO : how to choose between the n texcoords without recompiling
    // swizzling?
    // i.e. : out.albedoTexCoord = uniforms.albedoSwizzle.x * in.texcoord0 + uniforms.albedoSwizzle.y * in.texcoord1 + uniforms.albedoSwizzle.x * in.texcoord2 + uniforms.albedoSwizzle.x * in.texcoord3;
    // this can be more efficient if we szizzle the 4 texcoords like XXXX, YYYY. then that would be two dots
    out.albedoTexcoord = in.texcoord0;
    out.emissionTexcoord = in.texcoord0;
    out.ambientTexcoord = in.texcoord0;
    
    out.albedoTexcoord      = scn_commonprofile_ds.diffuseTransform * float3(out.albedoTexcoord, 1.f);
    out.emissionTexcoord    = scn_commonprofile_ds.emissionTransform * float3(out.emissionTexcoord, 1.f);
    out.ambientTexcoord     = scn_commonprofile_ds.ambientTransform * float3(out.ambientTexcoord, 1.f);
    
    // TODO transformation matrices
    
    return out;
// NormalMap version
vertex GBufferIO vertex_name(GBufferVertex in [[ stage_in ]],
                                   constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                                   constant GBufferUniforms& scn_node [[buffer(1)]],
                                   constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(2)]])
    float4 in_position = float4(in.position, 1.0);
    
    GBufferIO out;
    out.position = scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
    
    // view space position
    out.positionVS.xyz =  (scn_node.modelViewTransform * in_position).xyz;
    // far clip : OPTIM : we should store it in uniform (SceneBuffer) and access it in the fragment shader
    // for now compute it based on the projection matrix
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    out.positionVS.w = d / (1.f + c);
    
    // Tangent basis vectors
    out.normalVS = scn::mat4_mult_float3_normalized(scn_node.normalTransform, in.normal);
#ifdef USE_NORMAL_MAP
    out.tangentVS = scn::mat4_mult_float3_normalized(scn_node.normalTransform, in.tangent.xyz);
    out.bitangentVS = /*_geometry.tangent.w **/ cross(out.tangentVS, out.normalVS); // no need to renormalize since tangent and normal should be orthogonal
#endif
    
    // texcoord
    // TODO : how to choose between the n texcoords without recompiling
    // swizzling?
    // i.e. : out.albedoTexCoord = uniforms.albedoSwizzle.x * in.texcoord0 + uniforms.albedoSwizzle.y * in.texcoord1 + uniforms.albedoSwizzle.x * in.texcoord2 + uniforms.albedoSwizzle.x * in.texcoord3;
    // this can be more efficient if we szizzle the 4 texcoords like XXXX, YYYY. then that would be two dots
    out.albedoTexcoord = in.texcoord0;
    out.normalTexcoord = in.texcoord0;
    out.emissionTexcoord = in.texcoord0;
    out.ambientTexcoord = in.texcoord0;
    
    out.albedoTexcoord     = scn_commonprofile_ds.diffuseTransform * float3(out.albedoTexcoord, 1.f);
    out.emissionTexcoord   = scn_commonprofile_ds.emissionTransform * float3(out.emissionTexcoord, 1.f);
    out.ambientTexcoord    = scn_commonprofile_ds.ambientTransform * float3(out.ambientTexcoord, 1.f);
    out.normalTexcoord     = scn_commonprofile_ds.normalTransform * float3(out.normalTexcoord, 1.f);
    
    return out;
static float3 ComputeAlbedo(texture2d<float> tex, sampler smp, float2 uv, constant commonprofile_uniforms_ds& uniforms)
    float3 albedo = tex.sample(smp, uv).rgb;
    // OPTIM intensity could be integrated in color -> always a mul
    albedo *= uniforms.diffuseIntensity.xyz; // in case of color, texture is white, otherwise color is white
    //    _surface.diffuse *= in.vertexColor;
    return albedo;
static float3 ComputeEmission(texture2d<float> tex, sampler smp, float2 uv, constant commonprofile_uniforms_ds& uniforms)
    float3 emission = tex.sample(smp, uv).rgb;
    // OPTIM intensity could be integrated in color -> always a mul -> depends on the property type. AO is mix to white...
    //    emission *= uniforms.emissionIntensity;
    emission *= uniforms.emissionIntensity.xyz; // in case of color, texture is white, otherwise color is white
    return emission;
static float ComputeAmbientOcclusion(texture2d<float> tex, sampler smp, float2 uv, constant commonprofile_uniforms_ds& uniforms)
    float ao = tex.sample(smp, uv).r; // in case of color, texture is white, otherwise color is white
    ao = mix(1.0, ao, uniforms.ambientIntensity);
    return ao;
// Fragment shader function
fragment FragmentOutput ds_default_frag(GBufferIO in [[stage_in]]
                                        , constant SCNSceneBuffer& scn_frame [[buffer(0)]]
                                        , constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(1)]]
                                        , texture2d<float> u_emissionTexture [[texture(0)]]
                                        , sampler          u_emissionTextureSampler [[sampler(0)]]
                                        , texture2d<float> u_ambientTexture [[texture(1)]]
                                        , sampler          u_ambientTextureSampler [[sampler(1)]]
                                        , texture2d<float> u_diffuseTexture [[texture(2)]]
                                        , sampler          u_diffuseTextureSampler [[sampler(2)]]
#ifdef USE_PBR
                                        , texturecube<float> u_irradianceTexture [[texture(8)]]
                                        , texturecube<float> u_radianceTexture [[texture(9)]]
#endif
                                        )
    // depth is stored linearly, normalized on far clip dimension [0..1]
    float depth = -in.positionVS.z / in.positionVS.w;
    
    SCNPBRSurface surface;
    // Albedo
    surface.albedo = ComputeAlbedo(u_diffuseTexture, u_diffuseTextureSampler, in.albedoTexcoord, scn_commonprofile_ds);
    // Ambient Occlusion
    surface.ao  = ComputeAmbientOcclusion(u_ambientTexture, u_ambientTextureSampler, in.ambientTexcoord, scn_commonprofile_ds);
    // Emission
    surface.emission = ComputeEmission(u_emissionTexture, u_emissionTextureSampler, in.emissionTexcoord, scn_commonprofile_ds);
    // Roughness
    surface.roughness = scn_commonprofile_ds.roughnessIntensity; // TODO sample map
    // Metalness
    surface.metalness = scn_commonprofile_ds.metalnessIntensity; // TODO sample map
    // Normal
    surface.N = in.normalVS;
    // Position
    // surface.position = in.positionVS.xyz;
    // View (Only needed if radiance available)
    surface.V = -normalize(in.positionVS.xyz);
    FragmentOutput output;
    output.lighting = AmbientContribution(surface, u_irradianceTexture, u_radianceTexture, scn_frame);
    output.albedo_roughness = float4(surface.albedo, surface.roughness);
    output.normal_depth = float4(surface.N, depth);       // normal+z
    output.xxxx = float4(in.positionVS.xyz, 1.); // debug viewPosition ???
    
    return output;
// NormalMap version
fragment FragmentOutput fragment_name(GBufferIO in [[stage_in]]
                                          , constant SCNSceneBuffer& scn_frame [[buffer(0)]]
                                          , constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(1)]]
                                          , texture2d<float> u_emissionTexture [[texture(0)]]
                                          , sampler          u_emissionTextureSampler [[sampler(0)]]
                                          , texture2d<float> u_ambientTexture [[texture(1)]]
                                          , sampler          u_ambientTextureSampler [[sampler(1)]]
                                          , texture2d<float> u_diffuseTexture [[texture(2)]]
                                          , sampler          u_diffuseTextureSampler [[sampler(2)]]
#ifdef USE_NORMAL_MAP
                                          , texture2d<float> u_normalTexture [[texture(7)]]
                                          , sampler          u_normalTextureSampler [[sampler(7)]]
#endif
#ifdef USE_PBR
                                          , texturecube<float> u_irradianceTexture [[texture(8)]]
                                          , texturecube<float> u_radianceTexture [[texture(9)]]
#endif
                                          )
    // depth is stored linearly, normalized on far clip dimension [0..1]
    float depth = -in.positionVS.z / in.positionVS.w;
    
    SCNPBRSurface surface;
    
    // Albedo
    surface.albedo = ComputeAlbedo(u_diffuseTexture, u_diffuseTextureSampler, in.albedoTexcoord, scn_commonprofile_ds);
    // Ambient Occlusion
    surface.ao  = ComputeAmbientOcclusion(u_ambientTexture, u_ambientTextureSampler, in.ambientTexcoord, scn_commonprofile_ds);
    // Emission
    surface.emission = ComputeEmission(u_emissionTexture, u_emissionTextureSampler, in.emissionTexcoord, scn_commonprofile_ds);
    // Roughness
    surface.roughness = scn_commonprofile_ds.roughnessIntensity; // TODO sample map
    // Metalness
    surface.metalness = scn_commonprofile_ds.metalnessIntensity; // TODO sample map
    // Position
    // surface.position = in.positionVS.xyz;
    // View (Only needed if radiance available)
    surface.v = -normalize(in.positionVS.xyz);
    // Normal
#ifdef USE_NORMAL_MAP
    float3 normal = u_normalTexture.sample(u_normalTextureSampler, in.normalTexcoord).rgb * 2. - 1.;
    normal = mix(float3(0., 0., 1.), normal, scn_commonprofile_ds.normalIntensity);
    // transform the normal in view space
    float3x3 tangentBasisTransform = float3x3(in.tangentVS, in.bitangentVS, in.normalVS);
    surface.n = normalize(tangentBasisTransform * normal);
#else
    surface.n = normalize(in.normalVS);
#endif
    
    FragmentOutput output;
    output.lighting = 0.0; //AmbientContribution(surface, u_irradianceTexture, u_radianceTexture, scn_frame, in.position);
    // TODO
    output.albedo_roughness = float4(surface.albedo, surface.roughness);
    output.normal_depth = float4(surface.n, depth);       // normal+z
    output.xxxx = float4(in.positionVS.xyz, 1.); // debug viewPosition ???
    return output;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2 offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    for(i=0;i<n_sample;i++){
        accum += texture2D(textureSampler0, TexCoord+offsets[i]) *  weights[i];
    }
gl_FragColor = accum;
#define USE_UBERSHADER !defined(C3D_TARGET_XCODE)
typedef struct __attribute__((__aligned__(256))) {
    // tone mapping
    float whitePoint;
    float averageLuminance;
    float minimumExposure;
    float maximumExposure;
    float exposureOffset;
    
    // exposure adaptation
    float exposureAdaptationDuration;
    float exposureAdaptationBrighteningSpeedFactor;
    float exposureAdaptationDarkeningSpeedFactor;
    
    float bloomThreshold;
    float bloomOffset;
    float bloomIntensity;
    float colorGradingIntensity;
    
    float vignettingPower;
    float vignettingIntensity;
    
    float fringeStrength;
    float fringeIntensity;
    
    float saturation;
    float contrast;
    
    float dt;
    uint32_t adaptationCurrentFrame;
    uint32_t adaptationFrameCount;
} scn_postprocess_uniforms_t;
typedef struct {
    float exposure;
    float averageLum;
} scn_postprocess_output_t;
#define MAX_PAIR_SAMPLE_COUNT 15u
typedef struct {
    vector_float3   offsets_weight[1 + MAX_PAIR_SAMPLE_COUNT];
} scn_bloom_uniforms_t;
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    },
    "SceneKit_applyDeferredShadows" : {
      "outputs" : {
        "color" : "COLOR"
      },
      "inputs" : {
        "light_MVP" : "C3D-light_MVP-symbol",
        "depthSampler" : {
          "target" : "DEPTH",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_kernel" : "C3D-shadowKernel-symbol",
        "lightDepthSampler" : {
          "target" : "SceneKit-spotShadowDepth",
          "sampler" : {
            "wrapS" : "clamp",
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest",
            "wrapT" : "clamp"
          }
        },
        "shadowColor" : "C3D-shadowColor-symbol",
        "colorSampler" : "COLOR",
        "camera_MVP_i" : "C3D-camera_MVP_i-symbol",
        "u_lightPos" : "C3D-u_lightPos-symbol",
        "u_lightDir" : "C3D-u_lightDir-symbol",
        "shadowRadius" : "C3D-shadowRadius-symbol",
        "u_lightSpotAtt" : "C3D-u_lightSpotAtt-symbol"
      },
      "metalFragmentShader" : "shadowMap_frag",
      "draw" : "DRAW_QUAD",
      "clientProgram" : false,
      "metalVertexShader" : "shadowMap_vert"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight",
    "SceneKit_applyDeferredShadows"
  ],
  "symbols" : {
    "C3D-u_lightSpotAtt-symbol" : {
      "type" : "vec3"
    },
    "C3D-shadowColor-symbol" : {
      "type" : "vec4"
    },
    "C3D-light_MVP_i-symbol" : {
      "type" : "mat4"
    },
    "C3D-camera_MVP_i-symbol" : {
      "type" : "mat4"
    },
    "C3D-u_lightPos-symbol" : {
      "type" : "vec3"
    },
    "C3D-zMapFactor-symbol" : {
      "type" : "float"
    },
    "C3D-light_MVP-symbol" : {
      "type" : "mat4"
    },
    "C3D-shadowRadius-symbol" : {
      "type" : "float"
    },
    "C3D-shadowKernel-symbol" : {
      "type" : "vec4[128]"
    },
    "C3D-u_lightDir-symbol" : {
      "type" : "vec3"
    }
  },
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "type" : "depth"
    }
#include <metal_stdlib>
using namespace metal;
#import "scn_metal"
struct scn_motionblur_io_t {
    float4 position [[position]];
    float2 texCoord; // [0, 1]
    float2 uv;       // [-1, 1]
struct scn_motionblur_uniforms_t {
    float4x4 u_viewProjectionInverseTransform;
    float4x4 u_oldViewProjectionTransform;
    float intensity;
vertex scn_motionblur_io_t scn_motionblur_vert(uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    scn_motionblur_io_t out;
    out.position = in_position;
    out.texCoord = in_position.xy * float2(0.5f, -0.5f) + 0.5f;
    out.uv.x = in_position.x;
    out.uv.y = in_position.y;
    
    return out;
fragment half2 scn_motionblur_compute_velocity(scn_motionblur_io_t                 in          [[ stage_in ]],
                                                depth2d<float>                      depthBuffer [[ texture(0) ]],
                                                constant scn_motionblur_uniforms_t& uniform     [[ buffer(0) ]])
    constexpr sampler samp(filter::linear);
    
    // position on screen
    float4 currentPos = float4(in.uv, depthBuffer.sample(samp, in.texCoord), 1.);
    
    // world position
    float4 worldPos = uniform.u_viewProjectionInverseTransform * currentPos;
    worldPos /= worldPos.w;
    
    // world position [for previous frame]
    float4 oldPos = uniform.u_oldViewProjectionTransform * worldPos;
    oldPos /= oldPos.w;
    
    // velocity
    float2 velocity = currentPos.xy - oldPos.xy;
    velocity.y = -velocity.y;
    
    return half2(velocity);
fragment float4 scn_motionblur_blur_6samples(scn_motionblur_io_t                 in             [[ stage_in ]],
                                             texture2d<float>                    colorBuffer    [[ texture(0) ]],
                                             texture2d<float>                    velocityBuffer [[ texture(1) ]],
                                             constant scn_motionblur_uniforms_t& uniform        [[ buffer(0) ]])
    constexpr sampler samp(filter::linear);
    
    float2 dir = velocityBuffer.sample(samp, in.texCoord).rg;
    
    float2 delta = dir / 6.0f * uniform.intensity;
    
    float4 col = 0.0f;
    for (int i = 0; i < 6; i++) {
        col += colorBuffer.sample(samp, in.texCoord + delta * (float(i) - 2.5));
    }
    col /= 6.0f;
    
    return col;
fragment float4 scn_motionblur_blur_12samples(scn_motionblur_io_t                 in             [[ stage_in ]],
                                              texture2d<float>                    colorBuffer    [[ texture(0) ]],
                                              texture2d<float>                    velocityBuffer [[ texture(1) ]],
                                              constant scn_motionblur_uniforms_t& uniform        [[ buffer(0) ]])
    constexpr sampler samp(filter::linear);
    
    float2 dir = velocityBuffer.sample(samp, in.texCoord).rg;
    
    float2 delta = dir / 12.0f * uniform.intensity;
    
    float4 col = 0.0f;
    for (int i = 0; i < 12; i++) {
        col += colorBuffer.sample(samp, in.texCoord + delta * (float(i) - 5.5));
    }
    col /= 12.0f;
    
    return col;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
// I/O struct:
typedef struct {
    float4 position [[position]];
    float4 color;
} directmesh_io;
struct blendAuthoring_io {
    float4 position [[position]];
    float2 texCoord;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Blend authoring
vertex blendAuthoring_io blendAuthoring_vert( uint v_id [[ vertex_id ]] )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    blendAuthoring_io out;
    out.position = in_position;
    out.texCoord = (in_position.xy + 1.0) * 0.5;
    out.texCoord.y = 1.0 - out.texCoord.y;
    
    return out;
fragment float4 blendAuthoring_frag( blendAuthoring_io in [[stage_in]],
                             texture2d<float> sceneColor [[texture(0)]],
                             texture2d<float> authoringColor [[texture(1)]],
                             depth2d<float> sceneDepth [[texture(2)]],
                             depth2d<float> authoringDepth [[texture(3)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    
    float4 scene = sceneColor.sample(samp, uv);
    float4 authoring = authoringColor.sample(samp, uv);
    
    float scene_depth = sceneDepth.sample(samp, uv);
    float authoring_depth = authoringDepth.sample(samp, uv);
    
    if(scene_depth < authoring_depth){
        authoring.rgb *= 0.75;
    }
    
    return mix(scene, authoring, authoring.a);
    
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Color Only
// Vertex shader function
typedef struct
    float4x4 modelViewProjectionTransform;
    float4 color;
} directmesh_vertex_uniforms_t;
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
    float4 color [[attribute(SCNVertexSemanticColor)]];
} directmesh_vertex_color_t; // __attribute__((scn_per_frame));
vertex directmesh_io ManipulatorColorOnly_vert(directmesh_vertex_color_t in [[ stage_in ]],
                                               constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                               constant directmesh_vertex_uniforms_t& myUniform [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    directmesh_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    out.color.rgba = in.color;
    return out;
// Fragment shader function
fragment half4 ManipulatorColorOnly_frag(directmesh_io in [[stage_in]])
    return half4(in.color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Color and Texture
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
    float4 color [[attribute(SCNVertexSemanticColor)]];
    float2 uv [[attribute(SCNVertexSemanticTexcoord0)]];
} directmesh_vertex_color_uv_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 color;
    float2 uv;
} directmesh_uv_io;
vertex directmesh_uv_io ManipulatorColorAndTexture_vert(directmesh_vertex_color_uv_t in [[ stage_in ]],
                                                     constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                                     constant directmesh_vertex_uniforms_t& myUniform [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    directmesh_uv_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    out.color.rgba = in.color;
    out.uv = in.uv;
    return out;
// Fragment shader function
//fragment half4 ManipulatorColorAndTexture_frag(directmesh_io in [[stage_in]])
//    return half4(in.color);
fragment half4 ManipulatorColorAndTexture_frag(directmesh_uv_io in [[stage_in]],
                                    texture2d<float> tex [[texture(0)]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float4 color = tex.sample(linear_sampler, in.uv) * in.color;
    //    color.rgb = in.texcoord * 0.5 + 0.5;
    return half4(color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vertex Only
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
} directmesh_vertex_t; // __attribute__((scn_per_frame));
vertex directmesh_io Manipulator_vert(directmesh_vertex_t in [[ stage_in ]],
                                      constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                      constant directmesh_vertex_uniforms_t& myUniform [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    directmesh_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    out.color.rgba = myUniform.color;
    return out;
// Fragment shader function
fragment half4 Manipulator_frag(directmesh_io in [[stage_in]])
    return half4(in.color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// WireFrame
// Vertex shader function
typedef struct
    float4x4 modelViewProjectionTransform;
    float4 color;
} wireframe_vertex_uniforms_t;
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
} wireframe_vertex_color_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float3 center;
} wireframe_io;
vertex wireframe_io ManipulatorWireframe_vert(
                                              uint v_id [[ vertex_id ]],
                                              directmesh_vertex_color_t in [[ stage_in ]],
                                               constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                               constant wireframe_vertex_uniforms_t& myUniform [[buffer(1)]]
                                              )
    float4 in_position = float4(in.position, 1.0);
    
    wireframe_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    int id = v_id % 3;
    float s = 1;
    float3x3 centers = float3x3(float3(s, 0 ,0), float3(0, s, 0), float3(0, 0, s));
    out.center = centers[id];
    return out;
// Fragment shader function
float3 smooth(float3 edge0, float3 edge1, float3 x);
float3 smooth(float3 edge0, float3 edge1, float3 x)
    float3 t = clamp((x - edge0)/(edge1 - edge0), float3(0.), float3(1));
    return t * t * (3 - 2 * t);
fragment half4 ManipulatorWireframe_frag(wireframe_io in [[stage_in]],
                                         constant wireframe_vertex_uniforms_t& myUniform [[buffer(1)]]
                                         )
    float3 d = fwidth(in.center);
    float3 a3 = smooth(float3(0.0), d * 1.5, in.center);
//    float3 a3 = smoothstep(float3(0.0), d * 1.5, in.center);
    float edge =  min(min(a3.x, a3.y), a3.z);
    
    return half4(myUniform.color * (1.0 - edge) * 0.95);
// vertex data
attribute vec2 a_texCoord1; // x:cornerX y:cornerY
// instance data
attribute vec4 a_position; // xyz: position, w:angle
attribute vec3 a_texCoord0; // x:life y:size z:frame (texture animation)
attribute vec4 a_color; // particle color
#ifdef ENABLE_STRETCH
attribute vec4 a_texCoord2; // velocity of the particle in .xyz
uniform float u_stretchFactor;
#elif defined(ENABLE_ORIENTATION_FREE)
attribute vec4 a_texCoord2; // orientation in free mode as an axis angle
mat3 axisangle_to_matrix(vec4 axis_angle)
float c = cos(axis_angle.w);
    float s = sin(axis_angle.w);
    float t = 1. - c;
    
    mat3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
#endif
#ifdef ENABLE_FOG
uniform mediump vec4 u_fogColor;
uniform vec3 u_fogParameters; // x:-1/(end-start) y:1-start*x z:exp
#endif
#ifdef ENABLE_SOFT
varying float v_eyeLinearZ;
#endif
#ifdef ENABLE_CUBE_MAP
uniform mat4 u_viewToCubeWorld;
varying vec4 v_normal;
#endif
#ifdef ENABLE_ANIMATION
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
uniform vec4 u_frameSize; // 1/dimX, 1/dimY, dimX, dimX*dimY
// modf Only available for CoreProfile & GLES 3.0
float __modf(float value, out float intValue)
float fracValue = fract(value);
intValue = value - fracValue;
return fracValue;
vec4 ComputeUVS(vec2 iNormUV, float iFrame)
vec4 outUV;
#if ENABLE_ANIMATION == CLAMP
    
    iFrame = clamp(iFrame, 0., u_frameSize.w - 1.); // clamp frame
    
    float intFrame;
    float frameFrac = __modf(iFrame, intFrame);
    vec2 frame;
    frame.x = __modf(intFrame * u_frameSize.x, frame.y);
    frame.y *= u_frameSize.y;
    
    outUV.xy = frame + iNormUV * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = ((frame.x + u_frameSize.x) == 1.)?1.:0.; // next row or not
#elif ENABLE_ANIMATION == REPEAT
    
    float tmp = iFrame * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; // next row or not
#else // AUTOREVERSE
    
    float invFrameCount = u_frameSize.x * u_frameSize.y;
    float normFrame = iFrame * invFrameCount;
    float lastFrame = u_frameSize.w - 1.;
    float frameIndex = fract(normFrame) * u_frameSize.w;
    if (fract(normFrame * 0.5) > 0.5) {
        frameIndex = (lastFrame-frameIndex);
    }
    frameIndex = clamp(frameIndex, 0., lastFrame); // clamp frame
    
    float tmp = frameIndex * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; // next row or not
#endif
return outUV;
#endif
uniform mat4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
uniform mat4 u_projectionTransform;
#ifdef ENABLE_LIGHTING
// lighting
uniform vec3 u_lightPosition0; // in modelViewSpace already
uniform vec4 u_lightColor0;
#endif
#ifdef ENABLE_COLOR_RAMP
uniform sampler2D u_colorRamp;
#endif
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
varying vec4 v_vertexColor;
void main()
    // transform the particle in view space
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
#ifdef ENABLE_STRETCH
    // compute the trail direction in viewSpace
    vec4 viewDir = viewTransform * vec4(a_texCoord2.xyz, 0);
    viewDir *= u_stretchFactor;
    
    // move the top vertices to the end of the trail
    viewPos.xyz += (a_texCoord1.y > 0.) ? viewDir.xyz : vec3(0.);
    
    // compute the billboarding offsets
//    float len = length(viewDir.xy);
//    vec2 u = (len > 0.) ? viewDir.xy/len : vec2(0,1);
    vec2 u = normalize(viewDir.xy); // divide by 0 seems to work.. otherwise replace by code commented beneath
    vec2 r = vec2(-u.y, u.x);
    vec2 off = r * a_texCoord1.x + u * a_texCoord1.y ; // offset
    viewPos.xy += off * a_texCoord0.y; // * size
    vec3 N = normalize(vec3(-off.x, -off.y, -2));
    
#else // ENABLE_STRETCH
    
    // TODO only rotate if needed (angle != 0)
    float sn = sin(a_position.w);
    float cs = cos(a_position.w);
    // expand the quad corners
    vec2 dir = vec2( a_texCoord1.x * cs - a_texCoord1.y * sn,  a_texCoord1.y * cs + a_texCoord1.x * sn);
    dir *= a_texCoord0.y;
#ifdef ENABLE_ORIENTATION_FREE
    // TODO : we should work in world space then ? the transform is in worldSpace or localSpace...
    // TODO with version 120 we would not need this....
    mat3 vt = mat3(viewTransform[0].xyz, viewTransform[1].xyz, viewTransform[2].xyz);
    mat3 mat = vt * axisangle_to_matrix(a_texCoord2); // mat3(viewTransform)
    
#ifdef ENABLE_CUBE_MAP
    vec3 N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
    viewPos.xy += dir;
#else
    vec3 off = mat[0] * dir.x + mat[1] * dir.y;
    viewPos.xyz += off;
#endif
    // TODO we should also tranform the normal for the lighting !!!!!
    
#elif defined(ENABLE_BILLBOARD_VIEW)
    vec3 u = vec3(0,1,0);
    vec3 r = normalize(cross(u, -viewPos.xyz));
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
#elif defined(ENABLE_BILLBOARD_Y)
    vec3 u = (viewTransform * vec4(0, 1, 0, 0)).xyz;
    vec3 r = normalize(cross(u, vec3(0,0,1))); // Screen Aligned
//    vec3 r = normalize(cross(u, -viewPos.xyz)); // ViewAligned
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
    
#else // defined(ENABLE_BILLBOARD_SCREEN)
    viewPos.xy += dir;
    vec3 N = normalize(vec3(-dir.x, -dir.y, -2));
    
#endif // ENABLE_ORIENTATION_FREE
#endif // ENABLE_STRETCH
#ifdef ENABLE_CUBE_MAP
#ifdef ENABLE_ORIENTATION_FREE
    v_normal.xyz = N;
#else
    vec3 refl = reflect( viewPos.xyz, N );
    v_normal.xyz = mat3(u_viewToCubeWorld) * refl;
#endif // ENABLE_ORIENTATION_FREE
#endif
#ifdef ENABLE_COLOR_RAMP
    v_vertexColor = a_color * texture2D(u_colorRamp, a_texCoord0.xx);
#else // use vertex color (TODO : use constant color if needed)
    v_vertexColor = a_color;
#endif
    
#ifndef ENABLE_BLACKPASS
#ifdef ENABLE_LIGHTING
    vec3 L = normalize(viewPos.xyz - u_lightPosition0);
#if defined(ENABLE_ORIENTATION_FREE) && !defined(ENABLE_CUBE_MAP)
    // if we want to bend the normal (but free orientation doesn't need too right ?)
    // vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? -normalize(-mat[2] + 0.1 * off) : -normalize(mat[2] + 0.1 * off);
//    vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? mat[2] : -mat[2];
    vec3 N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
    // simple lambertian + back light diffusion
    float NdotL = dot(N, L);
//    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * max(0., -NdotL));
    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
    // Specular
    float _shininess = 100.0;
    vec3 halfVector = normalize(L + viewPos.xyz);
    float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
    v_vertexColor.rgb *= diff;
    v_vertexColor.rgb += spec;
#else
    // simple lambertian
    vec3 diff = vec3(max(0.0, dot(N, L))) * u_lightColor0.rgb;
    // trilight model (lambertian + wrap around + hemispheric)
    //vec3 diff = lightColor0 * max(0., NdotL) + lightColor1 * (1. - abs(NdotL)) + lightColor2 * max(0., -NdotL);
    // todo : support ambient !!!!!!!!!!
    // diff += vec3(0.5);
    
    v_vertexColor.rgb *= diff;
#endif // ENABLE_ORIENTATION_FREE
#endif // ENABLE_LIGHTING
#endif // ENABLE_BLACKPASS
    // TexCoord
#ifdef ENABLE_ANIMATION
    vec4 animUVS = ComputeUVS(a_texCoord1.xy * vec2(0.5, -0.5) + 0.5, a_texCoord0.z);
    v_uv0 = animUVS.xyw;
    v_uv1 = animUVS.xy + u_frameSize.xy * vec2(1.0, animUVS.z);
#else
    v_uv0 = a_texCoord1.xy * vec2(0.5, -0.5) + 0.5;
#endif
    
#ifndef ENABLE_BLACKPASS
    #ifdef ENABLE_FOG
        float fogFactor = pow(clamp(viewPos.z * u_fogParameters.x + u_fogParameters.y, 0.0, u_fogColor.a), u_fogParameters.z);
        #ifdef ENABLE_CUBE_MAP
            v_normal.a = fogFactor;
        #else
            // vertex color is alpha premultiplied, but not the fogcolor
            v_vertexColor.rgb = mix(v_vertexColor.rgb, u_fogColor.rgb * v_vertexColor.a, fogFactor);
        #endif // ENABLE_CUBE_MAP
    #endif // ENABLE_FOG
#endif // ENABLE_BLACKPASS
#ifdef ENABLE_SOFT
    v_eyeLinearZ = viewPos.z;
#endif
    
    gl_Position = u_projectionTransform * viewPos;
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    //Sobel
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    //texels[4] = texture2D(pickedColorBuffer, uv + vec2(                0., 0.)).r;
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    //A little hack for multi-objects selection
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    //Get min depth around 5x5 pixels
    float depth = 1.;
    for(int i=-2; i<3; i++)
    for(int j=-2; j<3; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    //Outline color
    vec3 outline = vec3(1.,.6,.2);
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), .25);
    else
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), min(magnitude/4.,1.) );
// In model space, must stay in it
struct SCNShaderGeometry
vec4 position;
vec3 normal;
vec4 tangent;
vec4 color;
vec2 texcoords[8]; // MAX_UV
} _geometry;
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    //Sobel
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    //texels[4] = texture2D(pickedColorBuffer, uv + vec2(                0., 0.)).r;
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    //A little hack for multi-objects selection
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    //Get min depth around 5x5 pixels
    float depth = 1.;
    for(int i=-2; i<3; i++)
    for(int j=-2; j<3; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    //Outline color
    vec3 outline = vec3(1.,.6,.2);
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = vec4(outline, .25);
    else
        gl_FragColor = vec4(outline, min(magnitude/4.,1.) );
    
// blend factors {One, InverseSourceAlpha}
uniform sampler2D u_textureSampler0;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main(){
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
    tex.rgb *= tex.a; // this premultiplied could be done upfront?
    
    vec4 col = v_vertexColor * tex;
gl_FragColor = vec4(col);
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
//------------------------------------------------------
// Global input output interface
//------------------------------------------------------
struct ColorGrading_io {
    float4 position [[position]];
    float2 uv; // 0..1
//------------------------------------------------------
// Vertex shaders
//------------------------------------------------------
vertex ColorGrading_io ColorGrading_vert( uint v_id [[ vertex_id ]] )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    ColorGrading_io out;
    out.position = in_position;
    out.uv = in_position.xy * float2(.5, -.5) + float2( .5 );
    
    return out;
//------------------------------------------------------
// Fragment shaders
//------------------------------------------------------
fragment float4 ColorGrading_frag( ColorGrading_io in [[stage_in]],
                             texture2d<float> colorBuffer [[texture(0)]],
                             texture2d<float> LUT [[texture(1)]] )
    constexpr sampler samp(filter::linear);
    
    
    //Tmp code with texture 2D LUT
    const float sliceSize = 1.0 / 16.;
    const float slicePixelSize = sliceSize / 16.;
    const float sliceInnerSize = slicePixelSize * (16. - 1.0);
    
    float4 col = colorBuffer.sample(samp, in.uv);
    
    float offset = floor(col.b*16.);
    float delta  = fract(col.b*16.);
    float3 a = LUT.sample(samp, float2( col.r * sliceInnerSize + min(offset   ,15.)*sliceSize + .5*slicePixelSize, col.g + .5*slicePixelSize) ).rgb;
    float3 b = LUT.sample(samp, float2( col.r * sliceInnerSize + min(offset+1.,15.)*sliceSize + .5*slicePixelSize, col.g + .5*slicePixelSize) ).rgb;
    
    col.rgb = mix( a, b, float3(delta) );
    
    
    //Final code with texture 3D LUT
    // col.rgb = LUT.sample(samp, col.rgb);
    
    
    return col;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
attribute vec2 a_texCoord0;
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
    v_texCoord = a_texCoord0;
normalTexcoord
tangent
ambientTexcoord
diffuseTexcoord
specularTexcoord
emissionTexcoord
multiplyTexcoord
transparentTexcoord
fresnel
_surface.%@
u_%@Texture
_geometry.normal
_geometry.tangent
_geometry.color
C3DShaderModifier
<C3DShaderModifierRef>
USE_EMISSIVETEXCOORD
USE_AMBIENTTEXCOORD
USE_DIFFUSETEXCOORD
USE_SPECULARTEXCOORD
USE_REFLECTIVETEXCOORD
USE_TRANSPARENTTEXCOORD
USE_FILTERTEXCOORD
USE_NORMALTEXCOORD
USE_METALNESSTEXCOORD
USE_ROUGHNESSTEXCOORD
u_%@TextureMatrix
{CATransform3D=dddddddddddddddd}
{CGRect={CGPoint=dd}{CGSize=dd}}
is%@%@
v@:^v
^v@:
v@:f
v@:i
v@:B
v@:c
v@:d
v@:{CGPoint=ff}
{CGPoint=ff}@:
v@:{SCNVector3=fff}
{SCNVector3=fff}@:
v@:{SCNVector4=ffff}
{SCNVector4=ffff}@:
v@:{SCNMatrix4=ffffffffffffffff}
{SCNMatrix4=ffffffffffffffff}@:
v@:{CATransform3D=ffffffffffffffff}
{CATransform3D=ffffffffffffffff}@:
v@:{C3DMatrix3x3=fffffffff}
{C3DMatrix3x3=fffffffff}@:
v@:{C3DColor4=ffff}
{C3DColor4=ffff}@:
v@:s
v@:C
v@:S
#pragma opaque
#pragma transparent
#pragma declaration
#pragma arguments
#pragma body
C3DConstraintController
<C3DConstraintController>
C3DConstraintLookAt
<C3DConstraintLookAt>
C3DConstraintBillboard
<C3DConstraintBillboard>
C3DConstraintConstantScale
<C3DConstraintConstantScale>
C3DConstraintProcedural
<C3DConstraintProcedural>
C3DConstraintIK
<C3DConstraintIK>
wheel
C3DConstraintManager
<C3DConstraintManagerRef>
__controller
superClass
C3DModelTarget
<C3DModelTarget>
C3DModelValueStorageItem
<C3DModelValueStorageItem %p>
C3DModelValueStorage
<C3DModelValueStorage>
freeAxes
TQ,N,V_freeAxes
v36@?0^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__CFString}{?=^?^?}fB}8^v16^{__C3DModelTarget={__CFRuntimeBase=Q[4C]I}^v^vss^?^?^?}24f32
joint
T@"SCNNode",W,N,Vjoint
maxAllowedRotationAngle
Td,N,VmaxAllowedRotationAngle
node%d
angle%d
ikTarget
[%.1f,%.1f,%.1f %.1f,%.1f,%.1f]
[infinite box]
computeVelocity
C3D-MotionBlur-Intensity-symbol
C3D-viewProjectionInverseTransform-symbol
C3D-oldViewProjectionTransform-symbol
rnm-symbol
SceneKit_renderDepth
SceneKit_blurSSAOH
SceneKit_blurSSAOV
SceneKit_computeSSAO
--DepthAndNormalMaterial--
#pragma body
_output.color.rgb = _surface.normal.xyz * 0.5 + 0.5;
ssaoParams
ds_default_vert_N
ds_default_frag_N
ds_default_vert
ds_default_frag
C3DAnimationEvents
<C3DAnimationEvents>
FreeList: (count:%d) (maxSpan:%d)
[%d:%d[ 
C3DRendererElementStore
<C3DRendererElementStore %p>
C3DIndexStore
<C3DIndexStore>
C3DAllocator
<C3DAllocator>
C3DAnimatableParamController
<C3DAnimatableParamController>
_timesToRepeat
_timesRepeated
_repeatedAction
Nil Action
Action to be repeated must be non-nil
_forever
C3DFXMetalProgram
<C3DFXMetalProgram %p [%@]>
T@?,C,N,V_block
frequency
Tq,N,V_frequency
T@"NSString",C,N,V_semantic
T@"NSDictionary",&,N,V_options
SCNProgramDidChangeNotification
parameter
semanticInfos
draw
ignoreFloors
onlyShadowCasters
onlyMovableNodes
hasConstantAlpha
installViewport
includeCategoryMask
excludeCategoryMask
samples
colorStates
clearColor
sceneBackground
clear
depthStates
enableWrite
enableRead
func
stencilStates
enable
behavior
backFaceBehavior
blendStates
C3DFXPassInput
<C3DFXPassInput %@>
symbolName
uniformName
C3DFXPass
<C3DFXPass %@>
nameToInput
draw_scene
draw_node
draw_nodes
draw_geometry
draw_quad
metal_custom
draw_none
custom
preDraw
preFX
preToneMap
postFX
front
cullNone
back
never
always
equal
notEqual
less
lessEqual
greater
greaterEqual
depthFail
fail
pass
readMask
writeMask
referenceValue
keep
zero
replace
increment
decrement
invert
incrementWrap
decrementWrap
colorSrc
colorDst
alphaSrc
alphaDst
colorOp
alphaOp
srcColor
oneMinusSrcColor
srcAlpha
oneMinusSrcAlpha
dstColor
oneMinusDstColor
dstAlpha
oneMinusDstAlpha
constantColor
oneMinusConstantColor
constantAlpha
oneMinusConstantAlpha
alphaSaturate
substract
reverseSubstract
mipmapped
scaleFactor
%fx%f
texture_rectangle
color0
color1
color2
color3
stencil
format
DEPTH
channel
modelViewProjectionTransform
modelViewTransform
normalTransform
modelViewProjectionInverseTransform
modelViewInverseTransform
modelInverseTransform
viewInverseTransform
projectionInverseTransform
normalInverseTransform
global
persistent
(1 - srcColor)
(1 - srcAlpha)
(1 - dstColor)
(1 - dstAlpha)
blendColor
(1 - blendColor)
blendAlpha
(1 - blendAlpha)
srcAlphaSat
C3DBlendStates
<C3DBlendStates %p targetCount:%d needsBlendColor:%d
  blend:%s col[(src * %@) %@ (dst * %@)] alpha[(src * %@) %@ (dst * %@)]
true
false
  blend:%s col[(src * %@) %@ (dst * %@)]
SCNShaderModifierEntryPointGeometry
SCNShaderModifierEntryPointSurface
SCNShaderModifierEntryPointFragment
SCNShaderModifierEntryPointLightingModel
v32@?0@"NSString"8@"SCNBufferBinding"16^B24
v24@?0i8^{__CFString=}12B20
owner
SCNShadableDidCompileNotificationName
issues
shadable
T@"<SCNShadable>",R,N,V_shadable
entryPoint
T@"NSString",R,N,V_entryPoint
effectiveModifier
T@"NSString",R,N,V_effectiveModifier
message
T@"NSString",R,N,V_message
TQ,R,N,V_type
C3DArray
<C3DArray %p:, %d objects>
<%@ | string=%@ extrusionDepth=%.3f> 
discretizedStraightLineMaxLength
useCustomContainerFrame
customContainerFrame
_wantsSeparateGeometryElements
T@"UIFont",&,N
T@"UIBezierPath",C,N
<%@ | path=%@ extrusionDepth=%.3f> 
ubyte
byte
invalid operation
invalid enum
invalid value
out of memory
invalid framebuffer operation
no error
unknown error
C3DCheckFramebufferStatus
C3DShape
<C3DShape '%@'>
C3DShapeGeometryValidate
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/sources/Core3DRuntime/Core/C3DShapeGeometry.m
CFGetTypeID(geometry) == C3DShapeGeometryGetTypeID()
C3DShapeGeometryMeshForBoundingBox
^{__C3DMesh=}8@?0
C3DShapeGeometryGetBoundingBox
C3DShapeGeometryGetBoundingSphere
C3DShapeGeometry
C3DTextGeometry
levelOfDetail <%p>: geometry:%@ threshold:%f useDistance:%d
mode
mat2x3
scn_frame.invScreenPixelSize
float2x3
btOptimizedBvhNodeData
btQuantizedBvhNodeData
btBvhSubtreeInfoData
btQuantizedBvhFloatData
btCollisionObjectFloatData
Overflow in AABB, object removed from simulation
If you can reproduce this, please email bugs@continuousphysics.com
Please include above information, your Platform, version of OS.
Thanks.
Triangle
btConvexInternalShapeData
Box2d
btTriangleMeshShapeData
BVHTRIANGLEMESH
CapsuleShape
btCapsuleShapeData
CapsuleX
CapsuleZ
btCollisionShapeData
btCompoundShapeChildData
btCompoundShapeData
Compound
Cone
btVector3FloatData
btConvexHullShapeData
Convex
ConvexTrimesh
CylinderY
btCylinderShapeData
CylinderX
CylinderZ
btPositionAndRadius
btMultiSphereShapeData
MultiSphere
SPHERE
STATICPLANE
btStaticPlaneShapeData
btIntIndexData
btShortIntIndexTripletData
btCharIndexTripletData
btVector3DoubleData
btMeshPartData
btStridingMeshInterfaceData
TRIANGLEMESH
btConeTwistConstraintData
btGeneric6DofConstraintData
btHingeConstraintFloatData
btPoint2PointConstraintFloatData
btSliderConstraintData
btTypedConstraintData
btDynamicsWorldFloatData
btRigidBodyFloatData
estimateAndAllocateChildValues
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/vtr/fvarRefinement.cpp
_refinement.isChildVertexComplete(cVert)
propagateValueTags
propagateValueCreases
_childFVar.hasSmoothBoundaries()
populateChildValuesForEdgeVertex
cVertFaces.size() == cVertFaceSiblings.size()
cVertFaces.size() >= cValueCount
populateChildValuesForVertexVertex
populateFaceVerticesFromParentFaces
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/vtr/triRefinement.cpp
pFaceVerts.size() == 3
pFaceChildren.size() == 4
populateFaceEdgesFromParentFaces
pFaceChildFaces.size() == 4
pFaceChildEdges.size() == 3
populateEdgeVerticesFromParentFaces
pFaceEdges.size() == 3
populateEdgeFacesFromParentFaces
populateVertexFacesFromParentEdges
markSparseFaceChildren
_parentFaceTag.size() > 0
fChildFaces.size() == 4
fChildEdges.size() == 3
Edge %d specified to be sharp does not exist (%d, %d)
Vertex %d specified to be sharp does not exist
MISSING_EDGE_FACES
MISSING_EDGE_VERTS
MISSING_FACE_EDGES
MISSING_FACE_VERTS
MISSING_VERT_FACES
MISSING_VERT_EDGES
FAILED_CORRELATION_EDGE_FACE
FAILED_CORRELATION_FACE_VERT
FAILED_CORRELATION_FACE_EDGE
FAILED_ORIENTATION_INCIDENT_EDGE
FAILED_ORIENTATION_INCIDENT_FACE
FAILED_ORIENTATION_INCIDENT_FACES_EDGES
DEGENERATE_EDGE
NON_MANIFOLD_EDGE
INVALID_CREASE_EDGE
INVALID_CREASE_VERT
getTopologyErrorString
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/vtr/level.cpp
%s - missing face-verts
%s - missing vert-faces
%s - face %d correlation of vert %d failed
%s - missing edge-faces
%s - missing face-edges
%s - face %d correlation of edge %d failed
%s - missing edge-verts
%s - missing vert-edges
%s - edge %d correlation of vert %d failed
%s - vertex %d cannot orient incident faces and edges
%s - vertex %d orientation failure at incident face %d
%s - vertex %d orientation failure at incident edge %d
%s - Error in eIndex = %d:  degenerate edge not tagged marked non-manifold
%s - edge %d with %d incident faces not tagged non-manifold
Level (0x%p):
  Depth = %d
    faces = %d
    edges = %d
    verts = %d
      face-vert counts/offset = %lu
      face-vert indices = %lu
        face %4d verts:  
      face-edge indices = %lu
        face %4d edges:  
      face tags = %lu
        face %4d:
  hole = %d
      face child-verts = %lu
      edge-vert indices = %lu
        edge %4d verts:  
      edge-face counts/offset = %lu
      edge-face indices       = %lu
      edge-face local-indices = %lu
        edge %4d faces:  
             face-edges:  
      edge child-verts = %lu
        edge %4d child vert:  %d
      edge sharpness = %lu
        edge %4d sharpness:  %f
      edge tags = %lu
        edge %4d:
  boundary = %d
, nonManifold = %d
, semiSharp = %d
, infSharp = %d
      vert-face counts/offset = %lu
      vert-face indices       = %lu
      vert-face local-indices = %lu
        vert %4d faces:  
             face-verts:  
      vert-edge counts/offset = %lu
      vert-edge indices       = %lu
      vert-edge local-indices = %lu
        vert %4d edges:  
             edge-verts:  
      vert child-verts = %lu
      vert sharpness = %lu
        vert %4d sharpness:  %f
      vert tags = %lu
        vert %4d:
  rule = %s
, boundary = %d
, corner = %d
, xordinary = %d
, semiSharpEdges = %d
gatherQuadLinearPatchPoints
(0 <= rotation) && (rotation < 4)
gatherQuadRegularInteriorPatchPoints
gatherQuadRegularBoundaryPatchPoints
(boundaryFaceInV0Faces >= 0) && (boundaryFaceInV1Faces >= 0)
gatherQuadRegularCornerPatchPoints
cornerFaceInIntVertFaces >= 0
completeTopologyFromFaceVertices
(vCount > 0) && (fCount > 0) && (eCount == 0)
_maxValence > 0
orderVertexFacesAndEdges
eCountOrdered == eCount
fCountOrdered == fCount
<uninitialized>
Smooth
Dart
Crease
Corner
ruleString
%d [%d
FindIndexIn4Tuple
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/vtr/../vtr/array.h
_size>=4
"FindIndexIn4Tuple() did not find expected value!" == 0
  Primary component counts:
  Topology relation sizes:
    Face relations:
    Edge relations:
    Vert relations:
bilinear
catmark
loop
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no vertices.
Failure in TopologyRefinerFactory<>::Create() -- meshes without faces not yet supported.
Failure in TopologyRefinerFactory<>::Create() -- face with %d vertices > %d max.
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no face-vertices.
Failure in TopologyRefinerFactory<>::Create() -- non-triangular faces not supported by Loop scheme.
prepareComponentTopologySizing
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/far/topologyRefinerFactory.cpp
baseLevel.getNumFaceEdgesTotal() > 0
baseLevel.getNumEdgeVerticesTotal() > 0
baseLevel.getNumEdgeFacesTotal() > 0
baseLevel.getNumVertexFacesTotal() > 0
baseLevel.getNumVertexEdgesTotal() > 0
Failure in TopologyRefinerFactory<>::Create() -- vertex with valence %d > %d max.
Failure in TopologyRefinerFactory<>::Create() -- maximum valence not assigned.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected from partial specification.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected as fully specified.
Failure in TopologyRefinerFactory<>::Create() -- face-varying channel %d has no values.
initializeInventory
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/far/topologyRefiner.cpp
_levels.size() == 1
Failure in TopologyRefiner::RefineUniform() -- base level is uninitialized.
Failure in TopologyRefiner::RefineUniform() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- base level is uninitialized.
Failure in TopologyRefiner::RefineAdaptive() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- currently only supported for Catmark scheme.
Error:  invalid sibling %d for face-vert %d.%d = %d
Error:  unexpected value %d for sibling %d of face-vert %d.%d = %d (expecting %d)
Error:  invalid sibling %d at vert-face %d.%d
Error:  value mismatch between face-vert %d.%d and vert-face %d.%d (%d != %d)
    vertex count       = %d
    source value count = %d
    vertex value count = %d
    face%4d:  
verts =
,  values =
,  siblings =
    vert%4d:  vcount = %1d, voffset =%4d, 
values =
, crease =
, semi-sharp =
    edge%4d:  verts = [%4d%4d], discts = [%d,%d]
getVertexEdgeValues
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/vtr/fvarLevel.cpp
edgeTopologyMatches(eIndex)
getFaceCompositeValueTag
_vertValueIndices[srcValueIndex] == faceValues[i]
getFaceCompositeValueAndVTag
Error:  value/vertex-value count mismatch
Error:  face-value/face-vert count mismatch
Error:  edge count mismatch
Error:  vertex count mismatch
Face-varying data channel:
  Inventory:
  Face values:
  Vertex values:
  Edge discontinuities:
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/vtr/quadRefinement.cpp
_splitType == Sdc::SPLIT_TO_QUADS
Refinement
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/vtr/refinement.cpp
(childArg.getDepth() == 0) && (childArg.getNumVertices() == 0)
refine
_parent && _child
populateParentToChildMapping
"Unsupported empty sparse refinement detected in Refinement" == 0
  Face %d:
    Child vert:  %d
    Child faces: 
    Child edges: 
  Edge %d:
    Child edges: %d %d
  Vert %d:
subdivideFVarChannels
_child->_fvarChannels.size() == 0
this->_fvarChannels.size() == 0
markSparseVertexChildren
_parentVertexTag.size() > 0
markSparseEdgeChildren
_parentEdgeTag.size() > 0
Parent-to-child component mapping:
No Error
Fatal Error
Coding Error (internal)
Coding Error
Error
/BuildRoot/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-386.11/lib/libOsd/sources/opensubdiv/far/error.cpp
err!=FAR_NO_ERROR
%s: %s
Warning: %s
Error: C3DMeshCreateTextFrame: C3DTextFrameRef object is NULL, will create NULL mesh
Error: failed to load %@ - unknown file format.
Error: COLLADA files are not supported on this platform.
Error: no file found at URL %@
Error: bad float x %f
Error: ParticleSystem: mismatch in meshes and meshElements
Error: Color deserialize: could not read the float array
Error: Color deserialize: no color or no deserialized data
Error: Geometry deserialization: cannot find the mesh ID
Error: Geometry deserialization: cannot find the specified mesh
Error: Geometry deserialization: cannot find the specified material
Warning: _C3DGeometryFinalizeDeserialization - material ID of 0 is unexpected
Error: cannot generate points : mismatch between vertices and normals count
Error: Cannot use volume generation on a generic mesh. fallbacking on surface
Error: Could not deserialize the property %@ in the serialized effect %@
Error: C3DImageToMDLTexture not supported for image 3D
Warning: Failed to create cubemap from Model I/O texture
Error: unknown MKGeometryType
Error: a MDLObject has more than 1 child mesh - not supported
Error: failed to find MKMaterial corresponding SCNMaterial
Error: C3DMeshElementCreateByMergingElements - strip not supported
Error: C3DMeshElementCreateByMergingElements - merging elements with different byte per index
Error: C3DMeshElementGetIndexCount:primitive type not handled
Error: Mesh element deserialization: no faces count
Error: Mesh element deserialization: no mesh element type
Error: Mesh element deserialization: no bytes per index
Error: Could not read the indexes
Error: Mesh element deserialization: no serialized indices
Warning: Unknown mesh element type %@, assuming triangles array.
Error: __C3DMeshElementBuildRenderableTopology - Invalid polygon edge count (%u)
Error: Inconsistent index count after triangulation.
Warning: unlock not locked ressource
Error: C3DMeshSubdivide inconsistency
Warning: try to preload a geometry with no mesh
Error: WARNING: NULL data in mesh source (warming geometry)
Warning: %s is deprecated please use %s instead
Error: Cannot generate tangents without valid positions
Error: Cannot generate valid tangents without valid texture coordinates
Error: Cannot generate valid tangents without valid normals
Error: Cannot generate tangents without texture coordinates
Error: error in C3DMeshCreateTextureTangentsIfNeeded
Warning: Cannot create an interleaved copy, count mismatch
Error: Given sources must be of the same length for interval list creation
Warning: __MergeMeshSources unknown source type
Error: C3DSourceAccessorCopyDataToAccessor failed
Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons
Error: can't archive audio data directly
Error: C3DTriangle3BarycentricCoordinates fail
Error: C3DSurfacePositionWithBlinnApproximationOnMeshAtLocation inconsistency
Error: _C3DHitTestResultComputeSmoothedValues no node
Error: _C3DHitTestResultComputeSmoothedValues no mesh
Error: _C3DUnProjectPoints : invalid viewport dimension
Error: error in _C3DUnProjectPoints
Error: inconsistency in lru list
Error: inconsistency in lru list (2)
Error: C3DMatrix4x4MakePerspective_GL : bad fov Y
Error: C3DMatrix4x4MakePerspective_GL : bad fov X
Error: C3DMatrix4x4MakePerspective_MTL : bad fov Y
Error: C3DMatrix4x4MakePerspective_MTL : bad fov X
Error: C3DMatrix4x4MakeOrtho - bad projection info
Error: can't share a SCNPhysicsField is already attached to a SCNNode
Error: object %@ doesn't conform to the copying protocol
Error: Could not read a matrix (serializedData: %@)
Error: Could not read a transform, position, scale and rotation have to be present (serializedData: %@)
Error: Could not read the pivot (serializedData: %@)
Error: Could not read a quaternion
Error: Could not read Euler
Error: Could not read the axis angle
Error: Could not read a matrix
Error: No data present to deserialize a rotation (serialized data : %@)
Error: _updateQuaternionRotationIfNeeded: inconsistent transform
Error: didAddToPhysicsWorld - can't share a physics behavior to multiple world
Error: _edgeIndexInTriangle error: can't find edge
Error: _C3DChooseFirstTriangle error
Warning: Trying to draw a manipulator with no authoring environment set
Error: mismatch in the sources given
Error: MeshSource packing only supports non interleaved float sources
Error: Conversion from other types than float is not supported
Error: Conversion of an interleaved source is not supported, please convert your sources before interleaving
Error: C3DMeshSourceCreateCopyWithComponentsBaseType: unsupported type
Error: Conversion from %@ to %@ to is not supported
Warning: Unknown semantic %@
Error: no meshSource deserialize => semantic in mesh source
Error: _C3DMeshSourceCopyPropertyList unsupported semantic
Warning: fail to setup the animation - won't be added to the animation stack
Error: unable to resolve target keypath: %@(%@)
Error: unable to resolve source keypath: %@(%@)
Error: trying to bind two incompatible keypath: %@(%@) -> %@(%@)
Error: _resolveAnimationGroupTargets - can't find common ancessor
Error: C3DKeyframeControllerRef - index out of bounds
Warning: can't simplify keyframes because of cubic interpolation
Warning: can't simplify keyframes because of tcb values
Warning: can't simplify keyframes because of timing functions
Error: failed to deserialize animation data
Error: _C3DKeyframeControllerFlattenKeyframeData unexpected value
Error: _C3DKeyframeControllerCreateKeyframeArray unknown key type
Warning: _C3DKeyDistance - can't compute key distance for type %d
Error: C3DFXTechniqueAppendPass out of capacity
Error: C3DFXTechniqueSetValueForSymbol - expect an image for paramName %@
Error: C3DFXTechniqueSetValueForSymbol - unknown param named %@
Error: C3DFXTechniqueGetValueForSymbol - unknown param named %@
Error: invalue description for input named %@ - expect a dictionary
Error: C3DFXTechniqueCompile - invalid description (sequence missing or empty) %@
Info: pass named %@ appears to be useless - skipping
Error: C3DES2SlotToAttachmentID : unknown slot
Error: _C3DKeyframedAnimationInitWithPropertyList plist invalid
Error: can't set a property on the presentation instance %@ - ignoring
Error: %@ is deprecated
Error: attempt to add a null animation on %@
Error: _applyCIFilter can't fint render target named SceneKit-CI-nodetree-color
Warning: CIFilter should have been clipped by the culling
Warning: CIFilter should have been clipped by the culling (2)
Warning: changing the content of a physics shape is not expected
Info: Non triangle list element type not yet supported in physics shape generation
Error: vertex format not supported for physics shape creation (%d)
Warning: Cannot create convex hull for entity %@
Error: Compound shapes cannot be created without shapes
Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)
Error: Cannot build cubemap from array of images because image at index %d is NULL
Error: Cannot build cubemap from array of images because image at index %d is not square: %fx%f
Error: Cannot build cubemap from array of images because image at index %d (%fx%f) does not have the expected size (%zux%zu)
Error: Cannot build cubemap from array of images because conversion to CGImageRef of image at index %d failed
Error: Cannot build column cubemap from non-cubemap image
Warning: Failed to create bitmap context for CG image %@
Error: Unknown cubemap image type
Error: Cannot support rotation layout for compressed texture
Error: Unknown Texture3D image type
Error: failed to load image with description: %@
Error: _C3DImageCopyPropertyList error retrieving path
Error: Failed loading : %@
Error: unable to get a CGImageRef from image
Warning: While reading a texture sampler: could not read %@ (serializedData: %@), using the default value %d instead
Error: Could not serialize an integer
Warning: Character should already have a body
Warning: FPS:%f FrameTime:%f (%f/%f)
Warning: DC:%d (V:%d P:%d) Sw VBO:%d IBO:%d FBO:%d
Warning: KTX file seems too small or is not a KTX
Warning: KTX file seems to be corrupted or data is not a KTX
Error: Only big endian ktx are supported
Error: Only compressed ktx are supported
Error: Bad KTX format
Warning: Compression type %d not supported
Error: overflow reading mip %d (%d > %d)
Error: Position must be float3 to be subdivided. Actual type is %d
Error: C3DRendererContextSetupResidentMeshSourceAtLocation - double not supported
Error: C3DRendererContextSetupResidentMeshSourceAtLocation:not handling type, using float as default
Error: C3DRendererContextCreateProgramObjectForProgram : missing vertex shader
Error: C3DRendererContextCreateProgramObjectForProgram : missing fragment shader
Error: C3DRendererContextCreateProgramObjectForProgram metal program unsupported
Error: C3DRendererContextCreateProgramObjectForProgram unsupported program
Warning: Trying to delete an empty or already released VBO
Error: error in C3DRendererUpdateSubTextureWithImage : empty bitmap
Error: image copy did fail: %@
Error: C3DRendererContextSetupFramebuffer invoked twice on a Framebuffer
Warning: C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler: called with kC3DTextureUntype type should be resolved before calling it, using GL_TEXTURE_2D as fallback
Error: C3DLightingModelPhysicallyBased not supported by OpenGL renderer
Error: C3DRendererContextCreateBufferObjectForMeshSource - mesh source has no data
Error: C3DRendererContextBindMeshElement unsupported byte per index (%d)
Error: __FillProgramObjectLocations uniform index out of bounds
Error: Cannot load image %@.
Error: For best performance when using OpenGL, consider adding the `SCNDisableLinearSpaceRendering` key with a bool value of `YES` to your app's Info.plist
Error: C3DRendererCreateTextureWithImage : error while getting bitmap bytes
Error: _createTextureForRenderTarget - fbo size is zero
Error: _createRBOForRenderTargetDescription - fbo size is zero
Error: Max number of texture unit (%d) is reached - can't bind a new texture
Error: We do not handle property %d to get the program attribute enum for the texture (using default: diffuse)
Error: __CreateMeshElement unexpected byte per index
Error: ParticleSystem shaders missing : %@
Error: unsupported conversion %@ -> float4
Error: block unknown
Error: failed to locate scene reference %@
Error: failed to resolve referenced scene (%@) cycle detected
Error: referenced animations can't be resolved without a SCNAssetCatalog
Error: referenced actions can't be resolved without a SCNAssetCatalog
Error: C3DRectanglePackerReleaseRect can't find rect
Error: C3DRectanglePackerReleaseRect double free
Error: mergeNodesIfPossible inconsistency
Error: C3DResourceManagerMakeProgramResident failed to compile program - fallback on default program
Error: rendererContext is not tracked by the resource manager
Error: __ResourceManagerDeleteTexture: texture to be deleted not found, bail out
Error: _C3DResourceManagerDeleteTexture source does not match to any stored texture (no texture samplers associated)
Error: _C3DResourceManagerDeleteTexture can't find image source
Error: failed loading texture named %@ : %@
Error: failed to find a rect in packers
Error: cannot find packer address in packer list
Error: failed to create a new texture
Warning: Warning _lightNodes not NULL in C3DEnginePipelineSetup
Warning: C3DTriangle3BarycentricCoordinates: unable to solve the equation
Error: C3DES3SlotToAttachmentID : unknown slot
Error: C3DRendererContextSetValueUniformAtLocation not implemented for this type (%d) yet
Error: uniform has incorrect type
Error: C3DBaseTypeForCFNumberType: Type not supported
Error: C3DConvertToPlatformIndependentData - archiving pointers makes no sense
Error: C3DConvertToPlatformIndependentData - Type not supported
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to read
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to write
Error: C3DConvertFromPlatformIndependentData - Type not supported
Warning: C3DBaseTypeFromDescription - signed/unsigned ambiguity
Error: C3DBaseTypeFromDescription - Type not supported
Error: C3DBaseTypeRequires32to64bitConversion:: unknown type
Error: C3DAddBaseType - type %d can't be added
Error: C3DAddBaseType - addition of half float not supported
Error: C3DAddBaseType - unknown type
Error: C3DSubBaseType - type %d can't be substracted
Error: C3DSubBaseType - substraction of half float not supported
Error: C3DSubBaseType - unknown type
Error: C3DMultBaseTypeWithFloat - type %d can't be multiplied
Error: C3DMultBaseTypeWithFloat - multiply half float not supported
Error: C3DMultBaseTypeWithFloat - unknown type
Error: Conversion to C string failed
Error: C3DCopyRelativePathBetweenURLs , referenceURL and targetURL does not share common root path
Warning: C3DParseVersionNumber - No version found
Assert failed [comparisonDepth<=comparisonMaxCount]too many nested macros in shader
Error: failed to load resource named %@
Error: failed to load dictionary named %@
Error: failed to load json named %@
Error: failed to load json named %@ (reason: %@)
Error: Could not deserialize a number array (nil buffer or serialized data)
Error: Could not deserialize a number (%@) in a number array
Error: Could not deserialize a number array (unexpected type)
Warning: C3DBaseTypeFromString: unknown type name '%@'
Warning: operator incorreclty parsed : %@
Error: unsupported SH order
Error: SH order unsupported : %d
Error: SphericalHarmonics Order not supported : %d
Error: _buildTetrahedrons - failed with first tetrahedron
Error: tetrahedrisation: index out of bounds
Warning: %s will return default value (false) for property %d
Error: No function %@ in the common profile %@
Error: Could not deserialize the color %@
Error: C3DEffectCommonProfile DeserializeColor: No property for the key %@
Error: Common profile deserialization: could not read the property %@
Error: Common profile deserialization: property found for the key %@
Error: Could not deserialize the texture sampler %@
Error: Cannot find the specified image
Error: Cannot find the image ID for the key %@ in the dictionary %@
Error: orphan effect common profile detected
Warning: __OpacityFromColorSlot:unexpected transparency mode %d
Error: C3DMeshSourceAppendVector3 - Type not supported
Error: C3DMeshSourceAppendVector2 - Type not supported
Error: C3DMeshSourceAppendCopyOfElement - Type not supported
Error: C3DMeshSourceCreate: unsupported type
Error: C3DEdgeArrayAddEdge out of capacity
Error: C3DMeshElementEditorCreateWithMeshElement: mesh element is not a triangle array
Error: _C3DMeshElementEditorSetIndex unknown bytes per index
Error: C3DMeshElementEditorSplitTriangleAtIndex: triangleIndex out of bounds
Error: C3DMeshElementEditorSubdivideTriangleAtIndex: triangleIndex out of bounds
Error: set transform not implemented on %@
Error: set position not implemented on %@
Error: Index %ld out of range bounds [0...%ld]
Error: Index %ld out of bounds [0...%ld]
Error: unable to update the physics shape of %@
Warning: cannot change collision bit masks without physics world
Error: cannot apply force on a body that is not attached to a SCNNode
Error: cannot clear forces on a body that is not attached to a SCNNode
Error: cannot attach a body to a null node %p
Error: C3DSimpleAnimationEvaluate - invalid evaluation function
Error: _C3DSimpleAnimationInitWithPropertyList - no base type
Error: While deserializing a light: could not decode the number for the key %@ (serializedData : %@)
Error: While deserializing a light: no value for the key %@ (serializedData : %@)
Error: While deserializing a light: could not decode the color
Error: While deserializing a light: could not decode the shadowcolor
Info: invalid zNear value (0) set to camera
Info: loaded camera has an invalid zNear value (0)
Error: inconsistency in scene graph found in C3DNode finalize
Error: Could not read a node's transforms
Error: Node deserialization: cannot retrieve the object ID
Warning: Node<->attribute inconsistency finalizing deserialization
Error: Node deserialization: cannot retrieve the lightmap image ID
Error: Node deserialization: cannot retrieve the lightmap image
Warning: Mesh sources of redundant semantic %d  will be ignored in rendering
Error: Mesh deserialization: cannot find the sources in %@
Error: Mesh deserialization: cannot find the specified source
Error: Mesh deserialization: cannot deserialize a source
Error: Mesh deserialization: cannot init a mesh element
Error: C3DMeshCheckValidity - bad mesh found
Warning: Can't add two vertex sources
Warning: Can only convert from triangle array to another element type
Warning: Can only convert to lines or points element type
Error: Cannot find the specified primary source
Error: Cannot find the specified source
Error: Could not deserialize a source locator in %@
Error: __C3DMeshCopy - unable to resolve interleaved mesh
Warning: Could not deserialize an effect
Warning: C3DSceneSetRootNode - old root node seems to be already connected to another scene
Error: Could not read the animations manager
Error: C3DSceneRef _copySerializedHierarchy: lib entry not found
Warning: Some nodes failed to be deserialized
Error: ... and we do not even have a root node, so bailing out
Error: Scene deserialization : cannot finalize the deserialization of the animation manager
Error: Library could not remap the ID %@
Error: _deserializeHierarchy: could not find the specified node in the library
Error: _deserializeHierarchy: no nodeID specified!
Error: convexSweep only works with convex shapes
Warning: PhysicsWarn: %s
Error: failed to create a GL context
Warning: SCNCreateGLContext - failed to share our context with SpriteKit - fallback on a private context
Warning: wrong current context rc:%p current:%p
Warning: C3DMeshElementConvertToPolygonArrayIfNeeded can only process triangles
Error: bad float y %f
Error: bad float z %f
Error: bad float w %f
Warning: Should not register a node without light to the light system
Error: Node is already registered to the light system
Error: Invalid runtime light index
Error: Too many effective lights at once. Limit is %d
Warning: can't prepare shadable animation with path %@
Error: Material : %@ is not an animatable path
Error: referenced particle systems can't be resolved without a SCNAssetCatalog
Error: particle reference name is nil
Error: Can't introspect type of property %@
Error: unknown particle controller input mode
Error: error in removeFromParentNode : inconsistent tree
Error: removing the root node of a scene from its scene is not allowed
Error: Error: physicsBody %@ 's owner (%@) should be %@
Error: attempt to add a null particle system on %@
Error: attempt to add a null audio player on %@
Error: error while transposing skeleton or morph target
Error: error while transposing animations to cloned tree
Error: [SCNScene root] is deprecated, use rootNode instead
Warning: failed to load scene at %@
Error: SCNRenderer::init - no engine context
Warning: _deleteGLFramebuffer - No context!
Warning: _prepareGLRenderTarget - No context!
Error: Failed to bind EAGLDrawable: %@ to GL_RENDERBUFFER
Error: failed to create a framebuffer
Error: autoenablesDefaultLighting: renderer has no context
Error: setAutoenablesDefaultLighting: renderer has no context
Error: SCNRenderer::setTechnique - no engine available yet - ignoring
Error: prepareObject:shouldAbortBlock renderer has no GL context
Error: glError before rendering SceneKit contents: %x
Error: Light probe generation not supported without Metal support
Error: unknown light type %@
Error: SCNEncodeAnimations unknown animation: %@
Error: can't deserialize animation %@
Error: failed to deserialize animation %@
Error: SCNEncodeAnimations failed to encode animation: %@
Error: SCNEncodeAnimations unknown animation type: %@
Error: SCNDecodemage: invalid archive
Warning: CGPath archiving: unknown path element type
Warning: unable to infer the type of a basic animation: %@
Warning: unable to infer the type of a keyframed animation: %@
Error: SCNAnimationToCAAnimation: unsupported animation
Error: SCNAnimationTargetGetValue unknown type (%d)
Error: can't add a NULL animation to %@
Error: can't add an abstract animation to %@
Error: %@ animation kind not supported
Error: unknown fill mode
Error: sub-animation %@ of %@ has no keyPath - ignoring
Error: animating between instances is not supported
Error: CAKeyframeAnimationToSCNAnimation :: too large value to animate : %d bytes
Warning: SCNAnimationGroupToCAAnimationGroup - no target path
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert startValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert endValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert byValue
Error: failed to add an animation with keypath: %@
Error: Error while converting a CAAnimation to a SCNAnimation
Error: %@ is not an animatable path (from %@)
Warning: Safe mode enabled, preventing the download of a network asset %@
Error: entryWithUID:withClass: object with uid %@ exists but is not a geometry
Error: entryWithUID:withClass: object with uid %@ exists but is not a material
Error: entryWithUID:withClass: object with uid %@ exists but is not an animation
Error: entryWithUID:withClass: object with uid %@ exists but is not a node
Error: entryWithUID:withClass: object with uid %@ exists but is not a light
Error: entryWithUID:withClass: object with uid %@ exists but is not a camera
Error: entryWithUID:withClass: object with uid %@ exists but is not a scene
Error: entryWithUID:withClass: object with uid %@ exists but is not a skinner
Error: entryWithUID:withClass: object with uid %@ exists but is not a morpher
Error: entryWithUID:withClass: object with uid %@ exists but is not an image
Error: entrieswithClass: class %@ is not a known C3D class
Error: Too many properties added to this ParticleSystem
Error: Cannot animate this particle semantic : %@
Error: Try to parametrize with a variable property not present : %@
Error: Unknown controller mode : %@
Error: Try to set a controller on a property not present : %@
Error: C3DLibraryCreateEntryIdentifier - unknown type
Error: _remapInfos does not contain an entry %@
Error: library does not contain an entry %d with kind %d
Warning: C3DLibraryAddEntryWithUniqueID - object has no unique ID
Error: Library: could not deserialize the substorage for the type %@
Error: type %d is not serializable
Error: Library deserialization: could not finalize the deserialization of a substorage
Error: Library Deserialization: cannot finalize the deserialization of %@
Warning: C3DLibraryGetMemoryUsageForKind found an image with no sampler
Error: Do not instantiate SCNMaterialProperty objects directly
Error: slotName %d not found
Error: array for material property contents must have 6 elements
Warning: copyC3DImageFromImage: invalid sub-image
Error: unknown material property type for archiving
Error: unknown archived material property type
Error: leaking mesh elements array
Error: Cannot set edge creases element because its primitive type is not SCNGeometryPrimitiveTypeLine
Error: Cannot set edge creases source because its semantic is not SCNGeometrySourceSemanticEdgeCrease
Warning: failed to transpose skeleton
Error: SCNSkinner setBaseGeometry is deprecated on iOS10 and OS X 10.12 and has no effect
Error: number of transforms (%d) doesn't match the number of joints (%d)
Error: Bones index too large for compressed representation : %d
Warning: C3DSkinnerTransposeSkeleton - unable to transpose every joints
Warning: Cannot update the joints using node names: unammed joint found
Warning: Cannot update the joints using node names: can't find node named %@
Warning: _C3DSkinnerUpdateBoundingBox - skinned node has no geometry
Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.
Error: bone out of range %d>=%d [face:%d/vertex:%d]
Error: wrong weight sum %f [face:%d/vertex:%d]
Error: C3DSkinner serialization: lib entry not found
Warning: Skinner deserialization: cannot find the specified skeleton
Error: Skinner deserialization: cannot find a joint
Error: Skinner deserialization: cannot find the skin
Error: C3DSkinner deserialization: lib entry not found
Error: C3DSkinner deserialization: Could not get a valid number value
Error: Unsupported skin weight format
Warning: Morph vertexCount = %ld
Warning: [%ld] = %ld (%f)
Error: meshElement %d : %@
Error: invalid skin indices
Info: Too many influencing joints (%ld > %d) on the vertex #%ld, will cap to %d and renormalize
Error: No jointsCount in the skin %@
Error: Unable to read the jointsCount in the skin %@
Warning: No maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Warning: Unable to read the maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Warning: Too many (%d) weights per vertex. Will cap to 4 to enable GPU skinning.
Error: No inverseBindMatrices in the skin %@
Error: No defaultShapeMatrix in the skin %@
Error: A vertex weight index does not fit on an int
Error: Skin: Could not remap the ID for geometry %d
Error: Skin deserialization: no weightsCount in %@
Error: Skin deserialization: no jointsForVertexWeights in %@
Error: Skin deserialization: no vertexWeights in %@
Error: Skin deserialization: invalid vertexWeights
Error: GenericSource deserialize => no data type
Error: GenericSource deserialize => no count, bailing out
Error: GenericSource deserialize => no comp/value, bailing out
Error: GenericSource deserialize => no padding, bailing out
Error: Could not serialize the accessor's type
Error: accessor->_count too big
Error: accessor->_offset too big
Error: accessor->_padding too big
Error: Accessor serialization failed
Error: Accessor deserialization: Could not find the source ID
Error: Accessor deserialization: Could not find a valid source type
Error: Accessor deserialization: Could not remap the ID for source %d
Error: Accessor deserialization: : no serialized data
Error: C3DSourceAccessorGetValuePtrAtIndex - no data
Error: C3DSourceAccessorGetMutableValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetVolatileValuePtrAtIndex - index out of bounds : %d > %d
Error: The destination does not have enough room to copy this data
Error: error in C3DSourceAccessorCopyDataToAccessor
Error: ERROR: GenericSource deserialize => no data type, bailing out
Error: ERROR: GenericSource deserialize => no count, bailing out
Error: ERROR: GenericSource deserialize => no stride, bailing out
Error: Could not deserialize an accessor
Error: Could not serialize an accessor
Error: Cannot finalize the deserialization of mesh source: accessor data missing
Warning: Cannot duplicate a Metal Buffer source. Create an empty data instead.
Warning: C3DResourceCacheGetResource - image changed on disk - ignore cache
Error: Animation group deserialization: could not deserialize the animation
Error: Could not deserialize an animation channel
Error: attaching a single wheel to multiple vehicle is not supported
Error: Could not deserialize an animation: targetPath not found in %@
Error: Could not deserialize an animation
Error: Could not deserialize an animation: animation not found in %@
Error: _C3DAnimationChannelCopyPropertyList - no target path
Error: C3DGLSLProfileBindProfileInputs - profile has no technique
Error: wrong location returned for input named %@
Error: can't find input named %@
Warning: the same program is shared by two passes but indexed in a different manner
Error: failed to find texture target named %@
Error: declared type doesn't match the uniform named %@
Warning: Possible rounding error, got sin(x) * cos(x) > 0.5, this might lead to NaNs later on.
Info: SCNSceneSourceConvertUnitsToMetersKey and SCNSceneSourceConvertToYUpKey have no effect on compressed assets. Use Xcode's compression options instead
Warning: Safe mode enabled, denying the download of a network URL %@
Warning: Unable to find the image named %@ at the specified path (%@)
Warning: Invalid URL %@
Warning: light_map uv_set:%d is pointing to an invalid uv_set(no corresponding source) and was reset to 1
Warning: invalid zRange detected (whole scene clipped)
Error: can't serize plist :%@
Error: Could not get the data for the serialized property list
Error: Could not zip the serialized property list
Error: This file cannot be opened (version is too old)
Error: This file cannot be opened (version of this c3d is too recent for this version of the framework)
Error: Could not find the zipped data
Error: Could not unzip the zipped data
Error: Error loading the unzipped data: %@
Error: cannot initialize library
Error: Cannot get the library in the serialized data
Error: cannot initialize scene
Error: cannot finalize scene deserialization
Warning: cannot finalize library deserialization
Error: failed to re-resove animation path
Error: unknown notification name
Warning: adding a node that was just removed %p
Warning: overflow the max batch size boundary
Info: PrefersOpenGL key is set in the plist but Metal is requested programmatically. Metal will be used
Error: switchToCameraNamed: no camera named %@
Error: display link thread seems stuck
Error: _initializeRenderFromLightPass - no light
Error: _initializeDeferredShadows - no light
Error: _willExecuteDeferredShadows - no light
Error: _setupDeferredShadows - no light
Error: Could not create morph intervals : Target %d is useless
Error: No morphingType in the morph %@
Error: Unable to read the morphingType in the morph %@
Error: Could not remap the ID for mesh %d
Error: Could not remap the ID for weights source %d
Error: Morphing for sources of type %@ not implemented yet
Error: Morpher deserialization: cannot find the morph
Error: C3DMorpher deserialization: lib entry not found
Error: C3DMorpher deserialization: Could not get a valid number value
Warning: C3DFXContextGetFirstPassInstanceWithGroupID: failed to find pass instance with name (%@)
Error: _C3DFXSetupPasses : no context
Error: shadows are only supported by spot lights and directional lights
Error: failed to bind program for pass %@
Error: pass %@ has no program set
Error: C3DEngineContextRenderTechnique - unknown draw instruction
Error: C3DFXRenderPassWillExecute: invalid framebuffer
Warning: failed to create a GLSL program for hashcode
Error: C3DCommonProfileProgramReleaseHashCode can't find cache for tracked resource
Error: cannot handle more than one lighting modifier
Error: failed to load vertex uber shader.
Error: failed to load fragment uber shader.
Error: Invalid shader modifier : no code provided
Error: DOF pass: no point of view
Error: DOF pass: no camera
Error: %@ setWeight:forTargetAtIndex:%d - index out of bounds (%d)
Error: Too many uniform custom samplers given (Max is %d)
Error: invalid custom texture slot.
Warning: invalid keypath: %@ sent to object %@
Warning: C3DTransactionFlush: command queue still not empty after 2 passes
Error: C3DTransactionCommit - transaction already committed
Error: C3DTransactionCommit - invalid transaction count - probably too many [transaction commit]
Error: C3DTransactionRemoveChild - inconsistency
Error: unexpected transaction commit (missing being ?)
Error: geometrySourceWithData: interleaved buffers as doubles are not supported
Error: Could not create mesh source
Error: SCNGeometryElement initialization - Invalid index size (%ld bytes)
Error: SCNGeometryElement initialization - Invalid polygon edge count (%ld)
Error: Cannot append manipulator vertex data because we encountered an overflow and we are not allowed to flush
Error: Unable to create context
Warning: _beginTranslateAtLocation: invalid zRange
Warning: Warning: no C3DIntersectionRay3Plane
Error: SCNTextureSource abstract method invoked textureWithEngineContext:textureSampler:
Error: SCNTextureSource abstract method invoked _textureWithEngineContext:textureSampler:
Error: SCNTextureSource abstract method invoked textureSize
Error: SCNTextureSource abstract method invoked renderWithEngineContext:nextFrameTime:
Error: SCNTextureSource abstract method invoked cleanup:
Error: SCNImageSource astract method invoked textureSource
Error: SCNTextureLayerSource::textureProxy -> no layer
Error: SCNTextureDelegateSource::textureProxy -> no delegate
Error: SCNTextureSpriteKitSource::textureProxy -> no scene
Error: program failed to build:
Error: Cannot compile empty shader %@
Error: %3d: %@
Error: failed to link program: %s
Error: _convertSlotToAttachmentID : unknown slot
Error: C3DRenderBufferGetSlotForOutputBufferType : unsupported type %d
Error: modifier without code is invalid
Error: unexpected value (%@)
Warning: SCNDefaultValueWithBaseType - unknwon base type %d
Error: unexpected returned value for property %@ of object %@
Error: can't generate implementation for property of type %d
Error: syntax error in the uniform declaration : %@
Error: C3DConstraintApplyIK leef is not a child of root
Error: C3DConstraintApplyIK root and leaf nodes are the same node
Error: Can't create a vehicle with this chassis because it is not in the scene yet
Warning: Chassis should already have a body
Warning: unsupported ease out for contraint applied on base type %d
Error: C3DModelPathResolveCommonProfileProperty unknown path %@
Error: C3DModelPathResolverFindRootEntityForCFType: CFType %d not implemented
Error: _C3DModelPathResolveColor4 unknown path %@
Error: _C3DModelPathResolveCommonProfileTexture unknown path %@
Error: _C3DModelPathResolveTransform unknown path %@
Error: _C3DModelPathResolveRotation unknown path %@
Error: _C3DModelPathResolveVector3 unknown path %@
Error: _C3DModelPathResolveVector4 unknown path %@
Error: _C3DModelPathResolveMatrix unknown path %@
Error: _C3DModelPathResolveShaderModifiers unknown path %@
Error: _C3DModelPathResolveNode unknown path %@
Error: _C3DModelPathResolveDynamicParameter unknown path %@
Error: _C3DModelPathResolveCommonProfile unknown path %@
Error: _C3DModelPathResolveLight unknown path %@
Warning: failed to find morph target named %@ (full path = %@)
Error: _C3DModelPathResolveMorpher unknown path %@
Error: _C3DModelPathResolveScene unknown path %@
Warning: _C3DCreateAnimationTargetFromChannel: can't resolve a path (null model)
Warning: _C3DCreateAnimationTargetFromChannel: can't resolve a path
Error: C3DModelValueStorageReleaseModelValue - object not found
Error: Motion blur pass: no point of view
Error: Motion blur pass: no camera
Error: RendererElementStore does not support span of more than %d
Error: indexstore::_getNextFreeIndex - no more free index
Error: C3DAllocatorDelete - unknown address
Error: technique should not be null
Error: too many blend states: max render target is %d
Warning: can't create a fbo description for pass %@ - can't find pass description with name %@
Error: failed to load program %@
Error: failed to load program %@ %@
Error: unknown cull mode named %@
Error: unknown depth comparison function named %@
Error: unknown blend factor named %@
Error: unknown blend op named %@
Error: invalid buffer type named %@
Error: _bufferTypeFromName - unknown output type: %@
Warning: unknown texture format : %@
Error: description for input named %@ is missing
Error: 'type' is required for symbol %@
Warning: symbol named %@ should be in "targets" not "symbols"
Warning: _convertOutputsDescriptionToOutputs - can't find output named %@
Error: _convertOutputsDescriptionToOutputs - unknown output type: %@
Error: Cannot use a program because shader modifiers are set
Error: ShaderModifiers - unkwnown supporting class '%@'
Error: Cannot use shader modifiers because a program is set
Warning: _updateC3DProgramInput can't find input named %@
Error: ShaderModifiers - unkwnown entrypoint '%@'
Warning: Unknown alignment mode %@
Warning: Unknown truncation mode %@
Error: %s:%d incomplete attachment (%x)
Error: %s:%d missing attachment (%x)
Error: %s:%d incomplete dimensions (%x)
Error: %s:%d framebuffer unsupported (%x)
Error: %s:%d unknown error (%x)
initWithTechniqueRef:
setInteraxialDistance:
objectForKeyedSubscript:
doubleValue
numberWithDouble:
setObject:forKeyedSubscript:
interaxialDistance
initWithDisplayLayout:
displayLayout
_displayLayout
setBarrelDistortionInputScale:
setBarrelDistortionOutputScale:
setBarrelDistortionLensCenter:
setBarrelDistortionWarpCoefficients:
floatValue
CGPointValue
valueWithCGPoint:
SCNVector4Value
valueWithSCNVector4:
init
barrelDistortionInputScale
barrelDistortionOutputScale
barrelDistortionLensCenter
barrelDistortionWarpCoefficients
autorelease
enumerateKeysAndObjectsUsingBlock:
UTF8String
caction
setCppAction:
initWithCoder:
decodeBoolForKey:
encodeWithCoder:
encodeBool:forKey:
alloc
setDuration:
copyWithZone:
duration
numberWithInt:
arrayWithObjects:count:
supportsSecureCoding
hide
unhide
reversedAction
parameters
_mycaction
setHidden:
mapVolatileMesh:verticesCount:
unmapVolatileMesh:
drawRenderElement:withPass:
dataWithBytes:length:
initWithData:topLeftOrigin:name:dimensions:rowStride:channelCount:channelEncoding:isCube:
imageFromTexture
isCube
transform
matrix
class
isKindOfClass:
initWithMatrix:
setTransform:
release
addObject:
children
countByEnumeratingWithState:objects:count:
boolValue
initWithURL:vertexDescriptor:bufferAllocator:preserveTopology:error:
sceneWithMDLAsset:
objectWithSCNNode:
nodeWithMDLObject:masterObjects:
rootNode
addChildNode:
assetWithSCNNode:
assetWithSCNNode:bufferAllocator:
initWithBufferAllocator:
objectWithSCNNode:bufferAllocator:
assetWithSCNScene:
assetWithSCNScene:bufferAllocator:
setMatrix:
name
setName:
camera
cameraWithSCNCamera:
addChild:
light
type
isEqualToString:
lightProbeWithSCNLight:node:
lightWithSCNLight:
geometry
meshWithSCNGeometry:bufferAllocator:
childNodes
geometrySourcesForSemantic:
objectAtIndexedSubscript:
vectorCount
stringWithFormat:
attributes
setFormat:
setBufferIndex:
dataOffset
setOffset:
layouts
dataStride
setStride:
data
newBufferWithData:type:
firstMaterial
multiply
contents
mappingChannel
selfIllumination
geometryElementCount
materials
count
geometryElementAtIndex:
submeshWithSCNGeometryElement:bufferAllocator:
materialWithSCNMaterial:
setMaterial:
initWithVertexBuffers:vertexCount:descriptor:submeshes:
meshWithSCNGeometry:
newSubmeshWithSCNGeometryElement:bufferAllocator:
bytesPerIndex
primitiveType
primitiveCount
initWithIndexBuffer:indexCount:indexType:geometryType:material:
bytes
dataWithLength:
mutableBytes
length
subdataWithRange:
initWithType:data:
setFaceCount:
setFaceTopology:
initWithName:indexBuffer:indexCount:indexType:geometryType:material:topology:
submeshWithSCNGeometryElement:
initWithName:scatteringFunction:
ambient
diffuse
specular
reflective
transparent
metalness
roughness
setColorSpace:
color
CGColor
setColor:
attenuationStartDistance
setAttenuationStartDistance:
attenuationEndDistance
setAttenuationEndDistance:
attenuationFalloffExponent
setAttenuationFalloffExponent:
spotInnerAngle
setInnerConeAngle:
spotOuterAngle
setOuterConeAngle:
setLightType:
focalDistance
setFocusDistance:
yFov
setFieldOfView:
xFov
setSensorAspect:
zNear
setNearVisibilityDistance:
zFar
setFarVisibilityDistance:
focalBlurRadius
setMaximumCircleOfConfusion:
aperture
setFStop:
usesOrthographicProjection
setProjection:
nodeWithMDLObject:
node
transformAnimation
addAnimation:forKey:
vertexDescriptor
objectAtIndex:
containsString:
geometryWithMDLMesh:
setGeometry:
morpherWithMDLMesh:
setMorpher:
lightWithMDLLight:
setLight:
lightWithMDLLightProbe:
cameraWithMDLCamera:
setCamera:
path
objectForKey:
setWantsCPUMorphing:
setObject:forKey:
instance
hidden
UUID
UUIDString
stringByAppendingPathComponent:
generateAmbientOcclusionVertexColorsWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:
generateAmbientOcclusionTextureWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
generateLightMapVertexColorsWithLightsToConsider:objectsToConsider:vertexAttributeNamed:
generateLightMapTextureWithQuality:lightsToConsider:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
_updateAssociatedSCNNodeWithGeometrySetter:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:
_associatedMDLObject
_bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:
nodeWithMDLAsset:
vertexCount
format
bufferIndex
stride
offset
vertexBuffers
geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
setMkSemantic:
geometrySourceWithMDLVertexAttribute:mesh:
submeshes
indexCount
geometryElementWithMDLSubmesh:
material
materialWithMDLMaterial:
geometryWithSources:elements:
setMaterials:
setTargets:
geometryType
topology
faceCount
indexType
indexBuffer
initWithCapacity:
setLength:
appendBytes:length:
faceTopology
geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
propertyNamed:
textureSamplerValue
texture
fileURLWithPath:
writeToURL:
setString:
mkSemantic
ambientOcclusion
setMappingChannel:
setContents:
setLightingModelName:
_integrateModelKitComputedMaps:withGeometry:node:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:filePath:
colorWithCGColor:
innerConeAngle
setSpotInnerAngle:
outerConeAngle
setSpotOuterAngle:
colorWithRed:green:blue:alpha:
lightType
setType:
focusDistance
setFocalDistance:
fieldOfView
setYFov:
sensorAspect
setXFov:
nearVisibilityDistance
setZNear:
farVisibilityDistance
setZFar:
setFocalBlurRadius:
fStop
setAperture:
projection
setUsesOrthographicProjection:
focalLengthAnimation
isSubclassOfClass:
values
arrayWithCapacity:
sensorVerticalAperture
numberWithFloat:
animation
setKeyPath:
setValues:
keyTimes
setKeyTimes:
setAdditive:
setUsesSceneTimeBase:
setRemovedOnCompletion:
focalDistanceAnimation
fStopAnimation
retain
array
initWithString:
copy
_associatedSCNNode
scn_C3DColorIgnoringColorSpace:success:
stringByAppendingString:
initWithName:semantic:float3:
setProperty:
initWithName:semantic:URL:
initWithName:semantic:string:
propertyWithSemantic:
URLValue
stringValue
hardwareFilter
sWrapMode
setWrapS:
tWrapMode
setWrapT:
setContentsTransform:
float4Value
float3Value
resourceManager
renderResourceForMesh:
renderResourceForImage:sampler:options:
renderingAlgorithm
setRenderingAlgorithm:
rate
setRate:
volume
setVolume:
reverbBlend
setReverbBlend:
initWithAVAudioNode:
setWillStartPlayback:
setDidFinishPlayback:
anyObject
removeObject:
initWithSource:
dealloc
audioBuffer
didFinishPlayback
setCompleted:
shouldStream
recycle
postCommandWithContext:object:applyBlock:
loops
scheduleBuffer:atTime:options:completionHandler:
audioFile
play
scheduleFile:atTime:completionHandler:
willStartPlayback
reset
audioBufferFormat
audioPlayerWithAVAudioNode:
audioPlayerWithSource:
setNodeRef:
nodeRef
__CFObject
audioNode
audioPlayer
audioSource
scene
completed
customAudioNode
_audioNode
_audioPlayer
_audioSource
_nodeRef
_scene
_customAudioNode
_completed
initWithAVAudioPCMBuffer:
setPositional:
isPositional
pathExtension
stringByDeletingPathExtension
URLForResource:withExtension:
_loadURLWithBundle:
mainBundle
initWithFileNamed:inBundle:
dictionary
initWithFileNamed:
_load
initForReading:error:
processingFormat
initWithPCMFormat:frameCapacity:
readIntoBuffer:error:
stringWithUTF8String:
currentHandler
localizedDescription
handleFailureInMethod:object:file:lineNumber:description:
load
loadIfNeeded
frameLength
fileFormat
sampleRate
audioSourceNamed:
initWithURL:
audioSourceWithAVAudioPCMBuffer:
setLoops:
setShouldStream:
encodeObject:forKey:
encodeFloat:forKey:
decodeObjectOfClass:forKey:
decodeFloatForKey:
_customEncodingOfSCNAudioSource:
_customDecodingOfSCNAudioSource:
fileName
_audioFile
_audioBuffer
_audioURL
_audioName
_loops
_shouldStream
_loaded
positional
allValues
renderTargetWithName:
matchesDescription:size:
referenceCount
setReferenceCount:
releaseRenderTarget:
newRenderTargetWithDescription:size:
initWithDescription:size:
setTexture:
initWithObjects:
currentFrameIndex
setTimeStamp:
removeObjectForKey:
renderBufferFormat
viewportDependant
timeStamp
enumerateObjectsUsingBlock:
removeObjectsInArray:
removeAllObjects
_purgeWithReason:
numberOfRenderTargets
initWithRenderContext:
renderTargetWithDescription:size:name:useCount:
releaseRenderTargetNamed:
retainTextureWithName:retainCount:
releaseTextureWithName:retainCount:
bumpTimeStamp
purgeRenderTargetsMatchingFrameBuffer
purge
finalizeFrame
viewportDidResize
cleanup
_renderContext
_renderTargets
_nameToRenderTarget
_purgeArray
_frameStamp
numberWithUnsignedLongLong:
initWithContext:
_commonInit
_removeOwner
field
setBlock:
setSmoothness:
setAnimationSpeed:
doesNotRecognizeSelector:
archivedDataWithRootObject:
unarchiveObjectWithData:
physicsWorld
_postCommandWithBlock:
_removeFieldFromWorld:
_createField
_setupCommonProperties
_addFieldToWorld:
encodeDouble:forKey:
encodeInteger:forKey:
immediateMode
setImmediateMode:
setHalfExtent:
decodeDoubleForKey:
setStrength:
setFalloffExponent:
setMinimumDistance:
setActive:
decodeIntegerForKey:
setScope:
setUsesEllipsoidalExtent:
setExclusive:
dragField
customFieldWithEvaluationBlock:
vortexField
radialGravityField
linearGravityField
noiseFieldWithSmoothness:animationSpeed:
turbulenceFieldWithSmoothness:animationSpeed:
springField
electricField
magneticField
_setDisplayScaleFactor:
_displayScaleFactor
strength
categoryBitMask
setCategoryBitMask:
falloffExponent
minimumDistance
isActive
scope
halfExtent
usesEllipsoidalExtent
isExclusive
direction
setDirection:
supportsDirection
supportsOffset
_willRemoveFromPhysicsWorld
_setOwner:
_setWorld:
_owner
_handle
evalAtLocation:
_halfExtent
_strength
_falloffExponent
_minimumDistance
_active
_scope
_usesEllipsoidalExtent
_exclusive
_offset
_direction
_categoryBitMask
_world
_node
_field
gravity
block
_block
axis
valueForUndefinedKey:
setValue:forUndefinedKey:
smoothness
animationSpeed
_smoothness
_animationSpeed
update
restart
stopIfNeeded
_canJitter
jitter
renderer
_jitterAtStep:updateMainFramebuffer:redisplay:jitterer:
initialize
initWithDelegate:
delegateWillDie
setEnabled:
isEnabled
isAborting
_enabled
_state
_iteration
_restartSourceIsSuspended
_delegate
_restartSource
initWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
initWithBody:axis:anchor:
jointWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
jointWithBody:axis:anchor:
bodyA
bodyB
axisA
setAxisA:
axisB
setAxisB:
anchorA
setAnchorA:
anchorB
setAnchorB:
_addToPhysicsWorld:
_willRemoveFromPhysicsWorld:
_definition
_constraint
authoringEnvironment
orderedSetWithCapacity:
component
parentItem
firstObject
orderedSetWithObject:
indexSet
_deleteOriginalData
target
setTarget:
editingSpace
effectiveEditingSpace
worldTransform
setPosition:
begin
setDisableActions:
gridUnit
shouldSnapToAlign
_snapPositionToAlign:original:unit:axisMove:rayStart:rayDir:didSnap:snapIndexes:
shouldSnapOnGrid
addIndex:
updateItemsPosition
commit
updateItemsRotation:
removeAllIndexes
_updateCloneStateWithEvent:
_applyWithEvent:
_saveOriginalData
clearSnapIndexes
validateClones
delegate
authoringEnvironment:didMoveItems:fromTransform:
respondsToSelector:
sceneRenderer
removeItemsFromScene:
addItems:toScene:
authoringEnvironment:didCloneSelection:
validateClone
orderedSet
cloneForManipulators
childNodesPassingTest:
targets
getBoundingBoxMin:max:
convertPosition:toNode:
_prepareSnapToAlignData:minOffset:maxOffset:
prepareSnapToAlignData
prepareSnapToAlignDataIfNeeded
_setAuthoringEnvironment:
isDragging
draw
mouseMoved:
mouseDragged:
mouseDown:
mouseUp:
removeClonesFromScene
addClonesToScene
setupClones
snapGuideIndexesOnAxis:
snapInfoAtIndex:axis:
readonly
setReadonly:
xAlignment
setXAlignment:
yAlignment
setYAlignment:
zAlignment
setZAlignment:
_authoringEnvironment
_targets
_xAxisToZAxisTransform
_yAxisToZAxisTransform
_xyPlaneToYZPlaneTransform
_xyPlaneToXZPlaneTransform
_actionData
_isMouseDown
_readonly
_action
_originalData
_originalDataCount
_worldInitialMatrix
_worldMatrix
_snapToAlignCount
_snapToAlignOnX
_snapToAlignOnY
_snapToAlignOnZ
_snapXIndexes
_snapYIndexes
_snapZIndexes
_xAlignment
_yAlignment
_zAlignment
_cloneSet
_cloning
containsObject:
viewMatrix
parentNode
appendFormat:
appendString:
_setupWithManifold:index:point:
_contactWithManifold:index:
description
_fillNodeA:nodeB:contactPoint:collisionImpulse:distance:
_fillNodeA:nodeB:
nodeA
nodeB
contactPoint
contactNormal
collisionImpulse
penetrationDistance
_prepareUpdate
_shouldPostUpdate
_nodeA
_nodeB
_contactPoint
_contactNormal
_collisionImpulse
_distance
_updateCount
_source
_destination
indexesOfObjectsPassingTest:
removeObjectsAtIndexes:
finished
runBlock:queue:
isCustom
updateWithTarget:forTime:
_queue
setLabel:
initWithMTLTexture:options:
ciImage
_description
_size
_ciImage
_texture
_name
_referenceCount
_timeStamp
valueForKey:
addObjectsFromArray:
addEntriesFromDictionary:
null
dictionaryWithObjects:forKeys:count:
_setupDuration
numberWithBool:
playAudioSource:waitForCompletion:
addAudioPlayer:
techniqueRef
_symbolsAssignedValues
allKeys
dictionaryRepresentation
techniqueWithDictionary:
setValue:forKey:
sceneRef
copyC3DImageFromImage:
postCommandWithContext:object:keyPath:applyBlock:
lock
unlock
disableActions
animationDuration
_syncObjCAnimations
animationManager
_pauseAnimation:forKey:
setSourceObject:
setKeyPathDst:
setKeyPathSrc:
setOptions:
initPresentationTechniqueWithTechniqueRef:
decodeObjectOfClasses:forKey:
_customEncodingOfSCNTechnique:
_customDecodingOfSCNTechnique:
techniqueBySequencingTechniques:
techniqueWithTechniqueRef:
removeAllAnimations
removeAnimationForKey:
animationForKey:
pauseAnimationForKey:
resumeAnimationForKey:
isAnimationForKeyPaused:
removeAnimationForKey:fadeOutDuration:
setSpeed:forAnimationKey:
animationKeys
isEqual:
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isMemberOfClass:
conformsToProtocol:
retainCount
zone
hash
superclass
debugDescription
handleBindingOfSymbol:usingBlock:
setValue:forSymbolNamed:
valueForSymbolNamed:
__removeAnimation:forKey:
addAnimation:
bindAnimatablePath:toObject:withKeyPath:options:
unbindAnimatablePath:
copyAnimationChannelForKeyPath:animation:
isPausedOrPausedByInheritance
presentationInstance
_didInstallInEngineContext:
_isPresentationInstance
_technique
_valueForSymbol
_animations
contextWithEAGLContext:
numberWithLong:
stringByReplacingOccurrencesOfString:withString:
intValue
vectorWithValues:count:
filterWithName:
setDefaults
vectorWithX:Y:Z:W:
extent
drawImage:inRect:fromRect:
initWithTexture:size:flipped:colorSpace:
pushDebugGroup:
renderMesh:meshElement:withProgram:engineContext:transform:color:rasterizerStates:blendState:texture:depthBias:
popDebugGroup
geometryRef
SCNVector3Value
initWithContent:options:
_setTransforms:
SCNMatrix4Value
pointerValue
shapeWithGeometry:options:
valueWithPointer:
valueWithSCNMatrix4:
_customEncodingOfSCNPhysicsShape:
_customDecodingOfSCNPhysicsShape:
setWithArray:
setReferenceObject:
shapeWithNode:options:
shapeWithShapes:transforms:
defaultShapeForGeometry:
initWithCachedObject:options:
referenceObject
options
transforms
sourceObject
_referenceObject
_options
_transforms
_cachedObject
_collisionShape
valueWithSCNVector3:
dictionaryWithObject:forKey:
defaultUICatalogForBundle:
namedTextureWithName:scaleFactor:
size
isOpaque
characterAtIndex:
bundlePath
resourcePath
URLByDeletingPathExtension
URLByAppendingPathExtension:
waitForDuration:withRange:
waitForDuration:
renderBackground:engineContext:
features
stats
clearCaches
profile
enablesDeferredShading
generatorWithProfile:
deferredGeneratorWithProfile:
programWithHashCode:trackedResource:introspectionDataPtr:
renderTargetRegistry
textureForEffectSlot:
setWorldTransform:
_handleCreateIfNeeded:
_allowGhostObjects
initWithCharacter:
setWalkingDirection:
canJump
jump
setVelocity:
velocity
setJumpSpeed:
jumpSpeed
_update
_characterController
_ghostObject
_filterCallback
_capsuleShape
setReferenceURL:
setLoadingPolicy:
assetCatalogWithURL:
bundleURL
isFileURL
relativePath
isAbsolutePath
URLByAppendingPathComponent:
removeFromParentNode
_loadWithCatalog:
_resolveURL
_catalog
sceneWithURL:
sceneWithURL:options:error:
clone
assetCatalog
catalogURL
referenceNodeWithURL:
_isAReference
referenceURL
unload
isLoaded
loadingPolicy
_referenceURL
_catalogURL
_loadingPolicy
_reloadWithScene:
referenceSceneName
setReferenceSceneName:
referenceNodeName
setReferenceNodeName:
setReferenceName:
referenceName
repeatCount
repeatDuration
usesSceneTimeBase
setRepeatCount:
setRepeatDuration:
animationNamed:
setAnimations:
actionNamed:
setupWithActions:
hasReferenceToPhysicsBody:
sharegroup
initWithSharegroup:
textureWithName:scaleFactor:bundle:options:error:
width
height
_operateOnDataUsingCompressionAlgorithm:operation:
mutableCopy
scn_compressedDataUsingCompressionAlgorithm:
scn_uncompressedDataUsingCompressionAlgorithm:
scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:
scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:
scn_indexedDataEncodingDeltaWithBytesPerIndex:
scn_indexedDataDecodingDeltaWithBytesPerIndex:
scn_indexedDataEncodingTrianglePairsWithBytesPerIndex:
scn_indexedDataDecodingTrianglePairsWithBytesPerIndex:
showsAuthoringEnvironment
startProcessingRendererElementsWithEngineIterationContext:
processRendererElement:
beginDeferredLighting
renderLight:lightType:lightData:
endDeferredLighting
stopProcessingRendererElements
numberWithUnsignedInt:
standardizedURL
stringWithContentsOfURL:encoding:error:
dataUsingEncoding:
propertyListWithData:options:format:error:
dictionaryWithContentsOfURL:
JSONObjectWithData:options:error:
standardUserDefaults
boolForKey:
infoDictionary
lastPathComponent
stringByDeletingLastPathComponent
setFinished:
perfromSelector:onTarget:
_selector
_target
integerValue
numberWithInteger:
moveByX:y:z:duration:
moveToX:y:z:duration:
rotateByX:y:z:duration:
rotateToX:y:z:duration:
rotateByAngle:aroundAxis:duration:
rotateToAxisAngle:duration:
rotateToX:y:z:duration:shortestUnitArc:
scaleBy:duration:
scaleTo:duration:
sequenceWithActions:
groupWithActions:
repeatAction:count:
repeatActionForever:
fadeInWithDuration:
fadeOutWithDuration:
fadeOpacityBy:duration:
fadeOpacityTo:duration:
runAction:onFirstChildWithName:
javaScriptActionWithDuration:script:
customActionWithDuration:actionBlock:
objectWithName:class:
editingModeEnabled
setEditingModeEnabled:
moveBy:duration:
moveTo:duration:
sequence:
group:
performSelector:onTarget:
runBlock:
runAction:onChildNodeWithName:
javaScriptActionWithScript:duration:
timingFunction
setTimingFunction:
durationRange
setDurationRange:
timingMode
setTimingMode:
isRelative
setSpeed:
speed
_caction
wasPausedWithTarget:atTime:
willResumeWithTarget:atTime:
timeJumpWithTarget:timeOffset:
ratioForTime:
wasAddedToTarget:atTime:
wasRemovedFromTarget:atTime:
willStartWithTarget:atTime:
setKey:
setCompletionBlock:
_removeAction:forKey:
position
euler
setEuler:
rotation
setRotation:
scale
setScale:
usesEuler
setUsesEuler:
opacity
setOpacity:
nodeWithNodeRef:
setEulerAngles:
_usesEulerRepresentation
eulerAngles
locationInNode:
nodeAtPoint:recursive:
isUserInteractionEnabled
parent
touchesBegan:withEvent:
touchesMoved:withEvent:
touchesEnded:withEvent:
touchesCancelled:withEvent:
setScene:
_touchMap
_script
globalObject
setException:
evaluateScript:
exception
toString
setNode:
setComponent:
elementIndex
setScreenSize:
screenSize
isNodeManipulator
elementPosition
setElementIndex:
_screenSize
nodeManipulatorItemWithNode:screenSize:
setGizmo:
convertTransform:toNode:
_createBody
initWithType:shape:
bodyWithType:shape:
setMass:
physicsBody
isResting
_shapeHandleWithShape:owner:
_physicsWorldCreateIfNeeded:
moveToTransform:
presentationNode
physicsShape
mass
charge
setCharge:
friction
setFriction:
restitution
setRestitution:
rollingFriction
setRollingFriction:
damping
setDamping:
angularVelocity
setAngularVelocity:
angularDamping
setAngularDamping:
velocityFactor
setVelocityFactor:
angularVelocityFactor
setAngularVelocityFactor:
collisionBitMask
setCollisionBitMask:
contactTestBitMask
setContactTestBitMask:
allowsResting
setAllowsResting:
isAffectedByGravity
setAffectedByGravity:
usesDefaultMomentOfInertia
setUsesDefaultMomentOfInertia:
momentOfInertia
setMomentOfInertia:
commitImmediate
removePhysicsBody:handle:
addPhysicsBody:nodeRef:colGroup:colMask:colTest:
setPhysicsShape:
_didDecodeSCNPhysicsBody:
staticBody
dynamicBody
kinematicBody
respondsToCollision
applyForce:impulse:
applyForce:atPosition:impulse:
applyTorque:impulse:
_activate
clearAllForces
resetToTransform:
resetTransform
moveToPosition:
rotateToAxisAngle:
_mass
_charge
_friction
_restitution
_rollingFriction
_physicsShape
_type
_damping
_angularVelocity
_angularDamping
_velocityFactor
_angularVelocityFactor
_velocity
_ignoreGravity
_explicitMomentOfInertia
_momentOfInertia
_collisionBitMask
_contactTestBitMask
_allowsResting
_isDefaultShape
_body
childNodeWithName:recursively:
runAction:
actionForKey:
runAction:afterActionWithKey:
_subSpriteKey
_actionKey
_waitForKeyedAction
_runOnSubSprite
_fired
unsignedIntegerValue
_preTick:
commonInit
wakeUpAllBodies
removeBehavior:
initWithResult:
_rayTestWithSegmentFromPoint:toPoint:options:
arrayWithObject:
_createDynamicWorldIfNeeded
addBehavior:
_customEncodingOfSCNPhysicsWorld:
_customDecodingOfSCNPhysicsWorld:
setGravity:
setTimeStep:
_didDecodeSCNPhysicsWorld:
_physicsContact
initWithScene:
sceneWillDie
timeStep
contactDelegate
setContactDelegate:
removeAllBehaviors
allBehaviors
rayTestWithSegmentFromPoint:toPoint:options:
contactTestBetweenBody:andBody:options:
contactTestWithBody:options:
convexSweepTestWithShape:fromTransform:toTransform:options:
updateCollisionPairs
_needsRedraw
enumerateBodiesUsingBlock:
_reset
_findFieldAttachedToNode:
_aetherHandle
_step:
_defaultVehicleRayCaster
_drawDebugInAuthoringEnvironment:
.cxx_destruct
.cxx_construct
_ghostPairCallback
_vehicleRayCaster
_debugDrawer
_aether
_hasActiveFields
_contactDelegate
_contact
_gravity
_speed
_scale
_timeStep
_fields
_elapsedTime
_behaviors
_bodies
physicsWorld:didBeginContact:
physicsWorld:didUpdateContact:
physicsWorld:didEndContact:
getControlPointAtIndex:values:
functionWithControlPoints::::
scn_colorWithC3DColor:
valueWithBytes:objCType:
getValue:
valueWithCGRect:
valueWithCATransform3D:
CATransform3DValue
SCN_CGPointValue
SCN_valueWithCGPoint:
cameraRef
stringByResolvingSymlinksInPath
defaultManager
attributesOfItemAtPath:error:
globalGLSharedContext
initWithAPI:properties:
setGlobalGLSharedContext:
currentContext
setCurrentContext:
_syncObjCModel
initWithLightRef:
parentWillDie:
initWithParent:propertyType:
_syncEntityObjCModel
initPresentationLightWithLightRef:
presentationLight
observeValueForKeyPath:ofObject:change:context:
identifier
setIdentifier:
intensity
setIntensity:
shadowColor
setShadowColor:
shadowRadius
setShadowRadius:
castsShadow
setCastsShadow:
shadowSampleCount
setShadowSampleCount:
orthographicScale
setOrthographicScale:
gobo
copyPropertiesFrom:
setSpotFalloffExponent:
spotFalloffExponent
usesDeferredShadows
usesModulatedMode
setUsesDeferredShadows:
setUsesModulatedMode:
initWithIESProfile:
computeSceneKitRenderingTexture:
dimensions
encodeInt:forKey:
encodeInt32:forKey:
containsValueForKey:
decodeIntForKey:
decodeInt32ForKey:
_customEncodingOfSCNLight:
valueWithCGSize:
_customDecodingOfSCNLight:
setBaked:
setShouldBakeDirectLighting:
setShouldBakeIndirectLighting:
set_sphericalHarmonics:
setTemperature:
CGSizeValue
setShadowMapSize:
setShadowBias:
setIESProfileURL:
setTechnique:
_didDecodeSCNLight:
lightWithLightRef:
technique
lightRef
copyAnimationChannelForKeyPath:property:
setAttribute:forKey:
attributeForKey:
_probeTexture
set_probeTexture:
_sphericalHarmonics
shouldBakeDirectLighting
shouldBakeIndirectLighting
isBaked
shadowBias
shadowMapSize
temperature
shadowMode
setShadowMode:
IESProfileURL
_light
_goboProjectShadows
_castsShadow
_usesDeferredShadows
_usesModulatedMode
_baked
_shouldBakeDirectLighting
_shouldBakeIndirectLighting
_color
_shadowColor
_shadowRadius
_intensity
_temperature
_orthographicScale
_shadowSampleCount
_shadowMapSize
_zNear
_zFar
_shadowBias
_attenuationStartDistance
_attenuationEndDistance
_attenuationFalloffExponent
_spotInnerAngle
_spotOuterAngle
_spotFalloffExponent
_gobo
_ies
_IESProfileURL
sphericalHarmonicsLevel
sphericalHarmonicsCoefficients
initWithMaterialRef:
ownerWillDie
materialRef
setVertexShader:
setFragmentShader:
setProgram:
initPresentationMaterialWithMaterialRef:
presentationMaterial
commonProfile
_materialPropertyClass
_setColor:
_setC3DImageRef:
emission
normal
arrayWithObjects:
_setupMaterialProperty:
presentationMaterialProperty
_property:
slotName
stringByAppendingFormat:
hasPrefix:
substringWithRange:
_setAttributes:
shininess
setShininess:
transparency
setTransparency:
transparencyMode
setTransparencyMode:
lightingModelName
isLitPerPixel
setLitPerPixel:
isDoubleSided
setDoubleSided:
cullMode
setCullMode:
program
locksAmbientWithDiffuse
setLocksAmbientWithDiffuse:
avoidsOverLighting
setAvoidsOverLighting:
fillMode
setFillMode:
fresnelExponent
setFresnelExponent:
writesToDepthBuffer
setWritesToDepthBuffer:
readsFromDepthBuffer
setReadsFromDepthBuffer:
blendMode
setBlendMode:
shaderModifiers
setShaderModifiers:
substringFromIndex:
unlinkCustomPropertyWithParent:
linkCustomPropertyWithParent:andCustomName:
effectSlot
initWithOwner:
_setupShadableHelperIfNeeded
handleUnbindingOfSymbol:usingBlock:
_customEncodingOfSCNMaterial:
_customDecodingOfSCNMaterial:
setIndexOfRefraction:
setSelfIlluminationOcclusion:
materialWithMaterialRef:
materialWithColor:
materialWithContents:
accessInstanceVariablesDirectly
resolveInstanceMethod:
materialNamed:
properties
indexOfRefraction
selfIlluminationOcclusion
content
setContent:
materialRefCreateIfNeeded
_material
_ambient
_diffuse
_specular
_emission
_reflective
_transparent
_multiply
_normal
_ambientOcclusion
_selfIllumination
_metalness
_roughness
_valuesForUndefinedKeys
_shininess
_transparency
_indexOfRefraction
_fresnelExponent
_selfIlluminationOcclusion
_transparencyMode
_lightingModelName
_cullMode
_shadableHelper
_litPerPixel
_doubleSided
_locksAmbientWithDiffuse
_avoidsOverLighting
_writesToDepthBuffer
_readsFromDepthBuffer
_fillMode
_blendMode
URLForResource:withExtension:subdirectory:
dataWithContentsOfURL:
initForReadingWithData:
setClass:forClassName:
particleSystemRef
geometryWithGeometryRef:
setEmitterShape:
setParticleColor:
particleImage
setParticleImage:
emissionDuration
setEmissionDuration:
emissionDurationVariation
setEmissionDurationVariation:
idleDuration
setIdleDuration:
idleDurationVariation
setIdleDurationVariation:
birthRate
setBirthRate:
birthRateVariation
setBirthRateVariation:
warmupDuration
setWarmupDuration:
emitterShape
birthLocation
setBirthLocation:
birthDirection
setBirthDirection:
emittingDirection
setEmittingDirection:
acceleration
setAcceleration:
spreadingAngle
setSpreadingAngle:
isLocal
setIsLocal:
affectedByGravity
affectedByPhysicsFields
setAffectedByPhysicsFields:
physicsCollisionsEnabled
setPhysicsCollisionsEnabled:
isLightingEnabled
setLightingEnabled:
areSoftParticlesEnabled
setSoftParticlesEnabled:
particleDiesOnCollision
setParticleDiesOnCollision:
isBlackPassEnabled
setBlackPassEnabled:
particleAngle
setParticleAngle:
particleAngleVariation
setParticleAngleVariation:
particleVelocity
setParticleVelocity:
particleVelocityVariation
setParticleVelocityVariation:
particleAngularVelocity
setParticleAngularVelocity:
particleAngularVelocityVariation
setParticleAngularVelocityVariation:
particleLifeSpan
setParticleLifeSpan:
particleLifeSpanVariation
setParticleLifeSpanVariation:
particleBounce
setParticleBounce:
particleBounceVariation
setParticleBounceVariation:
particleFriction
setParticleFriction:
particleFrictionVariation
setParticleFrictionVariation:
particleCharge
setParticleCharge:
particleChargeVariation
setParticleChargeVariation:
particleColor
particleColorVariation
setParticleColorVariation:
systemSpawnedOnCollision
setSystemSpawnedOnCollision:
systemSpawnedOnDying
setSystemSpawnedOnDying:
systemSpawnedOnLiving
setSystemSpawnedOnLiving:
particleSize
setParticleSize:
particleSizeVariation
setParticleSizeVariation:
seed
setSeed:
renderingMode
setRenderingMode:
orientationMode
setOrientationMode:
imageSequenceAnimationMode
setImageSequenceAnimationMode:
particleGeometries
setParticleGeometries:
colliderNodes
setColliderNodes:
propertyControllers
setPropertyControllers:
sortingMode
setSortingMode:
particleMass
setParticleMass:
particleMassVariation
setParticleMassVariation:
dampingFactor
setDampingFactor:
speedFactor
setSpeedFactor:
fixedTimeStep
setFixedTimeStep:
stretchFactor
setStretchFactor:
imageSequenceRowCount
setImageSequenceRowCount:
imageSequenceColumnCount
setImageSequenceColumnCount:
imageSequenceInitialFrame
setImageSequenceInitialFrame:
imageSequenceInitialFrameVariation
setImageSequenceInitialFrameVariation:
imageSequenceFrameRate
setImageSequenceFrameRate:
imageSequenceFrameRateVariation
setImageSequenceFrameRateVariation:
initWithParticleSystemRef:
initPresentationSystemWithSystemRef:
numberWithShort:
softParticlesEnabled
lightingEnabled
blackPassEnabled
_customEncodingOfSCNParticleSystem:
particleSystemNamed:
_customDecodingOfSCNParticleSystem:
particleSystem
particleSystemNamed:inDirectory:
particleSystemWithParticleSystemRef:
typeOfProperty:
setLocal:
handleEvent:forProperties:withBlock:
addModifierForProperties:atStage:withBlock:
removeModifiersOfStage:
removeAllModifiers
_particleSystem
_emissionDuration
_emissionDurationVariation
_idleDuration
_idleDurationVariation
_birthRate
_birthRateVariation
_warmupDuration
_emitterShape
_birthLocation
_birthDirection
_emittingDirection
_acceleration
_spreadingAngle
_isLocal
_affectedByGravity
_affectedByPhysicsFields
_physicsCollisionsEnabled
_lightingEnabled
_softParticlesEnabled
_particleDiesOnCollision
_blackPassEnabled
_particleAngle
_particleAngleVariation
_particleVelocity
_particleVelocityVariation
_particleAngularVelocity
_particleAngularVelocityVariation
_particleLifeSpan
_particleLifeSpanVariation
_particleBounce
_particleBounceVariation
_particleFriction
_particleFrictionVariation
_particleCharge
_particleChargeVariation
_particleImage
_particleColor
_particleColorVariation
_systemSpawnedOnCollision
_systemSpawnedOnDying
_systemSpawnedOnLiving
_particleSize
_particleSizeVariation
_seed
_renderingMode
_orientationMode
_imageSequenceAnimationMode
_particleGeometries
_colliderNodes
_propertyControllers
_sortingMode
_particleMass
_particleMassVariation
_dampingFactor
_speedFactor
_fixedTimeStep
_stretchFactor
_imageSequenceColumnCount
_imageSequenceRowCount
_imageSequenceInitialFrame
_imageSequenceInitialFrameVariation
_imageSequenceFrameRate
_imageSequenceFrameRateVariation
_referenceName
dictionaryWithCapacity:
setC3dAnimation:
inputScale
inputBias
inputOrigin
inputMode
inputProperty
setNext:
initWithType:component:
next
_setParent:
physicsField
initPresentationNodeWithNodeRef:
defaultCStringEncoding
cStringUsingEncoding:
_dump:
pivot
setPivot:
isHidden
renderingOrder
setRenderingOrder:
movabilityHint
setMovabilityHint:
rendererDelegate
setRendererDelegate:
skinner
setSkinner:
morpher
setPhysicsField:
constraints
setConstraints:
authoringEnvironmentNode
setAuthoringEnvironmentNode:
authoringEnvironmentCompanionNode
setAuthoringEnvironmentCompanionNode:
particleSystems
addParticleSystem:
isGizmo
actionKeys
runAction:forKey:
setPhysicsBody:
_copyRecursively
_initChildNodesArray
_expandChildArrayIfNeeded
initWithNodeRef:
_childNodesPassingTest:recursively:output:
childNodesPassingTest:recursively:
_enumerateChildNodesUsingBlock:
enumerateChildNodesUsingBlock:
enumerateHierarchyUsingBlock:
_childNodesWithAttribute:output:recursively:
objectInChildNodesWithAttribute:firstOnly:
_findComponentWithType:
_setComponent:withType:
cameraWithCameraRef:
presentationCamera
presentationGeometry
skinnerWithSkinnerRef:
_setBaseGeometry:
morpherWithMorphRef:
hitTestResultsFromHitTestResultRef:
_updateAffine
_quaternion
orientation
setOrientation:
_setQuaternion:
_euler
_setPosition:
_setScale:
setWithObjects:
_updateTransform
convertTransform:fromNode:
_removeComponentWithType:
_assignComponent:toContainerWithType:
__light
__skinner
skinnerRef
__morpher
morphRef
__camera
__geometry
filters
renderNode:renderer:arguments:
rendererWithContext:options:
_engineContext
rangeOfString:
parseSpecialKey:withPath:intoDestination:remainingPath:
setValue:forKeyPath:
valueForKeyPath:
_reSyncModelTree
countOfChildNodes
insertObject:inChildNodesAtIndex:
canAddChildNode:
exceptionWithName:reason:userInfo:
raise
insertObject:atIndex:
_setPaused:
__insertObject:inChildNodesAtIndex:
removeObjectAtIndex:
__removeObjectFromChildNodesAtIndex:
removeObjectFromChildNodesAtIndex:
replaceObjectAtIndex:withObject:
indexOfChildNode:
replaceObjectInChildNodesAtIndex:withObject:
getBoundingSphereCenter:radius:
isPresentationInstance
automaticallyAdjustsZRange
hasCustomProjectionTransform
projectionTransform
setCenter:
setRadius:
setMin:
setMax:
setGeometryRef:
flattenedClone
skeleton
setSkeleton:
_actionsTimeJump:
removeActionForKey:
runAction:forKey:completionHandler:
constraintRef
_removeDeadParticleSystem:
_particleSystems
_audioPlayers
audioPlayers
setBoundingBoxMin:max:
setFilters:
_customEncodingOfSCNNode:
_customDecodingOfSCNNode:
_didDecodeSCNNode:
nodeWithGeometry:
keyPathsForValuesAffectingPosition
keyPathsForValuesAffectingTransform
keyPathsForValuesAffectingRotation
keyPathsForValuesAffectingEulerAngles
keyPathsForValuesAffectingOrientation
keyPathsForValuesAffectingScale
runAction:completionHandler:
removeAllActions
hasActions
dump
objectInChildNodesWithName:
enumerateNodesUsingBlock:
childNodesWithAttribute:recursively:
childNodeWithName:
jsChildNodesWithAttribute:
hitTestWithSegmentFromPoint:toPoint:options:
_registerAsObserver
quaternion
setQuaternion:
mutableChildNodes
isJoint
renderInContext:
objectInChildNodesAtIndex:
removeAllChilds
insertChildNode:atIndex:
replaceChildNode:with:
getFrustum:withViewport:
getBoundingSphere
getBoundingBox
flattenedCopy
_subdividedCopyWithSubdivisionLevel:
setPaused:
isPaused
actions
removeAllParticleSystems
removeParticleSystem:
countOfParticleSystems
objectInParticleSystemsAtIndex:
insertObject:inParticleSystemsAtIndex:
removeObjectFromParticleSystemsAtIndex:
replaceObjectInParticleSystemsAtIndex:withObject:
removeAllAudioPlayers
removeAudioPlayer:
countOfAudioPlayers
objectInAudioPlayersAtIndex:
insertObject:inAudioPlayersAtIndex:
removeObjectFromAudioPlayersAtIndex:
replaceObjectInAudioPlayerAtIndex:withObject:
convertPosition:fromNode:
authoringEnvironmentPresentationNode
setAuthoringEnvironmentPresentationNode:
_parent
_childNodes
_presentationInstance
_lightLoaded
_geometryLoaded
_cameraLoaded
_skinnerLoaded
_morpherLoaded
_paused
_pausedByInheritance
_affineUpToDate
_transformUpToDate
_hasPivot
_usesEuler
_movability
_hidden
_ignoreAnimationWhenCopying_tmp
_hasComponentBitmask
_transform
_authoringEnvironmentNode
_position
_rotation
_opacity
_components
_actions
_fixedBoundingBoxExtrema
_renderingOrder
_valueForKey
_rendererDelegate
bones
setBones:
_setRootNode:
sceneNamed:inDirectory:options:
URLByResolvingSymlinksInPath
sceneSourceWithURL:options:
sceneWithClass:options:error:
dictionaryWithDictionary:
numberWithUnsignedInteger:
sceneWithData:options:
sceneSourceWithData:options:
initWithSceneRef:
lowercaseString
setStartTime:
setEndTime:
frameRate
setFrameRate:
playbackSpeed
setPlaybackSpeed:
setUpAxis:
startTime
endTime
upAxis
archivedDataWithRootObject:options:
writeToURL:atomically:
exportAssetToURL:
flush
library
URLWithString:
scheme
initWithURL:options:
_createSceneRefWithOptions:statusHandler:
initForJavascript:
_customEncodingOfSCNScene:
_didEncodeSCNScene:
_customDecodingOfSCNScene:
setRootNode:
setFogStartDistance:
setFogEndDistance:
setFogDensityExponent:
setFogColor:
_didDecodeSCNScene:
sceneNamed:
sceneNamed:options:
sceneWithURL:options:
sceneWithURL:atIndex:options:
sceneWithData:atIndex:options:
sceneWithSceneRef:
canImportFileUTI:
canImportFileExtension:
supportedFileUTIsForImport
supportedFileUTIsForExport
jsConstructor
lastEvalTime
setLastEvalTime:
_scenes
setSceneSource:
sceneSource
root
setRootNode:forLayer:
rootNodeForLayer:
_scaleSceneBy:
background
lightingEnvironment
fogColor
fogEndDistance
fogDensityExponent
fogStartDistance
writeToURL:options:delegate:progressHandler:
addSceneAnimation:forKey:target:
addParticleSystem:withTransform:
setPausedForEditing:
isPausedForEditing
_sceneSource
_lastEvalTime
_physicsWorld
_rootNode
_layerRootNode
_background
_environment
_userAttributes
_fogStartDistance
_fogEndDistance
_fogDensityExponent
_fogColor
_pausedForEditing
context
offscreenRendererWithContext:size:
setPointOfView:
backgroundColor
setBackgroundColor:
sceneTime
setSceneTime:
setSize:
transitionPass
prepareRendererAtIndex:withScene:renderSize:pointOfView:parentRenderer:
outgoingScene
setOutgoingScene:
transition
setTransition:
transitionStartTime
setTransitionStartTime:
outgoingPointOfView
setOutgoingPointOfView:
_transitionStartTime
_transition
_outgoingScene
_outgoingPointOfView
completionHandler
_transitionPass
_renderers
clearColor
antialiasingMode
set_antialiasingMode:
_updateEngineCallbacks
setContext:
setPrefersOpenGL:
initWithAPI:
_initWithOptions:isPrivateRenderer:privateRendererOwner:clearsOnDraw:context:renderingAPI:
pointOfView
defaultCenter
removeObserver:
sharedRegistry
removeSourceRenderersForEngineContext:
beginRenderPass:cubemapFaceIndex:isFinalTechnique:
endRenderPass
contentScaleFactor
_invalidateFramebuffer
_contentsScaleFactor
setContentScaleFactor:
_prepareRenderTarget
endFrameWaitingUntilCompleted:
_deleteGLFramebuffer
_createOffscreenFramebufferIfNeeded
_prepareGLRenderTarget
layer
renderbufferStorage:fromDrawable:
_sampleCount
_antialiasingMode
setSampleCount:
postNotificationName:object:
animationWithKeyPath:
setFromValue:
setToValue:
_projectPoint:viewport:
_unprojectPoint:viewport:
renderer:didRenderScene:atTime:
renderer:willRenderScene:atTime:
_isEditor
pausesIncomingScene
pausesOutgoingScene
setAnimationDuration:
_prepareForTransition:outgoingScene:outgoingPointOfView:completionHandler:
_defaultPOVForScene:
setBackingScaleFactor:
_setupSKRendererIfNeeded
bounds
setBounds:
scaleMode
_installContext
_beginFrame
initWithAPI:sharegroup:
_preparePreloadRenderer
_prepareObject:shouldAbortBlock:
_releasePreloadRenderer
currentProgress
isCancelled
_preloadResource:abortHandler:
progressWithTotalUnitCount:
becomeCurrentWithPendingUnitCount:
resignCurrent
renderer:didApplyAnimationsAtTime:
renderer:didSimulatePhysicsAtTime:
renderer:updateAtTime:
setPlaying:
_setSceneTime:
willChangeValueForKey:
didChangeValueForKey:
updateCurrentTimeIfPlayingWithSystemTime:
sharedApplication
applicationState
_systemTime
_updateSystemTimeAndDeltaTimeWithCurrentTime:
_update:rendererContext:
_prepareSKRenderer
updateAtTime:
render:
_hitTest:viewport:options:
_isNodeInsideFrustum:withPointOfView:viewport:
_nodesInsideFrustumWithPointOfView:viewport:
_play
_pause
_endFrame
_resolveAndDiscardGL
presentRenderbuffer:
set_showsAuthoringEnvironment:
setAuthoringDisplayMask:
_showsAuthoringEnvironment
authoringDisplayMask
setEnablesDeferredShading:
setShowsAuthoringEnvironment:
authoringEnvironmentForSceneRenderer:
_drawAtTime:
isJitteringEnabled
_renderSceneWithEngineContext:sceneTime:
_prepareFrame:
_computeNextFrameTime
set_nextFrameTime:
updateAndDrawStatisticsIfNeeded
_drawSceneWithNewRenderer:
_drawSceneWithLegacyRenderer:
_clearBuffers
set_systemTime:
set_deltaTime:
_installViewport
_duration
settingsForTransition:atTime:renderIncomingToTexture:renderOutgoingToTexture:renderIncomingToScreen:renderOutgoingToScreen:
_viewport
set_viewport:
renderAtTime:
_drawScene:
textureID
renderTransition:withInputTexture:outputTexture:inputTextureSize:outputTextureSize:time:
_updatePointOfView
_renderAtTime:
_renderAtTime:viewport:encoder:passDescriptor:commandQueue:commandBuffer:
_installGLContextAndSetViewport
createSnapshot:
imageWithCGImage:
_setBackingSize:
snapshotRendererWithSize:
snapshotAtTime:
_setupOffscreenRendererWithSize:
overlaySKScene
setOverlaySKScene:
setJitteringEnabled:
autoenablesDefaultLighting
setAutoenablesDefaultLighting:
autoAdjustCamera
setAutoAdjustCamera:
isPlaying
setDelegate:
updateProbes:atTime:
renderingAPI
_jitterRedisplay
drain
rendererWithDevice:options:
presentScene:withTransition:incomingPointOfView:completionHandler:
hitTest:options:
isNodeInsideFrustum:withPointOfView:
nodesInsideFrustumWithPointOfView:
projectPoint:
unprojectPoint:
prepareObject:shouldAbortBlock:
prepareObjects:withCompletionHandler:
showsStatistics
setShowsStatistics:
debugOptions
setDebugOptions:
audioEngine
audioEnvironmentNode
audioListener
setAudioListener:
currentRenderPassDescriptor
currentRenderCommandEncoder
device
commandQueue
_renderingQueue
_rendererContext
_renderContextMetal
_projectPoints:count:viewport:
_didRenderScene:
_willRenderScene:
setScene:completionHandler:
disableOverlays
setDisableOverlays:
programWithNode:withMaterial:
_nextFrameTime
nextFrameTime
_needsRepetitiveRedraw
currentTime
setCurrentTime:
_updateWithSystemTime:
_drawOverlaySceneAtTime:
_stop
jitteringEnabled
frozen
setFrozen:
_copyPerformanceStatistics
_displayLinkStatsTick
_displayLinkStatsTack
_runningInExtension
_presentFramebuffer
_enablesDeferredShading
set_enablesDeferredShading:
_drawWithJitteringPresentationMode
_draw
renderAtTime:viewport:commandBuffer:passDescriptor:
renderAtTime:viewport:encoder:passDescriptor:commandQueue:
render
snapshotAtTime:withSize:antialiasingMode:
_updateProbes:withProgress:
copySnapshotWithSize:
initOffscreenRendererWithSize:options:
_pointOfView
_lock
__renderingQueue
__antialiasingMode
_framebufferInfo
_mtlTexture
_shouldDeleteFramebuffer
_pointOfViewWasSet
_isPrivateRenderer
_isViewPrivateRenderer
_renderingSnapshot
_currentSceneTime
_currentSystemTime
_deltaTime
_forceSystemTime
_lastSystemTime
__nextFrameTime
_transitionContext
_playing
_isAnimating
_adaptativeState0
_adaptativeEndFrame
_adaptativeTechniqueTimeStamp
_renderingAPI
__viewport
_glContext
_jitteringEnabled
_frozen
_delegateSupportsWillRender
_delegateSupportsDidRender
_delegateSupportsDidApplyAnimations
_delegateSupportsUpdate
_delegateSupportsDidSimulatePhysics
_backgroundColor
_c3dBackgroundColor
_preloadRenderer
_privateRendererOwner
_snapshotRenderer
_overlayRenderer
_overlayScene
_disableOverlays
_isRunningInExtension
_showStatistics
_statisticsTimeStamp
snapshot
setAntialiasingMode:
encodeBytes:length:forKey:
decodeBytesForKey:returnedLength:
CGPath
flatness
bezierPathWithCGPath:
setFlatness:
keyPath
pathComponents
pathForResource:ofType:inDirectory:
initWithContentsOfFile:
CGImage
imageNamed:
absoluteString
checkResourceIsReachableAndReturnError:
SCNMutableDeepCopy
keys
_setupFrom:
applyFunction:withContext:
_keys
_keyValues
addIndexes:
removeIndexes:
allObjects
getC3DImageRef
rangeValue
stringWithCapacity:
stringWithString:
scn_stringByReplacingCharactersInRanges:withStrings:
_convertToCA
_clearC3DCache
timingFunctions
setTimingFunctions:
tensionValues
setTensionValues:
continuityValues
setContinuityValues:
biasValues
setBiasValues:
setAutoreverses:
autoreverses
setTimeOffset:
timeOffset
setFadeInDuration:
fadeInDuration
setFadeOutDuration:
fadeOutDuration
isRemovedOnCompletion
setCommitsOnCompletion:
commitsOnCompletion
setAnimationEvents:
animationEvents
isAdditive
setCumulative:
isCumulative
objCType
c3dAnimation
_c3dAnimation
_caReady
setTime:
setEventBlock:
animationEventWithKeyTime:block:
time
eventBlock
_eventTime
_eventBlock
fromValue
toValue
byValue
animationTimingFunction
functionWithName:
scnAnimationNamed:
SCN_evaluateAtTime:reverse:to:
sortedArrayUsingComparator:
setBeginTime:
beginTime
animationDidStart:
animationDidStop:finished:
animations
calculationMode
componentsJoinedByString:
setByValue:
_shouldCacheWithOptions:
sceneSourceOptions
initWithKeyOptions:valueOptions:capacity:
_cachedSceneSourceForURL:options:
initWithContentsOfURL:
blockOperationWithBlock:
addOperation:
_cacheSceneSource:forURL:options:
_removeCachedSceneSourceIfNeededForURL:
initWithData:options:
sceneCount
sceneWithOptions:error:
waitUntilAllOperationsAreFinished
errorWithDomain:code:userInfo:
localizedStringForKey:value:table:
dictionaryWithObjectsAndKeys:
setRequiresSecureCoding:
assetCatalogForResourceURL:
setAssetCatalog:
finishDecoding
_sceneWithClass:options:statusHandler:
sceneWithClass:options:statusHandler:
copyPropertiesAtIndex:options:
copyImageFromC3DImage:
_appendToEntries:entriesWithType:passingTest:entryObjectConstructor:
entryWithIdentifier:withClass:
identifiersOfEntriesWithClass:
sceneTypes
sceneFileTypes
countOfScenes
sceneAtIndex:options:
sceneAtIndex:options:error:
sceneWithOptions:statusHandler:
propertyForKey:
sceneSourceRef
entriesPassingTest:
entryWithID:withClass:
IDsOfEntriesWithClass:
sourceStatus
canExportToColladaWithNoDataLoss
performConsistencyCheck
_lastLoadedScene
_lastOptions
_downloadingQueue
_sceneLoaded
_sceneSourceOptions
lookUpKey
setLookUpKey:
lookUpFoundInstance
setLookUpFoundInstance:
_context
_assetCatalog
allocWithZone:
initWithLength:
initForWritingWithMutableData:
finishEncoding
isEqualToDictionary:
beginFrame:
createVolatileMeshElementOfType:primitiveCount:bytesPerIndex:
drawFullScreenQuadForPass:
sampleCount
wantsWideGamut
setWantsWideGamut:
setIsOpaque:
processRendererElement:engineIterationContext:
_currentFrameIndex
__engineStats
_renderTargetRegistry
textureCoordinatesWithMappingChannel:
geometryIndex
boneNode
faceIndex
localCoordinates
worldCoordinates
localNormal
worldNormal
textureCoordinate
modelTransform
_result
prepareScene:
addedNode:
setDisplayMask:
setFirstMaterial:
lightGeometry
particlesGeometry
jointGeometry
compare:
cameraGeometry
cameraFrustumGeometry
cameraNearPlaneGeometry
addLightNode:
addParticlesNode:
addCameraNode:
addJointNode:
removeLightNode:
removeParticlesNode:
removeCameraNode:
removeJointNode:
sphereWithRadius:
member:
updateLightTypeForNode:source:light:andRatio:
authoringEnvironmentForScene:
removedNode:
selectNode:
addNodeToSelection:
selectNodes:
cancelSelection
updateLightNode:withSourceNode:
updateParticlesNode:withSourceNode:
updateJointNode:withSourceNode:
updateCameraNode:withSourceNode:
updateWithRenderer:
displayMask
didTapAtPoint:
_selection
_layerRoot
_lightRoot
_cameraRoot
_particlesRoot
_jointsRoot
_lightsDictionary
_camerasDictionary
_particlesDictionary
_jointsDictionary
_renderer
_lightGeometry
_cameraFrustumGeometry
_cameraGeometry
_cameraNearPlaneGeometry
_particlesGeometry
_jointGeometry
_displayMask
_paleGreen
_paleBlue
_red
_green
_blue
_cyan
_yellow
_orange
_pink
_grayLight
_grayMedium
_grayDark
_white
planeWithWidth:height:
setValueForKey:optionKey:options:
boxWithWidth:height:length:chamferRadius:
pyramidWithWidth:height:length:
setGeodesic:
cylinderWithRadius:height:
coneWithTopRadius:bottomRadius:height:
tubeWithInnerRadius:outerRadius:height:
capsuleWithCapRadius:height:
torusWithRingRadius:pipeRadius:
floor
planeWithWidth:height:options:
boxWithWidth:height:length:cornerRadius:options:
pyramidWithWidth:height:length:options:
sphereWithRadius:options:
cylinderWithRadius:height:options:
coneWithHeight:topRadius:bottomRadius:options:
tubeWithInnerRadius:outerRadius:height:options:
capsuleWithRadius:height:options:
torusWithRingRadius:pipeRadius:options:
floorWithOptions:
_setGeometryRef:
reflectionFalloffStart
reflectionFalloffEnd
setReflectionFalloffStart:
setReflectionFalloffEnd:
reflectivity
setReflectivity:
reflectionResolutionScaleFactor
setReflectionResolutionScaleFactor:
reflectionSampleCount
setReflectionSampleCount:
reflectionCategoryBitMask
setReflectionCategoryBitMask:
setWidth:
_customDecodingOfSCNFloor:
floorRef
setHeight:
reflectionFallOffStart
reflectionFallOffEnd
setReflectionFallOffStart:
setReflectionFallOffEnd:
__createCFObject
_usesCustomScaleFactor
_reflectivity
_reflectionFalloffStart
_reflectionFalloffEnd
_reflectionCategoryBitMask
_width
_length
_reflectionResolutionScaleFactor
_reflectionSampleCount
initWithCameraRef:
initPresentationCameraWithCameraRef:
focalSize
setFocalSize:
setAutomaticallyAdjustsZRange:
wantsHDR
setWantsHDR:
whitePoint
setWhitePoint:
averageGray
setAverageGray:
wantsExposureAdaptation
setWantsExposureAdaptation:
exposureAdaptationDuration
setExposureAdaptationDuration:
exposureAdaptationBrighteningSpeedFactor
setExposureAdaptationBrighteningSpeedFactor:
exposureAdaptationDarkeningSpeedFactor
setExposureAdaptationDarkeningSpeedFactor:
minimumExposure
setMinimumExposure:
maximumExposure
setMaximumExposure:
bloomIntensity
setBloomIntensity:
bloomThreshold
setBloomThreshold:
bloomBlurRadius
setBloomBlurRadius:
vignettingPower
setVignettingPower:
vignettingIntensity
setVignettingIntensity:
colorFringeStrength
setColorFringeStrength:
colorFringeIntensity
setColorFringeIntensity:
saturation
setSaturation:
contrast
setContrast:
motionBlurIntensity
setMotionBlurIntensity:
setProjectionTransform:
_customEncodingOfSCNCamera:
setExposureOffset:
_didDecodeSCNCamera:
screenSpaceAmbientOcclusionAmount
setScreenSpaceAmbientOcclusionAmount:
screenSpaceAmbientOcclusionRadius
setScreenSpaceAmbientOcclusionRadius:
screenSpaceAmbientOcclusionStrength
setScreenSpaceAmbientOcclusionStrength:
screenSpaceAmbientOcclusionFalloff
setScreenSpaceAmbientOcclusionFalloff:
exposureOffset
xMag
setXMag:
yMag
setYMag:
colorGrading
_camera
_custom
_usesOrthographicProjection
_automaticallyAdjustsZRange
_xFov
_yFov
_focalDistance
_focalBlurRadius
_focalSize
_aperture
_projectionTransform
_colorGrading
_wantsHDR
_whitePoint
_averageGray
_exposureOffset
_minimumExposure
_maximumExposure
_wantsExposureAdaptation
_exposureAdaptationDuration
_exposureAdaptationBrighteningSpeedFactor
_exposureAdaptationDarkeningSpeedFactor
_bloomIntensity
_bloomThreshold
_bloomBlurRadius
_motionBlurIntensity
_vignettingPower
_vignettingIntensity
_colorFringeStrength
_colorFringeIntensity
_saturation
_contrast
_screenSpaceAmbientOcclusion
materialAttachmentWithGLKTextureInfo:
glID
setGlID:
propertyType
_clearContents
removeSourceRenderersForSource:
_animationPathForKey:
_updateMaterialColor:
_updateMaterialNumber:
textureSampler
_updateMaterialFilters
_presentationMappingChannel
_updateMaterialBorderColor:
_updateMaterialAttachment:
_textureOptions
copyC3DImageFromImage:textureOptions:
_updateMaterialImage:
_updateMaterialSKScene:
_updateMaterialSKTexture:
_updateMaterialLayer:
setUiView:
setUiWindow:
connectToProxy:
_layerDidChange:
addObserver:selector:name:object:
removeObserver:name:object:
_updateMaterialUIComponent:
setImage:
setLayer:
setSkScene:
setSkTexture:
setAttachment:
setUIView:
setUIWindow:
setFloatValue:
effectSlotCreateIfNeeded:
image
_updateMaterialProceduralContents:
_updateMaterialMTLTexture:
__allocateContentTransformIfNeeded
_updateMaterialPropertyTransform:
_copyC3DImageFromImageData:typeID:
initWithCGImage:
_copyImageFromC3DImage:
minificationFilter
setMinificationFilter:
magnificationFilter
setMagnificationFilter:
mipFilter
setMipFilter:
contentsTransform
wrapS
wrapT
borderColor
setBorderColor:
initPresentationMaterialPropertyWithModelProperty:
borderColor4
hasAlpha
filteringMode
usesMipmaps
setMaxAnisotropy:
_customEncodingOfSCNMaterialProperty:
_customDecodingOfSCNMaterialProperty:
_didDecodeSCNMaterialProperty:
materialPropertyWithContents:
initWithParent:andCustomName:
color4
attachment
pvrtcData
skScene
skTexture
UIView
maxAnisotropy
setProceduralContents:
proceduralContents
setMtlTexture:
mtlTexture
_isCommonProfileProperty
_propertyType
_customSlotName
_borderColor
_contentType
_contents
_mappingChannel
_maxAnisotropy
_minificationFilter
_magnificationFilter
_mipFilter
_wrapS
_wrapT
_customSlot
_c3dImage
_textureProxy
_contentTransform
glTextureId
textureTarget
textureRect
isRotated
initWithGeometryRef:
string
geometryDescription
initPresentationGeometryWithGeometryRef:
meshSource
meshElement
geometrySourceWithMeshSourceRef:
geometryElementWithMeshElementRef:
_setupGeometrySources
geometrySources
semantic
_setupGeometryElements
geometryElements
levelsOfDetail
setLevelsOfDetail:
_setupObjCModelFrom:
_materialWithName:
_expand
mutableMaterials
_firstMaterial
removeMaterialAtIndex:
insertMaterial:atIndex:
replaceObjectInMaterialsAtIndex:withObject:
insertObject:inMaterialsAtIndex:
indexOfObject:
removeObjectFromMaterialsAtIndex:
removeAllMaterials
thresholdMode
thresholdValue
_customEncodingOfSCNGeometry:
_customDecodingOfSCNGeometry:
setSubdivisionLevel:
setEdgeCreasesSource:
setEdgeCreasesElement:
_releaseCachedSourcesAndElements
geometrySourceForSemantic:
interleavedCopy
keyForNodeAttributes
materialWithName:
countOfMaterials
objectInMaterialsAtIndex:
removeMaterial:
replaceMaterialAtIndex:withMaterial:
replaceMaterial:with:
setPrimitiveType:
_subdivisionSettings
set_subdivisionSettings:
subdivisionLevel
edgeCreasesElement
edgeCreasesSource
_unifyNormals
_geometry
_sources
_elements
_materials
_levelsOfDetail
_subdivisionLevel
_edgeCreasesSource
_edgeCreasesElement
initWithMeshSource:
mutableGeometrySourcesForSemantic:
mutateGeometrySourcesWithSemantics:usingBlock:
substringToIndex:
URLByDeletingLastPathComponent
cacheObject:forKey:
URLOfResourceNamed:
unarchiveObjectWithFile:
enumeratorAtPath:
nextObject
caseInsensitiveCompare:
lookUpKeyForObjectNamed:class:
recursivePathsForResourcesOfType:inDirectory:
dataWithContentsOfFile:
decodeObjectForKey:
assetCatalogNamed:
clearCache
pathByMakingURLRelativeToCatalog:
_cache
sceneDatabase
addInstance:withName:class:
setAnimation:
setInputMode:
setInputScale:
setInputBias:
setInputOrigin:
setInputProperty:
_customEncodingOfSCNParticlePropertyController:
_customDecodingOfSCNParticlePropertyController:
particlePropertyControllerWithAnimation:
controllerWithAnimation:
_animation
_inputMode
_inputScale
_inputBias
_inputOrigin
_inputProperty
initWithSkinnerRef:
_setSkeleton:
_createSkinnerWithVertexCount:bones:boneWeights:boneIndices:baseGeometry:
bytesPerComponent
floatComponents
createSkinnerWithBaseGeometry:bones:boneWeights:boneIndices:
setBoneInverseBindTransforms:
setBaseGeometryBindTransform:
dataWithBytesNoCopy:length:freeWhenDone:
_geometrySourceWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
baseGeometry
baseGeometryBindTransform
boneWeights
boneIndices
boneInverseBindTransforms
_createSkinnerWithCompressedData:bonesCount:vertexCount:
skinnerWithBaseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:
_skinnerWithBaseGeometry:skinnableGeometry:bones:boneInverseBindTransforms:bindMatrix:
wantsCPUSkinning
setWantsCPUSkinning:
_bonesAndIndicesCompression
set_bonesAndIndicesCompression:
setBaseGeometry:
joints
_skinner
_skeleton
_baseGeometry
_caDisplayLinkCallback
displayLinkWithTarget:selector:
targetTimestamp
setPreferredFramesPerSecond:
setFrameInterval:
mainRunLoop
addToRunLoop:forMode:
_teardown
_resume
_isInvalidated
timestamp
_callbackWithTime:
invalidate
initWithOwner:queue:block:
willDie
setPaused:nextFrameTimeHint:lastUpdate:
preferredFrameRate
setPreferredFrameRate:
queuedFrameCount
setNeedsDisplay
_caDisplayLink
_supportTargetTimestamp
_invalidated
_asynchronous
_lastFrameTime
_preferredFrameRate
_queuedFrameCount
initWithData:options:error:
entryNames
contentsForEntryName:
initWithEntryNames:contents:properties:options:
archiveData
dataWithContentsOfFile:options:error:
archive:contentsForEntryName:
archive:streamForEntryName:
archive:propertiesForEntryName:
inputStreamWithData:
writeToFile:options:error:
initWithCalendarIdentifier:
date
components:fromDate:
year
month
hour
minute
second
replaceBytesInRange:withBytes:
appendData:
initWithPath:options:error:
initWithEntryNames:dataProvider:options:
streamForEntryName:
writeContentsForEntryName:toFile:options:error:
propertiesForEntryName:
archiveStream
isValid
_data
_provider
_desc
_path
_names
_properties
_cachedContents
_reserved
_zFlags
_reserved2
fileSystemRepresentation
initWithBytes:length:encoding:
initWithBodyA:anchorA:bodyB:anchorB:
initWithBody:anchor:
jointWithBodyA:anchorA:bodyB:anchorB:
jointWithBody:anchor:
addNormalsWithAttributeNamed:creaseThreshold:
_geometryByWeldingVerticesWithThreshold:normalThreshold:
componentsPerVector
_componentType
_geometryByUnifyingNormalsWithCreaseThreshold:
_geometryByAddingSourcesOfSkinner:
_geometryByRemovingSkinnerSources
_discardOriginalTopology
setConnectionPosition:
btVehicle
wheelWithNode:
suspensionStiffness
setSuspensionStiffness:
suspensionCompression
setSuspensionCompression:
suspensionDamping
setSuspensionDamping:
maximumSuspensionTravel
setMaximumSuspensionTravel:
frictionSlip
setFrictionSlip:
maximumSuspensionForce
setMaximumSuspensionForce:
connectionPosition
steeringAxis
setSteeringAxis:
axle
setAxle:
radius
suspensionRestLength
setSuspensionRestLength:
isFront
setIsFront:
_setVehicle:
_setWheelIndex:
_vehicle
_wheelIndex
_suspensionStiffness
_suspensionCompression
_suspensionDamping
_maximumSuspensionTravel
_frictionSlip
_maximumSuspensionForce
_connectionPosition
_steeringAxis
_axle
_radius
_suspensionRestLength
_isFront
keyPathSrc
keyPathDst
_syncObjCModel:
initPresentationParametricGeometryWithParametricGeometryRef:
presentationPlane
cornerRadius
setCornerRadius:
widthSegmentCount
setWidthSegmentCount:
heightSegmentCount
setHeightSegmentCount:
cornerSegmentCount
setCornerSegmentCount:
initWithParametricGeometryRef:
_height
_cornerRadius
_widthSegmentCount
_heightSegmentCount
_cornerSegmentCount
_primitiveType
presentationBox
setChamferRadius:
chamferRadius
lengthSegmentCount
setLengthSegmentCount:
chamferSegmentCount
setChamferSegmentCount:
_boxwidth
_boxheight
_boxlength
_boxchamferRadius
_boxwidthSegmentCount
_boxheightSegmentCount
_boxlengthSegmentCount
_boxchamferSegmentCount
_boxprimitiveType
presentationPyramid
_pyramidwidth
_pyramidheight
_pyramidlength
_pyramidwidthSegmentCount
_pyramidheightSegmentCount
_pyramidlengthSegmentCount
_pyramidprimitiveType
presentationSphere
radialSpan
setRadialSpan:
segmentCount
setSegmentCount:
isGeodesic
isHemispheric
setHemispheric:
_sphereradius
_sphereradialSpan
_spheresegmentCount
_sphereprimitiveType
_spheregeodesic
_spherehemispheric
presentationCylinder
radialSegmentCount
setRadialSegmentCount:
_cylinderradius
_cylinderheight
_cylinderradialSpan
_cylinderheightSegmentCount
_cylinderradialSegmentCount
_cylinderprimitiveType
presentationCone
topRadius
bottomRadius
setTopRadius:
setBottomRadius:
_conetopRadius
_conebottomRadius
_coneheight
_coneheightSegmentCount
_coneradialSegmentCount
_coneprimitiveType
presentationTube
outerRadius
setInnerRadius:
setOuterRadius:
innerRadius
_tubeinnerRadius
_tubeouterRadius
_tubeheight
_tuberadialSpan
_tubeheightSegmentCount
_tuberadialSegmentCount
_tubeprimitiveType
presentationCapsule
capRadius
setCapRadius:
capSegmentCount
setCapSegmentCount:
_capsulecapRadius
_capsuleheight
_capsuleheightSegmentCount
_capsuleradialSegmentCount
_capsulecapSegmentCount
_capsuleprimitiveType
presentationTorus
ringRadius
pipeRadius
setRingRadius:
setPipeRadius:
setRingSegmentCount:
setPipeSegmentCount:
pipeSegmentCount
ringSegmentCount
_torusringRadius
_toruspipeRadius
_torusradialSpan
_torusringSegmentCount
_toruspipeSegmentCount
_torusprimitiveType
geometrySourceWithVertices:count:
setOpaque:
setDrawableProperties:
eaglContext
_enterForeground:
_enterBackground:
mainScreen
nativeScale
_defaultBackgroundColor
setAllowsCameraControl:
initWithFrame:options:
_selectRenderingAPIWithOptions:
initWithFrame:
_commonInit:
setContentMode:
setMultipleTouchEnabled:
set_ibPreferredRenderingAPI:
set_ibWantsMultisampling:
_ibWantsMultisampling
set_ibSceneName:
allowsCameraControl
_ibSceneName
_ibPreferredRenderingAPI
_flushDisplayLink
_setGestureRecognizers:
sceneWillChange
removeObserver:forKeyPath:
_sceneDidUpdate:
addObserver:forKeyPath:options:context:
_setNeedsDisplay
sceneDidChange
_updateOpacity
eventHandler
viewWillDraw
viewDidDraw
_checkAndUpdateDisplayLinkStateIfNeeded
cameraWillChange
cameraDidChange
setEventHandler:
_displayLink
_flipY:
keyPathsForValuesAffectingValueForKey:
_kvoKeysForwardedToRenderer
setWithObject:
setByAddingObjectsFromSet:
automaticallyNotifiesObserversForKey:
setView:
_updateGestureRecognizers
whiteColor
_adjustBackingLayerPixelFormat
willMoveFromView:
_didMoveToView:
wantsRedraw
frame
setPointOfView:animate:
gestureRecognizers
removeGestureRecognizer:
addGestureRecognizer:
hitTest:withEvent:
locationInView:
window
resumeDisplayLink
didMoveToWindow
pauseDisplayLink
willMoveToWindow:
startAndReturnError:
pause
renderingAPIForOptions:
_isMetalSupported
layerClass
_supportsJitteringSyncRedraw
play:
pause:
stop:
eventHandlerWantsRedraw
_sceneBackgroundDidChange:
preferredFramesPerSecond
_systemTimeAnimationStarted:
switchToCameraNamed:
switchToNextCamera
ibPreferredRenderingAPI
setIbPreferredRenderingAPI:
ibSceneName
setIbSceneName:
ibWantsMultisampling
setIbWantsMultisampling:
_runFPSTestWithDuration:
setEaglContext:
displayLayer:
drawRect:
_controlsOwnScaleFactor
_lastUpdate
__ibSceneName
__ibPreferredRenderingAPI
_ibNoMultisampling
_allowsBrowsing
_isOpaque
_firstDrawDone
_drawOnMainThreadPending
_appIsDeactivated
_viewIsOffscreen
_backingSizeDidChange
__displayLink
_preferredFramePerSeconds
_jitterer
_snapshotImageData
_snapshotImageDataLength
_eventHandler
_spriteKitEventHandler
_controllerGestureRecognizers
_program
_owners
initWithProfile:
_programWithHashCode:introspectionDataPtr:
emptyShaderCache
releaseProgramForResource:
_programMutex
_shaders
_trackedResourcesToHashcode
_profile
fractionCompleted
removeObserver:forKeyPath:context:
initWithMorphRef:
initPresentationMorpherWithMorphRef:
presentationMorpher
setWeight:forTargetAtIndex:
weightForTargetAtIndex:
setCalculationMode:
_customEncodingOfSCNMorpher:
_customDecodingOfSCNMorpher:
setWeights:
setShouldMorphNormals:
_didDecodeSCNMorpher:
shouldMorphNormals
wantsCPUMorphing
convertToAdditiveWithBaseGeometry:
_isUsingSparseTargets
convertToSparseWithBaseGeometry:
_morpher
_calculationMode
_weights
_shouldMorphNormals
_useSparseTargets
center
numberWithUnsignedLong:
sharedInstance
add:
remove:
registerUIKitSource:
unregisterUIKitSource:
apply:
scnView
_warpPoint:outOfBounds:
superview
convertPoint:fromView:
subviews
_isSettingFirstResponder
_setFirstResponder:
_canBecomeKeyWindow
windowLevelForEventHandling
_hitTest:withEvent:windowServerHitTestWindow:
warpPoint:
uiView
addSubview:
setWindowLevel:
prepareWindowIfNeeded
uiWindow
setSource:
setup
windowWillDie
textureSource
_uiView
_uiWindow
superlayer
_layerTreeDidUpdate
cleanup:
textureWithEngineContext:textureSampler:nextFrameTime:
layerSizeInPixels
source
_setup
_windowReady
_sizeCache
_textureID
_textureSampler
isMultipleTouchEnabled
canBecomeFirstResponder
setAnimationTimingFunction:
completionBlock
currentState
dataByConvertingDoublesToFloats:count:
initWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
initWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
dataWithVector3Array:count:bytesPerComponent:
dataWithPointArray:count:bytesPerComponent:
geometrySourceWithNormals:count:
geometrySourceWithTextureCoordinates:count:
_meshSource
_semantic
_vectorCount
_componentCount
_dataOffset
_dataStride
_mkSemantic
mutableData
initWithMeshElement:
initWithData:primitiveType:primitiveCount:bytesPerIndex:
_optimizedGeometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
_optimizeTriangleIndices
_computeACMR
_renderableElementCopy
_meshElement
_elementData
_primitiveCount
_bytesPerIndex
engine
disconnectNodeInput:
disconnectNodeOutput:
detachNode:
attachNode:
initStandardFormatWithSampleRate:channels:
mainMixerNode
connect:to:format:
setListenerPosition:
setListenerVectorOrientation:
stop
isRunning
obstruction
setObstruction:
occlusion
setOcclusion:
defaultAuthoringDisplayMask
_initWithEngineContext:
mutableCopyWithZone:
cameraAutomaticTargetPoint
selectedItems
boundingRectWithSize:options:attributes:context:
initWithString:attributes:
drawAtPoint:
bezierPathWithOvalInRect:
fill
beginEditingNodes:
orderedSetWithArray:
_updateManipulatorTargets
selectedNodes
selectionIsReadonly
setSelectionIsReadonly:
manipulator
cancelEdition
beginEditingNode:
saveInitialSelection
drawLineFromPoint:toPoint:color:
drawString:atPoint:color:
isEditingSubComponent
setShouldSnapOnGrid:
setShouldSnapToAlign:
setEditingSpace:
graphicalSelectionEnabled
setGraphicalSelectionEnabled:
surroundToSelect
setSurroundToSelect:
selecting
_sceneRenderer
_noColorProgram
_colorOnlyProgram
_colorAndTextureProgram
_lightProbesProgram
_wireframeProgram
_logsInfo
_boldLogsInfo
_upArrowInfo
_xyQuadrantInfo
_xyQuadrantRingInfo
_dynamicLinesInfo
_dynamicTrianglesInfo
_overlayDynamicLinesInfo
_overlayDynamicTriangleInfo
_textInfo
_lightProbesInfo
_normalTextInfo
_boldTextInfo
_depthOnCullOnStates
_depthOffCullOnStates
_depthOnCullOffStates
_depthOffCullOffStates
_arrowIndicesOffset
_arrowIndicesCount
_quadrantIndicesOffset
_quadrantIndicesCount
_quadrantRingIndicesOffset
_quadrantRingIndicesCount
_authoringDisplayMask
_hasLighting
_shouldSnapOnGrid
_shouldSnapToAlign
_selectionIsReadonly
_editingSpace
_graphicalSelectionEnabled
_selectionP0
_selectionP1
_selecting
_surroundToSelect
_initialSelection
_selectedNodes
_lastGridDistance
_gridUnit
_visibleManipulableItems
_wireframeRenderer
_statisticsInfo
_drawScale
_manipulator
_pass
_authEnv2
firstIndex
indexGreaterThanIndex:
fontWithName:size:
stringFromByteCount:
setEnableFreeCamera:
view
freeCamera
enableFreeCamera
autoSwitchToFreeCamera
setAutoSwitchToFreeCamera:
activateFreeCamera
_view
_enableFreeCamera
_autoSwitchToFreeCamera
invalidateCameraTarget
setAutomaticCameraTarget:
_stopInertiaIfNeeded
_switchToFreeViewCamera
setCameraTarget:
frontVector
_browseScale
_resetFreeViewCamera
_prepareFreeViewCamera
updateBrowseScaleFactor
_freeCameraActivated
_installFreeViewCameraIfNeeded
computeAutomaticTargetPoint
viewedObjectSphere
cameraTarget
zoomBy:animate:
_translationCoef
focusNode:
_resetBrowseScaleFactor
_rotateWithDrag:mode:stickyAxis:
_onInertiaTimer
computeBoundingSphereOmittingFloorsForNode:sphere:
frontVectorWithPointOfView:
matrixWithNoRoll:
setMinimumPressDuration:
setNumberOfTapsRequired:
_handlePinch:
addTarget:action:
_handlePan:
_handlePress:
_handleRotation:
_handleDoubleTap:
setDelaysTouchesBegan:
setCancelsTouchesInView:
beginGesture:
pinchWithGestureRecognizer:
panWithGestureRecognizer:
rotateWithGestureRecognizer:
numberOfTouches
locationOfTouch:inView:
_startBrowsingIfNeeded:
_beginTranslateAtLocation:
setZoomFactor:
state
velocityInView:
endDraggingWithVelocity:
translationInView:
setTranslation:inView:
_translateTo:
allowsTranslation
setAllowsTranslation:
enableInertia
setEnableInertia:
gimbalLockMode
setGimbalLockMode:
gimbalLockVector
setGimbalLockVector:
automaticCameraTarget
stickyAxis
setStickyAxis:
rotateOf:
zoomBy:
zoomFactor
translateByX:Y:Z:
rotateWithVector:mode:
clearRoll
gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:
gestureRecognizerShouldBegin:
_freeViewCameraNode
_initialPoint
_initialMatrix
_initialZoom
_originalFovX
_originalFovY
_originalOrthoScale
_zoomFactor
_clickOrigin
_lastGestureFingerCount
_isDraggingWithOneFinger
_roll
_initialMatrixForRoll
_pressGesture
_tapGesture
_pinchGesture
_panGesture
_rotateGesture
_stickyAxis
_viewedObjectSphere
_isViewedObjectSphereComputed
_hasAutomaticCameraTarget
_automaticCameraTargetUpToDate
_inertia
_didEverFocusNode
_allowsTranslation
_pinchShouldMoveCamera
_alternateMode
_upDirIsSet
_gimbalLockMode
_inertiaRunning
_browseMode
_upDir
_cameraTarget
_autoCameraTarget
_browseScaleFactor
_totalDragWithInertia
_inertiaVelocity
_lastSimulationTime
prefersGL3
supportsMetal
rendererContextForTextureSourceWithEngineContext:
_textureWithEngineContext:textureSampler:nextFrameTime:
textureSize
renderWithEngineContext:nextFrameTime:
MTLTextureCache
setMTLTextureCache:
glTextureCache
setGlTextureCache:
_mtlTextureCache
_glTextureCache
isPremultiplied
_layer
_createFramebufferWithEngineContext:size:
__prepareFramebufferWithSize:withEngineContext:textureSampler:needsStencil:
_buildMipmaps:
_bindFramebuffer:
_unbindFramebuffer:
_usesIOSurface
_framebufferSize
_framebuffer
sourceRendererForEngineContext:source:textureSource:
__renderLayer:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
anchorPoint
beginFrameAtTime:timeStamp:
updateBounds
endFrame
addUpdateRect:
__updateTextureWithLayer:engineContext:sampler:
_nextUpdateDate
rendererOptions
rendererWithEAGLContext:options:
rendererDidChange:
_registry
drawInContext:atTime:
needsUpdate
contentSize
__updateTextureWithDelegate:engineContext:
__renderSKScene:withSKSCNRenderer:engineContext:viewport:atTime:
renderToFramebuffer:shouldClear:
__updateTextureWithSKScene:engineContext:sampler:
contentsScale
writeToURL:options:
minimumLinearLimit
setMinimumLinearLimit:
maximumLinearLimit
setMaximumLinearLimit:
minimumAngularLimit
setMinimumAngularLimit:
maximumAngularLimit
setMaximumAngularLimit:
motorTargetLinearVelocity
setMotorTargetLinearVelocity:
motorMaximumForce
setMotorMaximumForce:
motorTargetAngularVelocity
setMotorTargetAngularVelocity:
motorMaximumTorque
setMotorMaximumTorque:
debugQuickLookObjectWithPointOfView:
offscreenRendererWithDevice:size:
debugQuickLookObject
debugQuickLookData
initWithContentsOfURL:options:error:
setFrame:
SCNJSExportProtocol
imageWithContentsOfFile:
imageWithURL:
imageWithPath:
vector3
vector4
matrix4
valueWithVector3:
valueWithVector4:
valueWithMatrix4:
color::::
toDouble
valueWithObject:inContext:
valueWithVector4:inContext:
valueWithVector3:inContext:
valueWithTransform3D:inContext:
toVector4
toVector3
toTransform3D
toBool
setValue:forProperty:
setPath:
handleBindingOfBufferNamed:frequency:usingBlock:
setSemantic:forSymbol:options:
semanticForSymbol:
vertexShader
fragmentShader
tessellationControlShader
setTessellationControlShader:
tessellationEvaluationShader
setTessellationEvaluationShader:
geometryShader
setGeometryShader:
vertexFunctionName
setVertexFunctionName:
fragmentFunctionName
setFragmentFunctionName:
setLibrary:
weightAtTargetIndex:
setWeight:atTargetIndex:
screenSpaceRadius
worldSpaceDistance
levelOfDetailWithGeometry:screenSpaceRadius:
levelOfDetailWithGeometry:worldSpaceDistance:
influenceFactor
setInfluenceFactor:
applyEngineForce:forWheelAtIndex:
setSteeringAngle:forWheelAtIndex:
applyBrakingForce:forWheelAtIndex:
speedInKilometersPerHour
wheels
chassisBody
vehicleWithChassisBody:wheels:
gimbalLockEnabled
setGimbalLockEnabled:
lookAtConstraintWithTarget:
extrusionDepth
setExtrusionDepth:
chamferMode
setChamferMode:
chamferProfile
setChamferProfile:
shapeWithPath:extrusionDepth:
initWithChainRootNode:
setMaxAllowedRotationAngle:forJoint:
maxAllowedRotationAngleForJoint:
chainRootNode
targetPosition
setTargetPosition:
inverseKinematicsConstraintWithChainRootNode:
transformConstraintInWorldSpace:withBlock:
font
setFont:
isWrapped
setWrapped:
containerFrame
setContainerFrame:
textSize
truncationMode
setTruncationMode:
alignmentMode
setAlignmentMode:
textWithString:extrusionDepth:
valueForProperty:
isUndefined
_hasFired
numberWithChar:
numberWithUnsignedChar:
charValue
unsignedCharValue
numberWithUnsignedShort:
capitalizedString
componentsSeparatedByString:
shortValue
unsignedShortValue
_initializeWheelsArray
initWithChassisBody:wheels:
_createWheel:
wheelAtIndex:
_customDecodingOfSCNPhysicsVehicle:
_chassisBody
_wheels
_speedKmHour
copyTo:
setConstraintRef:
finalizeDecodeConstraint:
_constraintRef
_influenceFactor
initWithTarget:
_customEncodingOfSCNLookAtConstraint:
_customDecodingOfSCNLookAtConstraint:
_gimbalLockEnabled
setFreeAxes:
freeAxes
billboardConstraint
_freeAxes
constantScaleConstraint
initInWorld:withBlock:
joint
setJoint:
maxAllowedRotationAngle
setMaxAllowedRotationAngle:
setChainRootNode:
jointForNode:
_customEncodingOfSCNIKConstraint:
_customDecodingOfSCNIKConstraint:
_didDecodeSCNIKConstraint:
_chainRootNode
_ikTarget
_jointsPerNode
unsignedIntValue
raise:format:
_repeatedAction
frequency
setFrequency:
_frequency
setSemantic:
infoWithSemantic:options:
postNotificationName:object:userInfo:
setSemanticInfos:
_customEncodingOfSCNProgram:
_customDecodingOfSCNProgram:
programWithLibrary:
shadingLanguage
_optionsForSymbol:
_allSymbolsWithSceneKitSemantic
_bufferBindings
setSemantic:forSymbol:
_vertexShader
_fragmentShader
_vertexFunctionName
_fragmentFunctionName
_semanticInfos
_opaque
_library
_stopObservingProgram
_programDidChange:
_setC3DProgram
_startObservingProgram
owner
initWithDictionary:copyItems:
_shaderModifiersDidChange
userInfo
_updateC3DProgramInputForSymbol:
_programFromPassAtIndex:
_updateC3DProgramInput:forSymbol:
_updateAllC3DProgramInputs
_setC3DProgramDelegate
_customEncodingOfSCNShadableHelper:
_customDecodingOfSCNShadableHelper:
_didDecodeSCNShadableHelper:
_bindValueForSymbol:atLocation:programID:node:renderer:
_unbindValueForSymbol:atLocation:programID:node:renderer:
_shaderModifiers
_symbolToBinder
_symbolToUnbinder
issueWithShadable:entryPoint:effectiveModifier:message:type:
shadable
entryPoint
effectiveModifier
message
_shadable
_entryPoint
_effectiveModifier
_message
stringWithContentsOfFile:encoding:error:
program:handleError:
initPresentationTextGeometryWithTextGeometryRef:
initWithTextGeometryRef:
params
_customEncodingOfSCNText:
_customDecodingOfSCNText:
setDiscretizedStraightLineMaxLength:
CGRectValue
set_wantsSeparateGeometryElements:
text
_wantsSeparateGeometryElements
discretizedStraightLineMaxLength
_flatness
_chamferRadius
_extrusionDepth
_discretizedStraightLineMaxLength
_chamferProfile
_string
_font
_wrapped
_alignmentMode
_truncationMode
_useCustomContainerFrame
_customContainerFrame
__wantsSeparateGeometryElements
initPresentationShapeGeometryWithShapeGeometryRef:
initWithShapeGeometryRef:
_customEncodingOfSCNShape:
_customDecodingOfSCNShape:
_chamferMode
systemFontOfSize:
setAlignment:
setLineBreakMode:
attribute:atIndex:effectiveRange:
_setupWithGeometry:thresholdMode:value:
initWithGeometry:thresholdMode:lod:
_customEncodingOfSCNLevelOfDetail:
_didDecodeSCNLevelOfDetail:
initWithGeometry:thresholdMode:thresholdValue:
_lod
_mode
SCN3DDisplayRenderingTechnique
SCNStereoscopicRenderingTechnique
SCNHeadMountedDisplayRenderingTechnique
SCNActionHide
/////////"2
SCNModelIO
SceneKitAdditions
SCNAudioPlayer
SCNAudioSource
NSCopying
NSSecureCoding
NSCoding
SCNRenderTargetRegistry
SCNRenderContextOpenGL
SCNPhysicsField
SCNPhysicsLinearGravityField
SCNPhysicsRadialGravityField
SCNPhysicsSpringField
SCNPhysicsMagneticField
SCNPhysicsElectricField
SCNPhysicsDragField
SCNPhysicsCustomField
SCNPhysicsVortexField
SCNPhysicsNoiseField
SCNPhysicsTurbulenceField
SCNJitterer
SCNPhysicsHingeJoint
SCNManipulator
SCNPhysicsContact
C3DAnimationBinding
SCNActionRunBlock
SCNRenderTarget
SCNActionPlaySound
SCNTechnique
SCNAnimatable
NSObject
SCNPhysicsShape
SCNActionWait
SCNPhysicsCharacter
SCNReferenceNode
SCNNodeReference
SCNAnimationReference
SCNActionReference
SCNPhysicsBehavior
SCNExtensions
SCNActionPerformSelector
SCNAction
Internal
SCNActionTargetState
SCNSpriteKitEventHandler
SCNActionJavaScript
SCNManipulableItem
SCNNodeManipulableItem
SCNPhysicsBody
SCNActionRunAction
SCNActionFade
SCNPhysicsWorld
SCNAdditions
Core3DKitAdditions
SCNLight
SCNTechniqueSupport
SCNMaterial
SCNShadable
SCNParticleSystem
SCNNodeComponent
SCNNode
SCNActionable
SCNBoundingVolume
SCNScene
SCNRendererTransitionContext
SCNRenderer
SCNSceneRenderer
SCNOffscreenRenderer
SCNDeepCopy
SCNOrderedDictionary
SCN_CAKeyframeAnimation
SCNAnimationEvent
SCNAddition
SCNSceneSource
SCNKeyedUnarchiver
SCNKeyedArchiver
SCNRenderContextImp
SCNRenderContext
SCNHitTestResult
SCNAuthoringEnvironment2
SCNFloor
SCNCamera
SCNMaterialAttachment
SCNMaterialProperty
SCNGeometry
SCNMutableGeometry
SCNAssetCatalog
SCNSceneDatabase
SCNSceneLookUpUnarchiver
SCNParticlePropertyController
SCNSkinner
SCNDisplayLink
C3DIONSZipFileArchive
SCNPhysicsBallSocketJoint
SCNUtils
SCNPhysicsVehicleWheel
C3DBinding
SCNPlane
SCNBox
SCNPyramid
SCNSphere
SCNCylinder
SCNCone
SCNTube
SCNCapsule
SCNTorus
SCNActionCustom
SCNView
SCNCommonProfileProgramCache
SCNCommonProfileProgramGenerator
SCNCommonProfileProgramGeneratorGL
_C3DProgressDebugger
SCNMorpher
SCNBoundingBox
SCNBoundingSphere
SCNActionSequence
_SCNUIKitSourceRegistry
_SCNUIApplicationObserver
_SCNSnapshotWindow
SCNUIKitSource
SCNTextureUIKitSource
SCNActionMove
SCNTransaction
SCNGeometrySource
SCNMutableGeometrySource
SCNGeometryElement
AVAudio3DMixing
SCNAuthoringEnvironment
SCNEventHandler
SCNCameraControlEventHandler
SCNActionRotate
SCNTextureSource
SCNImageSource
SCNLayerSource
SCNTextureOffscreenRenderingSource
SCNTextureLayerSource
SCNSourceRendererRegistry
SCNDelegateSource
SCNTextureDelegateSource
SCNSpriteKitSource
SCNTextureSpriteKitSource
SCNExportAddition
SCNPhysicsSliderJoint
SCN_DTAdditions
SCNActionScale
SCNActionGroup
SCNJSLayerJSExport
JSExport
SCN_JSSupport
SCNJSImageJSExport
SCNJSImage
SCNJSValueSExport
SCNJSValue
SCNJSExtensions
SCNJSValueTmpImp
SCNMaterialPropertyJSExport
SCNBoundingBoxJSExport
SCNBoundingSphereJSExport
SCNTransactionJSExport
SCNColorJSExport
SCNJSBasicAnimationJSExport
SCNJSAnimationGroupJSExport
SCNJSKeyframeAnimationJSExport
SCNViewJSExport
SCNPhysicsBehaviorJSExport
SCNParticlePropertyControllerJSExport
SCNPhysicsHingeJointJSExport
SCNPhysicsContactJSExport
SCNProgramJSExport
SCNTorusJSExport
SCNMorpherJSExport
SCNCapsuleJSExport
SCNLevelOfDetailJSExport
SCNRendererJSExport
SCNCylinderJSExport
SCNFloorJSExport
SCNNodeJSExport
SCNPlaneJSExport
SCNPhysicsBallSocketJointJSExport
SCNConeJSExport
SCNSphereJSExport
SCNGeometryJSExport
SCNConstraintJSExport
SCNPhysicsSliderJointJSExport
SCNLightJSExport
SCNMaterialJSExport
SCNParticleSystemJSExport
SCNHitTestResultJSExport
SCNPhysicsVehicleJSExport
SCNTubeJSExport
SCNLookAtConstraintJSExport
SCNPhysicsShapeJSExport
SCNGeometryElementJSExport
SCNGeometrySourceJSExport
SCNShapeJSExport
SCNSceneSourceJSExport
SCNPyramidJSExport
SCNCameraJSExport
SCNIKConstraintJSExport
SCNTechniqueJSExport
SCNPhysicsWorldJSExport
SCNPhysicsBodyJSExport
SCNBoxJSExport
SCNTransformConstraintJSExport
SCNAnimationEventJSExport
SCNActionJSExport
SCNSceneJSExport
SCNPhysicsVehicleWheelJSExport
SCNPhysicsFieldJSExport
SCNTextJSExport
SCNJSMediaTimingFunctionJSExport
SCNActionRemove
SCNPhysicsVehicle
SCNConstraint
SCNLookAtConstraint
SCNBillboardConstraint
SCNConstantScaleConstraint
SCNTransformConstraint
SCNIKJoint
SCNIKConstraint
SCNDeferredProgramGeneratorMetal
SCNActionRepeat
SCNBufferBinding
SCNProgramSemanticInfo
SCNProgram
SCNShadableHelper
_SCNShadableCompilationIssue
SCNText
SCNShape
SCNLevelOfDetail
d16@0:8
v24@0:8d16
@24@0:8q16
q16@0:8
@16@0:8
{CGPoint=dd}16@0:8
v32@0:8{CGPoint=dd}16
{SCNVector4=ffff}16@0:8
v32@0:8{SCNVector4=ffff}16
B16@0:8
@24@0:8@16
v24@0:8@16
@24@0:8^{_NSZone=}16
^{SCNCActionHide=^^?f@?@BdddddBB@?^{__CFString}qddddB}
@32@0:8@16@24
v64@0:8@16@24B32B36f40f44@?48@?56
@72@0:8@16@24@32@?40@48@56@64
v48@0:8@?16@?24@32@40
v16@0:8
v24@0:8^{__C3DNode=}16
^{__C3DNode=}16@0:8
r^v16@0:8
@?16@0:8
v24@0:8@?16
^{__C3DScene=}16@0:8
v20@0:8B16
@"AVAudioNode"
@"AVAudioPlayerNode"
@"SCNAudioSource"
^{__C3DNode=}
^{__C3DScene=}
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
f16@0:8
v20@0:8f16
@"AVAudioFile"
@"AVAudioPCMBuffer"
@"NSURL"
@"NSString"
@48@0:8{?=CCCb1b1b1b1b1[4C]}1624@32q40
v32@0:8@16q24
v20@0:8i16
@"<SCNRenderContext>"
@"NSMutableDictionary"
@"NSMutableArray"
@24@0:8@?16
@32@0:8d16d24
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}16@0:8
Q16@0:8
v24@0:8Q16
v24@0:8q16
{SCNVector3=fff}16@0:8
v28@0:8{SCNVector3=fff}16
{SCNVector3=fff}28@0:8{SCNVector3=fff}16
{SCNVector3="x"f"y"f"z"f}
@"SCNPhysicsWorld"
@"SCNNode"
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}
v32@0:8@16@24
@"<SCNJittererDelegate>"
@"NSObject<OS_dispatch_source>"
@80@0:8@16{SCNVector3=fff}24{SCNVector3=fff}36@48{SCNVector3=fff}56{SCNVector3=fff}68
@48@0:8@16{SCNVector3=fff}24{SCNVector3=fff}36
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"f"y"f"z"f}"anchorB"{SCNVector3="x"f"y"f"z"f}"axisA"{SCNVector3="x"f"y"f"z"f}"axisB"{SCNVector3="x"f"y"f"z"f}}
^{btHingeConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ff{btAngularLimit=fffffffB}ffffBBBBBfifff}
{SCNMatrix4=ffffffffffffffff}16@0:8
B88@0:8{?=@{CGPoint=dd}{CGPoint=dd}{SCNVector3=fff}{SCNVector3=fff}d}16
v32@0:8{__C3DQuaternion=ffff}16
v88@0:8{?=@{CGPoint=dd}{CGPoint=dd}{SCNVector3=fff}{SCNVector3=fff}d}16
r^{?=f^{__C3DNode}f}32@0:8Q16q24
v52@0:8S162036
104@0:816{SCNVector3=fff}32d44B525672^B88^q96
@"SCNAuthoringEnvironment"
@"NSOrderedSet"
(C3DMatrix4x4="components"[16f]"m"[4])
(?="axisMove"{?="selectedAxis"S"originalPosition""axisDirection""mouseDeltaVector"}"planeMove"{?="selectedPlane"S"originalPosition""planeNormal""pointInPlane""mouseDeltaVector"}"axisRotate"{?="selectedAxis"S"originalMouseLocation"{CGPoint="x"d"y"d}"rotationSign"f"originalRotation"{__C3DQuaternion="x"f"y"f"z"f"s"f}})
{?="positions"^"orientations"^{__C3DQuaternion}"originalLocalMatrix"^{SCNMatrix4}}
^{?=f^{__C3DNode}f}
@"NSMutableIndexSet"
@32@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24
v64@0:8@16@24{SCNVector3=fff}32{SCNVector3=fff}44d56
v40@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24r^{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}32
^{__C3DModelTarget={__CFRuntimeBase=Q[4C]I}^v^vss^?^?^?}
@32@0:8@?16@24
v32@0:8@16d24
@"NSObject<OS_dispatch_queue>"
@32@0:8^{?=CCCb1b1b1b1b1[4C]}1624
C16@0:8
B32@0:8^{?=CCCb1b1b1b1b1[4C]}1624
{?="format"C"sampleCount"C"textureUsage"C"renderToTexture"b1"forceTextureRect"b1"viewportDependant"b1"renderToIOSurface"b1"mipmapped"b1"padding"[4C]}
@"CIImage"
@28@0:8@16B24
^{SCNCPlaySound=^^?f@?@BdddddBB@?^{__CFString}qddddBB@}
@24@0:8^{__C3DFXTechnique=}16
v32@0:8@"CAAnimation"16@"NSString"24
v24@0:8@"NSString"16
@"CAAnimation"24@0:8@"NSString"16
B24@0:8@16
B24@0:8@"NSString"16
v32@0:8@"NSString"16d24
v32@0:8d16@24
v32@0:8d16@"NSString"24
@"NSArray"16@0:8
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8@"Protocol"16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
@"NSString"16@0:8
v32@0:8@16@?24
^{__C3DFXTechnique=}16@0:8
^{__C3DAnimationManager={__CFRuntimeBase=Q[4C]I}^{__C3DModelValueStorage}^{__CFDictionary}^{__CFDictionary}^{__CFSet}^{__CFArray}^{__CFArray}BBB^{_C3DAnimationPendingEvent}^{__C3DAllocator}^{__CFDictionary}^{__CFArray}ddd{_opaque_pthread_mutex_t=q[56c]}iiii}16@0:8
B32@0:8@16@24
v28@0:8B16@20
v48@0:8@16@24@32@40
^{__C3DAnimationChannel={__CFRuntimeBase=Q[4C]I}^{__C3DAnimation}^{__CFArray}^v^{__C3DModelTarget}^{__CFString}}32@0:8@16@24
v24@0:8^{__C3DEngineContext=}16
^{__C3DFXTechnique=}
@"SCNOrderedDictionary"
@32@0:8^v16@24
^{btCollisionShape=^^?i^v}16@0:8
@"NSDictionary"
@"NSArray"
^{btCollisionShape=^^?i^v}
@24@0:8d16
^{SCNCActionWait=^^?f@?@BdddddBB@?^{__CFString}qdddd}
{?="characterBody"@"SCNPhysicsBody""direction"{SCNVector3="x"f"y"f"z"f}"velocity"d"jumpSpeed"d}
^{btCharacterControllerInterface=^^?}
^{btPairCachingGhostObject=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btHashedOverlappingPairCache}}
^{btOverlapFilterCallback=^^?}
^{btCapsuleShape=^^?i^v{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffi}
@24@0:8i16i20
@20@0:8i16
@24@0:8Q16
@48@0:8d16d24d32d40
@36@0:8{SCNVector3=fff}16d28
@44@0:8d16{SCNVector3=fff}24d36
@40@0:8{SCNVector4=ffff}16d32
@52@0:8d16d24d32d40B48
@32@0:8@16Q24
@32@0:8@16d24
@32@0:8d16@?24
^{SCNCAction=^^?f@?@BdddddBB@?^{__CFString}qdddd}16@0:8
^{SCNCAction=^^?f@?@BdddddBB@?^{__CFString}qdddd}
v24@0:8^v16
d24@0:8d16
{SCNVector4="x"f"y"f"z"f"w"f}
@"SKScene"
@32@0:8d16@24
v80@0:8{SCNMatrix4=ffffffffffffffff}16
@32@0:8q16@24
^{btRigidBody=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffBfffffff^{btMotionState}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}ii{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ii}16@0:8
^{btCollisionShape=^^?i^v}32@0:8@16@24
v32@0:8{SCNVector3=fff}16B28
v44@0:8{SCNVector3=fff}16{SCNVector3=fff}28B40
v36@0:8{SCNVector4=ffff}16B32
@"SCNPhysicsShape"
^{btRigidBody=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffBfffffff^{btMotionState}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}ii{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ii}
@"SCNAction"
^{SCNCActionFade=^^?f@?@BdddddBB@?^{__CFString}qddddfffB}
@48@0:8{SCNVector3=fff}16{SCNVector3=fff}28@40
@56@0:8{btVector3=(?=[4f])}16{btVector3=(?=[4f])}32@48
@40@0:8@16@24@32
@160@0:8@16{SCNMatrix4=ffffffffffffffff}24{SCNMatrix4=ffffffffffffffff}88@152
^{c3dAether={vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}^^{c3dPhysicsField}{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}}}}16@0:8
^{btVehicleRaycaster=^^?}16@0:8
^{btDynamicsWorld=^^?{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btDispatcher}{btDispatcherInfo=fiifB^{btIDebugDraw}BBBfBf}^{btBroadphaseInterface}^{btIDebugDraw}B^?^?^v{btContactSolverInfo=fffffifffffiffffiiiff}f}16@0:8
v56@0:8@16^{__C3DNode=}24Q32Q40Q48
v32@0:8@16^v24
^{btDiscreteDynamicsWorld=^^?{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btDispatcher}{btDispatcherInfo=fiifB^{btIDebugDraw}BBBfBf}^{btBroadphaseInterface}^{btIDebugDraw}B^?^?^v{btContactSolverInfo=fffffifffffiffffiiiff}f{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}^{InplaceSolverIslandCallback}^{btConstraintSolver}^{btSimulationIslandManager}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}{btAlignedObjectArray<btRigidBody *>={btAlignedAllocator<btRigidBody *, 16>=}ii^^{btRigidBody}B}{btVector3=(?=[4f])}fBBBB{btAlignedObjectArray<btActionInterface *>={btAlignedAllocator<btActionInterface *, 16>=}ii^^{btActionInterface}B}i{btAlignedObjectArray<btPersistentManifold *>={btAlignedAllocator<btPersistentManifold *, 16>=}ii^^{btPersistentManifold}B}B}
^{btOverlappingPairCallback=^^?}
^{btVehicleRaycaster=^^?}
^{btC3DDebugDraw=^^?i^v}
{c3dAether="_fields"{vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >="__first_"^^{c3dPhysicsField}}}}
@"<SCNPhysicsContactDelegate>"
@"SCNPhysicsContact"
@"SCNScene"
@"NSMutableSet"
{C3DColor4=(?=[4f]{?=ffff})}28@0:8B16^B20
@24@0:8r^{C3DColor4=(?=[4f]{?=ffff})}16
@32@0:8{CGPoint=dd}16
@28@0:8{SCNVector3=fff}16
@32@0:8{SCNVector4=ffff}16
@80@0:8{SCNMatrix4=ffffffffffffffff}16
@24@0:8^{__C3DLight={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}{C3DColor4=(?=[4f]{?=ffff})}iffffffff{C3DColor4=(?=[4f]{?=ffff})}ffIQBb1b1b1b1b1b1ddd^{__C3DEffectSlot}^{__C3DEffectSlot}if^{__C3DFXTechnique}^v^{__CFData}}16
@"SCNTechnique"16@0:8
v24@0:8@"SCNTechnique"16
^{__C3DLight={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}{C3DColor4=(?=[4f]{?=ffff})}iffffffff{C3DColor4=(?=[4f]{?=ffff})}ffIQBb1b1b1b1b1b1ddd^{__C3DEffectSlot}^{__C3DEffectSlot}if^{__C3DFXTechnique}^v^{__CFData}}16@0:8
v48@0:8@16@24@32^v40
{CGSize=dd}16@0:8
v32@0:8{CGSize=dd}16
^{__C3DLight={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}{C3DColor4=(?=[4f]{?=ffff})}iffffffff{C3DColor4=(?=[4f]{?=ffff})}ffIQBb1b1b1b1b1b1ddd^{__C3DEffectSlot}^{__C3DEffectSlot}if^{__C3DFXTechnique}^v^{__CFData}}
{CGSize="width"d"height"d}
@"SCNMaterialProperty"
@"SCNTechnique"
@"NSData"
@"<MTLTexture>"
@24@0:8^{__C3DMaterial=}16
v32@0:8@"NSString"16@?<v@?II@"SCNNode"@"SCNRenderer">24
@"SCNProgram"16@0:8
v24@0:8@"SCNProgram"16
@"NSDictionary"16@0:8
v24@0:8@"NSDictionary"16
^{__C3DMaterial=}16@0:8
^{__C3DEffectCommonProfile={__CFRuntimeBase=Q[4C]I}^{__C3DMaterial}i^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}fffffcqBBb1b1b1b1b1b1b1b1b1b13}16@0:8
v24@0:8^@16
@24@0:8^@16
^{__C3DMaterial=}
@"SCNShadableHelper"
@24@0:8^{__C3DParticleSystem=}16
^{__C3DParticleSystem=}16@0:8
s24@0:8@16
v40@0:8q16@24@?32
v40@0:8@16q24@?32
^{__C3DParticleSystem=}
@"SCNGeometry"
@"UIColor"
@"SCNParticleSystem"
@"SCNNodeComponent"
@24@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}16
v24@0:8@"SCNAction"16
v32@0:8@"SCNAction"16@?<v@?>24
v32@0:8@"SCNAction"16@"NSString"24
v40@0:8@16@24@?32
v40@0:8@"SCNAction"16@"NSString"24@?<v@?>32
@"SCNAction"24@0:8@"NSString"16
B32@0:8^{SCNVector3=fff}16^{SCNVector3=fff}24
v32@0:8^{SCNVector3=fff}16^{SCNVector3=fff}24
B32@0:8^{SCNVector3=fff}16^d24
B36@0:8@?16B24@28
@28@0:8@?16B24
B24@0:8@?16
v36@0:8#16@24B32
@28@0:8#16B24
^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}16@0:8
B48@0:8@16@24^@32^@40
v32@0:8@16Q24
v32@0:8Q16@24
Q24@0:8@16
B40@0:8^{C3DPlane=(?={?=ffff})}1624
v24@0:8^{__C3DParticleSystem=}16
{SCNVector3=fff}36@0:8{SCNVector3=fff}16@28
{SCNMatrix4=ffffffffffffffff}88@0:8{SCNMatrix4=ffffffffffffffff}16@80
^{__C3DNode={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DNode}^{__C3DNode}^{__C3DNode}{?={?=SS}I}^{?}^{__C3DGeometry}b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1QB^{__C3DTransforms}(C3DMatrix4x4=[16f][4])ff{__C3DAABB=}}
{SCNMatrix4="m11"f"m12"f"m13"f"m14"f"m21"f"m22"f"m23"f"m24"f"m31"f"m32"f"m33"f"m34"f"m41"f"m42"f"m43"f"m44"f}
^{SCNVector3=fff}
@40@0:8@16@24^@32
@40@0:8@16q24@32
@24@0:8^{__C3DScene=}16
:16@0:8
v28@0:8@16i24
@20@0:8B16
B48@0:8@16@24@32@?40
v40@0:8@16@24@32
v88@0:8@16{SCNMatrix4=ffffffffffffffff}24
@"SCNSceneSource"
[4@"SCNNode"]
^{__C3DFXPass=}16@0:8
@60@0:8i16@20{CGSize=dd}28@44@52
@"SKTransition"
^{__C3DFXPass=}
[2@"SCNOffscreenRenderer"]
v48@0:8@16@24@32@?40
v48@0:8@"SCNScene"16@"SKTransition"24@"SCNNode"32@?<v@?>40
@40@0:8{CGPoint=dd}16@32
@"NSArray"40@0:8{CGPoint=dd}16@"NSDictionary"32
B32@0:8@"SCNNode"16@"SCNNode"24
@"NSArray"24@0:8@"SCNNode"16
B32@0:8@16@?24
B32@0:8@16@?<B@?>24
v32@0:8@"NSArray"16@?<v@?B>24
@"SCNScene"16@0:8
v24@0:8@"SCNScene"16
@"<SCNSceneRendererDelegate>"16@0:8
v24@0:8@"<SCNSceneRendererDelegate>"16
@"SCNNode"16@0:8
v24@0:8@"SCNNode"16
@"SKScene"16@0:8
v24@0:8@"SKScene"16
^v16@0:8
@"AVAudioEngine"16@0:8
@"AVAudioEnvironmentNode"16@0:8
@56@0:8@16B24@28B36^v40Q48
^{__C3DEngineContext=}16@0:8
^{__C3DRendererContext={__CFRuntimeBase=Q[4C]I}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBBI^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}{Cache=[8I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^vii}{?=[2I][5i][11{?=iII}][11I]^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16@0:8
v48@0:8^{SCNVector3=fff}16Q24{CGSize=dd}32
{SCNVector3=fff}44@0:8{SCNVector3=fff}16{CGSize=dd}28
v32@0:8^{__C3DScene=}16^{__C3DRendererContext={__CFRuntimeBase=Q[4C]I}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBBI^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}{Cache=[8I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^vii}{?=[2I][5i][11{?=iII}][11I]^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}24
@56@0:8{CGPoint=dd}16{CGSize=dd}32@48
B48@0:8@16@24{CGSize=dd}32
@40@0:8@16{CGSize=dd}24
v32@0:8^{__C3DEngineContext=}16d24
B24@0:8^{__C3DScene=}16
v24@0:8^{__C3DScene=}16
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64
v88@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72@80
v80@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72
^{CGImage=}24@0:8d16
@48@0:8d16{CGSize=dd}24Q40
@32@0:8{CGSize=dd}16
^{CGImage=}32@0:8{CGSize=dd}16
@40@0:8{CGSize=dd}16@32
v40@0:8Q16B24B28@32
@"NSLock"
{?="frameBuffer"^{__C3DFramebuffer}"multisamplingFrameBuffer"^{__C3DFramebuffer}"drawableSize"{CGSize="width"d"height"d}}
@"SCNRendererTransitionContext"
^{__C3DEngineContext=}
@"EAGLContext"
{C3DColor4=""(?="rgba"[4f]""{?="r"f"g"f"b"f"a"f})}
@"SCNRenderer"
@"<SCNSceneRenderer>"
@"__SKSCNRenderer"
I16@0:8
v32@0:8^?16^v24
^{__C3DKeyframedAnimation={__C3DAnimation={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}df^{__C3DTimingFunction}b1b1b1b1b1b1b2b1b1b1b1b1dddfff^?^v^v^v^{__C3DAnimationEvents}{?=^?^?}}^{__C3DKeyframeController}}16@0:8
v24@0:8^{__C3DKeyframedAnimation={__C3DAnimation={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}df^{__C3DTimingFunction}b1b1b1b1b1b1b2b1b1b1b1b1dddfff^?^v^v^v^{__C3DAnimationEvents}{?=^?^?}}^{__C3DKeyframeController}}16
^{__C3DKeyframedAnimation={__C3DAnimation={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}df^{__C3DTimingFunction}b1b1b1b1b1b1b2b1b1b1b1b1dddfff^?^v^v^v^{__C3DAnimationEvents}{?=^?^?}}^{__C3DKeyframeController}}
B36@0:8d16B24^v28
@32@0:8Q16@24
@40@0:8Q16@24^@32
^{__C3DScene=}32@0:8@16@?24
@40@0:8#16@24@?32
@32@0:8@16@?24
@40@0:8#16@24^@32
@32@0:8@16^@24
^{__C3DSceneSource=}16@0:8
^{__C3DLibrary=}16@0:8
@32@0:8@16#24
@24@0:8#16
B48@0:8@16Q24@?32@?40
^{__C3DSceneSource=}
@"NSOperationQueue"
@"SCNAssetCatalog"
B36@0:8^{__C3DFXPass={__CFRuntimeBase=Q[4C]I}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}{?=b1BC}}16Q24B32
v32@0:8{C3DColor4=(?=[4f]{?=ffff})}16
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}16@0:8
@24@0:8^{__C3DEffectSlot={__CFRuntimeBase=Q[4C]I}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1i^{__C3DTextureSampler}^{__C3DTransforms}fi^v}16
v24@0:8^{?=^{__C3DEnginePipeline}^{__C3DEngineContext}^{__C3DFXPassInstance}^i^{__C3DNode}BB}16
v24@0:8^{__C3DRendererElement=}16
v32@0:8^{__C3DRendererElement=}16^{__C3DFXPass={__CFRuntimeBase=Q[4C]I}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}{?=b1BC}}24
B32@0:8^{__C3DMesh=}16q24
v24@0:8^{__C3DMesh=}16
^{__C3DMeshElement=}36@0:8c16q20q28
v32@0:8^{__C3DEffectSlot={__CFRuntimeBase=Q[4C]I}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1i^{__C3DTextureSampler}^{__C3DTransforms}fi^v}16^{__C3DEngineContext=}24
v148@0:8^{__C3DMesh=}16^{__C3DMeshElement=}24^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}ib1b1^{__C3DFXProgramDelegate}}32^{__C3DEngineContext=}40(C3DMatrix4x4=[16f][4])48r^{C3DColor4=(?=[4f]{?=ffff})}112^{__C3DRasterizerStates=}120^{__C3DBlendStates=}128^{__C3DImage=}136B144
v24@0:8^{__C3DFXPass={__CFRuntimeBase=Q[4C]I}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}{?=b1BC}}16
v36@0:8^{__C3DNode=}16i24^{__C3DLightRuntimeData=If(C3DMatrix4x4=[16f][4])^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}28
i16@0:8
@"SCNRenderTargetRegistry"16@0:8
@"<SCNResourceManager>"16@0:8
v32@0:8^{__C3DRendererElement=}16^{?=^{__C3DEnginePipeline}^{__C3DEngineContext}^{__C3DFXPassInstance}^i^{__C3DNode}BB}24
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}
@"SCNRenderTargetRegistry"
@24@0:8^{__CFArray=}16
@24@0:8^{__C3DHitTestResult=}16
{CGPoint=dd}24@0:8q16
^{__C3DHitTestResult=}
v44@0:8@16@24@32f40
B32@0:8{CGPoint=dd}16
^{__CFDictionary=}
@40@0:8d16d24@32
@56@0:8d16d24d32d40@48
@48@0:8d16d24d32@40
^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}ffffifffQ}16@0:8
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}16@0:8
@24@0:8^{__C3DCamera={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}{?=b1b1b1b1dddddd(C3DMatrix4x4=[16f][4])}ffffb1b1b1(C3DMatrix4x4=[16f][4])ffffffffffffffffff{?=ffff}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}{?=b1b1b1b1dddddd(C3DMatrix4x4=[16f][4])}ffffb1b1b1(C3DMatrix4x4=[16f][4])ffffffffffffffffff{?=ffff}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}16@0:8
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}{?=b1b1b1b1dddddd(C3DMatrix4x4=[16f][4])}ffffb1b1b1(C3DMatrix4x4=[16f][4])ffffffffffffffffff{?=ffff}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}
{?="amount"f"radius"f"strength"f"falloff"f}
v20@0:8I16
^{__C3DImage=}32@0:8@16Q24
^{__C3DImage=}28@0:8@16i24
^{__C3DImage=}24@0:8@16
@24@0:8^{__C3DImage=}16
@28@0:8@16i24
^{__C3DEffectSlot={__CFRuntimeBase=Q[4C]I}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1i^{__C3DTextureSampler}^{__C3DTransforms}fi^v}20@0:8B16
v24@0:8^{__C3DImage=}16
^{__C3DImage=}16@0:8
{C3DColor4=(?=[4f]{?=ffff})}16@0:8
^{__C3DEffectSlot={__CFRuntimeBase=Q[4C]I}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1i^{__C3DTextureSampler}^{__C3DTransforms}fi^v}16@0:8
^{__C3DTextureSampler={__CFRuntimeBase=Q[4C]I}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}16@0:8
v80@0:8(C3DMatrix4x4=[16f][4])16
^{__C3DEffectSlot={__CFRuntimeBase=Q[4C]I}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1i^{__C3DTextureSampler}^{__C3DTransforms}fi^v}
^{__C3DImage=}
^{__C3DTextureProxy=}
^{SCNMatrix4=ffffffffffffffff}
@24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}16
v24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}16
{?=BCCC}16@0:8
v20@0:8{?=BCCC}16
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}
@"SCNGeometrySource"
@"SCNGeometryElement"
{?="enableVertexWeldingAtImport"B"boundaryInterpolationRule"C"faceVaryingInterpolationRule"C"normalSmoothingMode"C}
v40@0:8@16@24#32
@"CAAnimation"
@24@0:8^{__C3DSkinner=}16
^{__C3DSkinner=}48@0:8@16@24@32@40
^{__C3DSkinner=}56@0:8q16@24@32@40@48
^{__C3DSkinner=}40@0:8@16Q24Q32
@56@0:8@16@24@32@40@48
@112@0:8@16@24@32@40{SCNMatrix4=ffffffffffffffff}48
^{__C3DSkinner=}16@0:8
^{__C3DSkinner=}
@40@0:8@16@24@?32
B36@0:8B16d20d28
@"CADisplayLink"
@40@0:8@16Q24^@32
@48@0:8@16@24@32Q40
@40@0:8@16@24Q32
B48@0:8@16@24Q32^@40
B40@0:8@16Q24^@32
{__zFlags="providerSuppliesContents"b1"providerSuppliesStreams"b1"providerSuppliesProperties"b1"noContentsCaching"b1"fileOpen"b1"reserved"b27}
[5^v]
@56@0:8@16{SCNVector3=fff}24@36{SCNVector3=fff}44
@36@0:8@16{SCNVector3=fff}24
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"f"y"f"z"f}"anchorB"{SCNVector3="x"f"y"f"z"f}}
^{btPoint2PointConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btVector3=(?=[4f])}{btVector3=(?=[4f])}iffB{btConstraintSetting=fff}}
@"SCNPhysicsVehicle"
@24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
v24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
@40@0:8d16d24d32
^{SCNCActionCustom=^^?f@?@BdddddBB@?^{__CFString}qdddd@?}
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
v28@0:8@16B24
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@"SCNDisplayLink"
@"SCNJitterer"
@"NSRecursiveLock"
@"SCNEventHandler"
@"SCNSpriteKitEventHandler"
^{__C3DFXProgram=}
^{__CFSet=}
^{__C3DFXProgram=}40@0:8^{__C3DRendererElementProgramHashCode=}16@24^v32
{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}
^{__C3DFXProgram=}32@0:8^{__C3DRendererElementProgramHashCode=}16^v24
@24@0:8^{__C3DMorph=}16
^{__C3DMorph=}16@0:8
v32@0:8d16Q24
d24@0:8Q16
^{__C3DMorph=}
^{SCNCActionSequence=^^?f@?@BdddddBB@?^{__CFString}qdddd{vector<SCNCAction *, std::__1::allocator<SCNCAction *> >=^^{SCNCAction}^^{SCNCAction}{__compressed_pair<SCNCAction **, std::__1::allocator<SCNCAction *> >=^^{SCNCAction}}}Qd}
@48@0:8{CGPoint=dd}16@32@40
{CGPoint=dd}40@0:8{CGPoint=dd}16^B32
{CGPoint=dd}32@0:8{CGPoint=dd}16
v24@0:8^{__C3DRendererContext={__CFRuntimeBase=Q[4C]I}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBBI^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}{Cache=[8I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^vii}{?=[2I][5i][11{?=iII}][11I]^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16
^{__C3DTexture=}40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=Q[4C]I}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
^{__C3DTextureSampler={__CFRuntimeBase=Q[4C]I}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}
^{SCNCActionMove=^^?f@?@BdddddBB@?^{__CFString}qdddddBB}
v40@0:8^v16@24@?32
v48@0:8^v16@24@32@?40
@24@0:8^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16
@32@0:8r^d16q24
@40@0:8r^{SCNVector3=fff}16q24^q32
@40@0:8r^{CGPoint=dd}16q24^q32
@76@0:8@16@24q32B40q44q52q60q68
@68@0:8@16@24q32s40Q44q52q60
@32@0:8r^{SCNVector3=fff}16q24
@32@0:8r^{CGPoint=dd}16q24
s16@0:8
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16@0:8
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}
@24@0:8^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}II^{__C3DMeshElement}CCC{?=c^{__CFData}I}{?=c^{__CFData}I}^v^{__C3DMeshSource}[2]}16
@48@0:8@16q24q32q40
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}II^{__C3DMeshElement}CCC{?=c^{__CFData}I}{?=c^{__CFData}I}^v^{__C3DMeshSource}[2]}16@0:8
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}II^{__C3DMeshElement}CCC{?=c^{__CFData}I}{?=c^{__CFData}I}^v^{__C3DMeshSource}[2]}
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@24@0:8^{__C3DEngineContext=}16
v48@0:8{SCNVector3=fff}16{SCNVector3=fff}28@40
v48@0:8@16{CGPoint=dd}24@40
^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}ib1b1^{__C3DFXProgramDelegate}}
{?="weakProgram"^{__C3DFXProgram}"baseIndex"I"baseVertex"I"vertexSize"I"allocatedVerticesSize"I"allocatedIndicesSize"I"textureImage"^{__C3DImage}"texture"^{__C3DTexture}"drawMode"I"orthographic"B"clearDepthBuffer"B"enableDepthTest"B"enableCulling"B"isDynamic"B"mesh"^{__C3DMesh}"meshElement"^{__C3DMeshElement}"_cache"{?="verticesStride"Q"colorsStride"Q"uvsStride"Q"verticesData"*"colorsData"*"uvsData"*}"_usedMeshes"@"NSMutableSet""_freeMeshes"@"NSMutableSet""_usedMeshElements"@"NSMutableSet""_freeMeshElements"@"NSMutableSet"}
{?="textureInfo"{?="texture"^{__C3DImage}"textureSize"{CGSize="width"d"height"d}"isRetina"B}"lineHeight"d"characterWidth_texture"s"characterWidth_typography"^d"characterHeight_texture"s"symbolRects"^{?}}
^{__C3DRasterizerStates=}
@"NSSet"
@"NSMutableOrderedSet"
{?="initialized"B"showFullStatistics"B"fps"f"waitDisplayLinkTime"f"pressedButtonIndex"q"fpsString"^{__CFString}"shortString"^{__CFString}"lightingStatistics"[9I]"stats"{__C3DEngineStats="verticesProcessed"I"primitivesProcessed"I"drawCount"I"drawStep"I"frameCount"I"fboSwitches"I"vboSwitches"I"attSwitches"I"attEnabling"I"iboSwitches"I"vaoSwitches"I"prgSwitches"I"texSwitches"I"rssSwitches"I"getCount"I"uniformFloatSent"I"uniformIntSent"I"uniformVector2Sent"I"uniformVector3Sent"I"uniformVector4Sent"I"uniformMatrix4Sent"I"vboUploaded"I"iboUploaded"I"texUploaded"I"cpuTime"d"cstrTime"d"phyTime"d"prtTime"d"animTime"d"skinTime"d"mrphTime"d"rendTime"d"twoDTime"d"delegateTime"d"glFlushTime"d"waitDisplayLinkTime"d"drawableWaitTime"d"lastDisplayLinkTime"d"prgCount"I"texCount"I"fboCount"I"vboCount"I"rboCount"I"iboCount"I"cboCount"I"vaoCount"I"fboMemory"I"rboMemory"I"vboMemory"I"iboMemory"I"cboMemory"I"texMemory"I"backBufferMemory"I"depthBuffersMemory"I"frmAvgTime"d"frmMinTime"d"frmMaxTime"d"frameTimeHistory"[60d]"frameTimeCurrentIndex"I"startTime"d"lastFrameTime"d}}
@"SCNManipulator"
^{__C3DFXPass={__CFRuntimeBase=Q[4C]I}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}{?=b1BC}}
@"SCNAuthoringEnvironment2"
@"SCNView"
24@0:8@16
{SCNMatrix4=ffffffffffffffff}80@0:8{SCNMatrix4=ffffffffffffffff}16
v24@0:8f16B20
v28@0:8f16f20f24
v40@0:816q32
B32@0:8^{__C3DNode=}16^{C3DSphere=}24
{C3DSphere=}16@0:8
16@0:8
v48@0:8{CGPoint=dd}16q32q40
{CGPoint="x"d"y"d}
@"UIGestureRecognizer"
{C3DSphere="vector"}
^{SCNCActionRotate=^^?f@?@BdddddBB@?^{__CFString}qddddf{__C3DQuaternion=ffff}{__C3DQuaternion=ffff}BBBBB}
v24@0:816
^{__C3DRendererContext={__CFRuntimeBase=Q[4C]I}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBBI^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}{Cache=[8I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^vii}{?=[2I][5i][11{?=iII}][11I]^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}24@0:8^{__C3DEngineContext=}16
v32@0:8^{__C3DEngineContext=}16^d24
v24@0:8^{__C3DImageProxy=}16
@"CALayer"
v40@0:8^{__C3DEngineContext=}16{CGSize=dd}24
^{__C3DTexture=}52@0:8{CGSize=dd}16^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=Q[4C]I}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40B48
^{__C3DFramebuffer=}
d76@0:8@16@24^{__C3DEngineContext=}3240d56B64^B68
d40@0:8@16^{__C3DEngineContext=}24^{__C3DTextureSampler={__CFRuntimeBase=Q[4C]I}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}32
@40@0:8^{__C3DEngineContext=}16@24@32
v32@0:8@16^{__C3DEngineContext=}24
v64@0:8@16@24^{__C3DEngineContext=}3240d56
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""axisA"{SCNVector3="x"f"y"f"z"f}"anchorA"{SCNVector3="x"f"y"f"z"f}"axisB"{SCNVector3="x"f"y"f"z"f}"anchorB"{SCNVector3="x"f"y"f"z"f}"minLinearLimit"d"maxLinearLimit"d"minAngularLimit"d"maxAngularLimit"d"motorTargetLinearVelocity"d"motorMaximumForce"d"motorTargetAngularVelocity"d"motorMaximumTorque"d}
^{btSliderConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}BB{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}BffffffffffffffffffffffffffffBBi[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3f][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]f{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffBfffBfff}
^{SCNCActionScale=^^?f@?@BdddddBB@?^{__CFString}qddddfffffBB}
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
@"CALayer"16@0:8
@24@0:8@"NSString"16
@40@0:8{SCNVector4=ffff}16@32
@36@0:8{SCNVector3=fff}16@28
@88@0:8{SCNMatrix4=ffffffffffffffff}16@80
v32@0:8@16@"NSString"24
@"CAMediaTimingFunction"16@0:8
v24@0:8@"CAMediaTimingFunction"16
@"UIColor"48@0:8d16d24d32d40
v24@0:8@"NSArray"16
^{CGPath=}16@0:8
v24@0:8^{CGPath=}16
@"CAAnimation"16@0:8
v24@0:8@"CAAnimation"16
@24@0:8@"CAAnimation"16
@"SCNPhysicsBody"16@0:8
@80@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24{SCNVector3=fff}36@"SCNPhysicsBody"48{SCNVector3=fff}56{SCNVector3=fff}68
@48@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24{SCNVector3=fff}36
v40@0:8@"NSString"16q24@?<v@?@"<SCNBufferStream>"@"SCNNode"@"<SCNShadable>"@"SCNRenderer">32
v40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@"NSString"24@0:8@"NSString"16
@"<SCNProgramDelegate>"16@0:8
v24@0:8@"<SCNProgramDelegate>"16
@"<MTLLibrary>"16@0:8
v24@0:8@"<MTLLibrary>"16
d24@0:8q16
v32@0:8d16q24
@"SCNMorpher"16@0:8
@"SCNGeometry"16@0:8
@32@0:8@"SCNGeometry"16d24
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@"<MTLCommandBuffer>"56@"MTLRenderPassDescriptor"64
v24@0:8@"SCNAudioPlayer"16
v32@0:8@"SCNNode"16Q24
v32@0:8@"SCNNode"16@"SCNNode"24
@"SCNNode"28@0:8@"NSString"16B24
@"NSArray"24@0:8@?<B@?@"SCNNode"^B>16
v24@0:8@?<v@?@"SCNNode"^B>16
{SCNVector3=fff}36@0:8{SCNVector3=fff}16@"SCNNode"28
{SCNMatrix4=ffffffffffffffff}88@0:8{SCNMatrix4=ffffffffffffffff}16@"SCNNode"80
@"NSArray"48@0:8{SCNVector3=fff}16{SCNVector3=fff}28@"NSDictionary"40
v24@0:8@"SCNParticleSystem"16
@"SCNNode"24@0:8@"NSString"16
@"SCNLight"16@0:8
v24@0:8@"SCNLight"16
@"SCNCamera"16@0:8
v24@0:8@"SCNCamera"16
v24@0:8@"SCNGeometry"16
@"SCNSkinner"16@0:8
v24@0:8@"SCNSkinner"16
v24@0:8@"SCNMorpher"16
v24@0:8@"SCNPhysicsBody"16
@"SCNPhysicsField"16@0:8
v24@0:8@"SCNPhysicsField"16
@"<SCNNodeRendererDelegate>"16@0:8
v24@0:8@"<SCNNodeRendererDelegate>"16
@"SCNNode"24@0:8@"SCNGeometry"16
@24@0:8@"MDLObject"16
@56@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24@"SCNPhysicsBody"36{SCNVector3=fff}44
@36@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24
v32@0:8@"SCNMaterial"16Q24
v32@0:8Q16@"SCNMaterial"24
@"SCNMaterial"24@0:8@"NSString"16
@"NSArray"24@0:8@"NSString"16
@"SCNGeometryElement"24@0:8q16
@"SCNMaterial"16@0:8
v24@0:8@"SCNMaterial"16
@"SCNGeometryElement"16@0:8
v24@0:8@"SCNGeometryElement"16
@"SCNGeometrySource"16@0:8
v24@0:8@"SCNGeometrySource"16
@32@0:8@"NSArray"16@"NSArray"24
@24@0:8@"MDLMesh"16
@"SCNMaterialProperty"16@0:8
@"NSURL"16@0:8
v24@0:8@"NSURL"16
@24@0:8@"MDLLight"16
@24@0:8@"MDLMaterial"16
v40@0:8q16@"NSArray"24@?<v@?^^v^Q^Iq>32
v40@0:8@"NSArray"16q24@?<v@?^^v^Qqqf>32
@"SCNParticleSystem"16@0:8
@32@0:8@"NSString"16@"NSString"24
@32@0:8@"SCNPhysicsBody"16@"NSArray"24
@24@0:8@"SCNNode"16
@32@0:8@"SCNGeometry"16@"NSDictionary"24
@32@0:8@"SCNNode"16@"NSDictionary"24
@"NSData"16@0:8
@48@0:8@"NSData"16q24q32q40
@24@0:8@"MDLSubmesh"16
@76@0:8@"NSData"16@"NSString"24q32B40q44q52q60q68
@32@0:8@"NSURL"16@"NSDictionary"24
@32@0:8@"NSData"16@"NSDictionary"24
@"SCNScene"32@0:8@"NSDictionary"16@?<v@?fq@"NSError"^B>24
@"SCNScene"32@0:8@"NSDictionary"16^@24
@32@0:8@"NSString"16#24
@"NSArray"24@0:8#16
@"NSArray"24@0:8@?<B@?@@"NSString"^B>16
@24@0:8@"MDLCamera"16
v32@0:8d16@"SCNNode"24
d24@0:8@16
d24@0:8@"SCNNode"16
v32@0:8@16@"<NSCopying>"24
@"SCNTechnique"24@0:8@"NSDictionary"16
@"SCNTechnique"24@0:8@"NSArray"16
v24@0:8@"SCNPhysicsBehavior"16
@"NSArray"40@0:8@"SCNPhysicsBody"16@"SCNPhysicsBody"24@"NSDictionary"32
@"NSArray"32@0:8@"SCNPhysicsBody"16@"NSDictionary"24
@"NSArray"160@0:8@"SCNPhysicsShape"16{SCNMatrix4=ffffffffffffffff}24{SCNMatrix4=ffffffffffffffff}88@"NSDictionary"152
@"<SCNPhysicsContactDelegate>"16@0:8
v24@0:8@"<SCNPhysicsContactDelegate>"16
@"SCNPhysicsShape"16@0:8
v24@0:8@"SCNPhysicsShape"16
@32@0:8q16@"SCNPhysicsShape"24
@28@0:8B16@?20
@28@0:8B16@?<{SCNMatrix4=ffffffffffffffff}@?@"SCNNode"{SCNMatrix4=ffffffffffffffff}>20
@32@0:8d16@?<v@?@"CAAnimation"@B>24
@"SCNAction"16@0:8
@?<f@?f>16@0:8
v24@0:8@?<f@?f>16
@"SCNAction"48@0:8d16d24d32d40
@"SCNAction"36@0:8{SCNVector3=fff}16d28
@"SCNAction"52@0:8d16d24d32d40B48
@"SCNAction"44@0:8d16{SCNVector3=fff}24d36
@"SCNAction"40@0:8{SCNVector4=ffff}16d32
@"SCNAction"32@0:8d16d24
@"SCNAction"24@0:8@"NSArray"16
@"SCNAction"32@0:8@"SCNAction"16Q24
@"SCNAction"24@0:8@"SCNAction"16
@"SCNAction"24@0:8d16
@"SCNAction"24@0:8@?<v@?@"SCNNode">16
@"SCNAction"32@0:8@?<v@?@"SCNNode">16@"NSObject<OS_dispatch_queue>"24
@"SCNAction"32@0:8@"NSString"16d24
@"SCNAction"32@0:8d16@?<v@?@"SCNNode"d>24
v88@0:8@"SCNParticleSystem"16{SCNMatrix4=ffffffffffffffff}24
B48@0:8@"NSURL"16@"NSDictionary"24@"<SCNSceneExportDelegate>"32@?<v@?f@"NSError"^B>40
@"SCNPhysicsWorld"16@0:8
@40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@40@0:8@"NSURL"16@"NSDictionary"24^@32
@24@0:8@"MDLAsset"16
@"SCNPhysicsField"32@0:8d16d24
@"SCNPhysicsField"24@0:8@?<{SCNVector3=fff}@?{SCNVector3=fff}{SCNVector3=fff}ffd>16
^{btRaycastVehicle=^^?{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}iiff^{btVehicleRaycaster}fff^{btRigidBody}iii{btAlignedObjectArray<btWheelInfo>={btAlignedAllocator<btWheelInfo, 16>=}ii^{btWheelInfo}B}}16@0:8
@"SCNPhysicsBody"
^{btRaycastVehicle=^^?{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}iiff^{btVehicleRaycaster}fff^{btRigidBody}iii{btAlignedObjectArray<btWheelInfo>={btAlignedAllocator<btWheelInfo, 16>=}ii^{btWheelInfo}B}}
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__CFString}{?=^?^?}fB}16@0:8
v24@0:8^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__CFString}{?=^?^?}fB}16
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__CFString}{?=^?^?}fB}
^{SCNCActionRepeat=^^?f@?@BdddddBB@?^{__CFString}qdddd^{SCNCAction}QQdB}
B48@0:8@16I24I28@32@40
v48@0:8@16I24I28@32@40
^{__C3DFXGLSLProgram=}24@0:8q16
v32@0:8^{__C3DFXGLSLProgram=}16@24
@"SCNProgram"
@56@0:8@16@24@32@40Q48
@"<SCNShadable>"
v24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
@24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
{?={?=cddid^v^v}^v^viiBB{CGRect={CGPoint=dd}{CGSize=dd}}d}16@0:8
@"UIBezierPath"
@"UIFont"
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
v24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
@24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{__C3DAABB}b1^?{?=S{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}}}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
{?=cddid^v^v}16@0:8
v40@0:8@16q24d32
@40@0:8@16q24^{__C3DLOD=}32
^{__C3DLOD=}
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
