isEqualToString:
copy
characterDirectionForLanguage:
length
dictionary
bundleIdentifier
objectForKey:
setObject:forKey:
localizations
arrayWithObject:
countByEnumeratingWithState:objects:count:
URLForResource:withExtension:subdirectory:localization:
dictionaryWithContentsOfURL:
null
class
isKindOfClass:
suic_localizedStringForKey:value:table:
suic_localizedStringForKey:table:
suic_localizedStringForKey:
init
alloc
_handleApplicationStateUpdate:
setHandler:
sharedMonitorForDisplayType:
addObserver:
invalidate
removeObserver:
dealloc
_updateForAppInfoDictionaries:
_appInfoDictionariesForDisplayLayout:completion:
arrayWithObjects:count:
intValue
unsignedIntValue
setIdentifier:
setPid:
removeObject:
addObject:
enumerateObjectsUsingBlock:
elements
layoutRole
level
arrayWithCapacity:
applicationInfoForApplication:completion:
insertObject:atIndex:
layoutMonitor:didUpdateDisplayLayout:
layoutMonitor:didUpdateDisplayLayout:withContext:
isEqual:
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
foregroundAppInfos
.cxx_destruct
_appStateMonitor
_foregroundAppInfos
_queue
_computeSpokenLanguageCode
defaultCenter
_spokenLanguageDidChange:
addObserver:selector:name:object:
_currentLocaleDidChange:
initWithDelegate:
_updateSpokenLanguageCode
_setSpokenLanguageCode:
_delegate
siriLanguageSpokenLanguageCodeDidChange:
sharedPreferences
languageCode
_setupAssistantHasCompletedInitialRunAvailable
preferredLanguages
count
objectAtIndex:
currentLocale
substringToIndex:
stringWithFormat:
containsObject:
spokenLanguageCode
setupAssistantHasCompletedInitialRunChecked
setSetupAssistantHasCompletedInitialRunChecked:
setSetupAssistantHasCompletedInitialRunAvailable:
_setupAssistantHasCompletedInitialRunChecked
_spokenLanguageCode
_initWithHistoryLength:
initWithMinimumPower:maximumPower:historyLength:
_updateMedianWithNewValue:
initWithMinimumPower:maximumPower:historyLength:attackSpeed:decaySpeed:
initWithBaseValue:exponentMultiplier:historyLength:
clearHistory
smoothedLevelForMicPower:
usesExponentialCurve
usesAttackAndDecaySpeed
minimumPower
setMinimumPower:
maximumPower
setMaximumPower:
attackSpeed
setAttackSpeed:
decaySpeed
setDecaySpeed:
baseValue
setBaseValue:
exponentMultiplier
setExponentMultiplier:
_minimumPower
_maximumPower
_historyLength
_samplesSinceLastCleared
_runningPowerLevels
_powerPointer
_previousLevel
_attackVelocity
_decayVelocity
_usesExponentialCurve
_usesAttackAndDecaySpeed
_attackSpeed
_decaySpeed
_baseValue
_exponentMultiplier
disallowSemanticContentModification
suic_recursiveSetSemanticContentAttribute:
subviews
semanticContentAttribute
setSemanticContentAttribute:
setTextAlignment:
textAlignment
userInterfaceLayoutDirectionForSemanticContentAttribute:
suic_updateViewHierarchyToUseSiriLanguageSemanticContentAttribute
fileSystemRepresentation
initWithPath:length:
bytes
_bytes
_length
initWithStyle:screenSize:
mainScreen
bounds
initWithFrame:
clearColor
setBackgroundColor:
didMoveToSuperview
_cleanupView
setHidden:
stop:
isAnimating
setAlpha:
_frameImagesForSequence:
animationWithKeyPath:
setValues:
setBeginTime:
setRepeatCount:
setCalculationMode:
setSpeed:
layer
addAnimation:forKey:
setTransform:
addKeyframeWithRelativeStartTime:relativeDuration:animations:
animateKeyframesWithDuration:delay:options:animations:completion:
animateWithDuration:animations:completion:
animationForKey:
removeAllAnimations
stringWithUTF8String:
bundleForClass:
pathForResource:ofType:
defaultManager
fileExistsAtPath:
attributesOfItemAtPath:error:
array
initWithCoder:
initWithStyle:
start:
_style
_width
_sequenceAttributes
numberWithBool:
stateTime
setStateTime:
zTime
setZTime:
globalAlpha
setGlobalAlpha:
transitionPhase
setTransitionPhase:
transitionPhasePtr
setTransitionPhasePtr:
stateModifiers
setStateModifiers:
stateModifiersPtr
setStateModifiersPtr:
isAura
setIsAura:
isDyingOff
setIsDyingOff:
_isAura
_isDyingOff
_stateTime
_zTime
_globalAlpha
_transitionPhase
_transitionPhasePtr
_stateModifiersPtr
_stateModifiers
scale
_numVerticesPerCircle
_reduceMotionStatusChanged:
_applicationWillResignActive:
_applicationWillEnterForeground:
_applicationDidBecomeActive:
setMode:
_setValuesForFidelity:
setOpaque:
setContentsScale:
initWithAPI:
_setCurrentContext
_restoreCurrentContext
initWithFrame:screen:fidelity:
_tearDownDisplayLink
_cleanupGL
superview
_setupDisplayLink
setUserInteractionEnabled:
_setPreferredFramesPerSecond
_updateDisplayLinkPausedStateFromSuccess:
setPreferredFramesPerSecond:
setPaused:
_initGLAndSetupDisplayLink:
getRed:green:blue:alpha:
setFrame:
frame
setBounds:
initWithImage:
addSubview:
removeFromSuperview
setParameter:to:
_updateDisplayLinkPausedState
prewarmShadersForScreen:size:fidelity:
prewarmShadersForScreen:size:fidelity:prewarmInBackground:
setRenderInBackground:
setActiveFrame:
_prewarmShaders
setAffineTransform:
_updateCurveLayer:
removeObjectsInArray:
isRenderingEnabled
setNeedsLayout
currentContext
setCurrentContext:
resetAndReinitializeGL:
setRenderingEnabled:forReason:
isHidden
displayLinkWithTarget:selector:
mainRunLoop
addToRunLoop:forMode:
renderbufferStorage:fromDrawable:
_predeterminedVertexPositionForAuraWithPolarVertex:
_generateIndicesForNumCircleShapes:withMaxSubdivisionLevel:startingWithNumSubdivisionLevel:forIndices:atStartIndex:withFill:withCullingForAura:forVertices:
_setupFramebuffer
_setupVertexBuffer
_setupShaders
_resizeFromLayer:
_updateOrthoProjection
mode
_currentMicPowerLevel
duration
delegate
flamesViewAuraDidDisplay:
presentRenderbuffer:
audioLevelForFlamesView:
layerClass
prewarmShadersForScreen:size:
initWithFrame:screenScale:fidelity:
setDelegate:
setState:
setDictationColor:
setOverlayImage:
setHorizontalScaleFactor:
prewarmShadersForCurrentMode
layoutSubviews
inSiriMode
inDictationMode
stopRenderingAndCleanupGL
state
showAura
setShowAura:
reduceFrameRate
setReduceFrameRate:
activeFrame
overlayImage
dictationColor
renderInBackground
paused
horizontalScaleFactor
accelerateTransitions
setAccelerateTransitions:
_displayLink
_eaglContext
_previousContext
_currentContextCount
_renderingDisabledReasons
_framebufferHandle
_renderbufferHandle
_flameProgramHandle
_auraProgramHandle
_vShadID
_fShadID
_vertexArrayObjectHandle
_vertexBufferHandle
_elementArrayHandle
_numVertices
_numAuraIndices
_numAuraIndicesCulled
_numWaveIndices
_maxVertexCircles
_auraVertexCircles
_maxSubdivisionLevel
_auraMinSubdivisionLevel
_auraMaxSubdivisionLevel
_flameGroups
_currentFlameGroup
_viewWidth
_viewHeight
_dictationUnitSize
_screen
_overlayImageView
_startTime
_dictationRedColor
_dictationGreenColor
_dictationBlueColor
_levelSmoother
_fidelity
_isInitialized
_hasCustomActiveFrame
_shadersAreCompiled
_reduceMotionEnabled
_showAura
_reduceFrameRate
_renderInBackground
_paused
_accelerateTransitions
_mode
_state
_overlayImage
_dictationColor
_horizontalScaleFactor
_activeFrame
%s %s updated language code to: %@
SUICSetSiriUILanguageCode
Localizable
strings
com.apple.SUICApplicationStateHelper.queue
v16@?0@"NSDictionary"8
v8@?0
v16@?0@"NSArray"8
v32@?0@"NSDictionary"8Q16^B24
v32@?0@"FBSDisplayLayoutElement"8Q16^B24
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
BYSetupAssistantHasCompletedInitialRun
en-GB
en-AU
%@-%@
delegate
T@"<SUICSiriLanguageDelegate>",R,W,N,G_delegate,V_delegate
spokenLanguageCode
T@"NSString",C,N,S_setSpokenLanguageCode:,V_spokenLanguageCode
setupAssistantHasCompletedInitialRunChecked
TB,N,V_setupAssistantHasCompletedInitialRunChecked
setupAssistantHasCompletedInitialRunAvailable
TB,N,G_setupAssistantHasCompletedInitialRunAvailable,V_setupAssistantHasCompletedInitialRunAvailable
/System/Library/PrivateFrameworks/SetupAssistant.framework/SetupAssistant
SiriBulletinBoardNotificationName
SiriBulletinBoardNotificationAppIDKey
SiriBulletinBoardNotificationUserActivityKey
usesExponentialCurve
TB,R,N,V_usesExponentialCurve
usesAttackAndDecaySpeed
TB,R,N,V_usesAttackAndDecaySpeed
minimumPower
Tf,N,V_minimumPower
maximumPower
Tf,N,V_maximumPower
attackSpeed
Tf,N,V_attackSpeed
decaySpeed
Tf,N,V_decaySpeed
baseValue
Tf,N,V_baseValue
exponentMultiplier
Tf,N,V_exponentMultiplier
SiriFlamesLoop~watch-Compact
DictationFlamesLoop~watch-Compact
SiriFlamesLoop~watch-Regular
DictationFlamesLoop~watch-Regular
FauxFlames
bytes
T^v,R,N,V_bytes
length
TQ,R,N,V_length
contents
v12@?0B8
artwork
stateTime: %f  zTime: %f  transitionPhase: %f  stateModifiers: %f, %f, %f, %f  globalAlpha: %f  isAura: %@  isDyingOff: %@
stateTime
Tf,N,V_stateTime
zTime
Tf,N,V_zTime
globalAlpha
Tf,N,V_globalAlpha
transitionPhase
Tf,N,V_transitionPhase
transitionPhasePtr
T^f,N,V_transitionPhasePtr
stateModifiers
T,N,V_stateModifiers
stateModifiersPtr
T^,N,V_stateModifiersPtr
isAura
TB,N,V_isAura
isDyingOff
TB,N,V_isDyingOff
kSUICFlamesViewUIApplicationNotificationReason
GdXjx1ixZYvN9Gg8iSf68A
in_Polar
in_FittedBounds
in_Time_ZTime_Height_Alpha
in_States
in_ViewportDim_ScreenScale_UnitLength
in_FragmentColor
isRenderingEnabled
TB,R,N
T@"<SUICFlamesViewDelegate>",W,N,V_delegate
mode
Ti,N,V_mode
state
Ti,N,V_state
showAura
TB,N,V_showAura
reduceFrameRate
TB,N,V_reduceFrameRate
activeFrame
T{CGRect={CGPoint=dd}{CGSize=dd}},N,V_activeFrame
overlayImage
T@"UIImage",&,N,V_overlayImage
dictationColor
T@"UIColor",&,N,V_dictationColor
renderInBackground
TB,N,V_renderInBackground
paused
TB,N,V_paused
horizontalScaleFactor
Td,N,V_horizontalScaleFactor
accelerateTransitions
TB,N,V_accelerateTransitions
#version 100
#extension GL_EXT_separate_shader_objects : enable
layout(location = 0) attribute vec4 in_Polar;
layout(location = 1) attribute vec4 in_ViewportDim_ScreenScale_UnitLength;
layout(location = 2) attribute vec4 in_FittedBounds;
layout(location = 3) attribute vec4 in_Time_ZTime_Height_Alpha;
layout(location = 4) attribute vec4 in_States;
varying mediump vec3 out_ChannelCoord;
varying mediump vec3 out_ColorNoise;
varying mediump vec3 out_Alpha3f;
varying mediump float out_Alpha1f;
varying mediump float out_CenterY;
vec3 mod289(vec3 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 mod289(vec4 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 permute(vec4 x) {
return mod289(((x*34.0)+1.0)*x);
vec4 taylorInvSqrt(vec4 r)
return 1.79284291400159 - 0.85373472095314 * r;
float snoise(vec3 v)
const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
vec3 i  = floor(v + dot(v, C.yyy) );
vec3 x0 =   v - i + dot(i, C.xxx) ;
vec3 g = step(x0.yzx, x0.xyz);
vec3 l = 1.0 - g;
vec3 i1 = min( g.xyz, l.zxy );
vec3 i2 = max( g.xyz, l.zxy );
vec3 x1 = x0 - i1 + C.xxx;
vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
i = mod289(i);
vec4 p = permute( permute( permute(
i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
float n_ = 0.142857142857; // 1.0/7.0
vec3  ns = n_ * D.wyz - D.xzx;
vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
vec4 x_ = floor(j * ns.z);
vec4 y_ = floor(j - 7.0 * x_ );
vec4 x = x_ *ns.x + ns.yyyy;
vec4 y = y_ *ns.x + ns.yyyy;
vec4 h = 1.0 - abs(x) - abs(y);
vec4 b0 = vec4( x.xy, y.xy );
vec4 b1 = vec4( x.zw, y.zw );
vec4 s0 = floor(b0)*2.0 + 1.0;
vec4 s1 = floor(b1)*2.0 + 1.0;
vec4 sh = -step(h, vec4(0.0));
vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
vec3 p0 = vec3(a0.xy,h.x);
vec3 p1 = vec3(a0.zw,h.y);
vec3 p2 = vec3(a1.xy,h.z);
vec3 p3 = vec3(a1.zw,h.w);
vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
m = m * m;
return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
dot(p2,x2), dot(p3,x3) ) );
const float kThinkingHeightMax = 0.45;
const float kFastTimeMultiplier = 4.4;
const float pi = 3.1415926535;
float FastSin( float rad )
   float x = mod(rad, 2.0 * pi) - pi;
   return (-4.0/(pi*pi)) * x * (pi - abs(x));
float FastCos( float rad )
   return FastSin(rad + pi * 0.5);
void main(void)
float time =   in_Time_ZTime_Height_Alpha.x;
float zTime =  in_Time_ZTime_Height_Alpha.y;
float height = in_Time_ZTime_Height_Alpha.z;
float globalAlpha = in_Time_ZTime_Height_Alpha.w;
float r_orig = in_Polar.x;
float q_orig = in_Polar.y;
float q_noise = in_Polar.w;
vec2 scale = in_FittedBounds.zw / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z);
vec2 center = (in_FittedBounds.xy + (in_FittedBounds.zw * 0.5)) / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z) * 2.0 - 1.0;
center.y = -center.y;
vec2 device_pixel = 2.0 / in_ViewportDim_ScreenScale_UnitLength.xy;
float abs_q_orig_ndc = abs(q_orig - pi)/pi * 2.0 - 1.0;
float abs_q_noise_ndc = abs(q_noise - pi)/pi * 2.0 - 1.0;
float sin_q = FastSin(q_orig);
float cos_q = FastCos(q_orig);
float state_0 = smoothstep(0.0, 1.0, in_States.x);
float state_1 = smoothstep(0.0, 1.0, in_States.y);
float state_2 = smoothstep(0.0, 1.0, in_States.z);
float state_3_fadeOut =    smoothstep(0.0, 0.25, in_States.w);
float state_3_change =     smoothstep(0.25, 0.5, in_States.w);
float state_3_fadeIn =     smoothstep(0.5, 1.0, in_States.w);
vec2 theta_geom = mix(vec2(abs_q_orig_ndc, sign(sin_q)), vec2(cos_q, sin_q), state_3_change);
vec2 theta_noise = mix(vec2(abs_q_noise_ndc, sign(sin_q)), vec2(cos_q, sin_q), state_3_change);
vec2 cartesian_orig = theta_geom * r_orig;
vec2 r_geom = mix(vec2(r_orig * (1.0 - state_0), 0.0) * scale, vec2(r_orig * distance(center, vec2(1.0))), state_3_change);
float wave_falloff = (smoothstep(-1.0, -0.5, cartesian_orig.x) - smoothstep(0.5, 1.0, cartesian_orig.x)) * (1.0 - in_States.x * in_States.x * in_States.x);
float aura_point_dist = length(cartesian_orig);
float falloff_aura = mix(1.0, smoothstep(1.0, 0.9, aura_point_dist), state_3_change);
falloff_aura = mix(falloff_aura, 1.0, state_3_change);
float listeningMap = smoothstep(-0.75, 0.0, cartesian_orig.x) - smoothstep(0.0, 0.75, cartesian_orig.x);
listeningMap *= height;
listeningMap *= (state_1 + state_0);
float thinkingMap = smoothstep(-0.3, 0.0, cartesian_orig.x) - smoothstep(0.0, 0.3, cartesian_orig.x);
thinkingMap *= state_2 * ((FastSin(time * kFastTimeMultiplier) + 2.0) * 0.5 * kThinkingHeightMax);
float mapSum = mix(listeningMap + thinkingMap, 1.0, state_3_change);
vec2 cartesian_noise = theta_noise * r_geom;
float noiseFrequency = ((0.00267 + height * 0.004) * (state_0 + state_1) + 0.00267 * state_2) * min(500.0 , max(in_FittedBounds.z, 200.0)) + state_3_change * 0.4;
float noise0 = snoise(vec3(cartesian_noise * noiseFrequency, zTime));
float noise1 = snoise(vec3(cartesian_noise * noiseFrequency, zTime + 1.0));
float noise2 = snoise(vec3(cartesian_noise * noiseFrequency, zTime + 2.0));
float abs_noise0 = abs(noise0);
float abs_noise1 = abs(noise1);
float abs_noise2 = abs(noise2);
float abs_noise = max(max(abs_noise0, abs_noise1), abs_noise2);
r_geom.y = mix(max(mapSum * abs_noise * scale.y, device_pixel.y * 2.0 * (state_1 + state_2)), r_geom.y, state_3_change);
vec2 cartesian_geom = theta_geom * r_geom + center;
vec3 wave_alpha = (1.0 - mapSum * vec3(abs_noise0, abs_noise1, abs_noise2) * 0.95);
wave_alpha *= wave_alpha;
gl_Position = vec4(cartesian_geom, 0.0, 1.0);
out_ChannelCoord = max(mapSum * vec3(abs_noise0, abs_noise1, abs_noise2) * (in_FittedBounds.w * 0.5) * in_ViewportDim_ScreenScale_UnitLength.z, 2.0 * (state_1 + state_2));
out_ColorNoise = 1.0 - (1.0 - vec3(1.0, 0.176, 0.333) * noise0) * (1.0 - vec3(0.251, 1.0, 0.639) * noise1) * (1.0 - vec3(0.0, 0.478, 1.0) * noise2);
out_Alpha3f = wave_alpha * wave_falloff * globalAlpha * (1.0 - state_3_fadeOut);
out_Alpha1f = max(out_ColorNoise.x, max(out_ColorNoise.y, out_ColorNoise.z)) * 0.4 * falloff_aura * (globalAlpha * state_3_fadeIn);
out_CenterY = (in_ViewportDim_ScreenScale_UnitLength.y - (in_FittedBounds.y + (in_FittedBounds.w * 0.5)) * in_ViewportDim_ScreenScale_UnitLength.z);
#version 100
#extension GL_EXT_separate_shader_objects : enable
layout(location = 0) attribute vec4 in_Polar;
layout(location = 1) attribute vec4 in_ViewportDim_ScreenScale_UnitLength;
layout(location = 2) attribute vec4 in_FittedBounds;
layout(location = 3) attribute vec4 in_Time_ZTime_Height_Alpha;
layout(location = 4) attribute vec4 in_States;
varying mediump vec3 out_ChannelCoord;
varying mediump vec3 out_ColorNoise;
varying mediump vec3 out_Alpha3f;
varying mediump float out_Alpha1f;
varying mediump float out_CenterY;
vec3 mod289(vec3 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 mod289(vec4 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 permute(vec4 x) {
return mod289(((x*34.0)+1.0)*x);
vec4 taylorInvSqrt(vec4 r)
return 1.79284291400159 - 0.85373472095314 * r;
float snoise(vec3 v)
const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
vec3 i  = floor(v + dot(v, C.yyy) );
vec3 x0 =   v - i + dot(i, C.xxx) ;
vec3 g = step(x0.yzx, x0.xyz);
vec3 l = 1.0 - g;
vec3 i1 = min( g.xyz, l.zxy );
vec3 i2 = max( g.xyz, l.zxy );
vec3 x1 = x0 - i1 + C.xxx;
vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
i = mod289(i);
vec4 p = permute( permute( permute(
i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
float n_ = 0.142857142857; // 1.0/7.0
vec3  ns = n_ * D.wyz - D.xzx;
vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
vec4 x_ = floor(j * ns.z);
vec4 y_ = floor(j - 7.0 * x_ );
vec4 x = x_ *ns.x + ns.yyyy;
vec4 y = y_ *ns.x + ns.yyyy;
vec4 h = 1.0 - abs(x) - abs(y);
vec4 b0 = vec4( x.xy, y.xy );
vec4 b1 = vec4( x.zw, y.zw );
vec4 s0 = floor(b0)*2.0 + 1.0;
vec4 s1 = floor(b1)*2.0 + 1.0;
vec4 sh = -step(h, vec4(0.0));
vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
vec3 p0 = vec3(a0.xy,h.x);
vec3 p1 = vec3(a0.zw,h.y);
vec3 p2 = vec3(a1.xy,h.z);
vec3 p3 = vec3(a1.zw,h.w);
vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
m = m * m;
return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
dot(p2,x2), dot(p3,x3) ) );
const float kThinkingHeightMax = 0.2;
const float kFastTimeMultiplier = 4.4;
const float pi = 3.1415926535;
float FastSin( float rad )
   float x = mod(rad, 2.0 * pi) - pi;
   return (-4.0/(pi*pi)) * x * (pi - abs(x));
float FastCos( float rad )
   return FastSin(rad + pi * 0.5);
void main(void)
float time =   in_Time_ZTime_Height_Alpha.x;
float zTime =  in_Time_ZTime_Height_Alpha.y;
float height = in_Time_ZTime_Height_Alpha.z;
float globalAlpha = in_Time_ZTime_Height_Alpha.w;
float r_orig = in_Polar.x;
float q_orig = in_Polar.y;
float q_noise = in_Polar.w;
vec2 scale = in_FittedBounds.zw / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z);
vec2 center = (in_FittedBounds.xy + (in_FittedBounds.zw * 0.5)) / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z) * 2.0 - 1.0;
center.y = -center.y;
vec2 device_pixel = 2.0 / in_ViewportDim_ScreenScale_UnitLength.xy;
float abs_q_orig_ndc = abs(q_orig - pi)/pi * 2.0 - 1.0;
float abs_q_noise_ndc = abs(q_noise - pi)/pi * 2.0 - 1.0;
float sin_q = FastSin(q_orig);
float cos_q = FastCos(q_orig);
float state_0 = smoothstep(0.0, 1.0, in_States.x);
float state_1 = smoothstep(0.0, 1.0, in_States.y);
float state_2 = smoothstep(0.0, 1.0, in_States.z);
float state_3a = smoothstep(0.0, 0.25, in_States.w);
float state_3b = smoothstep(0.0, 0.5, in_States.w);
float state_3c = smoothstep(0.0, 1.0, in_States.w);
float state_3d = smoothstep(0.75, 1.0, in_States.w);
vec2 theta_geom = mix(vec2(abs_q_orig_ndc, sign(sin_q)), vec2(cos_q, sin_q), state_3c);
vec2 theta_noise = mix(vec2(abs_q_noise_ndc, sign(sin_q)), vec2(cos_q, sin_q), state_3c);
vec2 cartesian_orig = theta_geom * r_orig;
vec2 r_geom = mix(vec2(r_orig * (1.0 - state_0), 0.0) * scale, vec2(r_orig * distance(center, vec2(1.0))), state_3b);
float wave_falloff = (smoothstep(-1.0, -0.5, cartesian_orig.x) - smoothstep(0.5, 1.0, cartesian_orig.x)) * (1.0 - in_States.x * in_States.x * in_States.x);
float aura_point_dist = length(cartesian_orig);
float falloff_aura = mix(1.0, smoothstep(1.0, 0.9, aura_point_dist), state_3a);
falloff_aura = mix(falloff_aura, 1.0, state_3d);
float map_x = abs(theta_geom.x * r_geom.x);
float waitingMap = clamp(FastSin((map_x + in_States.x * 1.5 - 1.0) * pi), 0.0, 1.0);
waitingMap *= 1.0 - 0.6 * state_0 * state_0;
float listeningMap = smoothstep(-0.75, 0.0, cartesian_orig.x) - smoothstep(0.0, 0.75, cartesian_orig.x);
listeningMap *= height;
listeningMap *= (state_1 + state_0);
float pingPong = FastSin(time * kFastTimeMultiplier) * 0.9;
float leftScale = max(0.0, FastSin(time * kFastTimeMultiplier + 0.4 * pi));
leftScale = (leftScale * leftScale * 0.9 + 0.1) * 0.9;
float rightScale = max(0.0, FastSin(time * kFastTimeMultiplier - 0.6 * pi));
rightScale = (rightScale * rightScale * 0.9 + 0.1) * 0.9;
float thinkingMap = smoothstep(pingPong - leftScale, pingPong, abs_q_orig_ndc) * smoothstep(pingPong + rightScale, pingPong, abs_q_orig_ndc) * kThinkingHeightMax;
thinkingMap *= state_2;
float mirroredSineMap = clamp(FastSin((map_x + (1.0 - in_States.z) * 2.0 - 1.0) * pi), 0.0, 1.0);
mirroredSineMap *= 0.3;
thinkingMap += mirroredSineMap;
float mapSum = mix(waitingMap + listeningMap + thinkingMap, 1.0, state_3a);
vec2 cartesian_noise = theta_noise * r_geom;
float noiseFrequency = ((0.00267 + height * 0.004) * (state_0 + state_1) + 0.001333 * state_2) * min(500.0 , max(in_FittedBounds.z, 200.0)) + state_3a * 0.4;
float noise0 = snoise(vec3(cartesian_noise * noiseFrequency, zTime));
float noise1 = snoise(vec3(cartesian_noise * noiseFrequency, zTime + 1.0));
float noise2 = snoise(vec3(cartesian_noise * noiseFrequency, zTime + 2.0));
float abs_noise0 = abs(noise0);
float abs_noise1 = abs(noise1);
float abs_noise2 = abs(noise2);
float abs_noise = max(max(abs_noise0, abs_noise1), abs_noise2);
r_geom.y = mix(max(mapSum * abs_noise * scale.y, device_pixel.y * 2.0 * state_1), r_geom.y, state_3b);
vec2 cartesian_geom = theta_geom * r_geom + center;
vec3 wave_alpha = (1.0 - mapSum * vec3(abs_noise0, abs_noise1, abs_noise2) * 0.95);
wave_alpha *= wave_alpha;
gl_Position = vec4(cartesian_geom, 0.0, 1.0);
out_ChannelCoord = max(mapSum * vec3(abs_noise0, abs_noise1, abs_noise2) * (in_FittedBounds.w * 0.5) * in_ViewportDim_ScreenScale_UnitLength.z, 2.0 * state_1);
out_ColorNoise = 1.0 - (1.0 - vec3(1.0, 0.176, 0.333) * noise0) * (1.0 - vec3(0.251, 1.0, 0.639) * noise1) * (1.0 - vec3(0.0, 0.478, 1.0) * noise2);
out_Alpha3f = wave_alpha * wave_falloff * globalAlpha;
out_Alpha1f = max(out_ColorNoise.x, max(out_ColorNoise.y, out_ColorNoise.z)) * 0.4 * falloff_aura * globalAlpha;
out_CenterY = (in_ViewportDim_ScreenScale_UnitLength.y - (in_FittedBounds.y + (in_FittedBounds.w * 0.5)) * in_ViewportDim_ScreenScale_UnitLength.z);
#version 100
varying mediump vec3 out_ChannelCoord;
varying mediump vec3 out_Alpha3f;
varying mediump float out_CenterY;
void main(void)
   mediump float p = abs(gl_FragCoord.y - out_CenterY);
   mediump vec3 wave_channel = smoothstep(out_ChannelCoord, out_ChannelCoord - 2.0, vec3(p));
   mediump vec4 xColor = vec4(1.0, 0.176, 0.333, out_Alpha3f.x) * wave_channel.x;
   mediump vec4 yColor = vec4(0.251, 1.0, 0.639, out_Alpha3f.y) * wave_channel.y;
   mediump vec4 zColor = vec4(0.0, 0.478, 1.0, out_Alpha3f.z) * wave_channel.z;
   gl_FragColor = 1.0 - (1.0 - xColor) * (1.0 - yColor) * (1.0 - zColor);
#version 100
varying mediump vec3 out_ColorNoise;
varying mediump float out_Alpha1f;
void main(void)
   gl_FragColor = vec4(out_ColorNoise, out_Alpha1f);
#version 100
#extension GL_EXT_separate_shader_objects : enable
layout(location = 0) attribute vec4 in_Polar;
layout(location = 1) attribute vec4 in_ViewportDim_ScreenScale_UnitLength;
layout(location = 2) attribute vec4 in_FittedBounds;
layout(location = 3) attribute vec4 in_Time_ZTime_Height_Alpha;
layout(location = 4) attribute vec4 in_States;
layout(location = 5) attribute vec3 in_FragmentColor;
varying mediump vec4 out_Height_Center_Alpha_UnitSize;
varying mediump vec4 out_Viewport;
varying mediump vec4 out_FittedBounds;
varying mediump vec3 out_FragmentColor;
vec3 mod289(vec3 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 mod289(vec4 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 permute(vec4 x) {
return mod289(((x*34.0)+1.0)*x);
vec4 taylorInvSqrt(vec4 r)
return 1.79284291400159 - 0.85373472095314 * r;
float snoise(vec3 v)
const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
vec3 i  = floor(v + dot(v, C.yyy) );
vec3 x0 =   v - i + dot(i, C.xxx) ;
vec3 g = step(x0.yzx, x0.xyz);
vec3 l = 1.0 - g;
vec3 i1 = min( g.xyz, l.zxy );
vec3 i2 = max( g.xyz, l.zxy );
vec3 x1 = x0 - i1 + C.xxx;
vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
i = mod289(i);
vec4 p = permute( permute( permute(
i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
float n_ = 0.142857142857; // 1.0/7.0
vec3  ns = n_ * D.wyz - D.xzx;
vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
vec4 x_ = floor(j * ns.z);
vec4 y_ = floor(j - 7.0 * x_ );
vec4 x = x_ *ns.x + ns.yyyy;
vec4 y = y_ *ns.x + ns.yyyy;
vec4 h = 1.0 - abs(x) - abs(y);
vec4 b0 = vec4( x.xy, y.xy );
vec4 b1 = vec4( x.zw, y.zw );
vec4 s0 = floor(b0)*2.0 + 1.0;
vec4 s1 = floor(b1)*2.0 + 1.0;
vec4 sh = -step(h, vec4(0.0));
vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
vec3 p0 = vec3(a0.xy,h.x);
vec3 p1 = vec3(a0.zw,h.y);
vec3 p2 = vec3(a1.xy,h.z);
vec3 p3 = vec3(a1.zw,h.w);
vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
m = m * m;
return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
dot(p2,x2), dot(p3,x3) ) );
const float kThinkingHeightMax = 0.2;
const float kFastTimeMultiplier = 3.0;
const float pi = 3.1415926535;
float FastSin( float rad )
   float x = mod(rad, 2.0 * pi) - pi;
   return (-4.0/(pi*pi)) * x * (pi - abs(x));
float FastCos( float rad )
   return FastSin(rad + pi * 0.5);
void main(void)
float time =   in_Time_ZTime_Height_Alpha.x;
float zTime =  in_Time_ZTime_Height_Alpha.y;
float height = in_Time_ZTime_Height_Alpha.z;
float globalAlpha = in_Time_ZTime_Height_Alpha.w;
float r_orig = in_Polar.x;
float q_orig = in_Polar.y;
float q_noise = in_Polar.w;
vec2 scale = in_FittedBounds.zw / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z);
vec2 center = (in_FittedBounds.xy + (in_FittedBounds.zw * 0.5)) / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z) * 2.0 - 1.0;
center.y = -center.y;
vec2 logical_pixel = 1.0 / (in_ViewportDim_ScreenScale_UnitLength.xy);
float abs_q_orig_ndc = abs(q_orig - pi)/pi * 2.0 - 1.0;
float abs_q_noise_ndc = abs(q_noise - pi)/pi * 2.0 - 1.0;
float sin_q = FastSin(q_orig);
float cos_q = FastCos(q_orig);
float state_0 = smoothstep(0.0, 1.0, in_States.x);
float state_1 = smoothstep(0.0, 1.0, in_States.y);
vec2 theta_geom = vec2(abs_q_orig_ndc, sign(sin_q));
vec2 theta_noise = vec2(abs_q_noise_ndc, sign(sin_q));
vec2 cartesian_orig = theta_geom * r_orig;
vec2 r_geom = vec2(r_orig * (1.0 - state_0), 0.0) * scale;
vec2 cartesian_noise = theta_noise * r_geom;
float map_x = abs(theta_geom.x * r_geom.x);
float waitingMap = clamp(FastSin((map_x + in_States.x * 1.5 - 1.0) * pi), 0.0, 1.0);
waitingMap *= 1.0 - 0.6 * state_0 * state_0;
float listeningMap = smoothstep(-1.0, -0.25, cartesian_noise.x) - smoothstep(0.25, 1.0, cartesian_noise.x);
listeningMap *= height;
listeningMap *= (state_1 + state_0);
float mapSum = waitingMap + listeningMap;
float noiseFrequency = (0.01 + height * 0.02) * (state_0 + state_1) * max(in_FittedBounds.z, 250.0);
float noise = snoise(vec3(cartesian_noise * noiseFrequency, zTime));
float abs_noise = abs(noise);
r_geom.y = max(mapSum * abs_noise * scale.y, logical_pixel.y * in_ViewportDim_ScreenScale_UnitLength.z * 3.0);
vec2 cartesian_geom = theta_geom * r_geom;
cartesian_geom += center;
float y_center_window = in_ViewportDim_ScreenScale_UnitLength.y - (in_FittedBounds.y + (in_FittedBounds.w * 0.5)) * in_ViewportDim_ScreenScale_UnitLength.z;
float r_window = max(mapSum * abs_noise * (in_FittedBounds.w * 0.5) * in_ViewportDim_ScreenScale_UnitLength.z, 2.0);
gl_Position = vec4(cartesian_geom, 0.0, 1.0);
out_Height_Center_Alpha_UnitSize = vec4(r_window, y_center_window, globalAlpha, in_ViewportDim_ScreenScale_UnitLength.w);
out_Viewport = in_ViewportDim_ScreenScale_UnitLength;
out_FittedBounds = in_FittedBounds;
out_FragmentColor = in_FragmentColor;
#version 100
varying mediump vec4 out_Height_Center_Alpha_UnitSize;
varying mediump vec4 out_Viewport;
varying mediump vec4 out_FittedBounds;
varying mediump vec3 out_FragmentColor;
void main(void)
   mediump float unitSize = out_Height_Center_Alpha_UnitSize.w;
   mediump float halfUnitSize = unitSize * 0.5;
   mediump float halfLineSize = 0.25 + out_Viewport.z;
   mediump float halfLineSize_sq = halfLineSize*halfLineSize;
   mediump vec2 p = floor(vec2(mod(gl_FragCoord.x - (out_FittedBounds.x * out_Viewport.z) + halfUnitSize, unitSize) - halfUnitSize, abs(gl_FragCoord.y - out_Height_Center_Alpha_UnitSize.y) - max(0.0, out_Height_Center_Alpha_UnitSize.x - halfLineSize * 2.0)));
   mediump float end = step(p.y, 0.0);
   mediump float d = (1.0 - smoothstep(0.25, halfLineSize_sq, dot(p, p))) * (1.0 - end);
   mediump float x = (1.0 - smoothstep(halfLineSize_sq - 1.0, halfLineSize_sq, p.x*p.x)) * end;
   gl_FragColor = vec4(out_FragmentColor.x, out_FragmentColor.y, out_FragmentColor.z, (x+d)*out_Height_Center_Alpha_UnitSize.z);
#version 100
#extension GL_EXT_separate_shader_objects : enable
layout(location = 0) attribute vec4 in_Polar;
layout(location = 1) attribute vec4 in_ViewportDim_ScreenScale_UnitLength;
layout(location = 2) attribute vec4 in_FittedBounds;
layout(location = 3) attribute vec4 in_Time_ZTime_Height_Alpha;
layout(location = 4) attribute vec4 in_States;
varying mediump vec3 out_ChannelCoord;
varying mediump vec3 out_Alpha3f;
varying mediump float out_Alpha1f;
varying mediump float out_CenterY;
vec3 mod289(vec3 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 mod289(vec4 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
vec4 permute(vec4 x) {
return mod289(((x*34.0)+1.0)*x);
vec4 taylorInvSqrt(vec4 r)
return 1.79284291400159 - 0.85373472095314 * r;
float snoise(vec3 v)
const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
vec3 i  = floor(v + dot(v, C.yyy) );
vec3 x0 =   v - i + dot(i, C.xxx) ;
vec3 g = step(x0.yzx, x0.xyz);
vec3 l = 1.0 - g;
vec3 i1 = min( g.xyz, l.zxy );
vec3 i2 = max( g.xyz, l.zxy );
vec3 x1 = x0 - i1 + C.xxx;
vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
i = mod289(i);
vec4 p = permute( permute( permute(
i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
float n_ = 0.142857142857; // 1.0/7.0
vec3  ns = n_ * D.wyz - D.xzx;
vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
vec4 x_ = floor(j * ns.z);
vec4 y_ = floor(j - 7.0 * x_ );
vec4 x = x_ *ns.x + ns.yyyy;
vec4 y = y_ *ns.x + ns.yyyy;
vec4 h = 1.0 - abs(x) - abs(y);
vec4 b0 = vec4( x.xy, y.xy );
vec4 b1 = vec4( x.zw, y.zw );
vec4 s0 = floor(b0)*2.0 + 1.0;
vec4 s1 = floor(b1)*2.0 + 1.0;
vec4 sh = -step(h, vec4(0.0));
vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
vec3 p0 = vec3(a0.xy,h.x);
vec3 p1 = vec3(a0.zw,h.y);
vec3 p2 = vec3(a1.xy,h.z);
vec3 p3 = vec3(a1.zw,h.w);
vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
m = m * m;
return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
dot(p2,x2), dot(p3,x3) ) );
const float kThinkingHeightMax = 0.2;
const float kFastTimeMultiplier = 4.4;
const float pi = 3.1415926535;
float FastSin( float rad )
   float x = mod(rad, 2.0 * pi) - pi;
   return (-4.0/(pi*pi)) * x * (pi - abs(x));
float FastCos( float rad )
   return FastSin(rad + pi * 0.5);
void main(void)
float time =   in_Time_ZTime_Height_Alpha.x;
float zTime =  in_Time_ZTime_Height_Alpha.y;
float height = in_Time_ZTime_Height_Alpha.z;
float globalAlpha = in_Time_ZTime_Height_Alpha.w;
float r_orig = in_Polar.x;
float q_orig = in_Polar.y;
float q_noise = in_Polar.w;
vec2 scale = in_FittedBounds.zw / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z);
vec2 center = (in_FittedBounds.xy + (in_FittedBounds.zw * 0.5)) / (in_ViewportDim_ScreenScale_UnitLength.xy / in_ViewportDim_ScreenScale_UnitLength.z) * 2.0 - 1.0;
center.y = -center.y;
vec2 device_pixel = 2.0 / in_ViewportDim_ScreenScale_UnitLength.xy;
float abs_q_orig_ndc = abs(q_orig - pi)/pi * 2.0 - 1.0;
float abs_q_noise_ndc = abs(q_noise - pi)/pi * 2.0 - 1.0;
float sin_q = FastSin(q_orig);
float cos_q = FastCos(q_orig);
float state_0 = smoothstep(0.0, 1.0, in_States.x);
float state_1 = smoothstep(0.0, 1.0, in_States.y);
float state_2 = smoothstep(0.0, 1.0, in_States.z);
vec2 theta_geom = vec2(abs_q_orig_ndc, sign(sin_q));
vec2 theta_noise = vec2(abs_q_noise_ndc, sign(sin_q));
vec2 cartesian_orig = theta_geom * r_orig;
vec2 r_geom = vec2(r_orig * (1.0 - state_0), 0.0) * scale;
float wave_falloff = (smoothstep(-1.0, -0.5, cartesian_orig.x) - smoothstep(0.5, 1.0, cartesian_orig.x)) * (1.0 - in_States.x * in_States.x * in_States.x);
float map_x = abs(theta_geom.x * r_geom.x);
float waitingMap = clamp(FastSin((map_x + in_States.x * 1.5 - 1.0) * pi), 0.0, 1.0);
waitingMap *= 1.0 - 0.6 * state_0 * state_0;
float listeningMap = smoothstep(-0.75, 0.0, cartesian_orig.x) - smoothstep(0.0, 0.75, cartesian_orig.x);
listeningMap *= height;
listeningMap *= (state_1 + state_0);
float pingPong = FastSin(time * kFastTimeMultiplier) * 0.9;
float leftScale = max(0.0, FastSin(time * kFastTimeMultiplier + 0.4 * pi));
leftScale = (leftScale * leftScale * 0.9 + 0.1) * 0.9;
float rightScale = max(0.0, FastSin(time * kFastTimeMultiplier - 0.6 * pi));
rightScale = (rightScale * rightScale * 0.9 + 0.1) * 0.9;
float thinkingMap = smoothstep(pingPong - leftScale, pingPong, abs_q_orig_ndc) * smoothstep(pingPong + rightScale, pingPong, abs_q_orig_ndc) * kThinkingHeightMax;
thinkingMap *= state_2;
float mirroredSineMap = clamp(FastSin((map_x + (1.0 - in_States.z) * 2.0 - 1.0) * pi), 0.0, 1.0);
mirroredSineMap *= 0.5;
thinkingMap += mirroredSineMap;
float mapSum = waitingMap + listeningMap + thinkingMap;
vec2 cartesian_noise = theta_noise * r_geom;
float noiseFrequency = ((0.00267 + height * 0.004) * (state_0 + state_1) + 0.001333 * state_2) * min(500.0 , max(in_FittedBounds.z, 200.0));
float noise0 = snoise(vec3(cartesian_noise * noiseFrequency, zTime));
float noise1 = snoise(vec3(cartesian_noise * noiseFrequency, zTime + 1.0));
float noise2 = snoise(vec3(cartesian_noise * noiseFrequency, zTime + 2.0));
float abs_noise0 = abs(noise0);
float abs_noise1 = abs(noise1);
float abs_noise2 = abs(noise2);
float abs_noise = max(max(abs_noise0, abs_noise1), abs_noise2);
r_geom.y = max(mapSum * abs_noise * scale.y, device_pixel.y * 2.0 * state_1);
vec2 cartesian_geom = theta_geom * r_geom + center;
vec3 wave_alpha = (1.0 - mapSum * vec3(abs_noise0, abs_noise1, abs_noise2) * 0.95);
wave_alpha *= wave_alpha;
gl_Position = vec4(cartesian_geom, 0.0, 1.0);
out_ChannelCoord = max(mapSum * vec3(abs_noise0, abs_noise1, abs_noise2) * (in_FittedBounds.w * 0.5) * in_ViewportDim_ScreenScale_UnitLength.z, 2.0 * state_1);
out_Alpha3f = wave_alpha * globalAlpha;
out_Alpha1f = wave_falloff * globalAlpha;
out_CenterY = (in_ViewportDim_ScreenScale_UnitLength.y - (in_FittedBounds.y + (in_FittedBounds.w * 0.5)) * in_ViewportDim_ScreenScale_UnitLength.z);
#version 100
varying mediump vec3 out_ChannelCoord;
varying mediump vec3 out_Alpha3f;
varying mediump float out_Alpha1f;
varying mediump float out_CenterY;
void main(void)
   mediump float p = abs(gl_FragCoord.y - out_CenterY);
   mediump vec3 wave_channel = smoothstep(out_ChannelCoord, out_ChannelCoord - 2.0, vec3(p));
   mediump vec4 colorModifier = vec4(0.3,0.3,0.3,0.0);
   mediump vec4 xColor = (vec4(1.0, 0.286, 0.333, out_Alpha1f) + colorModifier * (1.0 - out_Alpha3f.x)) * wave_channel.x;
   mediump vec4 yColor = (vec4(0.298, 0.85, 0.39, out_Alpha1f) + colorModifier * (1.0 - out_Alpha3f.y)) * wave_channel.y;
   mediump vec4 zColor = (vec4(0.0, 0.478, 1.0, out_Alpha1f) + colorModifier * (1.0 - out_Alpha3f.z)) * wave_channel.z;
   mediump vec4 screen = 1.0 - (1.0 - xColor) * (1.0 - yColor) * (1.0 - zColor);
   gl_FragColor = screen;
SUICLocalization
SUICApplicationStateHelper
FBSDisplayLayoutObserver
NSObject
SUICSiriLanguage
SUICAudioLevelSmoother
SUICSemanticContentModifiable
SiriUICore
SUICFauxFlamesImageDataContainer
SUICFauxFlamesView
FlameGroup
SUICFlamesView
@40@0:8@16@24@32
@32@0:8@16@24
@24@0:8@16
v32@0:8@16@24
v32@0:8@"FBSDisplayLayoutMonitor"16@"FBSDisplayLayout"24
v40@0:8@16@24@32
v40@0:8@"FBSDisplayLayoutMonitor"16@"FBSDisplayLayout"24@"FBSDisplayLayoutTransitionContext"32
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8@"Protocol"16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
@"NSString"16@0:8
v16@0:8
v24@0:8@16
v32@0:8@16@?24
@"BKSApplicationStateMonitor"
@"NSMutableArray"
@"NSObject<OS_dispatch_queue>"
v20@0:8B16
@"NSString"
@"<SUICSiriLanguageDelegate>"
@32@0:8f16f20q24
@40@0:8f16f20q24f32f36
@24@0:8q16
f20@0:8f16
f16@0:8
v20@0:8f16
v24@0:8q16
@32@0:8@16Q24
^v16@0:8
@48@0:8{?=ddi*}16
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@32@0:8q16q24
{?="imageHeight"d"imageWidth"d"frameCount"i"fileName"*}
^f16@0:8
v24@0:8^f16
16@0:8
v32@0:816
^16@0:8
v24@0:8^16
v40@0:8@16{CGSize=dd}24
v44@0:8@16{CGSize=dd}24i40
v48@0:8@16{CGSize=dd}24i40B44
v20@0:8i16
@60@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48i56
@60@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16d48i56
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
v24@0:8d16
v28@0:8B16@20
I16@0:8
24@0:816
i56@0:8i16f20f24^^I28i36B40B44^{?=}48
B20@0:8B16
i16@0:8
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
d16@0:8
@"CADisplayLink"
@"EAGLContext"
@"NSMutableSet"
@"FlameGroup"
@"UIScreen"
@"UIImageView"
@"SUICAudioLevelSmoother"
@"<SUICFlamesViewDelegate>"
@"UIImage"
@"UIColor"
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
>fff?
?33s?
?ffffff
MbP?
@(#)PROGRAM:SiriUICore  PROJECT:SiriUICore-1
