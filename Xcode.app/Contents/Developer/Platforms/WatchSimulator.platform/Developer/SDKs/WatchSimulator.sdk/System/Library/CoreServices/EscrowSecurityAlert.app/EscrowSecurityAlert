com.apple.EscrowSecurityAlert
com.apple.EscrowSecurityAlert.server
com.apple.EscrowSecurityAlert.record
com.apple.EscrowSecurityAlert.reset
com.apple.EscrowSecurityAlert.daily
com.apple.security.keychainchanged
com.apple.security.itembackup
com.apple.sbd.kvstorechange
https://support.apple.com/kb/HT205011
https://support.apple.com/kb/HT5834
hash
TI,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
com.apple.EscrowSecurityAlert.notifyQueue
v4@?0
v8@?0@"NSObject<OS_xpc_object>"4
com.apple.notifyd.matching
-[EscrowSecurityAlert handleNotification:]
pendingNotification
TB,V_pendingNotification
isMultiUser
TB,V_isMultiUser
notifyQueue
T@"NSObject<OS_dispatch_queue>",R,&,V_notifyQueue
T@"SecureBackup",R,&,V_sb
delegate
T@"<EscrowSecurityAlertDelegateProtocol>",&,V_delegate
void prompt(EscrowSecurityAlertType)
ESCROW_ELE_ALERT_MESSAGE_TITLE
ESCROW_ELE_ALERT_MESSAGE
NOTNOW
RESETKEYCHAIN
CREATENEWCODE
LEARNMORE
RECORD_BURNED_ALERT_MESSAGE_TITLE
RECORD_BURNED_ALERT_MESSAGE
UPDATECODE
void response(CFUserNotificationRef, CFOptionFlags)
RESET_CONFIRMATION_MESSAGE_TITLE
RESET_CONFIRMATION_MESSAGE
CANCEL
prefs:root=CASTLE&path=Keychain/ADVANCED
void cancelAlert()
notificationDisabled
TB,N,GisNotificationDisabled
shouldAllowSnooze
TB,R,N
alertType
Ti,N
notificationsAllowed
thresholdLevel
notificationType
daemon
init
alloc
isNotificationDisabled
setAlertType:
reset
alertType
prompt:
cancelAlert
isNotificationSnoozed
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
handleTimerEvent
stringWithUTF8String:
handleNotification:
inCircle
getAccountInfoWithInfo:results:
objectForKeyedSubscript:
numberWithBool:
isEqualToNumber:
delegate
numberWithInt:
isEqualToString:
backupWithInfo:
isMultiUser
pendingNotification
setPendingNotification:
notifyQueue
notificationOccurred:
.cxx_destruct
setDelegate:
setIsMultiUser:
_pendingNotification
_isMultiUser
_delegate
_notifyQueue
mainBundle
localizedStringForKey:value:table:
shouldAllowSnooze
dictionaryWithObjects:forKeys:count:
notificationSnoozed
setNotificationDisabled:
disableWithInfo:
URLWithString:
defaultWorkspace
openSensitiveURL:withOptions:
openURL:withOptions:error:
boolValue
intValue
numberWithUnsignedInt:
ESADelegate
EscrowSecurityAlertDelegateProtocol
NSObject
EscrowSecurityAlert
ESALocalSettings
v12@0:4i8
v8@0:4
B8@0:4
i8@0:4
B12@0:4@8
#8@0:4
@8@0:4
@12@0:4:8
@16@0:4:8@12
@20@0:4:8@12@16
B12@0:4#8
B12@0:4@"Protocol"8
B12@0:4:8
Vv8@0:4
I8@0:4
^{_NSZone=}8@0:4
@"NSString"8@0:4
v12@0:4@8
v12@0:4B8
@"<EscrowSecurityAlertDelegateProtocol>"
@"NSObject<OS_dispatch_queue>"
@"SecureBackup"
Daily maintenance
alert: %@
calling dispatch_after() to enqueue notification
in dispatch_after()
notification already pending
Getting info
In %s
Don't replace a ELE notification with one about a burned record
CFUserNotificationUpdate err=%d
Can't make notification err=%x
%s: starting xpc transaction
%s: unexpected xpc transaction count
Exit %s
Error displaying alert: %d
Error getting alert response: %d
Error disabling backup: %@
Error resetting circle: %@
could not open %@: %@
opened %@
canceling alert
%s: ending xpc transaction
@(#)PROGRAM:EscrowSecurityAlert  PROJECT:CloudServices-222.1.6
33333
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>application-identifier</key>
<string>com.apple.EscrowSecurityAlert</string>
<key>com.apple.private.notificationcenter-system</key>
<array>
<dict>
<key>identifier</key>
<string>com.apple.EscrowSecurityAlert</string>
</dict>
</array>
<key>com.apple.securebackupd.access</key>
<true/>
<key>com.apple.springboard.opensensitiveurl</key>
<true/>
</dict>
</plist>
