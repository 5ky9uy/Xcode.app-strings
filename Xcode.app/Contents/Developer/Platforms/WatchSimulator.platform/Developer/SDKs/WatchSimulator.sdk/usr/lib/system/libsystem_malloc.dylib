 @com.apple.Libsystem.malloc
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
@(#)PROGRAM:libsystem_malloc  PROJECT:libmalloc-116.50.8
FATAL ERROR - invalid bitarray level
purgeable zone does not support guard pages
Scalable zone %p: inUse=%u(%y) flags=%d
entry for pointer being discarded from death-row vanished
pointer being freed already on death-row
*** can't vm_purgable_control(..., VM_PURGABLE_SET_STATE) for large freed block at %p
*** can't reset protection for large freed block at %p
entry for pointer being freed from death-row vanished
pointer being freed was not allocated
large entry reallocated is not properly in table
Scalable zone %p: inUse=%u(%y) touched=%y allocated=%y flags=%d
tiny=%u(%y) small=%u(%y) large=%u(%y) huge=%u(%y)
%lu tiny regions:
[%lu tiny regions have been vm_deallocate'd]
%lu small regions:
[%lu small regions have been vm_deallocate'd]
at szone_check counter=%d
check: tiny region incorrect
*** tiny region %ld incorrect szone_check_all(%s) counter=%d
check: tiny free list incorrect
*** tiny free list incorrect (slot=%ld) szone_check_all(%s) counter=%d
check: small region incorrect
*** small region %ld incorrect szone_check_all(%s) counter=%d
check: small free list incorrect
*** small free list incorrect (slot=%ld) szone_check_all(%s) counter=%d
*** error for object %p: %s
*** error: %s
%s*** set a breakpoint in malloc_error_break to debug
*** set a breakpoint in malloc_error_break to debug
MallocErrorStop
*** sending SIGSTOP to help debug
MallocErrorSleep
*** sleeping to help debug
*** can't protect(%p) region for prelude guard page at %p
*** can't protect(%p) region for postlude guard page at %p
can't allocate region
*** mach_vm_map(size=%lu) failed (error code=%d)
can't unmap excess guard region
*** mach_vm_deallocate(addr=%p, size=%lu) failed (code=%d)
can't unmap excess trailing guard region
can't allocate region securely
Can't deallocate_pages region
Non-aligned pointer being freed
Pointer to metadata being freed
Non-aligned pointer being freed (2)
Pointer to metadata being freed (2)
non-page-aligned, non-allocated pointer being freed
pointer being reallocated was not allocated
*** FATAL ERROR - comm page version mismatch.
FATAL ERROR - comm page version mismatch
*** FATAL ERROR - magazine mask exceeds allocated magazines.
FATAL ERROR - magazine mask exceeds allocated magazines
small_free_list_find_by_ptr: ptr is not free (ptr metadata !SMALL_IS_FREE)
ptr=%p msize=%d metadata=0x%x
*** invariant broken: null msize ptr=%p num_small_regions=%d end=%p
*** invariant broken for free block %p this msize=%d
*** invariant broken for %p (next %p is not a free pointer)
*** invariant broken for small free %p followed by %p in region [%p-%p] (end marker incorrect) should be %d; in fact %d
small free list metadata inconsistency (headers[previous] != previous size)
incorrect size information - block header was damaged
small_free_try_depot_unmap_no_lock hash lookup failed:
small_free_try_depot_unmap_no_lock objects_in_use not zero:
small free sizes:
Small region [unknown address] was returned to the OS
Small region [%p-%p, %y] 
bad stack id. turning off stack logging
malloc_entropy
recording malloc and VM allocation stacks to disk using standard recorder
recording malloc (but not VM allocation) stacks to disk using standard recorder
recording VM allocation (but not malloc) stacks to disk using standard recorder
zone[0] is not the normal default zone so can't turn on lite mode.
recording malloc (but not VM allocation) stacks using lite mode
invalid mode %d passed to turn_on_stack_logging
malloc stack logging already enabled.
MallocStackLoggingLiteZone
*** MallocCheckHeap: FAILED check at %dth operation
Stack for last operation where the malloc check succeeded: 
(Use 'atos' for a symbolic stack)
(Use 'atos' for a symbolic stack)
*** Recommend using 'setenv MallocCheckHeapStart %d; setenv MallocCheckHeapEach %d' to narrow down failure
*** MallocCheckHeap: FAILED check
*** Sleeping for %d seconds to leave time to attach
*** Sleeping once for %d seconds to leave time to attach
%s(%d,%p) malloc: 
*** error for object %p: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug
*** error for object %p: pointer being freed was not allocated
*** error: pointer being freed was not allocated
*** malloc was initialized without entropy
System
Malloc
MallocLogFile
Could not open %s, using stderr
MallocGuardEdges
protecting edges
MallocDoNotProtectPrelude
... but not protecting prelude guard page
MallocDoNotProtectPostlude
... but not protecting postlude guard page
MallocStackLogging
MallocStackLoggingNoCompact
lite
malloc
stack logging compaction turned off; size of log files on disk can increase rapidly
stack logging compaction turned off; VM can increase rapidly
MallocScribble
enabling scribbling to detect mods to free blocks
MallocErrorAbort
enabling abort() on bad malloc or free
MallocTracing
MallocCorruptionAbort
MallocCheckHeapStart
MallocCheckHeapEach
checks heap after %dth operation and each %d operations
MallocCheckHeapAbort
will abort on heap corruption
MallocCheckHeapSleep
will sleep for %d seconds on heap corruption
will sleep once for %d seconds on heap corruption
no sleep on heap corruption
MallocHelp
environment variables that can be set for debug:
- MallocLogFile <f> to create/append messages to file <f> instead of stderr
- MallocGuardEdges to add 2 guard pages for each large block
- MallocDoNotProtectPrelude to disable protection (when previous flag set)
- MallocDoNotProtectPostlude to disable protection (when previous flag set)
- MallocStackLogging to record all stacks.  Tools like leaks can then be applied
- MallocStackLoggingNoCompact to record all stacks.  Needed for malloc_history
- MallocStackLoggingDirectory to set location of stack logs, which can grow large; default is /tmp
- MallocScribble to detect writing on free blocks and missing initializers:
  0x55 is written upon free and 0xaa is written on allocation
- MallocCheckHeapStart <n> to start checking the heap after <n> operations
- MallocCheckHeapEach <s> to repeat the checking of the heap after <s> operations
- MallocCheckHeapSleep <t> to sleep <t> seconds on heap corruption
- MallocCheckHeapAbort <b> to abort on heap corruption if <b> is non-zero
- MallocCorruptionAbort to abort on malloc errors, but not on out of memory for 32-bit processes
  MallocCorruptionAbort is always set on 64-bit processes
- MallocErrorAbort to abort on any malloc error, including out of memory
- MallocTracing to emit kdebug trace points on malloc entry points
- MallocHelp - this help!
Attempted to register zone more than once: %p
malloc_zone_register allocation failed: %d
turning off recording malloc and VM allocation stacks to disk using standard recorder
turnning off recording malloc (but not VM allocation) stacks to disk using standard recorder
turning off recording VM allocation (but not malloc) stacks to disk using standard recorder
turning off recording malloc (but not VM allocation) stacks using lite mode
invalid stack_logging_mode %d in turn_off_stack_logging
malloc stack logging not enabled.
*** malloc_default_scalable_zone() failed to find 'DefaultMallocZone'
DefaultPurgeableMallocZone
*** malloc_zone_unregister() failed for %p
*** error for object %p: pointer being realloc'd was not allocated
*** set a breakpoint in malloc_error_break to debug
*** error for object %p: pointer being realloc'd was not allocated
*** error: pointer being realloc'd was not allocated
*** malloc_get_all_zones: error reading zones_address at %p
*** malloc_get_all_zones: error reading num_zones at %p
*** malloc_get_all_zones: error reading zones at %p
ptr %p in registered zone %p
ptr %p not in heap
*** error %d
*** DefaultMallocError called
*** OBSOLETE: malloc_singlethreaded()
*** OBSOLETE: malloc_debug()
DefaultMallocZone
error creating VM region for stack logging output buffers
stack logging disabled due to previous errors.
allocate_pages(): virtual memory exhausted!
error while allocating stack uniquing table
error while allocating stack trace buffer
unable to allocate memory for stack log file path
MallocStackLoggingDirectory
MallocStackLoggingDirectory env var set to unwritable path '%s'
/tmp/
TMPDIR
stack logging postponed until after initialization.
No writeable tmp dir
stack-logs.
.XXXXXX
.index
stack logs being written into %s
unable to create stack logs at %s
0123456789abcdef
sandboxd
taskgated
MallocStackLoggingNoReaping
/private/var/folders
<xx>/<random>/T
stack logs deleted from %s
process %ld no longer exists, stack logs deleted from %s
unable to delete stack logs from %s
expandUniquingTable(): VMCopyFailed
expandUniquingTable(): mach_vm_deallocate failed. [%p]
no more space in uniquing table
circular parent reference in __decrement_table_slot_refcount
Unknown file descriptor; expecting stack logging index file
unable to re-open stack logging file %s
Unable to write to stack logging file %s (%s)
%s%d.
%s/%s
warning: unable to map shared memory from %llx in target process %d; no stack backtraces will be available.
error while attempting to mach_vm_read remote stack uniquing table (%d): %s
error while attempting to mach_vm_read remote stack uniquing table contents (%d): %s
error while attempting to cache information from remote stack index file. (update_cache_for_file_streams)
insufficient data in remote stack index file; expected more records.
impossible collision! two address==address lists! (transfer_node)
reporting bad hash function! disk stack logging reader %lu bit. (transfer_node)
MslUniquingTable
incorrect checksum for freed object - object was probably modified after being freed.
tiny_free_try_depot_unmap_no_lock hash lookup failed:
tiny_free_try_depot_unmap_no_lock objects_in_use not zero:
*** invariant broken for leader block %p - %d %d
*** invariant broken for tiny block %p this msize=%d - size is too small
*** invariant broken for %p this tiny msize=%d - size is too large
*** invariant broken for %p (previous %p is not a free pointer)
*** invariant broken for %p (next in free list %p is not a free pointer)
*** invariant broken for tiny free %p followed by %p in region [%p-%p] (end marker incorrect) should be %d; in fact %d
*** invariant broken for region end %p - %p
*** invariant broken for blocker block %p - %d %d
double free
tiny free sizes:
Magazine %d: 
%s%y[%d]; 
Tiny region [unknown address] was returned to the OS
*** error with %p: msize=%d
*** error at %p msize for in_use is %d
Tiny region [%p-%p, %y] 
Magazine=%d 
Allocations in use=%d 
 Bytes in use=%ly 
Untouched=%ly 
Advised MADV_FREE=%ly
Fragments subject to reclamation=%ly
Sizes in use: 
%d[%d] 
*** in-use ptr in free list slot=%d count=%d ptr=%p
*** unaligned ptr in free list slot=%d  count=%d ptr=%p
*** ptr not in szone slot=%d  count=%d ptr=%p
*** previous incorrectly set slot=%d  count=%d ptr=%p
