CNSt3__120__shared_ptr_emplaceI19CLConnectionMessageNS_9allocatorIS1_EEEE
0E18CLFilteredPressure
N16CLMotionNotifier18CallbackDispatcherIN10CLPressure6SampleEEE
N16CLMotionNotifier10DispatcherE
f@10CLCompass7
21CMDeviceMotionVisitor
N20CMDeviceMotionReport7VisitorE
 @fffff
@<@A
31CLGyroBiasEstimatorClientRemote
15CLNameValuePair
10BasicMutex
5Mutex
11NonCopyable
21DestructionAwareMutex
NSt3__120__shared_ptr_pointerIP29DestructionAwareMutexInternalNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI29DestructionAwareMutexInternalEE
26CLSensorFusionService9Axis
N16CLMotionNotifier18CallbackDispatcherIN15CLAccelerometer6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN14CLCompass_Type6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIbEE
#=L7
17CLRunningVector3dIfE
20CLRunningBufferStatsIfE
CDFGHJKLMNPQRSTVWXYZ
123456789CDFGHJKLMNPQRTVWXY
14CLPlatformInfo
16CLDaemonSettings
NSt3__120__shared_ptr_pointerIP16CLDaemonSettingsN12_GLOBAL__N_112null_deleterENS_9allocatorIS1_EEEE
N12_GLOBAL__N_112null_deleterE
17CLPersistentStore
25CLGyroBiasEstimatorClient
N13CLPreferences10OtherPrefsE
13CLPreferences
NSt3__120__shared_ptr_pointerIP19CLConnectionMessageNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI19CLConnectionMessageEE
10CLCompass6
N16CLMotionNotifier26SingleSamplePollDispatcherIN15CLAccelerometer6SampleEEE
N16CLMotionNotifier26SingleSamplePollDispatcherIN14CLDeviceMotion6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEE
10CLPressure
14CLNotifierBase
31CLGyroCalibrationDatabaseRemote
NSt3__120__shared_ptr_emplaceIN30CLGyroCalibrationDatabase_Type16NotificationDataENS_9allocatorIS2_EEEE
UUUUUU
@333333
?333333
>333333
@?18CLSensorFusionMekf
14CLSensorFusion
17CLRunningVector3dIdE
20CLRunningBufferStatsIdE
ADDED
15CLAccelerometer
6CLGyro
14CLMagnetometer
N16CLMotionNotifier18CallbackDispatcherI19CLMotionTypeVector3EE
16CLMotionNotifier
17CLSensorInterface
?N2CL3Log17logfile_streambufE
zD22CLSensorInterfaceIoHid
NSt3__120__shared_ptr_pointerIP10CLSettingsNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI10CLSettingsEE
@20CLPocketStateService
N16CLMotionNotifier18CallbackDispatcherIN21CLOrientationNotifier6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN19CLProximityNotifier6SampleEEE
MbP?
5CLLog
NSt3__120__shared_ptr_pointerIP19CLCircularLogBufferNS_14default_deleteIS1_EENS_9allocatorIS1_EEEE
NSt3__114default_deleteI19CLCircularLogBufferEE
10CLSettings
29CLSensorFusionService6AxisSPU
$x<:
.s<d=p<
m<D}i<;
a<\Z]<)
D<6'?<
Tr:~/d:
yQ:'
+}<K+u<g
t[<irR<
6<gI-<
;V-k;
24CLSensorInterfaceNetwork
NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
23CLSensorFusion9AxisMekf
23CLCompassDatabaseClient
NSt3__120__shared_ptr_emplaceIN22CLCompassDatabase_Type16NotificationDataENS_9allocatorIS2_EEEE
4@ffffff
T@333333
PAff
31CLAttitudeDependentKFCalibrator
19CLCompassCalibrator
10CLVector3dIjE
10CLMatrix3dIfE
16CLRunningMaximumIfE
@333C
?333333
@X9tB
ff&?
v@14CLMedianFilterIfE
10CLVector3dIfE
17CLCompassDatabase
10CLNotifierIN22CLCompassDatabase_Type12NotificationENS0_16NotificationDataEccE
N22CLCompassDatabase_Type6ClientE
N10CLNotifierIN22CLCompassDatabase_Type12NotificationENS0_16NotificationDataEccE6ClientE
20CLNotifierClientBase
kCMActivityAlarmId
kCMActivityAlarmTrigger
kCMActivityAlarmDuration
_)K;
*>,<
=jZ:
}A.@
>32CLGeomagneticModelProviderClient
NSt3__120__shared_ptr_emplaceIN31CLGeomagneticModelProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
26CLGeomagneticModelProvider
10CLNotifierIN31CLGeomagneticModelProvider_Type12NotificationENS0_16NotificationDataEccE
N31CLGeomagneticModelProvider_Type6ClientE
N10CLNotifierIN31CLGeomagneticModelProvider_Type12NotificationENS0_16NotificationDataEccE6ClientE
12CLCoverState
18CLCoverStateClient
33CLMagnetometerCoexistenceNotifier
9CLCompass
19CLProximityNotifier
39CLMagnetometerCoexistenceNotifierCpasV5
39CLMagnetometerCoexistenceNotifierCpasV6
C43CLMagnetometerCoexistenceNotifierCpasCamera
40CLMagnetometerCoexistenceNotifierCpasV10
ZN25CLNonlinearGyroBiasFitter4evalERKN26CMMotionCoprocessorCommand20NonlinearGyroBiasFitEfE8Receiver
24CMTemperatureFitReceiver
14CLDeviceMotion
N11CLBinaryLog5AccelE
N11CLBinaryLog10BinaryDataE
N11CLBinaryLog10AccelBatchE
N11CLBinaryLog4GyroE
N11CLBinaryLog12GyroOscarEmuE
N11CLBinaryLog15GyroTemperatureE
N11CLBinaryLog11GyroBiasFitE
N11CLBinaryLog6GyroDtE
N11CLBinaryLog12MagnetometerE
N11CLBinaryLog7CompassE
N11CLBinaryLog11GyroCompassE
N11CLBinaryLog18CompassCalibrationE
N11CLBinaryLog8PressureE
N11CLBinaryLog4ProxE
N11CLBinaryLog13TouchOscarEmuE
N11CLBinaryLog12DeviceMotionE
N11CLBinaryLog17MotionStateUpdateE
N11CLBinaryLog8AccelGpsE
N11CLBinaryLog7GyroGpsE
N11CLBinaryLog12BTConnectionE
N11CLBinaryLog15SessionOverrideE
N11CLBinaryLog16LocationOscarEmuE
N11CLBinaryLog20EnhancedDeviceMotionE
N11CLBinaryLog16NonlinearBiasFitE
11CLBinaryLog
N11CLBinaryLog13AccelOscarEmuE
N11CLBinaryLog12AccelGestureE
N11CLBinaryLog19GyroBiasAndVarianceE
N11CLBinaryLog16CompassAlignmentE
N11CLBinaryLog11PressureGpsE
N11CLBinaryLog16PressureOscarEmuE
N11CLBinaryLog16PressureFilteredE
N11CLBinaryLog11GestureHintE
PocketStateMaxMonitorTime
DisablePocketState
N16CLMotionNotifier18CallbackDispatcherIN20CLPocketStateService25CLPocketStateInternalTypeEEE
sA-C
Zw+?
Zwk?
TXA{
21CLOrientationNotifier
?fff
Y?fff?
/C33s?
?333333
)>B`e=
tS>J
Kw>z
40CLMagnetometerCoexistenceNotifierCpasV11
9CLLogBase
25CLGyroCalibrationDatabase
10CLNotifierIN30CLGyroCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE
N30CLGyroCalibrationDatabase_Type6ClientE
N10CLNotifierIN30CLGyroCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE6ClientE
19CLPowerStateService
zt?{
zt?{
?21CLSensorFusionService
23CLSensorFusionServiceAP
16CLGestureService
37CLSensorFusionService3AxisDynamicGyro
@(#)PROGRAM:CoreMotion  PROJECT:CoreLocation-2100.0.12
init
objectForKeyedSubscript:
intValue
_startWatchdogCheckins
dealloc
_stopWatchdogCheckins
sendMessageWithReplySync:
boolValue
setTimerArmed:
isTimerArmed
errorWithDomain:code:userInfo:
integerValue
_handleAlarmDataResponse:withHandler:
_teardown
_isActive
_handleStartStopTimerResponse:withHandler:
_registerForAlarmsWithHandler:
fClientQueue
fWatchdogTimer
fDaemonQueue
fLocationdConnection
_timerArmed
alloc
release
featureAvailability:
_internal
stringWithUTF8String:
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
timeIntervalSinceReferenceDate
numberWithDouble:
numberWithBool:
dictionaryWithObjects:forKeys:count:
isAvailable
isActive
startTimerWithStartTime:periodInterval:reminderInterval:autoReschedule:handler:
stopTimerWithHandler:
queryAlarmDataSince:withHandler:
registerForAlarmsWithHandler:
addOperationWithBlock:
_handleQueryResponse:onQueue:withHandler:
tccServiceMotionAccessWithBlock:
retain
isActivityAvailable
queryActivityStartingFromDate:toDate:toQueue:withHandler:
startActivityUpdatesToQueue:withHandler:
stopActivityUpdates
fLocationConnection
fQueue
fHandler
fHandlerQueue
initWithTimestamp:
copy
initWithCoder:
decodeDoubleForKey:
decodeIntegerForKey:
class
decodeObjectOfClass:forKey:
allocWithZone:
timestamp
initWithStartDate:recordId:session:mets:natalies:basalNatalies:timestamp:sourceId:
encodeWithCoder:
encodeDouble:forKey:
encodeInteger:forKey:
encodeObject:forKey:
dateWithTimeIntervalSinceReferenceDate:
numberWithInt:
recordId
startDate
sessionName:
mets
stringValue
natalies
basalNatalies
sourceId
stringWithFormat:
supportsSecureCoding
maxNatalieEntries
copyWithZone:
session
description
fRecordId
fStartDate
fSession
fMets
fNatalies
fBasalNatalies
fSourceId
setAcceleration:
initWithAcceleration:
fAcceleration
initWithAcceleration:andTimestamp:
acceleration
setAltitude:andPressure:
initWithAltitude:andPressure:
fAltitude
fPressure
initWithAltitude:andTimestamp:atBaseAltitude:
relativeAltitude
pressure
initWithUUIDBytes:
initWithTimeIntervalSinceReferenceDate:
initWithDouble:
initWithRecordId:sourceId:startDate:endDate:elevationAscended:elevationDescended:
endDate
elevationAscended
elevationDescended
initWithSignificantElevation:
fEndDate
fElevationAscended
fElevationDescended
UTF8String
cStringUsingEncoding:
mainBundle
objectForInfoDictionaryKey:
timeRange
deviceId
initWithTimeRange:deviceId:
fTimeRange
fDeviceId
doubleValue
initWithStartDate:endDate:
autorelease
mostRecentVehicleConnection
mostRecentInVehicle
lastPathComponent
fileURLWithPath:isDirectory:
dataWithContentsOfURL:options:error:
domain
isEqual:
code
writeToURL:options:error:
assertInside
sharedApplication
performSelector:
applicationState
objectForKey:
initWithSessionId:type:
sessionId
type
workoutName:
natalieDataSessionFromWorkoutType:
workoutTypeFromNatalieDataSession:
fSessionId
fType
initWithSessionId:location:poolLength:
location
swimLocationName:
poolLength
fLocation
fPoolLength
defaultManager
currentDirectoryPath
stringByAppendingString:
setQuaternion:
initWithQuaternion:
setDeviceMotion:
initWithDeviceMotion:
fGravity
fUserAcceleration
fRotationRate
fAttitude
fMagneticField
fMagneticFieldCalibrationLevel
fDoingYawCorrection
fDoingBiasEstimation
decodeBoolForKey:
quaternion
encodeBool:forKey:
magneticField
initWithDeviceMotion:andTimestamp:
attitude
rotationRate
gravity
userAcceleration
magneticFieldCalibrationLevel
doingYawCorrection
doingBiasEstimation
fQuaternion
pitch
roll
rotationMatrix
multiplyByInverseOfAttitude:
setAmbientPressure:
initWithPressure:
initWithPressure:andTimestamp:
ambientPressure
resetWithData:timestamp:walltime:identifier:
decodeFloatForKey:
encodeFloat:forKey:
initWithData:timestamp:walltime:identifier:
identifier
_startDateValue
_accelerationValue
_timestampValue
_identifier
newAccelMetaSinceID:
initWithCapacity:
_updateCurrentBlockProperties
_updatePointers
newAccelMetaFrom:to:
count
objectAtIndexedSubscript:
teardown
dataIdentifier
startTime
offset
addObject:
retainCount
setObject:atIndexedSubscript:
dataSize
newAccelMetaByID:
newAccelDataByID:metaID:
countByEnumeratingWithState:objects:count:
initWithIdentifier:
initFrom:to:
.cxx_construct
fProxy
fDataBuffer
fCurrentBlock
fCurrentBlockIdentifier
fCurrentBlockDataIdentifier
fCurrentBlockStartTime
fCurrentBlockTimestamp
fDataBufferPtr
fDataBufferLength
fCurrentIdentifier
fStartingIdentifier
fRetrievedDataBufferIdentifier
fBlockOffset
fAccelUnpacker
fCachedAccel
fMetaArray
_newAccelMetaUsingMessage:withIdentifier:
setIdentifier:
sendMessageSync:onConnection:timeoutAfter:withReplyHandler:
setStartTime:
setEndTime:
setMetaIdentifier:
fInternalQueue
tccServiceMotionAccessWithLabel:
timeIntervalSinceDate:
dateByAddingTimeInterval:
setDuration:
isAccelerometerRecordingAvailable
isAuthorizedForRecording
accelerometerDataSinceId:
accelerometerDataFromDate:toDate:
recordAccelerometerForDuration:
accelerometerDataFrom:to:
recordAccelerometerFor:
accelerometerDataSince:
initWithMode:
mode
register:forNotification:registrationInfo:
unregister:forNotification:
fTimestamp
_internalLogItem
dataWithPropertyList:format:options:error:
bytes
length
dataWithBytes:length:
propertyListWithData:options:format:error:
dictionaryWithObjectsAndKeys:
initWithBytesNoCopy:length:freeWhenDone:
handleFailureInFunction:file:lineNumber:description:
clientLocation
timeZoneWithName:
archivedDataWithRootObject:
isWakeGestureAvailable
hasSlowBootArgs
_stopOdometerUpdates
odometer
delegate
odometer:didUpdateGpsAvailability:
respondsToSelector:
getExecutablePathFromPid:
setTotalDistance:
totalDistance
setStartDate:
setAverageSpeed:
distance
currentSpeed
averageSpeed
initWithDistance:startDate:endDate:currentSpeed:averageSpeed:
initWithOdometer:
_startDaemonConnection
_startOdometerUpdatesWithHandler:
setOdometer:
fCallbackQueue
fGpsAvailability
_odometer
_totalDistance
_averageSpeed
_startDate
odometerProxy
startOdometerUpdatesForActivity:withHandler:
stopOdometerUpdates
setDelegate:
_delegate
_odometerProxy
initWithStartDate:recordId:sourceId:
maxExerciseMinuteDataEntries
setRotationRate:
initWithRotationRate:
initWithRotationRate:andTimestamp:
lastObject
removeLastObject
becameFatallyBlocked:
sync:
doAsync:
doAsync:withReply:
syncgetDoSync:
forget:
beginService
endService
registerDelegate:inSilo:
setOpaqueTag:
isSupported
getSilo
performSyncOnSilo:invoker:
valid
setValid:
self
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
zone
hash
superclass
debugDescription
onNotification:withData:
initWithInboundProtocol:outboundProtocol:andSilo:
silo
setAdaptedNotifier:
notifier
adaptee
initInSilo:
data
initWithData:destructor:
initWithCatherine:confidence:timestamp:
catherine
confidence
_catherine
_confidence
mutableCopy
resetBytesInRange:
resourcePath
initWithAge:gender:height:weight:condition:
gender
genderString:
height
weight
condition
initWithAge:gender:height:weight:
fAge
fGender
fHeight
fWeight
fCondition
initWithStartDate:firedDate:alarmType:didWake:
firedDate
didWake
alarmType
fFiredDate
fAlarmType
fDidWake
arrayWithCapacity:
arrayWithArray:
initWithUTF8String:
_startUpdatesFromRecord:handler:
_queryExerciseMinutesFromRecord:handler:
_startUpdatesWithHandler:
numberWithInteger:
UUIDString
UUID
_stopUpdates
fAppQueue
fStartedUpdates
fMostRecentRecord
isExerciseMinuteAvailable
startUpdatesFromRecord:handler:
stopUpdates
startUpdatesWithHandler:
queryExerciseMinutesFromRecord:handler:
liftMotionManagerDidRegisterForNotifications:
liftMotionManagerDidUnregisterForNotifications:
liftMotionManagerDidReceiveNotification:liftTransition:
registerForLiftNotifications
unregisterForLiftNotifications
fDelegate
fAccelerometerDispatcher
fLiftDetector
fSender
fPrevLiftState
main
setUnderlyingQueue:
processInfo
processName
initWithFormat:
stationary
_setSession:withCompletionHandler:
_handleQueryResponse:withHandler:
unsignedIntegerValue
_queryAbsoluteNatalimetryDataSinceRecord:withHandler:
_queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:
_startAbsoluteNatalimetryDataUpdatesWithHandler:
_stopAbsoluteNatalimetryDataUpdates
_promptsNeeded
fResendActivityOverrideOnInterrupt
fActivityOverride
numberWithFloat:
numberWithUnsignedInt:
setUserProfile:error:
isPaceAvailable
_shouldAllowMotionCalibrationPromptsForSession:
briskMinuteMetsThreshold
activeMetsThreshold
userProfile
defaultUserProfile
setUserInfo:error:
resetCalibrationDataWithError:
isNatalimeterAvailable
computeRestingCaloriesAtRate:user:duration:
setSession:withCompletionHandler:
queryAbsoluteNatalimetryDataSinceRecord:withHandler:
queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:
startAbsoluteNatalimetryDataUpdatesWithHandler:
stopAbsoluteNatalimetryDataUpdates
getSupportedMetricsForSession:
promptsNeededForSession:
setMagneticField:
initWithMagneticField:
initWithMagneticField:andTimestamp:
contentsOfDirectoryAtPath:error:
reverseObjectEnumerator
objectEnumerator
fAccelerometerUpdateInterval
fGyroUpdateInterval
fDeviceMotionUpdateInterval
fMagnetometerUpdateInterval
fShowsDeviceMovementDisplay
availableAttitudeReferenceFrames
sharedManager
isAccelerometerAvailable
isAccelerometerActive
setAccelerometerUpdateInterval:
accelerometerUpdateInterval
accelerometerData
startAccelerometerUpdatesToQueue:withHandler:
startAccelerometerUpdates
stopAccelerometerUpdates
isGyroAvailable
isGyroActive
setGyroUpdateInterval:
gyroUpdateInterval
gyroData
startGyroUpdates
startGyroUpdatesToQueue:withHandler:
stopGyroUpdates
isDeviceMotionAvailable
isDeviceMotionActive
setDeviceMotionUpdateInterval:
deviceMotionUpdateInterval
attitudeReferenceFrame
deviceMotion
startDeviceMotionUpdatesToQueue:withHandler:
startDeviceMotionUpdates
startDeviceMotionUpdatesUsingReferenceFrame:
startDeviceMotionUpdatesUsingReferenceFrame:toQueue:withHandler:
stopDeviceMotionUpdates
setShowsDeviceMovementDisplay:
showsDeviceMovementDisplay
dismissDeviceMovementDisplay
isMagnetometerAvailable
isMagnetometerActive
setMagnetometerUpdateInterval:
magnetometerUpdateInterval
magnetometerData
startMagnetometerUpdatesToQueue:withHandler:
startMagnetometerUpdates
stopMagnetometerUpdates
removeObjectForKey:
setObject:forKeyedSubscript:
unarchiveObjectWithData:
initWithSignificantElevationSample:
activity
initWithMotionActivity:
isMoving
isWalking
isRunning
isDriving
maybeExitingVehicle
hasExitedVehicle
fActivity
enumerateKeysAndObjectsUsingBlock:
startWatchdogCheckinsPrivate
stopWatchdogCheckinsPrivate
initWithPriority:
startGestureUpdatesWithHandlerPrivate:
stopGestureUpdatesPrivate
fPriority
fGestureHandler
fWatchDogTimer
fPrivateQueue
isGestureServiceEnabled
isGestureServiceAvailable
setGestureServiceEnabled:
setGestureHandler:
gestureHandler
disconnect
connect
startActivityUpdatesWithHandlerPrivate:
stopActivityUpdatesPrivate
overrideOscarSideband:withState:
simulateMotionState:withState:
fActivityHandler
fSubscribedToMotionState
fSidebandOverrideSemaphore
fSidebandOverrideQueue
fSidebandOverrideWaiting
fSidebandOverrideResult
fMotionStateSimSemaphore
fMotionStateSimQueue
fMotionStateSimWaiting
fMotionStateSimResult
setActivityHandler:
activityHandler
isFloorCountingAvailable
numberOfSteps
numberOfPushes
floorsAscended
floorsDescended
activeTime
currentPace
currentCadence
isOdometerDistance
isOdometerPace
initWithStartDate:endDate:steps:distance:floorsAscended:floorsDescended:recordID:currentPace:currentCadence:activeTime:sourceId:isOdometerDistance:isOdometerPace:pushes:workoutType:
_internalQueryPedometerDataFromDate:toDate:onQueue:withHandler:
isStepCountingAvailable
date
localizedDescription
_handleRecordQueryResponse:withHandler:
_queryPedometerDataFromDate:toDate:withHandler:
_startPedometerUpdatesFromDate:withHandler:
_stopPedometerUpdates
_queryPedometerDataSinceDataRecord:withHandler:
_startPedometerEventUpdatesWithHandler:
_stopPedometerEventUpdates
fStepCountFromStart
fPushCountFromStart
fStepCountOffset
fPushCountOffset
fDistanceFromStart
fDistanceOffset
fFloorAscendedStart
fFloorAscendedOffset
fFloorDescendedStart
fFloorDescendedOffset
fActiveTimeFromStart
fActiveTimeOffset
fValidStartDate
fStopUpdates
fFloorCountingAvailable
fPaceAndCadenceAvailable
fEventHandler
fStopEventUpdates
fWorkoutType
pedometerProxy
_pedometerDataWithRecordID:
isDistanceAvailable
isCadenceAvailable
isPedometerEventTrackingAvailable
queryPedometerDataFromDate:toDate:withHandler:
startPedometerUpdatesFromDate:withHandler:
stopPedometerUpdates
queryPedometerDataSinceRecord:withHandler:
queryPedometerDataSinceDataRecord:withHandler:
startPedometerEventUpdatesWithHandler:
stopPedometerEventUpdates
_pedometerProxy
async:
isServiceEnabled:
ensureServiceIsRunning:
getSiloForService:
invalidate
initWithClient:
proxyForService:
interfaceWithProtocol:base:
proxyForRecipientObject:inSilo:withInboundInterface:andOutboundInterface:
cl_json_serializeValue:
cl_json_serializeKey
userInfo
dictionaryWithDictionary:
floatValue
unsignedIntValue
initWithDeviceMotionLite:andDeviceID:
startDeviceMotionLiteUpdatesForDeviceID:usingConfiguration:toQueue:withFusedHandler:debugHandler:
isDeviceMotionLiteAvailable
startDeviceMotionLiteFusedUpdatesForDeviceID:toQueue:withHandler:
startDeviceMotionLiteDebugUpdatesForDeviceID:toQueue:withHandler:
stopDeviceMotionLiteUpdatesForDeviceID:
_endDate
_distance
_currentSpeed
showCalibrationAlert
dismissCalibrationAlert
decodeInt64ForKey:
decodeInt32ForKey:
encodeInt64:forKey:
encodeInt32:forKey:
setTimestamp:
setDataIdentifier:
setOffset:
setDataSize:
movement
setMovement:
_movement
_offset
_dataSize
_startTime
_timestamp
_dataIdentifier
endTime
_endTime
metaIdentifier
_metaIdentifier
duration
_duration
unknown
walking
running
automotive
cycling
isVehicleConnected
fState
initWithInt:
initWithInteger:
averageActivePace
maxPedometerEntries
workoutType
fNumberOfSteps
fDistance
fFloorsAscended
fFloorsDescended
fCurrentPace
fCurrentCadence
fActiveTime
fIsOdometerDistance
fIsOdometerPace
fNumberOfPushes
initWithEventDate:type:
eventStringFromType:
fDate
decodeIntForKey:
encodeInt:forKey:
initWithOrientation:andTimestamp:
orientation
fOrientation
onDeviceOrientation:
fSampleLock
fDeviceOrientationDispatcher
fDeviceOrientationHandler
fDeviceOrientationQueue
fDeviceOrientationSemaphore
fDidSignalSemaphore
fOrientationCallbackMode
fEnableOrientationNotification
fLatestDeviceOrientationSample
fLastSignificantOrientationSample
currentThread
isMainThread
isMultiThreaded
dummySelector:
detachNewThreadSelector:toTarget:withObject:
initPrivate
onMotionPreferencesUpdated
deallocPrivate
defaultCenter
removeObserver:
stopDeviceOrientationUpdatesPrivate
onNotification:
addObserver:selector:name:object:suspensionBehavior:
setDeviceOrientationCallbackModePrivate:
startDeviceOrientationUpdatesPrivateToQueue:withHandler:
isDeviceOrientationAvailable
signalAndReleaseSemaphoreIfNecessaryPrivate
updateAggregateDictionaryPrivate
orientationNotificationsDisabled
stringForOrientation:
initialize
isDeviceOrientationActive
startDeviceOrientationUpdatesToQueue:withHandler:
stopDeviceOrientationUpdates
deviceOrientationBlocking
setMode:
fMode
initWithQueue:andBlock:
dispatchWithState:andError:
fQueryQueue
fQueryBlock
setUpCMLogging
isPocketStateAvailable
removeObserver:name:object:
onPocketStateUpdated:
queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:
addToAggdScalarWithName:andScalar:
translateInternalState:
externalStateToString:
removeAllObjects
pocketStateManager:didUpdateState:
_disableDispatcher
queryStateOntoQueue:withTimeout:andHandler:
fQueryTimer
fCachedState
fDispatcher
fMaxMonitorTime
fQueryBlocks
initWithDate:liftTransition:
liftTransition
fLiftTransition
_feedCatherine:confidence:timestamp:
internal
feedCatherine:confidence:
setDateFormat:
stringFromDate:
arrayWithObjects:count:
componentsJoinedByString:
stringByAppendingPathComponent:
URLsForDirectory:inDomains:
objectAtIndex:
path
bundleIdentifier
firstObject
isMotionActivityEntitled
logDirectory
fire
trigger
activityAlarmAvailable
setObject:forKey:
sharedInstance
listenForActivityAlarm:
stopListeningForActivityAlarm:
fAlarmCounter
fAlarms
fReplyQueue
fAlarmAvailable
setTrigger:
activityAlarmInfo
initWithTrigger:duration:onQueue:withHandler:
initWithTrigger:duration:onRunLoop:withHandler:
isValid
fIsValid
fRunLoop
_trigger
_queryStepCountStartingFromInternal:to:toQueue:withHandler:
_startStepCountingUpdatesToQueue:updateOn:withHandler:
fPrevStepCount
stepcounterProxy
queryStepCountStartingFrom:to:toQueue:withHandler:
startStepCountingUpdatesToQueue:updateOn:withHandler:
stopStepCountingUpdates
enabled
getTotalCountToQueue:withHandler:
deleteHistory
setEnabled:
_stepcounterProxy
initWithString:
decodeObjectForKey:
unsignedLongLongValue
numberWithUnsignedLongLong:
tilt
rawAcceleration
rawRotationRate
machTimestamp
physicalDeviceUniqueID
fRawAcceleration
fRawRotationRate
fMachTimestamp
fPhysicalDeviceUniqueID
assertOutside
newTimer
afterInterval:async:
.cxx_destruct
timer
shouldFire
queue
reflectNextFireTime:fireInterval:
setTimer:
initWithDispatchSilo:
source
setSource:
_source
initInSilo:withScheduler:
setName:
initWithUnderlyingQueue:
initMain
operationQueue
_queue
_operationQueue
updateScheduler
setNextFireAfterDelay:
setNextFireTime:
setFireInterval:
setNextFireAfterDelay:interval:
setNextFireTime:interval:
handler
setHandler:
nextFireTime
fireInterval
_silo
_scheduler
_handler
_nextFireTime
_fireInterval
rangeOfString:options:
hasSuffixInsensitive:
numberOfArguments
methodReturnLength
hasPrefix:
getArgumentTypeAtIndex:
initWithSelector:andMethodSignature:
numArguments
replyBlockIndex
returnAddressIndex
returnValueSize
_numArguments
_replyBlockIndex
_returnAddressIndex
_returnValueSize
_sel
_sig
_str
signatureWithObjCTypes:
initWithProtocol:base:
appendString:
appendFormat:
getInfoForSelector:
protocol
_selectors
_protocol
_startElevationUpdatesWithHandler:
_stopElevationUpdates
_startSignificantElevationUpdatesWithHandler:
_stopSignificantElevationUpdates
_querySignificantElevationChangeFromDate:toDate:withHandler:
fFilteredPressureDispatcher
fRelativeAltimeterHandler
fRelativeAltimeterQueue
fBaseAltimeterSample
fBarometricBaseAltitude
fBaselineReceived
fPressureSamples
fSignificantElevationSampleHandler
fElevationAscendedOffset
fElevationDescendedOffset
onFilteredPressure:
cancelAllOperations
stopRelativeAltitudeUpdatesPrivate
isRelativeAltitudeAvailable
startRelativeAltitudeUpdatesPrivateToQueue:withHandler:
isSignificantElevationAvailable
startRelativeAltitudeUpdatesToQueue:withHandler:
stopRelativeAltitudeUpdates
startSignificantElevationUpdatesWithHandler:
stopSignificantElevationUpdates
querySignificantElevationChangeFromDate:toDate:withHandler:
isElevationAvailable
startElevationUpdatesWithHandler:
stopElevationUpdates
initWithUUIDString:
initWithSessionId:
_handleUpdates:
strokeCount
lapCount
strokeType
initWithRecordId:sourceId:sessionId:startDate:endDate:strokeCount:distance:avgPace:lapCount:strokeType:
_querySwimUpdatesFromRecord:handler:
fStrokeCountOffset
fLapCountOffset
maxSwimDataEntries
querySwimUpdatesFromRecord:handler:
getUUIDBytes:
avgPace
strokeTypeName:
convertToSwimEntry:
initWithSwimEntry:
fStrokeCount
fAvgPace
fLapCount
fStrokeType
initWithDelegateInterface:proxiedInterface:delegateObject:delegateSilo:andUninitializedPeer:
initWithDelegateInterface:proxiedInterface:andUninitializedPeer:
selector
argumentsRetained
getArgument:atIndex:
raise:format:
setTarget:
retainArguments
invoke
setArgument:atIndex:
delegateSilo
invokeWithTarget:
methodSignatureForSelector:
forwardInvocation:
delegateInterface
proxiedInterface
_peer
_asymStrongPeer
_last
_opaqueTag
_delegateSilo
_delegateInterface
_proxiedInterface
initWithOnBodyResult:confidence:timestamp:
result
fResult
fConfidence
inboundInterface
outboundInterface
isHydrated
_valid
_inboundInterface
_outboundInterface
logAssert
startWakeGestureUpdates
stopWakeGestureUpdates
simulateGestureWithDelay:Duration:
initTrackingService:
service
synCount
ackCount
_synCount
_ackCount
_service
array
compare:
sortUsingComparator:
insertObject:atIndex:
dictionary
rereadConfiguration
getKeyClass:andSilo:forServiceWithName:
getServiceWithName:
retireServiceWithName:
isServiceRunning:
proxyForService:forClient:
isOnBodyStatusDetectionAvailable
startOnBodyStatusDetectionPrivateToQueue:withParameters:handler:
stopOnBodyStatusDetectionPrivate
sharedOnBodyStatusManager
startOnBodyStatusDetectionToQueue:withParameters:handler:
stopOnBodyStatusDetection
setPropertiesWithDictionary:
fSubscribedToOnBodyStatusDetection
fOnBodyStatusQueue
fOnBodyStatusHandler
setData:
setDestructor:
destructor
_data
_destructor
_client
notifierClientNumForCoparty:
_clients
_notifier
_handleDaemonEvent:
_startWorkout:
_unregisterForWorkoutEvents
swimWorkoutInstance:
_handleDaemonResponse:
workoutManagerDidFail:workout:error:
workoutManagerDidStartWorkout:workout:startDate:
workoutManagerDidStopWorkout:workout:stopDate:
workoutManagerWillPauseWorkout:workout:pauseDate:
workoutManagerWillResumeWorkout:workout:resumeDate:
_stopWorkout:
_registerForWorkoutEvents
fWorkout
fResumeWorkoutOnInterrupt
startWorkout:
stopWorkout:
supportedMetricsForWorkoutType:
com.apple.CoreMotion.CMSedentaryTimer.client
com.apple.CoreMotion.CMSedentaryTimer.daemon
com.apple.locationd.registration
kCLConnectionMessageRegistration
__33-[CMSedentaryTimer_Internal init]_block_invoke
CoreLocation: Returned with CMError code %d
Returned with CMError code %d
Location %s
v24@?0{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}8
kCLConnectionMessageSedentaryTimerIsArmed
v8@?0
-[CMSedentaryTimer_Internal _handleStartStopTimerResponse:withHandler:]
CoreLocation: Unable to parse start / stop timer message!
Unable to parse start / stop timer message!
kCLConnectionMessageSedentaryTimerStart
kCLConnectionMessageSedentaryTimerStop
-[CMSedentaryTimer_Internal _handleAlarmDataResponse:withHandler:]
CoreLocation: Unable to parse kCLConnectionMessageSedentaryTimer message!
Unable to parse kCLConnectionMessageSedentaryTimer message!
kCLConnectionMessageSedentaryTimerAlarm
kCLConnectionMessageWatchdog
timerArmed
TB,N,GisTimerArmed,V_timerArmed
kCLConnectionMessageSedentaryTimerIsAvailable
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMSedentaryTimer.mm
<Unknown File>
Invalid parameter not satisfying: %@
handler
startTime
queryHandler
kCLConnectionMessageSedentaryTimerQuery
updateHandler
kCLConnectionMessageSubscribeKey
_internal
T@"CMSedentaryTimer_Internal",R,N,V_internal
kCLConnectionMessageMotionActivityAvailable
com.apple.CoreMotion.CMMotionActivityManager
kCLConnectionMessageMotionActivityUpdate
__31-[CMMotionActivityManager init]_block_invoke
CoreLocation: Error occurred while trying to retrieve motion state update: CMErrorDomain Code:%d
Error occurred while trying to retrieve motion state update: CMErrorDomain Code:%d
CoreLocation: Unable to parse kCLConnectionMessageMotionActivityUpdate message!
Unable to parse kCLConnectionMessageMotionActivityUpdate message!
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMMotionActivityManager.mm
start
queue
kCLConnectionMessageMotionActivityQuery
None
Walking
Running
Cycling
OutdoorCycling
IndoorCycling
Yoga
Dancing
CrossTraining
Elliptical
Climbing
StairClimbing
Rowing
ResistanceTraining
GenericWorkout
OutdoorWalking
IndoorWalking
OutdoorRunning
IndoorRunning
%@, <recordId %lu, startDate %@, session %@, mets %@, natalies %@, basalNatalies %@, sourceId %@> @ %f
recordId
Tq,R,N
sourceId
T@"NSUUID",R,N
startDate
T@"NSDate",R,N
mets
T@"NSNumber",R,N
natalies
basalNatalies
session
kNatalieDataCodingKeyStartDate
kNatalieDataCodingKeyRecordId
kNatalieDataCodingKeySession
kNatalieDataCodingKeyMets
kNatalieDataCodingKeyNatalies
kNatalieDataCodingKeyBasalNatalies
kNatalieDataCodingKeySourceId
x %f y %f z %f @ %f
acceleration
T{?=ddd},R,N
kCMAccelerationCodingKeyX
kCMAccelerationCodingKeyY
kCMAccelerationCodingKeyZ
CMErrorDomain
LogFilteredPressure
CLFilteredPressure
virtual void CLFilteredPressure::numberOfSpectatorsChanged(int, size_t)
CoreLocation: Unrecognized notification
Unrecognized notification
SENSOR
void CLFilteredPressure::onPressureData(const CLPressure::Sample *)
CoreLocation: Type,%s,pressure,%.6f,temperature,%.3f,timestamp,%f
PressureFiltered
Altitude %f Pressure %f @ %f
relativeAltitude
pressure
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMAltitude.mm
sourceId && startDate && endDate && elevationAscended && elevationDescended
%@, <startDate, %@, endDate, %@, elevationAscended, %@ elevationDescended, %@>
supportsSecureCoding
TB,R
TQ,R,N,VfRecordId
T@"NSUUID",R,N,VfSourceId
T@"NSDate",R,N,VfStartDate
endDate
T@"NSDate",R,N,VfEndDate
elevationAscended
T@"NSNumber",R,N,VfElevationAscended
elevationDescended
T@"NSNumber",R,N,VfElevationDescended
kCMAltitudeCodingKeyAltitude
kCMAltitudeCodingKeyPressure
kCMSignificantElevationCodingKeyRecordId
kCMSignificantElevationCodingKeySourceId
kCMSignificantElevationCodingKeyStartDate
kCMSignificantElevationCodingKeyEndDate
kCMSignificantElevationCodingKeyElevationAscended
kCMSignificantElevationCodingKeyElevationDescended
CLClientRef CLClientAllocate(CFAllocatorRef, CLClientCallback, const CLClientContext *)
CoreLocation: non-matching retain (%p) and release (%p) functions in context, ignoring
CoreLocation: Failed to initilize fHeadingCalibrationDisplayMutex, error code: %{public}d
com.apple.CoreLocation.%p
CLClientRef CLClientCreateWithBundleIdentifierAndPath(CFAllocatorRef, CLClientCallback, const CLClientContext *, CFStringRef, CFStringRef)
CoreLocation: CLClient is deprecated. Will be obsolete soon.
A location manager (%p) was created on a dispatch queue executing on a thread other than the main thread.  It is the developer's responsibility to ensure that there is a run loop running on the thread on which the location manager object is allocated.  In particular, creating location managers in arbitrary dispatch queues (not attached to the main queue) is not supported and will result in callbacks not being received.
CLClientRef _CLClientCreateWithBundleIdentifierAndPath(CFAllocatorRef, CLClientCallback, const CLClientContext *, CFStringRef, CFStringRef)
CoreLocation: Location manager created on a dispatch queue exectuing on non-main thread, notifying client
CoreLocation: #warning Could not register with daemon immediately, will retry later
<CLClient %p [%p]>
CLClient
void CLClientInvokeCallback(CLClientRef, CLClientEvent, id)
CoreLocation: Discarding message for event %{private}d because of too many unprocessed messages
CoreLocation: Location callback block not executed in a timely manner!
void CLClientHandleWillResignActiveNotification(CFNotificationCenterRef, void *, CFStringRef, const void *, CFDictionaryRef)
CoreLocation: received client will resign active notification
___Z41CLClientHandleDidBecomeActiveNotificationP22__CFNotificationCenterPvPK10__CFStringPKvPK14__CFDictionary_block_invoke
CoreLocation: received client did become active notification
void CLClientHandleRegistrationTimerExpiry(CFRunLoopTimerRef, void *)
CoreLocation: Registration timer expired, but client is still registering!
kCLConnectionMessagePurposeKey
kCLConnectionMessagePurpose
void CLClientRequestAuthorization(CLClientRef, CLClientAuthorizationStatus)
CoreLocation: Missing UsageDescription key for requsted authorization: %{public}d
This app has attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an %@ key with a string value explaining to the user how the app uses this data
kCLConnectionMessageStatusKey
kCLConnectionMessageRequestAuthorization
Boolean CLClientIsLocationServicesEnabled(CLClientRef)
CoreLocation: CLInternalGetLocationServicesEnabled failed: could not reach daemon
Boolean CLClientShutdownDaemon(CLClientRef)
Boolean CLClientLogDump(CLClientRef, const char *, Boolean)
kCLConnectionMessageDesiredAccuracyKey
kCLConnectionMessageDistanceFilterKey
kCLConnectionMessageOperatingModeKey
kCLConnectionMessageDynamicAccuracyReductionKey
kCLConnectionMessageAlteredAccessoryLocationsKey
kCLConnectionMessageLocation
kCLConnectionMessageEnabledKey
kCLConnectionMessageIsActuallyAWatchKitExtension
kCLConnectionMessageProxyForRemoteClient
kCLConnectionMessageHeadingFilterKey
kCLConnectionMessageHeading
kCLConnectionMessageSignificantLocationChange
kCLConnectionMessageSignificantLocationVisit
kCLConnectionMessageMicroLocation
kCLConnectionMessageRequestMicroLocation
kCLConnectionMessageNameKey
kCLConnectionMessageOnBehalfOfKey
kCLConnectionMessageNotifyOnEntryKey
kCLConnectionMessageNotifyOnExitKey
kCLConnectionMessageConservativeEntry
kCLConnectionMessageRegionTypeKey
kCLConnectionMessageLatitudeKey
kCLConnectionMessageLongitudeKey
kCLConnectionMessageRadiusKey
kCLConnectionMessageReferenceFrameKey
kCLConnectionMessageRegionDefinitionKey
kCLConnectionMessageProximityUUIDKey
kCLConnectionMessageMajorKey
kCLConnectionMessageMinorKey
kCLConnectionMessageNotifyEntryStateOnDisplayKey
kCLConnectionMessageRegionMonitoring
Boolean CLClientRequestRegionState(CLClientRef, CLClientRegion *)
CoreLocation: Fence: CLClientRequestRegionState, unsupported fence type
kCLConnectionMessageRegionState
kCLConnectionMessageBeaconRegionKey
kCLConnectionMessageCircularRegionKey
kCLConnectionMessageRangingPeersKey
kCLConnectionMessageRangingPeerTimeoutKey
kCLConnectionMessageRangingPeerInitiatorKey
kCLConnectionMessagePeerRanging
IsFitnessMatch
Boolean CLClientGetLocationUnavailable(CLClientRef, CLClientLocationUnavailable *)
CoreLocation: Function deprecated
kCLConnectionMessageError
kCLConnectionMessageErrorKey
kCLConnectionMessageEventKey
kCLConnectionMessageLocationKey
kCLConnectionMessageAlternateRegionKey
kCLConnectionMessageIdentifierKey
kCLConnectionMessageRegionsKey
kCLConnectionMessageRanging
kCLConnectionMessageBeaconsKey
kCLConnectionMessageAuthorizationStatus
kCLConnectionMessageMatchInfoEnabled
kCLConnectionMessagePersistentMonitoringEnabled
kCLConnectionMessageAllowsLocationPrompts
kCLConnectionMessageShowLocationPrompt
kCLConnectionMessageMarkAsHavingReceivedLocation
kCLConnectionMessageActivityTypeKey
kCLConnectionMessageActivityType
kCLConnectionMessagePausesLocationUpdatesAutomaticallyKey
kCLConnectionMessagePausesLocationUpdatesAutomatically
Boolean CLClientGetAutopauseState(CFDictionaryRef, Boolean *, Boolean *)
CoreLocation: Invalid call to CLClientGetAutopauseState
kCLConnectionMessageAutopauseStatusKey
kCLConnectionMessageAutopauseOverrideKey
CoreLocation: malformed message: kCLConnectionMessageAutopauseStatus
kCLConnectionMessageAllowsBackgroundLocationUpdatesKey
kCLConnectionMessageAllowsBackgroundLocationUpdates
kCLConnectionMessageBatchAllowedKey
kCLConnectionMessageBatchDistanceKey
kCLConnectionMessageBatchTimeoutKey
kCLConnectionMessageBatch
kCLConnectionMessageAllowsMapCorrectionKey
kCLConnectionMessageAllowsMapCorrection
kCLConnectionMessageRegisterAsLocationClient
kCLConnectionMessageVehicleSpeed
kCLConnectionMessageVehicleSpeedKey
kCLConnectionMessageVehicleHeading
kCLConnectionMessageVehicleHeadingKey
Boolean CLClientClearNvramData(CLClientRef, int)
CoreLocation: function deprecated - noop
Boolean CLClientSetProductionTest(CLClientRef, int)
Boolean CLClientEnableNmeaOutput(CLClientRef, int)
Boolean CLClientGetOneShotLocation(CLClientRef)
Boolean CLClientStartLocationUpdatesAll(CLClientRef)
Boolean CLClientRetrieveData(CLClientRef, CLClientEvent, Boolean)
Boolean CLClientGetCapabilities(CLClientRef, CLClientCapabilities *)
UIApplicationWillResignActiveNotification
UIApplicationDidBecomeActiveNotification
kCLClientEventKey
void _CLClientHandleMessage(CLClientRef, std::shared_ptr<CLConnectionMessage>)
CoreLocation: Got unhandled message %s from daemon
kCLConnectionMessageLocationUnavailable
kCLConnectionMessageRegionMonitoringError
kCLConnectionMessageRangingError
kCLConnectionMessageRegionMonitoringResponseDelayed
kCLConnectionMessageRegionMonitoringSetupCompleted
kCLConnectionMessageAutopauseStatus
kCLConnectionMessagePeerRangingError
kCLConnectionMessageHeadingDataKey
NSString *_CLUsageDescriptionKeyForAuthorizationStatus(CLClientAuthorizationStatus)
CoreLocation: There is no UsageDescriptionKey for this AuthorizationStatus
kCLConnectionMessageBundleIdentifierKey
kCLConnectionMessageBundlePathKey
kCLConnectionMessageClientSDKKey
virtual void CLCompass7::start(bool)
CoreLocation: compass for AOP started.
virtual void CLCompass7::stop()
CoreLocation: compass for AOP stopped.
virtual CFTimeInterval CLCompass7::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting update interval to %f
CLMotionTypeCompass CLCompass7::populateMotionType(const CMDeviceMotionReport::Compass &, const CFTimeInterval &)
CoreLocation: Type,%s,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,calibrated.x,%.8f,.y,%.8f,.z,%.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1f,level,%d,status,%u,timestamp,%f
GyroCompass
bool CLCompass7::populateAlignmentType(const CMDeviceMotionReport::Compass &, const CFTimeInterval &)
CoreLocation: Type,%s,compassJustAlignedToStableField,%d,timestamp,%20.20f
CompassAlignment
%@,<startDate %@, endDate %@, deviceId %@>
timeRange
T@"CMMotionTimeRange",R,N
deviceId
T@"NSString",R,N
kCLConnectionMessageVehicleStateIsAvailable
kCLConnectionMessageVehicleStateMostRecentVehicleConnection
kCLConnectionMessageVehicleStateMostRecentInVehicle
kCMVehicleStateDataCodingKeyTimeRange
kCMVehicleStateDataCodingKeyDeviceId
com.apple.locationd
com.apple.springboard
LocationServicesEnabledIn8.0
GestureServiceEnabled
DeviceOrientationServiceEnabled
LocationServicesAvailable
ResetLocationWarnings
KnownClients
PrivateMode
com.apple.locationd/kClientConfirmedCount
com.apple.locationd/Prefs
com.apple.ManagedConfiguration.profileListChanged
com.apple.locationd.DumpDiagnostics
OscarEmulation
com.apple.locationd.notbackedup
com.apple.carrier
com.apple.operator
NSLocationUsageDescription
NSLocationAlwaysUsageDescription
NSLocationWhenInUseUsageDescription
CFRunLoopRef CLCommonGetRunLoop()
CoreLocation: ***no run loop available***
***no run loop available***
void CLCommonSetRunLoop(CFRunLoopRef)
CoreLocation: Changing CLCommon's runloop after it was already established
CoreLocation: Setting CLCommon's runloop after it was already established
CoreLocation: CLCommonSetRunLoop, %p
mobile
int CLCommonCopyFile(const char *, const char *)
CoreLocation: cannot open source file: %s, errno %d
cannot open source file: %s, errno %d
CoreLocation: cannot open target file: %s, errno %d
cannot open target file: %s, errno %d
CoreLocation: error reading source file: %s
error reading source file: %s
CoreLocation: error writing target file: %s
error writing target file: %s
int CLCommonBzipFile(const char *, const char *)
CoreLocation: cannot open compression stream: %s, bzerror %d
cannot open compression stream: %s, bzerror %d
CoreLocation: error writing target file: %s, bzerror: %d
error writing target file: %s, bzerror: %d
CoreLocation: error closing target file: %s, bzerror: %d
error closing target file: %s, bzerror: %d
decompress:%@
bool CLCommonGzipDecompressFile(const char *, const char *)
CoreLocation: CLCommonGzipDecompressFile, can't stat, %s
CLCommonGzipDecompressFile, can't stat, %s
CoreLocation: CLCommonGzipDecompressFile, from, %s, to, %s, size, %llu, cTime, %.1lf, isOK, %d
CoreLocation: CLCommonGzipDecompressFile, can't open, file_path_to, %s, errno %d
CLCommonGzipDecompressFile, can't open, file_path_to, %s, errno %d
CoreLocation: CLCommonGzipDecompressFile, can't open, file_path_from, %s, errno, %d
CLCommonGzipDecompressFile, can't open, file_path_from, %s, errno, %d
CoreLocation: CLCommonGzipDecompressFile, error reading source file: %s, errno, %d, read, %d
CLCommonGzipDecompressFile, error reading source file: %s, errno, %d, read, %d
CoreLocation: CLCommonGzipDecompressFile, can't write, %s, errno, %d, write, %zu
CLCommonGzipDecompressFile, can't write, %s, errno, %d, write, %zu
CoreLocation: CLCommonGzipDecompressFile, from, %s, to, %s, isOK, %d, fileSize, %llu, totalReadBytes, %u, totalWrittenBytes, %u, compression, %.4lf
compress:%@
%a, %d %b %Y %T %Z
Date
int CLCommonGetTimeFromHttpHeaderAndRtt(CFDictionaryRef, const CFTimeInterval *, CFAbsoluteTime *)
CoreLocation: http date string is converted to timestamp %.3f and adjusted to %.3f by %.3fs RTT (%.3fs diff from systime)
en_US
%.3f
%.1f
BKDigitizerSignpostsEnabled
com.apple.backboardd
bool CLCommonIsGpsNetworkTestMode()
CoreLocation: GPS_NETWORK: enabled %d found %d
void CLCommonSetTimerNowPlusDelay(CFRunLoopTimerRef, CFTimeInterval)
CoreLocation: Timer set loop: %d %f %f %f %f
CFRunLoopTimerRef CLCommonCreateIntervalRunLoopTimer(CFTimeInterval, CFRunLoopTimerContext *, CFRunLoopTimerCallBack)
Boolean CLCommonCompareLocationEqualityClient(const CLClientLocation *, const CLClientLocation *)
CoreLocation: CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than their reference frames: (%lf, %lf, %d) (%lf, %lf, %d)
CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than their reference frames: (%lf, %lf, %d) (%lf, %lf, %d)
bool CLCommonGetFileTimestamps(const char *, CFAbsoluteTime *, CFAbsoluteTime *, CFAbsoluteTime *, off_t *)
CoreLocation: CLCommonGetFileTimestamps, failed to stat file, %s, ret, %d
bool CLCommonTouchMTimestamp(const char *)
CoreLocation: CLCommonTouchMTimestamp, utimes failed, ret, %d, file, %s
CLCommonTouchMTimestamp, utimes failed, ret, %d, file, %s
void CLCommonDeleteFileIfExists(const char *)
CoreLocation: TILE: delete file, %s
CoreLocation: TILE: stat, %s, ret, %d, mtime, %lu, ctime, %lu, size, %lld
CoreLocation: TILE: unlink, %s, ret, %d
bool CLCommonSetFileProtectionClass(const char *, int)
CoreLocation: failed, invalid filename
CoreLocation: failedToOpen, errno, %d
CoreLocation: failed,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d,errno,%d
CoreLocation: done,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d
kCLClientRegistrationResultAllowedAlways
kCLClientRegistrationResultAllowedWhenInUse
kCLClientRegistrationResultFailedUserDenied
kCLClientRegistrationResultFailedBlacklisted
kCLClientRegistrationResultFailedUnavailable
kCLClientRegistrationResultRequiresAgent
kCLClientRegistrationResultMissing
UNKNOWN
kCLClientAuthorizationStatusNotDetermined
kCLClientAuthorizationStatusRestricted
kCLClientAuthorizationStatusDenied
kCLClientAuthorizationStatusAuthorizedAlways
kCLClientAuthorizationStatusAuthorizedWhenInUse
%03d,%03d,0x%x,0x%x
%03d,%03d,0x%x
GpsNetworkCtrl
__TEXT
Binary Images:
armv6
armv7
unknown
%16p - %lld %c%s %s <
%02X
> %s
com.apple.CoreMotion.CLDeviceMotionPrivateQueue
kCLConnectionMessageGyroBiasEstimation
___ZN31CLGyroBiasEstimatorClientRemote36registerWithGyroBiasEstimatorPrivateEPFvRK31CLMotionTypeGyroBiasAndVariancePvEbS3__block_invoke_3
CoreLocation: Default handler received message %s
kCLConnectionMessageBuildGYTTKey
void CLGyroBiasEstimatorClientRemote::onGyroBiasEstimation(std::shared_ptr<CLConnectionMessage>, CLGyroBiasEstimatorClientCallback, void *)
CoreLocation: Could not get dictionary for message
CoreLocation: Message does not contain a valid gyro bias object
static void CLGyroBiasEstimatorClientRemote::onWatchdogTimerExpiry(CFRunLoopTimerRef, void *)
CoreLocation: unable to create fPrivateQueue
___ZN31CLGyroBiasEstimatorClientRemote21onWatchdogTimerExpiryEP16__CFRunLoopTimerPv_block_invoke
CoreLocation: Sent kCLConnectionMessageWatchdog message
static bool CLNameValuePair::encodeBase64(const void *, unsigned long, std::string &)
CoreLocation: processed %p %d to (%s)
CLNameValuePair::CLNameValuePair()
CoreLocation: could not create new mutable dictionary
could not create new mutable dictionary
CLNameValuePair::CLNameValuePair(CFDictionaryRef)
CLNameValuePair::CLNameValuePair(const CLNameValuePair &)
CLNameValuePair &CLNameValuePair::operator=(const CLNameValuePair &)
virtual bool CLNameValuePair::loadFromFile(const char *)
CoreLocation: could not deserialize property list from %s
could not deserialize property list from %s
CoreLocation: file %s does not exist... clearing, error, %s
CoreLocation: Error reading file %s: %s
Error reading file %s: %s
bool CLNameValuePair::writeDataToFile(const char *, CFDataRef, CLNVPDataProtection) const
CoreLocation: Could not create NSURL for file: %s
Could not create NSURL for file: %s
CoreLocation: Could not write data to disk %s
Could not write data to disk %s
virtual bool CLNameValuePair::saveToFile(const char *) const
CoreLocation: Could not serialize data for file %s
Could not serialize data for file %s
virtual bool CLNameValuePair::saveToBinaryFile(const char *, CLNVPDataProtection) const
virtual void CLNameValuePair::clearInternal(const CFStringRef, int)
CoreLocation: key %s does not have element %d in array of size %ld
key %s does not have element %d in array of size %ld
CoreLocation: key %s does not have element %d in non-array type %lu
key %s does not have element %d in non-array type %lu
virtual bool CLNameValuePair::get(CFStringRef, CFArrayRef &) const
CoreLocation: type IDs do not match for key %s - %lu vs %lu
type IDs do not match for key %s - %lu vs %lu
virtual bool CLNameValuePair::get(CFStringRef, CFDataRef &, int) const
virtual bool CLNameValuePair::get(CFStringRef, CFStringRef &, int) const
virtual bool CLNameValuePair::copyInternal(CFStringRef, CFTypeRef &, int) const
CoreLocation: specified index is out of range for key %s (%d of %ld)
specified index is out of range for key %s (%d of %ld)
CoreLocation: specified index %d not applicable to type %lu for key %s
specified index %d not applicable to type %lu for key %s
virtual bool CLNameValuePair::set(CFStringRef, const bool &)
CoreLocation: could not create cf type for key %s
could not create cf type for key %s
virtual bool CLNameValuePair::set(CFStringRef, const uint16_t &)
virtual bool CLNameValuePair::set(CFStringRef, const short &)
virtual bool CLNameValuePair::set(CFStringRef, const uint32_t &)
virtual bool CLNameValuePair::set(CFStringRef, const int64_t &)
virtual bool CLNameValuePair::set(CFStringRef, const int &)
virtual bool CLNameValuePair::set(CFStringRef, const long &)
virtual bool CLNameValuePair::set(CFStringRef, const double &)
virtual bool CLNameValuePair::set(CFStringRef, const char *)
virtual bool CLNameValuePair::set(CFStringRef, const CLNameValuePair &)
virtual bool CLNameValuePair::insert(CFStringRef, const bool &)
virtual bool CLNameValuePair::insert(CFStringRef, const uint16_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const short &)
virtual bool CLNameValuePair::insert(CFStringRef, const uint32_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const int64_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const int &)
virtual bool CLNameValuePair::insert(CFStringRef, const long &)
virtual bool CLNameValuePair::insert(CFStringRef, const double &)
virtual bool CLNameValuePair::insert(CFStringRef, const char *)
virtual bool CLNameValuePair::insert(CFStringRef, const CLNameValuePair &)
virtual bool CLNameValuePair::serializeBinary(CFDataRef *) const
CoreLocation: could not create write stream
could not create write stream
CoreLocation: could not open write stream
could not open write stream
CoreLocation: could not write data, error code, %ld, error domain, %s
could not write data, error code, %ld, error domain, %s
virtual bool CLNameValuePair::deserialize(const CFDataRef)
CoreLocation: could not create intermediate property list - %ld (%s)
unknown error
could not create intermediate property list - %ld (%s)
Direct
virtual void CLNameValuePair::print() const
CoreLocation: %s
<empty>
void CLNameValuePair::printCSV(const char *)
CoreLocation: dictionary, %s, NULL
static void CLNameValuePair::printKeyValue(const void *, const void *, void *)
CoreLocation: 
%s = <dictionary (%ld entries)>:
CoreLocation: 
%s = %s
CoreLocation: 
%s = %0.6f
CoreLocation: 
%s = %d
CoreLocation: 
%s = <unhandled value type %lu>
type ID does not match - %lu vs %lu
%s = <dictionary (%ld entries)>:
%s = %s
%s = %0.6f
%s = %d
%s = <unhandled value type %lu>
%s[%d]
static bool CLNameValuePair::fromCfType(const CFTypeRef, short &)
CoreLocation: could not get value
could not get value
static bool CLNameValuePair::fromCfType(const CFTypeRef, int64_t &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, int &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, long &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, double &)
CoreLocation: type IDs do not match - %lu vs %lu
type IDs do not match - %lu vs %lu
static bool CLNameValuePair::fromCfType(const CFTypeRef, std::string &)
CoreLocation: could not convert to C string
could not convert to C string
CoreLocation: can't convert %u data bytes
can't convert %u data bytes
CoreLocation: type IDs do not match - %lu
type IDs do not match - %lu
static bool CLNameValuePair::fromCfType(const CFTypeRef, const char *&, unsigned int &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, CLNameValuePair &)
%s.%ld
void _printCSV_logKeyValue(const void *, const void *, void *)
CoreLocation: dictionary, %s, key, %s, value, %s
CoreLocation: dictionary, %s, key, %s, value, %.8lf
CoreLocation: dictionary, %s, key, %s, value, %d, 0x%08x
CoreLocation: dictionary, %s, key, %s, value, %d, [CFBoolean]
CoreLocation: dictionary, %s, key, %s, value, %.2lf, [CFDate]
CoreLocation: dictionary, %s, key, %s, un-printable value
virtual void BasicMutex::lock()
CoreLocation: Assert Failed, %s, %d
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/CSI/CLMachThreadSupport.mm
Assert Failed, %s, %d
CoreLocation: locationd assert: %s, %d
CoreLocation: TIMEOUT: Waited %f seconds to aquire lock '%s' (%p)
<unnamed>
virtual void BasicMutex::unlock()
CoreLocation: TIMEOUT: Held lock '%s' (%p) for %f seconds
virtual DestructionAwareMutex::~DestructionAwareMutex()
Condition::WaitStatus Condition::wait(Mutex *, int)
CLSensorFusionService9Axis::CLSensorFusionService9Axis(bool, int, bool)
CoreLocation: 9-axis sensor fusion is not supported on this platform.  Returning
9-axis sensor fusion is not supported on this platform.  Returning
___ZN26CLSensorFusionService9Axis17onBiasAndVarianceE31CLMotionTypeGyroBiasAndVariance_block_invoke
CoreLocation: Type,%s,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
GyroBias
void CLSensorFusionService9Axis::onCompass(const CLCompass_Type::Sample *)
CoreLocation: correctedCompassExt, %.3f, %.3f, %.3f, %u, %u
UIApplication
com.apple.locationd.Core
com.apple.locationd.Motion
com.apple.locationd.Position
com.apple.locationd.Utility
Calorimetry
Swimming
Activity
Motion
Pocket
Orientation
EarGesture
WakeGesture
DeviceMotion
Position
Proximity
GeneralCLX
WifiPosition
GeoFencing
Gnss
Client
Core
Routine
Harvester
Database
Network
Utility
gas-gauge-battery
IsSimulator
%@ %@ (%@)
<null>
<name>
<version>
<build>
hw.model
hw.machine
Apple 
 CoreLocation-
IOPlatformExpertDevice
IOPlatformSerialNumber
NotAvailable
___ZN14CLPlatformInfo12getProvidersEv_block_invoke
CoreLocation: unknown hardware type %{private}d
UseNewGnssArchitecture
watch-companion
GpsEnableLPPM
GpsEnableGnssRfConfig
bool CLPlatformInfo::getDateFromSerialNumber(const std::string &, CFAbsoluteTime &)
CoreLocation: device SN date info type:%{private}zd - date:%{private}d %{private}d %{private}f
CoreLocation: Invalid year/week code
CoreLocation: Failed to allocate CFCalendar
CoreLocation: CFCalendarComposeAbsoluteTime() failed
CoreLocation: Cannot get weekday
CoreLocation: Cannot get week
CoreLocation: Invalid serial number format: %{private}s
bool CLPlatformInfo::supportsCampOnly()
CoreLocation: CAMP: device id [%d] [%s], camping support [%d]
ReleaseType
NonUI
InternalBuild
GpsForceSuplSupportIgnoringHw
bool CLPlatformInfo::supportsSupl()
CoreLocation: #warning SUPL: ignoring hw. forceSuplSupport,%d
GpsForceLppSupport
bool CLPlatformInfo::supportsLpp()
CoreLocation: #warning LPP: ignoring hw. forceLppSupport,%d
BeaconFenceBestEffortAlways
bool CLPlatformInfo::supportsBeaconBestEffortAlwaysEnabled()
CoreLocation: #warning Overriding BeaconFenceBestEffortAlways,%d
CoreLocation: zoneBestEffortAlwaysEnabled,%d
GnssPeakAntennaGain
CLPlatformInfo::GnssRfConfig CLPlatformInfo::getGnssRfConfig()
CoreLocation: #warning GNSSRF: overriding peak antenna gain, %d tenth-dB
CoreLocation: GNSSRF: no config for %d
CoreLocation: GNSSRF: peakAntennaGain,%d,gpsLoss,%d,gloLoss_0,%d,gloLoss_minus7,%d,gloLoss_plus6,%d
GpsForcePlosSupport
bool CLPlatformInfo::supportsPLOS()
CoreLocation: PLOS: ignoring hw. forceSupport,%d
GpsForceSupportOutdoorMatching
bool CLPlatformInfo::supportsOutdoorMatching()
CoreLocation: #warning OBM, ignoring hw. forceSupport,%d
wlan
IOService
wifi-antenna-sku-info
static bool CLPlatformInfo::isDeviceJapanSKU()
CoreLocation: data for wifi-antenna-sku-info found
CoreLocation: Device SKU:%s
CoreLocation: wifi-antenna-ski-info property not found.
CoreLocation: service for class wlan NOT found.
CoreLocation: class wlan NOT found.
com.apple.demo-settings
StoreDemoMode
FProgramNumber
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMWorkout.mm
sessionId
type < kCMWorkoutTypeMax
OutdoorWheelchairWalk
OutdoorWheelchairRun
Unhandled workout type
%@, <sessionId %@, type, %@>
type >= kCMWorkoutTypeNone && type <= kCMWorkoutTypeMax
session >= kCMNatalieDataSessionNone && session <= kCMNatalieDataSessionMax
type
location < kCMSwimWorkoutLocationMax
-[CMSwimWorkout initWithSessionId:location:poolLength:]
CoreLocation: pool length %f for workout is too small and may lead to undefined behavior.
Pool
OpenWater
%@, <sessionId %@, type, kCMWorkoutTypeSwimming, location, %@, poolLength, %f>
location
poolLength
Td,R,N
kCMWorkoutDataCodingKeySessionId
kCMWorkoutDataCodingKeyType
kCMWorkoutDataCodingKeySwimLocation
kCMWorkoutDataCodingKeyPoolLength
/private/var/Managed Preferences/
/Library/Caches/locationd/
root
static std::string CLPersistentStore::getMutableStorePath(CLPersistentStoreType)
CoreLocation: could not get mutable store path for type, %d
could not get mutable store path for type, %d
/System/Library/Frameworks/CoreLocation.framework/Support/
/System/Library/Frameworks/CoreLocation.framework
/Library/locationd/
CLPersistentStore::CLPersistentStore(CLSilo *, const char *, CLPersistentStore::Domain, CLPersistentStoreType, CLPersistentStoreDataProtection)
CoreLocation: Unknown persistent domain: %d
Unknown persistent domain: %d
CoreLocation: could not create path %s
could not create path %s
.plist
virtual bool CLPersistentStore::refresh()
CoreLocation: persistent store %s has been modified - refreshing will lose changes
virtual bool CLPersistentStore::store()
CoreLocation: data set %s is not changeable - not storing
CoreLocation: %s stored to disk %s
virtual void CLPersistentStore::setStoreInterval(const CFTimeInterval &, CFRunLoopTimerCallBack, void *)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Utilities/CLPersistentStore.mm
CoreLocation: scheduling to auto-store %s every %.3fs
CoreLocation: disabling auto-store for %s
QuaternionX %f QuaternionY %f QuaternionZ %f QuaternionW %f UserAccelX %f UserAccelY %f UserAccelZ %f RotationRateX %f RotationRateY %f RotationRateZ %f MagneticFieldX %f MagneticFieldY %f MagneticFieldZ %f MagneticFieldAccuracy %d @ %f
doingYawCorrection
TB,R,N
doingBiasEstimation
magneticFieldCalibrationLevel
Ti,R,N
attitude
T@"CMAttitude",R,N
rotationRate
gravity
userAcceleration
magneticField
T{?={?=ddd}i},R,N
kCMDeviceMotionCodingKeyQuaternionX
kCMDeviceMotionCodingKeyQuaternionY
kCMDeviceMotionCodingKeyQuaternionZ
kCMDeviceMotionCodingKeyQuaternionW
kCMDeviceMotionCodingKeyUserAccelerationX
kCMDeviceMotionCodingKeyUserAccelerationY
kCMDeviceMotionCodingKeyUserAccelerationZ
kCMDeviceMotionCodingKeyRotationRateX
kCMDeviceMotionCodingKeyRotationRateY
kCMDeviceMotionCodingKeyRotationRateZ
kCMDeviceMotionCodingKeyMagneticFieldX
kCMDeviceMotionCodingKeyMagneticFieldY
kCMDeviceMotionCodingKeyMagneticFieldZ
kCMDeviceMotionCodingKeyMagneticFieldCalibrationLevel
kCMDeviceMotionCodingKeyDoingYawCorrection
kCMDeviceMotionCodingKeyDoingBiasEstimation
%@ Pitch: %f, Roll: %f, Yaw: %f
roll
pitch
rotationMatrix
T{?=ddddddddd},R,N
quaternion
T{?=dddd},R,N
kCMAttitudeCodingKeyQX
kCMAttitudeCodingKeyQY
kCMAttitudeCodingKeyQZ
kCMAttitudeCodingKeyQW
Pressure %f Temeprature %f @ %f
ambientPressure
T{?=dd},R,N
kCMAmbientPressureCodingKeyPressure
kCMAmbientPressureCodingKeyTemperature
virtual bool CLPreferences::serialize(CFDataRef *) const
CoreLocation: ***not supported***
***not supported***
virtual bool CLPreferences::serializeBinary(CFDataRef *) const
virtual bool CLPreferences::deserialize(const CFDataRef)
virtual void CLPreferences::print() const
CoreLocation: 
<empty>
virtual void CLPreferences::merge(const CLPreferences &, bool)
virtual bool CLPreferences::loadFromFile(const char *)
virtual bool CLPreferences::saveToFile(const char *) const
virtual bool CLPreferences::saveToBinaryFile(const char *) const
virtual void CLPreferences::setInternal(const CFStringRef, const CFTypeRef)
CoreLocation: Attempt to set key %s for read-only preferences %s/%s!
Attempt to set key %s for read-only preferences %s/%s!
virtual bool CLPreferences::containsInternal(CFStringRef) const
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Utilities/CLPreferences.mm
%llu, %f, %f, (%f, %f, %f)
identifier
TQ,R,V_identifier
T@"NSDate",R
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMSensorRecorder.mm
Unexpected ptr exceeding size of buffer, block id, %llu, block offset %llu, size, %zu
Data object returned should be valid
Data pointer returned should be valid
com.apple.CoreMotion.CMSensorRecorderInternal
kCLConnectionMessageSensorRecorderAccelGetMetaByID
kCLConnectionMessageSensorRecorderAccelGetMetaSinceID
__69-[CMSensorRecorderInternal _newAccelMetaUsingMessage:withIdentifier:]_block_invoke
CoreLocation: Error occurred while trying to retrieve accelerometer record!
Error occurred while trying to retrieve accelerometer record!
kCLConnectionMessageSensorRecorderAccelGetMetasByDateRange
__48-[CMSensorRecorderInternal newAccelMetaFrom:to:]_block_invoke
CoreLocation: Error occurred while trying to retrieve accelerometer records!
Error occurred while trying to retrieve accelerometer records!
kCLConnectionMessageSensorRecorderAccelGetDataByID
__52-[CMSensorRecorderInternal newAccelDataByID:metaID:]_block_invoke
CoreLocation: Error occurred while trying to retrieve accelerometer data!
Error occurred while trying to retrieve accelerometer data!
kCLConnectionMessageSensorRecorderAccelAvailable
+[CMSensorRecorder isAccelerometerRecordingAvailable]
CoreLocation: Response invalid.
Response invalid.
kCLConnectionMessageSensorRecorderAuthorized
+[CMSensorRecorder isAuthorizedForRecording]
endTime
startTime must be <= to endTime
startTime must be within 3 days of today.
CoreLocation: -[CMSensorRecorder accelerometerDataFromDate:toDate:] fromDate has been adjusted so that the duration requested is <= 12 hours.
-[CMSensorRecorder accelerometerDataFromDate:toDate:]
duration > 0.0
kCLConnectionMessageSensorRecorderAccelRecordFor
-[CMSensorRecorder recordAccelerometerForDuration:]
timestamp
accel_x
accel_y
accel_z
DumpCompassCalibrationDatabaseOnCompassStart
CompassInterval
CompassIgnoreGyro
CLCompass6::CLCompass6(bool)
CoreLocation: legacy compass, logging (%d) interval (%.3f) gyro (%d)
%.0f
v16@?0^{CLCompassDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}8
virtual void CLCompass6::start(bool)
CoreLocation: Compass is requesting device motion with mode 0x%x
static void CLCompass6::onMagnetometerData(const CLMagnetometer::Sample *, void *)
CoreLocation: XYCompass: notify after %.3f seconds of no event.
CoreLocation: fCompassCalculator->getCompassData() returns false
CoreLocation: Type,%s,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
Compass
CoreLocation: notified clients. sampleCount,%d,compass.compass.calibrationLevel,%d,compass.timestamp,%f
kCMLogItemCodingKeyTimestamp
com.apple.locationd.spi
com.apple.locationd.synchronous
Boolean CLGetControlPlaneStatusReport(int, CFAbsoluteTime *, CFAbsoluteTime *, double *, double *, double *, double *, unsigned int *)
CoreLocation: Blocking Mig routine deferred on Daemon side... waiting and retrying
CFDictionaryRef CLCopyAppsUsingLocation()
CoreLocation: List of apps using location is not a dictionary -- type ID %lu
List of apps using location is not a dictionary -- type ID %lu
CFArrayRef CLCopyTechnologiesInUse()
CoreLocation: List of technologies in use is not an array -- type ID %lu
List of technologies in use is not an array -- type ID %lu
void CLInternalSetLocationServicesEnabled(Boolean)
CoreLocation: CLInternalSetLocationServicesEnabled failed
CLInternalSetLocationServicesEnabled failed
void CLInternalSetGestureServiceEnabled(Boolean)
CoreLocation: CLInternalSetGestureServiceEnabled failed
CLInternalSetGestureServiceEnabled failed
Boolean CLInternalGetAuthorizationStatus(CFStringRef, CFStringRef, CLClientAuthorizationStatus *)
CoreLocation: Couldn't send bundle identifier!
Couldn't send bundle identifier!
CoreLocation: Couldn't send bundle path!
Couldn't send bundle path!
Boolean CLInternalGetAuthorizationStatusForService(CFStringRef, CFStringRef, CLClientServiceTypeMask, CLClientAuthorizationStatus *)
Boolean CLInternalPerformMigration()
CoreLocation: _CLIntegrityCheck failed with result: %d
_CLIntegrityCheck failed with result: %d
Boolean CLShutdownDaemon()
CoreLocation: _CLShutdownDaemon failed with result: %d
_CLShutdownDaemon failed with result: %d
Boolean CLDisplayStatistics()
CoreLocation: _CLDisplayStatistics failed with result: %d
_CLDisplayStatistics failed with result: %d
Boolean CLDumpLogs(CFStringRef)
CoreLocation: _CLDumpLogs failed with result: %d
_CLDumpLogs failed with result: %d
Boolean CLCopyLastLog()
CoreLocation: _CLCopyLastLog failed with result: %d
_CLCopyLastLog failed with result: %d
CFDictionaryRef CLCopyMonitoredRegions(CFStringRef, CFStringRef)
CoreLocation: Returned type is not a dictionary
Returned type is not a dictionary
void CLSetLocationDefault(CFStringRef, CFPropertyListRef)
CoreLocation: Key is NULL!
Key is NULL!
CoreLocation: Couldn't set location default!
Couldn't set location default!
other
vehicularNavigation
fitness
void CLSetAutopauseState(_Bool, _Bool, _Bool)
CoreLocation: Couldn't set autopause state!
Couldn't set autopause state!
Boolean CLGetLocation(CFStringRef, CFStringRef, Boolean, Boolean, CLClientLocation *)
NSTimeZone *CLTimeZoneAtLocation(CLLocation *)
<Unknown Function>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/MiG/LocationInternal.m
nil != location
CLStartStopAdvertisingBeacon %@
_Bool CLStartStopAdvertisingBeacon(CLBeaconRegion *, NSNumber *)
CoreLocation: CLStartStopAdvertisingBeacon beacon: %s, power: %s
LogPressure
CLPressure
virtual CFTimeInterval CLPressure::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Setting data update interval to %f
void CLPressure::onPressureData(const CLMotionTypePressure &, const CLMotionTypeTimestamp &)
CoreLocation: ret=%d
Pressure
com.apple.CoreMotion.CMOdometer.internal
com.apple.CoreMotion.CMOdometer.callback
__41-[CMOdometerProxy _startDaemonConnection]_block_invoke
CoreLocation: Failed with CMError code %d
Failed with CMError code %d
kCLConnectionMessageOdometerGpsAvailability
__41-[CMOdometerProxy _startDaemonConnection]_block_invoke.33
CoreLocation: CMOdometer client connection interrupt, %@, %d, %p
kCLConnectionMessageStartOdometerUpdate
__52-[CMOdometerProxy _startOdometerUpdatesWithHandler:]_block_invoke
CoreLocation: Unable to parse kCLConnectionMessageOdometerUpdate message!
Unable to parse kCLConnectionMessageOdometerUpdate message!
odometer
T@"CMOdometer",N,V_odometer
totalDistance
Td,V_totalDistance
averageSpeed
Td,V_averageSpeed
Td,V_startDate
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMOdometer.mm
-[CMOdometer startOdometerUpdatesForActivity:withHandler:]
CoreLocation: The requested activity %ld is not yet supported
CoreLocation: Unsupported activity requested
odometerProxy
T@"CMOdometerProxy",R,N,V_odometerProxy
delegate
T@"<CMOdometerDelegate>",N,V_delegate
%@, <recordId %lu, startDate %@, sourceId %@>
kExerciseMinuteDataCodingKeyStartDate
kExerciseMinuteDataCodingKeyRecordId
kExerciseMinuteDataCodingKeySourceId
kCMRotationRateCodingKeyX
kCMRotationRateCodingKeyY
kCMRotationRateCodingKeyZ
%+08.4lf%+09.4lf/
%+08.4lf%+09.4lf%+08.3lf/
CLGyroCalibrationDatabaseRemoteSilo
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
valid
TB,N
-[CLGyroCalibrationDatabaseRemoteAdapter beginService]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Shared/Motion/SensorCalibration/CLGyroCalibrationDatabaseRemote.mm
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %s; client %d does not exist
%s; client %d does not exist
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::invokeClientWithData(const ClientMapIter &, const NotificationMapIter &, CLNotifierData *) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Utilities/CLNotifier.h
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %s; notification %s not found
%s; notification %s not found
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %s; client %d has deregistered, not notifying %s
void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLNotifierData *) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %s; unknown client %d
%s; unknown client %d
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CoreLocation: %s; already shutdown; not listing clients
CoreLocation: %s; listing clients, num clients: %zu
CoreLocation: %s; clients, id: %d, notification: %d
virtual bool CLGyroCalibrationDatabaseRemote::getBiasFit(CLMotionTypeGyroBiasFit &)
CoreLocation: successfully got GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
CoreLocation: Warning: can't get GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
kCMCatherineDataCodingKeyCatherine
kCMCatherineDataCodingKeyConfidence
%@,<catherine %f confidence %f @ %f>
catherine
Td,R,N,V_catherine
confidence
Td,R,N,V_confidence
compass
compass-calibration
CFDataRef CLMagnetometerCoexistenceLocal::copyCompassCalibrationData()
CoreLocation: Invalid cpas data.
CoreLocation: The cpas data is not a CFData type.
BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()
CoreLocation: Cpas data is NULL.
Cpas data is NULL.
CoreLocation: Cpas pointer is NULL.
Cpas pointer is NULL.
CoreLocation: Unexpected cpas version: %u.
Unexpected cpas version: %u.
CoreLocation: Original serial number data is NULL.
Original serial number data is NULL.
CoreLocation: Original serial number pointer is NULL.
Original serial number pointer is NULL.
BackCameraSerialNumber
CoreLocation: Invalid back camera serial number data.
Invalid back camera serial number data.
CoreLocation: Incorrect back camera serial number length. Actual length %ld. Expected length %lu.
Incorrect back camera serial number length. Actual length %ld. Expected length %lu.
CoreLocation: Current serial number data is NULL.
Current serial number data is NULL.
BackCameraModuleFocusActuatorID
NSNumber *CLMagnetometerCoexistenceLocal::cameraVcmId()
CoreLocation: Bailing while checking VCM actuator ID.
CoreLocation: VCM actuator ID data type %d does not match expected type %d
NSData *CLMagnetometerCoexistenceLocal::sanitizedCompassCalibrationData()
CoreLocation: CPAS data is NULL.
CPAS data is NULL.
CoreLocation: CPAS pointer is NULL.
CPAS pointer is NULL.
AppleH4CamIn
%@,<startDate %@, endDate %@>
kCMMotionTimeRangeCodingKeyStartDate
kCMMotionTimeRangeCodingKeyEndDate
%@%s%s
_internal_Calypso-Trimmed.wav
Male
Female
%@, <age %f, gender %@, height %f, weight %f, condition %ld>
gender
height
weight
condition
kCalorieUserInfoCodingKeyAge
kCalorieUserInfoCodingKeyGender
kCalorieUserInfoCodingKeyHeight
kCalorieUserInfoCodingKeyWeight
kCalorieUserInfoCodingKeyCondition
com.apple.locationd.vehicle.connected
com.apple.locationd.vehicle.disconnected
com.apple.locationd.vehicle.exit
static bool CMOQuaternion::northAndGravity(CMVector<float, 3>, CMVector<float, 3>, const float *, CMOQuaternion &, CMMatrix<float, 3> &)
CoreLocation: n and g are too close %f
CoreLocation: Assertion failed: lambda != 0, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMOQuaternion.cpp, line 223,invalid weights.
Assertion failed: lambda != 0, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMOQuaternion.cpp, line 223,invalid weights.
CoreLocation: kappa zero!
T CMVector<float, 3>::operator[](const size_t) const [T = float, N = 3]
CoreLocation: Assertion failed: i < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMVector.h, line 272,invalid index %zu >= %zu.
Assertion failed: i < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMVector.h, line 272,invalid index %zu >= %zu.
T CMMatrix<float, 3, 3>::operator[](size_t) const [T = float, M = 3, N = 3]
CoreLocation: Assertion failed: ldx < M*N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 78,invalid element %zu >= %zu.
Assertion failed: ldx < M*N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 78,invalid element %zu >= %zu.
T &CMMatrix<float, 3, 3>::operator()(size_t, size_t) [T = float, M = 3, N = 3]
CoreLocation: Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 71,invalid row %zu > %zu.
Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 71,invalid row %zu > %zu.
CoreLocation: Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 72,invalid col %zu > %zu.
Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 72,invalid col %zu > %zu.
T CMMatrix<float, 3, 3>::operator()(size_t, size_t) const [T = float, M = 3, N = 3]
CoreLocation: Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 64,invalid row %zu > %zu.
Assertion failed: row < M, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 64,invalid row %zu > %zu.
CoreLocation: Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 65,invalid col %zu > %zu.
Assertion failed: col < N, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/Math/CMMatrix.h, line 65,invalid col %zu > %zu.
Reminder
Final
Reset
ActiveReminder
%@, <startDate %@, firedDate %@, alarmType %@, didWake %@>
firedDate
alarmType
didWake
kSedentaryTimerDataCodingKeyStartDate
kSedentaryTimerDataCodingKeyFiredDate
kSedentaryTimerDataCodingKeyAlarmType
kSedentaryTimerDataCodingKeyDidWake
LogSensorFusion
CLSensorFusionMekf::CLSensorFusionMekf(const CFTimeInterval &, const CFTimeInterval &, bool)
CoreLocation: XY: Doing crude accel measurement update.
CoreLocation: XY: rotBufferSize, %zu, accelBufferSize, %zuu, peakCount, %d, fMaxStd, %.3f
CoreLocation: XY: gyroDt, %.4f, doAccelCheck, %d
virtual void CLSensorFusionMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: omegaMag6, %.3f, omega, %.3f, %.3f, %.3f
CoreLocation: Type,%s,x,%f,y,%f,z,%f,w,%f,timestamp,%f
AppleQuaternion
virtual void CLSensorFusionMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)
CoreLocation: Type,%s,bias.x,%f,bias.y,%f,bias.z,%f,var.x,%f,var.y,%f,var.z,%f
Bias,Var
virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: Type,%s,x,%.4f,y,%.4f,z,%.4f,lpf, %.4f, %.4f, %.4f, timestamp,%lf
Accelerometer6
CoreLocation: Type,%s,%.3f, %.3f, %.3f, %.3f, %.3f
RotationRate6X
CoreLocation: XY: rotating and going through.
CoreLocation: XY: it's been too long. go through.
CoreLocation: XY: grabing gravity, %.4f, %.4f, %.4f
CoreLocation: XY: std, %.3f, %.3f, %.3f, mag, %.3f, dot, %.3f, leftover, %.3f
CoreLocation: XY: sum, %.3f, %.3f, %.3f, dot, %.3f, leftover, %.3f
CoreLocation: XY: ===========Skip ahead.
CoreLocation: XY: Skip ahead------.
CoreLocation: XY: Taking another look.
CoreLocation: XY: using mean accel
CoreLocation: XY: accM, (%.4f, %.4f, %.4f), mag, %.3f
CoreLocation: XY: Doing some crude updates to catch up.
CoreLocation: Type,%s,%f,%f,%f,%f,%f,%f,%f
KalmanFilterStates
void CLIoHidManager::initializeHidIfNecessary()
CoreLocation: Could not create event system client. All bets are off
PreserveTimestamp
CoreLocation: Event system client initialized successfully
void CLIoHidManager::setEventCallback(IOHIDEventType, OnIoHidEvent, void *)
CoreLocation: Trying to set properties for unknown event %d
void CLIoHidManager::setEventProperty(IOHIDEventType, NSString *, id)
CoreLocation: Unknown event %d
CoreLocation: Could not convert NSString to C++ string
void CLIoHidManager::setEventPropertyForDevice(NSString *, IOHIDEventType, NSString *, id)
CoreLocation: Device ID not supported for event %d
CoreLocation: Physical device ID cannot be nil. Unable to set property for event %d
CoreLocation: setEventPropertyForDevice has invalid property %p or device id %s
void CLIoHidManager::setIoHidNewServiceCallback(IOHIDEventType, OnIoHidNewService, void *)
CoreLocation: Unknown event: %d
void CLIoHidManager::requestHidDriverInterface(IOHIDEventType, bool, bool)
CoreLocation: Unknown event %u
Opening
Closing
CoreLocation: %s hid driver interface for event %u, hidServiceRef %p
id CLIoHidManager::copyProperty(IOHIDEventType, NSString *)
CoreLocation: Service with event type %d is not ready
bool CLIoHidManager::isEventTypeAvailable(IOHIDEventType)
CoreLocation: IOHIDEventType event %d is unavailable
IOHIDServiceClientRef CLIoHidManager::getHidServiceClient(IOHIDEventType)
IOHIDServiceClientRef CLIoHidManager::getHidServiceClient(IOHIDEventType, std::string)
CoreLocation: Unknown device: %s for event: %d
void CLIoHidManager::refreshHidServiceRefs()
CoreLocation: IOHIDEventSystemClientCopyServices() returned NULL
PrimaryUsagePage
PrimaryUsage
PhysicalDeviceUniqueID
CoreLocation: Service ref with usage pair {%d,%d} (physicalDeviceUniqueID %s) (registryID %llu) (event %d) is %p
bool CLIoHidManager::setEventPropertyIoHid(IOHIDEventType, CFStringRef, CFTypeRef)
CoreLocation: IOHIDServiceClientSetProperty() returned false
CoreLocation: IOHIDServiceClientSetProperty() successfully set property for event %d
bool CLIoHidManager::setDevicePropertyIoHid(IOHIDEventType, std::string, CFStringRef, CFTypeRef)
CoreLocation: IOHIDServiceClientSetProperty() successfully set property for event %d and device %s
successfully
unsuccessfully
void CLIoHidManager::applyAllDirtyEventProperties()
CoreLocation: Property for usage pair {%d,%d}: {%s = %p} was set %s
CoreLocation: Property for usage pair {%d,%d} and physical device {%s}: {%s = %p} was set %s
CoreLocation: Could not set all properties. Setting timer to fire %f seconds from now
CoreLocation: Could not set all properties after too many retries. Giving up.
void CLIoHidManager::printProperties()
CoreLocation: Properties for event %d:
CoreLocation: 
CoreLocation: Properties for event %d and physical device %s:
void CLIoHidManager::setMatchingForEventMap()
CoreLocation: Removing set matching multiple
CoreLocation: Adding touch event,hidUsagePage,%d
DeviceUsagePage
Built-In
CoreLocation: Adding match entry for usage pair {%d,%d}
CoreLocation: Setting matching multiple
NSString *CLIoHidManager::physicalDeviceUniqueIDForSenderID(IOHIDEventType, uint64_t)
CoreLocation: Event %u does not support physical device ID
CoreLocation: Device information cannot be found for event %i with sender id %llu
AppleHIDKeyboardEventDriverV2
RequiresCompassResetOnConnect
CLIoHidManager::EventType CLIoHidManager::getMotionEventType(IOHIDEventRef)
CoreLocation: Unhandled usage %d
void CLIoHidManager::onEvent(void *, void *, IOHIDEventRef)
CoreLocation: Received null sender
void CLIoHidManager::onEventSystemReset(void *)
CoreLocation: It looks like our HID event system just become available (again)
void CLIoHidManager::onServiceRegistration(void *, IOHIDServiceClientRef)
CoreLocation: New IOHIDServiceClientRef for usage pair {%d,%d} just became available.
CoreLocation: Event type %d, device %s, old hidserviceref,%p,new,%p
CoreLocation: Registering new device %s, hidserviceref %p, registryid %llu
CoreLocation: Device unique id expected for event type %d, hidserviceref %p
CoreLocation: Event type %d, old hidserviceref,%p,new,%p
CLIoHidManager::EventInfo::~EventInfo()
CoreLocation: Releasing value for property %s, address = %p
CLIoHidManager::DeviceInfo::~DeviceInfo()
LogAccelerometer
CLAccelerometer
virtual CFTimeInterval CLAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
virtual CFTimeInterval CLAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)
static void CLAccelerometer::onAccelerometerData(void *, const CLMotionTypeAcceleration &, const CLMotionTypeTimestamp &)
CoreLocation: Type,%s,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f
Accelerometer
LogGyro
CLGyro
virtual CFTimeInterval CLGyro::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Type,%s,dt,%f
GyroDt
static void CLGyro::onGyroData(void *, const CLMotionTypeRotationRate &, const CLMotionTypeTimestamp &, unsigned int)
CoreLocation: Type,%s,temperature,%f
GyroTemperature
CoreLocation: Type,%s,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d
Gyro
com.apple.CoreMotion.CMExerciseMinute.InternalQueue
com.apple.CoreMotion.CMExerciseMinute.AppQueue
__32-[CMExerciseMinuteInternal init]_block_invoke
__32-[CMExerciseMinuteInternal init]_block_invoke_2
CoreLocation: CMExerciseMinute client connection interrupt, %@, %d, %d, %p
kCLConnectionMessageExerciseMinuteUpdate
__40-[CMExerciseMinuteInternal _stopUpdates]_block_invoke
CoreLocation: Unable to stop exercise minute updates as we are are not receiving updates
Unable to stop exercise minute updates as we are are not receiving updates
__53-[CMExerciseMinuteInternal _startUpdatesWithHandler:]_block_invoke_2
CoreLocation: Unable to parse kCLConnectionMessageExerciseMinuteUpdate message!
Unable to parse kCLConnectionMessageExerciseMinuteUpdate message!
kCLConnectionMessageExerciseMinuteQuery
__68-[CMExerciseMinuteInternal _queryExerciseMinutesFromRecord:handler:]_block_invoke_2
CoreLocation: Unable to parse kCLConnectionMessageExerciseMinuteQuery message!
Unable to parse kCLConnectionMessageExerciseMinuteQuery message!
kCLConnectionMessageNatalimetryAvailable
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMExerciseMinute.mm
T@"CMExerciseMinuteInternal",R,N,V_internal
LogMagnetometer
CLMagnetometer
virtual CFTimeInterval CLMagnetometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
static void CLMagnetometer::onMagnetometerData(void *, const CLMotionTypeMagneticField &, const CLMotionTypeTimestamp &)
Magnetometer
static void CLMagnetometer::onOffset(const CLMotionTypeMagneticField *, void *)
CoreLocation: Received magnetometer offset (%f, %f, %f)
ssize_t CLMotionNotifier::numberOfClients(int)
CoreLocation: Unknown notification %d
ssize_t CLMotionNotifier::numberOfSpectators(int)
CFTimeInterval CLMotionNotifier::minimumUpdateInterval(int)
bool CLMotionNotifier::addDispatcherPrivate(int, CLMotionNotifier::Dispatcher *, const CFTimeInterval &)
CoreLocation: Requested update interval cannot be == 0.0 and dispatcher cannot be NULL. Use interval < 0.0 for spectator.
CoreLocation: CLMotionNotifier::addDispatcherPrivate UpdateInterval is zero!
CoreLocation: CLMotionNotifier::addDispatcherPrivate Added dispatcher for notification:%d, Update Interval:%f(%.1fHz)
void CLMotionNotifier::setUpdateIntervalPrivate(int, CLMotionNotifier::Dispatcher *, const CFTimeInterval &)
CoreLocation: Unknown (notification,dispatcher) pair: (%d, %p)
CoreLocation: CLMotionNotifier::setUpdateIntervalPrivate RequestedUpdateInterval:%f, UpdateInterval:%f
void CLMotionNotifier::updateSamplePeriods(int)
CoreLocation: CLMotionNotifier::updateSamplePeriod UpdateInterval:%f
com.apple.CoreMotion.CMLiftManager
T@"CMLiftManagerInternal",R,N,V_internal
T@"<CMLiftManagerDelegate>",N
_lvl
_cat
_msg
null
No value written for object
%13.3lf
virtual void CLSensorInterfaceIoHid::configureDeviceMotionLiteForDevice(CLMotionTypeDeviceMotionLiteConfigure, NSString *)
CoreLocation: Physical device ID cannot be nil.  Unable to configure device motion lite.
CoreLocation: Setting DeviceMotionLite ReportInterval for device %@ to %d
ReportInterval
static void CLSensorInterfaceIoHid::onDeviceMotionLiteEvent(void *, void *, void *, IOHIDEventRef)
CoreLocation: DeviceMotionLite,VendorData,size,%ld
CoreLocation: Unhandled size %ld
Unhandled size %ld
/System/Library/Frameworks/CoreMotion.framework/Support
static void CLMotionCore::create()
CoreLocation: Could not get parent thread parameters
Could not get parent thread parameters
CoreLocation: Motion runloop ref still not set!
Motion runloop ref still not set!
___ZN12CLMotionCore23setMotionThreadPriorityEi_block_invoke
CoreLocation: Could not get scheduling parameters for motion thread, error = %d
Could not get scheduling parameters for motion thread, error = %d
LogSensorAscii
___ZN12CLMotionCore20shouldLogSensorAsciiEv_block_invoke
CoreLocation: LogSensorAscii,%d
wrapRunLoopWithAutoreleasePoolHandler
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Shared/Motion/CLMotionCore.mm
count > 0
com.apple.CoreMotion.MotionThread
MotionThreadPriority
static void *CLMotionCore::runMotionThread(void *)
CoreLocation: could not create runloop source
could not create runloop source
CoreLocation: Motion thread exiting
Motion thread exiting
locationd
com.apple.CoreMotion
CLPocketStateService
com.apple.CoreMotion.CLPocketStateService
v16@?0@"CMMotionActivity"8
void CLPocketStateService::enableDetection()
CoreLocation: Could not subscribe to system power notifications
CoreLocation: enabled detection successfully
void CLPocketStateService::determineState()
CoreLocation: Device Stationary?, %s, Orientation, %s, Proximity, %s
1 prox corroborated
2 not (FaceDown and static)
3 no prox
4 FaceDown only
5 not FaceDown, prox uncovered
Unknown
OutOfPocket
FaceDown
FaceDownOnTable
InPocket
Uncovered
Covered
Not FaceDown
started
extended
ignored
void CLPocketStateService::transitionToState(CLPocketStateInternalType, const char *)
CoreLocation: Transition, From: %s, To: %s, %s
CoreLocation: %f: Device Stationary?, %s, Orientation, %s, Proximity, %s, State, %s
virtual void CLPocketStateService::numberOfSpectatorsChanged(int, size_t)
CoreLocation: disable Detection
com.apple.CoreMotion.PocketState.%@
%@.%@
void CLPocketStateService::queryInitiated(NSTimeInterval)
CoreLocation: %f: monitorTime, %f, bksMonitorTime, %f, bksDelay, %f, proxStatus, %s
proxStatus.started
proxStatus.extended
proxStatus.ignored
___ZN20CLPocketStateService17feedProximityDataEj_block_invoke
CoreLocation: %f: ProxDelay,%f
proxBootDelay
CoreLocation: Proximity detection mask: %u, Last prox state: %s
void CLPocketStateService::onSystemPowerChanged(io_service_t, uint32_t, void *)
CoreLocation: received WillSleep
CoreLocation: received WillPowerOn
CoreLocation: received HasPoweredOn
com.apple.CoreMotion.CMNatalimeter
__29-[CMNatalimeterInternal init]_block_invoke
__29-[CMNatalimeterInternal init]_block_invoke_2
CoreLocation: CMNatalimeter client connection interrupt, %@, %d, %p
__29-[CMNatalimeterInternal init]_block_invoke_3
CoreLocation: Unable to set activity session on interrupted connection.  locationd and framework client states are not in sync!
Unable to set activity session on interrupted connection.  locationd and framework client states are not in sync!
v16@?0q8
CoreLocation: %s (%d) setting session %d %p
-[CMNatalimeterInternal _setSession:withCompletionHandler:]
kCLConnectionMessageNatalimetrySetSession
__59-[CMNatalimeterInternal _setSession:withCompletionHandler:]_block_invoke
CoreLocation: Unable to set session. Unexpected user error
Unable to set session. Unexpected user error
CoreLocation: Unable to set session. Error code %d
Unable to set session. Error code %d
CoreLocation: %s (%d) received status %d after setting session %d %p
kCLConnectionMessageNatalimetryQuery
__82-[CMNatalimeterInternal _queryAbsoluteNatalimetryDataSinceDataRecord:withHandler:]_block_invoke
CoreLocation: %@, pid, %d, CMNatalimeter query since record, %@, %p
kCLConnectionMessageNatalimetryUpdate
__73-[CMNatalimeterInternal _startAbsoluteNatalimetryDataUpdatesWithHandler:]_block_invoke.125
CoreLocation: %@, pid, %d, CMNatalimeter update, %@, %p
__73-[CMNatalimeterInternal _startAbsoluteNatalimetryDataUpdatesWithHandler:]_block_invoke_2
CoreLocation: Unable to parse kCLConnectionMessageNatalimetryUpdate message!
Unable to parse kCLConnectionMessageNatalimetryUpdate message!
__60-[CMNatalimeterInternal _stopAbsoluteNatalimetryDataUpdates]_block_invoke
CoreLocation: Unable to stop natalimetry data updates as we are are not receiving updates
Unable to stop natalimetry data updates as we are are not receiving updates
kCLConnectionMessageNatalimetryCalibrationPromptsNeeded
-[CMNatalimeterInternal _promptsNeeded]
CoreLocation: Querying for natalimetry calibration prompts encountered an error: %ld.
Querying for natalimetry calibration prompts encountered an error: %ld.
kCLConnectionMessageNatalimetryGetUserProfile
+[CMNatalimeter userProfile]
kCLConnectionMessageNatalimetrySetUserProfile
+[CMNatalimeter setUserProfile:error:]
CoreLocation: Unable to set user profile. Error code %d
Unable to set user profile. Error code %d
kCLConnectionMessageNatalimetryResetCalibration
+[CMNatalimeter resetCalibrationDataWithError:]
CoreLocation: Unable to reset calibration data. Error code %ld.
Unable to reset calibration data. Error code %ld.
CoreLocation: Invalid response to natalimetry reset calibration.
Invalid response to natalimetry reset calibration.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMNatalimeter.mm
session >= 0 && session < kCMNatalieDataSessionMax
userInfo
T@"CMNatalimeterInternal",R,N,V_internal
kTypeUnknown
kTypeFrozen
kTypeStatic
kTypeMoving
kTypeSemiStationary
kTypeWalking
kTypeWalkingSlow
kTypeRunning
kTypeCycling
kTypeInVehicleFrozen
kTypeInVehicleStatic
kTypeDriving
kTypeVehicularInHand
kTypeDrivingOther
kTypeDrivingMounted
kTypeDrivingOrWalkingSlow
kTypeCyclingSeat
kTypeCyclingChassis
kTypeCyclingLeg
kTypeCyclingArm
kTypeCyclingTorso
kTypeDrivingSeat
kTypeDrivingArm
kTypeDrivingStowed
kTypeRunningLeg
kTypeRunningArm
kTypeWalkingLeg
kTypeWalkingArm
kTypeSemiStationaryPocket
kTypeSemiStationaryArm
ERROR
LogFile
LogFileDirectory
LogFilePrefix
LogFileFlush
ShowError
LogFence
LogBufferSize
LogShowUI
LogFileLevel
LogBufferLevel
LogConsoleLevel
LogStackLevel
LogLocations
LogLocationsFile
LogLocationsFlush
.log
com.apple.locationd.log.compression
vlog
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Shared/Logging/CLLog.mm
newFullContentLength == fullContentLength
fullContentLength + 1 < bufferLength
%s,%s,Time,%08.3f,Function,"%s",
%s,%s,Time,%08.3f,
%s,%s,logging locations to %s%s
NOTICE
CLLog
 and flushing immediately
 no flush
%s,%s,logging locations to an internal buffer with capacity %d
.bz2
%s,%s,Failed to move aside log file %s (%d)
.log.bz2
%s/%s
Failed to delete log
%s,%s,Rotation path is too long, could not delete old logs.
C16@?0r*8
%s,%s,Failed to write %s
%s,%s,could not open locations log %s, errno %d
Unplugged!
void CLLog::logHeader()
CoreLocation-%s
locationd was compiled on %s at %s
Aug  6 2016
21:45:06
%s @ system model %s / version %s
/usr/libexec/locationd @ system model %s / version %s
IOPlatformSerialNumber: %s
Begin settings dump (read at construction of CLSettings or upon darwin notification 'com.apple.locationd/prefs')
End settings dump
%s,%s,CLLog does not honor stderr/stdout unless in backward compatibility mode
com.apple.timed
%s,%s,dumping internal buffer
.txt
%s,%s,copying gll.log
LogNatalimetry
LogCalorimetry
userinfo
cache
.plist.log
%s,%s,could not copy %s log
WARNING
%s,%s,could not dump log file
%s,%s,Time,%08.3f,%d
0x%08lx %s + %lu
STATUS
STACK
%s,%s,Time,%08.3f,%d
0x%08lx 0x%08lx + %lu
%s,%s,Time,%08.3f,%d
0x%08lx
CLCircularLogBuffer
kCMMagneticFieldCodingKeyX
kCMMagneticFieldCodingKeyY
kCMMagneticFieldCodingKeyZ
void CLWriteStackshot(const char *, _Bool)
CoreLocation: stackshot only available on device
long CLCommonGetFileSizeFd(int)
CoreLocation: Failed to get current position for fd %d: %s
Failed to get current position for fd %d: %s
CoreLocation: Failed to get size of fd %d: %s
Failed to get size of fd %d: %s
CoreLocation: Failed to restore to original position of fd %d: %s
Failed to restore to original position of fd %d: %s
-decrypt-XXXXXXXXX.tmp
bool CLCommonDecryptFileAES256(const char *, const char *, const char *)
CoreLocation: Failed to create decryptor. status = %d
Failed to create decryptor. status = %d
CoreLocation: Failed to open input file '%s' to decrypt: %s
Failed to open input file '%s' to decrypt: %s
CoreLocation: Failed to get size of input file %s
Failed to get size of input file %s
CoreLocation: Failed to open temporary output file '%s' to save '%s' to '%s': %s
Failed to open temporary output file '%s' to save '%s' to '%s': %s
CoreLocation: Decrypting '%s' to '%s' via temporary file '%s'
CoreLocation: Failed to read from '%s'.  %lld bytes read successfully.  %s
Failed to read from '%s'.  %lld bytes read successfully.  %s
CoreLocation: Failed to decrypt '%s'.  %lld input bytes decrypted successfully. %d
Failed to decrypt '%s'.  %lld input bytes decrypted successfully. %d
CoreLocation: Failed to write to '%s'.  %lld input bytes decrypted & written successfully. %s
Failed to write to '%s'.  %lld input bytes decrypted & written successfully. %s
CoreLocation: Failed to finalize decryption of '%s': %d
Failed to finalize decryption of '%s': %d
CoreLocation: Failed to write final %zu bytes to '%s': %s
Failed to write final %zu bytes to '%s': %s
CoreLocation: Failed to rename '%s' to '%s'. Decryption of '%s' failed: '%s'
Failed to rename '%s' to '%s'. Decryption of '%s' failed: '%s'
CoreLocation: Decryption of '%s' failed.  Also failed to unlink temporary file '%s': %s
Decryption of '%s' failed.  Also failed to unlink temporary file '%s': %s
CLAccelerometer::Sample CLSensorNetworkProtocol::deserializeAccelerometerPacket(CFDataRef)
CoreLocation: Not an accelerometer packet
Not an accelerometer packet
CLGyro::Sample CLSensorNetworkProtocol::deserializeGyroPacket(CFDataRef)
accelerometerUpdateInterval
Td,D,N
accelerometerAvailable
TB,R,D,N,GisAccelerometerAvailable
accelerometerActive
TB,R,D,N,GisAccelerometerActive
accelerometerData
T@"CMAccelerometerData",R,D
gyroUpdateInterval
gyroAvailable
TB,R,D,N,GisGyroAvailable
gyroActive
TB,R,D,N,GisGyroActive
gyroData
T@"CMGyroData",R,D
magnetometerUpdateInterval
Td,N
magnetometerAvailable
TB,R,N,GisMagnetometerAvailable
magnetometerActive
TB,R,N,GisMagnetometerActive
magnetometerData
T@"CMMagnetometerData",R
deviceMotionUpdateInterval
attitudeReferenceFrame
TQ,R,D,N
deviceMotionAvailable
TB,R,D,N,GisDeviceMotionAvailable
deviceMotionActive
TB,R,D,N,GisDeviceMotionActive
deviceMotion
T@"CMDeviceMotion",R,D
showsDeviceMovementDisplay
com.apple.locationd.appreset
com.apple.locationd.appstatus
com.apple.locationd.techstatus
com.apple.locationd.started
com.apple.locationd.statusbar
com.apple.locationd.authorization
Locations
LocationCount
CLConnection::~CLConnection()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Core/CLConnection.mm
void CLConnection::handleMessage(std::shared_ptr<CLConnectionMessage>)
CoreLocation: Unhandled message %s
bool CLConnection::sendMessageInternal(std::shared_ptr<CLConnectionMessage>, xpc_handler_t)
CoreLocation: Couldn't create XPC message
Couldn't create XPC message
v16@?0@"NSObject<OS_xpc_object>"8
kCLConnectionMessageInfoKey
id<NSSecureCoding> CLConnectionMessage::getObject() const
CoreLocation: The received data object is invalid.
The received data object is invalid.
bool CLConnectionMessage::sendReply(const std::string &, id<NSSecureCoding>)
CoreLocation: Unable to send reply, a reply message does not exist.
Unable to send reply, a reply message does not exist.
bool CLConnectionMessage::sendReply(const std::string &, xpc_object_t)
___ZL15setEventHandlerPU24objcproto13OS_xpc_object8NSObjectU13block_pointerFvNSt3__110shared_ptrI19CLConnectionMessageEEEU13block_pointerFvvES9_PS9__block_invoke
CoreLocation: Connection interrupted!
CoreLocation: Location connection invalid!
CoreLocation: Got unexpected location event
Got unexpected location event
void handleXPCEvent(xpc_object_t, CLConnectionMessageHandler, CLConnection *)
CoreLocation: Error on message reply (%s)
Error on message reply (%s)
CoreLocation: Ignoring unexpected event
Ignoring unexpected event
bool CLSensorInterfaceNetwork::connectToServer(const char *)
CoreLocation: Could not create socket
Could not create socket
CoreLocation: Could note create run loop source
Could note create run loop source
CoreLocation: Could not resolve address: %s
Could not resolve address: %s
CoreLocation: Could not connect to address: %s
Could not connect to address: %s
void CLSensorInterfaceNetwork::installDataSocket()
CoreLocation: Could not bind to address
Could not bind to address
CoreLocation: Data socket installed successfully
SetProperties
SensorName
UpdateInterval
BEGIN_COMMAND
END_COMMAND
CLSensorFusion9AxisMekf::CLSensorFusion9AxisMekf(const CFTimeInterval &, const CFTimeInterval &, const CFTimeInterval &, bool)
CoreLocation: XY: rotBufferSize9, %zu, accelBufferSize, %zuu, peakCount, %d, compassBufferSize, %zu
CoreLocation: XY: gyroDt9, %.4f, doAccelCheck, %d
virtual void CLSensorFusion9AxisMekf::reset()
CoreLocation: XY: fAccelBuffer,size,%zu
virtual void CLSensorFusion9AxisMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: omegaMag9, %.3f, omega, %.3f, %.3f, %.3f
AppleQuaternion9
virtual void CLSensorFusion9AxisMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)
virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)
CoreLocation: Type,%s,x,%f,y,%f,z,%f,timestamp,%lf
Accelerometer9
CoreLocation: Type,%s,%.3f, %.3f, %.3f, %.3f
RotationRate9
KalmanFilterStates9
void CLSensorFusion9AxisMekf::doAccelerometerMeasurementUpdate(double *, double)
KalmanFilterStates9-AccelUpdate
virtual bool CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const bool &, const bool &, const CFTimeInterval &)
CoreLocation: Type,%s,timestamp,%f,calibration level %d, compassHasAlignedToStableField %d, useMagneticRefX %d
CompassIntoKF
CoreLocation: Type,%s,fLastAccelTime,%f
CoreLocation: Type,%s,magneticFieldAdjusted!
CoreLocation: rotAroundGrav, %.3f, sum, %.3f
CoreLocation: Type,%s,omegaMag, %.3f, omegaVar, %.3f
CoreLocation: FieldDiff, %.3f, %.3f, %.3f, %.3f
CoreLocation: Aborted yawUpdate.
CoreLocation: Checking again for magField. checkcount, %d
CoreLocation: fCorrected, %.3f, %.3f, %.3f
CoreLocation: Type,%s,x,%f,y,%f,z,%f,calibrationLevel,%d,timestamp,%lf
!!!CompassInertialReference
CoreLocation: Compass outputs field magnitude 0.
CoreLocation: Type,%s,x,%f,y,%f,z,%f
CoreLocation: UpdatingYaw!
Magnetometer9
CoreLocation: Hey! Compass outputs field magnitude 0.
float CLSensorFusion9AxisMekf::doCompassMeasurementUpdate(double *, double, int, bool)
CoreLocation: Type,%s,%f,%f,%f,%f
ExpectedCompass
CoreLocation: Type,%s,%f,%f,%f,%d,%f
TrueCompass
CoreLocation: Type,%s,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f
MagCCross
CoreLocation: Type,%s,%f,%f,%f,angle,%.3f,sumRot,%.3f,%f
MagCorrectionDX
Generic
INFO
VERBOSE
NONE
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMElevationData.mm
sample
sourceId && startDate && endDate
%@, <startDate, %@, endDate, %@, elevationAscended, %lu, elevationDescended, %lu>
TQ,R,N
kCMElevationDataCodingKeyRecordId
kCMElevationDataCodingKeySourceId
kCMElevationDataCodingKeyStartDate
kCMElevationDataCodingKeyEndDate
kCMElevationDataCodingKeyElevationAscended
kCMElevationDataCodingKeyElevationDescended
%@ @ %f,<startDate,%@,type,%s,confidence,%s,mountedState,%d,mountedConfidence,%s,isStanding,%d,tiltAngle,%f,exitState,%d,estExitTime,%f>
isMoving
isWalking
isRunning
isDriving
maybeExitingVehicle
hasExitedVehicle
kCMActivityCodingKeyType
kCMActivityCodingKeyConfidence
kCMActivityCodingKeyMounted
kCMActivityCodingKeyMountedConfidence
kCMActivityCodingKeyIsStanding
kCMActivityCodingKeyTiltAngle
kCMActivityCodingKeyTimestamp
kCMActivityCodingKeyVehicleExitState
kCMActivityCodingKeyEstExitTime
kCMActivityCodingKeyStartTime
com.apple.CoreLocation.ConnectionClient.%p
com.apple.CoreLocation.ConnectionClient.%p.events
B8@?0
void CLConnectionClient::setHandlerForMessage_onQueue(NSString *, CLConnectionMessageHandler)
CoreLocation: Setting handler for message %s
bool CLConnectionClient::sendMessage_onQueue(std::shared_ptr<CLConnectionMessage>, bool)
CoreLocation: Sending an un-cached message without first clearing the previously cached value
Sending an un-cached message without first clearing the previously cached value
static void CLConnectionClient::handleDaemonStart(CFNotificationCenterRef, void *, CFStringRef, const void *, CFDictionaryRef)
CoreLocation: received daemon start notification for service %s
void CLConnectionClient::createConnection_onQueue()
CoreLocation: Creating connection
v32@?0@8@16^B24
void CLConnectionClient::destroyConnection_onQueue()
CoreLocation: Destroying connection
void CLConnectionClient::sendCachedMessages_onQueue()
CoreLocation: Sending cached messages to daemon
CoreLocation: No cached registration message
com.apple.CoreMotionCMGestureManagerPrivateQueue
kCLConnectionMessageGesture
__66-[CMGestureManagerInternal startGestureUpdatesWithHandlerPrivate:]_block_invoke
CoreLocation: Could not get dictionary for kCLConnectionMessageGesture
Could not get dictionary for kCLConnectionMessageGesture
GestureDetected
GestureCanceled
CoreLocation: Unexpected ear gesture state received: %s
Unexpected ear gesture state received: %s
__66-[CMGestureManagerInternal startGestureUpdatesWithHandlerPrivate:]_block_invoke.32
CoreLocation: Default handler received message %s
kCLConnectionMessagePriorityKey
CoreLocation: Calling ear gesture handler
__34-[CMGestureManager gestureHandler]_block_invoke
gestureHandler
T@?,C
com.apple.CoreMotion.CMActivityManagerPrivateQueue
kCLConnectionMessageMotionState
__36-[CMActivityManagerInternal connect]_block_invoke
CoreLocation: Could not get dictionary for kCLConnectionMessageMotionState
Could not get dictionary for kCLConnectionMessageMotionState
CoreLocation: Error occurred while trying to retrieve activity update: CMErrorDomain Code:%d
Error occurred while trying to retrieve activity update: CMErrorDomain Code:%d
CoreLocation: Unable to parse kCLConnectionMessageMotionState message!
Unable to parse kCLConnectionMessageMotionState message!
kCLConnectionMessageSidebandOverride
__36-[CMActivityManagerInternal connect]_block_invoke.30
CoreLocation: Could not parse dictionary for kCLConnectionMessageSidebandOverride
Could not parse dictionary for kCLConnectionMessageSidebandOverride
kCLConnectionMessageMotionStateSim
__36-[CMActivityManagerInternal connect]_block_invoke.40
CoreLocation: Could not parse dictionary for kCLConnectionMessageMotionStateSim
Could not parse dictionary for kCLConnectionMessageMotionStateSim
__36-[CMActivityManagerInternal connect]_block_invoke.51
-[CMActivityManagerInternal overrideOscarSideband:withState:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMActivityManager.mm
fSidebandOverrideSemaphore && "fSidbandOverrideSemaphore not initialized."
-[CMActivityManagerInternal simulateMotionState:withState:]
fMotionStateSimSemaphore && "fMotionStateSimSemaphore not initialized."
com.apple.CoreMotion.SidebandOverride
__53-[CMActivityManager overrideOscarSideband:withState:]_block_invoke.125
CoreLocation: Timeout occurred after 5 seconds during overrideOscarSideband:withState:.  Wait result = %ld
Timeout occurred after 5 seconds during overrideOscarSideband:withState:.  Wait result = %ld
com.apple.CoreMotion.MotionStateSim
activityHandler
activityAvailable
TB,R,N,GisActivityAvailable
com.apple.CoreMotion.CMPedometerInternalQueue
com.apple.CoreMotion.CMPedometerUpdateQueue
kCLConnectionMessageStartStepCountUpdate
__24-[CMPedometerProxy init]_block_invoke
CoreLocation: Unable to parse message (%s) when starting updates to queue
Unable to parse message (%s) when starting updates to queue
CoreLocation: Unable to parse message when starting updates to queue!
Unable to parse message when starting updates to queue!
kCLConnectionMessagePedometerEvent
__24-[CMPedometerProxy init]_block_invoke_2.84
CoreLocation: nil pedometer event dictionary received
nil pedometer event dictionary received
__24-[CMPedometerProxy init]_block_invoke.91
CoreLocation: Error pedometer event, %ld
Error pedometer event, %ld
__24-[CMPedometerProxy init]_block_invoke.102
CoreLocation: Unrecognizable pedometer event dictionary
Unrecognizable pedometer event dictionary
__24-[CMPedometerProxy init]_block_invoke.112
CoreLocation: CMPedometer client connection interrupt, %@, %d, %p
kCLConnectionMessageStepCountQuery
__63-[CMPedometerProxy _startPedometerUpdatesFromDate:withHandler:]_block_invoke.148
CoreLocation: Error occurred: %s
Error occurred: %s
v32@?0@"CMPedometerData"8@"NSDictionary"16@"NSError"24
-[CMPedometerProxy _handleQueryResponse:onQueue:withHandler:]
CoreLocation: Unable to parse message (%s) for query response 
Unable to parse message (%s) for query response 
CoreLocation: Unable to parse message when checking for availability!
Unable to parse message when checking for availability!
kCLConnectionMessageStepCountRecordQuery
kCLConnectionMessageStartStepCountAvailable
kCLConnectionMessagePaceAndCadenceAPIAvailable
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMPedometer.mm
-[CMPedometer _queryPedometerDataSinceDataRecord:withHandler:]
CoreLocation: handler not set.
handler not set.
pedometerProxy
T@"CMPedometerProxy",R,N,V_pedometerProxy
frozen
static
moving
walking
driving
cycling
semi-stationary
running
moving coarse
in vehicle frozen
in vehicle static
walking slow
vehicular in hand
driving other
cycling leg
Stationary Cycling
Cross Training
Stair Climbing
Indoor Running
Indoor Walking
Pushing Wheelchair
Outdoor Wheelchair Activity
medium
high
CLCompassDatabaseClientSilo
-[CLCompassDatabaseClientAdapter beginService]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Providers/Motion/CLCompassDatabaseClient.mm
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLNotifierData *) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::invokeClientWithData(const ClientMapIter &, const NotificationMapIter &, CLNotifierData *) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLAttitudeDependentKFCalibrator::init()
CoreLocation: RotationStability buffer not set.
RotationStability buffer not set.
virtual void CLAttitudeDependentKFCalibrator::setBias(const CLVector3d<float> &, const CLMotionTypeCompassCalibrationLevel &, const CLVector3d<float> &, const CLClientQuaternion *)
CoreLocation: Could not set bias retrieved from database
Could not set bias retrieved from database
void CLAttitudeDependentKFCalibrator::resetInternal(const CLVector3d<float> &, const CLMatrix3d<float> &, CLMotionTypeCompassCalibrationLevel)
CoreLocation: reset internal. levels-data(%d %d %d), pScale=%.3f 
virtual void CLAttitudeDependentKFCalibrator::reset()
CoreLocation: compass calibrator reset
void CLAttitudeDependentKFCalibrator::resetCalibration(const CLVector3d<float> &, const CLMatrix3d<float> &)
CoreLocation: Resetting calibrator states.
bool CLAttitudeDependentKFCalibrator::resync(float, bool, bool, bool, float, float, float, const CLVector3d<float> &, float, float, float, const CLVector3d<float> &)
CoreLocation: Resync after long coasting with mag drift. mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), Age(%d,%d)
CoreLocation: DRIFT DETECTED. numBad=%d,s=%.3f,delH(%.3f,%d,%.3f), expectedVec (%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d),deltaTime(%.3f)
CoreLocation: Likely bad resync. Backup. 
CoreLocation: RESYNC Rejected. numBad=%d,mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), syncAge(%d)
CoreLocation: numBad(%d), delH(%.3f), coastVec(%.3f/%.3f/%.3f), expectedVec(%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d)
bool CLAttitudeDependentKFCalibrator::handleInterference(const CLVector3d<float> &, const CLVector3d<float> &, bool, bool)
CoreLocation: Coasting vector not set.
Coasting vector not set.
CoreLocation: Prolonged high magDiff. Likely bad calibration. Resetting.
CoreLocation: Extremely high magnitude.  magDiff (%.3f), magnitude (%.3f), calibrated (%.3f/%.3f/%.3f), coastVector (%.3f/%.3f/%.3f),coastingTime,%.3f,magDiffVar,%.3f,resetInternal,%d
CoreLocation: Likely bad database lookup. Resetting. 
CoreLocation: Steep inclination. Likely bad interference or bad database lookup. Resetting. 
CoreLocation: Interference is gone.
CoreLocation: **INTERFERENCE-1 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
CoreLocation: **INTERFERENCE-0 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
void CLAttitudeDependentKFCalibrator::handleDivergence(const CLVector3d<float> &)
CoreLocation: Divergence!!! Resetting. 
int CLAttitudeDependentKFCalibrator::calcCalibrationLevel(const CLVector3d<float> &)
CoreLocation: new internal estimates (%.3f %.3f %.3f)
CoreLocation: taking new estimates, Internal. fIsCoasting (%d)
CoreLocation: new estimates denied, fIsCoasting (%d)
CoreLocation: taking new estimates, reached database. (%d)
CoreLocation: new esitmates disagree with database. (%d,%d,%.3f)
CoreLocation: calibrated, first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
CoreLocation: taking new estimates, fIsCoasting (%d)
CoreLocation: estimates improved.(%.3f/%.3f/%.3f), numImprov=%d 
CoreLocation: new estimates needed, fIsCoasting (%d)
CoreLocation: first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
bool CLAttitudeDependentKFCalibrator::sanityCheck(unsigned int *, CLMotionTypeCompassCalibrationLevel, float &)
CoreLocation: new estimates calculated, converged(%d %d %d) Var (%.3f %.3f %.3f), remain (%.3f), level (%d), num=%d 
void CLAttitudeDependentKFCalibrator::resetAfterCoasting()
CoreLocation: Bad heading divergence for too long. Prompt user to re-calibrate.
CoreLocation: Waiting too long for internal re-calibration. Prompt user.
CoreLocation: Waiting too long for high magnitude interference to go away. Exit coasting.
CoreLocation: Coasting for too long. Exit coasting.
virtual void CLAttitudeDependentKFCalibrator::referenceAttitudeChanged(bool, const CLMotionTypeMagneticField &)
CoreLocation: fCoastingVecPrint: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f
virtual void CLAttitudeDependentKFCalibrator::addSample(const CLVector3d<float> &, const CLClientQuaternion *, const CFTimeInterval &)
CoreLocation: Attitude data not set.
Attitude data not set.
CoreLocation: Type,%s,Updating reference frame.
Compass-withFusion
CoreLocation: Updating during coasting, fIsResetInternal(%d)
CoreLocation: BACKUP resync coasting vector
CoreLocation: resync coasting vector. rotM,%.3f,rotV,%.3f
CoreLocation: device status: (smooth static) = (%d %d), rotM,%.3f,rotV,%.3f, q.x,%.3f,q.y,%.3f,q.z,%.3f,q.w,%.3f)
CoreLocation: coasting vector is mature, no more updating
CoreLocation: numSamplesSkipped (%d), deltaQ (%.3f/%.3f/%.3f/%.3f), deltaReadingM (%.3f)
void CLAttitudeDependentKFCalibrator::setCalibrationValues()
CoreLocation: bias.x,%.3f,bias.y,%.3f,bias.z,%.3f,scale.x,%.5f,scale.y,%.5f,scale.z,%.5f,extF.x,%.3f,extF.y,%.3f,extF.z,%.3f
void CLAttitudeDependentKFCalibrator::setCoastingVector(bool)
CoreLocation: set coasting vector (%.3f/%.3f/%.3f), levels (%d %d) conv(%d %d %d) age (%d) syncAge (%d) DueTo (%d)
void CLAttitudeDependentKFCalibrator::enterCoasting()
CoreLocation: enters coasting
CLCompassCalibrator::CLCompassCalibrator(const CFTimeInterval &)
CoreLocation: compass calibrator logging (%d)
void CLAttitudeDependentKFCalibrator::exitCoasting()
CoreLocation: exits coasting
CMAvailable
CMAuthorized
CMErrorMessage
CMReturnCode
CMOnBodyStatusManagerClassifierTheta0
CMOnBodyStatusManagerClassifierTheta1
CMOnBodyStatusManagerClassifierTheta2
CMOnBodyStatusManagerClassifierTheta3
CMOnBodyStatusManagerClassifierTheta4
CMOnBodyStatusManagerClassifierTheta5
CMOnBodyStatusManagerClassifierMinLowPower
CMOnBodyStatusManagerClassifierMaxLowPower
CMOnBodyStatusManagerClassifierMaxHighPower
CMOnBodyStatusManagerLowBandStart
CMOnBodyStatusManagerLowBandStop
CMOnBodyStatusManagerHighBandStart
CMOnBodyStatusManagerHighBandStop
CMOnBodyStatusManagerWakeThreshold
CMOnBodyStatusManagerOddsThreshold
CMOnBodyStatusManagerMedianFilterSize
CMOnBodyStatusManagerConfidenceThreshold
CMOnBodyStatusManagerUseHysteresis
CMOnBodyStatusManagerUseAngleOverride
CMOnBodyStatusManagerAngleMetricThreshold
CMOnBodyStatusManagerManufacturer
CMPedometerDataObject
CMPedometerDataArray
CMPedometerStartTime
CMPedometerStopTime
CMPedometerSpeedSum
CMPedometerEntryCount
CMPedometerEventKey
CMNatalimetrySessionId
CMNatalimetryRecordId
CMNatalimetryNatalieData
CMNatalimetryNatalieDataStartDate
CMNatalimetryNatalieDataMets
CMNatalimetryNatalieDataNatalies
CMNatalimetryNatalieDataBasalNatalies
CMNatalimetryNatalieDataSourceId
CMNatalimetryNatalieDataArray
CMNatalimeterSetUserHeightMeter
CMNatalimeterSetUserWeightKG
CMNatalimeterSetUserAgeYr
CMNatalimeterSetUserBiologicalSex
CMNatalimeterSetUserCondition
CMNatalimeterSetUserPal
CMNatalimeterSetUserHrmin
CMNatalimeterSetUserHronset
CMNatalimeterSetUserVo2max
CMNatalimeterSetUserVo2maxReset
CMNatalimeterSetUserHrminReset
CMNatalimeterSetUserRunVo2max
CMNatalimeterSetUserOnsetVo2max
CMOdometerDataObject
CMOdometerGpsAvailability
CMOnBodyStatusData
CMSedentaryTimerIsArmed
CMSedentaryTimerStartTime
CMSedentaryTimerPeriodInterval
CMSedentaryTimerReminderInterval
CMSedentaryTimerAutoReschedule
CMSedentaryTimerAlarmData
CMSedentaryTimerErrorMessage
CMMotionActivityStartTime
CMMotionActivityStopTime
CMMotionActivityData
CMMotionActivityDataArray
CMActivityData
CMOverrideSidebandOverride
CMStateSidebandState
CMOverrideResult
CMSidebandSensorFusionEnable
CMSidebandSensorFusionLatency
CMSidebandSensorFusionSnoop
CMSidebandSensorFusionSuccess
CMMotionStateSim
CMMotionStateSimState
CMMotionStateSimResult
CMVehicleConnectionStartTime
CMVehicleConnectionEndTime
CMVehicleStateDeviceId
CMDeviceHasOriginalBackCamera
CMCameraVcmActuatorId
CMCompassCalibrationData
CMMotionStateUpdateType
CMMotionStateUpdateData
CMExerciseMinuteRecordId
CMExerciseMinuteStartDate
CMExerciseMinuteSourceId
CMExerciseMinuteDataArray
CMWorkoutKeyType
CMWorkoutKeySessionId
CMWorkoutKeyEventDate
CMWorkoutKeyLocation
CMWorkoutKeyPoolLength
CMSwimKeyDataRecord
CMSwimKeyDataArray
CMSignificantElevationKeyQueryTimeRange
CMSignificantElevationKeySample
CMCaptureModeData
void CLGyroCalibrationCache::removeOutliers()
CoreLocation: Begin.
CoreLocation: Too few points.  End.
CoreLocation: temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,1
CoreLocation: temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,0
CoreLocation: End.
reset
/BuildRoot/Applications/Xcode.app/Contents/Developer/Platforms/AppleTVSimulator.platform/Developer/SDKs/AppleTVSimulator10.0.sdk/usr/local/include/boost/smart_ptr/scoped_ptr.hpp
p == 0 || p != px
CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, bool, bool)
CoreLocation: using attitude dependent KF calibrator
CompassIgnoreDatabase
CompassManualCalibration
CompassOffsetManualX
CompassOffsetManualY
CompassOffsetManualZ
CompassIgnoreCalibration
CompassInputFilter
CompassOutputFilterSize
CompassOutputFilterScale
CoreLocation: apple compass calculator, logging (%d) sample rate (%.3f) ignoreDatabase (%d) manual (%d)
bool CLCompassCalculator::feedMagnetometerData(const CLMotionTypeMagneticField &)
CoreLocation: XYDevice not stable. %d, %d, %.3f, Clearing search buffers.
CoreLocation: storing new compass calibration, magneticField (%+.3f,%+.3f,%+.3f), bias (%+.3f/%+.3f/%+.3f), level (%d) magnitude (%+.3f) inclination (%+.3f)
bool CLCompassCalculator::getCompassData(CLMotionTypeCompass &)
CoreLocation: rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f
CoreLocation: Heading  %.2f, is not in bound [0 360]
void CLCompassCalculator::updateInterferenceChecks()
CoreLocation: magnitude max threshold exceeded (%+.3f), resetting calibration
CoreLocation: magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
CoreLocation: inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
void CLCompassCalculator::feedCompassDatabaseNotificationWithData(int, const CLCompassDatabase_Type::Notification &, const CLCompassDatabase_Type::NotificationData &)
CoreLocation: CompassDB restored bias (%+.3f/%+.3f/%+.3f)
CLCompassDatabaseDaemon
CLCompassDatabaseClient
kCLMotionTypeGeomagneticModelDataXKey
kCLMotionTypeGeomagneticModelDataYKey
kCLMotionTypeGeomagneticModelDataZKey
kCLMotionTypeGeomagneticModelDataMagnitudeKey
kCLMotionTypeGeomagneticModelDataHorizontalKey
kCLMotionTypeGeomagneticModelDataDeclinationKey
kCLMotionTypeGeomagneticModelDataInclinationKey
kCLMotionTypeGeomagneticModelDataTimestampKey
kCLBiasXKey
kCLBiasYKey
kCLBiasZKey
kCLVarianceXKey
kCLVarianceYKey
kCLVarianceZKey
KCLDoingBiasEstimationKey
class
<%@: %p>
v32@?0@"NSObject"8@"NSObject"16^B24
code
domain
Attempt to write value multiple times
nullptr key not allowed
Infinity
-Infinity
void CLOnBodyNotifier_Type::Params::log() const
CoreLocation: Parameters: theta0, %f, theta1, %f, theta2, %f, theta3, %f, theta4, %f, theta5, %f, minLowPower, %f, maxLowPower, %f, maxHighPower, %f, lowBandStart, %d, lowBandStop, %d, highbandStart, %d, highBandStop, %d, wakeThreshold, %f, oddsThreshold, %f, medianFilterSize, %u, confidenceThreshold, %f, useHysteresis, %d, useAngleOverride, %d, angleMetricThreshold, %f
static CLOnBodyNotifier_Type::Params CLOnBodyNotifier_Type::Params::getParams(NSDictionary *, NSString *)
CoreLocation: Using the manufacturer specific parameters (%s): %s
CoreLocation: Using the default parameters: %s
CoreLocation: Using the hardcoded parameters
static bool CLOnBodyNotifier_Type::Params::isValid(NSDictionary *)
CoreLocation: Invalid parameters received:
Invalid parameters received:
-[CMMotionManager(DeviceMotionLite) startDeviceMotionLiteUpdatesForDeviceID:usingConfiguration:toQueue:withFusedHandler:debugHandler:]
CoreLocation: Motion manager asked to start device motion lite updates for device id %@
__134-[CMMotionManager(DeviceMotionLite) startDeviceMotionLiteUpdatesForDeviceID:usingConfiguration:toQueue:withFusedHandler:debugHandler:]_block_invoke
CoreLocation: Physical device ID cannot be nil.  Unable to start updates.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMMotionManager+DeviceMotionLite.mm
v24@?0r^{?={?=dddd}{?=fff}{?=fff}{?=fff}{?=fff}Q}8@"NSString"16
-[CMMotionManager(DeviceMotionLite) stopDeviceMotionLiteUpdatesForDeviceID:]
CoreLocation: Motion manager asked to stop device motion lite updates for device id %@
__76-[CMMotionManager(DeviceMotionLite) stopDeviceMotionLiteUpdatesForDeviceID:]_block_invoke
CoreLocation: Physical device ID cannot be nil.  Unable to stop updates.
isDeviceMotionLiteAvailable
TB,R,N,GisDeviceMotionLiteAvailable
CLGeomagneticModelProviderClientSilo
-[CLGeomagneticModelProviderClientAdapter beginService]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Providers/Motion/CLGeomagneticModelProviderClient.mm
virtual bool CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)
CoreLocation: fLocationdConnection is not NULL
fLocationdConnection is not NULL
com.apple.CoreMotion.CLGeomagneticModelProviderClientPrivateQueue
kCLConnectionMessageGmm
___ZN32CLGeomagneticModelProviderClient31registerForNotificationInternalERKN31CLGeomagneticModelProvider_Type12NotificationE_block_invoke
CoreLocation: Could not get geomagnetic model data for message!
Could not get geomagnetic model data for message!
___ZN32CLGeomagneticModelProviderClient31registerForNotificationInternalERKN31CLGeomagneticModelProvider_Type12NotificationE_block_invoke_3
virtual bool CLGeomagneticModelProviderClient::unregisterForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)
CoreLocation: fLocationdConnection is NULL
fLocationdConnection is NULL
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLNotifierData *) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::invokeClientWithData(const ClientMapIter &, const NotificationMapIter &, CLNotifierData *) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
%@,<startDate %@, endDate %@, distance %@, currentSpeed %@, averageSpeed %@>
T@"NSDate",R,N,V_startDate
T@"NSDate",R,N,V_endDate
distance
T@"NSNumber",R,N,V_distance
currentSpeed
T@"NSNumber",R,N,V_currentSpeed
T@"NSNumber",R,N,V_averageSpeed
kCMOdometerDataCodingKeyStartDate
kCMOdometerDataCodingKeyEndDate
kCMOdometerDataCodingKeyDistance
kCMOdometerDataCodingKeyCurrentSpeed
kCMOdometerDataCodingKeyAverageSpeed
CLGeomagneticModelProviderDaemon
CLGeomagneticModelProviderClient
write_escaped_str
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Shared/Logging/CLJsonLogging.cpp
next.first[0] == '\0'
nullptr != escapedControlChar(next.first[0])
/System/Library/PrivateFrameworks/CompassUI.framework/CompassUI
void CLClientLoadCompassUIIfNecessary()
CoreLocation: Unable to load CompassUI framework
CUICalibration
CoreLocation: Could not load CUICalibrationClass from CompassUI framework
CLCoverState
dataIdentifier
offset
dataSize
movement
%@,<identifier, %llu, startTime, %f, timestamp, %llu, dataIdentifier, %llu, offset, %u, dataSize, %u, movement, %d>
TQ,V_identifier
Td,V_startTime
TQ,V_timestamp
TQ,V_dataIdentifier
TI,V_offset
TI,V_dataSize
TB,V_movement
Td,V_endTime
metaIdentifier
TQ,V_metaIdentifier
duration
Td,V_duration
CLMagnetometerCoexistenceNotifier
EnableMagnetometerCoexistenceCompensation
kCLConnectionMessageCompassCalibrationData
static void CLMagnetometerCoexistenceNotifier::create()
CoreLocation: CPAS data response was invaild.
CPAS data response was invaild.
CoreLocation: CPAS data is NULL
CPAS data is NULL
CoreLocation: cpas version is %u, length is %ld bytes
CoreLocation: cpas data was found but did not match any versions. version (%u) length (%ld)
CoreLocation: Magnetometer coexistence compensation is disabled
void CMNonlinearTemperatureFit::feedGyroTemperature(float)
CoreLocation: Assertion failed: temperature != 3.40282347e+38F, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/CMNonlinearTemperatureFit.cpp, line 74,temperature,%f.
Assertion failed: temperature != 3.40282347e+38F, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/CMNonlinearTemperatureFit.cpp, line 74,temperature,%f.
LogCompass
CLCompass
CompassForceCoverAttach
CLCompass::CLCompass()
CoreLocation: %s cover attached logic to %d
Forcing
NOT forcing
CoreLocation: Registered for cover state notifications
virtual CFTimeInterval CLCompass::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: Could not create timer
Could not create timer
void CLCompass::startCompass()
CoreLocation: starting apple compass
CoreLocation: Cover is %sattached
not 
void CLCompass::stopCompass()
CoreLocation: stopping apple compass
static void CLCompass::onCoverState(const bool *, void *)
CoreLocation: Cover Open: %d
void CLCompass::updateKeyboardState(bool)
CoreLocation: keyboard,isConnected,%d
void CLCompass::registerForKeyboardUpdates()
CoreLocation: registering for keyboard updates
IOServiceFirstMatch
IOServiceTerminate
___ZN9CLCompass26registerForKeyboardUpdatesEv_block_invoke
CoreLocation: Failed to register for keyboard updates. Could not register for AppleHIDKeyboardEventDriverV2 service kIOFirstMatchNotification and kIOTerminatedNotification.
CoreLocation: Failed to register for keyboard updates. Could not create KeyboardConnectNotificationPort and KeyboardConnectNotificationPort
void CLCompass::unregisterForKeyboardUpdates()
CoreLocation: unregistering for keyboard updates
CLProximityNotifier
%@ @ %f,<startDate,%@,confidence,%ld,unknown,%d,stationary,%d,walking,%d,running,%d,automotive,%d,cycling,%d>
vehicleConnected
TB,R,N,GisVehicleConnected
stationary
automotive
kCMMotionActivityCodingKeyType
kCMMotionActivityCodingKeyConfidence
kCMMotionActivityCodingKeyStartTime
kCMMotionActivityCodingKeyVehicleConnected
void CLMagnetometerCoexistenceNotifierCpasV5::initializeCalibrationParamaters(const UInt8 *, int)
CoreLocation: Device still has original rear camera. Using unit-specific calibration info
CoreLocation: Rear camera was replaced. VCM actuator ID is %d
CoreLocation: Using generic Mitsumi calibration info
CoreLocation: Using generic Alps calibration info
CoreLocation: Unrecongized VCM actuator. Not performing compensation
void CLMagnetometerCoexistenceNotifierCpasV6::initializeCalibrationParamaters(const UInt8 *, int)
%@,<startDate %@ endDate %@ steps %@ distance %@ floorsAscended %@ floorsDescended %@ currentPace %@ currentCadence %@ averageActivePace %@>
numberOfPushes
workoutType
numberOfSteps
floorsAscended
floorsDescended
currentPace
currentCadence
averageActivePace
Pause
Resume
%@,<eventDate, %@, eventType, %@>
date
T@"NSDate",R,N,VfDate
Tq,R,N,VfType
kCMPedometerDataCodingKeyStartDate
kCMPedometerDataCodingKeyEndDate
kCMPedometerDataCodingKeyNumberOfSteps
kCMPedometerDataCodingKeyDistance
kCMPedometerDataCodingKeyFloorAscended
kCMPedometerDataCodingKeyFloorDescended
kCMPedometerDataCodingKeyRecordId
kCMPedometerDataCodingKeyPace
kCMPedometerDataCodingKeyCurrentCadence
kCMPedometerDataCodingKeyActiveTime
kCMPedometerDatacodingKeyUUID
kCMPedometerDataCodingKeyIsOdometerDistance
kCMPedometerDataCodingKeyIsOdometerPace
kCMPedometerDataCodingKeyNumberOfPushes
kCMPedometerDataCodingKeyWorkoutType
kCMPedometerEventKeyEventDate
kCMPedometerEventKeyEventType
void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CLMagnetometerCoexistenceNotifierCpasCamera::CameraCoexistenceInfo &)
CoreLocation: VCM Delta.x,%f,VCM Delta.y,%f,VCM Delta.z,%f
CoreLocation: Rear camera offset.x,%f,Rear camera offset.y,%f,Rear camera offset.z,%f
kCLConnectionMessageDeviceHasOriginalCamera
kCLConnectionMessageCameraVcmActuatorId
com.apple.isp.focusing
void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()
CoreLocation: Could not register for notification %s
Could not register for notification %s
com.apple.isp.backcamerapower
com.apple.isp.backcamerasensorconfig
void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()
CoreLocation: Could not get state for %s
Could not get state for %s
CoreLocation: focus position = %d
void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()
CoreLocation: camera state = %d
void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()
CoreLocation: camera mode = %d
void CLMagnetometerCoexistenceNotifierCpasCamera::onFocusingNotification()
CoreLocation: Received focusing notification
void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraStateNotification()
CoreLocation: Received camera state notification
void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraModeNotification()
CoreLocation: Received camera mode notification
void CLMagnetometerCoexistenceNotifierCpasV10::chooseOffsetData()
CoreLocation: Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d
CMVector3d CLNonlinearGyroBiasFitter::eval(const Fit &, float)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Providers/Motion/GyroBiasEstimator/CLNonlinearGyroBiasFitter.cpp
Fit::SubFit CLNonlinearGyroBiasFitter::detail::computeSubFit(std::vector<Sample>::const_iterator, std::vector<Sample>::const_iterator)
Fit CLNonlinearGyroBiasFitter::detail::windowFit(std::vector<Sample> &&)
getMedianInPlace
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/CMPressureUtilities.h
size > 0
%@ orientation %d name %@ @ %f
orientation
kCMDeviceOrientationCodingKeyOrientation
CMSetDeviceOrientationNotification
CMSetDeviceOrientationTypeKey
CMPersistOrientationCallbackModeKey
+[CMDeviceOrientationManager initialize]
CoreLocation: Orientation Manager initialized
-[CMDeviceOrientationManager onMotionPreferencesUpdated]
CoreLocation: OrientationCallbackMode,%d,EnableOrientationNotification,%d
__45-[CMDeviceOrientationManager onNotification:]_block_invoke
CoreLocation: The orientation %d is not in bounds
-[CMDeviceOrientationManager startDeviceOrientationUpdatesToQueue:withHandler:]
CoreLocation: Starting orientation updates
-[CMDeviceOrientationManager stopDeviceOrientationUpdates]
CoreLocation: Stopping orientation updates
-[CMDeviceOrientationManager onDeviceOrientation:]
CoreLocation: Notifications disabled
CoreLocation: Received orientation. (%d to %d) Timestamp %f
CoreLocation: Updating client handler: Orientation %d, Callback mode: %d
-[CMDeviceOrientationManager deviceOrientationBlocking]
CoreLocation: Received deviceOrientationBlocking
CoreLocation: Waiting for the first orientation to come in
CoreLocation: Orientation blocking: timeout exceeded!
CoreLocation: Got latest sample: %d @ %f
%@.%@Time
com.apple.backboardd.loggingchanged
OrientationCallbackMode
EnableOrientationNotification
com.apple.CoreMotion.DeviceOrientation
CLBundleKeyValueCache
CLSystemService
CLHarvestableSystemService
CLIsFindMyiPhone
CLIsCoreRoutine
CLEmergencyService
CLRequiredCapabilities
LogDeviceMotion
GyroOnly
6Axis
9Axis
9AxisWithNorthReference
BuildGYTT
3AxisDynamicGyro
6AxisThrottledGyro
CLDeviceMotionProperties<DeviceMotion=%@>
mode
Ti,N,VfMode
CLDeviceMotion
static CLDeviceMotion::CLDeviceMotionNotification CLDeviceMotion::CLMotionTypeDeviceMotionModeToCLDeviceMotionNotification(const CLMotionTypeDeviceMotionMode)
CoreLocation: No viable convertion for mode 0x%x
static CLMotionTypeDeviceMotionMode CLDeviceMotion::CLDeviceMotionNotificationToCLMotionTypeDeviceMotionMode(const int)
CoreLocation: No viable convertion for notification 0x%x
___ZN14CLDeviceMotion29setDeviceMotionUpdateIntervalEPN16CLMotionNotifier10DispatcherEd_block_invoke
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Shared/Motion/Notifiers/CLDeviceMotion.mm
CoreLocation: CLDeviceMotion::setDeviceMotionUpdateInterval changing update interval to: %f
___ZN14CLDeviceMotion25addDeviceMotionDispatcherEPN16CLMotionNotifier10DispatcherEd_block_invoke
CoreLocation: CLDeviceMotion::addDeviceMotionDispatcher adding dispatcher with property: %s
___ZN14CLDeviceMotion28removeDeviceMotionDispatcherEPN16CLMotionNotifier10DispatcherE_block_invoke
CoreLocation: CLDeviceMotion::removeDeviceMotionDispatcher removing dispatcher with property: %s
virtual CFTimeInterval CLDeviceMotion::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CoreLocation: CLDeviceMotion::minimumUpdateIntervalChanged,notification,%d,minimumUpdateInterval,%f
virtual void CLDeviceMotion::numberOfClientsChanged(int, size_t, size_t)
CoreLocation: CLDeviceMotion::numberOfClientsChanged notification:%d, from:%zu, to:%zu
CoreLocation: numberOfClients GyroOnly:%zd, 3AxisDynamicGyro:%zd, 6Axis:%zd, 6AxisThrottledGyro:%zd, 9Axis:%zd, 9AxisWithNorthReference:%zd, BuildGYTT:%zd
CoreLocation: Device motion mode not supported: %d
bool CLDeviceMotion::isModeValid(const CLMotionTypeDeviceMotionMode &) const
CoreLocation: Unsupported mode (%d). Returning.
CoreLocation: Unsupported mode (%d). Compass not found. Returning.
CoreLocation: Unsupported mode (%d). Couldn't do DeviceMotion without Gyro. Returning.
void CLDeviceMotion::enableSensorFusionWithMode(const CLMotionTypeDeviceMotionMode &)
CoreLocation: Starting device motion, mode=0x%x,useAccelerometer=%d,useGyro=%d,useCompass=%d,fUseNorthRef=%d,buildingGYTT=%d
void CLDeviceMotion::disableSensorFusionWithMode(const CLMotionTypeDeviceMotionMode &)
CoreLocation: Stopping device motion, mode=0x%x
BinaryLogDirectory
static void CLBinaryLog::create()
CoreLocation: creating the BinaryLog instance
CoreLocation: creating fInstance = new CLBinaryLog()
CLBinaryLog::CLBinaryLog()
CoreLocation: kCLBinaryLogDirectory not set!
kCLBinaryLogDirectory not set!
CoreLocation: Logging binary sensor data to %s
com.apple.locationd.binlog.compression
STATUS,SENSOR,Time,%.3lf,Type,AccelOscarEmu,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,AccelGesture,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,GyroOscarEmu,x,%20.20f,y,%20.20f,z,%20.20f,sampleNum,%d,fsync,%d,timestamp,%20.20lf
void CLBinaryLog::rotateIfNeeded(const double &)
CoreLocation: Failed to determine if log rotation is needed. errno, %d, %s
Failed to determine if log rotation is needed. errno, %d, %s
CoreLocation: Failed to move aside log file %s to %s (%d)
%s,%s,Failed to delete log: %s
void CLBinaryLog::open()
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Shared/Logging/CLBinaryLog.mm
CoreLocation: Unable to open %s
void CLBinaryLog::close()
STATUS,SENSOR,Time,%.3lf,Type,Accelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
AccelGps,Time,%.4lf,timestamp,%.4f,x,%.12g,y,%.12g,z,%.12g
AccelBatch,Time,%.4lf,timestamp,%.4f,batch,%d,x,%.12g,y,%.12g,z,%.12g
STATUS,SENSOR,Time,%.3lf,Type,Gyro,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d
GyroGps,Time,%.4lf,timestamp,%.4f,x,%.12g,y,%.12g,z,%.12g
STATUS,SENSOR,Time,%.3lf,Type,GyroTemperature,temperature,%f
STATUS,SENSOR,Time,%.3lf,Type,GyroBias,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
STATUS,SENSOR,Time,%.3lf,Type,GyroBiasFit,slope.x,%20.20f,slope.y,%20.20f,slope.z,%20.20f,intercept.x,%20.20f,intercept.y,%20.20f,intercept.z,%20.20f, lastMiniCal,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,GyroDt,dt,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,Magnetometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,Compass,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,CompassAlignment,compassJustAlignedToStableField,%d,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,CLDeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,timestamp,%20.20f,doingBiasEstimation,%d,doingYawCorrection,%d
STATUS,SENSOR,Time,%.3lf,Type,MotionStateUpdate,motionStateUpdate:Motion,%d,conf,%d,Mounted,%d,MountedConf,%d,exitState,%d,turn,%d,isVehicular,%d,isMoving,%d,seq,%d,startTime,%f,timestamp,%f,startTimeUL,%llu,nowUL,%llu -- caltype,%d,vm,%f,standing,%d,machinefrequency,%f,strokefrequency,%f,strokeAmplitude,%f,strokepower,%f
STATUS,SENSOR,Time,%.3lf,Type,Pressure,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,PressureGps,pressure,%.6f,temperature,%.6f,timestamp,%.6lf
STATUS,SENSOR,Time,%.3lf,Type,PressureOscarEmu,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,PressureFiltered,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,Prox,DetectionMask,%d,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,TouchOscarEmu,touchDetected,%d,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,GyroCompass,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,calibrated.x,%.8f,.y,%.8f,.z,%.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1f,level,%d,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,CompassCalibration,bias.x,%.8f,.y,%.8f,.z,%.8f,scale.x,%.8f,.y,%.8f,.z,%.8f,quality,%.8f,cost,%.8f,coverage,%.8f,earthDiffRatio,%.8f,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,BTConnection,startTime,%.3lf,endTime,%.3lf,connected,%d
STATUS,SENSOR,Time,%.3lf,Type,SessionOverride,sessionType,%d,timestamp,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,LocationOscarEmu,locationType,%d,speed,%.3lf,speedAccuracy,%.3lf,latitude,%.7lf,longitude,%.7lf,horizontalAccuracy,%.3lf,altitude,%.3lf,verticalAccuracy,%.3lf,course,%.3lf,courseAccuracy,%.3lf,confidence,%d,locationLoggingEnabled,%d,timestamp,%.3lf
MenuButton
PowerButton
ChargerConnect
DeviceAwake
InActiveCall
DisplayOn
LockscreenOn
PocketQuery
WakePower
WakeMenu
WLAN
Baseband
Sleep
STATUS,SENSOR,Time,%.lf,Type,GestureHint,event,%d,eventDescription,%s,value,%d,valueDescription,%s
STATUS,SENSOR,Time,%.lf,Type,GestureHint,event,%d,eventDescription,%s,value,%d
STATUS,SENSOR,Time,%.3lf,Type,CLDeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,timestamp,%20.20f,doingBiasEstimation,%d,doingYawCorrection,%d,type,%d
fits,
slope.x,%f,slope.y,%f,slope.z,%f,intercept.x,%f,intercept.y,%f,intercept.z,%f,
temperatures,%f,%f,%f,%f,%f,%f,%f,overlap,%f,error,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d
STATUS,SENSOR,Time,%.3lf,Type,CLNonlinearGyroBiasFit,fits,%s
%s,%s,Failed to write CLBinaryLog Buffer to disk
%s,%s,Failed to move file %s to %s (%d)
.bin
CoreMotionSensors
logs
LogFileRotationSizeBinary
LogFileStorageCountBinary
CMSetPocketStateNotification
CMSetPocketStateTypeKey
com.apple.CoreMotion.CMPocketStatePrivateQueue
+[CMPocketStateManager isPocketStateAvailable]
CoreLocation: Pocket state disabled by defaults write
-[CMPocketStateManager _disableDispatcher]
CoreLocation: disabling dispatcher
com.apple.CoreMotion.CMPocketStateManager.%@.%@
__58-[CMPocketStateManager addToAggdScalarWithName:andScalar:]_block_invoke
CoreLocation: ADClient: %s + %llu
-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]
CoreLocation: QueryRequest,%f
__81-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke
CoreLocation: %f: query started with timeout %f
queryStart
CoreLocation: Query aborted
queryAbort
__81-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke_2
CoreLocation: QueryTimerFire,%f
queryTimerFire
queryResponse.%@
CoreLocation: %f: query response external=%u (%s), cbcount=%lu
CoreLocation: timer fired even though fQueryTimer is NULL
CoreLocation: Attempted to exceed max monitor time %f, %f
CoreLocation: Query timer failed to initialize
queryTimerFail
__39-[CMPocketStateManager onNotification:]_block_invoke
CoreLocation: The pocket state %d is not in bounds
T@"<CMPocketStateDelegate>",N,V_delegate
com.apple.CoreMotion.PocketState.queryStart
%@,<liftTransition %lu date %@>
liftTransition
kCMLiftMotionCodingKeyLiftDate
kCMLiftMotionCodingKeyLiftTransition
double CLDistanceCalc::calculateDistance(const CLDaemonLocation &, const CLDaemonLocation &)
CoreLocation: refAlt < %.1lf,refAlt,%.1lf,using the min
CoreLocation: refAlt > %.1lf,refAlt,%.1lf,using the max
bool CLDistanceCalc::calc_dNdE(double, double, double &, double &)
CoreLocation: latitude,%.7lf,is out of bounds
latitude,%.7lf,is out of bounds
LogDeviceOrientation
CLOrientationNotifier
SBHasSeenACaseLatchCoverOnce
com.apple.springboard.HasSeenACaseLatchCoverNotification
CLOrientationNotifier::CLOrientationNotifier()
CoreLocation: Registering for SBHasSeenACaseLatchCoverNotification.
virtual void CLOrientationNotifier::numberOfSpectatorsChanged(int, size_t)
CoreLocation: Unrecognized notification
void CLOrientationNotifier::startDetection(bool)
CoreLocation: hwType, %d
CoreLocation: Unknown iPad HW %d
CoreLocation: isPad %d
CoreLocation: forceAccelOnly for device %d
OrientationGyroTimeout
OrientationStableVariance
CoreLocation: fOrientationGyroTimeout,%f,fEnableGyroTimeout,%d,fMaxAccelerationVarianceForStability,%f
OrientationAccelDecimation
CoreLocation: Not starting orientation detection since requested accelerometer frequency < 0
CoreLocation: No accelerometer; not detecting orientation!
CoreLocation: No gyro; not detecting orientation!
CoreLocation: fHasSeenACaseLatchCoverOnce, %d
CoreLocation: Starting orientation detection with accelFrequency %f, isIpad, %d, decimationRate, %d
void CLOrientationNotifier::stopDetection()
CoreLocation: Stopping orientation detection.
static void CLOrientationNotifier::onAccelerometerData(const CLAccelerometer::Sample *, void *)
CoreLocation: Sending orientation changed notification
CoreLocation: Device is in motion, re-enabling Gyro.
CoreLocation: Device is stationary and OrientationGyroTimeout exceeded, disabling Gyro.
static void CLOrientationNotifier::onGyroData(const CLGyro::Sample *, void *)
CoreLocation: GYRO: Sending orientation changed notification
void CLOrientationNotifier::onNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
CLOrientationDetector::CLOrientationDetector(CLOrientationDetector::FormFactor, bool)
CoreLocation: gyroFrequency,%.3f,gyroBufferSize,%d,gyroMeanBufferSize,%d,zRotBufferSize,%d,minRequiredZrots,%d
CoreLocation: accelBufferSize,%d
CoreLocation: fMinVarPerAxisForMoving,%.3f,fMinDeltaSquaredMagnitudeForMoving,%.3f,fMinVarPerAxisForMovingRelaxed,%.3f
void CLOrientationDetector::addAccSample(const CLMotionTypeAcceleration &, const CFAbsoluteTime &)
CoreLocation: Accelerometer samples data gap or out of order! deltaInterval=%.4f
CoreLocation: accel, %.3f, %.3f, %.3f, timestamp, %.20f
void CLOrientationDetector::addGyroSample(const CLMotionTypeRotationRate &, const CFAbsoluteTime &)
CoreLocation: Gyro samples data gap or out of order! deltaInterval=%.4f
CoreLocation: gyro, %.3f, %.3f, %.3f, gyroMean, %.3f, %.3f, %.3f, fLastDetection,%d,fStartZrot,%d
CoreLocation: gyro, %.3f, %.3f, %.3f, timestamp, %.20f
void CLOrientationDetector::fillZRotBuffer(const CLMotionTypeRotationRate &, const CLVector3d<float> &)
CoreLocation: zRot (%.3f, %.3f, %.3f), mean(%.3f, %.3f, %.3f), var(%.3f, %.3f, %.3f)
void CLOrientationDetector::updateZRotationStatus(float, float, float, const CLVector3d<float> &, const CLVector3d<float> &)
CoreLocation: mostlyZ, %d, zRotMean.z, %.3f, zRot, %.3f, numSamples, %d, numZRots, %d, estCurr, %.3f
CoreLocation: Slowing decrement numZRot,delta, %.3f, numZRot, %d
CoreLocation: ZDROP detected. deltaDrop, %.3f, fNumZDrops, %d
CoreLocation: TRANSIENT!
CoreLocation: Going through with 180 turn.
CoreLocation: Rotating around Z. numSamples: %d, numAccu, %d, zRotVar, %.3f
void CLOrientationDetector::checkForRotation()
CoreLocation: SCREEN FLAT. NOT FILLING UP ZROT BUFFER.
CoreLocation: EST Z ANGLE, %.2f, numAccu, %d
CoreLocation: Transient!
CoreLocation: Rotating! Current max gyro rate %.3f
void CLOrientationDetector::updateLastPrimaryOrientationForZStats(float, float)
CoreLocation: Setting lastPrimaryOrientation.
void CLOrientationDetector::nixRotationAroundZIfNecessary(float, float, float)
CoreLocation: Nixed rotationAroundZ state.
void CLOrientationDetector::setUpForOrienationChangeViaRotation(CLVector3d<float> &)
CoreLocation: Ready for orientation change via rotation
void CLOrientationDetector::updateStableCountWithGyro(bool &, float, float)
CoreLocation: Gyro var, %.3f, %.3f,%.3f, maxGyroVar, %.3f, mean, %.3f, %.3f, %.3f
CoreLocation: gyroMeanMag %.3f
void CLOrientationDetector::resetZStatsWhenNecessary(float, float)
CoreLocation: Not filling Zrot buffer.
float CLOrientationDetector::getAccStats(CLVector3d<float> &, float &)
CoreLocation: acc variance, %.3f, %.3f, %.3f, acc mean, %.3f, %.3f, %.3f, maxVar, %.3f, mag2,%.3f
bool CLOrientationDetector::deviceIsMoving(const CLVector3d<float> &, float, float)
CoreLocation: Resetting stable count
static bool CLOrientationDetector::withinMagicAngleLimits(CLOrientationDetector::FormFactor, bool, float)
CoreLocation: Within magic angle limits: Threshold %.4f, Delta %.4f
bool CLOrientationDetector::atMagicCoverRestingAngle(const float *, float, float, float)
CoreLocation: Ipad %d: screenJustTurnedOn, %d, deltaTime %.5f
CoreLocation: allowShallow, %d, magicCaseRest, %d, tiltIn, %d, wasMoving, %d, maxVar, %.5f
void CLOrientationDetector::calcCurrentOrientation()
CoreLocation: onStartup, x, %.3f, y, %.3f, z, %.3f
CoreLocation: FaceUp/Down: maxWeight,%.3f, 2ndWeight,%.3f, orientation,%d
CoreLocation: deltaWeightThreshold, %.3f, tiltWeightTheshold, %.3f, currAcc, %.3f, %.3f, %.3f, deltaWeight, %.3f, tilt, %.3f, fCurrentOrientation, %d, isMoving, %d, wasMoving, %d, fLastClearOrientation, %d, fStableCount, %d, fLastDetectionTime, %f
bool CLOrientationDetector::calcOrientation(CMDeviceOrientationType &, CLMotionTypeTimestamp &)
CoreLocation: Notify from, %s -> %s 
void CLOrientationDetector::disableGyro()
CoreLocation: Disabling gyro.
void CLOrientationDetector::enableGyro()
CoreLocation: Enabling gyro.
Ambiguous
Portrait
PortraitUpsideDown
LandscapeLeft
LandscapeRight
FaceUp
Unexpected
com.apple.CoreMotion.CMCatherineFeeder.internal
__51-[CMCatherineFeederInternal _startDaemonConnection]_block_invoke
kCLConnectionMessageCatherineDataKey
kCLConnectionMessageCatherineData
internal
T@"CMCatherineFeederInternal",R,N,V_internal
void CLMagnetometerCoexistenceNotifierCpasV11::chooseOffsetData()
LogFileRotationSize
LogFileStorageCount
CLLogBase
yyyy-MM-dd_HH-mm-ss
/Library/Logs/CrashReporter
Library
Caches
Logs
CrashReporter
move
%s,%s,could not %s log file %s to %s
%s,%s,could not stat %s
%s,%s,failed to open %s
LogDumpOnUnload
LogDumpOnLoad
CLGyroCalibrationDatabaseLocalBase
CLGyroCalibrationDatabaseRemote
virtual bool CLGyroCalibrationDatabase::getGyroStats(CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, bool)
CoreLocation: Warning: Not implemented.
virtual int CLGyroCalibrationDatabase::getMaxDynamicTemperature()
void CMPressureFilter::update(const CMPressureSample &)
CoreLocation: Type,%s,Time,%llu,RawPressure,%f,FilteredPressureTimeStamp,%llu,FilteredPressure,%f,RawPressurePeriod,%f,StateFOF,%d,StateFIR,%d
CMPressureFilter::update
void CMPressureFilter::updateFIR(const CMPressureSample &)
CoreLocation: CMPressureFilter,Time,%llu,FastPressureRate,%f,PressureDecimation,%d,PressureFilterOffset,%d,PressureFilterDelay,%d
const T &CMQueue<float>::operator[](const size_t) const [T = float]
CoreLocation: Assertion failed: i < fCapacity, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/CMQueue.h, line 174,i,%zu,capacity,%u.
Assertion failed: i < fCapacity, file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/CMQueue.h, line 174,i,%zu,capacity,%u.
SampleType CMSymmetricFirFilter<float>::batchFilter(const CMQueue<SampleType> &, int) const [T = float, SampleType = float]
CoreLocation: Assertion failed: (offset >= 0) && (offset + fFullTapCount - 1 < samples.size()), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/CMSymmetricFirFilter.h, line 37,offset,%d,fullTapCount,%d,samplesSize,%zu.
Assertion failed: (offset >= 0) && (offset + fFullTapCount - 1 < samples.size()), file /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Oscar/CMSymmetricFirFilter.h, line 37,offset,%d,fullTapCount,%d,samplesSize,%zu.
v32@?0@"NSString"8@16^B24
CoreMotion
com.apple.CoreMotion.CMMotionUtils.MessageQueue
+[CMMotionUtils sendMessageWithReplySync:]
CoreLocation: Timeout (after 5 seconds) occurred during wait!
Timeout (after 5 seconds) occurred during wait!
com.apple.locationd.activity
+[CMMotionUtils tccServiceMotionAccessWithLabel:]
CoreLocation: Warning - invoking %@ on main may lead to deadlock.
v12@?0C8
__49+[CMMotionUtils tccServiceMotionAccessWithLabel:]_block_invoke
CoreLocation: TCCServiceMotionAccess timeouts!
TCCServiceMotionAccess timeouts!
com.apple.CoreMotion.tcc
__49+[CMMotionUtils tccServiceMotionAccessWithBlock:]_block_invoke
CoreMotion.log
+[CMMotionUtils featureAvailability:]
com.apple.CoreMotion.CMActivityAlarmProxyPrivateQueue
kCLConnectionMessageActivityAlarmStart
__28-[CMActivityAlarmProxy init]_block_invoke
CoreLocation: Did not find the triggered activity alarm in the current set of alarms.
CoreLocation: Could not get dictionary for kCLConnectionMessageActivityAlarm
Could not get dictionary for kCLConnectionMessageActivityAlarm
kCLConnectionMessageActivityAlarmAvailable
__28-[CMActivityAlarmProxy init]_block_invoke.43
-[CMActivityAlarmProxy listenForActivityAlarm:]
CoreLocation: Was not able to listen for alarm.  Activity alarms are not available for this sytem.
-[CMActivityAlarmProxy stopListeningForActivityAlarm:]
CoreLocation: Cannot unsubscribe from activity alarm (Trigger:%d, Duration:%f).  This alarm is not being listened for.
kCLConnectionMessageVehicleConnectionMostRecent
kCMVehicleConnectionDataCodingKeyStartDate
kCMVehicleConnectionDataCodingKeyEndDate
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMActivityAlarm.mm
trigger < kActivityAlarmTriggerCount
-[CMActivityAlarm initWithTrigger:duration:onQueue:withHandler:]
CoreLocation: Unable to create sharedInstance of CMActivityAlarmProxy.
Unable to create sharedInstance of CMActivityAlarmProxy.
-[CMActivityAlarm initWithTrigger:duration:onRunLoop:withHandler:]
Td,N,V_duration
trigger
TI,N,V_trigger
CLPowerStateService
CMStepCounterQueue
__26-[CMStepCounterProxy init]_block_invoke
CoreLocation: Failed with CMError code %d
Failed with CMError code %d
__76-[CMStepCounterProxy _startStepCountingUpdatesToQueue:updateOn:withHandler:]_block_invoke
CoreLocation: Unable to parse mesage (%s) when starting updates to queue
Unable to parse mesage (%s) when starting updates to queue
-[CMStepCounterProxy _handleQueryResponse:onQueue:withHandler:]
CoreLocation: Unable to parse mesage (%s) for query response
Unable to parse mesage (%s) for query response
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMStepCounter.mm
__70-[CMStepCounter startStepCountingUpdatesToQueue:updateOn:withHandler:]_block_invoke
CoreLocation: Unable to start additional step updates while it is already active
Unable to start additional step updates while it is already active
__40-[CMStepCounter stopStepCountingUpdates]_block_invoke
CoreLocation: Unable to stop step updates as we are are not receiving updates
Unable to stop step updates as we are are not receiving updates
kCLConnectionMessageStepCountReset
stepcounterProxy
T@"CMStepCounterProxy",R,N,V_stepcounterProxy
enabled
CLSensorFusionService::CLSensorFusionService(int)
CoreLocation: Starting device motion service 0x%x
DeviceMotionUseThrottledInterval
DeviceMotionAccelerometerUpdateInterval
DeviceMotionGyroUpdateInterval
DeviceMotionCompassUpdateInterval
CoreLocation: Type,%s,dt,%20.20f
CoreLocation: Type,%s,interval,%f
DumpGyroCalibrationDatabaseOnDeviceMotionStart
v16@?0^{CLGyroCalibrationDatabase=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}8
virtual CLSensorFusionService::~CLSensorFusionService()
CoreLocation: Stopping device motion service 0x%x
void CLSensorFusionService::publishSensorFusion(const CLSensorFusionService::Sample *)
CoreLocation: Type,%s,q.x,%10.10f,q.y,%10.10f,q.z,%10.10f,q.w,%10.10f,userAccel.x,%10.10f,userAccel.y,%10.10f,userAccel.z,%10.10f,rotationRate.x,%10.10f,rotationRate.y,%10.10f,rotationRate.z,%10.10f,magneticField.x,%10.10f,magneticField.y,%10.10f,magneticField.z,%10.10f,magneticFieldCalibrationLevel,%d,timestamp,%20.20f,doingBiasEstimation,%d,doingYawCorrection,%d
void CLSensorFusionService::updateSensorStatus(const CLSensorFusionService::SensorStatus &)
CoreLocation: Set device motion sensor status %ld
%@ <Gravity (%f %f %f) UserAcceleration (%f %f %f) Tip %f Tilt %f MachTimestamp %llu PhysicalDeviceUniqueID %@>
%@ <Quaternion (%f %f %f %f) RotationRate (%f %f %f) RawAcceleration (%f %f %f) RawRotationRate (%f %f %f) MachTimestamp %llu PhysicalDeviceUniqueID %@>
T@"CMAttitude",R,N,VfAttitude
T{?=ddd},R,N,VfRotationRate
rawAcceleration
T{?=ddd},R,N,VfRawAcceleration
rawRotationRate
T{?=ddd},R,N,VfRawRotationRate
machTimestamp
TQ,R,N,VfMachTimestamp
T{?=ddd},R,N,VfGravity
T{?=ddd},R,N,VfUserAcceleration
Tf,R,N
tilt
physicalDeviceUniqueID
T@"NSString",R,&,N,VfPhysicalDeviceUniqueID
kCMDeviceMotionLiteCodingKeyQuaternionW
kCMDeviceMotionLiteCodingKeyQuaternionX
kCMDeviceMotionLiteCodingKeyQuaternionY
kCMDeviceMotionLiteCodingKeyQuaternionZ
kCMDeviceMotionLiteCodingKeyUserAccelerationX
kCMDeviceMotionLiteCodingKeyUserAccelerationY
kCMDeviceMotionLiteCodingKeyUserAccelerationZ
kCMDeviceMotionLiteCodingKeyRotationRateX
kCMDeviceMotionLiteCodingKeyRotationRateY
kCMDeviceMotionLiteCodingKeyRotationRateZ
kCMDeviceMotionLiteCodingKeyRawAccelerationX
kCMDeviceMotionLiteCodingKeyRawAccelerationY
kCMDeviceMotionLiteCodingKeyRawAccelerationZ
kCMDeviceMotionLiteCodingKeyRawRotationRateX
kCMDeviceMotionLiteCodingKeyRawRotationRateY
kCMDeviceMotionLiteCodingKeyRawRotationRateZ
kCMDeviceMotionLiteCodingKeyMachTimestamp
kCMDeviceMotionLiteCodingKeyPhysicalDeviceUniqueID
CLSilo: %@
-[CLSilo assertInside]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Intersilo/CLSilo.m
-[CLSilo assertOutside]
-[CLSilo newTimer]
-[CLSilo async:]
-[CLSilo sync:]
-[CLSilo afterInterval:async:]
T@"NSString",R,N,V_identifier
-[CLDispatchTimerScheduler reflectNextFireTime:fireInterval:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Intersilo/CLDispatchSilo.m
_source
timer
T@"CLTimer",W,N
source
T@"NSObject<OS_dispatch_source>",&,N,V_source
T@"CLTimer",W,N,Vtimer
MainSilo
%@.NSOperationQueue
CLDispatchSilo: %s
-[CLTimer shouldFire]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Intersilo/CLTimer.m
T@?,C,N,V_handler
nextFireTime
Td,N,V_nextFireTime
fireInterval
Td,N,V_fireInterval
-[CLIntersiloInterfaceSelectorInfo initWithSelector:andMethodSignature:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Intersilo/CLIntersiloInterface.mm
syncget
withReply:
T:,R,N,V_sel
numArguments
Ti,R,N,V_numArguments
replyBlockIndex
Ti,R,N,V_replyBlockIndex
returnAddressIndex
Ti,R,N,V_returnAddressIndex
returnValueSize
Ti,R,N,V_returnValueSize
T@"NSMethodSignature",R,&,N,V_sig
T@"NSString",R,&,N,V_str
Protocol: %p
Name: %s
Selectors: (
protocol
T@"Protocol",R,N,V_protocol
___ZN23CLSensorFusionServiceAP17onBiasAndVarianceE31CLMotionTypeGyroBiasAndVariance_block_invoke
com.apple.CoreMotion.CMAltimeterInternalQueue
com.apple.CoreMotion.CMAltimeterAppQueue
kCLConnectionMessageSignificantElevationUpdate
__27-[CMAltimeterInternal init]_block_invoke
CoreLocation: Unable to parse message (%s) when starting updates to queue
Unable to parse message (%s) when starting updates to queue
CoreLocation: Unable to parse message when starting updates to queue!
Unable to parse message when starting updates to queue!
kCLConnectionMessageSignificantElevationDeltaQuery
__83-[CMAltimeterInternal _querySignificantElevationChangeFromDate:toDate:withHandler:]_block_invoke_2
CoreLocation: Unable to parse message (%s) for query response
Unable to parse message (%s) for query response
CoreLocation: Unable to parse message when checking for availability!
Unable to parse message when checking for availability!
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMAltimeter.mm
fromDate
toDate
-[CMAltimeter onFilteredPressure:]
CoreLocation: relativeAltitude,%f,pressure,%f
T@"CMAltimeterInternal",R,N,V_internal
com.apple.CoreMotion.CMSwimTracker
__29-[CMSwimTrackerInternal init]_block_invoke
__29-[CMSwimTrackerInternal init]_block_invoke_2
CoreLocation: CMSwimTracker client connection interrupt, %@, %d, %d, %p
00000000-0000-0000-0000-000000000000
kCLConnectionMessageSwimDataQuery
kCLConnectionMessageSwimDataUpdate
__37-[CMSwimTrackerInternal _stopUpdates]_block_invoke
CoreLocation: Unable to stop swim data updates as we are are not receiving updates.
Unable to stop swim data updates as we are are not receiving updates.
__61-[CMSwimTrackerInternal _querySwimUpdatesFromRecord:handler:]_block_invoke_2
CoreLocation: Unable to parse kCLConnectionMessageSwimDataQuery message.
Unable to parse kCLConnectionMessageSwimDataQuery message.
-[CMSwimTrackerInternal _handleUpdates:]
CoreLocation: Unable to parse kCLConnectionMessageSwimDataUpdate message.
Unable to parse kCLConnectionMessageSwimDataUpdate message.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMSwimTracker.mm
T@"CMSwimTrackerInternal",R,N,V_internal
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMSwimData.mm
sourceId && sessionId && startDate && endDate && strokeType < kCMSwimStrokeTypeMax
Freestyle
Backstroke
Breaststroke
Butterfly
Mixed
%@, <sessionId %@, startDate %@, endDate %@, strokeCount %lu, distance %.2f, avgPace %.2f, lapCount %lu, strokeType %@>
strokeCount
avgPace
lapCount
strokeType
kCMSwimDataCodingKeyRecordId
kCMSwimDataCodingKeySourceId
kCMSwimDataCodingKeySessionId
kCMSwimDataCodingKeyStartDate
kCMSwimDataCodingKeyEndDate
kCMSwimDataCodingKeyStrokeCount
kCMSwimDataCodingKeyDistance
kCMSwimDataCodingKeyAvgPace
kCMSwimDataCodingKeyLapCount
kCMSwimDataCodingKeyStrokeType
+[CLIntersiloProxy proxyForRecipientObject:inSilo:withInboundInterface:andOutboundInterface:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Intersilo/CLIntersiloProxy.m
-[CLIntersiloProxy forwardInvocation:]
CLService: Block was not compiled using a compiler that inserts type information about arguments. (%@)
v16@?0@"NSInvocation"8
-[CLIntersiloProxy registerDelegate:inSilo:]
<%@: peer silo:%@, peer tag:%lu>
-[CLIntersiloProxy setOpaqueTag:]
T@"<CLIntersiloProxyDelegateProtocol>",R,W,N,V_delegate
delegateSilo
T@"CLSilo",R,W,N,V_delegateSilo
delegateInterface
T@"CLIntersiloInterface",R,C,N,V_delegateInterface
proxiedInterface
T@"CLIntersiloInterface",R,C,N,V_proxiedInterface
result %d confidence %d timestamp %f
result
kCMOnBodyStatusResult
kCMOnBodyStatusConfidence
+[CLIntersiloService getSilo]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Intersilo/CLIntersiloService.m
+[CLIntersiloService becameFatallyBlocked:]
+[CLIntersiloService performSyncOnSilo:invoker:]
-[CLIntersiloService init]
-[CLIntersiloService initInSilo:]
-[CLIntersiloService initWithInboundProtocol:outboundProtocol:andSilo:]
Silo: %@
Inbound: %@
Outbound: %@
silo
T@"CLSilo",R,N,V_silo
inboundInterface
T@"CLIntersiloInterface",R,N,V_inboundInterface
outboundInterface
T@"CLIntersiloInterface",R,N,V_outboundInterface
TB,N,V_valid
__37+[CMWakeGestureManager sharedManager]_block_invoke
CoreLocation: Watch: Gesture Manager Active
CoreLocation: Phone: Gesture Manager Active
CoreLocation: CMWakeGestureManager is not supported on this platform!
-[CMWakeGestureManager logAssert]
CoreLocation: Calling methods directly on an instance of CMWakeGestureManager is not permitted. Please use +[CMWakeGestureManager sharedManager] instead.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMWakeGestureManager.mm
false
T@"<CMWakeGestureDelegate>",N,V_delegate
-[CLServiceVendorHeartbeatRecord initTrackingService:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Intersilo/CLServiceVendor.mm
service
T@"<CLIntersiloServiceProtocol>",R,W,N,V_service
synCount
Ti,R,N,V_synCount
ackCount
Ti,R,N,V_ackCount
+[_Locationd becameFatallyBlocked:]
+[_Locationd performSyncOnSilo:invoker:]
___Z20validateTrackedSilosv_block_invoke
v32@?0@"CLSilo"8@"CLServiceVendorHeartbeatRecord"16^B24
HeartAttack
q24@?0@8@16
CLServiceVendorQueue
_CLMainService
CLServiceVendor.HeartbeatCheckInterval
Adapter
+[CLServiceVendor getServiceWithName:]
CoreLocation: Tried to look up a service by name that doesn't exist: %{public}@.
CLGestureService
virtual void CLGestureService::numberOfSpectatorsChanged(int, size_t)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Shared/Motion/Notifiers/CLGestureService.mm
void CLGestureService::onGestureService(const uint8_t *, size_t, const CFTimeInterval &)
CoreLocation: numberOfSpectators,%zi
CoreLocation: Undecodable data.,size,%zu,type,%u
com.apple.CoreMotion.CMOnBodyStatusManagerPrivateQueue
kCLConnectionMessageOnBodyDetectionParams
kCLConnectionMessageOnBodyDetection
__32-[CMOnBodyStatusManager connect]_block_invoke
__32-[CMOnBodyStatusManager connect]_block_invoke.55
-[CMOnBodyStatusManager startOnBodyStatusDetectionPrivateToQueue:withParameters:handler:]
CoreLocation: Neither the queue nor the handler can be nil
Neither the queue nor the handler can be nil
data
T^v,N,V_data
destructor
T@?,C,N,V_destructor
virtual void CLSensorFusionService3AxisDynamicGyro::start()
CoreLocation: %s is enabling power conservative device motion for parallax.
virtual void CLSensorFusionService3AxisDynamicGyro::stop()
CoreLocation: %s is disabling power conservation for parallax.
___ZN37CLSensorFusionService3AxisDynamicGyro19onAccelerometerDataEPKN15CLAccelerometer6SampleE_block_invoke_3
CoreLocation: Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.
___ZN37CLSensorFusionService3AxisDynamicGyro17onBiasAndVarianceE31CLMotionTypeGyroBiasAndVariance_block_invoke
-[CLNotifierClientAdapter init]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Utilities/CLNotifierClientAdapter.mm
-[CLNotifierClientAdapter onNotification:withData:]
CLNotifierClientBase: %p
-[CLNotifierServiceAdapter setAdaptedNotifier:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Daemon/Utilities/CLNotifierServiceAdapter.mm
-[CLNotifierServiceAdapter notifierClientNumForCoparty:]
ClientIntegerMap: (
%p = %d
notifier
T^{CLNotifierBase=^^?},R,N,V_notifier
com.apple.CoreMotion.CMWorkoutManager
__32-[CMWorkoutManagerInternal init]_block_invoke.6
CoreLocation: CMWorkoutManager client connection interrupt, %@, %d, %d, %p
kCLConnectionMessageWorkoutEvent
-[CMWorkoutManagerInternal _startWorkout:]
CoreLocation: Starting workout, %@, %d, %p, %ld
CoreLocation: starting swim workout, location, %ld, pool length %f
CoreLocation: Trying to start a swim session without using a CMSwimWorkout!  Treating this swim as an open water swim.
kCLConnectionMessageWorkoutStart
-[CMWorkoutManagerInternal _stopWorkout:]
CoreLocation: Stopping workout, %@, %d, %p, %ld
kCLConnectionMessageWorkoutStop
-[CMWorkoutManagerInternal _handleDaemonResponse:]
CoreLocation: nil workout event dictionary received, %s
CoreLocation: Workout ERROR, %d, %s
-[CMWorkoutManagerInternal _handleDaemonEvent:]
CoreLocation: Workout DID START at %f, %s
CoreLocation: Workout DID STOP at %f, %s
CoreLocation: Workout WILL PAUSE at %f, %s
CoreLocation: Workout WILL RESUME at %f, %s
CoreLocation: Unrecognized workout event, %ld, %s
CoreLocation: Unrecognizable workout event dictionary, %s
/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-2100.0.12/Framework/CoreMotion/CMWorkoutManager.mm
workout
T@"CMWorkoutManagerInternal",R,N,V_internal
T@"<CMWorkoutManagerDelegate>",N
CMSedentaryTimer_Internal
CMSedentaryTimer
CMMotionActivityManager
CMNatalieData
CMAccelerometerDataInternal
NSCopying
CMAccelerometerData
CMAltitudeDataInternal
CMAltitudeData
CMSignificantElevationSample
NSSecureCoding
NSCoding
CMVehicleStateData
CMVehicleState
CMWorkout
CMSwimWorkout
CMDeviceMotionInternal
CMDeviceMotion
CMAttitudeInternal
CMAttitude
CMAmbientPressureDataInternal
CMAmbientPressureData
CMRecordedAccelerometerData
CMSensorDataList
NSFastEnumeration
CMSensorRecorderInternal
CMSensorRecorder
CMLogItemInternal
CMLogItem
CMWakeGesturePhone
CMOdometerProxy
CMOdometer
CMExerciseMinuteData
CMGyroDataInternal
CMGyroData
CLGyroCalibrationDatabaseRemoteProtocol
CLNotifierServiceProtocol
CLIntersiloServiceProtocol
CLIntersiloProxyDelegateProtocol
NSObject
CLGyroCalibrationDatabaseRemoteClientProtocol
CLNotifierServiceClientProtocol
CLIntersiloClientProtocol
CLGyroCalibrationDatabaseRemoteAdapter
IsSupported
CMCatherineData
CMMotionTimeRange
CMCalorieUserInfo
CMSedentaryTimerData
CMExerciseMinuteInternal
CMExerciseMinute
CMLiftManagerInternal
CMLiftManager
CMNatalimeterInternal
CMNatalimeter
CMMagnetometerDataInternal
CMMagnetometerData
CMMotionManagerInternal
CMMotionManager
CMElevationData
CMActivity
CMGestureManagerInternal
CMGestureManager
CMActivityManagerInternal
CMActivityManager
CMPedometerProxy
CMPedometer
CLCompassDatabaseClientProtocol
CLCompassDatabaseClientClientProtocol
CLCompassDatabaseClientAdapter
CMWakeGestureWatch
CLJsonLogging
DeviceMotionLite
CLGeomagneticModelProviderClientProtocol
CLGeomagneticModelProviderClientClientProtocol
CLGeomagneticModelProviderClientAdapter
CMOdometerData
CLSensorRecorderAccelMeta
CLSensorRecorderAccelMetaRequestById
CLSensorRecorderAccelMetaRequestByDateRange
CLSensorRecorderAccelDataRequestById
CLSensorRecorderAccelRecordFor
CMMotionActivity
CMPedometerData
CMPedometerEvent
CMDeviceOrientation
CMDeviceOrientationManagerInternal
CMDeviceOrientationManager
CLDeviceMotionProperties
CMPocketStateQueueBlockPair
CMPocketStateManager
CMLiftMotion
CMCatherineFeederInternal
CMCatherineFeeder
CMMotionUtils
CMActivityAlarmProxy
CMVehicleConnectionData
CMVehicleConnection
CMActivityAlarm
CMStepCounterProxy
CMStepCounter
CMDeviceMotionLite
CLSilo
CLDispatchTimerScheduler
CLTimerScheduler
CLDispatchSilo
MainSilo
CLTimer
CLExtensions
CLIntersiloInterfaceSelectorInfo
CLIntersiloInterface
CMAltimeterInternal
CMAltimeter
CMElevation
CMSwimTrackerInternal
CMSwimTracker
CMSwimData
CLIntersiloProxy
CMOnBodyStatus
CLIntersiloService
CMWakeGestureManager
CLServiceVendorHeartbeatRecord
_Locationd
_CLMainService
CLServiceVendor
CMOnBodyStatusManager
CLNotifierData
CLNotifierClientAdapter
CLNotifierServiceAdapter
CMWorkoutManagerInternal
CMWorkoutManager
@16@0:8
v16@0:8
B16@0:8
v40@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16@?32
v24@0:8@?16
v20@0:8B16
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_source>"
^{CLConnectionClient={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@^{CLConnection}B{CLNameValuePair=^^?^{__CFDictionary}}{CLNameValuePair=^^?^{__CFDictionary}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@?@?@@?@?}
v52@0:8@16d24d32B40@?44
v32@0:8@16@?24
@"CMSedentaryTimer_Internal"
v48@0:8@16@24@32@?40
v48@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16@32@?40
@"NSOperationQueue"
@24@0:8q16
@80@0:8d16q24q32d40d48d56d64@72
@24@0:8@16
@24@0:8^{_NSZone=}16
v24@0:8@16
q16@0:8
@"NSUUID"
v28@0:8{?=fff}16
@28@0:8{?=fff}16
{?="x"f"y"f"z"f}
@36@0:8{?=fff}16d28
{?=ddd}16@0:8
v24@0:8f16f20
@24@0:8f16f20
@32@0:8f16d20f28
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@64@0:8Q16@24@32@40@48@56
@24@0:8r^{CLSignificantElevation=i[16C]ddII}16
Q16@0:8
@"NSDate"
@"NSNumber"
@32@0:8@16@24
@"CMMotionTimeRange"
@"NSString"
q24@0:8q16
@32@0:8@16q24
@40@0:8@16q24d32
d16@0:8
v96@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}iBBB}16
@96@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}iBBB}16
{?="x"d"y"d"z"d}
@"CMAttitude"
@104@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}iBBB}16d96
{?={?=ddd}i}16@0:8
i16@0:8
v48@0:8{?=dddd}16
@48@0:8{?=dddd}16
{?="w"d"x"d"y"d"z"d}
{?=ddddddddd}16@0:8
{?=dddd}16@0:8
v24@0:8{?=ff}16
@24@0:8{?=ff}16
{?="pressure"f"temperature"f}
@32@0:8{?=ff}16d24
{?=dd}16@0:8
@48@0:8^{CMAccel100=fffQ}16Q24d32Q40
v48@0:8^{CMAccel100=fffQ}16Q24d32Q40
Q40@0:8^{?=Q^@^Q[5Q]}16^@24Q32
@24@0:8Q16
@32@0:8d16d24
@"CMSensorRecorderInternal"
@"NSObject<OS_xpc_object>"
@"CLSensorRecorderAccelMeta"
{Unpacker="fData"*"fBitsLeft"I"fPartial"C"fTimestampLast"Q"fTimestampLastDelta"q"fAccelerationLast"[3i]}
@"NSMutableArray"
@"NSArray"
@32@0:8r*16Q24
@32@0:8Q16Q24
v24@0:8d16
@24@0:8d16
@"CMOdometer"
v32@0:8q16@?24
@"<CMOdometerDelegate>"
@"CMOdometerProxy"
@40@0:8d16q24@32
v24@0:8@?<v@?^{CLGyroCalibrationDatabaseRemote=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16
v32@0:8@?16@?24
v32@0:8@?<v@?^{CLGyroCalibrationDatabaseRemote=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16@?<v@?>24
B24@0:8@?16
B24@0:8@?<v@?^{CLGyroCalibrationDatabaseRemote=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}>16
v36@0:8R@16i24@28
v36@0:8R@"<CLNotifierServiceClientProtocol>"16i24@"CLNotifierData"28
v28@0:8R@16i24
v28@0:8R@"<CLNotifierServiceClientProtocol>"16i24
v24@0:8R@16
v24@0:8R@"<CLNotifierServiceClientProtocol>"16
v32@0:8@16@24
v32@0:8@"<CLIntersiloProxyDelegateProtocol>"16@"CLSilo"24
v24@0:8^v16
@"CLSilo"16@0:8
v24@0:8@"NSMutableArray"16
v32@0:8@"CLSilo"16@?<v@?>24
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8@"Protocol"16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
@"NSString"16@0:8
v28@0:8i16@20
v28@0:8i16@"CLNotifierData"20
^{CLGyroCalibrationDatabaseRemote=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB}16@0:8
@40@0:8d16d24d32
@48@0:8d16q24d32d40
@56@0:8d16q24d32d40q48
@44@0:8d16d24q32B40
@"CMExerciseMinuteData"
@"CMExerciseMinuteInternal"
@"<CMLiftManagerDelegate>"
^{Dispatcher=^^?@}
^{CMLiftDetector={CLRunningVector3d<float>=^^?Q{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}}{CLRunningVector3d<float>=^^?Q{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}}{CLRunningVector3d<float>=^^?Q{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}{CLRunningBufferStats<float>=^^?Qff{deque<float, std::__1::allocator<float> >={__split_buffer<float *, std::__1::allocator<float *> >=^^f^^f^^f{__compressed_pair<float **, std::__1::allocator<float *> >=^^f}}Q{__compressed_pair<unsigned long, std::__1::allocator<float> >=Q}}}}Bi}
@"CMLiftManager"
@"CMLiftManagerInternal"
B32@0:8@16^@24
B24@0:8^@16
@40@0:8Q16@24d32
Q24@0:8q16
B24@0:8q16
@"CMNatalimeterInternal"
v24@0:8Q16
v40@0:8Q16@24@?32
@64@0:8Q16@24@32@40Q48Q56
@72@0:8{CLMotionActivity=iiiiBfdBidd}16
{CLMotionActivity=iiiiBfdBidd}16@0:8
{CLMotionActivity="type"i"confidence"i"mountedState"i"mountedConfidence"i"isStanding"B"tilt"f"timestamp"d"isVehicleConnected"B"exitState"i"estExitTime"d"startTime"d}
@20@0:8i16
@?16@0:8
v28@0:8B16q20
@"NSObject<OS_dispatch_semaphore>"
q28@0:8B16q20
v40@0:8@16@24@?32
@"CMPedometerProxy"
v24@0:8@?<v@?^{CLCompassDatabaseClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}>16
v32@0:8@?<v@?^{CLCompassDatabaseClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}>16@?<v@?>24
B24@0:8@?<v@?^{CLCompassDatabaseClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}>16
^{CLCompassDatabaseClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB{BasicMutex=^^?^{MutexInfo}}i}16@0:8
v24@0:8^{value_ostream=B^{ostream}}16
v52@0:8@16{?=i}24@28@?36@?44
v24@0:8@?<v@?^{CLGeomagneticModelProviderClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB^{CLConnectionClient}@}>16
v32@0:8@?<v@?^{CLGeomagneticModelProviderClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB^{CLConnectionClient}@}>16@?<v@?>24
B24@0:8@?<v@?^{CLGeomagneticModelProviderClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB^{CLConnectionClient}@}>16
^{CLGeomagneticModelProviderClient=^^?{BasicMutex=^^?^{MutexInfo}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::Notification>, std::__1::less<int>, true> >=Q}}}{map<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications, std::__1::less<int>, std::__1::allocator<std::__1::pair<const int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >={__tree<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true>, std::__1::allocator<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications> > >=^{__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<int, std::__1::__value_type<int, CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData, char, char>::ClientNotifications>, std::__1::less<int>, true> >=Q}}}iB^{CLConnectionClient}@}16@0:8
@56@0:8@16@24@32@40@48
I16@0:8
v20@0:8I16
@124@0:8d16d24i32d36@44@52q60@68@76@84@92@100@108i116i120
@28@0:8i16d20
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
{Sample="timestamp"d"orientation"i}
v20@0:8i16
v24@0:8r^{Sample=di}16
@32@0:8@16@?24
v32@0:8q16@24
q20@0:8i16
v32@0:8@16Q24
v40@0:8@16d24@?32
v48@0:8@16d24d32@?40
@"<CMPocketStateDelegate>"
@32@0:8d16Q24
v40@0:8d16d24d32
v32@0:8d16d24
@"CMCatherineFeederInternal"
@32@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16
B56@0:8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16^{CLConnectionClient={basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@@@^{CLConnection}B{CLNameValuePair=^^?^{__CFDictionary}}{CLNameValuePair=^^?^{__CFDictionary}}{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}@?@?@@?@?}32d40@?48
B24@0:8r*16
@"NSMutableDictionary"
@44@0:8I16d20@28@?36
@44@0:8I16d20^{__CFRunLoop=}28@?36
^{__CFRunLoop=}
v40@0:8@16q24@?32
@"CMStepCounterProxy"
@112@0:8{?={?=dddd}{?=fff}{?=fff}{?=fff}{?=fff}Q}16@104
f16@0:8
v32@0:8d16@?24
@"CLTimer"16@0:8
v24@0:8@"CLTimer"16
@"CLTimer"
@"CLSilo"
@"<CLTimerScheduler>"
:16@0:8
@"NSMethodSignature"
{map<SEL *, CLIntersiloInterfaceSelectorInfo *, std::__1::less<SEL *>, std::__1::allocator<std::__1::pair<SEL *const, CLIntersiloInterfaceSelectorInfo *> > >="__tree_"{__tree<std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, std::__1::__map_value_compare<SEL *, std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, std::__1::less<SEL *>, true>, std::__1::allocator<std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *> > >="__begin_node_"^{__tree_node<std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, void *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, void *> > >="__first_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<SEL *, std::__1::__value_type<SEL *, CLIntersiloInterfaceSelectorInfo *>, std::__1::less<SEL *>, true> >="__first_"Q}}}
@"Protocol"
{Sample="timestamp"d"pressureData"{?="pressure"f"temperature"f}}
{deque<float, std::__1::allocator<float> >="__map_"{__split_buffer<float *, std::__1::allocator<float *> >="__first_"^^f"__begin_"^^f"__end_"^^f"__end_cap_"{__compressed_pair<float **, std::__1::allocator<float *> >="__first_"^^f}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::__1::allocator<float> >="__first_"Q}}
v24@0:8r^{Sample=d{?=ff}}16
@"CMAltimeterInternal"
@"CMSwimData"
@"CMSwimTrackerInternal"
v24@0:8^{CLSwimEntry=Q[16C][16C]ddddddiiiifff}16
@96@0:8Q16@24@32@40@48Q56d64d72Q80q88
@24@0:8r^{CLSwimEntry=Q[16C][16C]ddddddiiiifff}16
@48@0:8@16@24@32@40
@40@0:8@16@24@32
@"CLIntersiloProxy"
@"CLIntersiloInterfaceSelectorInfo"
@"<CLIntersiloProxyDelegateProtocol>"
@"CLIntersiloInterface"
@32@0:8i16i20d24
B32@0:8d16d24
@"<CMWakeGestureDelegate>"
@"<CLIntersiloServiceProtocol>"
B40@0:8^#16^@24@32
@32@0:8^v16@?24
^v16@0:8
@24@0:8^{CLNotifierClientBase=^^?}16
^{CLNotifierClientBase=^^?}
v24@0:8^{CLNotifierBase=^^?}16
i24@0:8@16
^{CLNotifierBase=^^?}16@0:8
{map<unsigned long, int, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, int> > >="__tree_"{__tree<std::__1::__value_type<unsigned long, int>, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, int>, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long, int> > >="__begin_node_"^{__tree_node<std::__1::__value_type<unsigned long, int>, void *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long, int>, void *> > >="__first_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, std::__1::__value_type<unsigned long, int>, std::__1::less<unsigned long>, true> >="__first_"Q}}}
^{CLNotifierBase=^^?}
@"<CMWorkoutManagerDelegate>"
@"CMWorkoutManager"
@"CMWorkout"
@"CMWorkoutManagerInternal"
non-matching retain (%p) and release (%p) functions in context, ignoring
Failed to initilize fHeadingCalibrationDisplayMutex, error code: %{public}d
CLClient is deprecated. Will be obsolete soon.
Location manager created on a dispatch queue exectuing on non-main thread, notifying client
#warning Could not register with daemon immediately, will retry later
Discarding message for event %{private}d because of too many unprocessed messages
Location callback block not executed in a timely manner!
received client will resign active notification
received client did become active notification
Registration timer expired, but client is still registering!
Missing UsageDescription key for requsted authorization: %{public}d
CLInternalGetLocationServicesEnabled failed: could not reach daemon
Fence: CLClientRequestRegionState, unsupported fence type
Function deprecated
Invalid call to CLClientGetAutopauseState
malformed message: kCLConnectionMessageAutopauseStatus
function deprecated - noop
Got unhandled message %s from daemon
There is no UsageDescriptionKey for this AuthorizationStatus
failed, invalid filename
failedToOpen, errno, %d
failed,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d,errno,%d
done,fd,%d,origProtectionClass,%d,newProtectionClass,%d,ret,%d
Default handler received message %s
Could not get dictionary for message
Message does not contain a valid gyro bias object
unable to create fPrivateQueue
Sent kCLConnectionMessageWatchdog message
unknown hardware type %{private}d
device SN date info type:%{private}zd - date:%{private}d %{private}d %{private}f
Invalid year/week code
Failed to allocate CFCalendar
CFCalendarComposeAbsoluteTime() failed
Cannot get weekday
Cannot get week
Invalid serial number format: %{private}s
CAMP: device id [%d] [%s], camping support [%d]
#warning SUPL: ignoring hw. forceSuplSupport,%d
#warning LPP: ignoring hw. forceLppSupport,%d
#warning Overriding BeaconFenceBestEffortAlways,%d
zoneBestEffortAlwaysEnabled,%d
#warning GNSSRF: overriding peak antenna gain, %d tenth-dB
GNSSRF: no config for %d
GNSSRF: peakAntennaGain,%d,gpsLoss,%d,gloLoss_0,%d,gloLoss_minus7,%d,gloLoss_plus6,%d
PLOS: ignoring hw. forceSupport,%d
#warning OBM, ignoring hw. forceSupport,%d
pool length %f for workout is too small and may lead to undefined behavior.
CMOdometer client connection interrupt, %@, %d, %p
successfully got GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
Warning: can't get GyroBiasFit from CLGyroCalibrationDatabaseGetBiasFitAtTemperature()
Could not create event system client. All bets are off
Event system client initialized successfully
Trying to set properties for unknown event %d
Unknown event %d
Could not convert NSString to C++ string
Device ID not supported for event %d
Physical device ID cannot be nil. Unable to set property for event %d
setEventPropertyForDevice has invalid property %p or device id %s
Unknown event: %d
Unknown event %u
%s hid driver interface for event %u, hidServiceRef %p
Service with event type %d is not ready
IOHIDEventType event %d is unavailable
Unknown device: %s for event: %d
IOHIDEventSystemClientCopyServices() returned NULL
Service ref with usage pair {%d,%d} (physicalDeviceUniqueID %s) (registryID %llu) (event %d) is %p
IOHIDServiceClientSetProperty() returned false
IOHIDServiceClientSetProperty() successfully set property for event %d
IOHIDServiceClientSetProperty() successfully set property for event %d and device %s
Property for usage pair {%d,%d}: {%s = %p} was set %s
Property for usage pair {%d,%d} and physical device {%s}: {%s = %p} was set %s
Could not set all properties. Setting timer to fire %f seconds from now
Could not set all properties after too many retries. Giving up.
Properties for event %d:
Properties for event %d and physical device %s:
Removing set matching multiple
Adding touch event,hidUsagePage,%d
Adding match entry for usage pair {%d,%d}
Setting matching multiple
Event %u does not support physical device ID
Device information cannot be found for event %i with sender id %llu
Unhandled usage %d
Received null sender
It looks like our HID event system just become available (again)
New IOHIDServiceClientRef for usage pair {%d,%d} just became available.
Event type %d, device %s, old hidserviceref,%p,new,%p
Registering new device %s, hidserviceref %p, registryid %llu
Device unique id expected for event type %d, hidserviceref %p
Event type %d, old hidserviceref,%p,new,%p
Releasing value for property %s, address = %p
CMExerciseMinute client connection interrupt, %@, %d, %d, %p
Unknown notification %d
Requested update interval cannot be == 0.0 and dispatcher cannot be NULL. Use interval < 0.0 for spectator.
CLMotionNotifier::addDispatcherPrivate UpdateInterval is zero!
CLMotionNotifier::addDispatcherPrivate Added dispatcher for notification:%d, Update Interval:%f(%.1fHz)
Unknown (notification,dispatcher) pair: (%d, %p)
CLMotionNotifier::setUpdateIntervalPrivate RequestedUpdateInterval:%f, UpdateInterval:%f
CLMotionNotifier::updateSamplePeriod UpdateInterval:%f
Physical device ID cannot be nil.  Unable to configure device motion lite.
Could not subscribe to system power notifications
enabled detection successfully
Device Stationary?, %s, Orientation, %s, Proximity, %s
Transition, From: %s, To: %s, %s
%f: Device Stationary?, %s, Orientation, %s, Proximity, %s, State, %s
disable Detection
%f: monitorTime, %f, bksMonitorTime, %f, bksDelay, %f, proxStatus, %s
%f: ProxDelay,%f
Proximity detection mask: %u, Last prox state: %s
received WillSleep
received WillPowerOn
received HasPoweredOn
CMNatalimeter client connection interrupt, %@, %d, %p
%@, pid, %d, CMNatalimeter query since record, %@, %p
%@, pid, %d, CMNatalimeter update, %@, %p
Failed parse os_log format specifier for shimming:missing closing brace,format,%{public}s
CMPedometer client connection interrupt, %@, %d, %p
Begin.
Too few points.  End.
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,1
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,0
End.
Motion manager asked to start device motion lite updates for device id %@
Physical device ID cannot be nil.  Unable to start updates.
Motion manager asked to stop device motion lite updates for device id %@
Physical device ID cannot be nil.  Unable to stop updates.
Unable to load CompassUI framework
Could not load CUICalibrationClass from CompassUI framework
Orientation Manager initialized
OrientationCallbackMode,%d,EnableOrientationNotification,%d
The orientation %d is not in bounds
Starting orientation updates
Stopping orientation updates
Notifications disabled
Received orientation. (%d to %d) Timestamp %f
Updating client handler: Orientation %d, Callback mode: %d
Received deviceOrientationBlocking
Waiting for the first orientation to come in
Orientation blocking: timeout exceeded!
Got latest sample: %d @ %f
No viable convertion for mode 0x%x
No viable convertion for notification 0x%x
CLDeviceMotion::setDeviceMotionUpdateInterval changing update interval to: %f
CLDeviceMotion::addDeviceMotionDispatcher adding dispatcher with property: %s
CLDeviceMotion::removeDeviceMotionDispatcher removing dispatcher with property: %s
CLDeviceMotion::minimumUpdateIntervalChanged,notification,%d,minimumUpdateInterval,%f
CLDeviceMotion::numberOfClientsChanged notification:%d, from:%zu, to:%zu
numberOfClients GyroOnly:%zd, 3AxisDynamicGyro:%zd, 6Axis:%zd, 6AxisThrottledGyro:%zd, 9Axis:%zd, 9AxisWithNorthReference:%zd, BuildGYTT:%zd
Device motion mode not supported: %d
Unsupported mode (%d). Returning.
Unsupported mode (%d). Compass not found. Returning.
Unsupported mode (%d). Couldn't do DeviceMotion without Gyro. Returning.
Starting device motion, mode=0x%x,useAccelerometer=%d,useGyro=%d,useCompass=%d,fUseNorthRef=%d,buildingGYTT=%d
Stopping device motion, mode=0x%x
Pocket state disabled by defaults write
disabling dispatcher
ADClient: %s + %llu
QueryRequest,%f
%f: query started with timeout %f
Query aborted
QueryTimerFire,%f
%f: query response external=%u (%s), cbcount=%lu
timer fired even though fQueryTimer is NULL
Attempted to exceed max monitor time %f, %f
Query timer failed to initialize
The pocket state %d is not in bounds
Registering for SBHasSeenACaseLatchCoverNotification.
Unrecognized notification
hwType, %d
Unknown iPad HW %d
isPad %d
forceAccelOnly for device %d
fOrientationGyroTimeout,%f,fEnableGyroTimeout,%d,fMaxAccelerationVarianceForStability,%f
Not starting orientation detection since requested accelerometer frequency < 0
No accelerometer; not detecting orientation!
No gyro; not detecting orientation!
fHasSeenACaseLatchCoverOnce, %d
Starting orientation detection with accelFrequency %f, isIpad, %d, decimationRate, %d
Stopping orientation detection.
Sending orientation changed notification
Device is in motion, re-enabling Gyro.
Device is stationary and OrientationGyroTimeout exceeded, disabling Gyro.
GYRO: Sending orientation changed notification
gyroFrequency,%.3f,gyroBufferSize,%d,gyroMeanBufferSize,%d,zRotBufferSize,%d,minRequiredZrots,%d
accelBufferSize,%d
fMinVarPerAxisForMoving,%.3f,fMinDeltaSquaredMagnitudeForMoving,%.3f,fMinVarPerAxisForMovingRelaxed,%.3f
Accelerometer samples data gap or out of order! deltaInterval=%.4f
accel, %.3f, %.3f, %.3f, timestamp, %.20f
Gyro samples data gap or out of order! deltaInterval=%.4f
gyro, %.3f, %.3f, %.3f, gyroMean, %.3f, %.3f, %.3f, fLastDetection,%d,fStartZrot,%d
gyro, %.3f, %.3f, %.3f, timestamp, %.20f
zRot (%.3f, %.3f, %.3f), mean(%.3f, %.3f, %.3f), var(%.3f, %.3f, %.3f)
mostlyZ, %d, zRotMean.z, %.3f, zRot, %.3f, numSamples, %d, numZRots, %d, estCurr, %.3f
Slowing decrement numZRot,delta, %.3f, numZRot, %d
ZDROP detected. deltaDrop, %.3f, fNumZDrops, %d
TRANSIENT!
Going through with 180 turn.
Rotating around Z. numSamples: %d, numAccu, %d, zRotVar, %.3f
SCREEN FLAT. NOT FILLING UP ZROT BUFFER.
EST Z ANGLE, %.2f, numAccu, %d
Transient!
Rotating! Current max gyro rate %.3f
Setting lastPrimaryOrientation.
Nixed rotationAroundZ state.
Ready for orientation change via rotation
Gyro var, %.3f, %.3f,%.3f, maxGyroVar, %.3f, mean, %.3f, %.3f, %.3f
gyroMeanMag %.3f
Not filling Zrot buffer.
acc variance, %.3f, %.3f, %.3f, acc mean, %.3f, %.3f, %.3f, maxVar, %.3f, mag2,%.3f
Resetting stable count
Within magic angle limits: Threshold %.4f, Delta %.4f
Ipad %d: screenJustTurnedOn, %d, deltaTime %.5f
allowShallow, %d, magicCaseRest, %d, tiltIn, %d, wasMoving, %d, maxVar, %.5f
onStartup, x, %.3f, y, %.3f, z, %.3f
FaceUp/Down: maxWeight,%.3f, 2ndWeight,%.3f, orientation,%d
deltaWeightThreshold, %.3f, tiltWeightTheshold, %.3f, currAcc, %.3f, %.3f, %.3f, deltaWeight, %.3f, tilt, %.3f, fCurrentOrientation, %d, isMoving, %d, wasMoving, %d, fLastClearOrientation, %d, fStableCount, %d, fLastDetectionTime, %f
Notify from, %s -> %s 
Disabling gyro.
Enabling gyro.
Warning: Not implemented.
Warning - invoking %@ on main may lead to deadlock.
Starting device motion service 0x%x
Stopping device motion service 0x%x
Set device motion sensor status %ld
CMSwimTracker client connection interrupt, %@, %d, %d, %p
Watch: Gesture Manager Active
Phone: Gesture Manager Active
CMWakeGestureManager is not supported on this platform!
Calling methods directly on an instance of CMWakeGestureManager is not permitted. Please use +[CMWakeGestureManager sharedManager] instead.
{"msg":"Heartbeat tracking requested", "silo":"%{public}@"}
{"msg":"Heartbeat tracking terminated", "silo":"%{public}@"}
{"msg":"Heartbeat underflow; going to crash now!", "silo":"%{public}@"}
{"msg":"#warning Heartbeat underflow", "silo":"%{public}@", "deficit":"%{public}d"}
{"msg":"Heartbeat tracking already enabled", "interval":"%{public}f"}
{"msg":"Heartbeat tracking resumed", "interval":"%{public}f"}
{"msg":"Heartbeat tracking suspended", }
{"msg":"Heartbeat tracking already disabled", }
Tried to look up a service by name that doesn't exist: %{public}@.
numberOfSpectators,%zi
Undecodable data.,size,%zu,type,%u
%s is enabling power conservative device motion for parallax.
%s is disabling power conservation for parallax.
Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.
CMWorkoutManager client connection interrupt, %@, %d, %d, %p
Starting workout, %@, %d, %p, %ld
starting swim workout, location, %ld, pool length %f
Trying to start a swim session without using a CMSwimWorkout!  Treating this swim as an open water swim.
Stopping workout, %@, %d, %p, %ld
nil workout event dictionary received, %s
Workout ERROR, %d, %s
Workout DID START at %f, %s
Workout DID STOP at %f, %s
Workout WILL PAUSE at %f, %s
Workout WILL RESUME at %f, %s
Unrecognized workout event, %ld, %s
Unrecognizable workout event dictionary, %s
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
